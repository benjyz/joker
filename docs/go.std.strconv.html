<html>
<head>
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
  <div class="main">
    <h1>Namespace: go.std.strconv</h1>
    <span class="var-added">v1.0</span>
    <p class="var-docstr">Provides a low-level interface to the strconv package.<br>
<br>
Package strconv implements conversions to and from string representations<br>
of basic data types.<br>
<br>
Numeric Conversions<br>
<br>
The most common numeric conversions are Atoi (string to int) and Itoa (int to string).<br>
<br>
	i, err := strconv.Atoi(&#34;-42&#34;)<br>
	s := strconv.Itoa(-42)<br>
<br>
These assume decimal and the Go int type.<br>
<br>
ParseBool, ParseFloat, ParseInt, and ParseUint convert strings to values:<br>
<br>
	b, err := strconv.ParseBool(&#34;true&#34;)<br>
	f, err := strconv.ParseFloat(&#34;3.1415&#34;, 64)<br>
	i, err := strconv.ParseInt(&#34;-42&#34;, 10, 64)<br>
	u, err := strconv.ParseUint(&#34;42&#34;, 10, 64)<br>
<br>
The parse functions return the widest type (float64, int64, and uint64),<br>
but if the size argument specifies a narrower width the result can be<br>
converted to that narrower type without data loss:<br>
<br>
	s := &#34;2147483647&#34; // biggest int32<br>
	i64, err := strconv.ParseInt(s, 10, 32)<br>
	...<br>
	i := int32(i64)<br>
<br>
FormatBool, FormatFloat, FormatInt, and FormatUint convert values to strings:<br>
<br>
	s := strconv.FormatBool(true)<br>
	s := strconv.FormatFloat(3.1415, &#39;E&#39;, -1, 64)<br>
	s := strconv.FormatInt(-42, 16)<br>
	s := strconv.FormatUint(42, 16)<br>
<br>
AppendBool, AppendFloat, AppendInt, and AppendUint are similar but<br>
append the formatted value to a destination slice.<br>
<br>
String Conversions<br>
<br>
Quote and QuoteToASCII convert strings to quoted Go string literals.<br>
The latter guarantees that the result is an ASCII string, by escaping<br>
any non-ASCII Unicode with \u:<br>
<br>
	q := strconv.Quote(&#34;Hello, 世界&#34;)<br>
	q := strconv.QuoteToASCII(&#34;Hello, 世界&#34;)<br>
<br>
QuoteRune and QuoteRuneToASCII are similar but accept runes and<br>
return quoted Go rune literals.<br>
<br>
Unquote and UnquoteChar unquote Go string and rune literals.<br>
</p>
    <h2>Index</h2>
    <ul class="index">
      <li>
  <a href="#Atoi">Atoi</a>
</li>
<li>
  <a href="#CanBackquote">CanBackquote</a>
</li>
<li>
  <a href="#ErrRange">ErrRange</a>
</li>
<li>
  <a href="#ErrSyntax">ErrSyntax</a>
</li>
<li>
  <a href="#FormatBool">FormatBool</a>
</li>
<li>
  <a href="#FormatInt">FormatInt</a>
</li>
<li>
  <a href="#FormatUint">FormatUint</a>
</li>
<li>
  <a href="#IntSize">IntSize</a>
</li>
<li>
  <a href="#IsGraphic">IsGraphic</a>
</li>
<li>
  <a href="#IsPrint">IsPrint</a>
</li>
<li>
  <a href="#Itoa">Itoa</a>
</li>
<li>
  <a href="#NumError.">NumError.</a>
</li>
<li>
  <a href="#ParseBool">ParseBool</a>
</li>
<li>
  <a href="#ParseInt">ParseInt</a>
</li>
<li>
  <a href="#ParseUint">ParseUint</a>
</li>
<li>
  <a href="#Quote">Quote</a>
</li>
<li>
  <a href="#QuoteRune">QuoteRune</a>
</li>
<li>
  <a href="#QuoteRuneToASCII">QuoteRuneToASCII</a>
</li>
<li>
  <a href="#QuoteRuneToGraphic">QuoteRuneToGraphic</a>
</li>
<li>
  <a href="#QuoteToASCII">QuoteToASCII</a>
</li>
<li>
  <a href="#QuoteToGraphic">QuoteToGraphic</a>
</li>
<li>
  <a href="#Unquote">Unquote</a>
</li>
<li>
  <a href="#UnquoteChar">UnquoteChar</a>
</li>

    </ul>
    <ul>
      <li>
  <h3 id="Atoi">Atoi</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Atoi __s)</code></div>
</pre>
  <p class="var-docstr">Atoi is equivalent to ParseInt(s, 10, 0), converted to type int.<br>
<br>
Go input arguments: (s string)<br>
<br>
Go return type: (int, error)<br>
<br>
Joker input arguments: [^String s]<br>
<br>
Joker return type: [Int Error]</p>
  
</li>
<li>
  <h3 id="CanBackquote">CanBackquote</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(CanBackquote __s)</code></div>
</pre>
  <p class="var-docstr">CanBackquote reports whether the string s can be represented<br>
unchanged as a single-line backquoted string without control<br>
characters other than tab.<br>
<br>
Go input arguments: (s string)<br>
<br>
Go return type: bool<br>
<br>
Joker input arguments: [^String s]<br>
<br>
Joker return type: Boolean</p>
  
</li>
<li>
  <h3 id="ErrRange">ErrRange</h3>
  <span class="var-type GoVar[*.error]">GoVar[*.error]</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">ErrRange indicates that a value is out of range for the target type.<br>
</p>
  
</li>
<li>
  <h3 id="ErrSyntax">ErrSyntax</h3>
  <span class="var-type GoVar[*.error]">GoVar[*.error]</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">ErrSyntax indicates that a value does not have the right syntax for the target type.<br>
</p>
  
</li>
<li>
  <h3 id="FormatBool">FormatBool</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(FormatBool __b)</code></div>
</pre>
  <p class="var-docstr">FormatBool returns &#34;true&#34; or &#34;false&#34; according to the value of b.<br>
<br>
Go input arguments: (b bool)<br>
<br>
Go return type: string<br>
<br>
Joker input arguments: [^Boolean b]<br>
<br>
Joker return type: String</p>
  
</li>
<li>
  <h3 id="FormatInt">FormatInt</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(FormatInt __i __base)</code></div>
</pre>
  <p class="var-docstr">FormatInt returns the string representation of i in the given base,<br>
for 2 &lt;= base &lt;= 36. The result uses the lower-case letters &#39;a&#39; to &#39;z&#39;<br>
for digit values &gt;= 10.<br>
<br>
Go input arguments: (i int64, base int)<br>
<br>
Go return type: string<br>
<br>
Joker input arguments: [^Number i, ^Int base]<br>
<br>
Joker return type: String</p>
  
</li>
<li>
  <h3 id="FormatUint">FormatUint</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(FormatUint __i __base)</code></div>
</pre>
  <p class="var-docstr">FormatUint returns the string representation of i in the given base,<br>
for 2 &lt;= base &lt;= 36. The result uses the lower-case letters &#39;a&#39; to &#39;z&#39;<br>
for digit values &gt;= 10.<br>
<br>
Go input arguments: (i uint64, base int)<br>
<br>
Go return type: string<br>
<br>
Joker input arguments: [^Number i, ^Int base]<br>
<br>
Joker return type: String</p>
  
</li>
<li>
  <h3 id="IntSize">IntSize</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">IntSize is the size in bits of an int or uint value.<br>
</p>
  
</li>
<li>
  <h3 id="IsGraphic">IsGraphic</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(IsGraphic __r)</code></div>
</pre>
  <p class="var-docstr">IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such<br>
characters include letters, marks, numbers, punctuation, symbols, and<br>
spaces, from categories L, M, N, P, S, and Zs.<br>
<br>
Go input arguments: (r rune)<br>
<br>
Go return type: bool<br>
<br>
Joker input arguments: [^Char r]<br>
<br>
Joker return type: Boolean</p>
  
</li>
<li>
  <h3 id="IsPrint">IsPrint</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(IsPrint __r)</code></div>
</pre>
  <p class="var-docstr">IsPrint reports whether the rune is defined as printable by Go, with<br>
the same definition as unicode.IsPrint: letters, numbers, punctuation,<br>
symbols and ASCII space.<br>
<br>
Go input arguments: (r rune)<br>
<br>
Go return type: bool<br>
<br>
Joker input arguments: [^Char r]<br>
<br>
Joker return type: Boolean</p>
  
</li>
<li>
  <h3 id="Itoa">Itoa</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Itoa __i)</code></div>
</pre>
  <p class="var-docstr">Itoa is equivalent to FormatInt(int64(i), 10).<br>
<br>
Go input arguments: (i int)<br>
<br>
Go return type: string<br>
<br>
Joker input arguments: [^Int i]<br>
<br>
Joker return type: String</p>
  
</li>
<li>
  <h3 id="NumError.">NumError.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(NumError. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for strconv.NumError</p>
  
</li>
<li>
  <h3 id="ParseBool">ParseBool</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ParseBool __str)</code></div>
</pre>
  <p class="var-docstr">ParseBool returns the boolean value represented by the string.<br>
It accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False.<br>
Any other value returns an error.<br>
<br>
Go input arguments: (str string)<br>
<br>
Go return type: (bool, error)<br>
<br>
Joker input arguments: [^String str]<br>
<br>
Joker return type: [Boolean Error]</p>
  
</li>
<li>
  <h3 id="ParseInt">ParseInt</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ParseInt __s __base __bitSize)</code></div>
</pre>
  <p class="var-docstr">ParseInt interprets a string s in the given base (0, 2 to 36) and<br>
bit size (0 to 64) and returns the corresponding value i.<br>
<br>
If base == 0, the base is implied by the string&#39;s prefix:<br>
base 16 for &#34;0x&#34;, base 8 for &#34;0&#34;, and base 10 otherwise.<br>
For bases 1, below 0 or above 36 an error is returned.<br>
<br>
The bitSize argument specifies the integer type<br>
that the result must fit into. Bit sizes 0, 8, 16, 32, and 64<br>
correspond to int, int8, int16, int32, and int64.<br>
For a bitSize below 0 or above 64 an error is returned.<br>
<br>
The errors that ParseInt returns have concrete type *NumError<br>
and include err.Num = s. If s is empty or contains invalid<br>
digits, err.Err = ErrSyntax and the returned value is 0;<br>
if the value corresponding to s cannot be represented by a<br>
signed integer of the given size, err.Err = ErrRange and the<br>
returned value is the maximum magnitude integer of the<br>
appropriate bitSize and sign.<br>
<br>
Go input arguments: (s string, base int, bitSize int)<br>
<br>
Go return type: (i int64, err error)<br>
<br>
Joker input arguments: [^String s, ^Int base, ^Int bitSize]<br>
<br>
Joker return type: [Number Error]</p>
  
</li>
<li>
  <h3 id="ParseUint">ParseUint</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ParseUint __s __base __bitSize)</code></div>
</pre>
  <p class="var-docstr">ParseUint is like ParseInt but for unsigned numbers.<br>
<br>
Go input arguments: (s string, base int, bitSize int)<br>
<br>
Go return type: (uint64, error)<br>
<br>
Joker input arguments: [^String s, ^Int base, ^Int bitSize]<br>
<br>
Joker return type: [Number Error]</p>
  
</li>
<li>
  <h3 id="Quote">Quote</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Quote __s)</code></div>
</pre>
  <p class="var-docstr">Quote returns a double-quoted Go string literal representing s. The<br>
returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for<br>
control characters and non-printable characters as defined by<br>
IsPrint.<br>
<br>
Go input arguments: (s string)<br>
<br>
Go return type: string<br>
<br>
Joker input arguments: [^String s]<br>
<br>
Joker return type: String</p>
  
</li>
<li>
  <h3 id="QuoteRune">QuoteRune</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(QuoteRune __r)</code></div>
</pre>
  <p class="var-docstr">QuoteRune returns a single-quoted Go character literal representing the<br>
rune. The returned string uses Go escape sequences (\t, \n, \xFF, \u0100)<br>
for control characters and non-printable characters as defined by IsPrint.<br>
<br>
Go input arguments: (r rune)<br>
<br>
Go return type: string<br>
<br>
Joker input arguments: [^Char r]<br>
<br>
Joker return type: String</p>
  
</li>
<li>
  <h3 id="QuoteRuneToASCII">QuoteRuneToASCII</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(QuoteRuneToASCII __r)</code></div>
</pre>
  <p class="var-docstr">QuoteRuneToASCII returns a single-quoted Go character literal representing<br>
the rune. The returned string uses Go escape sequences (\t, \n, \xFF,<br>
\u0100) for non-ASCII characters and non-printable characters as defined<br>
by IsPrint.<br>
<br>
Go input arguments: (r rune)<br>
<br>
Go return type: string<br>
<br>
Joker input arguments: [^Char r]<br>
<br>
Joker return type: String</p>
  
</li>
<li>
  <h3 id="QuoteRuneToGraphic">QuoteRuneToGraphic</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(QuoteRuneToGraphic __r)</code></div>
</pre>
  <p class="var-docstr">QuoteRuneToGraphic returns a single-quoted Go character literal representing<br>
the rune. The returned string uses Go escape sequences (\t, \n, \xFF,<br>
\u0100) for non-ASCII characters and non-printable characters as defined<br>
by IsGraphic.<br>
<br>
Go input arguments: (r rune)<br>
<br>
Go return type: string<br>
<br>
Joker input arguments: [^Char r]<br>
<br>
Joker return type: String</p>
  
</li>
<li>
  <h3 id="QuoteToASCII">QuoteToASCII</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(QuoteToASCII __s)</code></div>
</pre>
  <p class="var-docstr">QuoteToASCII returns a double-quoted Go string literal representing s.<br>
The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for<br>
non-ASCII characters and non-printable characters as defined by IsPrint.<br>
<br>
Go input arguments: (s string)<br>
<br>
Go return type: string<br>
<br>
Joker input arguments: [^String s]<br>
<br>
Joker return type: String</p>
  
</li>
<li>
  <h3 id="QuoteToGraphic">QuoteToGraphic</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(QuoteToGraphic __s)</code></div>
</pre>
  <p class="var-docstr">QuoteToGraphic returns a double-quoted Go string literal representing s.<br>
The returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for<br>
non-ASCII characters and non-printable characters as defined by IsGraphic.<br>
<br>
Go input arguments: (s string)<br>
<br>
Go return type: string<br>
<br>
Joker input arguments: [^String s]<br>
<br>
Joker return type: String</p>
  
</li>
<li>
  <h3 id="Unquote">Unquote</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Unquote __s)</code></div>
</pre>
  <p class="var-docstr">Unquote interprets s as a single-quoted, double-quoted,<br>
or backquoted Go string literal, returning the string value<br>
that s quotes.  (If s is single-quoted, it would be a Go<br>
character literal; Unquote returns the corresponding<br>
one-character string.)<br>
<br>
Go input arguments: (s string)<br>
<br>
Go return type: (string, error)<br>
<br>
Joker input arguments: [^String s]<br>
<br>
Joker return type: [String Error]</p>
  
</li>
<li>
  <h3 id="UnquoteChar">UnquoteChar</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(UnquoteChar __s __quote)</code></div>
</pre>
  <p class="var-docstr">UnquoteChar decodes the first character or byte in the escaped string<br>
or character literal represented by the string s.<br>
It returns four values:<br>
<br>
	1) value, the decoded Unicode code point or byte value;<br>
	2) multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;<br>
	3) tail, the remainder of the string after the character; and<br>
	4) an error that will be nil if the character is syntactically valid.<br>
<br>
The second argument, quote, specifies the type of literal being parsed<br>
and therefore which escaped quote character is permitted.<br>
If set to a single quote, it permits the sequence \&#39; and disallows unescaped &#39;.<br>
If set to a double quote, it permits \&#34; and disallows unescaped &#34;.<br>
If set to zero, it does not permit either escape and allows both quote characters to appear unescaped.<br>
<br>
Go input arguments: (s string, quote byte)<br>
<br>
Go return type: (value rune, multibyte bool, tail string, err error)<br>
<br>
Joker input arguments: [^String s, ^Int quote]<br>
<br>
Joker return type: [Char Boolean String Error]</p>
  
</li>

    </ul>
  </div>
</body>
</html>
