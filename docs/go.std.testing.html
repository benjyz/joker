<html>
<head>
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
  <div class="main">
    <h1>Namespace: go.std.testing</h1>
    <span class="var-added">v1.0</span>
    <p class="var-docstr">Provides a low-level interface to the testing package.<br>
<br>
Package testing provides support for automated testing of Go packages.<br>
It is intended to be used in concert with the ``go test&#39;&#39; command, which automates<br>
execution of any function of the form<br>
    func TestXxx(*testing.T)<br>
where Xxx does not start with a lowercase letter. The function name<br>
serves to identify the test routine.<br>
<br>
Within these functions, use the Error, Fail or related methods to signal failure.<br>
<br>
To write a new test suite, create a file whose name ends _test.go that<br>
contains the TestXxx functions as described here. Put the file in the same<br>
package as the one being tested. The file will be excluded from regular<br>
package builds but will be included when the ``go test&#39;&#39; command is run.<br>
For more detail, run ``go help test&#39;&#39; and ``go help testflag&#39;&#39;.<br>
<br>
A simple test function looks like this:<br>
<br>
    func TestAbs(t *testing.T) {<br>
        got := Abs(-1)<br>
        if got != 1 {<br>
            t.Errorf(&#34;Abs(-1) = %d; want 1&#34;, got)<br>
        }<br>
    }<br>
<br>
Benchmarks<br>
<br>
Functions of the form<br>
    func BenchmarkXxx(*testing.B)<br>
are considered benchmarks, and are executed by the &#34;go test&#34; command when<br>
its -bench flag is provided. Benchmarks are run sequentially.<br>
<br>
For a description of the testing flags, see<br>
https://golang.org/cmd/go/#hdr-Testing_flags<br>
<br>
A sample benchmark function looks like this:<br>
    func BenchmarkHello(b *testing.B) {<br>
        for i := 0; i &lt; b.N; i++ {<br>
            fmt.Sprintf(&#34;hello&#34;)<br>
        }<br>
    }<br>
<br>
The benchmark function must run the target code b.N times.<br>
During benchmark execution, b.N is adjusted until the benchmark function lasts<br>
long enough to be timed reliably. The output<br>
    BenchmarkHello    10000000    282 ns/op<br>
means that the loop ran 10000000 times at a speed of 282 ns per loop.<br>
<br>
If a benchmark needs some expensive setup before running, the timer<br>
may be reset:<br>
<br>
    func BenchmarkBigLen(b *testing.B) {<br>
        big := NewBig()<br>
        b.ResetTimer()<br>
        for i := 0; i &lt; b.N; i++ {<br>
            big.Len()<br>
        }<br>
    }<br>
<br>
If a benchmark needs to test performance in a parallel setting, it may use<br>
the RunParallel helper function; such benchmarks are intended to be used with<br>
the go test -cpu flag:<br>
<br>
    func BenchmarkTemplateParallel(b *testing.B) {<br>
        templ := template.Must(template.New(&#34;test&#34;).Parse(&#34;Hello, {{.}}!&#34;))<br>
        b.RunParallel(func(pb *testing.PB) {<br>
            var buf bytes.Buffer<br>
            for pb.Next() {<br>
                buf.Reset()<br>
                templ.Execute(&amp;buf, &#34;World&#34;)<br>
            }<br>
        })<br>
    }<br>
<br>
Examples<br>
<br>
The package also runs and verifies example code. Example functions may<br>
include a concluding line comment that begins with &#34;Output:&#34; and is compared with<br>
the standard output of the function when the tests are run. (The comparison<br>
ignores leading and trailing space.) These are examples of an example:<br>
<br>
    func ExampleHello() {<br>
        fmt.Println(&#34;hello&#34;)<br>
        // Output: hello<br>
    }<br>
<br>
    func ExampleSalutations() {<br>
        fmt.Println(&#34;hello, and&#34;)<br>
        fmt.Println(&#34;goodbye&#34;)<br>
        // Output:<br>
        // hello, and<br>
        // goodbye<br>
    }<br>
<br>
The comment prefix &#34;Unordered output:&#34; is like &#34;Output:&#34;, but matches any<br>
line order:<br>
<br>
    func ExamplePerm() {<br>
        for _, value := range Perm(4) {<br>
            fmt.Println(value)<br>
        }<br>
        // Unordered output: 4<br>
        // 2<br>
        // 1<br>
        // 3<br>
        // 0<br>
    }<br>
<br>
Example functions without output comments are compiled but not executed.<br>
<br>
The naming convention to declare examples for the package, a function F, a type T and<br>
method M on type T are:<br>
<br>
    func Example() { ... }<br>
    func ExampleF() { ... }<br>
    func ExampleT() { ... }<br>
    func ExampleT_M() { ... }<br>
<br>
Multiple example functions for a package/type/function/method may be provided by<br>
appending a distinct suffix to the name. The suffix must start with a<br>
lower-case letter.<br>
<br>
    func Example_suffix() { ... }<br>
    func ExampleF_suffix() { ... }<br>
    func ExampleT_suffix() { ... }<br>
    func ExampleT_M_suffix() { ... }<br>
<br>
The entire test file is presented as the example when it contains a single<br>
example function, at least one other function, type, variable, or constant<br>
declaration, and no test or benchmark functions.<br>
<br>
Skipping<br>
<br>
Tests or benchmarks may be skipped at run time with a call to<br>
the Skip method of *T or *B:<br>
<br>
    func TestTimeConsuming(t *testing.T) {<br>
        if testing.Short() {<br>
            t.Skip(&#34;skipping test in short mode.&#34;)<br>
        }<br>
        ...<br>
    }<br>
<br>
Subtests and Sub-benchmarks<br>
<br>
The Run methods of T and B allow defining subtests and sub-benchmarks,<br>
without having to define separate functions for each. This enables uses<br>
like table-driven benchmarks and creating hierarchical tests.<br>
It also provides a way to share common setup and tear-down code:<br>
<br>
    func TestFoo(t *testing.T) {<br>
        // &lt;setup code&gt;<br>
        t.Run(&#34;A=1&#34;, func(t *testing.T) { ... })<br>
        t.Run(&#34;A=2&#34;, func(t *testing.T) { ... })<br>
        t.Run(&#34;B=1&#34;, func(t *testing.T) { ... })<br>
        // &lt;tear-down code&gt;<br>
    }<br>
<br>
Each subtest and sub-benchmark has a unique name: the combination of the name<br>
of the top-level test and the sequence of names passed to Run, separated by<br>
slashes, with an optional trailing sequence number for disambiguation.<br>
<br>
The argument to the -run and -bench command-line flags is an unanchored regular<br>
expression that matches the test&#39;s name. For tests with multiple slash-separated<br>
elements, such as subtests, the argument is itself slash-separated, with<br>
expressions matching each name element in turn. Because it is unanchored, an<br>
empty expression matches any string.<br>
For example, using &#34;matching&#34; to mean &#34;whose name contains&#34;:<br>
<br>
    go test -run &#39;&#39;      # Run all tests.<br>
    go test -run Foo     # Run top-level tests matching &#34;Foo&#34;, such as &#34;TestFooBar&#34;.<br>
    go test -run Foo/A=  # For top-level tests matching &#34;Foo&#34;, run subtests matching &#34;A=&#34;.<br>
    go test -run /A=1    # For all top-level tests, run subtests matching &#34;A=1&#34;.<br>
<br>
Subtests can also be used to control parallelism. A parent test will only<br>
complete once all of its subtests complete. In this example, all tests are<br>
run in parallel with each other, and only with each other, regardless of<br>
other top-level tests that may be defined:<br>
<br>
    func TestGroupedParallel(t *testing.T) {<br>
        for _, tc := range tests {<br>
            tc := tc // capture range variable<br>
            t.Run(tc.Name, func(t *testing.T) {<br>
                t.Parallel()<br>
                ...<br>
            })<br>
        }<br>
    }<br>
<br>
The race detector kills the program if it exceeds 8192 concurrent goroutines,<br>
so use care when running parallel tests with the -race flag set.<br>
<br>
Run does not return until parallel subtests have completed, providing a way<br>
to clean up after a group of parallel tests:<br>
<br>
    func TestTeardownParallel(t *testing.T) {<br>
        // This Run will not return until the parallel tests finish.<br>
        t.Run(&#34;group&#34;, func(t *testing.T) {<br>
            t.Run(&#34;Test1&#34;, parallelTest1)<br>
            t.Run(&#34;Test2&#34;, parallelTest2)<br>
            t.Run(&#34;Test3&#34;, parallelTest3)<br>
        })<br>
        // &lt;tear-down code&gt;<br>
    }<br>
<br>
Main<br>
<br>
It is sometimes necessary for a test program to do extra setup or teardown<br>
before or after testing. It is also sometimes necessary for a test to control<br>
which code runs on the main thread. To support these and other cases,<br>
if a test file contains a function:<br>
<br>
	func TestMain(m *testing.M)<br>
<br>
then the generated test will call TestMain(m) instead of running the tests<br>
directly. TestMain runs in the main goroutine and can do whatever setup<br>
and teardown is necessary around a call to m.Run. It should then call<br>
os.Exit with the result of m.Run. When TestMain is called, flag.Parse has<br>
not been run. If TestMain depends on command-line flags, including those<br>
of the testing package, it should call flag.Parse explicitly.<br>
<br>
A simple implementation of TestMain is:<br>
<br>
	func TestMain(m *testing.M) {<br>
		// call flag.Parse() here if TestMain uses flags<br>
		os.Exit(m.Run())<br>
	}<br>
</p>
    <h2>Index</h2>
    <ul class="index">
      <li>
  <a href="#B.">B.</a>
</li>
<li>
  <a href="#CoverBlock.">CoverBlock.</a>
</li>
<li>
  <a href="#CoverMode">CoverMode</a>
</li>
<li>
  <a href="#M.">M.</a>
</li>
<li>
  <a href="#PB.">PB.</a>
</li>
<li>
  <a href="#Short">Short</a>
</li>
<li>
  <a href="#T.">T.</a>
</li>
<li>
  <a href="#Verbose">Verbose</a>
</li>

    </ul>
    <ul>
      <li>
  <h3 id="B.">B.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(B. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for testing.B</p>
  
</li>
<li>
  <h3 id="CoverBlock.">CoverBlock.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(CoverBlock. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for testing.CoverBlock</p>
  
</li>
<li>
  <h3 id="CoverMode">CoverMode</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(CoverMode)</code></div>
</pre>
  <p class="var-docstr">CoverMode reports what the test coverage mode is set to. The<br>
values are &#34;set&#34;, &#34;count&#34;, or &#34;atomic&#34;. The return value will be<br>
empty if test coverage is not enabled.<br>
<br>
Go return type: string<br>
<br>
Joker input arguments: []<br>
<br>
Joker return type: String</p>
  
</li>
<li>
  <h3 id="M.">M.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(M. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for testing.M</p>
  
</li>
<li>
  <h3 id="PB.">PB.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(PB. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for testing.PB</p>
  
</li>
<li>
  <h3 id="Short">Short</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Short)</code></div>
</pre>
  <p class="var-docstr">Short reports whether the -test.short flag is set.<br>
<br>
Go return type: bool<br>
<br>
Joker input arguments: []<br>
<br>
Joker return type: Boolean</p>
  
</li>
<li>
  <h3 id="T.">T.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(T. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for testing.T</p>
  
</li>
<li>
  <h3 id="Verbose">Verbose</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Verbose)</code></div>
</pre>
  <p class="var-docstr">Verbose reports whether the -test.v flag is set.<br>
<br>
Go return type: bool<br>
<br>
Joker input arguments: []<br>
<br>
Joker return type: Boolean</p>
  
</li>

    </ul>
  </div>
</body>
</html>
