(alias 'string 'joker.string)
(require 'joker.walk)
(require 'joker.tools.cli)
(require 'joker.test)
(require 'joker.template)
(require 'joker.set)
(require 'joker.repl)
(require 'joker.html)

(def rpl joker.string/replace)

(def index-template
  (slurp "templates/index.html"))

(def ns-template
  (slurp "templates/ns.html"))

(def var-template
  (slurp "templates/var.html"))

(def receiver-template
  (slurp "templates/receiver.html"))

(def namespace-template
  (slurp "templates/ns-summary.html"))

(def type-template
  (slurp "templates/type-summary.html"))

(def link-item-template
  (slurp "templates/link-item.html"))

(def usage-template
  (slurp "templates/usage.html"))

(defn type-name
  [v]
  (let [m (meta v)]
    (cond
      (not (bound? v)) "Object"
      (:special-form m) "Special form"
      (:macro m) "Macro"
      (= Fn (type @v)) "Function"
      (= Proc (type @v)) "Function"
      (:tag m) (let [t (str (:tag m))]
                 (if (= t "GoType")
                   (str (if (:specificity m)
                          "Abstract "
                          "Concrete ") t)
                   (str t)))
      :else (str (type @v)))))

(defn link-item-doc
  [n k]
  (-> link-item-template
      (rpl "{name}" n)
      (rpl "{kind}" k)))

(defn usage
  [k m]
  (if (:special-form m)
    (let [examples (for [form (:forms m)]
                     (string/replace usage-template "{usage}" (str form)))]
      (string/join "" examples))
    (let [examples (for [arglist (:arglists m)]
                     (string/replace usage-template "{usage}" (str (apply list k arglist))))]
      (string/join "" examples))))

(defn- source-file
  [ns]
  (string/join "_" (rest (string/split (str ns) #"\."))))

(defn type-string
  "Returns the type name without the qualifying path (which is assumed to be local to the current namespace)."
  [^String t]
  (let [prefix (get (string/split t #"[A-Za-z0-9_]+") 0)
        base (get (string/split t #"/") 1)]
    (str prefix base)))

(defn receiver-doc
  [t r what]
  (if-let [m (Go t r)]
    (-> receiver-template
        (string/replace "{id}" (str r))
        (string/replace "{name}" (str r))
        (string/replace "{type}" (str what " for " (type-string (str t))))
        (string/replace "{usage}" (string/replace usage-template "{usage}" (str (apply list (get m :arglists)))))
        (string/replace "{docstring}" (string/replace (joker.html/escape (:doc m)) "\n" "<br>\n"))
        (string/replace "{added}" (str (:added m)))
        (string/replace
         "{source}"
         (if (:line m)
           (format "<a href=\"https://github.com/candid82/joker/blob/master/core/data/%s.joke#L%s\">source</a>"
                   (source-file (:ns m))
                   (str (:line m)))
           "{blank}")))
    "{blank}"))

(defn receivers-doc
  [k v what]
  (let [go-type-info (deref (Go v nil))
        members (get go-type-info "Members")
        memvec (sort (get members nil))]
    (string/join
     ""
     (for [m memvec]
       (receiver-doc v m what)))))

(defn var-doc
  [k v]
  (let [m (meta v)
        ns (get m :ns "<internal>")
        full-name (str ns "/" (str k))]
    (when-not (:added m)
      (println "WARNING: public var without added meta key: " full-name))
    (when-not (:doc m)
      (println "WARNING: public var without doc meta key: " full-name))
    (-> var-template
        (string/replace "{id}" (str k))
        (string/replace "{name}" (str k))
        (string/replace "{type}" (type-name v))
        (string/replace "{usage}" (usage k m))
        (string/replace "{docstring}" (string/replace (joker.html/escape (:doc m)) "\n" "<br>\n"))
        (string/replace "{added}" (str (:added m)))
        (string/replace
         "{source}"
         (if (:line m)
           (format "<a href=\"https://github.com/candid82/joker/blob/master/core/data/%s.joke#L%s\">source</a>"
                   (source-file (:ns m))
                   (str (:line m)))
           "{blank}"))
        (string/replace
         "{receivers}"
         (if (= GoType (type (deref v)))
           (let [what (if (:specificity (meta v)) "Receiver" "Method")]
             (receivers-doc k (deref v) what))
           "{blank}")))))

(defn- first-line
  [s]
  (first (string/split s #"\n")))

(defn namespace-doc
  [ns-sym]
  (let [ns (find-ns ns-sym)
        k (str (ns-name ns))
        m (meta ns)]
    (when-not (:added m)
      (println "WARNING: namespace without added meta key: " k))
    (when-not (:doc m)
      (println "WARNING: namespace without doc meta key: " k))
    (-> namespace-template
        (string/replace "{id}" k)
        (string/replace "{name}" k)
        (string/replace "{docstring}" (string/replace (joker.html/escape (first-line (:doc m))) "\n" "<br>\n"))
        (string/replace "{added}" (str (:added m))))))

(defn type-doc
  [k]
  (let [m (meta (get (joker.core/types__) k))]
    (when-not (:added m)
      (println "WARNING: type without added meta key: " k))
    (when-not (:doc m)
      (println "WARNING: type without doc meta key: " k))
    (-> type-template
        (string/replace "{id}" k)
        (string/replace "{name}" k)
        (string/replace "{docstring}" (string/replace (joker.html/escape (:doc m)) "\n" "<br>\n"))
        (string/replace "{added}" (str (:added m))))))

(defn sym-is
  [s x]
  (= x (type (deref s))))

(defn sym-is-constant
  [s]
  (condp = (type (deref s))
    Fn false
    GoType false
    GoVar false
    Proc false
    true))

(defn filter-vals
  "Filters on values in a map using supplied function, returning map with only matching key/value pairs."
  [f m]
  (into {} (filter #(-> % val f) m)))

(defn section-doc
  [ns-sym match]
  (string/join
   ""
   (for [[k v] (sort (filter-vals match (ns-publics ns-sym)))]
     (var-doc k v))))

(defn ns-doc
  [ns-sym]
  (let [ns (find-ns ns-sym)
        m (meta ns)
        index (string/join
                       ""
                       (for [[k v] (sort #(compare (key %1) (key %2)) (ns-publics ns-sym))]
                         (link-item-doc (str k) (type-name v))))
        functions-doc (section-doc ns-sym #(or (sym-is % Proc) (sym-is % Fn)))
        constants-doc (section-doc ns-sym #(sym-is-constant %))
        variables-doc (section-doc ns-sym #(sym-is % GoVar))
        types-doc (section-doc ns-sym #(sym-is % GoType))]
    (-> ns-template
        (string/replace "{name}" (name ns-sym))
        (string/replace "{added}" (str (:added m)))
        (string/replace "{docstring}" (string/replace (joker.html/escape (:doc m)) "\n" "<br>\n"))
        (string/replace "{constants}" constants-doc)
        (string/replace "{variables}" variables-doc)
        (string/replace "{functions}" functions-doc)
        (string/replace "{types}" types-doc)
        (string/replace "{index}" index))))

(defn go-version
  []
  (string/replace (go.std.runtime/Version) "go" ""))

(defn index-doc
  [namespaces types]
  (let [namespaces-docs (string/join
                         ""
                         (for [ns-sym namespaces]
                           (namespace-doc ns-sym)))
        ns-links-doc (string/join
                      ""
                      (->> namespaces
                           (map #(link-item-doc (str %) "Namespace"))))
        types-docs (string/join
                    ""
                    (for [t types]
                      (type-doc t)))
        type-links-doc (string/join
                        ""
                        (->> types
                             (map #(link-item-doc (str %) "Type"))))]
    (-> index-template
        (string/replace "{JokerVersion}" (joker-version))
        (string/replace "{GoVersion}" (go-version))
        (string/replace "{index-of-namespaces}" ns-links-doc)
        (string/replace "{namespaces}" namespaces-docs)
        (string/replace "{index-of-types}" type-links-doc)
        (string/replace "{types}" types-docs))))

(defn remove-blanky-lines
  [s]
  (-> s
      (rpl #"[[:space:]]*{blank}" "")))

(defn full-doc
  [ns-fn]
  (let [namespaces (->> (ns-fn)
                        (map ns-name)
                        (remove #(= 'user %))
                        (sort))
        types (->> (joker.core/types__)
                   (map key)
                   (sort))]
    (spit "index.html" (index-doc namespaces types))
    (doseq [ns namespaces]
      (spit (str ns ".html") (remove-blanky-lines (ns-doc ns))))))

(defn is-go
  [ns]
  (string/starts-with? (str ns) "go.std."))

(defn no-go-ns
  []
  (->> (all-ns)
      (remove #(is-go %))))

(defn have-option
  "Quick and dirty options parser."
  [opt]
  (some #(= opt %) *command-line-args*))

;;; Bind the REPL stuff so (deref ...) of them doesn't fail.
(doseq [s ['*1 '*2 '*3 '*e]]
  (intern 'joker.core s "empty"))

(if (have-option "--no-go")
  (full-doc no-go-ns)
  (full-doc all-ns))
