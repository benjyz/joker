<html>
<head>
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
  <div class="main">
    <h1>Namespace: go.std.math.big</h1>
    <span class="var-added">v1.0</span>
    <p class="var-docstr">Provides a low-level interface to the math/big package.<br>
<br>
Package big implements arbitrary-precision arithmetic (big numbers).<br>
The following numeric types are supported:<br>
<br>
	Int    signed integers<br>
	Rat    rational numbers<br>
	Float  floating-point numbers<br>
<br>
The zero value for an Int, Rat, or Float correspond to 0. Thus, new<br>
values can be declared in the usual ways and denote 0 without further<br>
initialization:<br>
<br>
	var x Int        // &amp;x is an *Int of value 0<br>
	var r = &amp;Rat{}   // r is a *Rat of value 0<br>
	y := new(Float)  // y is a *Float of value 0<br>
<br>
Alternatively, new values can be allocated and initialized with factory<br>
functions of the form:<br>
<br>
	func NewT(v V) *T<br>
<br>
For instance, NewInt(x) returns an *Int set to the value of the int64<br>
argument x, NewRat(a, b) returns a *Rat set to the fraction a/b where<br>
a and b are int64 values, and NewFloat(f) returns a *Float initialized<br>
to the float64 argument f. More flexibility is provided with explicit<br>
setters, for instance:<br>
<br>
	var z1 Int<br>
	z1.SetUint64(123)                 // z1 := 123<br>
	z2 := new(Rat).SetFloat64(1.25)   // z2 := 5/4<br>
	z3 := new(Float).SetInt(z1)       // z3 := 123.0<br>
<br>
Setters, numeric operations and predicates are represented as methods of<br>
the form:<br>
<br>
	func (z *T) SetV(v V) *T          // z = v<br>
	func (z *T) Unary(x *T) *T        // z = unary x<br>
	func (z *T) Binary(x, y *T) *T    // z = x binary y<br>
	func (x *T) Pred() P              // p = pred(x)<br>
<br>
with T one of Int, Rat, or Float. For unary and binary operations, the<br>
result is the receiver (usually named z in that case; see below); if it<br>
is one of the operands x or y it may be safely overwritten (and its memory<br>
reused).<br>
<br>
Arithmetic expressions are typically written as a sequence of individual<br>
method calls, with each call corresponding to an operation. The receiver<br>
denotes the result and the method arguments are the operation&#39;s operands.<br>
For instance, given three *Int values a, b and c, the invocation<br>
<br>
	c.Add(a, b)<br>
<br>
computes the sum a + b and stores the result in c, overwriting whatever<br>
value was held in c before. Unless specified otherwise, operations permit<br>
aliasing of parameters, so it is perfectly ok to write<br>
<br>
	sum.Add(sum, x)<br>
<br>
to accumulate values x in a sum.<br>
<br>
(By always passing in a result value via the receiver, memory use can be<br>
much better controlled. Instead of having to allocate new memory for each<br>
result, an operation can reuse the space allocated for the result value,<br>
and overwrite that value with the new result in the process.)<br>
<br>
Notational convention: Incoming method parameters (including the receiver)<br>
are named consistently in the API to clarify their use. Incoming operands<br>
are usually named x, y, a, b, and so on, but never z. A parameter specifying<br>
the result is named z (typically the receiver).<br>
<br>
For instance, the arguments for (*Int).Add are named x and y, and because<br>
the receiver specifies the result destination, it is called z:<br>
<br>
	func (z *Int) Add(x, y *Int) *Int<br>
<br>
Methods of this form typically return the incoming receiver as well, to<br>
enable simple call chaining.<br>
<br>
Methods which don&#39;t require a result value to be passed in (for instance,<br>
Int.Sign), simply return the result. In this case, the receiver is typically<br>
the first operand, named x:<br>
<br>
	func (x *Int) Sign() int<br>
<br>
Various methods support conversions between strings and corresponding<br>
numeric values, and vice versa: *Int, *Rat, and *Float values implement<br>
the Stringer interface for a (default) string representation of the value,<br>
but also provide SetString methods to initialize a value from a string in<br>
a variety of supported formats (see the respective SetString documentation).<br>
<br>
Finally, *Int, *Rat, and *Float satisfy the fmt package&#39;s Scanner interface<br>
for scanning and (except for *Rat) the Formatter interface for formatted<br>
printing.<br>
</p>
    <h2>Index</h2>
    <ul class="index">
      <li>
  <a href="#Above">Above</a>
</li>
<li>
  <a href="#Accuracy.">Accuracy.</a>
</li>
<li>
  <a href="#AwayFromZero">AwayFromZero</a>
</li>
<li>
  <a href="#Below">Below</a>
</li>
<li>
  <a href="#ErrNaN.">ErrNaN.</a>
</li>
<li>
  <a href="#Exact">Exact</a>
</li>
<li>
  <a href="#Float.">Float.</a>
</li>
<li>
  <a href="#Int.">Int.</a>
</li>
<li>
  <a href="#Jacobi">Jacobi</a>
</li>
<li>
  <a href="#MaxBase">MaxBase</a>
</li>
<li>
  <a href="#NewInt">NewInt</a>
</li>
<li>
  <a href="#NewRat">NewRat</a>
</li>
<li>
  <a href="#ParseFloat">ParseFloat</a>
</li>
<li>
  <a href="#Rat.">Rat.</a>
</li>
<li>
  <a href="#RoundingMode.">RoundingMode.</a>
</li>
<li>
  <a href="#ToNearestAway">ToNearestAway</a>
</li>
<li>
  <a href="#ToNearestEven">ToNearestEven</a>
</li>
<li>
  <a href="#ToNegativeInf">ToNegativeInf</a>
</li>
<li>
  <a href="#ToPositiveInf">ToPositiveInf</a>
</li>
<li>
  <a href="#ToZero">ToZero</a>
</li>
<li>
  <a href="#Word.">Word.</a>
</li>

    </ul>
    <ul>
      <li>
  <h3 id="Above">Above</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">Constants describing the Accuracy of a Float.<br>
</p>
  
</li>
<li>
  <h3 id="Accuracy.">Accuracy.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Accuracy. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for big.Accuracy</p>
  
</li>
<li>
  <h3 id="AwayFromZero">AwayFromZero</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">no IEEE 754-2008 equivalent<br>
</p>
  
</li>
<li>
  <h3 id="Below">Below</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">Constants describing the Accuracy of a Float.<br>
</p>
  
</li>
<li>
  <h3 id="ErrNaN.">ErrNaN.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ErrNaN. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for big.ErrNaN</p>
  
</li>
<li>
  <h3 id="Exact">Exact</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">Constants describing the Accuracy of a Float.<br>
</p>
  
</li>
<li>
  <h3 id="Float.">Float.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Float. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for big.Float</p>
  
</li>
<li>
  <h3 id="Int.">Int.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Int. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for big.Int</p>
  
</li>
<li>
  <h3 id="Jacobi">Jacobi</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Jacobi __x __y)</code></div>
</pre>
  <p class="var-docstr">Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0.<br>
The y argument must be an odd integer.<br>
<br>
Go input arguments: (x *Int, y *Int)<br>
<br>
Go return type: int<br>
<br>
Joker input arguments: [^(atom-of go.std.math.big/Int) x, ^(atom-of go.std.math.big/Int) y]<br>
<br>
Joker return type: Int</p>
  
</li>
<li>
  <h3 id="MaxBase">MaxBase</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">MaxBase is the largest number base accepted for string conversions.<br>
</p>
  
</li>
<li>
  <h3 id="NewInt">NewInt</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(NewInt __x)</code></div>
</pre>
  <p class="var-docstr">NewInt allocates and returns a new Int set to x.<br>
<br>
Go input arguments: (x int64)<br>
<br>
Go return type: *Int<br>
<br>
Joker input arguments: [^Number x]<br>
<br>
Joker return type: (atom-of go.std.math.big/Int)</p>
  
</li>
<li>
  <h3 id="NewRat">NewRat</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(NewRat __a __b)</code></div>
</pre>
  <p class="var-docstr">NewRat creates a new Rat with numerator a and denominator b.<br>
<br>
Go input arguments: (a int64, b int64)<br>
<br>
Go return type: *Rat<br>
<br>
Joker input arguments: [^Number a, ^Number b]<br>
<br>
Joker return type: (atom-of go.std.math.big/Rat)</p>
  
</li>
<li>
  <h3 id="ParseFloat">ParseFloat</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ParseFloat __s __base __prec __mode)</code></div>
</pre>
  <p class="var-docstr">ParseFloat is like f.Parse(s, base) with f set to the given precision<br>
and rounding mode.<br>
<br>
Go input arguments: (s string, base int, prec uint, mode RoundingMode)<br>
<br>
Go return type: (f *Float, b int, err error)<br>
<br>
Joker input arguments: [^String s, ^Int base, ^Number prec, ^go.std.math.big/RoundingMode mode]<br>
<br>
Joker return type: [(atom-of go.std.math.big/Float) Int Error]</p>
  
</li>
<li>
  <h3 id="Rat.">Rat.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Rat. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for big.Rat</p>
  
</li>
<li>
  <h3 id="RoundingMode.">RoundingMode.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(RoundingMode. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for big.RoundingMode</p>
  
</li>
<li>
  <h3 id="ToNearestAway">ToNearestAway</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">== IEEE 754-2008 roundTiesToAway<br>
</p>
  
</li>
<li>
  <h3 id="ToNearestEven">ToNearestEven</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">== IEEE 754-2008 roundTiesToEven<br>
</p>
  
</li>
<li>
  <h3 id="ToNegativeInf">ToNegativeInf</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">== IEEE 754-2008 roundTowardNegative<br>
</p>
  
</li>
<li>
  <h3 id="ToPositiveInf">ToPositiveInf</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">== IEEE 754-2008 roundTowardPositive<br>
</p>
  
</li>
<li>
  <h3 id="ToZero">ToZero</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">== IEEE 754-2008 roundTowardZero<br>
</p>
  
</li>
<li>
  <h3 id="Word.">Word.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Word. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for big.Word</p>
  
</li>

    </ul>
  </div>
</body>
</html>
