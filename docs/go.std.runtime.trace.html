<html>
<head>
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
  <div class="main">
    <h1>Namespace: go.std.runtime.trace</h1>
    <span class="var-added">v1.0</span>
    <p class="var-docstr">Provides a low-level interface to the runtime/trace package.<br>
<br>
Package trace contains facilities for programs to generate traces<br>
for the Go execution tracer.<br>
<br>
Tracing runtime activities<br>
<br>
The execution trace captures a wide range of execution events such as<br>
goroutine creation/blocking/unblocking, syscall enter/exit/block,<br>
GC-related events, changes of heap size, processor start/stop, etc.<br>
A precise nanosecond-precision timestamp and a stack trace is<br>
captured for most events. The generated trace can be interpreted<br>
using `go tool trace`.<br>
<br>
Support for tracing tests and benchmarks built with the standard<br>
testing package is built into `go test`. For example, the following<br>
command runs the test in the current directory and writes the trace<br>
file (trace.out).<br>
<br>
   go test -trace=test.out<br>
<br>
This runtime/trace package provides APIs to add equivalent tracing<br>
support to a standalone program. See the Example that demonstrates<br>
how to use this API to enable tracing.<br>
<br>
There is also a standard HTTP interface to trace data. Adding the<br>
following line will install a handler under the /debug/pprof/trace URL<br>
to download a live trace:<br>
<br>
    import _ &#34;net/http/pprof&#34;<br>
<br>
See the net/http/pprof package for more details about all of the<br>
debug endpoints installed by this import.<br>
<br>
User annotation<br>
<br>
Package trace provides user annotation APIs that can be used to<br>
log interesting events during execution.<br>
<br>
There are three types of user annotations: log messages, regions,<br>
and tasks.<br>
<br>
Log emits a timestamped message to the execution trace along with<br>
additional information such as the category of the message and<br>
which goroutine called Log. The execution tracer provides UIs to filter<br>
and group goroutines using the log category and the message supplied<br>
in Log.<br>
<br>
A region is for logging a time interval during a goroutine&#39;s execution.<br>
By definition, a region starts and ends in the same goroutine.<br>
Regions can be nested to represent subintervals.<br>
For example, the following code records four regions in the execution<br>
trace to trace the durations of sequential steps in a cappuccino making<br>
operation.<br>
<br>
  trace.WithRegion(ctx, &#34;makeCappuccino&#34;, func() {<br>
<br>
     // orderID allows to identify a specific order<br>
     // among many cappuccino order region records.<br>
     trace.Log(ctx, &#34;orderID&#34;, orderID)<br>
<br>
     trace.WithRegion(ctx, &#34;steamMilk&#34;, steamMilk)<br>
     trace.WithRegion(ctx, &#34;extractCoffee&#34;, extractCoffee)<br>
     trace.WithRegion(ctx, &#34;mixMilkCoffee&#34;, mixMilkCoffee)<br>
  })<br>
<br>
A task is a higher-level component that aids tracing of logical<br>
operations such as an RPC request, an HTTP request, or an<br>
interesting local operation which may require multiple goroutines<br>
working together. Since tasks can involve multiple goroutines,<br>
they are tracked via a context.Context object. NewTask creates<br>
a new task and embeds it in the returned context.Context object.<br>
Log messages and regions are attached to the task, if any, in the<br>
Context passed to Log and WithRegion.<br>
<br>
For example, assume that we decided to froth milk, extract coffee,<br>
and mix milk and coffee in separate goroutines. With a task,<br>
the trace tool can identify the goroutines involved in a specific<br>
cappuccino order.<br>
<br>
     ctx, task := trace.NewTask(ctx, &#34;makeCappuccino&#34;)<br>
     trace.Log(ctx, &#34;orderID&#34;, orderID)<br>
<br>
     milk := make(chan bool)<br>
     espresso := make(chan bool)<br>
<br>
     go func() {<br>
             trace.WithRegion(ctx, &#34;steamMilk&#34;, steamMilk)<br>
             milk &lt;- true<br>
     }()<br>
     go func() {<br>
             trace.WithRegion(ctx, &#34;extractCoffee&#34;, extractCoffee)<br>
             espresso &lt;- true<br>
     }()<br>
     go func() {<br>
             defer task.End() // When assemble is done, the order is complete.<br>
             &lt;-espresso<br>
             &lt;-milk<br>
             trace.WithRegion(ctx, &#34;mixMilkCoffee&#34;, mixMilkCoffee)<br>
     }()<br>
<br>
The trace tool computes the latency of a task by measuring the<br>
time between the task creation and the task end and provides<br>
latency distributions for each task type found in the trace.<br>
</p>
    <h2>Index</h2>
    <ul class="index">
      <li>
  <a href="#IsEnabled">IsEnabled</a>
</li>
<li>
  <a href="#Region.">Region.</a>
</li>
<li>
  <a href="#Task.">Task.</a>
</li>

    </ul>
    <ul>
      <li>
  <h3 id="IsEnabled">IsEnabled</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(IsEnabled)</code></div>
</pre>
  <p class="var-docstr">IsEnabled reports whether tracing is enabled.<br>
The information is advisory only. The tracing status<br>
may have changed by the time this function returns.<br>
<br>
Go return type: bool<br>
<br>
Joker input arguments: []<br>
<br>
Joker return type: Boolean</p>
  
</li>
<li>
  <h3 id="Region.">Region.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Region. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for trace.Region</p>
  
</li>
<li>
  <h3 id="Task.">Task.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Task. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for trace.Task</p>
  
</li>

    </ul>
  </div>
</body>
</html>
