<html>
<head>
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
  <div class="main">
    <h1>Namespace: go.std.reflect</h1>
    <span class="var-added">v1.0</span>
    <p class="var-docstr">Provides a low-level interface to the reflect package.<br>
<br>
Package reflect implements run-time reflection, allowing a program to<br>
manipulate objects with arbitrary types. The typical use is to take a value<br>
with static type interface{} and extract its dynamic type information by<br>
calling TypeOf, which returns a Type.<br>
<br>
A call to ValueOf returns a Value representing the run-time data.<br>
Zero takes a Type and returns a Value representing a zero value<br>
for that type.<br>
<br>
See &#34;The Laws of Reflection&#34; for an introduction to reflection in Go:<br>
https://golang.org/doc/articles/laws_of_reflection.html<br>
</p>
    <h2>Index</h2>
    <ul class="index">
      <li>
  <a href="#AppendSlice">AppendSlice</a>
</li>
<li>
  <a href="#Array">Array</a>
</li>
<li>
  <a href="#ArrayOf">ArrayOf</a>
</li>
<li>
  <a href="#Bool">Bool</a>
</li>
<li>
  <a href="#BothDir">BothDir</a>
</li>
<li>
  <a href="#Chan">Chan</a>
</li>
<li>
  <a href="#ChanDir.">ChanDir.</a>
</li>
<li>
  <a href="#ChanOf">ChanOf</a>
</li>
<li>
  <a href="#Complex128">Complex128</a>
</li>
<li>
  <a href="#Complex64">Complex64</a>
</li>
<li>
  <a href="#Copy">Copy</a>
</li>
<li>
  <a href="#Float32">Float32</a>
</li>
<li>
  <a href="#Float64">Float64</a>
</li>
<li>
  <a href="#Func">Func</a>
</li>
<li>
  <a href="#Indirect">Indirect</a>
</li>
<li>
  <a href="#Int-renamed">Int-renamed</a>
</li>
<li>
  <a href="#Int16">Int16</a>
</li>
<li>
  <a href="#Int32">Int32</a>
</li>
<li>
  <a href="#Int64">Int64</a>
</li>
<li>
  <a href="#Int8">Int8</a>
</li>
<li>
  <a href="#Interface">Interface</a>
</li>
<li>
  <a href="#Invalid">Invalid</a>
</li>
<li>
  <a href="#Kind.">Kind.</a>
</li>
<li>
  <a href="#MakeChan">MakeChan</a>
</li>
<li>
  <a href="#MakeMap">MakeMap</a>
</li>
<li>
  <a href="#MakeMapWithSize">MakeMapWithSize</a>
</li>
<li>
  <a href="#MakeSlice">MakeSlice</a>
</li>
<li>
  <a href="#Map">Map</a>
</li>
<li>
  <a href="#MapIter.">MapIter.</a>
</li>
<li>
  <a href="#MapOf">MapOf</a>
</li>
<li>
  <a href="#New">New</a>
</li>
<li>
  <a href="#Ptr">Ptr</a>
</li>
<li>
  <a href="#PtrTo">PtrTo</a>
</li>
<li>
  <a href="#RecvDir">RecvDir</a>
</li>
<li>
  <a href="#SelectDefault">SelectDefault</a>
</li>
<li>
  <a href="#SelectDir.">SelectDir.</a>
</li>
<li>
  <a href="#SelectRecv">SelectRecv</a>
</li>
<li>
  <a href="#SelectSend">SelectSend</a>
</li>
<li>
  <a href="#SendDir">SendDir</a>
</li>
<li>
  <a href="#Slice">Slice</a>
</li>
<li>
  <a href="#SliceHeader.">SliceHeader.</a>
</li>
<li>
  <a href="#SliceOf">SliceOf</a>
</li>
<li>
  <a href="#String-renamed">String-renamed</a>
</li>
<li>
  <a href="#StringHeader.">StringHeader.</a>
</li>
<li>
  <a href="#Struct">Struct</a>
</li>
<li>
  <a href="#StructTag.">StructTag.</a>
</li>
<li>
  <a href="#Uint">Uint</a>
</li>
<li>
  <a href="#Uint16">Uint16</a>
</li>
<li>
  <a href="#Uint32">Uint32</a>
</li>
<li>
  <a href="#Uint64">Uint64</a>
</li>
<li>
  <a href="#Uint8">Uint8</a>
</li>
<li>
  <a href="#Uintptr">Uintptr</a>
</li>
<li>
  <a href="#UnsafePointer">UnsafePointer</a>
</li>
<li>
  <a href="#Value.">Value.</a>
</li>
<li>
  <a href="#ValueError.">ValueError.</a>
</li>
<li>
  <a href="#Zero">Zero</a>
</li>

    </ul>
    <ul>
      <li>
  <h3 id="AppendSlice">AppendSlice</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(AppendSlice __s __t)</code></div>
</pre>
  <p class="var-docstr">AppendSlice appends a slice t to a slice s and returns the resulting slice.<br>
The slices s and t must have the same element type.<br>
<br>
Go input arguments: (s Value, t Value)<br>
<br>
Go return type: Value<br>
<br>
Joker input arguments: [^go.std.reflect/Value s, ^go.std.reflect/Value t]<br>
<br>
Joker return type: go.std.reflect/Value</p>
  
</li>
<li>
  <h3 id="Array">Array</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="ArrayOf">ArrayOf</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ArrayOf __count __elem)</code></div>
</pre>
  <p class="var-docstr">ArrayOf returns the array type with the given count and element type.<br>
For example, if t represents int, ArrayOf(5, t) represents [5]int.<br>
<br>
If the resulting type would be larger than the available address space,<br>
ArrayOf panics.<br>
<br>
Go input arguments: (count int, elem Type)<br>
<br>
Go return type: Type<br>
<br>
Joker input arguments: [^Int count, ^go.std.reflect/Type elem]<br>
<br>
Joker return type: go.std.reflect/Type</p>
  
</li>
<li>
  <h3 id="Bool">Bool</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="BothDir">BothDir</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">chan<br>
</p>
  
</li>
<li>
  <h3 id="Chan">Chan</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="ChanDir.">ChanDir.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ChanDir. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for reflect.ChanDir</p>
  
</li>
<li>
  <h3 id="ChanOf">ChanOf</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ChanOf __dir __t)</code></div>
</pre>
  <p class="var-docstr">ChanOf returns the channel type with the given direction and element type.<br>
For example, if t represents int, ChanOf(RecvDir, t) represents &lt;-chan int.<br>
<br>
The gc runtime imposes a limit of 64 kB on channel element types.<br>
If t&#39;s size is equal to or exceeds this limit, ChanOf panics.<br>
<br>
Go input arguments: (dir ChanDir, t Type)<br>
<br>
Go return type: Type<br>
<br>
Joker input arguments: [^go.std.reflect/ChanDir dir, ^go.std.reflect/Type t]<br>
<br>
Joker return type: go.std.reflect/Type</p>
  
</li>
<li>
  <h3 id="Complex128">Complex128</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Complex64">Complex64</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Copy">Copy</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Copy __dst __src)</code></div>
</pre>
  <p class="var-docstr">Copy copies the contents of src into dst until either<br>
dst has been filled or src has been exhausted.<br>
It returns the number of elements copied.<br>
Dst and src each must have kind Slice or Array, and<br>
dst and src must have the same element type.<br>
<br>
As a special case, src can have kind String if the element type of dst is kind Uint8.<br>
<br>
Go input arguments: (dst Value, src Value)<br>
<br>
Go return type: int<br>
<br>
Joker input arguments: [^go.std.reflect/Value dst, ^go.std.reflect/Value src]<br>
<br>
Joker return type: Int</p>
  
</li>
<li>
  <h3 id="Float32">Float32</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Float64">Float64</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Func">Func</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Indirect">Indirect</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Indirect __v)</code></div>
</pre>
  <p class="var-docstr">Indirect returns the value that v points to.<br>
If v is a nil pointer, Indirect returns a zero Value.<br>
If v is not a pointer, Indirect returns v.<br>
<br>
Go input arguments: (v Value)<br>
<br>
Go return type: Value<br>
<br>
Joker input arguments: [^go.std.reflect/Value v]<br>
<br>
Joker return type: go.std.reflect/Value</p>
  
</li>
<li>
  <h3 id="Int-renamed">Int-renamed</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Int16">Int16</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Int32">Int32</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Int64">Int64</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Int8">Int8</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Interface">Interface</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Invalid">Invalid</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Kind.">Kind.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Kind. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for reflect.Kind</p>
  
</li>
<li>
  <h3 id="MakeChan">MakeChan</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(MakeChan __typ __buffer)</code></div>
</pre>
  <p class="var-docstr">MakeChan creates a new channel with the specified type and buffer size.<br>
<br>
Go input arguments: (typ Type, buffer int)<br>
<br>
Go return type: Value<br>
<br>
Joker input arguments: [^go.std.reflect/Type typ, ^Int buffer]<br>
<br>
Joker return type: go.std.reflect/Value</p>
  
</li>
<li>
  <h3 id="MakeMap">MakeMap</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(MakeMap __typ)</code></div>
</pre>
  <p class="var-docstr">MakeMap creates a new map with the specified type.<br>
<br>
Go input arguments: (typ Type)<br>
<br>
Go return type: Value<br>
<br>
Joker input arguments: [^go.std.reflect/Type typ]<br>
<br>
Joker return type: go.std.reflect/Value</p>
  
</li>
<li>
  <h3 id="MakeMapWithSize">MakeMapWithSize</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(MakeMapWithSize __typ __n)</code></div>
</pre>
  <p class="var-docstr">MakeMapWithSize creates a new map with the specified type<br>
and initial space for approximately n elements.<br>
<br>
Go input arguments: (typ Type, n int)<br>
<br>
Go return type: Value<br>
<br>
Joker input arguments: [^go.std.reflect/Type typ, ^Int n]<br>
<br>
Joker return type: go.std.reflect/Value</p>
  
</li>
<li>
  <h3 id="MakeSlice">MakeSlice</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(MakeSlice __typ __len __cap)</code></div>
</pre>
  <p class="var-docstr">MakeSlice creates a new zero-initialized slice value<br>
for the specified slice type, length, and capacity.<br>
<br>
Go input arguments: (typ Type, len int, cap int)<br>
<br>
Go return type: Value<br>
<br>
Joker input arguments: [^go.std.reflect/Type typ, ^Int len, ^Int cap]<br>
<br>
Joker return type: go.std.reflect/Value</p>
  
</li>
<li>
  <h3 id="Map">Map</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="MapIter.">MapIter.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(MapIter. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for reflect.MapIter</p>
  
</li>
<li>
  <h3 id="MapOf">MapOf</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(MapOf __key __elem)</code></div>
</pre>
  <p class="var-docstr">MapOf returns the map type with the given key and element types.<br>
For example, if k represents int and e represents string,<br>
MapOf(k, e) represents map[int]string.<br>
<br>
If the key type is not a valid map key type (that is, if it does<br>
not implement Go&#39;s == operator), MapOf panics.<br>
<br>
Go input arguments: (key Type, elem Type)<br>
<br>
Go return type: Type<br>
<br>
Joker input arguments: [^go.std.reflect/Type key, ^go.std.reflect/Type elem]<br>
<br>
Joker return type: go.std.reflect/Type</p>
  
</li>
<li>
  <h3 id="New">New</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(New __typ)</code></div>
</pre>
  <p class="var-docstr">New returns a Value representing a pointer to a new zero value<br>
for the specified type. That is, the returned Value&#39;s Type is PtrTo(typ).<br>
<br>
Go input arguments: (typ Type)<br>
<br>
Go return type: Value<br>
<br>
Joker input arguments: [^go.std.reflect/Type typ]<br>
<br>
Joker return type: go.std.reflect/Value</p>
  
</li>
<li>
  <h3 id="Ptr">Ptr</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="PtrTo">PtrTo</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(PtrTo __t)</code></div>
</pre>
  <p class="var-docstr">PtrTo returns the pointer type with element t.<br>
For example, if t represents type Foo, PtrTo(t) represents *Foo.<br>
<br>
Go input arguments: (t Type)<br>
<br>
Go return type: Type<br>
<br>
Joker input arguments: [^go.std.reflect/Type t]<br>
<br>
Joker return type: go.std.reflect/Type</p>
  
</li>
<li>
  <h3 id="RecvDir">RecvDir</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">&lt;-chan<br>
</p>
  
</li>
<li>
  <h3 id="SelectDefault">SelectDefault</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">default<br>
</p>
  
</li>
<li>
  <h3 id="SelectDir.">SelectDir.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(SelectDir. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for reflect.SelectDir</p>
  
</li>
<li>
  <h3 id="SelectRecv">SelectRecv</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">case &lt;-Chan:<br>
</p>
  
</li>
<li>
  <h3 id="SelectSend">SelectSend</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">case Chan &lt;- Send<br>
</p>
  
</li>
<li>
  <h3 id="SendDir">SendDir</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">chan&lt;-<br>
</p>
  
</li>
<li>
  <h3 id="Slice">Slice</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="SliceHeader.">SliceHeader.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(SliceHeader. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for reflect.SliceHeader</p>
  
</li>
<li>
  <h3 id="SliceOf">SliceOf</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(SliceOf __t)</code></div>
</pre>
  <p class="var-docstr">SliceOf returns the slice type with element type t.<br>
For example, if t represents int, SliceOf(t) represents []int.<br>
<br>
Go input arguments: (t Type)<br>
<br>
Go return type: Type<br>
<br>
Joker input arguments: [^go.std.reflect/Type t]<br>
<br>
Joker return type: go.std.reflect/Type</p>
  
</li>
<li>
  <h3 id="String-renamed">String-renamed</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="StringHeader.">StringHeader.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(StringHeader. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for reflect.StringHeader</p>
  
</li>
<li>
  <h3 id="Struct">Struct</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="StructTag.">StructTag.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(StructTag. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for reflect.StructTag</p>
  
</li>
<li>
  <h3 id="Uint">Uint</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Uint16">Uint16</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Uint32">Uint32</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Uint64">Uint64</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Uint8">Uint8</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Uintptr">Uintptr</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="UnsafePointer">UnsafePointer</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Value.">Value.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Value. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for reflect.Value</p>
  
</li>
<li>
  <h3 id="ValueError.">ValueError.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ValueError. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for reflect.ValueError</p>
  
</li>
<li>
  <h3 id="Zero">Zero</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Zero __typ)</code></div>
</pre>
  <p class="var-docstr">Zero returns a Value representing the zero value for the specified type.<br>
The result is different from the zero value of the Value struct,<br>
which represents no value at all.<br>
For example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0.<br>
The returned value is neither addressable nor settable.<br>
<br>
Go input arguments: (typ Type)<br>
<br>
Go return type: Value<br>
<br>
Joker input arguments: [^go.std.reflect/Type typ]<br>
<br>
Joker return type: go.std.reflect/Value</p>
  
</li>

    </ul>
  </div>
</body>
</html>
