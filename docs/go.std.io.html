<html>
<head>
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
  <div class="main">
    <h1>Namespace: go.std.io</h1>
    <span class="var-added">v1.0</span>
    <p class="var-docstr">Provides a low-level interface to the io package.<br>
<br>
Package io provides basic interfaces to I/O primitives.<br>
Its primary job is to wrap existing implementations of such primitives,<br>
such as those in package os, into shared public interfaces that<br>
abstract the functionality, plus some other related primitives.<br>
<br>
Because these interfaces and primitives wrap lower-level operations with<br>
various implementations, unless otherwise informed clients should not<br>
assume they are safe for parallel execution.<br>
</p>
    <h2>Index</h2>
    <ul class="index">
      <li>
  <a href="#Copy">Copy</a>
</li>
<li>
  <a href="#CopyN">CopyN</a>
</li>
<li>
  <a href="#EOF">EOF</a>
</li>
<li>
  <a href="#ErrClosedPipe">ErrClosedPipe</a>
</li>
<li>
  <a href="#ErrNoProgress">ErrNoProgress</a>
</li>
<li>
  <a href="#ErrShortBuffer">ErrShortBuffer</a>
</li>
<li>
  <a href="#ErrShortWrite">ErrShortWrite</a>
</li>
<li>
  <a href="#ErrUnexpectedEOF">ErrUnexpectedEOF</a>
</li>
<li>
  <a href="#LimitReader">LimitReader</a>
</li>
<li>
  <a href="#NewSectionReader">NewSectionReader</a>
</li>
<li>
  <a href="#Pipe">Pipe</a>
</li>
<li>
  <a href="#PipeReader.">PipeReader.</a>
</li>
<li>
  <a href="#PipeWriter.">PipeWriter.</a>
</li>
<li>
  <a href="#SectionReader.">SectionReader.</a>
</li>
<li>
  <a href="#SeekCurrent">SeekCurrent</a>
</li>
<li>
  <a href="#SeekEnd">SeekEnd</a>
</li>
<li>
  <a href="#SeekStart">SeekStart</a>
</li>
<li>
  <a href="#TeeReader">TeeReader</a>
</li>
<li>
  <a href="#WriteString">WriteString</a>
</li>

    </ul>
    <ul>
      <li>
  <h3 id="Copy">Copy</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Copy __dst __src)</code></div>
</pre>
  <p class="var-docstr">Copy copies from src to dst until either EOF is reached<br>
on src or an error occurs. It returns the number of bytes<br>
copied and the first error encountered while copying, if any.<br>
<br>
A successful Copy returns err == nil, not err == EOF.<br>
Because Copy is defined to read from src until EOF, it does<br>
not treat an EOF from Read as an error to be reported.<br>
<br>
If src implements the WriterTo interface,<br>
the copy is implemented by calling src.WriteTo(dst).<br>
Otherwise, if dst implements the ReaderFrom interface,<br>
the copy is implemented by calling dst.ReadFrom(src).<br>
<br>
Go input arguments: (dst Writer, src Reader)<br>
<br>
Go return type: (written int64, err error)<br>
<br>
Joker input arguments: [^go.std.io/Writer dst, ^go.std.io/Reader src]<br>
<br>
Joker return type: [Number Error]</p>
  
</li>
<li>
  <h3 id="CopyN">CopyN</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(CopyN __dst __src __n)</code></div>
</pre>
  <p class="var-docstr">CopyN copies n bytes (or until an error) from src to dst.<br>
It returns the number of bytes copied and the earliest<br>
error encountered while copying.<br>
On return, written == n if and only if err == nil.<br>
<br>
If dst implements the ReaderFrom interface,<br>
the copy is implemented using it.<br>
<br>
Go input arguments: (dst Writer, src Reader, n int64)<br>
<br>
Go return type: (written int64, err error)<br>
<br>
Joker input arguments: [^go.std.io/Writer dst, ^go.std.io/Reader src, ^Number n]<br>
<br>
Joker return type: [Number Error]</p>
  
</li>
<li>
  <h3 id="EOF">EOF</h3>
  <span class="var-type GoVar[*.error]">GoVar[*.error]</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">EOF is the error returned by Read when no more input is available.<br>
Functions should return EOF only to signal a graceful end of input.<br>
If the EOF occurs unexpectedly in a structured data stream,<br>
the appropriate error is either ErrUnexpectedEOF or some other error<br>
giving more detail.<br>
</p>
  
</li>
<li>
  <h3 id="ErrClosedPipe">ErrClosedPipe</h3>
  <span class="var-type GoVar[*.error]">GoVar[*.error]</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">ErrClosedPipe is the error used for read or write operations on a closed pipe.<br>
</p>
  
</li>
<li>
  <h3 id="ErrNoProgress">ErrNoProgress</h3>
  <span class="var-type GoVar[*.error]">GoVar[*.error]</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">ErrNoProgress is returned by some clients of an io.Reader when<br>
many calls to Read have failed to return any data or error,<br>
usually the sign of a broken io.Reader implementation.<br>
</p>
  
</li>
<li>
  <h3 id="ErrShortBuffer">ErrShortBuffer</h3>
  <span class="var-type GoVar[*.error]">GoVar[*.error]</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">ErrShortBuffer means that a read required a longer buffer than was provided.<br>
</p>
  
</li>
<li>
  <h3 id="ErrShortWrite">ErrShortWrite</h3>
  <span class="var-type GoVar[*.error]">GoVar[*.error]</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">ErrShortWrite means that a write accepted fewer bytes than requested<br>
but failed to return an explicit error.<br>
</p>
  
</li>
<li>
  <h3 id="ErrUnexpectedEOF">ErrUnexpectedEOF</h3>
  <span class="var-type GoVar[*.error]">GoVar[*.error]</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">ErrUnexpectedEOF means that EOF was encountered in the<br>
middle of reading a fixed-size block or data structure.<br>
</p>
  
</li>
<li>
  <h3 id="LimitReader">LimitReader</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(LimitReader __r __n)</code></div>
</pre>
  <p class="var-docstr">LimitReader returns a Reader that reads from r<br>
but stops with EOF after n bytes.<br>
The underlying implementation is a *LimitedReader.<br>
<br>
Go input arguments: (r Reader, n int64)<br>
<br>
Go return type: Reader<br>
<br>
Joker input arguments: [^go.std.io/Reader r, ^Number n]<br>
<br>
Joker return type: go.std.io/Reader</p>
  
</li>
<li>
  <h3 id="NewSectionReader">NewSectionReader</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(NewSectionReader __r __off __n)</code></div>
</pre>
  <p class="var-docstr">NewSectionReader returns a SectionReader that reads from r<br>
starting at offset off and stops with EOF after n bytes.<br>
<br>
Go input arguments: (r ReaderAt, off int64, n int64)<br>
<br>
Go return type: *SectionReader<br>
<br>
Joker input arguments: [^go.std.io/ReaderAt r, ^Number off, ^Number n]<br>
<br>
Joker return type: (atom-of go.std.io/SectionReader)</p>
  
</li>
<li>
  <h3 id="Pipe">Pipe</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Pipe)</code></div>
</pre>
  <p class="var-docstr">Pipe creates a synchronous in-memory pipe.<br>
It can be used to connect code expecting an io.Reader<br>
with code expecting an io.Writer.<br>
<br>
Reads and Writes on the pipe are matched one to one<br>
except when multiple Reads are needed to consume a single Write.<br>
That is, each Write to the PipeWriter blocks until it has satisfied<br>
one or more Reads from the PipeReader that fully consume<br>
the written data.<br>
The data is copied directly from the Write to the corresponding<br>
Read (or Reads); there is no internal buffering.<br>
<br>
It is safe to call Read and Write in parallel with each other or with Close.<br>
Parallel calls to Read and parallel calls to Write are also safe:<br>
the individual calls will be gated sequentially.<br>
<br>
Go return type: (*PipeReader, *PipeWriter)<br>
<br>
Joker input arguments: []<br>
<br>
Joker return type: [(atom-of go.std.io/PipeReader) (atom-of go.std.io/PipeWriter)]</p>
  
</li>
<li>
  <h3 id="PipeReader.">PipeReader.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(PipeReader. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for io.PipeReader</p>
  
</li>
<li>
  <h3 id="PipeWriter.">PipeWriter.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(PipeWriter. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for io.PipeWriter</p>
  
</li>
<li>
  <h3 id="SectionReader.">SectionReader.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(SectionReader. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for io.SectionReader</p>
  
</li>
<li>
  <h3 id="SeekCurrent">SeekCurrent</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">seek relative to the current offset<br>
</p>
  
</li>
<li>
  <h3 id="SeekEnd">SeekEnd</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">seek relative to the end<br>
</p>
  
</li>
<li>
  <h3 id="SeekStart">SeekStart</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">seek relative to the origin of the file<br>
</p>
  
</li>
<li>
  <h3 id="TeeReader">TeeReader</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(TeeReader __r __w)</code></div>
</pre>
  <p class="var-docstr">TeeReader returns a Reader that writes to w what it reads from r.<br>
All reads from r performed through it are matched with<br>
corresponding writes to w. There is no internal buffering -<br>
the write must complete before the read completes.<br>
Any error encountered while writing is reported as a read error.<br>
<br>
Go input arguments: (r Reader, w Writer)<br>
<br>
Go return type: Reader<br>
<br>
Joker input arguments: [^go.std.io/Reader r, ^go.std.io/Writer w]<br>
<br>
Joker return type: go.std.io/Reader</p>
  
</li>
<li>
  <h3 id="WriteString">WriteString</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(WriteString __w __s)</code></div>
</pre>
  <p class="var-docstr">WriteString writes the contents of the string s to w, which accepts a slice of bytes.<br>
If w implements StringWriter, its WriteString method is invoked directly.<br>
Otherwise, w.Write is called exactly once.<br>
<br>
Go input arguments: (w Writer, s string)<br>
<br>
Go return type: (n int, err error)<br>
<br>
Joker input arguments: [^go.std.io/Writer w, ^String s]<br>
<br>
Joker return type: [Int Error]</p>
  
</li>

    </ul>
  </div>
</body>
</html>
