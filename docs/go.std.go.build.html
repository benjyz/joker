<html>
<head>
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
  <div class="main">
    <h1>Namespace: go.std.go.build</h1>
    <span class="var-added">v1.0</span>
    <p class="var-docstr">Provides a low-level interface to the go/build package.<br>
<br>
Package build gathers information about Go packages.<br>
<br>
Go Path<br>
<br>
The Go path is a list of directory trees containing Go source code.<br>
It is consulted to resolve imports that cannot be found in the standard<br>
Go tree. The default path is the value of the GOPATH environment<br>
variable, interpreted as a path list appropriate to the operating system<br>
(on Unix, the variable is a colon-separated string;<br>
on Windows, a semicolon-separated string;<br>
on Plan 9, a list).<br>
<br>
Each directory listed in the Go path must have a prescribed structure:<br>
<br>
The src/ directory holds source code. The path below &#39;src&#39; determines<br>
the import path or executable name.<br>
<br>
The pkg/ directory holds installed package objects.<br>
As in the Go tree, each target operating system and<br>
architecture pair has its own subdirectory of pkg<br>
(pkg/GOOS_GOARCH).<br>
<br>
If DIR is a directory listed in the Go path, a package with<br>
source in DIR/src/foo/bar can be imported as &#34;foo/bar&#34; and<br>
has its compiled form installed to &#34;DIR/pkg/GOOS_GOARCH/foo/bar.a&#34;<br>
(or, for gccgo, &#34;DIR/pkg/gccgo/foo/libbar.a&#34;).<br>
<br>
The bin/ directory holds compiled commands.<br>
Each command is named for its source directory, but only<br>
using the final element, not the entire path. That is, the<br>
command with source in DIR/src/foo/quux is installed into<br>
DIR/bin/quux, not DIR/bin/foo/quux. The foo/ is stripped<br>
so that you can add DIR/bin to your PATH to get at the<br>
installed commands.<br>
<br>
Here&#39;s an example directory layout:<br>
<br>
	GOPATH=/home/user/gocode<br>
<br>
	/home/user/gocode/<br>
	    src/<br>
	        foo/<br>
	            bar/               (go code in package bar)<br>
	                x.go<br>
	            quux/              (go code in package main)<br>
	                y.go<br>
	    bin/<br>
	        quux                   (installed command)<br>
	    pkg/<br>
	        linux_amd64/<br>
	            foo/<br>
	                bar.a          (installed package object)<br>
<br>
Build Constraints<br>
<br>
A build constraint, also known as a build tag, is a line comment that begins<br>
<br>
	// +build<br>
<br>
that lists the conditions under which a file should be included in the package.<br>
Constraints may appear in any kind of source file (not just Go), but<br>
they must appear near the top of the file, preceded<br>
only by blank lines and other line comments. These rules mean that in Go<br>
files a build constraint must appear before the package clause.<br>
<br>
To distinguish build constraints from package documentation, a series of<br>
build constraints must be followed by a blank line.<br>
<br>
A build constraint is evaluated as the OR of space-separated options;<br>
each option evaluates as the AND of its comma-separated terms;<br>
and each term is an alphanumeric word or, preceded by !, its negation.<br>
That is, the build constraint:<br>
<br>
	// +build linux,386 darwin,!cgo<br>
<br>
corresponds to the boolean formula:<br>
<br>
	(linux AND 386) OR (darwin AND (NOT cgo))<br>
<br>
A file may have multiple build constraints. The overall constraint is the AND<br>
of the individual constraints. That is, the build constraints:<br>
<br>
	// +build linux darwin<br>
	// +build 386<br>
<br>
corresponds to the boolean formula:<br>
<br>
	(linux OR darwin) AND 386<br>
<br>
During a particular build, the following words are satisfied:<br>
<br>
	- the target operating system, as spelled by runtime.GOOS<br>
	- the target architecture, as spelled by runtime.GOARCH<br>
	- the compiler being used, either &#34;gc&#34; or &#34;gccgo&#34;<br>
	- &#34;cgo&#34;, if ctxt.CgoEnabled is true<br>
	- &#34;go1.1&#34;, from Go version 1.1 onward<br>
	- &#34;go1.2&#34;, from Go version 1.2 onward<br>
	- &#34;go1.3&#34;, from Go version 1.3 onward<br>
	- &#34;go1.4&#34;, from Go version 1.4 onward<br>
	- &#34;go1.5&#34;, from Go version 1.5 onward<br>
	- &#34;go1.6&#34;, from Go version 1.6 onward<br>
	- &#34;go1.7&#34;, from Go version 1.7 onward<br>
	- &#34;go1.8&#34;, from Go version 1.8 onward<br>
	- &#34;go1.9&#34;, from Go version 1.9 onward<br>
	- &#34;go1.10&#34;, from Go version 1.10 onward<br>
	- &#34;go1.11&#34;, from Go version 1.11 onward<br>
	- &#34;go1.12&#34;, from Go version 1.12 onward<br>
	- any additional words listed in ctxt.BuildTags<br>
<br>
There are no build tags for beta or minor releases.<br>
<br>
If a file&#39;s name, after stripping the extension and a possible _test suffix,<br>
matches any of the following patterns:<br>
	*_GOOS<br>
	*_GOARCH<br>
	*_GOOS_GOARCH<br>
(example: source_windows_amd64.go) where GOOS and GOARCH represent<br>
any known operating system and architecture values respectively, then<br>
the file is considered to have an implicit build constraint requiring<br>
those terms (in addition to any explicit constraints in the file).<br>
<br>
To keep a file from being considered for the build:<br>
<br>
	// +build ignore<br>
<br>
(any other unsatisfied word will work as well, but ``ignore&#39;&#39; is conventional.)<br>
<br>
To build a file only when using cgo, and only on Linux and OS X:<br>
<br>
	// +build linux,cgo darwin,cgo<br>
<br>
Such a file is usually paired with another file implementing the<br>
default functionality for other systems, which in this case would<br>
carry the constraint:<br>
<br>
	// +build !linux,!darwin !cgo<br>
<br>
Naming a file dns_windows.go will cause it to be included only when<br>
building the package for Windows; similarly, math_386.s will be included<br>
only when building the package for 32-bit x86.<br>
<br>
Using GOOS=android matches build tags and files as for GOOS=linux<br>
in addition to android tags and files.<br>
<br>
Binary-Only Packages<br>
<br>
It is possible to distribute packages in binary form without including the<br>
source code used for compiling the package. To do this, the package must<br>
be distributed with a source file not excluded by build constraints and<br>
containing a &#34;//go:binary-only-package&#34; comment.<br>
Like a build constraint, this comment must appear near the top of the file,<br>
preceded only by blank lines and other line comments and with a blank line<br>
following the comment, to separate it from the package documentation.<br>
Unlike build constraints, this comment is only recognized in non-test<br>
Go source files.<br>
<br>
The minimal source code for a binary-only package is therefore:<br>
<br>
	//go:binary-only-package<br>
<br>
	package mypkg<br>
<br>
The source code may include additional Go code. That code is never compiled<br>
but will be processed by tools like godoc and might be useful as end-user<br>
documentation.<br>
</p>
    <h2>Index</h2>
    <ul class="index">
      <li>
  <a href="#AllowBinary">AllowBinary</a>
</li>
<li>
  <a href="#ArchChar">ArchChar</a>
</li>
<li>
  <a href="#Default">Default</a>
</li>
<li>
  <a href="#FindOnly">FindOnly</a>
</li>
<li>
  <a href="#IgnoreVendor">IgnoreVendor</a>
</li>
<li>
  <a href="#Import">Import</a>
</li>
<li>
  <a href="#ImportComment">ImportComment</a>
</li>
<li>
  <a href="#ImportDir">ImportDir</a>
</li>
<li>
  <a href="#ImportMode.">ImportMode.</a>
</li>
<li>
  <a href="#IsLocalImport">IsLocalImport</a>
</li>
<li>
  <a href="#NoGoError.">NoGoError.</a>
</li>
<li>
  <a href="#ToolDir">ToolDir</a>
</li>

    </ul>
    <ul>
      <li>
  <h3 id="AllowBinary">AllowBinary</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">If AllowBinary is set, Import can be satisfied by a compiled<br>
package object without corresponding sources.<br>
<br>
Deprecated:<br>
The supported way to create a compiled-only package is to<br>
write source code containing a //go:binary-only-package comment at<br>
the top of the file. Such a package will be recognized<br>
regardless of this flag setting (because it has source code)<br>
and will have BinaryOnly set to true in the returned Package.<br>
</p>
  
</li>
<li>
  <h3 id="ArchChar">ArchChar</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ArchChar __goarch)</code></div>
</pre>
  <p class="var-docstr">ArchChar returns &#34;?&#34; and an error.<br>
In earlier versions of Go, the returned string was used to derive<br>
the compiler and linker tool names, the default object file suffix,<br>
and the default linker output name. As of Go 1.5, those strings<br>
no longer vary by architecture; they are compile, link, .o, and a.out, respectively.<br>
<br>
Go input arguments: (goarch string)<br>
<br>
Go return type: (string, error)<br>
<br>
Joker input arguments: [^String goarch]<br>
<br>
Joker return type: [String Error]</p>
  
</li>
<li>
  <h3 id="Default">Default</h3>
  <span class="var-type GoVar[*go/build.Context]">GoVar[*go/build.Context]</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">Default is the default Context for builds.<br>
It uses the GOARCH, GOOS, GOROOT, and GOPATH environment variables<br>
if set, or else the compiled code&#39;s GOARCH, GOOS, and GOROOT.<br>
</p>
  
</li>
<li>
  <h3 id="FindOnly">FindOnly</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">If FindOnly is set, Import stops after locating the directory<br>
that should contain the sources for a package. It does not<br>
read any files in the directory.<br>
</p>
  
</li>
<li>
  <h3 id="IgnoreVendor">IgnoreVendor</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">By default, Import searches vendor directories<br>
that apply in the given source directory before searching<br>
the GOROOT and GOPATH roots.<br>
If an Import finds and returns a package using a vendor<br>
directory, the resulting ImportPath is the complete path<br>
to the package, including the path elements leading up<br>
to and including &#34;vendor&#34;.<br>
For example, if Import(&#34;y&#34;, &#34;x/subdir&#34;, 0) finds<br>
&#34;x/vendor/y&#34;, the returned package&#39;s ImportPath is &#34;x/vendor/y&#34;,<br>
not plain &#34;y&#34;.<br>
See golang.org/s/go15vendor for more information.<br>
<br>
Setting IgnoreVendor ignores vendor directories.<br>
<br>
In contrast to the package&#39;s ImportPath,<br>
the returned package&#39;s Imports, TestImports, and XTestImports<br>
are always the exact import paths from the source files:<br>
Import makes no attempt to resolve or check those paths.<br>
</p>
  
</li>
<li>
  <h3 id="Import">Import</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Import __path __srcDir __mode)</code></div>
</pre>
  <p class="var-docstr">Import is shorthand for Default.Import.<br>
<br>
Go input arguments: (path string, srcDir string, mode ImportMode)<br>
<br>
Go return type: (*Package, error)<br>
<br>
Joker input arguments: [^String path, ^String srcDir, ^go.std.go.build/ImportMode mode]<br>
<br>
Joker return type: [(atom-of go.std.go.build/Package) Error]</p>
  
</li>
<li>
  <h3 id="ImportComment">ImportComment</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">If ImportComment is set, parse import comments on package statements.<br>
Import returns an error if it finds a comment it cannot understand<br>
or finds conflicting comments in multiple source files.<br>
See golang.org/s/go14customimport for more information.<br>
</p>
  
</li>
<li>
  <h3 id="ImportDir">ImportDir</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ImportDir __dir __mode)</code></div>
</pre>
  <p class="var-docstr">ImportDir is shorthand for Default.ImportDir.<br>
<br>
Go input arguments: (dir string, mode ImportMode)<br>
<br>
Go return type: (*Package, error)<br>
<br>
Joker input arguments: [^String dir, ^go.std.go.build/ImportMode mode]<br>
<br>
Joker return type: [(atom-of go.std.go.build/Package) Error]</p>
  
</li>
<li>
  <h3 id="ImportMode.">ImportMode.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ImportMode. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for build.ImportMode</p>
  
</li>
<li>
  <h3 id="IsLocalImport">IsLocalImport</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(IsLocalImport __path)</code></div>
</pre>
  <p class="var-docstr">IsLocalImport reports whether the import path is<br>
a local import path, like &#34;.&#34;, &#34;..&#34;, &#34;./foo&#34;, or &#34;../foo&#34;.<br>
<br>
Go input arguments: (path string)<br>
<br>
Go return type: bool<br>
<br>
Joker input arguments: [^String path]<br>
<br>
Joker return type: Boolean</p>
  
</li>
<li>
  <h3 id="NoGoError.">NoGoError.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(NoGoError. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for build.NoGoError</p>
  
</li>
<li>
  <h3 id="ToolDir">ToolDir</h3>
  <span class="var-type GoVar[*.string]">GoVar[*.string]</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">ToolDir is the directory containing build tools.<br>
</p>
  
</li>

    </ul>
  </div>
</body>
</html>
