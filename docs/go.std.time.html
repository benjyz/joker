<html>
<head>
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
  <div class="main">
    <h1>Namespace: go.std.time</h1>
    <span class="var-added">v1.0</span>
    <p class="var-docstr">Provides a low-level interface to the time package.<br>
<br>
Package time provides functionality for measuring and displaying time.<br>
<br>
The calendrical calculations always assume a Gregorian calendar, with<br>
no leap seconds.<br>
<br>
Monotonic Clocks<br>
<br>
Operating systems provide both a “wall clock,” which is subject to<br>
changes for clock synchronization, and a “monotonic clock,” which is<br>
not. The general rule is that the wall clock is for telling time and<br>
the monotonic clock is for measuring time. Rather than split the API,<br>
in this package the Time returned by time.Now contains both a wall<br>
clock reading and a monotonic clock reading; later time-telling<br>
operations use the wall clock reading, but later time-measuring<br>
operations, specifically comparisons and subtractions, use the<br>
monotonic clock reading.<br>
<br>
For example, this code always computes a positive elapsed time of<br>
approximately 20 milliseconds, even if the wall clock is changed during<br>
the operation being timed:<br>
<br>
	start := time.Now()<br>
	... operation that takes 20 milliseconds ...<br>
	t := time.Now()<br>
	elapsed := t.Sub(start)<br>
<br>
Other idioms, such as time.Since(start), time.Until(deadline), and<br>
time.Now().Before(deadline), are similarly robust against wall clock<br>
resets.<br>
<br>
The rest of this section gives the precise details of how operations<br>
use monotonic clocks, but understanding those details is not required<br>
to use this package.<br>
<br>
The Time returned by time.Now contains a monotonic clock reading.<br>
If Time t has a monotonic clock reading, t.Add adds the same duration to<br>
both the wall clock and monotonic clock readings to compute the result.<br>
Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time<br>
computations, they always strip any monotonic clock reading from their results.<br>
Because t.In, t.Local, and t.UTC are used for their effect on the interpretation<br>
of the wall time, they also strip any monotonic clock reading from their results.<br>
The canonical way to strip a monotonic clock reading is to use t = t.Round(0).<br>
<br>
If Times t and u both contain monotonic clock readings, the operations<br>
t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out<br>
using the monotonic clock readings alone, ignoring the wall clock<br>
readings. If either t or u contains no monotonic clock reading, these<br>
operations fall back to using the wall clock readings.<br>
<br>
On some systems the monotonic clock will stop if the computer goes to sleep.<br>
On such a system, t.Sub(u) may not accurately reflect the actual<br>
time that passed between t and u.<br>
<br>
Because the monotonic clock reading has no meaning outside<br>
the current process, the serialized forms generated by t.GobEncode,<br>
t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic<br>
clock reading, and t.Format provides no format for it. Similarly, the<br>
constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix,<br>
as well as the unmarshalers t.GobDecode, t.UnmarshalBinary.<br>
t.UnmarshalJSON, and t.UnmarshalText always create times with<br>
no monotonic clock reading.<br>
<br>
Note that the Go == operator compares not just the time instant but<br>
also the Location and the monotonic clock reading. See the<br>
documentation for the Time type for a discussion of equality<br>
testing for Time values.<br>
<br>
For debugging, the result of t.String does include the monotonic<br>
clock reading if present. If t != u because of different monotonic clock readings,<br>
that difference will be visible when printing t.String() and u.String().<br>
</p>
    <h2>Index</h2>
    <ul class="index">
      <li>
  <a href="#ANSIC">ANSIC</a>
</li>
<li>
  <a href="#April">April</a>
</li>
<li>
  <a href="#August">August</a>
</li>
<li>
  <a href="#Date">Date</a>
</li>
<li>
  <a href="#December">December</a>
</li>
<li>
  <a href="#Duration.">Duration.</a>
</li>
<li>
  <a href="#February">February</a>
</li>
<li>
  <a href="#FixedZone">FixedZone</a>
</li>
<li>
  <a href="#Friday">Friday</a>
</li>
<li>
  <a href="#Hour">Hour</a>
</li>
<li>
  <a href="#January">January</a>
</li>
<li>
  <a href="#July">July</a>
</li>
<li>
  <a href="#June">June</a>
</li>
<li>
  <a href="#Kitchen">Kitchen</a>
</li>
<li>
  <a href="#LoadLocation">LoadLocation</a>
</li>
<li>
  <a href="#Local">Local</a>
</li>
<li>
  <a href="#Location.">Location.</a>
</li>
<li>
  <a href="#March">March</a>
</li>
<li>
  <a href="#May">May</a>
</li>
<li>
  <a href="#Microsecond">Microsecond</a>
</li>
<li>
  <a href="#Millisecond">Millisecond</a>
</li>
<li>
  <a href="#Minute">Minute</a>
</li>
<li>
  <a href="#Monday">Monday</a>
</li>
<li>
  <a href="#Month.">Month.</a>
</li>
<li>
  <a href="#Nanosecond">Nanosecond</a>
</li>
<li>
  <a href="#NewTicker">NewTicker</a>
</li>
<li>
  <a href="#NewTimer">NewTimer</a>
</li>
<li>
  <a href="#November">November</a>
</li>
<li>
  <a href="#Now">Now</a>
</li>
<li>
  <a href="#October">October</a>
</li>
<li>
  <a href="#Parse">Parse</a>
</li>
<li>
  <a href="#ParseDuration">ParseDuration</a>
</li>
<li>
  <a href="#ParseError.">ParseError.</a>
</li>
<li>
  <a href="#ParseInLocation">ParseInLocation</a>
</li>
<li>
  <a href="#RFC1123">RFC1123</a>
</li>
<li>
  <a href="#RFC1123Z">RFC1123Z</a>
</li>
<li>
  <a href="#RFC3339">RFC3339</a>
</li>
<li>
  <a href="#RFC3339Nano">RFC3339Nano</a>
</li>
<li>
  <a href="#RFC822">RFC822</a>
</li>
<li>
  <a href="#RFC822Z">RFC822Z</a>
</li>
<li>
  <a href="#RFC850">RFC850</a>
</li>
<li>
  <a href="#RubyDate">RubyDate</a>
</li>
<li>
  <a href="#Saturday">Saturday</a>
</li>
<li>
  <a href="#Second">Second</a>
</li>
<li>
  <a href="#September">September</a>
</li>
<li>
  <a href="#Since">Since</a>
</li>
<li>
  <a href="#Stamp">Stamp</a>
</li>
<li>
  <a href="#StampMicro">StampMicro</a>
</li>
<li>
  <a href="#StampMilli">StampMilli</a>
</li>
<li>
  <a href="#StampNano">StampNano</a>
</li>
<li>
  <a href="#Sunday">Sunday</a>
</li>
<li>
  <a href="#Thursday">Thursday</a>
</li>
<li>
  <a href="#Time.">Time.</a>
</li>
<li>
  <a href="#Tuesday">Tuesday</a>
</li>
<li>
  <a href="#UTC">UTC</a>
</li>
<li>
  <a href="#Unix">Unix</a>
</li>
<li>
  <a href="#UnixDate">UnixDate</a>
</li>
<li>
  <a href="#Until">Until</a>
</li>
<li>
  <a href="#Wednesday">Wednesday</a>
</li>
<li>
  <a href="#Weekday.">Weekday.</a>
</li>

    </ul>
    <ul>
      <li>
  <h3 id="ANSIC">ANSIC</h3>
  <span class="var-type String">String</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">These are predefined layouts for use in Time.Format and time.Parse.<br>
The reference time used in the layouts is the specific time:<br>
	Mon Jan 2 15:04:05 MST 2006<br>
which is Unix time 1136239445. Since MST is GMT-0700,<br>
the reference time can be thought of as<br>
	01/02 03:04:05PM &#39;06 -0700<br>
To define your own format, write down what the reference time would look<br>
like formatted your way; see the values of constants like ANSIC,<br>
StampMicro or Kitchen for examples. The model is to demonstrate what the<br>
reference time looks like so that the Format and Parse methods can apply<br>
the same transformation to a general time value.<br>
<br>
Some valid layouts are invalid time values for time.Parse, due to formats<br>
such as _ for space padding and Z for zone information.<br>
<br>
Within the format string, an underscore _ represents a space that may be<br>
replaced by a digit if the following number (a day) has two digits; for<br>
compatibility with fixed-width Unix time formats.<br>
<br>
A decimal point followed by one or more zeros represents a fractional<br>
second, printed to the given number of decimal places. A decimal point<br>
followed by one or more nines represents a fractional second, printed to<br>
the given number of decimal places, with trailing zeros removed.<br>
When parsing (only), the input may contain a fractional second<br>
field immediately after the seconds field, even if the layout does not<br>
signify its presence. In that case a decimal point followed by a maximal<br>
series of digits is parsed as a fractional second.<br>
<br>
Numeric time zone offsets format as follows:<br>
	-0700  ±hhmm<br>
	-07:00 ±hh:mm<br>
	-07    ±hh<br>
Replacing the sign in the format with a Z triggers<br>
the ISO 8601 behavior of printing Z instead of an<br>
offset for the UTC zone. Thus:<br>
	Z0700  Z or ±hhmm<br>
	Z07:00 Z or ±hh:mm<br>
	Z07    Z or ±hh<br>
<br>
The recognized day of week formats are &#34;Mon&#34; and &#34;Monday&#34;.<br>
The recognized month formats are &#34;Jan&#34; and &#34;January&#34;.<br>
<br>
Text in the format string that is not recognized as part of the reference<br>
time is echoed verbatim during Format and expected to appear verbatim<br>
in the input to Parse.<br>
<br>
The executable example for Time.Format demonstrates the working<br>
of the layout string in detail and is a good reference.<br>
<br>
Note that the RFC822, RFC850, and RFC1123 formats should be applied<br>
only to local times. Applying them to UTC times will use &#34;UTC&#34; as the<br>
time zone abbreviation, while strictly speaking those RFCs require the<br>
use of &#34;GMT&#34; in that case.<br>
In general RFC1123Z should be used instead of RFC1123 for servers<br>
that insist on that format, and RFC3339 should be preferred for new protocols.<br>
RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;<br>
when used with time.Parse they do not accept all the time formats<br>
permitted by the RFCs.<br>
The RFC3339Nano format removes trailing zeros from the seconds field<br>
and thus may not sort correctly once formatted.<br>
</p>
  
</li>
<li>
  <h3 id="April">April</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="August">August</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Date">Date</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Date __year __month __day __hour __min __sec __nsec __loc)</code></div>
</pre>
  <p class="var-docstr">Date returns the Time corresponding to<br>
	yyyy-mm-dd hh:mm:ss + nsec nanoseconds<br>
in the appropriate zone for that time in the given location.<br>
<br>
The month, day, hour, min, sec, and nsec values may be outside<br>
their usual ranges and will be normalized during the conversion.<br>
For example, October 32 converts to November 1.<br>
<br>
A daylight savings time transition skips or repeats times.<br>
For example, in the United States, March 13, 2011 2:15am never occurred,<br>
while November 6, 2011 1:15am occurred twice. In such cases, the<br>
choice of time zone, and therefore the time, is not well-defined.<br>
Date returns a time that is correct in one of the two zones involved<br>
in the transition, but it does not guarantee which.<br>
<br>
Date panics if loc is nil.<br>
<br>
Go input arguments: (year int, month Month, day int, hour int, min int, sec int, nsec int, loc *Location)<br>
<br>
Go return type: Time<br>
<br>
Joker input arguments: [^Int year, ^go.std.time/Month month, ^Int day, ^Int hour, ^Int min, ^Int sec, ^Int nsec, ^(atom-of go.std.time/Location) loc]<br>
<br>
Joker return type: go.std.time/Time</p>
  
</li>
<li>
  <h3 id="December">December</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Duration.">Duration.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Duration. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for time.Duration</p>
  
</li>
<li>
  <h3 id="February">February</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="FixedZone">FixedZone</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(FixedZone __name __offset)</code></div>
</pre>
  <p class="var-docstr">FixedZone returns a Location that always uses<br>
the given zone name and offset (seconds east of UTC).<br>
<br>
Go input arguments: (name string, offset int)<br>
<br>
Go return type: *Location<br>
<br>
Joker input arguments: [^String name, ^Int offset]<br>
<br>
Joker return type: (atom-of go.std.time/Location)</p>
  
</li>
<li>
  <h3 id="Friday">Friday</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Hour">Hour</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">Common durations. There is no definition for units of Day or larger<br>
to avoid confusion across daylight savings time zone transitions.<br>
<br>
To count the number of units in a Duration, divide:<br>
	second := time.Second<br>
	fmt.Print(int64(second/time.Millisecond)) // prints 1000<br>
<br>
To convert an integer number of units to a Duration, multiply:<br>
	seconds := 10<br>
	fmt.Print(time.Duration(seconds)*time.Second) // prints 10s<br>
</p>
  
</li>
<li>
  <h3 id="January">January</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="July">July</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="June">June</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Kitchen">Kitchen</h3>
  <span class="var-type String">String</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">These are predefined layouts for use in Time.Format and time.Parse.<br>
The reference time used in the layouts is the specific time:<br>
	Mon Jan 2 15:04:05 MST 2006<br>
which is Unix time 1136239445. Since MST is GMT-0700,<br>
the reference time can be thought of as<br>
	01/02 03:04:05PM &#39;06 -0700<br>
To define your own format, write down what the reference time would look<br>
like formatted your way; see the values of constants like ANSIC,<br>
StampMicro or Kitchen for examples. The model is to demonstrate what the<br>
reference time looks like so that the Format and Parse methods can apply<br>
the same transformation to a general time value.<br>
<br>
Some valid layouts are invalid time values for time.Parse, due to formats<br>
such as _ for space padding and Z for zone information.<br>
<br>
Within the format string, an underscore _ represents a space that may be<br>
replaced by a digit if the following number (a day) has two digits; for<br>
compatibility with fixed-width Unix time formats.<br>
<br>
A decimal point followed by one or more zeros represents a fractional<br>
second, printed to the given number of decimal places. A decimal point<br>
followed by one or more nines represents a fractional second, printed to<br>
the given number of decimal places, with trailing zeros removed.<br>
When parsing (only), the input may contain a fractional second<br>
field immediately after the seconds field, even if the layout does not<br>
signify its presence. In that case a decimal point followed by a maximal<br>
series of digits is parsed as a fractional second.<br>
<br>
Numeric time zone offsets format as follows:<br>
	-0700  ±hhmm<br>
	-07:00 ±hh:mm<br>
	-07    ±hh<br>
Replacing the sign in the format with a Z triggers<br>
the ISO 8601 behavior of printing Z instead of an<br>
offset for the UTC zone. Thus:<br>
	Z0700  Z or ±hhmm<br>
	Z07:00 Z or ±hh:mm<br>
	Z07    Z or ±hh<br>
<br>
The recognized day of week formats are &#34;Mon&#34; and &#34;Monday&#34;.<br>
The recognized month formats are &#34;Jan&#34; and &#34;January&#34;.<br>
<br>
Text in the format string that is not recognized as part of the reference<br>
time is echoed verbatim during Format and expected to appear verbatim<br>
in the input to Parse.<br>
<br>
The executable example for Time.Format demonstrates the working<br>
of the layout string in detail and is a good reference.<br>
<br>
Note that the RFC822, RFC850, and RFC1123 formats should be applied<br>
only to local times. Applying them to UTC times will use &#34;UTC&#34; as the<br>
time zone abbreviation, while strictly speaking those RFCs require the<br>
use of &#34;GMT&#34; in that case.<br>
In general RFC1123Z should be used instead of RFC1123 for servers<br>
that insist on that format, and RFC3339 should be preferred for new protocols.<br>
RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;<br>
when used with time.Parse they do not accept all the time formats<br>
permitted by the RFCs.<br>
The RFC3339Nano format removes trailing zeros from the seconds field<br>
and thus may not sort correctly once formatted.<br>
</p>
  
</li>
<li>
  <h3 id="LoadLocation">LoadLocation</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(LoadLocation __name)</code></div>
</pre>
  <p class="var-docstr">LoadLocation returns the Location with the given name.<br>
<br>
If the name is &#34;&#34; or &#34;UTC&#34;, LoadLocation returns UTC.<br>
If the name is &#34;Local&#34;, LoadLocation returns Local.<br>
<br>
Otherwise, the name is taken to be a location name corresponding to a file<br>
in the IANA Time Zone database, such as &#34;America/New_York&#34;.<br>
<br>
The time zone database needed by LoadLocation may not be<br>
present on all systems, especially non-Unix systems.<br>
LoadLocation looks in the directory or uncompressed zip file<br>
named by the ZONEINFO environment variable, if any, then looks in<br>
known installation locations on Unix systems,<br>
and finally looks in $GOROOT/lib/time/zoneinfo.zip.<br>
<br>
Go input arguments: (name string)<br>
<br>
Go return type: (*Location, error)<br>
<br>
Joker input arguments: [^String name]<br>
<br>
Joker return type: [(atom-of go.std.time/Location) Error]</p>
  
</li>
<li>
  <h3 id="Local">Local</h3>
  <span class="var-type GoVar[**time.Location]">GoVar[**time.Location]</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">Local represents the system&#39;s local time zone.<br>
</p>
  
</li>
<li>
  <h3 id="Location.">Location.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Location. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for time.Location</p>
  
</li>
<li>
  <h3 id="March">March</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="May">May</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Microsecond">Microsecond</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">Common durations. There is no definition for units of Day or larger<br>
to avoid confusion across daylight savings time zone transitions.<br>
<br>
To count the number of units in a Duration, divide:<br>
	second := time.Second<br>
	fmt.Print(int64(second/time.Millisecond)) // prints 1000<br>
<br>
To convert an integer number of units to a Duration, multiply:<br>
	seconds := 10<br>
	fmt.Print(time.Duration(seconds)*time.Second) // prints 10s<br>
</p>
  
</li>
<li>
  <h3 id="Millisecond">Millisecond</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">Common durations. There is no definition for units of Day or larger<br>
to avoid confusion across daylight savings time zone transitions.<br>
<br>
To count the number of units in a Duration, divide:<br>
	second := time.Second<br>
	fmt.Print(int64(second/time.Millisecond)) // prints 1000<br>
<br>
To convert an integer number of units to a Duration, multiply:<br>
	seconds := 10<br>
	fmt.Print(time.Duration(seconds)*time.Second) // prints 10s<br>
</p>
  
</li>
<li>
  <h3 id="Minute">Minute</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">Common durations. There is no definition for units of Day or larger<br>
to avoid confusion across daylight savings time zone transitions.<br>
<br>
To count the number of units in a Duration, divide:<br>
	second := time.Second<br>
	fmt.Print(int64(second/time.Millisecond)) // prints 1000<br>
<br>
To convert an integer number of units to a Duration, multiply:<br>
	seconds := 10<br>
	fmt.Print(time.Duration(seconds)*time.Second) // prints 10s<br>
</p>
  
</li>
<li>
  <h3 id="Monday">Monday</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Month.">Month.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Month. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for time.Month</p>
  
</li>
<li>
  <h3 id="Nanosecond">Nanosecond</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">Common durations. There is no definition for units of Day or larger<br>
to avoid confusion across daylight savings time zone transitions.<br>
<br>
To count the number of units in a Duration, divide:<br>
	second := time.Second<br>
	fmt.Print(int64(second/time.Millisecond)) // prints 1000<br>
<br>
To convert an integer number of units to a Duration, multiply:<br>
	seconds := 10<br>
	fmt.Print(time.Duration(seconds)*time.Second) // prints 10s<br>
</p>
  
</li>
<li>
  <h3 id="NewTicker">NewTicker</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(NewTicker __d)</code></div>
</pre>
  <p class="var-docstr">NewTicker returns a new Ticker containing a channel that will send the<br>
time with a period specified by the duration argument.<br>
It adjusts the intervals or drops ticks to make up for slow receivers.<br>
The duration d must be greater than zero; if not, NewTicker will panic.<br>
Stop the ticker to release associated resources.<br>
<br>
Go input arguments: (d Duration)<br>
<br>
Go return type: *Ticker<br>
<br>
Joker input arguments: [^go.std.time/Duration d]<br>
<br>
Joker return type: (atom-of go.std.time/Ticker)</p>
  
</li>
<li>
  <h3 id="NewTimer">NewTimer</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(NewTimer __d)</code></div>
</pre>
  <p class="var-docstr">NewTimer creates a new Timer that will send<br>
the current time on its channel after at least duration d.<br>
<br>
Go input arguments: (d Duration)<br>
<br>
Go return type: *Timer<br>
<br>
Joker input arguments: [^go.std.time/Duration d]<br>
<br>
Joker return type: (atom-of go.std.time/Timer)</p>
  
</li>
<li>
  <h3 id="November">November</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Now">Now</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Now)</code></div>
</pre>
  <p class="var-docstr">Now returns the current local time.<br>
<br>
Go return type: Time<br>
<br>
Joker input arguments: []<br>
<br>
Joker return type: go.std.time/Time</p>
  
</li>
<li>
  <h3 id="October">October</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Parse">Parse</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Parse __layout __value)</code></div>
</pre>
  <p class="var-docstr">Parse parses a formatted string and returns the time value it represents.<br>
The layout defines the format by showing how the reference time,<br>
defined to be<br>
	Mon Jan 2 15:04:05 -0700 MST 2006<br>
would be interpreted if it were the value; it serves as an example of<br>
the input format. The same interpretation will then be made to the<br>
input string.<br>
<br>
Predefined layouts ANSIC, UnixDate, RFC3339 and others describe standard<br>
and convenient representations of the reference time. For more information<br>
about the formats and the definition of the reference time, see the<br>
documentation for ANSIC and the other constants defined by this package.<br>
Also, the executable example for Time.Format demonstrates the working<br>
of the layout string in detail and is a good reference.<br>
<br>
Elements omitted from the value are assumed to be zero or, when<br>
zero is impossible, one, so parsing &#34;3:04pm&#34; returns the time<br>
corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is<br>
0, this time is before the zero Time).<br>
Years must be in the range 0000..9999. The day of the week is checked<br>
for syntax but it is otherwise ignored.<br>
<br>
In the absence of a time zone indicator, Parse returns a time in UTC.<br>
<br>
When parsing a time with a zone offset like -0700, if the offset corresponds<br>
to a time zone used by the current location (Local), then Parse uses that<br>
location and zone in the returned time. Otherwise it records the time as<br>
being in a fabricated location with time fixed at the given zone offset.<br>
<br>
When parsing a time with a zone abbreviation like MST, if the zone abbreviation<br>
has a defined offset in the current location, then that offset is used.<br>
The zone abbreviation &#34;UTC&#34; is recognized as UTC regardless of location.<br>
If the zone abbreviation is unknown, Parse records the time as being<br>
in a fabricated location with the given zone abbreviation and a zero offset.<br>
This choice means that such a time can be parsed and reformatted with the<br>
same layout losslessly, but the exact instant used in the representation will<br>
differ by the actual zone offset. To avoid such problems, prefer time layouts<br>
that use a numeric zone offset, or use ParseInLocation.<br>
<br>
Go input arguments: (layout string, value string)<br>
<br>
Go return type: (Time, error)<br>
<br>
Joker input arguments: [^String layout, ^String value]<br>
<br>
Joker return type: [go.std.time/Time Error]</p>
  
</li>
<li>
  <h3 id="ParseDuration">ParseDuration</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ParseDuration __s)</code></div>
</pre>
  <p class="var-docstr">ParseDuration parses a duration string.<br>
A duration string is a possibly signed sequence of<br>
decimal numbers, each with optional fraction and a unit suffix,<br>
such as &#34;300ms&#34;, &#34;-1.5h&#34; or &#34;2h45m&#34;.<br>
Valid time units are &#34;ns&#34;, &#34;us&#34; (or &#34;µs&#34;), &#34;ms&#34;, &#34;s&#34;, &#34;m&#34;, &#34;h&#34;.<br>
<br>
Go input arguments: (s string)<br>
<br>
Go return type: (Duration, error)<br>
<br>
Joker input arguments: [^String s]<br>
<br>
Joker return type: [go.std.time/Duration Error]</p>
  
</li>
<li>
  <h3 id="ParseError.">ParseError.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ParseError. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for time.ParseError</p>
  
</li>
<li>
  <h3 id="ParseInLocation">ParseInLocation</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ParseInLocation __layout __value __loc)</code></div>
</pre>
  <p class="var-docstr">ParseInLocation is like Parse but differs in two important ways.<br>
First, in the absence of time zone information, Parse interprets a time as UTC;<br>
ParseInLocation interprets the time as in the given location.<br>
Second, when given a zone offset or abbreviation, Parse tries to match it<br>
against the Local location; ParseInLocation uses the given location.<br>
<br>
Go input arguments: (layout string, value string, loc *Location)<br>
<br>
Go return type: (Time, error)<br>
<br>
Joker input arguments: [^String layout, ^String value, ^(atom-of go.std.time/Location) loc]<br>
<br>
Joker return type: [go.std.time/Time Error]</p>
  
</li>
<li>
  <h3 id="RFC1123">RFC1123</h3>
  <span class="var-type String">String</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">These are predefined layouts for use in Time.Format and time.Parse.<br>
The reference time used in the layouts is the specific time:<br>
	Mon Jan 2 15:04:05 MST 2006<br>
which is Unix time 1136239445. Since MST is GMT-0700,<br>
the reference time can be thought of as<br>
	01/02 03:04:05PM &#39;06 -0700<br>
To define your own format, write down what the reference time would look<br>
like formatted your way; see the values of constants like ANSIC,<br>
StampMicro or Kitchen for examples. The model is to demonstrate what the<br>
reference time looks like so that the Format and Parse methods can apply<br>
the same transformation to a general time value.<br>
<br>
Some valid layouts are invalid time values for time.Parse, due to formats<br>
such as _ for space padding and Z for zone information.<br>
<br>
Within the format string, an underscore _ represents a space that may be<br>
replaced by a digit if the following number (a day) has two digits; for<br>
compatibility with fixed-width Unix time formats.<br>
<br>
A decimal point followed by one or more zeros represents a fractional<br>
second, printed to the given number of decimal places. A decimal point<br>
followed by one or more nines represents a fractional second, printed to<br>
the given number of decimal places, with trailing zeros removed.<br>
When parsing (only), the input may contain a fractional second<br>
field immediately after the seconds field, even if the layout does not<br>
signify its presence. In that case a decimal point followed by a maximal<br>
series of digits is parsed as a fractional second.<br>
<br>
Numeric time zone offsets format as follows:<br>
	-0700  ±hhmm<br>
	-07:00 ±hh:mm<br>
	-07    ±hh<br>
Replacing the sign in the format with a Z triggers<br>
the ISO 8601 behavior of printing Z instead of an<br>
offset for the UTC zone. Thus:<br>
	Z0700  Z or ±hhmm<br>
	Z07:00 Z or ±hh:mm<br>
	Z07    Z or ±hh<br>
<br>
The recognized day of week formats are &#34;Mon&#34; and &#34;Monday&#34;.<br>
The recognized month formats are &#34;Jan&#34; and &#34;January&#34;.<br>
<br>
Text in the format string that is not recognized as part of the reference<br>
time is echoed verbatim during Format and expected to appear verbatim<br>
in the input to Parse.<br>
<br>
The executable example for Time.Format demonstrates the working<br>
of the layout string in detail and is a good reference.<br>
<br>
Note that the RFC822, RFC850, and RFC1123 formats should be applied<br>
only to local times. Applying them to UTC times will use &#34;UTC&#34; as the<br>
time zone abbreviation, while strictly speaking those RFCs require the<br>
use of &#34;GMT&#34; in that case.<br>
In general RFC1123Z should be used instead of RFC1123 for servers<br>
that insist on that format, and RFC3339 should be preferred for new protocols.<br>
RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;<br>
when used with time.Parse they do not accept all the time formats<br>
permitted by the RFCs.<br>
The RFC3339Nano format removes trailing zeros from the seconds field<br>
and thus may not sort correctly once formatted.<br>
</p>
  
</li>
<li>
  <h3 id="RFC1123Z">RFC1123Z</h3>
  <span class="var-type String">String</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">RFC1123 with numeric zone<br>
</p>
  
</li>
<li>
  <h3 id="RFC3339">RFC3339</h3>
  <span class="var-type String">String</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">These are predefined layouts for use in Time.Format and time.Parse.<br>
The reference time used in the layouts is the specific time:<br>
	Mon Jan 2 15:04:05 MST 2006<br>
which is Unix time 1136239445. Since MST is GMT-0700,<br>
the reference time can be thought of as<br>
	01/02 03:04:05PM &#39;06 -0700<br>
To define your own format, write down what the reference time would look<br>
like formatted your way; see the values of constants like ANSIC,<br>
StampMicro or Kitchen for examples. The model is to demonstrate what the<br>
reference time looks like so that the Format and Parse methods can apply<br>
the same transformation to a general time value.<br>
<br>
Some valid layouts are invalid time values for time.Parse, due to formats<br>
such as _ for space padding and Z for zone information.<br>
<br>
Within the format string, an underscore _ represents a space that may be<br>
replaced by a digit if the following number (a day) has two digits; for<br>
compatibility with fixed-width Unix time formats.<br>
<br>
A decimal point followed by one or more zeros represents a fractional<br>
second, printed to the given number of decimal places. A decimal point<br>
followed by one or more nines represents a fractional second, printed to<br>
the given number of decimal places, with trailing zeros removed.<br>
When parsing (only), the input may contain a fractional second<br>
field immediately after the seconds field, even if the layout does not<br>
signify its presence. In that case a decimal point followed by a maximal<br>
series of digits is parsed as a fractional second.<br>
<br>
Numeric time zone offsets format as follows:<br>
	-0700  ±hhmm<br>
	-07:00 ±hh:mm<br>
	-07    ±hh<br>
Replacing the sign in the format with a Z triggers<br>
the ISO 8601 behavior of printing Z instead of an<br>
offset for the UTC zone. Thus:<br>
	Z0700  Z or ±hhmm<br>
	Z07:00 Z or ±hh:mm<br>
	Z07    Z or ±hh<br>
<br>
The recognized day of week formats are &#34;Mon&#34; and &#34;Monday&#34;.<br>
The recognized month formats are &#34;Jan&#34; and &#34;January&#34;.<br>
<br>
Text in the format string that is not recognized as part of the reference<br>
time is echoed verbatim during Format and expected to appear verbatim<br>
in the input to Parse.<br>
<br>
The executable example for Time.Format demonstrates the working<br>
of the layout string in detail and is a good reference.<br>
<br>
Note that the RFC822, RFC850, and RFC1123 formats should be applied<br>
only to local times. Applying them to UTC times will use &#34;UTC&#34; as the<br>
time zone abbreviation, while strictly speaking those RFCs require the<br>
use of &#34;GMT&#34; in that case.<br>
In general RFC1123Z should be used instead of RFC1123 for servers<br>
that insist on that format, and RFC3339 should be preferred for new protocols.<br>
RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;<br>
when used with time.Parse they do not accept all the time formats<br>
permitted by the RFCs.<br>
The RFC3339Nano format removes trailing zeros from the seconds field<br>
and thus may not sort correctly once formatted.<br>
</p>
  
</li>
<li>
  <h3 id="RFC3339Nano">RFC3339Nano</h3>
  <span class="var-type String">String</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">These are predefined layouts for use in Time.Format and time.Parse.<br>
The reference time used in the layouts is the specific time:<br>
	Mon Jan 2 15:04:05 MST 2006<br>
which is Unix time 1136239445. Since MST is GMT-0700,<br>
the reference time can be thought of as<br>
	01/02 03:04:05PM &#39;06 -0700<br>
To define your own format, write down what the reference time would look<br>
like formatted your way; see the values of constants like ANSIC,<br>
StampMicro or Kitchen for examples. The model is to demonstrate what the<br>
reference time looks like so that the Format and Parse methods can apply<br>
the same transformation to a general time value.<br>
<br>
Some valid layouts are invalid time values for time.Parse, due to formats<br>
such as _ for space padding and Z for zone information.<br>
<br>
Within the format string, an underscore _ represents a space that may be<br>
replaced by a digit if the following number (a day) has two digits; for<br>
compatibility with fixed-width Unix time formats.<br>
<br>
A decimal point followed by one or more zeros represents a fractional<br>
second, printed to the given number of decimal places. A decimal point<br>
followed by one or more nines represents a fractional second, printed to<br>
the given number of decimal places, with trailing zeros removed.<br>
When parsing (only), the input may contain a fractional second<br>
field immediately after the seconds field, even if the layout does not<br>
signify its presence. In that case a decimal point followed by a maximal<br>
series of digits is parsed as a fractional second.<br>
<br>
Numeric time zone offsets format as follows:<br>
	-0700  ±hhmm<br>
	-07:00 ±hh:mm<br>
	-07    ±hh<br>
Replacing the sign in the format with a Z triggers<br>
the ISO 8601 behavior of printing Z instead of an<br>
offset for the UTC zone. Thus:<br>
	Z0700  Z or ±hhmm<br>
	Z07:00 Z or ±hh:mm<br>
	Z07    Z or ±hh<br>
<br>
The recognized day of week formats are &#34;Mon&#34; and &#34;Monday&#34;.<br>
The recognized month formats are &#34;Jan&#34; and &#34;January&#34;.<br>
<br>
Text in the format string that is not recognized as part of the reference<br>
time is echoed verbatim during Format and expected to appear verbatim<br>
in the input to Parse.<br>
<br>
The executable example for Time.Format demonstrates the working<br>
of the layout string in detail and is a good reference.<br>
<br>
Note that the RFC822, RFC850, and RFC1123 formats should be applied<br>
only to local times. Applying them to UTC times will use &#34;UTC&#34; as the<br>
time zone abbreviation, while strictly speaking those RFCs require the<br>
use of &#34;GMT&#34; in that case.<br>
In general RFC1123Z should be used instead of RFC1123 for servers<br>
that insist on that format, and RFC3339 should be preferred for new protocols.<br>
RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;<br>
when used with time.Parse they do not accept all the time formats<br>
permitted by the RFCs.<br>
The RFC3339Nano format removes trailing zeros from the seconds field<br>
and thus may not sort correctly once formatted.<br>
</p>
  
</li>
<li>
  <h3 id="RFC822">RFC822</h3>
  <span class="var-type String">String</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">These are predefined layouts for use in Time.Format and time.Parse.<br>
The reference time used in the layouts is the specific time:<br>
	Mon Jan 2 15:04:05 MST 2006<br>
which is Unix time 1136239445. Since MST is GMT-0700,<br>
the reference time can be thought of as<br>
	01/02 03:04:05PM &#39;06 -0700<br>
To define your own format, write down what the reference time would look<br>
like formatted your way; see the values of constants like ANSIC,<br>
StampMicro or Kitchen for examples. The model is to demonstrate what the<br>
reference time looks like so that the Format and Parse methods can apply<br>
the same transformation to a general time value.<br>
<br>
Some valid layouts are invalid time values for time.Parse, due to formats<br>
such as _ for space padding and Z for zone information.<br>
<br>
Within the format string, an underscore _ represents a space that may be<br>
replaced by a digit if the following number (a day) has two digits; for<br>
compatibility with fixed-width Unix time formats.<br>
<br>
A decimal point followed by one or more zeros represents a fractional<br>
second, printed to the given number of decimal places. A decimal point<br>
followed by one or more nines represents a fractional second, printed to<br>
the given number of decimal places, with trailing zeros removed.<br>
When parsing (only), the input may contain a fractional second<br>
field immediately after the seconds field, even if the layout does not<br>
signify its presence. In that case a decimal point followed by a maximal<br>
series of digits is parsed as a fractional second.<br>
<br>
Numeric time zone offsets format as follows:<br>
	-0700  ±hhmm<br>
	-07:00 ±hh:mm<br>
	-07    ±hh<br>
Replacing the sign in the format with a Z triggers<br>
the ISO 8601 behavior of printing Z instead of an<br>
offset for the UTC zone. Thus:<br>
	Z0700  Z or ±hhmm<br>
	Z07:00 Z or ±hh:mm<br>
	Z07    Z or ±hh<br>
<br>
The recognized day of week formats are &#34;Mon&#34; and &#34;Monday&#34;.<br>
The recognized month formats are &#34;Jan&#34; and &#34;January&#34;.<br>
<br>
Text in the format string that is not recognized as part of the reference<br>
time is echoed verbatim during Format and expected to appear verbatim<br>
in the input to Parse.<br>
<br>
The executable example for Time.Format demonstrates the working<br>
of the layout string in detail and is a good reference.<br>
<br>
Note that the RFC822, RFC850, and RFC1123 formats should be applied<br>
only to local times. Applying them to UTC times will use &#34;UTC&#34; as the<br>
time zone abbreviation, while strictly speaking those RFCs require the<br>
use of &#34;GMT&#34; in that case.<br>
In general RFC1123Z should be used instead of RFC1123 for servers<br>
that insist on that format, and RFC3339 should be preferred for new protocols.<br>
RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;<br>
when used with time.Parse they do not accept all the time formats<br>
permitted by the RFCs.<br>
The RFC3339Nano format removes trailing zeros from the seconds field<br>
and thus may not sort correctly once formatted.<br>
</p>
  
</li>
<li>
  <h3 id="RFC822Z">RFC822Z</h3>
  <span class="var-type String">String</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">RFC822 with numeric zone<br>
</p>
  
</li>
<li>
  <h3 id="RFC850">RFC850</h3>
  <span class="var-type String">String</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">These are predefined layouts for use in Time.Format and time.Parse.<br>
The reference time used in the layouts is the specific time:<br>
	Mon Jan 2 15:04:05 MST 2006<br>
which is Unix time 1136239445. Since MST is GMT-0700,<br>
the reference time can be thought of as<br>
	01/02 03:04:05PM &#39;06 -0700<br>
To define your own format, write down what the reference time would look<br>
like formatted your way; see the values of constants like ANSIC,<br>
StampMicro or Kitchen for examples. The model is to demonstrate what the<br>
reference time looks like so that the Format and Parse methods can apply<br>
the same transformation to a general time value.<br>
<br>
Some valid layouts are invalid time values for time.Parse, due to formats<br>
such as _ for space padding and Z for zone information.<br>
<br>
Within the format string, an underscore _ represents a space that may be<br>
replaced by a digit if the following number (a day) has two digits; for<br>
compatibility with fixed-width Unix time formats.<br>
<br>
A decimal point followed by one or more zeros represents a fractional<br>
second, printed to the given number of decimal places. A decimal point<br>
followed by one or more nines represents a fractional second, printed to<br>
the given number of decimal places, with trailing zeros removed.<br>
When parsing (only), the input may contain a fractional second<br>
field immediately after the seconds field, even if the layout does not<br>
signify its presence. In that case a decimal point followed by a maximal<br>
series of digits is parsed as a fractional second.<br>
<br>
Numeric time zone offsets format as follows:<br>
	-0700  ±hhmm<br>
	-07:00 ±hh:mm<br>
	-07    ±hh<br>
Replacing the sign in the format with a Z triggers<br>
the ISO 8601 behavior of printing Z instead of an<br>
offset for the UTC zone. Thus:<br>
	Z0700  Z or ±hhmm<br>
	Z07:00 Z or ±hh:mm<br>
	Z07    Z or ±hh<br>
<br>
The recognized day of week formats are &#34;Mon&#34; and &#34;Monday&#34;.<br>
The recognized month formats are &#34;Jan&#34; and &#34;January&#34;.<br>
<br>
Text in the format string that is not recognized as part of the reference<br>
time is echoed verbatim during Format and expected to appear verbatim<br>
in the input to Parse.<br>
<br>
The executable example for Time.Format demonstrates the working<br>
of the layout string in detail and is a good reference.<br>
<br>
Note that the RFC822, RFC850, and RFC1123 formats should be applied<br>
only to local times. Applying them to UTC times will use &#34;UTC&#34; as the<br>
time zone abbreviation, while strictly speaking those RFCs require the<br>
use of &#34;GMT&#34; in that case.<br>
In general RFC1123Z should be used instead of RFC1123 for servers<br>
that insist on that format, and RFC3339 should be preferred for new protocols.<br>
RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;<br>
when used with time.Parse they do not accept all the time formats<br>
permitted by the RFCs.<br>
The RFC3339Nano format removes trailing zeros from the seconds field<br>
and thus may not sort correctly once formatted.<br>
</p>
  
</li>
<li>
  <h3 id="RubyDate">RubyDate</h3>
  <span class="var-type String">String</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">These are predefined layouts for use in Time.Format and time.Parse.<br>
The reference time used in the layouts is the specific time:<br>
	Mon Jan 2 15:04:05 MST 2006<br>
which is Unix time 1136239445. Since MST is GMT-0700,<br>
the reference time can be thought of as<br>
	01/02 03:04:05PM &#39;06 -0700<br>
To define your own format, write down what the reference time would look<br>
like formatted your way; see the values of constants like ANSIC,<br>
StampMicro or Kitchen for examples. The model is to demonstrate what the<br>
reference time looks like so that the Format and Parse methods can apply<br>
the same transformation to a general time value.<br>
<br>
Some valid layouts are invalid time values for time.Parse, due to formats<br>
such as _ for space padding and Z for zone information.<br>
<br>
Within the format string, an underscore _ represents a space that may be<br>
replaced by a digit if the following number (a day) has two digits; for<br>
compatibility with fixed-width Unix time formats.<br>
<br>
A decimal point followed by one or more zeros represents a fractional<br>
second, printed to the given number of decimal places. A decimal point<br>
followed by one or more nines represents a fractional second, printed to<br>
the given number of decimal places, with trailing zeros removed.<br>
When parsing (only), the input may contain a fractional second<br>
field immediately after the seconds field, even if the layout does not<br>
signify its presence. In that case a decimal point followed by a maximal<br>
series of digits is parsed as a fractional second.<br>
<br>
Numeric time zone offsets format as follows:<br>
	-0700  ±hhmm<br>
	-07:00 ±hh:mm<br>
	-07    ±hh<br>
Replacing the sign in the format with a Z triggers<br>
the ISO 8601 behavior of printing Z instead of an<br>
offset for the UTC zone. Thus:<br>
	Z0700  Z or ±hhmm<br>
	Z07:00 Z or ±hh:mm<br>
	Z07    Z or ±hh<br>
<br>
The recognized day of week formats are &#34;Mon&#34; and &#34;Monday&#34;.<br>
The recognized month formats are &#34;Jan&#34; and &#34;January&#34;.<br>
<br>
Text in the format string that is not recognized as part of the reference<br>
time is echoed verbatim during Format and expected to appear verbatim<br>
in the input to Parse.<br>
<br>
The executable example for Time.Format demonstrates the working<br>
of the layout string in detail and is a good reference.<br>
<br>
Note that the RFC822, RFC850, and RFC1123 formats should be applied<br>
only to local times. Applying them to UTC times will use &#34;UTC&#34; as the<br>
time zone abbreviation, while strictly speaking those RFCs require the<br>
use of &#34;GMT&#34; in that case.<br>
In general RFC1123Z should be used instead of RFC1123 for servers<br>
that insist on that format, and RFC3339 should be preferred for new protocols.<br>
RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;<br>
when used with time.Parse they do not accept all the time formats<br>
permitted by the RFCs.<br>
The RFC3339Nano format removes trailing zeros from the seconds field<br>
and thus may not sort correctly once formatted.<br>
</p>
  
</li>
<li>
  <h3 id="Saturday">Saturday</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Second">Second</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">Common durations. There is no definition for units of Day or larger<br>
to avoid confusion across daylight savings time zone transitions.<br>
<br>
To count the number of units in a Duration, divide:<br>
	second := time.Second<br>
	fmt.Print(int64(second/time.Millisecond)) // prints 1000<br>
<br>
To convert an integer number of units to a Duration, multiply:<br>
	seconds := 10<br>
	fmt.Print(time.Duration(seconds)*time.Second) // prints 10s<br>
</p>
  
</li>
<li>
  <h3 id="September">September</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Since">Since</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Since __t)</code></div>
</pre>
  <p class="var-docstr">Since returns the time elapsed since t.<br>
It is shorthand for time.Now().Sub(t).<br>
<br>
Go input arguments: (t Time)<br>
<br>
Go return type: Duration<br>
<br>
Joker input arguments: [^go.std.time/Time t]<br>
<br>
Joker return type: go.std.time/Duration</p>
  
</li>
<li>
  <h3 id="Stamp">Stamp</h3>
  <span class="var-type String">String</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">Handy time stamps.<br>
</p>
  
</li>
<li>
  <h3 id="StampMicro">StampMicro</h3>
  <span class="var-type String">String</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">These are predefined layouts for use in Time.Format and time.Parse.<br>
The reference time used in the layouts is the specific time:<br>
	Mon Jan 2 15:04:05 MST 2006<br>
which is Unix time 1136239445. Since MST is GMT-0700,<br>
the reference time can be thought of as<br>
	01/02 03:04:05PM &#39;06 -0700<br>
To define your own format, write down what the reference time would look<br>
like formatted your way; see the values of constants like ANSIC,<br>
StampMicro or Kitchen for examples. The model is to demonstrate what the<br>
reference time looks like so that the Format and Parse methods can apply<br>
the same transformation to a general time value.<br>
<br>
Some valid layouts are invalid time values for time.Parse, due to formats<br>
such as _ for space padding and Z for zone information.<br>
<br>
Within the format string, an underscore _ represents a space that may be<br>
replaced by a digit if the following number (a day) has two digits; for<br>
compatibility with fixed-width Unix time formats.<br>
<br>
A decimal point followed by one or more zeros represents a fractional<br>
second, printed to the given number of decimal places. A decimal point<br>
followed by one or more nines represents a fractional second, printed to<br>
the given number of decimal places, with trailing zeros removed.<br>
When parsing (only), the input may contain a fractional second<br>
field immediately after the seconds field, even if the layout does not<br>
signify its presence. In that case a decimal point followed by a maximal<br>
series of digits is parsed as a fractional second.<br>
<br>
Numeric time zone offsets format as follows:<br>
	-0700  ±hhmm<br>
	-07:00 ±hh:mm<br>
	-07    ±hh<br>
Replacing the sign in the format with a Z triggers<br>
the ISO 8601 behavior of printing Z instead of an<br>
offset for the UTC zone. Thus:<br>
	Z0700  Z or ±hhmm<br>
	Z07:00 Z or ±hh:mm<br>
	Z07    Z or ±hh<br>
<br>
The recognized day of week formats are &#34;Mon&#34; and &#34;Monday&#34;.<br>
The recognized month formats are &#34;Jan&#34; and &#34;January&#34;.<br>
<br>
Text in the format string that is not recognized as part of the reference<br>
time is echoed verbatim during Format and expected to appear verbatim<br>
in the input to Parse.<br>
<br>
The executable example for Time.Format demonstrates the working<br>
of the layout string in detail and is a good reference.<br>
<br>
Note that the RFC822, RFC850, and RFC1123 formats should be applied<br>
only to local times. Applying them to UTC times will use &#34;UTC&#34; as the<br>
time zone abbreviation, while strictly speaking those RFCs require the<br>
use of &#34;GMT&#34; in that case.<br>
In general RFC1123Z should be used instead of RFC1123 for servers<br>
that insist on that format, and RFC3339 should be preferred for new protocols.<br>
RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;<br>
when used with time.Parse they do not accept all the time formats<br>
permitted by the RFCs.<br>
The RFC3339Nano format removes trailing zeros from the seconds field<br>
and thus may not sort correctly once formatted.<br>
</p>
  
</li>
<li>
  <h3 id="StampMilli">StampMilli</h3>
  <span class="var-type String">String</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">These are predefined layouts for use in Time.Format and time.Parse.<br>
The reference time used in the layouts is the specific time:<br>
	Mon Jan 2 15:04:05 MST 2006<br>
which is Unix time 1136239445. Since MST is GMT-0700,<br>
the reference time can be thought of as<br>
	01/02 03:04:05PM &#39;06 -0700<br>
To define your own format, write down what the reference time would look<br>
like formatted your way; see the values of constants like ANSIC,<br>
StampMicro or Kitchen for examples. The model is to demonstrate what the<br>
reference time looks like so that the Format and Parse methods can apply<br>
the same transformation to a general time value.<br>
<br>
Some valid layouts are invalid time values for time.Parse, due to formats<br>
such as _ for space padding and Z for zone information.<br>
<br>
Within the format string, an underscore _ represents a space that may be<br>
replaced by a digit if the following number (a day) has two digits; for<br>
compatibility with fixed-width Unix time formats.<br>
<br>
A decimal point followed by one or more zeros represents a fractional<br>
second, printed to the given number of decimal places. A decimal point<br>
followed by one or more nines represents a fractional second, printed to<br>
the given number of decimal places, with trailing zeros removed.<br>
When parsing (only), the input may contain a fractional second<br>
field immediately after the seconds field, even if the layout does not<br>
signify its presence. In that case a decimal point followed by a maximal<br>
series of digits is parsed as a fractional second.<br>
<br>
Numeric time zone offsets format as follows:<br>
	-0700  ±hhmm<br>
	-07:00 ±hh:mm<br>
	-07    ±hh<br>
Replacing the sign in the format with a Z triggers<br>
the ISO 8601 behavior of printing Z instead of an<br>
offset for the UTC zone. Thus:<br>
	Z0700  Z or ±hhmm<br>
	Z07:00 Z or ±hh:mm<br>
	Z07    Z or ±hh<br>
<br>
The recognized day of week formats are &#34;Mon&#34; and &#34;Monday&#34;.<br>
The recognized month formats are &#34;Jan&#34; and &#34;January&#34;.<br>
<br>
Text in the format string that is not recognized as part of the reference<br>
time is echoed verbatim during Format and expected to appear verbatim<br>
in the input to Parse.<br>
<br>
The executable example for Time.Format demonstrates the working<br>
of the layout string in detail and is a good reference.<br>
<br>
Note that the RFC822, RFC850, and RFC1123 formats should be applied<br>
only to local times. Applying them to UTC times will use &#34;UTC&#34; as the<br>
time zone abbreviation, while strictly speaking those RFCs require the<br>
use of &#34;GMT&#34; in that case.<br>
In general RFC1123Z should be used instead of RFC1123 for servers<br>
that insist on that format, and RFC3339 should be preferred for new protocols.<br>
RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;<br>
when used with time.Parse they do not accept all the time formats<br>
permitted by the RFCs.<br>
The RFC3339Nano format removes trailing zeros from the seconds field<br>
and thus may not sort correctly once formatted.<br>
</p>
  
</li>
<li>
  <h3 id="StampNano">StampNano</h3>
  <span class="var-type String">String</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">These are predefined layouts for use in Time.Format and time.Parse.<br>
The reference time used in the layouts is the specific time:<br>
	Mon Jan 2 15:04:05 MST 2006<br>
which is Unix time 1136239445. Since MST is GMT-0700,<br>
the reference time can be thought of as<br>
	01/02 03:04:05PM &#39;06 -0700<br>
To define your own format, write down what the reference time would look<br>
like formatted your way; see the values of constants like ANSIC,<br>
StampMicro or Kitchen for examples. The model is to demonstrate what the<br>
reference time looks like so that the Format and Parse methods can apply<br>
the same transformation to a general time value.<br>
<br>
Some valid layouts are invalid time values for time.Parse, due to formats<br>
such as _ for space padding and Z for zone information.<br>
<br>
Within the format string, an underscore _ represents a space that may be<br>
replaced by a digit if the following number (a day) has two digits; for<br>
compatibility with fixed-width Unix time formats.<br>
<br>
A decimal point followed by one or more zeros represents a fractional<br>
second, printed to the given number of decimal places. A decimal point<br>
followed by one or more nines represents a fractional second, printed to<br>
the given number of decimal places, with trailing zeros removed.<br>
When parsing (only), the input may contain a fractional second<br>
field immediately after the seconds field, even if the layout does not<br>
signify its presence. In that case a decimal point followed by a maximal<br>
series of digits is parsed as a fractional second.<br>
<br>
Numeric time zone offsets format as follows:<br>
	-0700  ±hhmm<br>
	-07:00 ±hh:mm<br>
	-07    ±hh<br>
Replacing the sign in the format with a Z triggers<br>
the ISO 8601 behavior of printing Z instead of an<br>
offset for the UTC zone. Thus:<br>
	Z0700  Z or ±hhmm<br>
	Z07:00 Z or ±hh:mm<br>
	Z07    Z or ±hh<br>
<br>
The recognized day of week formats are &#34;Mon&#34; and &#34;Monday&#34;.<br>
The recognized month formats are &#34;Jan&#34; and &#34;January&#34;.<br>
<br>
Text in the format string that is not recognized as part of the reference<br>
time is echoed verbatim during Format and expected to appear verbatim<br>
in the input to Parse.<br>
<br>
The executable example for Time.Format demonstrates the working<br>
of the layout string in detail and is a good reference.<br>
<br>
Note that the RFC822, RFC850, and RFC1123 formats should be applied<br>
only to local times. Applying them to UTC times will use &#34;UTC&#34; as the<br>
time zone abbreviation, while strictly speaking those RFCs require the<br>
use of &#34;GMT&#34; in that case.<br>
In general RFC1123Z should be used instead of RFC1123 for servers<br>
that insist on that format, and RFC3339 should be preferred for new protocols.<br>
RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;<br>
when used with time.Parse they do not accept all the time formats<br>
permitted by the RFCs.<br>
The RFC3339Nano format removes trailing zeros from the seconds field<br>
and thus may not sort correctly once formatted.<br>
</p>
  
</li>
<li>
  <h3 id="Sunday">Sunday</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Thursday">Thursday</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Time.">Time.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Time. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for time.Time</p>
  
</li>
<li>
  <h3 id="Tuesday">Tuesday</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="UTC">UTC</h3>
  <span class="var-type GoVar[**time.Location]">GoVar[**time.Location]</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">UTC represents Universal Coordinated Time (UTC).<br>
</p>
  
</li>
<li>
  <h3 id="Unix">Unix</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Unix __sec __nsec)</code></div>
</pre>
  <p class="var-docstr">Unix returns the local Time corresponding to the given Unix time,<br>
sec seconds and nsec nanoseconds since January 1, 1970 UTC.<br>
It is valid to pass nsec outside the range [0, 999999999].<br>
Not all sec values have a corresponding time value. One such<br>
value is 1&lt;&lt;63-1 (the largest int64 value).<br>
<br>
Go input arguments: (sec int64, nsec int64)<br>
<br>
Go return type: Time<br>
<br>
Joker input arguments: [^Number sec, ^Number nsec]<br>
<br>
Joker return type: go.std.time/Time</p>
  
</li>
<li>
  <h3 id="UnixDate">UnixDate</h3>
  <span class="var-type String">String</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">These are predefined layouts for use in Time.Format and time.Parse.<br>
The reference time used in the layouts is the specific time:<br>
	Mon Jan 2 15:04:05 MST 2006<br>
which is Unix time 1136239445. Since MST is GMT-0700,<br>
the reference time can be thought of as<br>
	01/02 03:04:05PM &#39;06 -0700<br>
To define your own format, write down what the reference time would look<br>
like formatted your way; see the values of constants like ANSIC,<br>
StampMicro or Kitchen for examples. The model is to demonstrate what the<br>
reference time looks like so that the Format and Parse methods can apply<br>
the same transformation to a general time value.<br>
<br>
Some valid layouts are invalid time values for time.Parse, due to formats<br>
such as _ for space padding and Z for zone information.<br>
<br>
Within the format string, an underscore _ represents a space that may be<br>
replaced by a digit if the following number (a day) has two digits; for<br>
compatibility with fixed-width Unix time formats.<br>
<br>
A decimal point followed by one or more zeros represents a fractional<br>
second, printed to the given number of decimal places. A decimal point<br>
followed by one or more nines represents a fractional second, printed to<br>
the given number of decimal places, with trailing zeros removed.<br>
When parsing (only), the input may contain a fractional second<br>
field immediately after the seconds field, even if the layout does not<br>
signify its presence. In that case a decimal point followed by a maximal<br>
series of digits is parsed as a fractional second.<br>
<br>
Numeric time zone offsets format as follows:<br>
	-0700  ±hhmm<br>
	-07:00 ±hh:mm<br>
	-07    ±hh<br>
Replacing the sign in the format with a Z triggers<br>
the ISO 8601 behavior of printing Z instead of an<br>
offset for the UTC zone. Thus:<br>
	Z0700  Z or ±hhmm<br>
	Z07:00 Z or ±hh:mm<br>
	Z07    Z or ±hh<br>
<br>
The recognized day of week formats are &#34;Mon&#34; and &#34;Monday&#34;.<br>
The recognized month formats are &#34;Jan&#34; and &#34;January&#34;.<br>
<br>
Text in the format string that is not recognized as part of the reference<br>
time is echoed verbatim during Format and expected to appear verbatim<br>
in the input to Parse.<br>
<br>
The executable example for Time.Format demonstrates the working<br>
of the layout string in detail and is a good reference.<br>
<br>
Note that the RFC822, RFC850, and RFC1123 formats should be applied<br>
only to local times. Applying them to UTC times will use &#34;UTC&#34; as the<br>
time zone abbreviation, while strictly speaking those RFCs require the<br>
use of &#34;GMT&#34; in that case.<br>
In general RFC1123Z should be used instead of RFC1123 for servers<br>
that insist on that format, and RFC3339 should be preferred for new protocols.<br>
RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;<br>
when used with time.Parse they do not accept all the time formats<br>
permitted by the RFCs.<br>
The RFC3339Nano format removes trailing zeros from the seconds field<br>
and thus may not sort correctly once formatted.<br>
</p>
  
</li>
<li>
  <h3 id="Until">Until</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Until __t)</code></div>
</pre>
  <p class="var-docstr">Until returns the duration until t.<br>
It is shorthand for t.Sub(time.Now()).<br>
<br>
Go input arguments: (t Time)<br>
<br>
Go return type: Duration<br>
<br>
Joker input arguments: [^go.std.time/Time t]<br>
<br>
Joker return type: go.std.time/Duration</p>
  
</li>
<li>
  <h3 id="Wednesday">Wednesday</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr"></p>
  
</li>
<li>
  <h3 id="Weekday.">Weekday.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Weekday. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for time.Weekday</p>
  
</li>

    </ul>
  </div>
</body>
</html>
