<html>
<head>
  <link rel="stylesheet" type="text/css" href="main.css">
</head>
<body>
  <div class="main">
    <h1>Namespace: go.std.net</h1>
    <span class="var-added">v1.0</span>
    <h2>Contents</h2>
    <ul>
      <li>
        <a href="#_summary">Summary</a>
      </li>
      <li>
        <a href="#_index">Index</a>
      </li>
      <li>
        <a href="#_constants">Constants</a>
      </li>
      <li>
        <a href="#_variables">Variables</a>
      </li>
      <li>
        <a href="#_functions">Functions and Macros</a>
      </li>
      <li>
        <a href="#_types">Types</a>
      </li>
    </ul>
    <h2 id="_summary">Summary</h2>
    <p class="var-docstr">Provides a low-level interface to the net package.<br>
<br>
Package net provides a portable interface for network I/O, including<br>
TCP/IP, UDP, domain name resolution, and Unix domain sockets.<br>
<br>
Although the package provides access to low-level networking<br>
primitives, most clients will need only the basic interface provided<br>
by the Dial, Listen, and Accept functions and the associated<br>
Conn and Listener interfaces. The crypto/tls package uses<br>
the same interfaces and similar Dial and Listen functions.<br>
<br>
The Dial function connects to a server:<br>
<br>
	conn, err := net.Dial(&#34;tcp&#34;, &#34;golang.org:80&#34;)<br>
	if err != nil {<br>
		// handle error<br>
	}<br>
	fmt.Fprintf(conn, &#34;GET / HTTP/1.0\r\n\r\n&#34;)<br>
	status, err := bufio.NewReader(conn).ReadString(&#39;\n&#39;)<br>
	// ...<br>
<br>
The Listen function creates servers:<br>
<br>
	ln, err := net.Listen(&#34;tcp&#34;, &#34;:8080&#34;)<br>
	if err != nil {<br>
		// handle error<br>
	}<br>
	for {<br>
		conn, err := ln.Accept()<br>
		if err != nil {<br>
			// handle error<br>
		}<br>
		go handleConnection(conn)<br>
	}<br>
<br>
Name Resolution<br>
<br>
The method for resolving domain names, whether indirectly with functions like Dial<br>
or directly with functions like LookupHost and LookupAddr, varies by operating system.<br>
<br>
On Unix systems, the resolver has two options for resolving names.<br>
It can use a pure Go resolver that sends DNS requests directly to the servers<br>
listed in /etc/resolv.conf, or it can use a cgo-based resolver that calls C<br>
library routines such as getaddrinfo and getnameinfo.<br>
<br>
By default the pure Go resolver is used, because a blocked DNS request consumes<br>
only a goroutine, while a blocked C call consumes an operating system thread.<br>
When cgo is available, the cgo-based resolver is used instead under a variety of<br>
conditions: on systems that do not let programs make direct DNS requests (OS X),<br>
when the LOCALDOMAIN environment variable is present (even if empty),<br>
when the RES_OPTIONS or HOSTALIASES environment variable is non-empty,<br>
when the ASR_CONFIG environment variable is non-empty (OpenBSD only),<br>
when /etc/resolv.conf or /etc/nsswitch.conf specify the use of features that the<br>
Go resolver does not implement, and when the name being looked up ends in .local<br>
or is an mDNS name.<br>
<br>
The resolver decision can be overridden by setting the netdns value of the<br>
GODEBUG environment variable (see package runtime) to go or cgo, as in:<br>
<br>
	export GODEBUG=netdns=go    # force pure Go resolver<br>
	export GODEBUG=netdns=cgo   # force cgo resolver<br>
<br>
The decision can also be forced while building the Go source tree<br>
by setting the netgo or netcgo build tag.<br>
<br>
A numeric netdns setting, as in GODEBUG=netdns=1, causes the resolver<br>
to print debugging information about its decisions.<br>
To force a particular resolver while also printing debugging information,<br>
join the two settings by a plus sign, as in GODEBUG=netdns=go+1.<br>
<br>
On Plan 9, the resolver always accesses /net/cs and /net/dns.<br>
<br>
On Windows, the resolver always uses C library functions, such as GetAddrInfo and DnsQuery.<br>
</p>
    <h2 id="_index">Index</h2>
    <ul class="index">
      <li>
  <a href="#AddrError.">AddrError.</a>
</li>
<li>
  <a href="#CIDRMask">CIDRMask</a>
</li>
<li>
  <a href="#DNSConfigError.">DNSConfigError.</a>
</li>
<li>
  <a href="#DNSError.">DNSError.</a>
</li>
<li>
  <a href="#DefaultResolver">DefaultResolver</a>
</li>
<li>
  <a href="#Dial">Dial</a>
</li>
<li>
  <a href="#DialIP">DialIP</a>
</li>
<li>
  <a href="#DialTCP">DialTCP</a>
</li>
<li>
  <a href="#DialUDP">DialUDP</a>
</li>
<li>
  <a href="#DialUnix">DialUnix</a>
</li>
<li>
  <a href="#ErrWriteToConnected">ErrWriteToConnected</a>
</li>
<li>
  <a href="#FlagBroadcast">FlagBroadcast</a>
</li>
<li>
  <a href="#FlagLoopback">FlagLoopback</a>
</li>
<li>
  <a href="#FlagMulticast">FlagMulticast</a>
</li>
<li>
  <a href="#FlagPointToPoint">FlagPointToPoint</a>
</li>
<li>
  <a href="#FlagUp">FlagUp</a>
</li>
<li>
  <a href="#Flags.">Flags.</a>
</li>
<li>
  <a href="#IPConn.">IPConn.</a>
</li>
<li>
  <a href="#IPv4">IPv4</a>
</li>
<li>
  <a href="#IPv4Mask">IPv4Mask</a>
</li>
<li>
  <a href="#IPv4allrouter">IPv4allrouter</a>
</li>
<li>
  <a href="#IPv4allsys">IPv4allsys</a>
</li>
<li>
  <a href="#IPv4bcast">IPv4bcast</a>
</li>
<li>
  <a href="#IPv4len">IPv4len</a>
</li>
<li>
  <a href="#IPv4zero">IPv4zero</a>
</li>
<li>
  <a href="#IPv6interfacelocalallnodes">IPv6interfacelocalallnodes</a>
</li>
<li>
  <a href="#IPv6len">IPv6len</a>
</li>
<li>
  <a href="#IPv6linklocalallnodes">IPv6linklocalallnodes</a>
</li>
<li>
  <a href="#IPv6linklocalallrouters">IPv6linklocalallrouters</a>
</li>
<li>
  <a href="#IPv6loopback">IPv6loopback</a>
</li>
<li>
  <a href="#IPv6unspecified">IPv6unspecified</a>
</li>
<li>
  <a href="#IPv6zero">IPv6zero</a>
</li>
<li>
  <a href="#InterfaceAddrs">InterfaceAddrs</a>
</li>
<li>
  <a href="#InterfaceByIndex">InterfaceByIndex</a>
</li>
<li>
  <a href="#InterfaceByName">InterfaceByName</a>
</li>
<li>
  <a href="#Interfaces">Interfaces</a>
</li>
<li>
  <a href="#InvalidAddrError.">InvalidAddrError.</a>
</li>
<li>
  <a href="#JoinHostPort">JoinHostPort</a>
</li>
<li>
  <a href="#Listen">Listen</a>
</li>
<li>
  <a href="#ListenIP">ListenIP</a>
</li>
<li>
  <a href="#ListenMulticastUDP">ListenMulticastUDP</a>
</li>
<li>
  <a href="#ListenPacket">ListenPacket</a>
</li>
<li>
  <a href="#ListenTCP">ListenTCP</a>
</li>
<li>
  <a href="#ListenUDP">ListenUDP</a>
</li>
<li>
  <a href="#ListenUnix">ListenUnix</a>
</li>
<li>
  <a href="#ListenUnixgram">ListenUnixgram</a>
</li>
<li>
  <a href="#LookupAddr">LookupAddr</a>
</li>
<li>
  <a href="#LookupCNAME">LookupCNAME</a>
</li>
<li>
  <a href="#LookupHost">LookupHost</a>
</li>
<li>
  <a href="#LookupIP">LookupIP</a>
</li>
<li>
  <a href="#LookupMX">LookupMX</a>
</li>
<li>
  <a href="#LookupNS">LookupNS</a>
</li>
<li>
  <a href="#LookupPort">LookupPort</a>
</li>
<li>
  <a href="#LookupSRV">LookupSRV</a>
</li>
<li>
  <a href="#LookupTXT">LookupTXT</a>
</li>
<li>
  <a href="#MX">MX</a>
</li>
<li>
  <a href="#MX.">MX.</a>
</li>
<li>
  <a href="#NS.">NS.</a>
</li>
<li>
  <a href="#ParseCIDR">ParseCIDR</a>
</li>
<li>
  <a href="#ParseError.">ParseError.</a>
</li>
<li>
  <a href="#ParseIP">ParseIP</a>
</li>
<li>
  <a href="#ParseMAC">ParseMAC</a>
</li>
<li>
  <a href="#Pipe">Pipe</a>
</li>
<li>
  <a href="#ResolveIPAddr">ResolveIPAddr</a>
</li>
<li>
  <a href="#ResolveTCPAddr">ResolveTCPAddr</a>
</li>
<li>
  <a href="#ResolveUDPAddr">ResolveUDPAddr</a>
</li>
<li>
  <a href="#ResolveUnixAddr">ResolveUnixAddr</a>
</li>
<li>
  <a href="#SRV.">SRV.</a>
</li>
<li>
  <a href="#SplitHostPort">SplitHostPort</a>
</li>
<li>
  <a href="#TCPConn.">TCPConn.</a>
</li>
<li>
  <a href="#TCPListener.">TCPListener.</a>
</li>
<li>
  <a href="#UDPConn.">UDPConn.</a>
</li>
<li>
  <a href="#UnixAddr.">UnixAddr.</a>
</li>
<li>
  <a href="#UnixConn.">UnixConn.</a>
</li>
<li>
  <a href="#UnixListener.">UnixListener.</a>
</li>
<li>
  <a href="#UnknownNetworkError.">UnknownNetworkError.</a>
</li>

    </ul>
    <h2 id="_constants">Constants</h2>
    <ul>
      <li>
  <h3 id="FlagBroadcast">FlagBroadcast</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">interface supports broadcast access capability<br>
</p>
</li>
<li>
  <h3 id="FlagLoopback">FlagLoopback</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">interface is a loopback interface<br>
</p>
</li>
<li>
  <h3 id="FlagMulticast">FlagMulticast</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">interface supports multicast access capability<br>
</p>
</li>
<li>
  <h3 id="FlagPointToPoint">FlagPointToPoint</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">interface belongs to a point-to-point link<br>
</p>
</li>
<li>
  <h3 id="FlagUp">FlagUp</h3>
  <span class="var-type BigInt">BigInt</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">interface is up<br>
</p>
</li>
<li>
  <h3 id="IPv4len">IPv4len</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">IP address lengths (bytes).<br>
</p>
</li>
<li>
  <h3 id="IPv6len">IPv6len</h3>
  <span class="var-type Int">Int</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">IP address lengths (bytes).<br>
</p>
</li>

    </ul>
    <h2 id="_variables">Variables</h2>
    <ul>
      <li>
  <h3 id="DefaultResolver">DefaultResolver</h3>
  <span class="var-type GoVar">GoVar</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">DefaultResolver is the resolver used by the package-level Lookup<br>
functions and by Dialers without a specified Resolver.<br>
</p>
</li>
<li>
  <h3 id="ErrWriteToConnected">ErrWriteToConnected</h3>
  <span class="var-type GoVar">GoVar</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">Various errors contained in OpError.<br>
</p>
</li>
<li>
  <h3 id="IPv4allrouter">IPv4allrouter</h3>
  <span class="var-type GoVar">GoVar</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">all routers<br>
</p>
</li>
<li>
  <h3 id="IPv4allsys">IPv4allsys</h3>
  <span class="var-type GoVar">GoVar</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">all systems<br>
</p>
</li>
<li>
  <h3 id="IPv4bcast">IPv4bcast</h3>
  <span class="var-type GoVar">GoVar</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">limited broadcast<br>
</p>
</li>
<li>
  <h3 id="IPv4zero">IPv4zero</h3>
  <span class="var-type GoVar">GoVar</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">all zeros<br>
</p>
</li>
<li>
  <h3 id="IPv6interfacelocalallnodes">IPv6interfacelocalallnodes</h3>
  <span class="var-type GoVar">GoVar</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">Well-known IPv6 addresses<br>
</p>
</li>
<li>
  <h3 id="IPv6linklocalallnodes">IPv6linklocalallnodes</h3>
  <span class="var-type GoVar">GoVar</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">Well-known IPv6 addresses<br>
</p>
</li>
<li>
  <h3 id="IPv6linklocalallrouters">IPv6linklocalallrouters</h3>
  <span class="var-type GoVar">GoVar</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">Well-known IPv6 addresses<br>
</p>
</li>
<li>
  <h3 id="IPv6loopback">IPv6loopback</h3>
  <span class="var-type GoVar">GoVar</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">Well-known IPv6 addresses<br>
</p>
</li>
<li>
  <h3 id="IPv6unspecified">IPv6unspecified</h3>
  <span class="var-type GoVar">GoVar</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">Well-known IPv6 addresses<br>
</p>
</li>
<li>
  <h3 id="IPv6zero">IPv6zero</h3>
  <span class="var-type GoVar">GoVar</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"></pre>
  <p class="var-docstr">Well-known IPv6 addresses<br>
</p>
</li>

    </ul>
    <h2 id="_functions">Functions and Macros</h2>
    <ul>
      <li>
  <h3 id="AddrError.">AddrError.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(AddrError. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for net.AddrError</p>
</li>
<li>
  <h3 id="CIDRMask">CIDRMask</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(CIDRMask __ones __bits)</code></div>
</pre>
  <p class="var-docstr">CIDRMask returns an IPMask consisting of `ones&#39; 1 bits<br>
followed by 0s up to a total length of `bits&#39; bits.<br>
For a mask of this form, CIDRMask is the inverse of IPMask.Size.<br>
<br>
Go input arguments: (ones int, bits int)<br>
<br>
Go return type: IPMask<br>
<br>
Joker input arguments: [^Int ones, ^Int bits]<br>
<br>
Joker return type: go.std.net/IPMask</p>
</li>
<li>
  <h3 id="DNSConfigError.">DNSConfigError.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(DNSConfigError. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for net.DNSConfigError</p>
</li>
<li>
  <h3 id="DNSError.">DNSError.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(DNSError. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for net.DNSError</p>
</li>
<li>
  <h3 id="Dial">Dial</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Dial __network __address)</code></div>
</pre>
  <p class="var-docstr">Dial connects to the address on the named network.<br>
<br>
Known networks are &#34;tcp&#34;, &#34;tcp4&#34; (IPv4-only), &#34;tcp6&#34; (IPv6-only),<br>
&#34;udp&#34;, &#34;udp4&#34; (IPv4-only), &#34;udp6&#34; (IPv6-only), &#34;ip&#34;, &#34;ip4&#34;<br>
(IPv4-only), &#34;ip6&#34; (IPv6-only), &#34;unix&#34;, &#34;unixgram&#34; and<br>
&#34;unixpacket&#34;.<br>
<br>
For TCP and UDP networks, the address has the form &#34;host:port&#34;.<br>
The host must be a literal IP address, or a host name that can be<br>
resolved to IP addresses.<br>
The port must be a literal port number or a service name.<br>
If the host is a literal IPv6 address it must be enclosed in square<br>
brackets, as in &#34;[2001:db8::1]:80&#34; or &#34;[fe80::1%zone]:80&#34;.<br>
The zone specifies the scope of the literal IPv6 address as defined<br>
in RFC 4007.<br>
The functions JoinHostPort and SplitHostPort manipulate a pair of<br>
host and port in this form.<br>
When using TCP, and the host resolves to multiple IP addresses,<br>
Dial will try each IP address in order until one succeeds.<br>
<br>
Examples:<br>
	Dial(&#34;tcp&#34;, &#34;golang.org:http&#34;)<br>
	Dial(&#34;tcp&#34;, &#34;192.0.2.1:http&#34;)<br>
	Dial(&#34;tcp&#34;, &#34;198.51.100.1:80&#34;)<br>
	Dial(&#34;udp&#34;, &#34;[2001:db8::1]:domain&#34;)<br>
	Dial(&#34;udp&#34;, &#34;[fe80::1%lo0]:53&#34;)<br>
	Dial(&#34;tcp&#34;, &#34;:80&#34;)<br>
<br>
For IP networks, the network must be &#34;ip&#34;, &#34;ip4&#34; or &#34;ip6&#34; followed<br>
by a colon and a literal protocol number or a protocol name, and<br>
the address has the form &#34;host&#34;. The host must be a literal IP<br>
address or a literal IPv6 address with zone.<br>
It depends on each operating system how the operating system<br>
behaves with a non-well known protocol number such as &#34;0&#34; or &#34;255&#34;.<br>
<br>
Examples:<br>
	Dial(&#34;ip4:1&#34;, &#34;192.0.2.1&#34;)<br>
	Dial(&#34;ip6:ipv6-icmp&#34;, &#34;2001:db8::1&#34;)<br>
	Dial(&#34;ip6:58&#34;, &#34;fe80::1%lo0&#34;)<br>
<br>
For TCP, UDP and IP networks, if the host is empty or a literal<br>
unspecified IP address, as in &#34;:80&#34;, &#34;0.0.0.0:80&#34; or &#34;[::]:80&#34; for<br>
TCP and UDP, &#34;&#34;, &#34;0.0.0.0&#34; or &#34;::&#34; for IP, the local system is<br>
assumed.<br>
<br>
For Unix networks, the address must be a file system path.<br>
<br>
Go input arguments: (network string, address string)<br>
<br>
Go return type: (Conn, error)<br>
<br>
Joker input arguments: [^String network, ^String address]<br>
<br>
Joker return type: [go.std.net/Conn Error]</p>
</li>
<li>
  <h3 id="DialIP">DialIP</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(DialIP __network __laddr __raddr)</code></div>
</pre>
  <p class="var-docstr">DialIP acts like Dial for IP networks.<br>
<br>
The network must be an IP network name; see func Dial for details.<br>
<br>
If laddr is nil, a local address is automatically chosen.<br>
If the IP field of raddr is nil or an unspecified IP address, the<br>
local system is assumed.<br>
<br>
Go input arguments: (network string, laddr *IPAddr, raddr *IPAddr)<br>
<br>
Go return type: (*IPConn, error)<br>
<br>
Joker input arguments: [^String network, ^(atom-of go.std.net/IPAddr) laddr, ^(atom-of go.std.net/IPAddr) raddr]<br>
<br>
Joker return type: [(atom-of go.std.net/IPConn) Error]</p>
</li>
<li>
  <h3 id="DialTCP">DialTCP</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(DialTCP __network __laddr __raddr)</code></div>
</pre>
  <p class="var-docstr">DialTCP acts like Dial for TCP networks.<br>
<br>
The network must be a TCP network name; see func Dial for details.<br>
<br>
If laddr is nil, a local address is automatically chosen.<br>
If the IP field of raddr is nil or an unspecified IP address, the<br>
local system is assumed.<br>
<br>
Go input arguments: (network string, laddr *TCPAddr, raddr *TCPAddr)<br>
<br>
Go return type: (*TCPConn, error)<br>
<br>
Joker input arguments: [^String network, ^(atom-of go.std.net/TCPAddr) laddr, ^(atom-of go.std.net/TCPAddr) raddr]<br>
<br>
Joker return type: [(atom-of go.std.net/TCPConn) Error]</p>
</li>
<li>
  <h3 id="DialUDP">DialUDP</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(DialUDP __network __laddr __raddr)</code></div>
</pre>
  <p class="var-docstr">DialUDP acts like Dial for UDP networks.<br>
<br>
The network must be a UDP network name; see func Dial for details.<br>
<br>
If laddr is nil, a local address is automatically chosen.<br>
If the IP field of raddr is nil or an unspecified IP address, the<br>
local system is assumed.<br>
<br>
Go input arguments: (network string, laddr *UDPAddr, raddr *UDPAddr)<br>
<br>
Go return type: (*UDPConn, error)<br>
<br>
Joker input arguments: [^String network, ^(atom-of go.std.net/UDPAddr) laddr, ^(atom-of go.std.net/UDPAddr) raddr]<br>
<br>
Joker return type: [(atom-of go.std.net/UDPConn) Error]</p>
</li>
<li>
  <h3 id="DialUnix">DialUnix</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(DialUnix __network __laddr __raddr)</code></div>
</pre>
  <p class="var-docstr">DialUnix acts like Dial for Unix networks.<br>
<br>
The network must be a Unix network name; see func Dial for details.<br>
<br>
If laddr is non-nil, it is used as the local address for the<br>
connection.<br>
<br>
Go input arguments: (network string, laddr *UnixAddr, raddr *UnixAddr)<br>
<br>
Go return type: (*UnixConn, error)<br>
<br>
Joker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr, ^(atom-of go.std.net/UnixAddr) raddr]<br>
<br>
Joker return type: [(atom-of go.std.net/UnixConn) Error]</p>
</li>
<li>
  <h3 id="Flags.">Flags.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Flags. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for net.Flags</p>
</li>
<li>
  <h3 id="IPConn.">IPConn.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(IPConn. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for net.IPConn</p>
</li>
<li>
  <h3 id="IPv4">IPv4</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(IPv4 __a __b __c __d)</code></div>
</pre>
  <p class="var-docstr">IPv4 returns the IP address (in 16-byte form) of the<br>
IPv4 address a.b.c.d.<br>
<br>
Go input arguments: (a byte, b byte, c byte, d byte)<br>
<br>
Go return type: IP<br>
<br>
Joker input arguments: [^Int a, ^Int b, ^Int c, ^Int d]<br>
<br>
Joker return type: go.std.net/IP</p>
</li>
<li>
  <h3 id="IPv4Mask">IPv4Mask</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(IPv4Mask __a __b __c __d)</code></div>
</pre>
  <p class="var-docstr">IPv4Mask returns the IP mask (in 4-byte form) of the<br>
IPv4 mask a.b.c.d.<br>
<br>
Go input arguments: (a byte, b byte, c byte, d byte)<br>
<br>
Go return type: IPMask<br>
<br>
Joker input arguments: [^Int a, ^Int b, ^Int c, ^Int d]<br>
<br>
Joker return type: go.std.net/IPMask</p>
</li>
<li>
  <h3 id="InterfaceAddrs">InterfaceAddrs</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(InterfaceAddrs)</code></div>
</pre>
  <p class="var-docstr">InterfaceAddrs returns a list of the system&#39;s unicast interface<br>
addresses.<br>
<br>
The returned list does not identify the associated interface; use<br>
Interfaces and Interface.Addrs for more detail.<br>
<br>
Go return type: ([]Addr, error)<br>
<br>
Joker input arguments: []<br>
<br>
Joker return type: [(vector-of go.std.net/Addr) Error]</p>
</li>
<li>
  <h3 id="InterfaceByIndex">InterfaceByIndex</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(InterfaceByIndex __index)</code></div>
</pre>
  <p class="var-docstr">InterfaceByIndex returns the interface specified by index.<br>
<br>
On Solaris, it returns one of the logical network interfaces<br>
sharing the logical data link; for more precision use<br>
InterfaceByName.<br>
<br>
Go input arguments: (index int)<br>
<br>
Go return type: (*Interface, error)<br>
<br>
Joker input arguments: [^Int index]<br>
<br>
Joker return type: [(atom-of go.std.net/Interface) Error]</p>
</li>
<li>
  <h3 id="InterfaceByName">InterfaceByName</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(InterfaceByName __name)</code></div>
</pre>
  <p class="var-docstr">InterfaceByName returns the interface specified by name.<br>
<br>
Go input arguments: (name string)<br>
<br>
Go return type: (*Interface, error)<br>
<br>
Joker input arguments: [^String name]<br>
<br>
Joker return type: [(atom-of go.std.net/Interface) Error]</p>
</li>
<li>
  <h3 id="Interfaces">Interfaces</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Interfaces)</code></div>
</pre>
  <p class="var-docstr">Interfaces returns a list of the system&#39;s network interfaces.<br>
<br>
Go return type: ([]Interface, error)<br>
<br>
Joker input arguments: []<br>
<br>
Joker return type: [(vector-of go.std.net/Interface) Error]</p>
</li>
<li>
  <h3 id="InvalidAddrError.">InvalidAddrError.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(InvalidAddrError. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for net.InvalidAddrError</p>
</li>
<li>
  <h3 id="JoinHostPort">JoinHostPort</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(JoinHostPort __host __port)</code></div>
</pre>
  <p class="var-docstr">JoinHostPort combines host and port into a network address of the<br>
form &#34;host:port&#34;. If host contains a colon, as found in literal<br>
IPv6 addresses, then JoinHostPort returns &#34;[host]:port&#34;.<br>
<br>
See func Dial for a description of the host and port parameters.<br>
<br>
Go input arguments: (host string, port string)<br>
<br>
Go return type: string<br>
<br>
Joker input arguments: [^String host, ^String port]<br>
<br>
Joker return type: String</p>
</li>
<li>
  <h3 id="Listen">Listen</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Listen __network __address)</code></div>
</pre>
  <p class="var-docstr">Listen announces on the local network address.<br>
<br>
The network must be &#34;tcp&#34;, &#34;tcp4&#34;, &#34;tcp6&#34;, &#34;unix&#34; or &#34;unixpacket&#34;.<br>
<br>
For TCP networks, if the host in the address parameter is empty or<br>
a literal unspecified IP address, Listen listens on all available<br>
unicast and anycast IP addresses of the local system.<br>
To only use IPv4, use network &#34;tcp4&#34;.<br>
The address can use a host name, but this is not recommended,<br>
because it will create a listener for at most one of the host&#39;s IP<br>
addresses.<br>
If the port in the address parameter is empty or &#34;0&#34;, as in<br>
&#34;127.0.0.1:&#34; or &#34;[::1]:0&#34;, a port number is automatically chosen.<br>
The Addr method of Listener can be used to discover the chosen<br>
port.<br>
<br>
See func Dial for a description of the network and address<br>
parameters.<br>
<br>
Go input arguments: (network string, address string)<br>
<br>
Go return type: (Listener, error)<br>
<br>
Joker input arguments: [^String network, ^String address]<br>
<br>
Joker return type: [go.std.net/Listener Error]</p>
</li>
<li>
  <h3 id="ListenIP">ListenIP</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ListenIP __network __laddr)</code></div>
</pre>
  <p class="var-docstr">ListenIP acts like ListenPacket for IP networks.<br>
<br>
The network must be an IP network name; see func Dial for details.<br>
<br>
If the IP field of laddr is nil or an unspecified IP address,<br>
ListenIP listens on all available IP addresses of the local system<br>
except multicast IP addresses.<br>
<br>
Go input arguments: (network string, laddr *IPAddr)<br>
<br>
Go return type: (*IPConn, error)<br>
<br>
Joker input arguments: [^String network, ^(atom-of go.std.net/IPAddr) laddr]<br>
<br>
Joker return type: [(atom-of go.std.net/IPConn) Error]</p>
</li>
<li>
  <h3 id="ListenMulticastUDP">ListenMulticastUDP</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ListenMulticastUDP __network __ifi __gaddr)</code></div>
</pre>
  <p class="var-docstr">ListenMulticastUDP acts like ListenPacket for UDP networks but<br>
takes a group address on a specific network interface.<br>
<br>
The network must be a UDP network name; see func Dial for details.<br>
<br>
ListenMulticastUDP listens on all available IP addresses of the<br>
local system including the group, multicast IP address.<br>
If ifi is nil, ListenMulticastUDP uses the system-assigned<br>
multicast interface, although this is not recommended because the<br>
assignment depends on platforms and sometimes it might require<br>
routing configuration.<br>
If the Port field of gaddr is 0, a port number is automatically<br>
chosen.<br>
<br>
ListenMulticastUDP is just for convenience of simple, small<br>
applications. There are golang.org/x/net/ipv4 and<br>
golang.org/x/net/ipv6 packages for general purpose uses.<br>
<br>
Go input arguments: (network string, ifi *Interface, gaddr *UDPAddr)<br>
<br>
Go return type: (*UDPConn, error)<br>
<br>
Joker input arguments: [^String network, ^(atom-of go.std.net/Interface) ifi, ^(atom-of go.std.net/UDPAddr) gaddr]<br>
<br>
Joker return type: [(atom-of go.std.net/UDPConn) Error]</p>
</li>
<li>
  <h3 id="ListenPacket">ListenPacket</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ListenPacket __network __address)</code></div>
</pre>
  <p class="var-docstr">ListenPacket announces on the local network address.<br>
<br>
The network must be &#34;udp&#34;, &#34;udp4&#34;, &#34;udp6&#34;, &#34;unixgram&#34;, or an IP<br>
transport. The IP transports are &#34;ip&#34;, &#34;ip4&#34;, or &#34;ip6&#34; followed by<br>
a colon and a literal protocol number or a protocol name, as in<br>
&#34;ip:1&#34; or &#34;ip:icmp&#34;.<br>
<br>
For UDP and IP networks, if the host in the address parameter is<br>
empty or a literal unspecified IP address, ListenPacket listens on<br>
all available IP addresses of the local system except multicast IP<br>
addresses.<br>
To only use IPv4, use network &#34;udp4&#34; or &#34;ip4:proto&#34;.<br>
The address can use a host name, but this is not recommended,<br>
because it will create a listener for at most one of the host&#39;s IP<br>
addresses.<br>
If the port in the address parameter is empty or &#34;0&#34;, as in<br>
&#34;127.0.0.1:&#34; or &#34;[::1]:0&#34;, a port number is automatically chosen.<br>
The LocalAddr method of PacketConn can be used to discover the<br>
chosen port.<br>
<br>
See func Dial for a description of the network and address<br>
parameters.<br>
<br>
Go input arguments: (network string, address string)<br>
<br>
Go return type: (PacketConn, error)<br>
<br>
Joker input arguments: [^String network, ^String address]<br>
<br>
Joker return type: [go.std.net/PacketConn Error]</p>
</li>
<li>
  <h3 id="ListenTCP">ListenTCP</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ListenTCP __network __laddr)</code></div>
</pre>
  <p class="var-docstr">ListenTCP acts like Listen for TCP networks.<br>
<br>
The network must be a TCP network name; see func Dial for details.<br>
<br>
If the IP field of laddr is nil or an unspecified IP address,<br>
ListenTCP listens on all available unicast and anycast IP addresses<br>
of the local system.<br>
If the Port field of laddr is 0, a port number is automatically<br>
chosen.<br>
<br>
Go input arguments: (network string, laddr *TCPAddr)<br>
<br>
Go return type: (*TCPListener, error)<br>
<br>
Joker input arguments: [^String network, ^(atom-of go.std.net/TCPAddr) laddr]<br>
<br>
Joker return type: [(atom-of go.std.net/TCPListener) Error]</p>
</li>
<li>
  <h3 id="ListenUDP">ListenUDP</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ListenUDP __network __laddr)</code></div>
</pre>
  <p class="var-docstr">ListenUDP acts like ListenPacket for UDP networks.<br>
<br>
The network must be a UDP network name; see func Dial for details.<br>
<br>
If the IP field of laddr is nil or an unspecified IP address,<br>
ListenUDP listens on all available IP addresses of the local system<br>
except multicast IP addresses.<br>
If the Port field of laddr is 0, a port number is automatically<br>
chosen.<br>
<br>
Go input arguments: (network string, laddr *UDPAddr)<br>
<br>
Go return type: (*UDPConn, error)<br>
<br>
Joker input arguments: [^String network, ^(atom-of go.std.net/UDPAddr) laddr]<br>
<br>
Joker return type: [(atom-of go.std.net/UDPConn) Error]</p>
</li>
<li>
  <h3 id="ListenUnix">ListenUnix</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ListenUnix __network __laddr)</code></div>
</pre>
  <p class="var-docstr">ListenUnix acts like Listen for Unix networks.<br>
<br>
The network must be &#34;unix&#34; or &#34;unixpacket&#34;.<br>
<br>
Go input arguments: (network string, laddr *UnixAddr)<br>
<br>
Go return type: (*UnixListener, error)<br>
<br>
Joker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr]<br>
<br>
Joker return type: [(atom-of go.std.net/UnixListener) Error]</p>
</li>
<li>
  <h3 id="ListenUnixgram">ListenUnixgram</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ListenUnixgram __network __laddr)</code></div>
</pre>
  <p class="var-docstr">ListenUnixgram acts like ListenPacket for Unix networks.<br>
<br>
The network must be &#34;unixgram&#34;.<br>
<br>
Go input arguments: (network string, laddr *UnixAddr)<br>
<br>
Go return type: (*UnixConn, error)<br>
<br>
Joker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr]<br>
<br>
Joker return type: [(atom-of go.std.net/UnixConn) Error]</p>
</li>
<li>
  <h3 id="LookupAddr">LookupAddr</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(LookupAddr __addr)</code></div>
</pre>
  <p class="var-docstr">LookupAddr performs a reverse lookup for the given address, returning a list<br>
of names mapping to that address.<br>
<br>
When using the host C library resolver, at most one result will be<br>
returned. To bypass the host resolver, use a custom Resolver.<br>
<br>
Go input arguments: (addr string)<br>
<br>
Go return type: (names []string, err error)<br>
<br>
Joker input arguments: [^String addr]<br>
<br>
Joker return type: [(vector-of String) Error]</p>
</li>
<li>
  <h3 id="LookupCNAME">LookupCNAME</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(LookupCNAME __host)</code></div>
</pre>
  <p class="var-docstr">LookupCNAME returns the canonical name for the given host.<br>
Callers that do not care about the canonical name can call<br>
LookupHost or LookupIP directly; both take care of resolving<br>
the canonical name as part of the lookup.<br>
<br>
A canonical name is the final name after following zero<br>
or more CNAME records.<br>
LookupCNAME does not return an error if host does not<br>
contain DNS &#34;CNAME&#34; records, as long as host resolves to<br>
address records.<br>
<br>
Go input arguments: (host string)<br>
<br>
Go return type: (cname string, err error)<br>
<br>
Joker input arguments: [^String host]<br>
<br>
Joker return type: [String Error]</p>
</li>
<li>
  <h3 id="LookupHost">LookupHost</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(LookupHost __host)</code></div>
</pre>
  <p class="var-docstr">LookupHost looks up the given host using the local resolver.<br>
It returns a slice of that host&#39;s addresses.<br>
<br>
Go input arguments: (host string)<br>
<br>
Go return type: (addrs []string, err error)<br>
<br>
Joker input arguments: [^String host]<br>
<br>
Joker return type: [(vector-of String) Error]</p>
</li>
<li>
  <h3 id="LookupIP">LookupIP</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(LookupIP __host)</code></div>
</pre>
  <p class="var-docstr">LookupIP looks up host using the local resolver.<br>
It returns a slice of that host&#39;s IPv4 and IPv6 addresses.<br>
<br>
Go input arguments: (host string)<br>
<br>
Go return type: ([]IP, error)<br>
<br>
Joker input arguments: [^String host]<br>
<br>
Joker return type: [(vector-of go.std.net/IP) Error]</p>
</li>
<li>
  <h3 id="LookupMX">LookupMX</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(LookupMX __name)</code></div>
</pre>
  <p class="var-docstr">LookupMX returns the DNS MX records for the given domain name sorted by preference.<br>
<br>
Go input arguments: (name string)<br>
<br>
Go return type: ([]*MX, error)<br>
<br>
Joker input arguments: [^String name]<br>
<br>
Joker return type: [(vector-of (atom-of go.std.net/MX)) Error]</p>
</li>
<li>
  <h3 id="LookupNS">LookupNS</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(LookupNS __name)</code></div>
</pre>
  <p class="var-docstr">LookupNS returns the DNS NS records for the given domain name.<br>
<br>
Go input arguments: (name string)<br>
<br>
Go return type: ([]*NS, error)<br>
<br>
Joker input arguments: [^String name]<br>
<br>
Joker return type: [(vector-of (atom-of go.std.net/NS)) Error]</p>
</li>
<li>
  <h3 id="LookupPort">LookupPort</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(LookupPort __network __service)</code></div>
</pre>
  <p class="var-docstr">LookupPort looks up the port for the given network and service.<br>
<br>
Go input arguments: (network string, service string)<br>
<br>
Go return type: (port int, err error)<br>
<br>
Joker input arguments: [^String network, ^String service]<br>
<br>
Joker return type: [Int Error]</p>
</li>
<li>
  <h3 id="LookupSRV">LookupSRV</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(LookupSRV __service __proto __name)</code></div>
</pre>
  <p class="var-docstr">LookupSRV tries to resolve an SRV query of the given service,<br>
protocol, and domain name. The proto is &#34;tcp&#34; or &#34;udp&#34;.<br>
The returned records are sorted by priority and randomized<br>
by weight within a priority.<br>
<br>
LookupSRV constructs the DNS name to look up following RFC 2782.<br>
That is, it looks up _service._proto.name. To accommodate services<br>
publishing SRV records under non-standard names, if both service<br>
and proto are empty strings, LookupSRV looks up name directly.<br>
<br>
Go input arguments: (service string, proto string, name string)<br>
<br>
Go return type: (cname string, addrs []*SRV, err error)<br>
<br>
Joker input arguments: [^String service, ^String proto, ^String name]<br>
<br>
Joker return type: [String (vector-of (atom-of go.std.net/SRV)) Error]</p>
</li>
<li>
  <h3 id="LookupTXT">LookupTXT</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(LookupTXT __name)</code></div>
</pre>
  <p class="var-docstr">LookupTXT returns the DNS TXT records for the given domain name.<br>
<br>
Go input arguments: (name string)<br>
<br>
Go return type: ([]string, error)<br>
<br>
Joker input arguments: [^String name]<br>
<br>
Joker return type: [(vector-of String) Error]</p>
</li>
<li>
  <h3 id="MX.">MX.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(MX. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for net.MX</p>
</li>
<li>
  <h3 id="NS.">NS.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(NS. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for net.NS</p>
</li>
<li>
  <h3 id="ParseCIDR">ParseCIDR</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ParseCIDR __s)</code></div>
</pre>
  <p class="var-docstr">ParseCIDR parses s as a CIDR notation IP address and prefix length,<br>
like &#34;192.0.2.0/24&#34; or &#34;2001:db8::/32&#34;, as defined in<br>
RFC 4632 and RFC 4291.<br>
<br>
It returns the IP address and the network implied by the IP and<br>
prefix length.<br>
For example, ParseCIDR(&#34;192.0.2.1/24&#34;) returns the IP address<br>
192.0.2.1 and the network 192.0.2.0/24.<br>
<br>
Go input arguments: (s string)<br>
<br>
Go return type: (IP, *IPNet, error)<br>
<br>
Joker input arguments: [^String s]<br>
<br>
Joker return type: [go.std.net/IP (atom-of go.std.net/IPNet) Error]</p>
</li>
<li>
  <h3 id="ParseError.">ParseError.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ParseError. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for net.ParseError</p>
</li>
<li>
  <h3 id="ParseIP">ParseIP</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ParseIP __s)</code></div>
</pre>
  <p class="var-docstr">ParseIP parses s as an IP address, returning the result.<br>
The string s can be in dotted decimal (&#34;192.0.2.1&#34;)<br>
or IPv6 (&#34;2001:db8::68&#34;) form.<br>
If s is not a valid textual representation of an IP address,<br>
ParseIP returns nil.<br>
<br>
Go input arguments: (s string)<br>
<br>
Go return type: IP<br>
<br>
Joker input arguments: [^String s]<br>
<br>
Joker return type: go.std.net/IP</p>
</li>
<li>
  <h3 id="ParseMAC">ParseMAC</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ParseMAC __s)</code></div>
</pre>
  <p class="var-docstr">ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet<br>
IP over InfiniBand link-layer address using one of the following formats:<br>
  01:23:45:67:89:ab<br>
  01:23:45:67:89:ab:cd:ef<br>
  01:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00<br>
  01-23-45-67-89-ab<br>
  01-23-45-67-89-ab-cd-ef<br>
  01-23-45-67-89-ab-cd-ef-00-00-01-23-45-67-89-ab-cd-ef-00-00<br>
  0123.4567.89ab<br>
  0123.4567.89ab.cdef<br>
  0123.4567.89ab.cdef.0000.0123.4567.89ab.cdef.0000<br>
<br>
Go input arguments: (s string)<br>
<br>
Go return type: (hw HardwareAddr, err error)<br>
<br>
Joker input arguments: [^String s]<br>
<br>
Joker return type: [go.std.net/HardwareAddr Error]</p>
</li>
<li>
  <h3 id="Pipe">Pipe</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(Pipe)</code></div>
</pre>
  <p class="var-docstr">Pipe creates a synchronous, in-memory, full duplex<br>
network connection; both ends implement the Conn interface.<br>
Reads on one end are matched with writes on the other,<br>
copying data directly between the two; there is no internal<br>
buffering.<br>
<br>
Go return type: (Conn, Conn)<br>
<br>
Joker input arguments: []<br>
<br>
Joker return type: [go.std.net/Conn go.std.net/Conn]</p>
</li>
<li>
  <h3 id="ResolveIPAddr">ResolveIPAddr</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ResolveIPAddr __network __address)</code></div>
</pre>
  <p class="var-docstr">ResolveIPAddr returns an address of IP end point.<br>
<br>
The network must be an IP network name.<br>
<br>
If the host in the address parameter is not a literal IP address,<br>
ResolveIPAddr resolves the address to an address of IP end point.<br>
Otherwise, it parses the address as a literal IP address.<br>
The address parameter can use a host name, but this is not<br>
recommended, because it will return at most one of the host name&#39;s<br>
IP addresses.<br>
<br>
See func Dial for a description of the network and address<br>
parameters.<br>
<br>
Go input arguments: (network string, address string)<br>
<br>
Go return type: (*IPAddr, error)<br>
<br>
Joker input arguments: [^String network, ^String address]<br>
<br>
Joker return type: [(atom-of go.std.net/IPAddr) Error]</p>
</li>
<li>
  <h3 id="ResolveTCPAddr">ResolveTCPAddr</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ResolveTCPAddr __network __address)</code></div>
</pre>
  <p class="var-docstr">ResolveTCPAddr returns an address of TCP end point.<br>
<br>
The network must be a TCP network name.<br>
<br>
If the host in the address parameter is not a literal IP address or<br>
the port is not a literal port number, ResolveTCPAddr resolves the<br>
address to an address of TCP end point.<br>
Otherwise, it parses the address as a pair of literal IP address<br>
and port number.<br>
The address parameter can use a host name, but this is not<br>
recommended, because it will return at most one of the host name&#39;s<br>
IP addresses.<br>
<br>
See func Dial for a description of the network and address<br>
parameters.<br>
<br>
Go input arguments: (network string, address string)<br>
<br>
Go return type: (*TCPAddr, error)<br>
<br>
Joker input arguments: [^String network, ^String address]<br>
<br>
Joker return type: [(atom-of go.std.net/TCPAddr) Error]</p>
</li>
<li>
  <h3 id="ResolveUDPAddr">ResolveUDPAddr</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ResolveUDPAddr __network __address)</code></div>
</pre>
  <p class="var-docstr">ResolveUDPAddr returns an address of UDP end point.<br>
<br>
The network must be a UDP network name.<br>
<br>
If the host in the address parameter is not a literal IP address or<br>
the port is not a literal port number, ResolveUDPAddr resolves the<br>
address to an address of UDP end point.<br>
Otherwise, it parses the address as a pair of literal IP address<br>
and port number.<br>
The address parameter can use a host name, but this is not<br>
recommended, because it will return at most one of the host name&#39;s<br>
IP addresses.<br>
<br>
See func Dial for a description of the network and address<br>
parameters.<br>
<br>
Go input arguments: (network string, address string)<br>
<br>
Go return type: (*UDPAddr, error)<br>
<br>
Joker input arguments: [^String network, ^String address]<br>
<br>
Joker return type: [(atom-of go.std.net/UDPAddr) Error]</p>
</li>
<li>
  <h3 id="ResolveUnixAddr">ResolveUnixAddr</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(ResolveUnixAddr __network __address)</code></div>
</pre>
  <p class="var-docstr">ResolveUnixAddr returns an address of Unix domain socket end point.<br>
<br>
The network must be a Unix network name.<br>
<br>
See func Dial for a description of the network and address<br>
parameters.<br>
<br>
Go input arguments: (network string, address string)<br>
<br>
Go return type: (*UnixAddr, error)<br>
<br>
Joker input arguments: [^String network, ^String address]<br>
<br>
Joker return type: [(atom-of go.std.net/UnixAddr) Error]</p>
</li>
<li>
  <h3 id="SRV.">SRV.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(SRV. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for net.SRV</p>
</li>
<li>
  <h3 id="SplitHostPort">SplitHostPort</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(SplitHostPort __hostport)</code></div>
</pre>
  <p class="var-docstr">SplitHostPort splits a network address of the form &#34;host:port&#34;,<br>
&#34;host%zone:port&#34;, &#34;[host]:port&#34; or &#34;[host%zone]:port&#34; into host or<br>
host%zone and port.<br>
<br>
A literal IPv6 address in hostport must be enclosed in square<br>
brackets, as in &#34;[::1]:80&#34;, &#34;[::1%lo0]:80&#34;.<br>
<br>
See func Dial for a description of the hostport parameter, and host<br>
and port results.<br>
<br>
Go input arguments: (hostport string)<br>
<br>
Go return type: (host string, port string, err error)<br>
<br>
Joker input arguments: [^String hostport]<br>
<br>
Joker return type: [String String Error]</p>
</li>
<li>
  <h3 id="TCPConn.">TCPConn.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(TCPConn. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for net.TCPConn</p>
</li>
<li>
  <h3 id="TCPListener.">TCPListener.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(TCPListener. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for net.TCPListener</p>
</li>
<li>
  <h3 id="UDPConn.">UDPConn.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(UDPConn. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for net.UDPConn</p>
</li>
<li>
  <h3 id="UnixAddr.">UnixAddr.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(UnixAddr. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for net.UnixAddr</p>
</li>
<li>
  <h3 id="UnixConn.">UnixConn.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(UnixConn. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for net.UnixConn</p>
</li>
<li>
  <h3 id="UnixListener.">UnixListener.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(UnixListener. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for net.UnixListener</p>
</li>
<li>
  <h3 id="UnknownNetworkError.">UnknownNetworkError.</h3>
  <span class="var-type Function">Function</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(UnknownNetworkError. _v)</code></div>
</pre>
  <p class="var-docstr">Constructor for net.UnknownNetworkError</p>
</li>

    </ul>
    <h2 id="_types">Types</h2>
    <ul>
      <li>
  <h3 id="MX">MX</h3>
  <span class="var-type GoType">GoType</span>
  <span class="var-added">v1.0</span>
  <pre class="var-usage"><div><code>(MX _v)</code></div>
</pre>
  <p class="var-docstr">GoType[net.MX]</p>
    <li>
    <h4 id="fixme">fixme</h4>
    <span class="var-type Receiver">Receiver</span>
    <span class="var-added">v1.0</span>
    <pre class="var-usage"></pre>
    <p class="var-docstr">wow this works</p>
  </li>
  <li>
    <h4 id="fixme">fixme</h4>
    <span class="var-type Receiver">Receiver</span>
    <span class="var-added">v1.0</span>
    <pre class="var-usage"></pre>
    <p class="var-docstr">this too!!</p>
  </li>

</li>

    </ul>
  </div>
</body>
</html>
