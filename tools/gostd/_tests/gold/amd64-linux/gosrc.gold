Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/archive
Processing archive:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/archive/tar
Processing archive/tar:
Matchfile(/usr/local/go-1.11.5/src/archive/tar/stat_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/archive/tar/reader.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/archive/tar/common.go) => true <nil>
Ignoring test code in tar_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/archive/tar/stat_actime2.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/archive/tar/format.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/archive/tar/writer.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/archive/tar/strconv.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/archive/tar/stat_actime1.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in writer_test.go
Ignoring test code in strconv_test.go
Processing package=archive/tar:
Excluding /usr/local/go-1.11.5/src/archive/tar/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/archive/zip
Processing archive/zip:
Matchfile(/usr/local/go-1.11.5/src/archive/zip/reader.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/archive/zip/struct.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/archive/zip/writer.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in writer_test.go
Ignoring test code in zip_test.go
Matchfile(/usr/local/go-1.11.5/src/archive/zip/register.go) => true <nil>
Processing package=archive/zip:
Excluding /usr/local/go-1.11.5/src/archive/zip/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/bufio
Processing bufio:
Ignoring test code in scan_test.go
Matchfile(/usr/local/go-1.11.5/src/bufio/scan.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Matchfile(/usr/local/go-1.11.5/src/bufio/bufio.go) => true <nil>
Ignoring test code in bufio_test.go
Processing package=bufio:
Excluding /usr/local/go-1.11.5/src/builtin
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/bytes
Processing bytes:
Matchfile(/usr/local/go-1.11.5/src/bytes/reader.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Ignoring test code in bytes_test.go
Matchfile(/usr/local/go-1.11.5/src/bytes/bytes.go) => true <nil>
Ignoring test code in boundary_test.go
Ignoring test code in compare_test.go
Matchfile(/usr/local/go-1.11.5/src/bytes/buffer.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in buffer_test.go
Matchfile(/usr/local/go-1.11.5/src/bytes/bytes_decl.go) => true <nil>
Processing package=bytes:
Excluding /usr/local/go-1.11.5/src/cmd
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/compress
Processing compress:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/compress/bzip2
Processing compress/bzip2:
Ignoring test code in bzip2_test.go
Matchfile(/usr/local/go-1.11.5/src/compress/bzip2/bzip2.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/compress/bzip2/bit_reader.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/compress/bzip2/move_to_front.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/compress/bzip2/huffman.go) => true <nil>
Processing package=compress/bzip2:
Excluding /usr/local/go-1.11.5/src/compress/bzip2/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/compress/flate
Processing compress/flate:
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/compress/flate/dict_decoder.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/compress/flate/deflate.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/compress/flate/inflate.go) => true <nil>
Ignoring test code in huffman_bit_writer_test.go
Matchfile(/usr/local/go-1.11.5/src/compress/flate/huffman_code.go) => true <nil>
Ignoring test code in deflate_test.go
Matchfile(/usr/local/go-1.11.5/src/compress/flate/deflatefast.go) => true <nil>
Ignoring test code in dict_decoder_test.go
Matchfile(/usr/local/go-1.11.5/src/compress/flate/huffman_bit_writer.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in inflate_test.go
Ignoring test code in writer_test.go
Ignoring test code in flate_test.go
Matchfile(/usr/local/go-1.11.5/src/compress/flate/token.go) => true <nil>
Processing package=compress/flate:
Excluding /usr/local/go-1.11.5/src/compress/flate/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/compress/gzip
Processing compress/gzip:
Ignoring test code in gunzip_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/compress/gzip/gunzip.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/compress/gzip/gzip.go) => true <nil>
Ignoring test code in gzip_test.go
Ignoring test code in issue14937_test.go
Processing package=compress/gzip:
Excluding /usr/local/go-1.11.5/src/compress/gzip/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/compress/lzw
Processing compress/lzw:
Matchfile(/usr/local/go-1.11.5/src/compress/lzw/reader.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/compress/lzw/writer.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in writer_test.go
Processing package=compress/lzw:
Excluding /usr/local/go-1.11.5/src/compress/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/compress/zlib
Processing compress/zlib:
Matchfile(/usr/local/go-1.11.5/src/compress/zlib/reader.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/compress/zlib/writer.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in writer_test.go
Processing package=compress/zlib:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/container
Processing container:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/container/heap
Processing container/heap:
Ignoring test code in example_intheap_test.go
Ignoring test code in heap_test.go
Ignoring test code in example_pq_test.go
Matchfile(/usr/local/go-1.11.5/src/container/heap/heap.go) => true <nil>
Processing package=container/heap:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/container/list
Processing container/list:
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/container/list/list.go) => true <nil>
Ignoring test code in list_test.go
Processing package=container/list:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/container/ring
Processing container/ring:
Matchfile(/usr/local/go-1.11.5/src/container/ring/ring.go) => true <nil>
Ignoring test code in ring_test.go
Ignoring test code in example_test.go
Processing package=container/ring:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/context
Processing context:
Ignoring test code in net_test.go
Ignoring test code in x_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/context/context.go) => true <nil>
Ignoring test code in context_test.go
Ignoring test code in benchmark_test.go
Processing package=context:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/crypto
Processing crypto:
Matchfile(/usr/local/go-1.11.5/src/crypto/crypto.go) => true <nil>
Ignoring test code in issue21104_test.go
Processing package=crypto:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/crypto/aes
Processing crypto/aes:
Matchfile(/usr/local/go-1.11.5/src/crypto/aes/cipher_s390x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/aes/ctr_s390x.go) => false <nil>
Ignoring test code in aes_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/aes/gcm_s390x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/aes/cipher.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/aes/modes.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/aes/block.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/aes/cipher_ppc64le.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/aes/cbc_s390x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/aes/cipher_generic.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/aes/cipher_asm.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/aes/const.go) => true <nil>
Ignoring test code in modes_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/aes/aes_gcm.go) => true <nil>
Processing package=crypto/aes:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/crypto/cipher
Processing crypto/cipher:
Matchfile(/usr/local/go-1.11.5/src/crypto/cipher/cfb.go) => true <nil>
Ignoring test code in xor_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/cipher/ofb.go) => true <nil>
Ignoring test code in cfb_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/cipher/cipher.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/cipher/xor.go) => true <nil>
Ignoring test code in cbc_aes_test.go
Ignoring test code in ctr_test.go
Ignoring test code in ctr_aes_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/cipher/cbc.go) => true <nil>
Ignoring test code in ofb_test.go
Ignoring test code in cipher_test.go
Ignoring test code in gcm_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/cipher/io.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/cipher/ctr.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/cipher/gcm.go) => true <nil>
Ignoring test code in benchmark_test.go
Ignoring test code in common_test.go
Processing package=crypto/cipher:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/crypto/des
Processing crypto/des:
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/des/cipher.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/des/block.go) => true <nil>
Ignoring test code in des_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/des/const.go) => true <nil>
Processing package=crypto/des:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/crypto/dsa
Processing crypto/dsa:
Matchfile(/usr/local/go-1.11.5/src/crypto/dsa/dsa.go) => true <nil>
Ignoring test code in dsa_test.go
Processing package=crypto/dsa:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/crypto/ecdsa
Processing crypto/ecdsa:
Ignoring test code in ecdsa_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/ecdsa/ecdsa.go) => true <nil>
Ignoring test code in example_test.go
Processing package=crypto/ecdsa:
Excluding /usr/local/go-1.11.5/src/crypto/ecdsa/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/crypto/elliptic
Processing crypto/elliptic:
Matchfile(/usr/local/go-1.11.5/src/crypto/elliptic/p256_asm.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/elliptic/p256_s390x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/elliptic/p256_generic.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/elliptic/elliptic.go) => true <nil>
Ignoring test code in elliptic_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/elliptic/p224.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/elliptic/p256.go) => false <nil>
Ignoring test code in fuzz_test.go
Ignoring test code in p224_test.go
Processing package=crypto/elliptic:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/crypto/hmac
Processing crypto/hmac:
Ignoring test code in hmac_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/hmac/hmac.go) => true <nil>
Processing package=crypto/hmac:
Excluding /usr/local/go-1.11.5/src/crypto/internal
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/crypto/md5
Processing crypto/md5:
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/md5/md5block_generic.go) => false <nil>
Ignoring test code in md5_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/md5/md5block_decl.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/md5/md5block.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/md5/gen.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/md5/md5.go) => true <nil>
Processing package=crypto/md5:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/crypto/rand
Processing crypto/rand:
Matchfile(/usr/local/go-1.11.5/src/crypto/rand/rand_js.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/rand/rand_linux.go) => true <nil>
Ignoring test code in rand_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/rand/eagain.go) => true <nil>
Ignoring test code in rand_linux_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/rand/util.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in util_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/rand/rand.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/rand/rand_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/rand/rand_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/rand/rand_openbsd.go) => false <nil>
Processing package=crypto/rand:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/crypto/rc4
Processing crypto/rc4:
Ignoring test code in rc4_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/rc4/rc4_asm.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/rc4/rc4_ref.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/rc4/rc4.go) => true <nil>
Processing package=crypto/rc4:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/crypto/rsa
Processing crypto/rsa:
Matchfile(/usr/local/go-1.11.5/src/crypto/rsa/pss.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/rsa/rsa.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/rsa/pkcs1v15.go) => true <nil>
Ignoring test code in pkcs1v15_test.go
Ignoring test code in pss_test.go
Ignoring test code in rsa_test.go
Processing package=crypto/rsa:
Excluding /usr/local/go-1.11.5/src/crypto/rsa/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/crypto/sha1
Processing crypto/sha1:
Matchfile(/usr/local/go-1.11.5/src/crypto/sha1/sha1block_decl.go) => false <nil>
Ignoring test code in example_test.go
Ignoring test code in sha1_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/sha1/sha1block_amd64.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/sha1/sha1block_s390x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/sha1/sha1block_arm64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/sha1/sha1block_generic.go) => false <nil>
Ignoring test code in issue15617_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/sha1/sha1.go) => true <nil>
Ignoring test code in fallback_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/sha1/sha1block.go) => true <nil>
Processing package=crypto/sha1:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/crypto/sha256
Processing crypto/sha256:
Matchfile(/usr/local/go-1.11.5/src/crypto/sha256/sha256block_s390x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/sha256/sha256block_arm64.go) => false <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/sha256/sha256block_decl.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/sha256/sha256block.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/sha256/sha256block_amd64.go) => true <nil>
Ignoring test code in sha256_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/sha256/sha256.go) => true <nil>
Ignoring test code in fallback_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/sha256/sha256block_generic.go) => false <nil>
Processing package=crypto/sha256:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/crypto/sha512
Processing crypto/sha512:
Ignoring test code in sha512_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/sha512/sha512block_generic.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/sha512/sha512.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/sha512/sha512block_decl.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/sha512/sha512block_s390x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/sha512/sha512block.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/sha512/sha512block_amd64.go) => true <nil>
Ignoring test code in fallback_test.go
Processing package=crypto/sha512:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/crypto/subtle
Processing crypto/subtle:
Matchfile(/usr/local/go-1.11.5/src/crypto/subtle/constant_time.go) => true <nil>
Ignoring test code in constant_time_test.go
Processing package=crypto/subtle:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/crypto/tls
Processing crypto/tls:
Matchfile(/usr/local/go-1.11.5/src/crypto/tls/tls.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/tls/key_agreement.go) => true <nil>
Ignoring test code in auth_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/tls/common.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/tls/handshake_server.go) => true <nil>
Ignoring test code in tls_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/tls/cipher_suites.go) => true <nil>
Ignoring test code in handshake_messages_test.go
Ignoring test code in handshake_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/tls/handshake_messages.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/tls/handshake_client.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/tls/alert.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/tls/prf.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/tls/generate_cert.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/tls/ticket.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/tls/conn.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/tls/auth.go) => true <nil>
Ignoring test code in conn_test.go
Ignoring test code in handshake_server_test.go
Ignoring test code in handshake_client_test.go
Ignoring test code in prf_test.go
Processing package=crypto/tls:
Excluding /usr/local/go-1.11.5/src/crypto/tls/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/crypto/x509
Processing crypto/x509:
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/sec1.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/x509.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/x509_test_import.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/pkcs1.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/root_cgo_darwin.go) => false <nil>
Ignoring test code in verify_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/cert_pool.go) => true <nil>
Ignoring test code in name_constraints_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/root_nacl.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/root_bsd.go) => false <nil>
Ignoring test code in x509_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/root_solaris.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/root_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/root.go) => true <nil>
Ignoring test code in pkcs8_test.go
Ignoring test code in sec1_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/root_nocgo_darwin.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/pem_decrypt.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/root_darwin_armx.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/verify.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/root_darwin_arm_gen.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/root_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/pkcs8.go) => true <nil>
Ignoring test code in root_unix_test.go
Ignoring test code in pem_decrypt_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/root_linux.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/root_js.go) => false <nil>
Ignoring test code in root_darwin_test.go
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/root_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/root_darwin.go) => false <nil>
Processing package=crypto/x509:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/crypto/x509/pkix
Processing crypto/x509/pkix:
Matchfile(/usr/local/go-1.11.5/src/crypto/x509/pkix/pkix.go) => true <nil>
Processing package=crypto/x509/pkix:
Excluding /usr/local/go-1.11.5/src/crypto/x509/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/database
Processing database:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/database/sql
Processing database/sql:
Ignoring test code in sql_test.go
Ignoring test code in fakedb_test.go
Matchfile(/usr/local/go-1.11.5/src/database/sql/sql.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/database/sql/convert.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/database/sql/ctxutil.go) => true <nil>
Ignoring test code in convert_test.go
Processing package=database/sql:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/database/sql/driver
Processing database/sql/driver:
Ignoring test code in types_test.go
Matchfile(/usr/local/go-1.11.5/src/database/sql/driver/driver.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/database/sql/driver/types.go) => true <nil>
Processing package=database/sql/driver:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/debug
Processing debug:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/debug/dwarf
Processing debug/dwarf:
Matchfile(/usr/local/go-1.11.5/src/debug/dwarf/line.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/debug/dwarf/typeunit.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/debug/dwarf/type.go) => true <nil>
Ignoring test code in export_test.go
Ignoring test code in type_test.go
Matchfile(/usr/local/go-1.11.5/src/debug/dwarf/attr_string.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/debug/dwarf/entry.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/debug/dwarf/open.go) => true <nil>
Ignoring test code in line_test.go
Matchfile(/usr/local/go-1.11.5/src/debug/dwarf/buf.go) => true <nil>
Ignoring test code in entry_test.go
Matchfile(/usr/local/go-1.11.5/src/debug/dwarf/const.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/debug/dwarf/unit.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/debug/dwarf/class_string.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/debug/dwarf/tag_string.go) => true <nil>
Processing package=debug/dwarf:
Excluding /usr/local/go-1.11.5/src/debug/dwarf/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/debug/elf
Processing debug/elf:
Matchfile(/usr/local/go-1.11.5/src/debug/elf/reader.go) => true <nil>
Ignoring test code in symbols_test.go
Ignoring test code in file_test.go
Matchfile(/usr/local/go-1.11.5/src/debug/elf/file.go) => true <nil>
Ignoring test code in elf_test.go
Matchfile(/usr/local/go-1.11.5/src/debug/elf/elf.go) => true <nil>
Processing package=debug/elf:
Excluding /usr/local/go-1.11.5/src/debug/elf/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/debug/gosym
Processing debug/gosym:
Matchfile(/usr/local/go-1.11.5/src/debug/gosym/symtab.go) => true <nil>
Ignoring test code in pclntab_test.go
Ignoring test code in symtab_test.go
Matchfile(/usr/local/go-1.11.5/src/debug/gosym/pclntab.go) => true <nil>
Processing package=debug/gosym:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/debug/macho
Processing debug/macho:
Matchfile(/usr/local/go-1.11.5/src/debug/macho/reloctype_string.go) => true <nil>
Ignoring test code in file_test.go
Matchfile(/usr/local/go-1.11.5/src/debug/macho/file.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/debug/macho/fat.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/debug/macho/reloctype.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/debug/macho/macho.go) => true <nil>
Processing package=debug/macho:
Excluding /usr/local/go-1.11.5/src/debug/macho/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/debug/pe
Processing debug/pe:
Ignoring test code in file_cgo_test.go
Matchfile(/usr/local/go-1.11.5/src/debug/pe/string.go) => true <nil>
Ignoring test code in file_test.go
Matchfile(/usr/local/go-1.11.5/src/debug/pe/file.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/debug/pe/pe.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/debug/pe/symbol.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/debug/pe/section.go) => true <nil>
Processing package=debug/pe:
Excluding /usr/local/go-1.11.5/src/debug/pe/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/debug/plan9obj
Processing debug/plan9obj:
Ignoring test code in file_test.go
Matchfile(/usr/local/go-1.11.5/src/debug/plan9obj/file.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/debug/plan9obj/plan9obj.go) => true <nil>
Processing package=debug/plan9obj:
Excluding /usr/local/go-1.11.5/src/debug/plan9obj/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/encoding
Processing encoding:
Matchfile(/usr/local/go-1.11.5/src/encoding/encoding.go) => true <nil>
Processing package=encoding:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/encoding/ascii85
Processing encoding/ascii85:
Ignoring test code in ascii85_test.go
Matchfile(/usr/local/go-1.11.5/src/encoding/ascii85/ascii85.go) => true <nil>
Processing package=encoding/ascii85:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/encoding/asn1
Processing encoding/asn1:
Ignoring test code in marshal_test.go
Matchfile(/usr/local/go-1.11.5/src/encoding/asn1/common.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/encoding/asn1/asn1.go) => true <nil>
Ignoring test code in asn1_test.go
Matchfile(/usr/local/go-1.11.5/src/encoding/asn1/marshal.go) => true <nil>
Processing package=encoding/asn1:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/encoding/base32
Processing encoding/base32:
Matchfile(/usr/local/go-1.11.5/src/encoding/base32/base32.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in base32_test.go
Processing package=encoding/base32:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/encoding/base64
Processing encoding/base64:
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/encoding/base64/base64.go) => true <nil>
Ignoring test code in base64_test.go
Processing package=encoding/base64:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/encoding/binary
Processing encoding/binary:
Ignoring test code in varint_test.go
Matchfile(/usr/local/go-1.11.5/src/encoding/binary/varint.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/encoding/binary/binary.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in binary_test.go
Processing package=encoding/binary:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/encoding/csv
Processing encoding/csv:
Matchfile(/usr/local/go-1.11.5/src/encoding/csv/reader.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/encoding/csv/writer.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in writer_test.go
Processing package=encoding/csv:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/encoding/gob
Processing encoding/gob:
Matchfile(/usr/local/go-1.11.5/src/encoding/gob/doc.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/encoding/gob/type.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/encoding/gob/debug.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/encoding/gob/encoder.go) => true <nil>
Ignoring test code in encoder_test.go
Matchfile(/usr/local/go-1.11.5/src/encoding/gob/decoder.go) => true <nil>
Ignoring test code in type_test.go
Matchfile(/usr/local/go-1.11.5/src/encoding/gob/encode.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/encoding/gob/error.go) => true <nil>
Ignoring test code in example_interface_test.go
Ignoring test code in gobencdec_test.go
Matchfile(/usr/local/go-1.11.5/src/encoding/gob/dump.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/encoding/gob/encgen.go) => false <nil>
Ignoring test code in codec_test.go
Ignoring test code in example_encdec_test.go
Ignoring test code in timing_test.go
Matchfile(/usr/local/go-1.11.5/src/encoding/gob/decode.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/encoding/gob/decgen.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/encoding/gob/dec_helpers.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/encoding/gob/enc_helpers.go) => true <nil>
Processing package=encoding/gob:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/encoding/hex
Processing encoding/hex:
Matchfile(/usr/local/go-1.11.5/src/encoding/hex/hex.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in hex_test.go
Processing package=encoding/hex:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/encoding/json
Processing encoding/json:
Ignoring test code in tags_test.go
Ignoring test code in stream_test.go
Matchfile(/usr/local/go-1.11.5/src/encoding/json/tables.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/encoding/json/indent.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/encoding/json/tags.go) => true <nil>
Ignoring test code in bench_test.go
Ignoring test code in tagkey_test.go
Matchfile(/usr/local/go-1.11.5/src/encoding/json/encode.go) => true <nil>
Ignoring test code in encode_test.go
Matchfile(/usr/local/go-1.11.5/src/encoding/json/scanner.go) => true <nil>
Ignoring test code in decode_test.go
Ignoring test code in fold_test.go
Matchfile(/usr/local/go-1.11.5/src/encoding/json/stream.go) => true <nil>
Ignoring test code in example_marshaling_test.go
Ignoring test code in scanner_test.go
Ignoring test code in number_test.go
Matchfile(/usr/local/go-1.11.5/src/encoding/json/fold.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/encoding/json/decode.go) => true <nil>
Processing package=encoding/json:
Excluding /usr/local/go-1.11.5/src/encoding/json/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/encoding/pem
Processing encoding/pem:
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/encoding/pem/pem.go) => true <nil>
Ignoring test code in pem_test.go
Processing package=encoding/pem:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/encoding/xml
Processing encoding/xml:
Matchfile(/usr/local/go-1.11.5/src/encoding/xml/xml.go) => true <nil>
Ignoring test code in marshal_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/encoding/xml/marshal.go) => true <nil>
Ignoring test code in atom_test.go
Matchfile(/usr/local/go-1.11.5/src/encoding/xml/typeinfo.go) => true <nil>
Ignoring test code in read_test.go
Matchfile(/usr/local/go-1.11.5/src/encoding/xml/read.go) => true <nil>
Ignoring test code in xml_test.go
Processing package=encoding/xml:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/errors
Processing errors:
Ignoring test code in example_test.go
Ignoring test code in errors_test.go
Matchfile(/usr/local/go-1.11.5/src/errors/errors.go) => true <nil>
Processing package=errors:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/expvar
Processing expvar:
Matchfile(/usr/local/go-1.11.5/src/expvar/expvar.go) => true <nil>
Ignoring test code in expvar_test.go
Processing package=expvar:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/flag
Processing flag:
Matchfile(/usr/local/go-1.11.5/src/flag/flag.go) => true <nil>
Ignoring test code in example_value_test.go
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Ignoring test code in flag_test.go
Processing package=flag:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/fmt
Processing fmt:
Ignoring test code in scan_test.go
Matchfile(/usr/local/go-1.11.5/src/fmt/doc.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/fmt/print.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/fmt/scan.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Ignoring test code in stringer_test.go
Matchfile(/usr/local/go-1.11.5/src/fmt/format.go) => true <nil>
Ignoring test code in fmt_test.go
Processing package=fmt:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/go
Processing go:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/go/ast
Processing go/ast:
Matchfile(/usr/local/go-1.11.5/src/go/ast/print.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/ast/resolve.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/ast/scope.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in ast_test.go
Matchfile(/usr/local/go-1.11.5/src/go/ast/ast.go) => true <nil>
Ignoring test code in filter_test.go
Matchfile(/usr/local/go-1.11.5/src/go/ast/filter.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/ast/commentmap.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/ast/walk.go) => true <nil>
Ignoring test code in print_test.go
Matchfile(/usr/local/go-1.11.5/src/go/ast/import.go) => true <nil>
Ignoring test code in commentmap_test.go
Processing package=go/ast:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/go/build
Processing go/build:
Matchfile(/usr/local/go-1.11.5/src/go/build/doc.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/build/build.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/build/gc.go) => true <nil>
Ignoring test code in deps_test.go
Ignoring test code in syslist_test.go
Matchfile(/usr/local/go-1.11.5/src/go/build/syslist.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/build/zcgo.go) => true <nil>
Ignoring test code in build_test.go
Ignoring test code in read_test.go
Matchfile(/usr/local/go-1.11.5/src/go/build/gccgo.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/go/build/read.go) => true <nil>
Processing package=go/build:
Excluding /usr/local/go-1.11.5/src/go/build/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/go/constant
Processing go/constant:
Matchfile(/usr/local/go-1.11.5/src/go/constant/value.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in value_test.go
Processing package=go/constant:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/go/doc
Processing go/doc:
Matchfile(/usr/local/go-1.11.5/src/go/doc/doc.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/doc/reader.go) => true <nil>
Ignoring test code in comment_test.go
Matchfile(/usr/local/go-1.11.5/src/go/doc/example.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in doc_test.go
Matchfile(/usr/local/go-1.11.5/src/go/doc/exports.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/doc/headscan.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/go/doc/filter.go) => true <nil>
Ignoring test code in synopsis_test.go
Matchfile(/usr/local/go-1.11.5/src/go/doc/comment.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/doc/synopsis.go) => true <nil>
Processing package=go/doc:
Excluding /usr/local/go-1.11.5/src/go/doc/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/go/format
Processing go/format:
Ignoring test code in format_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/go/format/internal.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/format/format.go) => true <nil>
Processing package=go/format:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/go/importer
Processing go/importer:
Matchfile(/usr/local/go-1.11.5/src/go/importer/importer.go) => true <nil>
Ignoring test code in importer_test.go
Processing package=go/importer:
Excluding /usr/local/go-1.11.5/src/go/internal
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/go/parser
Processing go/parser:
Ignoring test code in parser_test.go
Matchfile(/usr/local/go-1.11.5/src/go/parser/parser.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in performance_test.go
Ignoring test code in short_test.go
Matchfile(/usr/local/go-1.11.5/src/go/parser/interface.go) => true <nil>
Ignoring test code in error_test.go
Processing package=go/parser:
Excluding /usr/local/go-1.11.5/src/go/parser/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/go/printer
Processing go/printer:
Ignoring test code in example_test.go
Ignoring test code in performance_test.go
Ignoring test code in printer_test.go
Matchfile(/usr/local/go-1.11.5/src/go/printer/printer.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/printer/nodes.go) => true <nil>
Processing package=go/printer:
Excluding /usr/local/go-1.11.5/src/go/printer/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/go/scanner
Processing go/scanner:
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/go/scanner/scanner.go) => true <nil>
Ignoring test code in scanner_test.go
Matchfile(/usr/local/go-1.11.5/src/go/scanner/errors.go) => true <nil>
Processing package=go/scanner:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/go/token
Processing go/token:
Ignoring test code in position_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/go/token/serialize.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/token/position.go) => true <nil>
Ignoring test code in serialize_test.go
Matchfile(/usr/local/go-1.11.5/src/go/token/token.go) => true <nil>
Processing package=go/token:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/go/types
Processing go/types:
Ignoring test code in check_test.go
Matchfile(/usr/local/go-1.11.5/src/go/types/call.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/types/interfaces.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/types/sizes.go) => true <nil>
Ignoring test code in object_test.go
Matchfile(/usr/local/go-1.11.5/src/go/types/builtins.go) => true <nil>
Ignoring test code in token_test.go
Matchfile(/usr/local/go-1.11.5/src/go/types/scope.go) => true <nil>
Ignoring test code in issues_test.go
Ignoring test code in api_test.go
Ignoring test code in typestring_test.go
Matchfile(/usr/local/go-1.11.5/src/go/types/type.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/go/types/expr.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/types/predicates.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/types/typestring.go) => true <nil>
Ignoring test code in sizes_test.go
Matchfile(/usr/local/go-1.11.5/src/go/types/object.go) => true <nil>
Ignoring test code in builtins_test.go
Ignoring test code in self_test.go
Matchfile(/usr/local/go-1.11.5/src/go/types/initorder.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/types/objset.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/types/universe.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/types/package.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/types/operand.go) => true <nil>
Ignoring test code in exprstring_test.go
Matchfile(/usr/local/go-1.11.5/src/go/types/return.go) => true <nil>
Ignoring test code in eval_test.go
Matchfile(/usr/local/go-1.11.5/src/go/types/stmt.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/types/decl.go) => true <nil>
Ignoring test code in stdlib_test.go
Matchfile(/usr/local/go-1.11.5/src/go/types/methodset.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/types/api.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/types/check.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/types/typexpr.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/types/resolver.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/types/selection.go) => true <nil>
Ignoring test code in resolver_test.go
Matchfile(/usr/local/go-1.11.5/src/go/types/exprstring.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/types/labels.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/types/gotype.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/go/types/errors.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/types/assignments.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/types/eval.go) => true <nil>
Ignoring test code in hilbert_test.go
Matchfile(/usr/local/go-1.11.5/src/go/types/conversions.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/go/types/lookup.go) => true <nil>
Processing package=go/types:
Excluding /usr/local/go-1.11.5/src/go/types/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/hash
Processing hash:
Ignoring test code in marshal_test.go
Matchfile(/usr/local/go-1.11.5/src/hash/hash.go) => true <nil>
Ignoring test code in example_test.go
Processing package=hash:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/hash/adler32
Processing hash/adler32:
Ignoring test code in adler32_test.go
Matchfile(/usr/local/go-1.11.5/src/hash/adler32/adler32.go) => true <nil>
Processing package=hash/adler32:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/hash/crc32
Processing hash/crc32:
Matchfile(/usr/local/go-1.11.5/src/hash/crc32/crc32_arm64.go) => false <nil>
Ignoring test code in crc32_test.go
Matchfile(/usr/local/go-1.11.5/src/hash/crc32/crc32.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/hash/crc32/gen_const_ppc64le.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/hash/crc32/crc32_ppc64le.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/hash/crc32/crc32_generic.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/hash/crc32/crc32_amd64.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/hash/crc32/crc32_s390x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/hash/crc32/crc32_amd64p32.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/hash/crc32/crc32_otherarch.go) => false <nil>
Processing package=hash/crc32:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/hash/crc64
Processing hash/crc64:
Ignoring test code in crc64_test.go
Matchfile(/usr/local/go-1.11.5/src/hash/crc64/crc64.go) => true <nil>
Processing package=hash/crc64:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/hash/fnv
Processing hash/fnv:
Matchfile(/usr/local/go-1.11.5/src/hash/fnv/fnv.go) => true <nil>
Ignoring test code in fnv_test.go
Processing package=hash/fnv:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/html
Processing html:
Ignoring test code in escape_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/html/entity.go) => true <nil>
Ignoring test code in entity_test.go
Matchfile(/usr/local/go-1.11.5/src/html/escape.go) => true <nil>
Processing package=html:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/html/template
Processing html/template:
Ignoring test code in transition_test.go
Matchfile(/usr/local/go-1.11.5/src/html/template/doc.go) => true <nil>
Ignoring test code in css_test.go
Ignoring test code in html_test.go
Matchfile(/usr/local/go-1.11.5/src/html/template/element_string.go) => true <nil>
Ignoring test code in template_test.go
Matchfile(/usr/local/go-1.11.5/src/html/template/transition.go) => true <nil>
Ignoring test code in url_test.go
Matchfile(/usr/local/go-1.11.5/src/html/template/delim_string.go) => true <nil>
Ignoring test code in escape_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/html/template/context.go) => true <nil>
Ignoring test code in examplefiles_test.go
Matchfile(/usr/local/go-1.11.5/src/html/template/css.go) => true <nil>
Ignoring test code in content_test.go
Ignoring test code in js_test.go
Matchfile(/usr/local/go-1.11.5/src/html/template/attr_string.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/html/template/error.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/html/template/html.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/html/template/content.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/html/template/escape.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/html/template/attr.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/html/template/url.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/html/template/template.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/html/template/jsctx_string.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/html/template/state_string.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/html/template/js.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/html/template/urlpart_string.go) => true <nil>
Ignoring test code in clone_test.go
Processing package=html/template:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/image
Processing image:
Ignoring test code in ycbcr_test.go
Matchfile(/usr/local/go-1.11.5/src/image/names.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/image/geom.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/image/ycbcr.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/image/format.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/image/image.go) => true <nil>
Ignoring test code in decode_example_test.go
Ignoring test code in image_test.go
Ignoring test code in decode_test.go
Ignoring test code in geom_test.go
Processing package=image:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/image/color
Processing image/color:
Ignoring test code in ycbcr_test.go
Matchfile(/usr/local/go-1.11.5/src/image/color/ycbcr.go) => true <nil>
Ignoring test code in color_test.go
Matchfile(/usr/local/go-1.11.5/src/image/color/color.go) => true <nil>
Processing package=image/color:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/image/color/palette
Processing image/color/palette:
Matchfile(/usr/local/go-1.11.5/src/image/color/palette/generate.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/image/color/palette/palette.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/image/color/palette/gen.go) => false <nil>
Processing package=image/color/palette:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/image/draw
Processing image/draw:
Ignoring test code in draw_test.go
Ignoring test code in example_test.go
Ignoring test code in bench_test.go
Matchfile(/usr/local/go-1.11.5/src/image/draw/draw.go) => true <nil>
Ignoring test code in clip_test.go
Processing package=image/draw:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/image/gif
Processing image/gif:
Matchfile(/usr/local/go-1.11.5/src/image/gif/reader.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/image/gif/writer.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in writer_test.go
Processing package=image/gif:
Excluding /usr/local/go-1.11.5/src/image/internal
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/image/jpeg
Processing image/jpeg:
Matchfile(/usr/local/go-1.11.5/src/image/jpeg/scan.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/image/jpeg/reader.go) => true <nil>
Ignoring test code in dct_test.go
Matchfile(/usr/local/go-1.11.5/src/image/jpeg/writer.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(/usr/local/go-1.11.5/src/image/jpeg/idct.go) => true <nil>
Ignoring test code in writer_test.go
Matchfile(/usr/local/go-1.11.5/src/image/jpeg/fdct.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/image/jpeg/huffman.go) => true <nil>
Processing package=image/jpeg:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/image/png
Processing image/png:
Matchfile(/usr/local/go-1.11.5/src/image/png/reader.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/image/png/writer.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in writer_test.go
Ignoring test code in paeth_test.go
Matchfile(/usr/local/go-1.11.5/src/image/png/paeth.go) => true <nil>
Processing package=image/png:
Excluding /usr/local/go-1.11.5/src/image/png/testdata
Excluding /usr/local/go-1.11.5/src/image/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/index
Processing index:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/index/suffixarray
Processing index/suffixarray:
Ignoring test code in suffixarray_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/index/suffixarray/qsufsort.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/index/suffixarray/suffixarray.go) => true <nil>
Processing package=index/suffixarray:
Excluding /usr/local/go-1.11.5/src/internal
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/io
Processing io:
Ignoring test code in io_test.go
Ignoring test code in example_test.go
Ignoring test code in pipe_test.go
Matchfile(/usr/local/go-1.11.5/src/io/io.go) => true <nil>
Ignoring test code in multi_test.go
Matchfile(/usr/local/go-1.11.5/src/io/multi.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/io/pipe.go) => true <nil>
Processing package=io:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/io/ioutil
Processing io/ioutil:
Matchfile(/usr/local/go-1.11.5/src/io/ioutil/tempfile.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in tempfile_test.go
Ignoring test code in ioutil_test.go
Matchfile(/usr/local/go-1.11.5/src/io/ioutil/ioutil.go) => true <nil>
Processing package=io/ioutil:
Excluding /usr/local/go-1.11.5/src/io/ioutil/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/log
Processing log:
Ignoring test code in log_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/log/log.go) => true <nil>
Processing package=log:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/log/syslog
Processing log/syslog:
Matchfile(/usr/local/go-1.11.5/src/log/syslog/doc.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/log/syslog/syslog_unix.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/log/syslog/syslog.go) => true <nil>
Ignoring test code in syslog_test.go
Processing package=log/syslog:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/math
Processing math:
Matchfile(/usr/local/go-1.11.5/src/math/tan.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/lgamma.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/j1.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/jn.go) => true <nil>
Ignoring test code in export_s390x_test.go
Matchfile(/usr/local/go-1.11.5/src/math/mod.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/erfinv.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/abs.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/logb.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/acosh.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/atanh.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Matchfile(/usr/local/go-1.11.5/src/math/asin.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/modf.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/pow10.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/dim.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/copysign.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/remainder.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/nextafter.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/asinh.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/tanh.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/cbrt.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/sinh.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/log.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/sincos.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/exp.go) => true <nil>
Ignoring test code in all_test.go
Matchfile(/usr/local/go-1.11.5/src/math/exp_asm.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/hypot.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/log1p.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/bits.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/arith_s390x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/math/sqrt.go) => true <nil>
Ignoring test code in arith_s390x_test.go
Matchfile(/usr/local/go-1.11.5/src/math/signbit.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/sin.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/log10.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/erf.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/atan.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/expm1.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/pow.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/frexp.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/j0.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/sincos_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/math/const.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/ldexp.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/floor.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/unsafe.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/atan2.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/gamma.go) => true <nil>
Processing package=math:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/math/big
Processing math/big:
Matchfile(/usr/local/go-1.11.5/src/math/big/doc.go) => true <nil>
Ignoring test code in decimal_test.go
Matchfile(/usr/local/go-1.11.5/src/math/big/intmarsh.go) => true <nil>
Ignoring test code in floatmarsh_test.go
Matchfile(/usr/local/go-1.11.5/src/math/big/int.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/big/arith.go) => true <nil>
Ignoring test code in natconv_test.go
Ignoring test code in bits_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/math/big/ratmarsh.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/big/ftoa.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/big/decimal.go) => true <nil>
Ignoring test code in intconv_test.go
Ignoring test code in float_test.go
Matchfile(/usr/local/go-1.11.5/src/math/big/accuracy_string.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/big/prime.go) => true <nil>
Ignoring test code in prime_test.go
Ignoring test code in floatexample_test.go
Ignoring test code in rat_test.go
Ignoring test code in gcd_test.go
Ignoring test code in ratconv_test.go
Ignoring test code in arith_test.go
Matchfile(/usr/local/go-1.11.5/src/math/big/natconv.go) => true <nil>
Ignoring test code in calibrate_test.go
Matchfile(/usr/local/go-1.11.5/src/math/big/rat.go) => true <nil>
Ignoring test code in sqrt_test.go
Ignoring test code in nat_test.go
Matchfile(/usr/local/go-1.11.5/src/math/big/floatconv.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/big/floatmarsh.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/big/sqrt.go) => true <nil>
Ignoring test code in int_test.go
Ignoring test code in arith_s390x_test.go
Matchfile(/usr/local/go-1.11.5/src/math/big/ratconv.go) => true <nil>
Ignoring test code in ratmarsh_test.go
Matchfile(/usr/local/go-1.11.5/src/math/big/nat.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/big/float.go) => true <nil>
Ignoring test code in example_rat_test.go
Matchfile(/usr/local/go-1.11.5/src/math/big/arith_decl.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/big/arith_decl_pure.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/math/big/arith_amd64.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/big/arith_decl_s390x.go) => false <nil>
Ignoring test code in intmarsh_test.go
Ignoring test code in floatconv_test.go
Matchfile(/usr/local/go-1.11.5/src/math/big/roundingmode_string.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/big/intconv.go) => true <nil>
Ignoring test code in hilbert_test.go
Processing package=math/big:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/math/bits
Processing math/bits:
Ignoring test code in bits_test.go
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Matchfile(/usr/local/go-1.11.5/src/math/bits/bits.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/bits/bits_tables.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/bits/make_tables.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/math/bits/make_examples.go) => false <nil>
Processing package=math/bits:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/math/cmplx
Processing math/cmplx:
Matchfile(/usr/local/go-1.11.5/src/math/cmplx/tan.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/cmplx/abs.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/math/cmplx/asin.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/cmplx/isnan.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/cmplx/log.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/cmplx/exp.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/cmplx/sqrt.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/cmplx/isinf.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/cmplx/rect.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/cmplx/sin.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/cmplx/phase.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/cmplx/pow.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/cmplx/polar.go) => true <nil>
Ignoring test code in cmath_test.go
Matchfile(/usr/local/go-1.11.5/src/math/cmplx/conj.go) => true <nil>
Processing package=math/cmplx:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/math/rand
Processing math/rand:
Matchfile(/usr/local/go-1.11.5/src/math/rand/rng.go) => true <nil>
Ignoring test code in rand_test.go
Ignoring test code in regress_test.go
Matchfile(/usr/local/go-1.11.5/src/math/rand/gen_cooked.go) => false <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/math/rand/zipf.go) => true <nil>
Ignoring test code in race_test.go
Matchfile(/usr/local/go-1.11.5/src/math/rand/exp.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/rand/normal.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/math/rand/rand.go) => true <nil>
Processing package=math/rand:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/mime
Processing mime:
Matchfile(/usr/local/go-1.11.5/src/mime/encodedword.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/mime/grammar.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/mime/type.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/mime/type_openbsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/mime/type_windows.go) => false <nil>
Ignoring test code in type_test.go
Ignoring test code in mediatype_test.go
Matchfile(/usr/local/go-1.11.5/src/mime/type_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/mime/mediatype.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/mime/type_dragonfly.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/mime/type_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/mime/type_freebsd.go) => false <nil>
Ignoring test code in encodedword_test.go
Processing package=mime:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/mime/multipart
Processing mime/multipart:
Ignoring test code in multipart_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/mime/multipart/writer.go) => true <nil>
Ignoring test code in writer_test.go
Matchfile(/usr/local/go-1.11.5/src/mime/multipart/formdata.go) => true <nil>
Ignoring test code in formdata_test.go
Matchfile(/usr/local/go-1.11.5/src/mime/multipart/multipart.go) => true <nil>
Processing package=mime/multipart:
Excluding /usr/local/go-1.11.5/src/mime/multipart/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/mime/quotedprintable
Processing mime/quotedprintable:
Matchfile(/usr/local/go-1.11.5/src/mime/quotedprintable/reader.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/mime/quotedprintable/writer.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in writer_test.go
Processing package=mime/quotedprintable:
Excluding /usr/local/go-1.11.5/src/mime/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/net
Processing net:
Ignoring test code in dnsclient_test.go
Matchfile(/usr/local/go-1.11.5/src/net/sock_bsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/cgo_sockold.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/hook_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/file_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/ipsock.go) => true <nil>
Ignoring test code in net_test.go
Matchfile(/usr/local/go-1.11.5/src/net/ip.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/cgo_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/dnsclient.go) => true <nil>
Ignoring test code in parse_test.go
Ignoring test code in external_test.go
Matchfile(/usr/local/go-1.11.5/src/net/port_unix.go) => true <nil>
Ignoring test code in main_unix_test.go
Ignoring test code in udpsock_plan9_test.go
Matchfile(/usr/local/go-1.11.5/src/net/sockoptip_posix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/tcpsockopt_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/lookup_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/sockopt_bsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/conf_netcgo.go) => false <nil>
Ignoring test code in mac_test.go
Matchfile(/usr/local/go-1.11.5/src/net/sockopt_linux.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/parse.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/file_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/sock_stub.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/file_stub.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/cgo_resnew.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/lookup_fake.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/dial.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/hosts.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/addrselect.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/interface_linux.go) => true <nil>
Ignoring test code in file_test.go
Ignoring test code in udpsock_test.go
Ignoring test code in net_windows_test.go
Ignoring test code in example_test.go
Ignoring test code in error_posix_test.go
Ignoring test code in nss_test.go
Ignoring test code in timeout_test.go
Matchfile(/usr/local/go-1.11.5/src/net/net_fake.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/udpsock_posix.go) => true <nil>
Ignoring test code in mockserver_test.go
Matchfile(/usr/local/go-1.11.5/src/net/file.go) => true <nil>
Ignoring test code in main_plan9_test.go
Matchfile(/usr/local/go-1.11.5/src/net/iprawsock_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/cgo_windows.go) => false <nil>
Ignoring test code in interface_bsd_test.go
Ignoring test code in hosts_test.go
Matchfile(/usr/local/go-1.11.5/src/net/interface_stub.go) => false <nil>
Ignoring test code in ipsock_test.go
Matchfile(/usr/local/go-1.11.5/src/net/sys_cloexec.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/fd_unix.go) => true <nil>
Ignoring test code in rawconn_test.go
Matchfile(/usr/local/go-1.11.5/src/net/sendfile_stub.go) => false <nil>
Ignoring test code in rawconn_windows_test.go
Matchfile(/usr/local/go-1.11.5/src/net/tcpsockopt_solaris.go) => false <nil>
Ignoring test code in lookup_windows_test.go
Matchfile(/usr/local/go-1.11.5/src/net/net.go) => true <nil>
Ignoring test code in port_test.go
Matchfile(/usr/local/go-1.11.5/src/net/sockoptip_stub.go) => false <nil>
Ignoring test code in server_test.go
Matchfile(/usr/local/go-1.11.5/src/net/interface_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/sockoptip_bsdvar.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/cgo_linux.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/fd_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/interface_solaris.go) => false <nil>
Ignoring test code in main_noconf_test.go
Matchfile(/usr/local/go-1.11.5/src/net/tcpsockopt_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/iprawsock_posix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/cgo_android.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/sock_cloexec.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/sock_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/file_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/sendfile_linux.go) => true <nil>
Ignoring test code in dnsconfig_unix_test.go
Ignoring test code in writev_test.go
Matchfile(/usr/local/go-1.11.5/src/net/tcpsock.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/error_plan9.go) => false <nil>
Ignoring test code in error_plan9_test.go
Ignoring test code in tcpsock_test.go
Ignoring test code in interface_test.go
Ignoring test code in error_unix_test.go
Matchfile(/usr/local/go-1.11.5/src/net/interface.go) => true <nil>
Ignoring test code in cgo_unix_test.go
Ignoring test code in dial_test.go
Ignoring test code in conf_test.go
Matchfile(/usr/local/go-1.11.5/src/net/cgo_bsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/splice_stub.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/tcpsockopt_stub.go) => false <nil>
Ignoring test code in error_windows_test.go
Matchfile(/usr/local/go-1.11.5/src/net/hook_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/sockoptip_linux.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/sendfile_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/cgo_socknew.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/error_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/unixsock_posix.go) => true <nil>
Ignoring test code in netgo_unix_test.go
Ignoring test code in pipe_test.go
Matchfile(/usr/local/go-1.11.5/src/net/sock_posix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/sockaddr_posix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/sock_linux.go) => true <nil>
Ignoring test code in tcpsock_unix_test.go
Ignoring test code in dnsclient_unix_test.go
Matchfile(/usr/local/go-1.11.5/src/net/error_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/writev_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/dnsclient_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/cgo_resold.go) => false <nil>
Ignoring test code in packetconn_test.go
Matchfile(/usr/local/go-1.11.5/src/net/sockopt_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/udpsock.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/hook_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/dnsconfig_unix.go) => true <nil>
Ignoring test code in ip_test.go
Matchfile(/usr/local/go-1.11.5/src/net/fd_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/interface_windows.go) => false <nil>
Ignoring test code in listen_test.go
Matchfile(/usr/local/go-1.11.5/src/net/sendfile_unix_alt.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/sockopt_solaris.go) => false <nil>
Ignoring test code in unixsock_test.go
Ignoring test code in main_conf_test.go
Matchfile(/usr/local/go-1.11.5/src/net/cgo_solaris.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/error_posix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/tcpsockopt_posix.go) => true <nil>
Ignoring test code in rawconn_stub_test.go
Matchfile(/usr/local/go-1.11.5/src/net/sockoptip_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/tcpsockopt_dragonfly.go) => false <nil>
Ignoring test code in rawconn_unix_test.go
Matchfile(/usr/local/go-1.11.5/src/net/cgo_openbsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/tcpsock_posix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/tcpsockopt_darwin.go) => false <nil>
Ignoring test code in main_cloexec_test.go
Matchfile(/usr/local/go-1.11.5/src/net/sockopt_posix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/sockopt_plan9.go) => false <nil>
Ignoring test code in sendfile_test.go
Ignoring test code in dial_unix_test.go
Ignoring test code in platform_test.go
Matchfile(/usr/local/go-1.11.5/src/net/ipsock_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/rawconn.go) => true <nil>
Ignoring test code in dnsname_test.go
Matchfile(/usr/local/go-1.11.5/src/net/iprawsock.go) => true <nil>
Ignoring test code in addrselect_test.go
Matchfile(/usr/local/go-1.11.5/src/net/lookup_plan9.go) => false <nil>
Ignoring test code in splice_test.go
Matchfile(/usr/local/go-1.11.5/src/net/interface_freebsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/error_nacl.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/ipsock_posix.go) => true <nil>
Ignoring test code in interface_unix_test.go
Matchfile(/usr/local/go-1.11.5/src/net/splice_linux.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/conf.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/cgo_netbsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/tcpsock_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/udpsock_plan9.go) => false <nil>
Ignoring test code in conn_test.go
Matchfile(/usr/local/go-1.11.5/src/net/hook.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/interface_darwin.go) => false <nil>
Ignoring test code in main_test.go
Matchfile(/usr/local/go-1.11.5/src/net/cgo_stub.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/sockopt_stub.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/mac.go) => true <nil>
Ignoring test code in iprawsock_test.go
Matchfile(/usr/local/go-1.11.5/src/net/nss.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/tcpsockopt_openbsd.go) => false <nil>
Ignoring test code in main_posix_test.go
Matchfile(/usr/local/go-1.11.5/src/net/interface_bsdvar.go) => false <nil>
Ignoring test code in interface_linux_test.go
Matchfile(/usr/local/go-1.11.5/src/net/interface_bsd.go) => false <nil>
Ignoring test code in unixsock_linux_test.go
Matchfile(/usr/local/go-1.11.5/src/net/unixsock_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/unixsock.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/port.go) => true <nil>
Ignoring test code in lookup_test.go
Ignoring test code in main_windows_test.go
Matchfile(/usr/local/go-1.11.5/src/net/pipe.go) => true <nil>
Ignoring test code in protoconn_test.go
Matchfile(/usr/local/go-1.11.5/src/net/tcpsockopt_windows.go) => false <nil>
Ignoring test code in error_test.go
Matchfile(/usr/local/go-1.11.5/src/net/sock_windows.go) => false <nil>
Ignoring test code in write_unix_test.go
Matchfile(/usr/local/go-1.11.5/src/net/lookup_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/lookup.go) => true <nil>
Processing package=net:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/net/http
Processing net/http:
Matchfile(/usr/local/go-1.11.5/src/net/http/header.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/http/doc.go) => true <nil>
Ignoring test code in requestwrite_test.go
Matchfile(/usr/local/go-1.11.5/src/net/http/fs.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/http/http.go) => true <nil>
Ignoring test code in response_test.go
Ignoring test code in fs_test.go
Ignoring test code in range_test.go
Ignoring test code in responsewrite_test.go
Matchfile(/usr/local/go-1.11.5/src/net/http/cookie.go) => true <nil>
Ignoring test code in clientserver_test.go
Matchfile(/usr/local/go-1.11.5/src/net/http/server.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/http/request.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Ignoring test code in request_test.go
Ignoring test code in npn_test.go
Matchfile(/usr/local/go-1.11.5/src/net/http/filetransport.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/http/roundtrip_js.go) => false <nil>
Ignoring test code in transport_internal_test.go
Ignoring test code in serve_test.go
Matchfile(/usr/local/go-1.11.5/src/net/http/method.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/http/response.go) => true <nil>
Ignoring test code in client_test.go
Matchfile(/usr/local/go-1.11.5/src/net/http/triv.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/http/transfer.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/http/roundtrip.go) => true <nil>
Ignoring test code in header_test.go
Ignoring test code in transfer_test.go
Matchfile(/usr/local/go-1.11.5/src/net/http/socks_bundle.go) => true <nil>
Ignoring test code in readrequest_test.go
Matchfile(/usr/local/go-1.11.5/src/net/http/h2_bundle.go) => true <nil>
Ignoring test code in cookie_test.go
Ignoring test code in transport_test.go
Ignoring test code in filetransport_test.go
Ignoring test code in http_test.go
Ignoring test code in main_test.go
Matchfile(/usr/local/go-1.11.5/src/net/http/race.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/net/http/client.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/http/status.go) => true <nil>
Ignoring test code in sniff_test.go
Matchfile(/usr/local/go-1.11.5/src/net/http/jar.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/http/sniff.go) => true <nil>
Ignoring test code in proxy_test.go
Matchfile(/usr/local/go-1.11.5/src/net/http/transport.go) => true <nil>
Processing package=net/http:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/net/http/cgi
Processing net/http/cgi:
Ignoring test code in child_test.go
Ignoring test code in posix_test.go
Matchfile(/usr/local/go-1.11.5/src/net/http/cgi/child.go) => true <nil>
Ignoring test code in matryoshka_test.go
Ignoring test code in host_test.go
Matchfile(/usr/local/go-1.11.5/src/net/http/cgi/host.go) => true <nil>
Ignoring test code in plan9_test.go
Processing package=net/http/cgi:
Excluding /usr/local/go-1.11.5/src/net/http/cgi/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/net/http/cookiejar
Processing net/http/cookiejar:
Ignoring test code in example_test.go
Ignoring test code in dummy_publicsuffix_test.go
Matchfile(/usr/local/go-1.11.5/src/net/http/cookiejar/punycode.go) => true <nil>
Ignoring test code in punycode_test.go
Ignoring test code in jar_test.go
Matchfile(/usr/local/go-1.11.5/src/net/http/cookiejar/jar.go) => true <nil>
Processing package=net/http/cookiejar:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/net/http/fcgi
Processing net/http/fcgi:
Ignoring test code in fcgi_test.go
Matchfile(/usr/local/go-1.11.5/src/net/http/fcgi/child.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/http/fcgi/fcgi.go) => true <nil>
Processing package=net/http/fcgi:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/net/http/httptest
Processing net/http/httptest:
Matchfile(/usr/local/go-1.11.5/src/net/http/httptest/server.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in server_test.go
Ignoring test code in httptest_test.go
Matchfile(/usr/local/go-1.11.5/src/net/http/httptest/httptest.go) => true <nil>
Ignoring test code in recorder_test.go
Matchfile(/usr/local/go-1.11.5/src/net/http/httptest/recorder.go) => true <nil>
Processing package=net/http/httptest:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/net/http/httptrace
Processing net/http/httptrace:
Matchfile(/usr/local/go-1.11.5/src/net/http/httptrace/trace.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in trace_test.go
Processing package=net/http/httptrace:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/net/http/httputil
Processing net/http/httputil:
Matchfile(/usr/local/go-1.11.5/src/net/http/httputil/persist.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/http/httputil/reverseproxy.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in dump_test.go
Ignoring test code in reverseproxy_test.go
Matchfile(/usr/local/go-1.11.5/src/net/http/httputil/dump.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/http/httputil/httputil.go) => true <nil>
Processing package=net/http/httputil:
Excluding /usr/local/go-1.11.5/src/net/http/internal
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/net/http/pprof
Processing net/http/pprof:
Matchfile(/usr/local/go-1.11.5/src/net/http/pprof/pprof.go) => true <nil>
Ignoring test code in pprof_test.go
Processing package=net/http/pprof:
Excluding /usr/local/go-1.11.5/src/net/http/testdata
Excluding /usr/local/go-1.11.5/src/net/internal
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/net/mail
Processing net/mail:
Matchfile(/usr/local/go-1.11.5/src/net/mail/message.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in message_test.go
Processing package=net/mail:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/net/rpc
Processing net/rpc:
Matchfile(/usr/local/go-1.11.5/src/net/rpc/server.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/rpc/debug.go) => true <nil>
Ignoring test code in server_test.go
Ignoring test code in client_test.go
Matchfile(/usr/local/go-1.11.5/src/net/rpc/client.go) => true <nil>
Processing package=net/rpc:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/net/rpc/jsonrpc
Processing net/rpc/jsonrpc:
Matchfile(/usr/local/go-1.11.5/src/net/rpc/jsonrpc/server.go) => true <nil>
Ignoring test code in all_test.go
Matchfile(/usr/local/go-1.11.5/src/net/rpc/jsonrpc/client.go) => true <nil>
Processing package=net/rpc/jsonrpc:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/net/smtp
Processing net/smtp:
Ignoring test code in example_test.go
Ignoring test code in smtp_test.go
Matchfile(/usr/local/go-1.11.5/src/net/smtp/auth.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/smtp/smtp.go) => true <nil>
Processing package=net/smtp:
Excluding /usr/local/go-1.11.5/src/net/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/net/textproto
Processing net/textproto:
Matchfile(/usr/local/go-1.11.5/src/net/textproto/header.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/textproto/textproto.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/textproto/reader.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/textproto/pipeline.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/net/textproto/writer.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in writer_test.go
Processing package=net/textproto:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/net/url
Processing net/url:
Ignoring test code in url_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/net/url/url.go) => true <nil>
Processing package=net/url:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/os
Processing os:
Matchfile(/usr/local/go-1.11.5/src/os/dir_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/file_windows.go) => false <nil>
Ignoring test code in path_test.go
Matchfile(/usr/local/go-1.11.5/src/os/wait_unimp.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/stat_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/types_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/env.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/file_posix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/path_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/sys_linux.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/file_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/proc.go) => true <nil>
Ignoring test code in env_test.go
Matchfile(/usr/local/go-1.11.5/src/os/sys_plan9.go) => false <nil>
Ignoring test code in export_windows_test.go
Matchfile(/usr/local/go-1.11.5/src/os/executable_freebsd.go) => false <nil>
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Ignoring test code in timeout_test.go
Matchfile(/usr/local/go-1.11.5/src/os/file.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/dir_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/stat_netbsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/stat_nacljs.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/str.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/getwd.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/pipe2_bsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/sticky_notbsd.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/executable.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/exec_unix.go) => true <nil>
Ignoring test code in path_windows_test.go
Matchfile(/usr/local/go-1.11.5/src/os/stat_solaris.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/sys_unix.go) => true <nil>
Ignoring test code in os_test.go
Ignoring test code in fifo_test.go
Matchfile(/usr/local/go-1.11.5/src/os/wait_waitid.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/file_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/stat_dragonfly.go) => false <nil>
Ignoring test code in executable_test.go
Matchfile(/usr/local/go-1.11.5/src/os/error_plan9.go) => false <nil>
Ignoring test code in error_unix_test.go
Ignoring test code in error_windows_test.go
Matchfile(/usr/local/go-1.11.5/src/os/stat_linux.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/error.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/executable_procfs.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/exec.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/path_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/error_windows.go) => false <nil>
Ignoring test code in pipe_test.go
Matchfile(/usr/local/go-1.11.5/src/os/stat_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/dir.go) => true <nil>
Ignoring test code in env_unix_test.go
Matchfile(/usr/local/go-1.11.5/src/os/stat_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/getwd_darwin.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/types_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/stat_darwin.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/types.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/error_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/types_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/executable_path.go) => false <nil>
Ignoring test code in os_windows_test.go
Matchfile(/usr/local/go-1.11.5/src/os/sys_js.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/executable_solaris.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/exec_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/stat.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/sticky_bsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/error_posix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/wait_wait6.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/pipe_linux.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/exec_posix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/stat_freebsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/executable_windows.go) => false <nil>
Ignoring test code in os_unix_test.go
Matchfile(/usr/local/go-1.11.5/src/os/sys_solaris.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/sys_bsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/executable_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/sys.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/path.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/exec_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/executable_darwin.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/stat_openbsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/sys_nacl.go) => false <nil>
Ignoring test code in error_test.go
Matchfile(/usr/local/go-1.11.5/src/os/dir_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/sys_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/pipe_bsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/path_windows.go) => false <nil>
Processing package=os:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/os/exec
Processing os/exec:
Ignoring test code in exec_test.go
Ignoring test code in lp_unix_test.go
Ignoring test code in env_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/os/exec/lp_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/exec/lp_js.go) => false <nil>
Ignoring test code in internal_test.go
Matchfile(/usr/local/go-1.11.5/src/os/exec/exec_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/exec/lp_windows.go) => false <nil>
Ignoring test code in lp_windows_test.go
Matchfile(/usr/local/go-1.11.5/src/os/exec/lp_unix.go) => true <nil>
Ignoring test code in exec_posix_test.go
Matchfile(/usr/local/go-1.11.5/src/os/exec/exec.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/exec/exec_windows.go) => false <nil>
Ignoring test code in lp_test.go
Processing package=os/exec:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/os/signal
Processing os/signal:
Matchfile(/usr/local/go-1.11.5/src/os/signal/doc.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in signal_windows_test.go
Matchfile(/usr/local/go-1.11.5/src/os/signal/signal_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/signal/signal.go) => true <nil>
Ignoring test code in signal_cgo_test.go
Ignoring test code in signal_plan9_test.go
Ignoring test code in signal_test.go
Matchfile(/usr/local/go-1.11.5/src/os/signal/signal_plan9.go) => false <nil>
Processing package=os/signal:
Excluding /usr/local/go-1.11.5/src/os/signal/internal
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/os/user
Processing os/user:
Matchfile(/usr/local/go-1.11.5/src/os/user/listgroups_solaris.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/user/listgroups_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/user/lookup_unix.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/user/getgrouplist_darwin.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/user/user.go) => true <nil>
Ignoring test code in user_test.go
Ignoring test code in cgo_unix_test.go
Matchfile(/usr/local/go-1.11.5/src/os/user/lookup_android.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/user/lookup_stubs.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/user/cgo_lookup_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/user/lookup_plan9.go) => false <nil>
Ignoring test code in lookup_unix_test.go
Matchfile(/usr/local/go-1.11.5/src/os/user/lookup_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/os/user/getgrouplist_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/os/user/lookup.go) => true <nil>
Processing package=os/user:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/path
Processing path:
Ignoring test code in path_test.go
Matchfile(/usr/local/go-1.11.5/src/path/match.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in match_test.go
Matchfile(/usr/local/go-1.11.5/src/path/path.go) => true <nil>
Processing package=path:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/path/filepath
Processing path/filepath:
Ignoring test code in path_test.go
Matchfile(/usr/local/go-1.11.5/src/path/filepath/match.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/path/filepath/path_unix.go) => true <nil>
Ignoring test code in export_windows_test.go
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Matchfile(/usr/local/go-1.11.5/src/path/filepath/symlink.go) => true <nil>
Ignoring test code in path_windows_test.go
Ignoring test code in example_unix_walk_test.go
Ignoring test code in example_unix_test.go
Matchfile(/usr/local/go-1.11.5/src/path/filepath/path_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/path/filepath/symlink_windows.go) => false <nil>
Ignoring test code in match_test.go
Matchfile(/usr/local/go-1.11.5/src/path/filepath/path.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/path/filepath/symlink_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/path/filepath/path_windows.go) => false <nil>
Processing package=path/filepath:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/plugin
Processing plugin:
Matchfile(/usr/local/go-1.11.5/src/plugin/plugin_stubs.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/plugin/plugin_dlopen.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/plugin/plugin.go) => true <nil>
Processing package=plugin:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/reflect
Processing reflect:
Ignoring test code in tostring_test.go
Matchfile(/usr/local/go-1.11.5/src/reflect/value.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/reflect/type.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Ignoring test code in all_test.go
Matchfile(/usr/local/go-1.11.5/src/reflect/deepequal.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/reflect/swapper.go) => true <nil>
Ignoring test code in set_test.go
Matchfile(/usr/local/go-1.11.5/src/reflect/makefunc.go) => true <nil>
Processing package=reflect:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/regexp
Processing regexp:
Ignoring test code in exec_test.go
Ignoring test code in exec2_test.go
Ignoring test code in example_test.go
Ignoring test code in onepass_test.go
Ignoring test code in all_test.go
Ignoring test code in find_test.go
Matchfile(/usr/local/go-1.11.5/src/regexp/backtrack.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/regexp/regexp.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/regexp/exec.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/regexp/onepass.go) => true <nil>
Processing package=regexp:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/regexp/syntax
Processing regexp/syntax:
Matchfile(/usr/local/go-1.11.5/src/regexp/syntax/doc.go) => true <nil>
Ignoring test code in parse_test.go
Ignoring test code in simplify_test.go
Matchfile(/usr/local/go-1.11.5/src/regexp/syntax/parse.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/regexp/syntax/perl_groups.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/regexp/syntax/simplify.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/regexp/syntax/op_string.go) => true <nil>
Ignoring test code in prog_test.go
Matchfile(/usr/local/go-1.11.5/src/regexp/syntax/regexp.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/regexp/syntax/compile.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/regexp/syntax/prog.go) => true <nil>
Processing package=regexp/syntax:
Excluding /usr/local/go-1.11.5/src/regexp/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/runtime
Processing runtime:
Matchfile(/usr/local/go-1.11.5/src/runtime/trace.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_nacl_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/debugcall.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/wincallback.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/unaligned1.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/vdso_freebsd_arm.go) => false <nil>
Ignoring test code in string_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/env_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_dragonfly.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mmap.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/sys_arm64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/unaligned2.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_freebsd.go) => false <nil>
Ignoring test code in numcpu_freebsd_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/utf8.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/cgo_sigaction.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/symtab.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_windows_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/stubs_x86.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_nacl.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/rdebug.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/sys_s390x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/malloc.go) => true <nil>
Ignoring test code in crash_cgo_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/msan.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/vdso_elf32.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_darwin_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/syscall_solaris.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs1_linux.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/cpuprof.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/panic.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os3_plan9.go) => false <nil>
Ignoring test code in crash_nonunix_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/os2_nacl.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/print.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/sys_ppc64x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_plan9_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/stubs32.go) => false <nil>
Ignoring test code in rand_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_linux_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/vdso_in_none.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/write_err.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/netpoll_fake.go) => false <nil>
Ignoring test code in export_unix_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/os_linux_novdso.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/proflabel.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/map.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_netbsd_arm.go) => false <nil>
Ignoring test code in syscall_windows_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_mipsx.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/slice.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/netpoll.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mgcsweep.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/stubs_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/lfstack.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mkfastlog2table.go) => false <nil>
Ignoring test code in memmove_linux_amd64_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/proc.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_darwin.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mcache.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/lfstack_32bit.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/netpoll_solaris.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/sigtab_linux_generic.go) => true <nil>
Ignoring test code in env_test.go
Ignoring test code in chan_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/string.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_darwin_arm.go) => false <nil>
Ignoring test code in export_windows_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_amd64x.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs2_linux.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_netbsd.go) => false <nil>
Ignoring test code in norace_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/fastlog2.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/vdso_freebsd_x86.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mgcsweepbuf.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/type.go) => true <nil>
Ignoring test code in runtime_linux_test.go
Ignoring test code in chanbarrier_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/mwbbuf.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Ignoring test code in runtime_mmap_test.go
Ignoring test code in closure_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/mbitmap.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_nacl_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/cgo_mmap.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os2_openbsd.go) => false <nil>
Ignoring test code in stack_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/sigqueue.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/netpoll_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/heapdump.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_netbsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/atomic_pointer.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/lock_futex.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_dragonfly_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/cgocall.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/sigaction.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_linux_mipsx.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_mips64x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mfixalloc.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_windows_amd64.go) => false <nil>
Ignoring test code in vlop_arm_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_darwin.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/debug.go) => true <nil>
Ignoring test code in crash_unix_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/auxv_none.go) => false <nil>
Ignoring test code in memmove_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/os_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/compiler.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/cgo.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs3_linux.go) => false <nil>
Ignoring test code in export_debug_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_openbsd_amd64.go) => false <nil>
Ignoring test code in slice_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mgcmark.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mkduff.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/sys_nonppc64x.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/sys_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/write_err_android.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/runtime.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_nacl_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_linux_mipsx.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/profbuf.go) => true <nil>
Ignoring test code in gc_test.go
Ignoring test code in sizeof_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_linux_mips64x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/msize.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/timestub2.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/softfloat64.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_linux_ppc64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/stubs_android.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_openbsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mprof.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/sema.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_linux_generic.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_openbsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_linux_amd64.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/cgocallback.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os2_solaris.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/stubs.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/stubs2.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_linux_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_dragonfly.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/netpoll_kqueue.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/timeasm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/netpoll_epoll.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_nacl_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/vdso_elf64.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_openbsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_nacl.go) => false <nil>
Ignoring test code in symtab_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/map_fast32.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/rwmutex.go) => true <nil>
Ignoring test code in iface_test.go
Ignoring test code in lfstack_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_linux_amd64.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/cputicks.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/vdso_linux_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_nacl_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_linux_ppc64x.go) => false <nil>
Ignoring test code in softfloat64_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/sys_wasm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/select.go) => true <nil>
Ignoring test code in proc_runtime_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/defs1_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/fastlog2table.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/error.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_arm.go) => false <nil>
Ignoring test code in runtime_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/sys_x86.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/map_faststr.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/time.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_linux_arm64.go) => false <nil>
Ignoring test code in runtime_unix_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_freebsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mstats.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/sigqueue_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/vdso_linux_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_plan9_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/vdso_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/lock_js.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_freebsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mbarrier.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_android.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mgclarge.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/msan0.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/sizeclasses.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/lfstack_64bit.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/stack.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_darwin.go) => false <nil>
Ignoring test code in export_mmap_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/alg.go) => true <nil>
Ignoring test code in norace_linux_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_linux_ppc64x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/race0.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/traceback.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_darwin_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_plan9_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/extern.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/cgocheck.go) => true <nil>
Ignoring test code in map_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_plan9.go) => false <nil>
Ignoring test code in futex_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/cpuflags_amd64.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_linux_mips64x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_linux_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_nonopenbsd.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_linux_be64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs1_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_freebsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/netpoll_stub.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_nacl_amd64p32.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mem_js.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/stubs_nonlinux.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/runtime2.go) => true <nil>
Ignoring test code in export_linux_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/stubs_linux.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/iface.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/chan.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mksizeclasses.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/complex.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mgc.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/net_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_windows.go) => false <nil>
Ignoring test code in debug_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/vdso_freebsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_freebsd_noauxv.go) => false <nil>
Ignoring test code in callers_test.go
Ignoring test code in runtime-gdb_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/os_linux_mips64x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/float.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/runtime1.go) => true <nil>
Ignoring test code in malloc_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/lock_sema.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/sys_mips64x.go) => false <nil>
Ignoring test code in rwmutex_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/sys_darwin.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_linux.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/typekind.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_darwin_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_solaris.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_ppc64x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mgcwork.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_js.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/vdso_linux.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_openbsd_arm.go) => false <nil>
Ignoring test code in proc_test.go
Ignoring test code in fastlog2_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/mem_windows.go) => false <nil>
Ignoring test code in crash_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/vdso_linux_amd64.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mcentral.go) => true <nil>
Ignoring test code in hash_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_solaris.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/plugin.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_dragonfly.go) => false <nil>
Ignoring test code in complex_test.go
Ignoring test code in vdso_linux_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/mheap.go) => true <nil>
Ignoring test code in profbuf_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/os_freebsd2.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_openbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_arm64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/syscall2_solaris.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_dragonfly_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_solaris.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/map_fast64.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mem_linux.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mem_plan9.go) => false <nil>
Ignoring test code in mfinal_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/vlrt.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/stubs3.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/env_posix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mfinal.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/race.go) => false <nil>
Ignoring test code in export_arm_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/os_linux.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/cgo_ppc64x.go) => false <nil>
Ignoring test code in export_futex_test.go
Ignoring test code in runtime-lldb_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/hash32.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_netbsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/sigtab_linux_mipsx.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/syscall_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_openbsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_linux_ppc64le.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_openbsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_darwin_amd64.go) => false <nil>
Ignoring test code in map_benchmark_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_freebsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs1_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_sighandler.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_plan9_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os2_freebsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mem_bsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_linux_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/timestub.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/hash64.go) => true <nil>
Ignoring test code in gcinfo_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/sys_mipsx.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_linux_noauxv.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs1_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_linux_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os_openbsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/mem_darwin.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/relax_stub.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_nacl_amd64p32.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_arm_linux.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os2_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/signal_openbsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/defs_linux_mipsx.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/zcallback_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/os3_solaris.go) => false <nil>
Processing package=runtime:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/runtime/cgo
Processing runtime/cgo:
Matchfile(/usr/local/go-1.11.5/src/runtime/cgo/signal_darwin_armx.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/cgo/mmap.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/cgo/freebsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/cgo/callbacks_traceback.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/cgo/openbsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/cgo/sigaction.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/cgo/cgo.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/cgo/callbacks.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/cgo/netbsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/cgo/setenv.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/cgo/iscgo.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/cgo/dragonfly.go) => false <nil>
Processing package=runtime/cgo:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/runtime/debug
Processing runtime/debug:
Ignoring test code in garbage_test.go
Ignoring test code in stack_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/debug/stubs.go) => true <nil>
Ignoring test code in heapdump_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/debug/stack.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/debug/garbage.go) => true <nil>
Processing package=runtime/debug:
Excluding /usr/local/go-1.11.5/src/runtime/internal
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/runtime/msan
Processing runtime/msan:
Matchfile(/usr/local/go-1.11.5/src/runtime/msan/msan.go) => false <nil>
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/runtime/pprof
Processing runtime/pprof:
Matchfile(/usr/local/go-1.11.5/src/runtime/pprof/map.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/pprof/pprof.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/pprof/label.go) => true <nil>
Ignoring test code in mprof_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/pprof/protomem.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/pprof/runtime.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/runtime/pprof/protobuf.go) => true <nil>
Ignoring test code in runtime_test.go
Ignoring test code in pprof_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/pprof/proto.go) => true <nil>
Ignoring test code in proto_test.go
Ignoring test code in protomem_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/pprof/elf.go) => true <nil>
Ignoring test code in label_test.go
Processing package=runtime/pprof:
Excluding /usr/local/go-1.11.5/src/runtime/pprof/internal
Excluding /usr/local/go-1.11.5/src/runtime/pprof/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/runtime/race
Processing runtime/race:
Matchfile(/usr/local/go-1.11.5/src/runtime/race/doc.go) => true <nil>
Ignoring test code in race_windows_test.go
Ignoring test code in race_linux_test.go
Ignoring test code in race_test.go
Ignoring test code in race_unix_test.go
Ignoring test code in output_test.go
Ignoring test code in sched_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/race/race.go) => false <nil>
Processing package=runtime/race:
Excluding /usr/local/go-1.11.5/src/runtime/race/testdata
Excluding /usr/local/go-1.11.5/src/runtime/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/runtime/trace
Processing runtime/trace:
Matchfile(/usr/local/go-1.11.5/src/runtime/trace/trace.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in trace_test.go
Matchfile(/usr/local/go-1.11.5/src/runtime/trace/annotation.go) => true <nil>
Ignoring test code in annotation_test.go
Ignoring test code in trace_stack_test.go
Processing package=runtime/trace:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/sort
Processing sort:
Ignoring test code in example_keys_test.go
Matchfile(/usr/local/go-1.11.5/src/sort/search.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/sort/slice.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Ignoring test code in search_test.go
Ignoring test code in sort_test.go
Matchfile(/usr/local/go-1.11.5/src/sort/genzfunc.go) => false <nil>
Ignoring test code in example_wrapper_test.go
Ignoring test code in example_multi_test.go
Ignoring test code in example_search_test.go
Matchfile(/usr/local/go-1.11.5/src/sort/sort.go) => true <nil>
Ignoring test code in example_interface_test.go
Matchfile(/usr/local/go-1.11.5/src/sort/zfuncversion.go) => true <nil>
Processing package=sort:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/strconv
Processing strconv:
Matchfile(/usr/local/go-1.11.5/src/strconv/doc.go) => true <nil>
Ignoring test code in decimal_test.go
Ignoring test code in itoa_test.go
Ignoring test code in atob_test.go
Ignoring test code in fp_test.go
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Matchfile(/usr/local/go-1.11.5/src/strconv/ftoa.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/strconv/extfloat.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/strconv/decimal.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/strconv/isprint.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/strconv/atof.go) => true <nil>
Ignoring test code in internal_test.go
Ignoring test code in atof_test.go
Matchfile(/usr/local/go-1.11.5/src/strconv/itoa.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/strconv/quote.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/strconv/atob.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/strconv/atoi.go) => true <nil>
Ignoring test code in ftoa_test.go
Ignoring test code in quote_test.go
Ignoring test code in strconv_test.go
Matchfile(/usr/local/go-1.11.5/src/strconv/makeisprint.go) => false <nil>
Ignoring test code in atoi_test.go
Processing package=strconv:
Excluding /usr/local/go-1.11.5/src/strconv/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/strings
Processing strings:
Matchfile(/usr/local/go-1.11.5/src/strings/search.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/strings/builder.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/strings/reader.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/strings/strings.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/strings/strings_decl.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Ignoring test code in search_test.go
Ignoring test code in compare_test.go
Ignoring test code in strings_test.go
Ignoring test code in replace_test.go
Ignoring test code in reader_test.go
Matchfile(/usr/local/go-1.11.5/src/strings/compare.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/strings/replace.go) => true <nil>
Ignoring test code in builder_test.go
Processing package=strings:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/sync
Processing sync:
Matchfile(/usr/local/go-1.11.5/src/sync/map.go) => true <nil>
Ignoring test code in once_test.go
Matchfile(/usr/local/go-1.11.5/src/sync/once.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Matchfile(/usr/local/go-1.11.5/src/sync/mutex.go) => true <nil>
Ignoring test code in example_pool_test.go
Matchfile(/usr/local/go-1.11.5/src/sync/runtime.go) => true <nil>
Ignoring test code in map_reference_test.go
Matchfile(/usr/local/go-1.11.5/src/sync/rwmutex.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/sync/cond.go) => true <nil>
Ignoring test code in map_bench_test.go
Ignoring test code in map_test.go
Ignoring test code in rwmutex_test.go
Ignoring test code in cond_test.go
Matchfile(/usr/local/go-1.11.5/src/sync/waitgroup.go) => true <nil>
Ignoring test code in mutex_test.go
Ignoring test code in waitgroup_test.go
Matchfile(/usr/local/go-1.11.5/src/sync/pool.go) => true <nil>
Ignoring test code in pool_test.go
Ignoring test code in runtime_sema_test.go
Processing package=sync:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/sync/atomic
Processing sync/atomic:
Matchfile(/usr/local/go-1.11.5/src/sync/atomic/doc.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/sync/atomic/value.go) => true <nil>
Ignoring test code in atomic_test.go
Ignoring test code in example_test.go
Ignoring test code in value_test.go
Processing package=sync/atomic:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/syscall
Processing syscall:
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysctl_openbsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/dir_plan9.go) => false <nil>
Ignoring test code in creds_test.go
Matchfile(/usr/local/go-1.11.5/src/syscall/route_freebsd_64bit.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_linux.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_dragonfly_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_linux_ppc64x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_nacl_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/route_openbsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_darwin_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_darwin_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/env_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_openbsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/endian_big.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/types_linux.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_linux_amd64.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_linux_mips64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_linux_mips64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/msan.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_linux_mips.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/env_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_solaris.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_openbsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_darwin.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_openbsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_plan9_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_linux_mipsx.go) => false <nil>
Ignoring test code in export_unix_test.go
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_dragonfly_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/unzip_nacl.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/forkpipe.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/mkpost.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/timestruct.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_linux_ppc64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_openbsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_linux_mips64x.go) => false <nil>
Ignoring test code in syscall_windows_test.go
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/errors_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_windows_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_darwin_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_linux_mips64le.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_windows_amd64.go) => false <nil>
Ignoring test code in mmap_unix_test.go
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/route_netbsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_openbsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_linux_amd64.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_openbsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_solaris_amd64.go) => false <nil>
Ignoring test code in export_test.go
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_linux_amd64.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_darwin_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_freebsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/dirent.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_linux_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_linux_mips64le.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_windows_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_linux_mipsle.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_linux_mipsle.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/str.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_linux_ppc64le.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/sockcmsg_linux.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_linux_ppc64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/exec_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_linux_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/net_nacl.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/net.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_linux_mipsle.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_linux_mips.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_linux_amd64.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_bsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_dragonfly_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_dragonfly.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/forkpipe2.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/bpf_bsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_openbsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_darwin_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/route_bsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_darwin_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/fd_nacl.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/pwd_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_openbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_linux_mips64le.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_openbsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_linux_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_nacl_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/env_windows.go) => false <nil>
Ignoring test code in syscall_unix_test.go
Ignoring test code in syscall_test.go
Matchfile(/usr/local/go-1.11.5/src/syscall/dll_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_linux_ppc64le.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/mksyscall_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_windows_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_openbsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_nacl_amd64p32.go) => false <nil>
Ignoring test code in exec_linux_test.go
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_netbsd_386.go) => false <nil>
Ignoring test code in syscall_bsd_test.go
Ignoring test code in syscall_linux_test.go
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_darwin_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_nacl_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_linux_ppc64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_freebsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/msan0.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/const_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_linux_ppc64le.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_nacl_amd64p32.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/types_dragonfly.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/flock.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_openbsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_nacl.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/types_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/setuidgid_32_linux.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/types_openbsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_windows_386.go) => false <nil>
Ignoring test code in syscall_plan9_test.go
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_plan9_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_plan9_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_js.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_freebsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_windows_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/setuidgid_linux.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/fs_js.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/netlink_linux.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_linux_amd64.go) => true <nil>
Ignoring test code in export_linux_test.go
Matchfile(/usr/local/go-1.11.5/src/syscall/endian_little.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_linux_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/exec_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/fs_nacl.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_linux_mips64le.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_linux_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_linux_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_darwin_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_freebsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/tables_nacljs.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/types_darwin.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_linux_mipsle.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_linux_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/security_windows.go) => false <nil>
Ignoring test code in exec_unix_test.go
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_darwin_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_linux_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_openbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_openbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_linux_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_getwd_bsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/exec_bsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_netbsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_freebsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/route_darwin.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_netbsd_arm.go) => false <nil>
Ignoring test code in exec_solaris_test.go
Matchfile(/usr/local/go-1.11.5/src/syscall/route_dragonfly.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_linux_mips.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_openbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/lsf_linux.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_linux_mips64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/flock_linux_32bit.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_linux_mips.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_linux_mips64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/route_freebsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/net_js.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_openbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/types_solaris.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_openbsd_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsyscall_linux_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/types_netbsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/types_windows_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/sockcmsg_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_linux_ppc64le.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/exec_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/exec_solaris.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_dragonfly_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/route_freebsd_32bit.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_freebsd_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/exec_linux.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/types_windows_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/types_freebsd.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_dragonfly_amd64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zerrors_darwin_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/syscall_nacl_386.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/zsysnum_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/ztypes_linux_ppc64.go) => false <nil>
Processing package=syscall:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/syscall/js
Processing syscall/js:
Matchfile(/usr/local/go-1.11.5/src/syscall/js/callback.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/syscall/js/typedarray.go) => false <nil>
Ignoring test code in js_test.go
Matchfile(/usr/local/go-1.11.5/src/syscall/js/js.go) => false <nil>
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/testing
Processing testing:
Ignoring test code in testing_test.go
Matchfile(/usr/local/go-1.11.5/src/testing/match.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/testing/cover.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/testing/allocs.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/testing/example.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(/usr/local/go-1.11.5/src/testing/benchmark.go) => true <nil>
Ignoring test code in sub_test.go
Ignoring test code in allocs_test.go
Ignoring test code in match_test.go
Ignoring test code in helperfuncs_test.go
Ignoring test code in helper_test.go
Ignoring test code in benchmark_test.go
Matchfile(/usr/local/go-1.11.5/src/testing/testing.go) => true <nil>
Processing package=testing:
Excluding /usr/local/go-1.11.5/src/testing/internal
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/testing/iotest
Processing testing/iotest:
Matchfile(/usr/local/go-1.11.5/src/testing/iotest/reader.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/testing/iotest/writer.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/testing/iotest/logger.go) => true <nil>
Processing package=testing/iotest:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/testing/quick
Processing testing/quick:
Matchfile(/usr/local/go-1.11.5/src/testing/quick/quick.go) => true <nil>
Ignoring test code in quick_test.go
Processing package=testing/quick:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/text
Processing text:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/text/scanner
Processing text/scanner:
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/text/scanner/scanner.go) => true <nil>
Ignoring test code in scanner_test.go
Processing package=text/scanner:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/text/tabwriter
Processing text/tabwriter:
Matchfile(/usr/local/go-1.11.5/src/text/tabwriter/tabwriter.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in tabwriter_test.go
Processing package=text/tabwriter:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/text/template
Processing text/template:
Matchfile(/usr/local/go-1.11.5/src/text/template/doc.go) => true <nil>
Ignoring test code in exec_test.go
Matchfile(/usr/local/go-1.11.5/src/text/template/funcs.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/text/template/helper.go) => true <nil>
Ignoring test code in examplefiles_test.go
Matchfile(/usr/local/go-1.11.5/src/text/template/exec.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/text/template/template.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/text/template/option.go) => true <nil>
Ignoring test code in examplefunc_test.go
Ignoring test code in multi_test.go
Processing package=text/template:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/text/template/parse
Processing text/template/parse:
Ignoring test code in parse_test.go
Matchfile(/usr/local/go-1.11.5/src/text/template/parse/parse.go) => true <nil>
Ignoring test code in lex_test.go
Matchfile(/usr/local/go-1.11.5/src/text/template/parse/lex.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/text/template/parse/node.go) => true <nil>
Processing package=text/template/parse:
Excluding /usr/local/go-1.11.5/src/text/template/testdata
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/time
Processing time:
Ignoring test code in zoneinfo_android_test.go
Ignoring test code in format_test.go
Ignoring test code in sleep_test.go
Matchfile(/usr/local/go-1.11.5/src/time/zoneinfo_android.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/time/zoneinfo_abbrs_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/time/sys_plan9.go) => false <nil>
Ignoring test code in export_windows_test.go
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Ignoring test code in internal_test.go
Ignoring test code in tick_test.go
Matchfile(/usr/local/go-1.11.5/src/time/format.go) => true <nil>
Ignoring test code in export_android_test.go
Matchfile(/usr/local/go-1.11.5/src/time/sys_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/time/zoneinfo_windows.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/time/genzabbrs.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/time/time.go) => true <nil>
Ignoring test code in time_test.go
Matchfile(/usr/local/go-1.11.5/src/time/zoneinfo_unix.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/time/zoneinfo_read.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/time/zoneinfo.go) => true <nil>
Ignoring test code in zoneinfo_windows_test.go
Matchfile(/usr/local/go-1.11.5/src/time/tick.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/time/sleep.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/time/zoneinfo_ios.go) => false <nil>
Ignoring test code in zoneinfo_test.go
Ignoring test code in mono_test.go
Matchfile(/usr/local/go-1.11.5/src/time/zoneinfo_plan9.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/time/sys_windows.go) => false <nil>
Processing package=time:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/unicode
Processing unicode:
Matchfile(/usr/local/go-1.11.5/src/unicode/maketables.go) => false <nil>
Matchfile(/usr/local/go-1.11.5/src/unicode/tables.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go-1.11.5/src/unicode/letter.go) => true <nil>
Ignoring test code in script_test.go
Matchfile(/usr/local/go-1.11.5/src/unicode/casetables.go) => true <nil>
Ignoring test code in letter_test.go
Ignoring test code in digit_test.go
Matchfile(/usr/local/go-1.11.5/src/unicode/graphic.go) => true <nil>
Matchfile(/usr/local/go-1.11.5/src/unicode/digit.go) => true <nil>
Ignoring test code in graphic_test.go
Processing package=unicode:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/unicode/utf16
Processing unicode/utf16:
Ignoring test code in export_test.go
Ignoring test code in utf16_test.go
Matchfile(/usr/local/go-1.11.5/src/unicode/utf16/utf16.go) => true <nil>
Processing package=unicode/utf16:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/unicode/utf8
Processing unicode/utf8:
Matchfile(/usr/local/go-1.11.5/src/unicode/utf8/utf8.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in utf8_test.go
Processing package=unicode/utf8:
Walking from /usr/local/go-1.11.5/src to /usr/local/go-1.11.5/src/unsafe
Processing unsafe:
Matchfile(/usr/local/go-1.11.5/src/unsafe/unsafe.go) => true <nil>
NOTICE: Ignoring package unsafe in unsafe
Excluding /usr/local/go-1.11.5/src/vendor
JOKER FUNC archive/tar.FileInfoHeader from archive/tar/common.go:
;; (defn FileInfoHeader
;;   "FileInfoHeader creates a partially-populated Header from fi.\nIf fi describes a symlink, FileInfoHeader records link as the link target.\nIf fi describes a directory, a slash is appended to the name.\n\nSince os.FileInfo's Name method only returns the base name of\nthe file it describes, it may be necessary to modify Header.Name\nto provide the full path name of the file.\n\nGo input arguments: (fi os.FileInfo, link string)\n\nGo return type: (*Header, error)\n\nJoker input arguments: [^go.std.os/FileInfo fi, ^String link]\n\nJoker return type: [(atom-of go.std.archive.tar/Header) Error]"
;;   {:added "1.0"
;;    :go "__fileInfoHeader(*_fi, _link)"}
;;   [^os/FileInfo _fi, ^String _link])

JOKER FUNC archive/tar.NewReader from archive/tar/reader.go:
;; (defn NewReader
;;   "NewReader creates a new Reader reading from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.archive.tar/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC archive/tar.NewWriter from archive/tar/writer.go:
;; (defn NewWriter
;;   "NewWriter creates a new Writer writing to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.archive.tar/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*_w)"}
;;   [^io/Writer _w])

JOKER TYPE archive/zip.Compressor from archive/zip/register.go:
;; (defn ^"GoObject" Compressor.
;;   "Constructor for zip.Compressor"
;;   {:added "1.0"
;;    :go "_ConstructCompressor(_v)"}
;;   [^Object _v])

JOKER TYPE archive/zip.Decompressor from archive/zip/register.go:
;; (defn ^"GoObject" Decompressor.
;;   "Constructor for zip.Decompressor"
;;   {:added "1.0"
;;    :go "_ConstructDecompressor(_v)"}
;;   [^Object _v])

JOKER TYPE archive/zip.File from archive/zip/reader.go:
(defn ^"GoObject" File.
  "Constructor for zip.File"
  {:added "1.0"
   :go "_ConstructFile(_v)"}
  [^Object _v])

JOKER TYPE archive/zip.FileHeader from archive/zip/struct.go:
(defn ^"GoObject" FileHeader.
  "Constructor for zip.FileHeader"
  {:added "1.0"
   :go "_ConstructFileHeader(_v)"}
  [^Object _v])

JOKER TYPE archive/zip.ReadCloser from archive/zip/reader.go:
(defn ^"GoObject" ReadCloser.
  "Constructor for zip.ReadCloser"
  {:added "1.0"
   :go "_ConstructReadCloser(_v)"}
  [^Object _v])

JOKER TYPE archive/zip.Reader from archive/zip/reader.go:
(defn ^"GoObject" Reader.
  "Constructor for zip.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER TYPE archive/zip.Writer from archive/zip/writer.go:
(defn ^"GoObject" Writer.
  "Constructor for zip.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC archive/zip.FileInfoHeader from archive/zip/struct.go:
;; (defn FileInfoHeader
;;   "FileInfoHeader creates a partially-populated FileHeader from an\nos.FileInfo.\nBecause os.FileInfo's Name method returns only the base name of\nthe file it describes, it may be necessary to modify the Name field\nof the returned header to provide the full path name of the file.\nIf compression is desired, callers should set the FileHeader.Method\nfield; it is unset by default.\n\nGo input arguments: (fi os.FileInfo)\n\nGo return type: (*FileHeader, error)\n\nJoker input arguments: [^go.std.os/FileInfo fi]\n\nJoker return type: [(atom-of go.std.archive.zip/FileHeader) Error]"
;;   {:added "1.0"
;;    :go "__fileInfoHeader(*_fi)"}
;;   [^os/FileInfo _fi])

JOKER FUNC archive/zip.NewReader from archive/zip/reader.go:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from r, which is assumed to\nhave the given size in bytes.\n\nGo input arguments: (r io.ReaderAt, size int64)\n\nGo return type: (*Reader, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r, ^Int64 size]\n\nJoker return type: [(atom-of go.std.archive.zip/Reader) Error]"
;;   {:added "1.0"
;;    :go "__newReader(*_r, _size)"}
;;   [^io/ReaderAt _r, ^Int64 _size])

JOKER FUNC archive/zip.NewWriter from archive/zip/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer writing a zip file to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.archive.zip/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*_w)"}
;;   [^io/Writer _w])

JOKER FUNC archive/zip.OpenReader from archive/zip/reader.go:
(defn OpenReader
  "OpenReader will open the Zip file specified by name and return a ReadCloser.\n\nGo input arguments: (name string)\n\nGo return type: (*ReadCloser, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.archive.zip/ReadCloser) Error]"
  {:added "1.0"
   :go "__openReader(_name)"}
  [^String _name])

JOKER FUNC archive/zip.RegisterCompressor from archive/zip/register.go:
;; (defn RegisterCompressor
;;   "RegisterCompressor registers custom compressors for a specified method ID.\nThe common methods Store and Deflate are built in.\n\nGo input arguments: (method uint16, comp Compressor)\n\nJoker input arguments: [^UInt16 method, ^go.std.archive.zip/Compressor comp]"
;;   {:added "1.0"
;;    :go "__registerCompressor(_method, *_comp)"}
;;   [^UInt16 _method, ^zip/Compressor _comp])

JOKER FUNC archive/zip.RegisterDecompressor from archive/zip/register.go:
;; (defn RegisterDecompressor
;;   "RegisterDecompressor allows custom decompressors for a specified method ID.\nThe common methods Store and Deflate are built in.\n\nGo input arguments: (method uint16, dcomp Decompressor)\n\nJoker input arguments: [^UInt16 method, ^go.std.archive.zip/Decompressor dcomp]"
;;   {:added "1.0"
;;    :go "__registerDecompressor(_method, *_dcomp)"}
;;   [^UInt16 _method, ^zip/Decompressor _dcomp])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the archive/zip package."
    :empty false}
  go.std.archive.zip)
JOKER TYPE bufio.ReadWriter from bufio/bufio.go:
(defn ^"GoObject" ReadWriter.
  "Constructor for bufio.ReadWriter"
  {:added "1.0"
   :go "_ConstructReadWriter(_v)"}
  [^Object _v])

JOKER TYPE bufio.Reader from bufio/bufio.go:
(defn ^"GoObject" Reader.
  "Constructor for bufio.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER TYPE bufio.Scanner from bufio/scan.go:
(defn ^"GoObject" Scanner.
  "Constructor for bufio.Scanner"
  {:added "1.0"
   :go "_ConstructScanner(_v)"}
  [^Object _v])

JOKER TYPE bufio.SplitFunc from bufio/scan.go:
;; (defn ^"GoObject" SplitFunc.
;;   "Constructor for bufio.SplitFunc"
;;   {:added "1.0"
;;    :go "_ConstructSplitFunc(_v)"}
;;   [^Object _v])

JOKER TYPE bufio.Writer from bufio/bufio.go:
(defn ^"GoObject" Writer.
  "Constructor for bufio.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC bufio.NewReadWriter from bufio/bufio.go:
(defn NewReadWriter
  "NewReadWriter allocates a new ReadWriter that dispatches to r and w.\n\nGo input arguments: (r *Reader, w *Writer)\n\nGo return type: *ReadWriter\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) r, ^(atom-of go.std.bufio/Writer) w]\n\nJoker return type: (atom-of go.std.bufio/ReadWriter)"
  {:added "1.0"
   :go "__newReadWriter(_r, _w)"}
  [^bufio/Reader _r, ^bufio/Writer _w])

JOKER FUNC bufio.NewReader from bufio/bufio.go:
;; (defn NewReader
;;   "NewReader returns a new Reader whose buffer has the default size.\n\nGo input arguments: (rd io.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader rd]\n\nJoker return type: (atom-of go.std.bufio/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(*_rd)"}
;;   [^io/Reader _rd])

JOKER FUNC bufio.NewReaderSize from bufio/bufio.go:
;; (defn NewReaderSize
;;   "NewReaderSize returns a new Reader whose buffer has at least the specified\nsize. If the argument io.Reader is already a Reader with large enough\nsize, it returns the underlying Reader.\n\nGo input arguments: (rd io.Reader, size int)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader rd, ^Int size]\n\nJoker return type: (atom-of go.std.bufio/Reader)"
;;   {:added "1.0"
;;    :go "__newReaderSize(*_rd, _size)"}
;;   [^io/Reader _rd, ^Int _size])

JOKER FUNC bufio.NewScanner from bufio/scan.go:
;; (defn NewScanner
;;   "NewScanner returns a new Scanner to read from r.\nThe split function defaults to ScanLines.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Scanner\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.bufio/Scanner)"
;;   {:added "1.0"
;;    :go "__newScanner(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC bufio.NewWriter from bufio/bufio.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer whose buffer has the default size.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.bufio/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*_w)"}
;;   [^io/Writer _w])

JOKER FUNC bufio.NewWriterSize from bufio/bufio.go:
;; (defn NewWriterSize
;;   "NewWriterSize returns a new Writer whose buffer has at least the specified\nsize. If the argument io.Writer is already a Writer with large enough\nsize, it returns the underlying Writer.\n\nGo input arguments: (w io.Writer, size int)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w, ^Int size]\n\nJoker return type: (atom-of go.std.bufio/Writer)"
;;   {:added "1.0"
;;    :go "__newWriterSize(*_w, _size)"}
;;   [^io/Writer _w, ^Int _size])

JOKER FUNC bufio.ScanBytes from bufio/scan.go:
;; (defn ScanBytes
;;   "ScanBytes is a split function for a Scanner that returns each byte as a token.\n\nGo input arguments: (data []byte, atEOF bool)\n\nGo return type: (advance int, token []byte, err error)\n\nJoker input arguments: [^(vector-of Byte) data, ^Boolean atEOF]\n\nJoker return type: [Int (vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__scanBytes(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), _atEOF)"}
;;   [^Object _data, ^Boolean _atEOF])

JOKER FUNC bufio.ScanLines from bufio/scan.go:
;; (defn ScanLines
;;   "ScanLines is a split function for a Scanner that returns each line of\ntext, stripped of any trailing end-of-line marker. The returned line may\nbe empty. The end-of-line marker is one optional carriage return followed\nby one mandatory newline. In regular expression notation, it is `\\r?\\n`.\nThe last non-empty line of input will be returned even if it has no\nnewline.\n\nGo input arguments: (data []byte, atEOF bool)\n\nGo return type: (advance int, token []byte, err error)\n\nJoker input arguments: [^(vector-of Byte) data, ^Boolean atEOF]\n\nJoker return type: [Int (vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__scanLines(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), _atEOF)"}
;;   [^Object _data, ^Boolean _atEOF])

JOKER FUNC bufio.ScanRunes from bufio/scan.go:
;; (defn ScanRunes
;;   "ScanRunes is a split function for a Scanner that returns each\nUTF-8-encoded rune as a token. The sequence of runes returned is\nequivalent to that from a range loop over the input as a string, which\nmeans that erroneous UTF-8 encodings translate to U+FFFD = \"\\xef\\xbf\\xbd\".\nBecause of the Scan interface, this makes it impossible for the client to\ndistinguish correctly encoded replacement runes from encoding errors.\n\nGo input arguments: (data []byte, atEOF bool)\n\nGo return type: (advance int, token []byte, err error)\n\nJoker input arguments: [^(vector-of Byte) data, ^Boolean atEOF]\n\nJoker return type: [Int (vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__scanRunes(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), _atEOF)"}
;;   [^Object _data, ^Boolean _atEOF])

JOKER FUNC bufio.ScanWords from bufio/scan.go:
;; (defn ScanWords
;;   "ScanWords is a split function for a Scanner that returns each\nspace-separated word of text, with surrounding spaces deleted. It will\nnever return an empty string. The definition of space is set by\nunicode.IsSpace.\n\nGo input arguments: (data []byte, atEOF bool)\n\nGo return type: (advance int, token []byte, err error)\n\nJoker input arguments: [^(vector-of Byte) data, ^Boolean atEOF]\n\nJoker return type: [Int (vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__scanWords(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), _atEOF)"}
;;   [^Object _data, ^Boolean _atEOF])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the bufio package."
    :empty false}
  go.std.bufio)
JOKER TYPE bytes.Buffer from bytes/buffer.go:
(defn ^"GoObject" Buffer.
  "Constructor for bytes.Buffer"
  {:added "1.0"
   :go "_ConstructBuffer(_v)"}
  [^Object _v])

JOKER TYPE bytes.Reader from bytes/reader.go:
(defn ^"GoObject" Reader.
  "Constructor for bytes.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER FUNC bytes.Compare from bytes/bytes_decl.go:
;; (defn ^"Int" Compare
;;   "Compare returns an integer comparing two byte slices lexicographically.\nThe result will be 0 if a==b, -1 if a < b, and +1 if a > b.\nA nil argument is equivalent to an empty slice.\n\nGo input arguments: (a []byte, b []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) a, ^(vector-of Byte) b]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.Compare(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_a)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _a, ^Object _b])

JOKER FUNC bytes.Contains from bytes/bytes.go:
;; (defn ^"Boolean" Contains
;;   "Contains reports whether subslice is within b.\n\nGo input arguments: (b []byte, subslice []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) b, ^(vector-of Byte) subslice]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "bytes.Contains(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_subslice)))"}
;;   [^Object _b, ^Object _subslice])

JOKER FUNC bytes.ContainsAny from bytes/bytes.go:
;; (defn ^"Boolean" ContainsAny
;;   "ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b.\n\nGo input arguments: (b []byte, chars string)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) b, ^String chars]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "bytes.ContainsAny(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)), _chars)"}
;;   [^Object _b, ^String _chars])

JOKER FUNC bytes.ContainsRune from bytes/bytes.go:
;; (defn ^"Boolean" ContainsRune
;;   "ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b.\n\nGo input arguments: (b []byte, r rune)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) b, ^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "bytes.ContainsRune(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)), _r)"}
;;   [^Object _b, ^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC bytes.Count from bytes/bytes.go:
;; (defn ^"Int" Count
;;   "Count counts the number of non-overlapping instances of sep in s.\nIf sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) sep]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.Count(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_sep)))"}
;;   [^Object _s, ^Object _sep])

JOKER FUNC bytes.Equal from bytes/bytes_decl.go:
;; (defn ^"Boolean" Equal
;;   "Equal returns a boolean reporting whether a and b\nare the same length and contain the same bytes.\nA nil argument is equivalent to an empty slice.\n\nGo input arguments: (a []byte, b []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) a, ^(vector-of Byte) b]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "bytes.Equal(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_a)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _a, ^Object _b])

JOKER FUNC bytes.EqualFold from bytes/bytes.go:
;; (defn ^"Boolean" EqualFold
;;   "EqualFold reports whether s and t, interpreted as UTF-8 strings,\nare equal under Unicode case-folding.\n\nGo input arguments: (s []byte, t []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) t]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "bytes.EqualFold(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_t)))"}
;;   [^Object _s, ^Object _t])

JOKER FUNC bytes.Fields from bytes/bytes.go:
;; (defn Fields
;;   "Fields interprets s as a sequence of UTF-8-encoded code points.\nIt splits the slice s around each instance of one or more consecutive white space\ncharacters, as defined by unicode.IsSpace, returning a slice of subslices of s or an\nempty slice if s contains only white space.\n\nGo input arguments: (s []byte)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Byte) s]\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "__fields(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^Object _s])

JOKER FUNC bytes.FieldsFunc from bytes/bytes.go:
;; (defn FieldsFunc
;;   "FieldsFunc interprets s as a sequence of UTF-8-encoded code points.\nIt splits the slice s at each run of code points c satisfying f(c) and\nreturns a slice of subslices of s. If all code points in s satisfy f(c), or\nlen(s) == 0, an empty slice is returned.\nFieldsFunc makes no guarantees about the order in which it calls f(c).\nIf f does not return consistent results for a given c, FieldsFunc may crash.\n\nGo input arguments: (s []byte, f func)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Byte) s, ^fn f]\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "__fieldsFunc(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object _s, ^fn _f])

JOKER FUNC bytes.HasPrefix from bytes/bytes.go:
;; (defn ^"Boolean" HasPrefix
;;   "HasPrefix tests whether the byte slice s begins with prefix.\n\nGo input arguments: (s []byte, prefix []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) prefix]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "bytes.HasPrefix(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_prefix)))"}
;;   [^Object _s, ^Object _prefix])

JOKER FUNC bytes.HasSuffix from bytes/bytes.go:
;; (defn ^"Boolean" HasSuffix
;;   "HasSuffix tests whether the byte slice s ends with suffix.\n\nGo input arguments: (s []byte, suffix []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) suffix]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "bytes.HasSuffix(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_suffix)))"}
;;   [^Object _s, ^Object _suffix])

JOKER FUNC bytes.Index from bytes/bytes.go:
;; (defn ^"Int" Index
;;   "Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) sep]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.Index(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_sep)))"}
;;   [^Object _s, ^Object _sep])

JOKER FUNC bytes.IndexAny from bytes/bytes.go:
;; (defn ^"Int" IndexAny
;;   "IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points.\nIt returns the byte index of the first occurrence in s of any of the Unicode\ncode points in chars. It returns -1 if chars is empty or if there is no code\npoint in common.\n\nGo input arguments: (s []byte, chars string)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^String chars]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexAny(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), _chars)"}
;;   [^Object _s, ^String _chars])

JOKER FUNC bytes.IndexByte from bytes/bytes_decl.go:
;; (defn ^"Int" IndexByte
;;   "IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b.\n\nGo input arguments: (b []byte, c byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) b, ^Byte c]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexByte(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)), _c)"}
;;   [^Object _b, ^Byte _c])

JOKER FUNC bytes.IndexFunc from bytes/bytes.go:
;; (defn ^"Int" IndexFunc
;;   "IndexFunc interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index in s of the first Unicode\ncode point satisfying f(c), or -1 if none do.\n\nGo input arguments: (s []byte, f func)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexFunc(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object _s, ^fn _f])

JOKER FUNC bytes.IndexRune from bytes/bytes.go:
;; (defn ^"Int" IndexRune
;;   "IndexRune interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index of the first occurrence in s of the given rune.\nIt returns -1 if rune is not present in s.\nIf r is utf8.RuneError, it returns the first instance of any\ninvalid UTF-8 byte sequence.\n\nGo input arguments: (s []byte, r rune)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^rune r]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexRune(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), _r)"}
;;   [^Object _s, ^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC bytes.Join from bytes/bytes.go:
;; (defn Join
;;   "Join concatenates the elements of s to create a new byte slice. The separator\nsep is placed between elements in the resulting slice.\n\nGo input arguments: (s [][]byte, sep []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of (vector-of Byte)) s, ^(vector-of Byte) sep]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__join(ConvertToArrayOf[]byte(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s))), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_sep)))"}
;;   [^Object _s, ^Object _sep])

JOKER FUNC bytes.LastIndex from bytes/bytes.go:
;; (defn ^"Int" LastIndex
;;   "LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) sep]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.LastIndex(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_sep)))"}
;;   [^Object _s, ^Object _sep])

JOKER FUNC bytes.LastIndexAny from bytes/bytes.go:
;; (defn ^"Int" LastIndexAny
;;   "LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code\npoints. It returns the byte index of the last occurrence in s of any of\nthe Unicode code points in chars. It returns -1 if chars is empty or if\nthere is no code point in common.\n\nGo input arguments: (s []byte, chars string)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^String chars]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.LastIndexAny(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), _chars)"}
;;   [^Object _s, ^String _chars])

JOKER FUNC bytes.LastIndexByte from bytes/bytes.go:
;; (defn ^"Int" LastIndexByte
;;   "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.\n\nGo input arguments: (s []byte, c byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^Byte c]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.LastIndexByte(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), _c)"}
;;   [^Object _s, ^Byte _c])

JOKER FUNC bytes.LastIndexFunc from bytes/bytes.go:
;; (defn ^"Int" LastIndexFunc
;;   "LastIndexFunc interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index in s of the last Unicode\ncode point satisfying f(c), or -1 if none do.\n\nGo input arguments: (s []byte, f func)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.LastIndexFunc(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object _s, ^fn _f])

JOKER FUNC bytes.Map from bytes/bytes.go:
;; (defn Map
;;   "Map returns a copy of the byte slice s with all its characters modified\naccording to the mapping function. If mapping returns a negative value, the character is\ndropped from the byte slice with no replacement. The characters in s and the\noutput are interpreted as UTF-8-encoded code points.\n\nGo input arguments: (mapping func, s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^fn mapping, ^(vector-of Byte) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__map(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^fn _mapping, ^Object _s])

JOKER FUNC bytes.NewBuffer from bytes/buffer.go:
;; (defn NewBuffer
;;   "NewBuffer creates and initializes a new Buffer using buf as its\ninitial contents. The new Buffer takes ownership of buf, and the\ncaller should not use buf after this call. NewBuffer is intended to\nprepare a Buffer to read existing data. It can also be used to size\nthe internal buffer for writing. To do that, buf should have the\ndesired capacity but a length of zero.\n\nIn most cases, new(Buffer) (or just declaring a Buffer variable) is\nsufficient to initialize a Buffer.\n\nGo input arguments: (buf []byte)\n\nGo return type: *Buffer\n\nJoker input arguments: [^(vector-of Byte) buf]\n\nJoker return type: (atom-of go.std.bytes/Buffer)"
;;   {:added "1.0"
;;    :go "__newBuffer(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)))"}
;;   [^Object _buf])

JOKER FUNC bytes.NewBufferString from bytes/buffer.go:
(defn NewBufferString
  "NewBufferString creates and initializes a new Buffer using string s as its\ninitial contents. It is intended to prepare a buffer to read an existing\nstring.\n\nIn most cases, new(Buffer) (or just declaring a Buffer variable) is\nsufficient to initialize a Buffer.\n\nGo input arguments: (s string)\n\nGo return type: *Buffer\n\nJoker input arguments: [^String s]\n\nJoker return type: (atom-of go.std.bytes/Buffer)"
  {:added "1.0"
   :go "__newBufferString(_s)"}
  [^String _s])

JOKER FUNC bytes.NewReader from bytes/reader.go:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from b.\n\nGo input arguments: (b []byte)\n\nGo return type: *Reader\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: (atom-of go.std.bytes/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _b])

JOKER FUNC bytes.Repeat from bytes/bytes.go:
;; (defn Repeat
;;   "Repeat returns a new byte slice consisting of count copies of b.\n\nIt panics if count is negative or if\nthe result of (len(b) * count) overflows.\n\nGo input arguments: (b []byte, count int)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) b, ^Int count]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__repeat(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)), _count)"}
;;   [^Object _b, ^Int _count])

JOKER FUNC bytes.Replace from bytes/bytes.go:
;; (defn Replace
;;   "Replace returns a copy of the slice s with the first n\nnon-overlapping instances of old replaced by new.\nIf old is empty, it matches at the beginning of the slice\nand after each UTF-8 sequence, yielding up to k+1 replacements\nfor a k-rune slice.\nIf n < 0, there is no limit on the number of replacements.\n\nGo input arguments: (s []byte, old []byte, new []byte, n int)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) old, ^(vector-of Byte) new, ^Int n]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__replace(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_old)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_new)), _n)"}
;;   [^Object _s, ^Object _old, ^Object _new, ^Int _n])

JOKER FUNC bytes.Runes from bytes/bytes.go:
;; (defn Runes
;;   "Runes interprets s as a sequence of UTF-8-encoded code points.\nIt returns a slice of runes (Unicode code points) equivalent to s.\n\nGo input arguments: (s []byte)\n\nGo return type: []...\n\nJoker input arguments: [^(vector-of Byte) s]\n\nJoker return type: (vector-of ABEND043(post.go: unsupported built-in type rune))"
;;   {:added "1.0"
;;    :go "__runes(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^Object _s])

JOKER FUNC bytes.Split from bytes/bytes.go:
;; (defn Split
;;   "Split slices s into all subslices separated by sep and returns a slice of\nthe subslices between those separators.\nIf sep is empty, Split splits after each UTF-8 sequence.\nIt is equivalent to SplitN with a count of -1.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) sep]\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "__split(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_sep)))"}
;;   [^Object _s, ^Object _sep])

JOKER FUNC bytes.SplitAfter from bytes/bytes.go:
;; (defn SplitAfter
;;   "SplitAfter slices s into all subslices after each instance of sep and\nreturns a slice of those subslices.\nIf sep is empty, SplitAfter splits after each UTF-8 sequence.\nIt is equivalent to SplitAfterN with a count of -1.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) sep]\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "__splitAfter(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_sep)))"}
;;   [^Object _s, ^Object _sep])

JOKER FUNC bytes.SplitAfterN from bytes/bytes.go:
;; (defn SplitAfterN
;;   "SplitAfterN slices s into subslices after each instance of sep and\nreturns a slice of those subslices.\nIf sep is empty, SplitAfterN splits after each UTF-8 sequence.\nThe count determines the number of subslices to return:\n  n > 0: at most n subslices; the last subslice will be the unsplit remainder.\n  n == 0: the result is nil (zero subslices)\n  n < 0: all subslices\n\nGo input arguments: (s []byte, sep []byte, n int)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) sep, ^Int n]\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "__splitAfterN(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_sep)), _n)"}
;;   [^Object _s, ^Object _sep, ^Int _n])

JOKER FUNC bytes.SplitN from bytes/bytes.go:
;; (defn SplitN
;;   "SplitN slices s into subslices separated by sep and returns a slice of\nthe subslices between those separators.\nIf sep is empty, SplitN splits after each UTF-8 sequence.\nThe count determines the number of subslices to return:\n  n > 0: at most n subslices; the last subslice will be the unsplit remainder.\n  n == 0: the result is nil (zero subslices)\n  n < 0: all subslices\n\nGo input arguments: (s []byte, sep []byte, n int)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) sep, ^Int n]\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "__splitN(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_sep)), _n)"}
;;   [^Object _s, ^Object _sep, ^Int _n])

JOKER FUNC bytes.Title from bytes/bytes.go:
;; (defn Title
;;   "Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin\nwords mapped to their title case.\n\nBUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\n\nGo input arguments: (s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__title(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^Object _s])

JOKER FUNC bytes.ToLower from bytes/bytes.go:
;; (defn ToLower
;;   "ToLower treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case.\n\nGo input arguments: (s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__toLower(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^Object _s])

JOKER FUNC bytes.ToLowerSpecial from bytes/bytes.go:
;; (defn ToLowerSpecial
;;   "ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\nlower case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^(vector-of Byte) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__toLowerSpecial(*_c, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^unicode/SpecialCase _c, ^Object _s])

JOKER FUNC bytes.ToTitle from bytes/bytes.go:
;; (defn ToTitle
;;   "ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.\n\nGo input arguments: (s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__toTitle(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^Object _s])

JOKER FUNC bytes.ToTitleSpecial from bytes/bytes.go:
;; (defn ToTitleSpecial
;;   "ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\ntitle case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^(vector-of Byte) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__toTitleSpecial(*_c, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^unicode/SpecialCase _c, ^Object _s])

JOKER FUNC bytes.ToUpper from bytes/bytes.go:
;; (defn ToUpper
;;   "ToUpper treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters within it mapped to their upper case.\n\nGo input arguments: (s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__toUpper(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^Object _s])

JOKER FUNC bytes.ToUpperSpecial from bytes/bytes.go:
;; (defn ToUpperSpecial
;;   "ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\nupper case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^(vector-of Byte) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__toUpperSpecial(*_c, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^unicode/SpecialCase _c, ^Object _s])

JOKER FUNC bytes.Trim from bytes/bytes.go:
;; (defn Trim
;;   "Trim returns a subslice of s by slicing off all leading and\ntrailing UTF-8-encoded code points contained in cutset.\n\nGo input arguments: (s []byte, cutset string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s, ^String cutset]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trim(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), _cutset)"}
;;   [^Object _s, ^String _cutset])

JOKER FUNC bytes.TrimFunc from bytes/bytes.go:
;; (defn TrimFunc
;;   "TrimFunc returns a subslice of s by slicing off all leading and trailing\nUTF-8-encoded code points c that satisfy f(c).\n\nGo input arguments: (s []byte, f func)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s, ^fn f]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimFunc(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object _s, ^fn _f])

JOKER FUNC bytes.TrimLeft from bytes/bytes.go:
;; (defn TrimLeft
;;   "TrimLeft returns a subslice of s by slicing off all leading\nUTF-8-encoded code points contained in cutset.\n\nGo input arguments: (s []byte, cutset string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s, ^String cutset]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimLeft(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), _cutset)"}
;;   [^Object _s, ^String _cutset])

JOKER FUNC bytes.TrimLeftFunc from bytes/bytes.go:
;; (defn TrimLeftFunc
;;   "TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off\nall leading UTF-8-encoded code points c that satisfy f(c).\n\nGo input arguments: (s []byte, f func)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s, ^fn f]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimLeftFunc(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object _s, ^fn _f])

JOKER FUNC bytes.TrimPrefix from bytes/bytes.go:
;; (defn TrimPrefix
;;   "TrimPrefix returns s without the provided leading prefix string.\nIf s doesn't start with prefix, s is returned unchanged.\n\nGo input arguments: (s []byte, prefix []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) prefix]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimPrefix(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_prefix)))"}
;;   [^Object _s, ^Object _prefix])

JOKER FUNC bytes.TrimRight from bytes/bytes.go:
;; (defn TrimRight
;;   "TrimRight returns a subslice of s by slicing off all trailing\nUTF-8-encoded code points that are contained in cutset.\n\nGo input arguments: (s []byte, cutset string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s, ^String cutset]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimRight(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), _cutset)"}
;;   [^Object _s, ^String _cutset])

JOKER FUNC bytes.TrimRightFunc from bytes/bytes.go:
;; (defn TrimRightFunc
;;   "TrimRightFunc returns a subslice of s by slicing off all trailing\nUTF-8-encoded code points c that satisfy f(c).\n\nGo input arguments: (s []byte, f func)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s, ^fn f]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimRightFunc(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object _s, ^fn _f])

JOKER FUNC bytes.TrimSpace from bytes/bytes.go:
;; (defn TrimSpace
;;   "TrimSpace returns a subslice of s by slicing off all leading and\ntrailing white space, as defined by Unicode.\n\nGo input arguments: (s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimSpace(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^Object _s])

JOKER FUNC bytes.TrimSuffix from bytes/bytes.go:
;; (defn TrimSuffix
;;   "TrimSuffix returns s without the provided trailing suffix string.\nIf s doesn't end with suffix, s is returned unchanged.\n\nGo input arguments: (s []byte, suffix []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) suffix]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimSuffix(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_suffix)))"}
;;   [^Object _s, ^Object _suffix])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the bytes package."
    :empty false}
  go.std.bytes)
JOKER FUNC compress/bzip2.NewReader from compress/bzip2/bzip2.go:
;; (defn NewReader
;;   "NewReader returns an io.Reader which decompresses bzip2 data from r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__newReader(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC compress/flate.NewReader from compress/flate/inflate.go:
;; (defn NewReader
;;   "NewReader returns a new ReadCloser that can be used\nto read the uncompressed version of r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser\nwhen finished reading.\n\nThe ReadCloser returned by NewReader also implements Resetter.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.ReadCloser\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "__newReader(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC compress/flate.NewReaderDict from compress/flate/inflate.go:
;; (defn NewReaderDict
;;   "NewReaderDict is like NewReader but initializes the reader\nwith a preset dictionary. The returned Reader behaves as if\nthe uncompressed data stream started with the given dictionary,\nwhich has already been read. NewReaderDict is typically used\nto read data compressed by NewWriterDict.\n\nThe ReadCloser returned by NewReader also implements Resetter.\n\nGo input arguments: (r io.Reader, dict []byte)\n\nGo return type: io.ReadCloser\n\nJoker input arguments: [^go.std.io/Reader r, ^(vector-of Byte) dict]\n\nJoker return type: go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "__newReaderDict(*_r, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_dict)))"}
;;   [^io/Reader _r, ^Object _dict])

JOKER FUNC compress/flate.NewWriter from compress/flate/deflate.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer compressing data at the given level.\nFollowing zlib, levels range from 1 (BestSpeed) to 9 (BestCompression);\nhigher levels typically run slower but compress more. Level 0\n(NoCompression) does not attempt any compression; it only adds the\nnecessary DEFLATE framing.\nLevel -1 (DefaultCompression) uses the default compression level.\nLevel -2 (HuffmanOnly) will use Huffman compression only, giving\na very fast compression for all types of input, but sacrificing considerable\ncompression efficiency.\n\nIf level is in the range [-2, 9] then the error returned will be nil.\nOtherwise the error returned will be non-nil.\n\nGo input arguments: (w io.Writer, level int)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Int level]\n\nJoker return type: [(atom-of go.std.compress.flate/Writer) Error]"
;;   {:added "1.0"
;;    :go "__newWriter(*_w, _level)"}
;;   [^io/Writer _w, ^Int _level])

JOKER FUNC compress/flate.NewWriterDict from compress/flate/deflate.go:
;; (defn NewWriterDict
;;   "NewWriterDict is like NewWriter but initializes the new\nWriter with a preset dictionary. The returned Writer behaves\nas if the dictionary had been written to it without producing\nany compressed output. The compressed data written to w\ncan only be decompressed by a Reader initialized with the\nsame dictionary.\n\nGo input arguments: (w io.Writer, level int, dict []byte)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Int level, ^(vector-of Byte) dict]\n\nJoker return type: [(atom-of go.std.compress.flate/Writer) Error]"
;;   {:added "1.0"
;;    :go "__newWriterDict(*_w, _level, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_dict)))"}
;;   [^io/Writer _w, ^Int _level, ^Object _dict])

JOKER FUNC compress/gzip.NewReader from compress/gzip/gunzip.go:
;; (defn NewReader
;;   "NewReader creates a new Reader reading the given reader.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\n\nIt is the caller's responsibility to call Close on the Reader when done.\n\nThe Reader.Header fields will be valid in the Reader returned.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (*Reader, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [(atom-of go.std.compress.gzip/Reader) Error]"
;;   {:added "1.0"
;;    :go "__newReader(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC compress/gzip.NewWriter from compress/gzip/gzip.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer.\nWrites to the returned writer are compressed and written to w.\n\nIt is the caller's responsibility to call Close on the Writer when done.\nWrites may be buffered and not flushed until Close.\n\nCallers that wish to set the fields in Writer.Header must do so before\nthe first call to Write, Flush, or Close.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.compress.gzip/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*_w)"}
;;   [^io/Writer _w])

JOKER FUNC compress/gzip.NewWriterLevel from compress/gzip/gzip.go:
;; (defn NewWriterLevel
;;   "NewWriterLevel is like NewWriter but specifies the compression level instead\nof assuming DefaultCompression.\n\nThe compression level can be DefaultCompression, NoCompression, HuffmanOnly\nor any integer value between BestSpeed and BestCompression inclusive.\nThe error returned will be nil if the level is valid.\n\nGo input arguments: (w io.Writer, level int)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Int level]\n\nJoker return type: [(atom-of go.std.compress.gzip/Writer) Error]"
;;   {:added "1.0"
;;    :go "__newWriterLevel(*_w, _level)"}
;;   [^io/Writer _w, ^Int _level])

JOKER FUNC compress/lzw.NewReader from compress/lzw/reader.go:
;; (defn NewReader
;;   "NewReader creates a new io.ReadCloser.\nReads from the returned io.ReadCloser read and decompress data from r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser when\nfinished reading.\nThe number of bits to use for literal codes, litWidth, must be in the\nrange [2,8] and is typically 8. It must equal the litWidth\nused during compression.\n\nGo input arguments: (r io.Reader, order Order, litWidth int)\n\nGo return type: io.ReadCloser\n\nJoker input arguments: [^go.std.io/Reader r, ^go.std.compress.lzw/Order order, ^Int litWidth]\n\nJoker return type: go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "__newReader(*_r, *_order, _litWidth)"}
;;   [^io/Reader _r, ^lzw/Order _order, ^Int _litWidth])

JOKER FUNC compress/lzw.NewWriter from compress/lzw/writer.go:
;; (defn NewWriter
;;   "NewWriter creates a new io.WriteCloser.\nWrites to the returned io.WriteCloser are compressed and written to w.\nIt is the caller's responsibility to call Close on the WriteCloser when\nfinished writing.\nThe number of bits to use for literal codes, litWidth, must be in the\nrange [2,8] and is typically 8. Input bytes must be less than 1<<litWidth.\n\nGo input arguments: (w io.Writer, order Order, litWidth int)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^go.std.io/Writer w, ^go.std.compress.lzw/Order order, ^Int litWidth]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "__newWriter(*_w, *_order, _litWidth)"}
;;   [^io/Writer _w, ^lzw/Order _order, ^Int _litWidth])

JOKER FUNC compress/zlib.NewReader from compress/zlib/reader.go:
;; (defn NewReader
;;   "NewReader creates a new ReadCloser.\nReads from the returned ReadCloser read and decompress data from r.\nIf r does not implement io.ByteReader, the decompressor may read more\ndata than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser when done.\n\nThe ReadCloser returned by NewReader also implements Resetter.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (io.ReadCloser, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.io/ReadCloser Error]"
;;   {:added "1.0"
;;    :go "__newReader(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC compress/zlib.NewReaderDict from compress/zlib/reader.go:
;; (defn NewReaderDict
;;   "NewReaderDict is like NewReader but uses a preset dictionary.\nNewReaderDict ignores the dictionary if the compressed data does not refer to it.\nIf the compressed data refers to a different dictionary, NewReaderDict returns ErrDictionary.\n\nThe ReadCloser returned by NewReaderDict also implements Resetter.\n\nGo input arguments: (r io.Reader, dict []byte)\n\nGo return type: (io.ReadCloser, error)\n\nJoker input arguments: [^go.std.io/Reader r, ^(vector-of Byte) dict]\n\nJoker return type: [go.std.io/ReadCloser Error]"
;;   {:added "1.0"
;;    :go "__newReaderDict(*_r, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_dict)))"}
;;   [^io/Reader _r, ^Object _dict])

JOKER FUNC compress/zlib.NewWriter from compress/zlib/writer.go:
;; (defn NewWriter
;;   "NewWriter creates a new Writer.\nWrites to the returned Writer are compressed and written to w.\n\nIt is the caller's responsibility to call Close on the Writer when done.\nWrites may be buffered and not flushed until Close.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.compress.zlib/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*_w)"}
;;   [^io/Writer _w])

JOKER FUNC compress/zlib.NewWriterLevel from compress/zlib/writer.go:
;; (defn NewWriterLevel
;;   "NewWriterLevel is like NewWriter but specifies the compression level instead\nof assuming DefaultCompression.\n\nThe compression level can be DefaultCompression, NoCompression, HuffmanOnly\nor any integer value between BestSpeed and BestCompression inclusive.\nThe error returned will be nil if the level is valid.\n\nGo input arguments: (w io.Writer, level int)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Int level]\n\nJoker return type: [(atom-of go.std.compress.zlib/Writer) Error]"
;;   {:added "1.0"
;;    :go "__newWriterLevel(*_w, _level)"}
;;   [^io/Writer _w, ^Int _level])

JOKER FUNC compress/zlib.NewWriterLevelDict from compress/zlib/writer.go:
;; (defn NewWriterLevelDict
;;   "NewWriterLevelDict is like NewWriterLevel but specifies a dictionary to\ncompress with.\n\nThe dictionary may be nil. If not, its contents should not be modified until\nthe Writer is closed.\n\nGo input arguments: (w io.Writer, level int, dict []byte)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Int level, ^(vector-of Byte) dict]\n\nJoker return type: [(atom-of go.std.compress.zlib/Writer) Error]"
;;   {:added "1.0"
;;    :go "__newWriterLevelDict(*_w, _level, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_dict)))"}
;;   [^io/Writer _w, ^Int _level, ^Object _dict])

JOKER FUNC container/heap.Fix from container/heap/heap.go:
;; (defn Fix
;;   "Fix re-establishes the heap ordering after the element at index i has changed its value.\nChanging the value of the element at index i and then calling Fix is equivalent to,\nbut less expensive than, calling Remove(h, i) followed by a Push of the new value.\nThe complexity is O(log(n)) where n = h.Len().\n\nGo input arguments: (h Interface, i int)\n\nJoker input arguments: [^go.std.container.heap/Interface h, ^Int i]"
;;   {:added "1.0"
;;    :go "__fix(*_h, _i)"}
;;   [^heap/Interface _h, ^Int _i])

JOKER FUNC container/heap.Init from container/heap/heap.go:
;; (defn Init
;;   "Init establishes the heap invariants required by the other routines in this package.\nInit is idempotent with respect to the heap invariants\nand may be called whenever the heap invariants may have been invalidated.\nIts complexity is O(n) where n = h.Len().\n\nGo input arguments: (h Interface)\n\nJoker input arguments: [^go.std.container.heap/Interface h]"
;;   {:added "1.0"
;;    :go "__init(*_h)"}
;;   [^heap/Interface _h])

JOKER FUNC container/heap.Pop from container/heap/heap.go:
;; (defn Pop
;;   "Pop removes the minimum element (according to Less) from the heap\nand returns it. The complexity is O(log(n)) where n = h.Len().\nIt is equivalent to Remove(h, 0).\n\nGo input arguments: (h Interface)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.container.heap/Interface h]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.InterfaceType at: /usr/local/go-1.11.5/src/container/heap/heap.go:62:23)"
;;   {:added "1.0"
;;    :go "__pop(*_h)"}
;;   [^heap/Interface _h])

JOKER FUNC container/heap.Push from container/heap/heap.go:
;; (defn Push
;;   "Push pushes the element x onto the heap. The complexity is\nO(log(n)) where n = h.Len().\n\nGo input arguments: (h Interface, x interface {})\n\nJoker input arguments: [^go.std.container.heap/Interface h, ^<protocol-or-something> x]"
;;   {:added "1.0"
;;    :go "__push(*_h, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^heap/Interface _h, ^<protocol-or-something> _x])

JOKER FUNC container/heap.Remove from container/heap/heap.go:
;; (defn Remove
;;   "Remove removes the element at index i from the heap.\nThe complexity is O(log(n)) where n = h.Len().\n\nGo input arguments: (h Interface, i int)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.container.heap/Interface h, ^Int i]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.InterfaceType at: /usr/local/go-1.11.5/src/container/heap/heap.go:72:33)"
;;   {:added "1.0"
;;    :go "__remove(*_h, _i)"}
;;   [^heap/Interface _h, ^Int _i])

JOKER TYPE container/list.Element from container/list/list.go:
(defn ^"GoObject" Element.
  "Constructor for list.Element"
  {:added "1.0"
   :go "_ConstructElement(_v)"}
  [^Object _v])

JOKER TYPE container/list.List from container/list/list.go:
(defn ^"GoObject" List.
  "Constructor for list.List"
  {:added "1.0"
   :go "_ConstructList(_v)"}
  [^Object _v])

JOKER FUNC container/list.New from container/list/list.go:
(defn New
  "New returns an initialized list.\n\nGo return type: *List\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.container.list/List)"
  {:added "1.0"
   :go "__new()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the container/list package."
    :empty false}
  go.std.container.list)
JOKER TYPE container/ring.Ring from container/ring/ring.go:
(defn ^"GoObject" Ring.
  "Constructor for ring.Ring"
  {:added "1.0"
   :go "_ConstructRing(_v)"}
  [^Object _v])

JOKER FUNC container/ring.New from container/ring/ring.go:
(defn New
  "New creates a ring of n elements.\n\nGo input arguments: (n int)\n\nGo return type: *Ring\n\nJoker input arguments: [^Int n]\n\nJoker return type: (atom-of go.std.container.ring/Ring)"
  {:added "1.0"
   :go "__new(_n)"}
  [^Int _n])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the container/ring package."
    :empty false}
  go.std.container.ring)
JOKER TYPE context.CancelFunc from context/context.go:
;; (defn ^"GoObject" CancelFunc.
;;   "Constructor for context.CancelFunc"
;;   {:added "1.0"
;;    :go "_ConstructCancelFunc(_v)"}
;;   [^Object _v])

JOKER TYPE context.Context from context/context.go:
;; (defn ^"GoObject" Context.
;;   "Constructor for context.Context"
;;   {:added "1.0"
;;    :go "_ConstructContext(_v)"}
;;   [^Object _v])

JOKER FUNC context.Background from context/context.go:
(defn Background
  "Background returns a non-nil, empty Context. It is never canceled, has no\nvalues, and has no deadline. It is typically used by the main function,\ninitialization, and tests, and as the top-level Context for incoming\nrequests.\n\nGo return type: Context\n\nJoker input arguments: []\n\nJoker return type: go.std.context/Context"
  {:added "1.0"
   :go "__background()"}
  [])

JOKER FUNC context.TODO from context/context.go:
(defn TODO
  "TODO returns a non-nil, empty Context. Code should use context.TODO when\nit's unclear which Context to use or it is not yet available (because the\nsurrounding function has not yet been extended to accept a Context\nparameter). TODO is recognized by static analysis tools that determine\nwhether Contexts are propagated correctly in a program.\n\nGo return type: Context\n\nJoker input arguments: []\n\nJoker return type: go.std.context/Context"
  {:added "1.0"
   :go "__tODO()"}
  [])

JOKER FUNC context.WithCancel from context/context.go:
(defn WithCancel
  "WithCancel returns a copy of parent with a new Done channel. The returned\ncontext's Done channel is closed when the returned cancel function is called\nor when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete.\n\nGo input arguments: (parent Context)\n\nGo return type: (ctx Context, cancel CancelFunc)\n\nJoker input arguments: [^go.std.context/Context parent]\n\nJoker return type: [go.std.context/Context go.std.context/CancelFunc]"
  {:added "1.0"
   :go "__withCancel(*_parent)"}
  [^context/Context _parent])

JOKER FUNC context.WithDeadline from context/context.go:
;; (defn WithDeadline
;;   "WithDeadline returns a copy of the parent context with the deadline adjusted\nto be no later than d. If the parent's deadline is already earlier than d,\nWithDeadline(parent, d) is semantically equivalent to parent. The returned\ncontext's Done channel is closed when the deadline expires, when the returned\ncancel function is called, or when the parent context's Done channel is\nclosed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete.\n\nGo input arguments: (parent Context, d time.Time)\n\nGo return type: (Context, CancelFunc)\n\nJoker input arguments: [^go.std.context/Context parent, ^go.std.time/Time d]\n\nJoker return type: [go.std.context/Context go.std.context/CancelFunc]"
;;   {:added "1.0"
;;    :go "__withDeadline(*_parent, *_d)"}
;;   [^context/Context _parent, ^time/Time _d])

JOKER FUNC context.WithTimeout from context/context.go:
;; (defn WithTimeout
;;   "WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete:\n\n\tfunc slowOperationWithTimeout(ctx context.Context) (Result, error) {\n\t\tctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)\n\t\tdefer cancel()  // releases resources if slowOperation completes before timeout elapses\n\t\treturn slowOperation(ctx)\n\t}\n\nGo input arguments: (parent Context, timeout time.Duration)\n\nGo return type: (Context, CancelFunc)\n\nJoker input arguments: [^go.std.context/Context parent, ^go.std.time/Duration timeout]\n\nJoker return type: [go.std.context/Context go.std.context/CancelFunc]"
;;   {:added "1.0"
;;    :go "__withTimeout(*_parent, *_timeout)"}
;;   [^context/Context _parent, ^time/Duration _timeout])

JOKER FUNC context.WithValue from context/context.go:
;; (defn WithValue
;;   "WithValue returns a copy of parent in which the value associated with key is\nval.\n\nUse context Values only for request-scoped data that transits processes and\nAPIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type\nstring or any other built-in type to avoid collisions between\npackages using context. Users of WithValue should define their own\ntypes for keys. To avoid allocating when assigning to an\ninterface{}, context keys often have concrete type\nstruct{}. Alternatively, exported context key variables' static\ntype should be a pointer or interface.\n\nGo input arguments: (parent Context, key interface {}, val interface {})\n\nGo return type: Context\n\nJoker input arguments: [^go.std.context/Context parent, ^<protocol-or-something> key, ^<protocol-or-something> val]\n\nJoker return type: go.std.context/Context"
;;   {:added "1.0"
;;    :go "__withValue(*_parent, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^context/Context _parent, ^<protocol-or-something> _key, ^<protocol-or-something> _val])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the context package."
    :empty false}
  go.std.context)
JOKER FUNC crypto.RegisterHash from crypto/crypto.go:
;; (defn RegisterHash
;;   "RegisterHash registers a function that returns a new instance of the given\nhash function. This is intended to be called from the init function in\npackages that implement hash functions.\n\nGo input arguments: (h Hash, f func)\n\nJoker input arguments: [^go.std.crypto/Hash h, ^fn f]"
;;   {:added "1.0"
;;    :go "__registerHash(*_h, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^crypto/Hash _h, ^fn _f])

JOKER FUNC crypto/aes.NewCipher from crypto/aes/cipher.go:
;; (defn NewCipher
;;   "NewCipher creates and returns a new cipher.Block.\nThe key argument should be the AES key,\neither 16, 24, or 32 bytes to select\nAES-128, AES-192, or AES-256.\n\nGo input arguments: (key []byte)\n\nGo return type: (crypto/cipher.Block, error)\n\nJoker input arguments: [^(vector-of Byte) key]\n\nJoker return type: [go.std.crypto.cipher/Block Error]"
;;   {:added "1.0"
;;    :go "__newCipher(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_key)))"}
;;   [^Object _key])

JOKER TYPE crypto/cipher.AEAD from crypto/cipher/gcm.go:
;; (defn ^"GoObject" AEAD.
;;   "Constructor for cipher.AEAD"
;;   {:added "1.0"
;;    :go "_ConstructAEAD(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/cipher.Block from crypto/cipher/cipher.go:
;; (defn ^"GoObject" Block.
;;   "Constructor for cipher.Block"
;;   {:added "1.0"
;;    :go "_ConstructBlock(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/cipher.BlockMode from crypto/cipher/cipher.go:
;; (defn ^"GoObject" BlockMode.
;;   "Constructor for cipher.BlockMode"
;;   {:added "1.0"
;;    :go "_ConstructBlockMode(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/cipher.Stream from crypto/cipher/cipher.go:
;; (defn ^"GoObject" Stream.
;;   "Constructor for cipher.Stream"
;;   {:added "1.0"
;;    :go "_ConstructStream(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/cipher.StreamReader from crypto/cipher/io.go:
(defn ^"GoObject" StreamReader.
  "Constructor for cipher.StreamReader"
  {:added "1.0"
   :go "_ConstructStreamReader(_v)"}
  [^Object _v])

JOKER TYPE crypto/cipher.StreamWriter from crypto/cipher/io.go:
(defn ^"GoObject" StreamWriter.
  "Constructor for cipher.StreamWriter"
  {:added "1.0"
   :go "_ConstructStreamWriter(_v)"}
  [^Object _v])

JOKER FUNC crypto/cipher.NewCBCDecrypter from crypto/cipher/cbc.go:
;; (defn NewCBCDecrypter
;;   "NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining\nmode, using the given Block. The length of iv must be the same as the\nBlock's block size and must match the iv used to encrypt the data.\n\nGo input arguments: (b Block, iv []byte)\n\nGo return type: BlockMode\n\nJoker input arguments: [^go.std.crypto.cipher/Block b, ^(vector-of Byte) iv]\n\nJoker return type: go.std.crypto.cipher/BlockMode"
;;   {:added "1.0"
;;    :go "__newCBCDecrypter(*_b, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_iv)))"}
;;   [^cipher/Block _b, ^Object _iv])

JOKER FUNC crypto/cipher.NewCBCEncrypter from crypto/cipher/cbc.go:
;; (defn NewCBCEncrypter
;;   "NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining\nmode, using the given Block. The length of iv must be the same as the\nBlock's block size.\n\nGo input arguments: (b Block, iv []byte)\n\nGo return type: BlockMode\n\nJoker input arguments: [^go.std.crypto.cipher/Block b, ^(vector-of Byte) iv]\n\nJoker return type: go.std.crypto.cipher/BlockMode"
;;   {:added "1.0"
;;    :go "__newCBCEncrypter(*_b, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_iv)))"}
;;   [^cipher/Block _b, ^Object _iv])

JOKER FUNC crypto/cipher.NewCFBDecrypter from crypto/cipher/cfb.go:
;; (defn NewCFBDecrypter
;;   "NewCFBDecrypter returns a Stream which decrypts with cipher feedback mode,\nusing the given Block. The iv must be the same length as the Block's block\nsize.\n\nGo input arguments: (block Block, iv []byte)\n\nGo return type: Stream\n\nJoker input arguments: [^go.std.crypto.cipher/Block block, ^(vector-of Byte) iv]\n\nJoker return type: go.std.crypto.cipher/Stream"
;;   {:added "1.0"
;;    :go "__newCFBDecrypter(*_block, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_iv)))"}
;;   [^cipher/Block _block, ^Object _iv])

JOKER FUNC crypto/cipher.NewCFBEncrypter from crypto/cipher/cfb.go:
;; (defn NewCFBEncrypter
;;   "NewCFBEncrypter returns a Stream which encrypts with cipher feedback mode,\nusing the given Block. The iv must be the same length as the Block's block\nsize.\n\nGo input arguments: (block Block, iv []byte)\n\nGo return type: Stream\n\nJoker input arguments: [^go.std.crypto.cipher/Block block, ^(vector-of Byte) iv]\n\nJoker return type: go.std.crypto.cipher/Stream"
;;   {:added "1.0"
;;    :go "__newCFBEncrypter(*_block, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_iv)))"}
;;   [^cipher/Block _block, ^Object _iv])

JOKER FUNC crypto/cipher.NewCTR from crypto/cipher/ctr.go:
;; (defn NewCTR
;;   "NewCTR returns a Stream which encrypts/decrypts using the given Block in\ncounter mode. The length of iv must be the same as the Block's block size.\n\nGo input arguments: (block Block, iv []byte)\n\nGo return type: Stream\n\nJoker input arguments: [^go.std.crypto.cipher/Block block, ^(vector-of Byte) iv]\n\nJoker return type: go.std.crypto.cipher/Stream"
;;   {:added "1.0"
;;    :go "__newCTR(*_block, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_iv)))"}
;;   [^cipher/Block _block, ^Object _iv])

JOKER FUNC crypto/cipher.NewGCM from crypto/cipher/gcm.go:
(defn NewGCM
  "NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode\nwith the standard nonce length.\n\nIn general, the GHASH operation performed by this implementation of GCM is not constant-time.\nAn exception is when the underlying Block was created by aes.NewCipher\non systems with hardware support for AES. See the crypto/aes package documentation for details.\n\nGo input arguments: (cipher Block)\n\nGo return type: (AEAD, error)\n\nJoker input arguments: [^go.std.crypto.cipher/Block cipher]\n\nJoker return type: [go.std.crypto.cipher/AEAD Error]"
  {:added "1.0"
   :go "__newGCM(*_cipher)"}
  [^cipher/Block _cipher])

JOKER FUNC crypto/cipher.NewGCMWithNonceSize from crypto/cipher/gcm.go:
(defn NewGCMWithNonceSize
  "NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois\nCounter Mode, which accepts nonces of the given length.\n\nOnly use this function if you require compatibility with an existing\ncryptosystem that uses non-standard nonce lengths. All other users should use\nNewGCM, which is faster and more resistant to misuse.\n\nGo input arguments: (cipher Block, size int)\n\nGo return type: (AEAD, error)\n\nJoker input arguments: [^go.std.crypto.cipher/Block cipher, ^Int size]\n\nJoker return type: [go.std.crypto.cipher/AEAD Error]"
  {:added "1.0"
   :go "__newGCMWithNonceSize(*_cipher, _size)"}
  [^cipher/Block _cipher, ^Int _size])

JOKER FUNC crypto/cipher.NewGCMWithTagSize from crypto/cipher/gcm.go:
(defn NewGCMWithTagSize
  "NewGCMWithTagSize returns the given 128-bit, block cipher wrapped in Galois\nCounter Mode, which generates tags with the given length.\n\nTag sizes between 12 and 16 bytes are allowed.\n\nOnly use this function if you require compatibility with an existing\ncryptosystem that uses non-standard tag lengths. All other users should use\nNewGCM, which is more resistant to misuse.\n\nGo input arguments: (cipher Block, tagSize int)\n\nGo return type: (AEAD, error)\n\nJoker input arguments: [^go.std.crypto.cipher/Block cipher, ^Int tagSize]\n\nJoker return type: [go.std.crypto.cipher/AEAD Error]"
  {:added "1.0"
   :go "__newGCMWithTagSize(*_cipher, _tagSize)"}
  [^cipher/Block _cipher, ^Int _tagSize])

JOKER FUNC crypto/cipher.NewOFB from crypto/cipher/ofb.go:
;; (defn NewOFB
;;   "NewOFB returns a Stream that encrypts or decrypts using the block cipher b\nin output feedback mode. The initialization vector iv's length must be equal\nto b's block size.\n\nGo input arguments: (b Block, iv []byte)\n\nGo return type: Stream\n\nJoker input arguments: [^go.std.crypto.cipher/Block b, ^(vector-of Byte) iv]\n\nJoker return type: go.std.crypto.cipher/Stream"
;;   {:added "1.0"
;;    :go "__newOFB(*_b, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_iv)))"}
;;   [^cipher/Block _b, ^Object _iv])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/cipher package."
    :empty false}
  go.std.crypto.cipher)
JOKER FUNC crypto/des.NewCipher from crypto/des/cipher.go:
;; (defn NewCipher
;;   "NewCipher creates and returns a new cipher.Block.\n\nGo input arguments: (key []byte)\n\nGo return type: (crypto/cipher.Block, error)\n\nJoker input arguments: [^(vector-of Byte) key]\n\nJoker return type: [go.std.crypto.cipher/Block Error]"
;;   {:added "1.0"
;;    :go "__newCipher(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_key)))"}
;;   [^Object _key])

JOKER FUNC crypto/des.NewTripleDESCipher from crypto/des/cipher.go:
;; (defn NewTripleDESCipher
;;   "NewTripleDESCipher creates and returns a new cipher.Block.\n\nGo input arguments: (key []byte)\n\nGo return type: (crypto/cipher.Block, error)\n\nJoker input arguments: [^(vector-of Byte) key]\n\nJoker return type: [go.std.crypto.cipher/Block Error]"
;;   {:added "1.0"
;;    :go "__newTripleDESCipher(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_key)))"}
;;   [^Object _key])

JOKER FUNC crypto/dsa.GenerateKey from crypto/dsa/dsa.go:
;; (defn ^"Error" GenerateKey
;;   "GenerateKey generates a public&private key pair. The Parameters of the\nPrivateKey must already be valid (see GenerateParameters).\n\nGo input arguments: (priv *PrivateKey, rand io.Reader)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.crypto.dsa/PrivateKey) priv, ^go.std.io/Reader rand]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "dsa.GenerateKey(_priv, *_rand)"}
;;   [^dsa/PrivateKey _priv, ^io/Reader _rand])

JOKER FUNC crypto/dsa.GenerateParameters from crypto/dsa/dsa.go:
;; (defn ^"Error" GenerateParameters
;;   "GenerateParameters puts a random, valid set of DSA parameters into params.\nThis function can take many seconds, even on fast machines.\n\nGo input arguments: (params *Parameters, rand io.Reader, sizes ParameterSizes)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.crypto.dsa/Parameters) params, ^go.std.io/Reader rand, ^go.std.crypto.dsa/ParameterSizes sizes]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "dsa.GenerateParameters(_params, *_rand, *_sizes)"}
;;   [^dsa/Parameters _params, ^io/Reader _rand, ^dsa/ParameterSizes _sizes])

JOKER FUNC crypto/dsa.Sign from crypto/dsa/dsa.go:
;; (defn Sign
;;   "Sign signs an arbitrary length hash (which should be the result of hashing a\nlarger message) using the private key, priv. It returns the signature as a\npair of integers. The security of the private key depends on the entropy of\nrand.\n\nNote that FIPS 186-3 section 4.6 specifies that the hash should be truncated\nto the byte-length of the subgroup. This function does not perform that\ntruncation itself.\n\nBe aware that calling Sign with an attacker-controlled PrivateKey may\nrequire an arbitrary amount of CPU.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, hash []byte)\n\nGo return type: (r *math/big.Int, s *math/big.Int, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.dsa/PrivateKey) priv, ^(vector-of Byte) hash]\n\nJoker return type: [(atom-of go.std.math.big/Int) (atom-of go.std.math.big/Int) Error]"
;;   {:added "1.0"
;;    :go "__sign(*_rand, _priv, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_hash)))"}
;;   [^io/Reader _rand, ^dsa/PrivateKey _priv, ^Object _hash])

JOKER FUNC crypto/dsa.Verify from crypto/dsa/dsa.go:
;; (defn ^"Boolean" Verify
;;   "Verify verifies the signature in r, s of hash using the public key, pub. It\nreports whether the signature is valid.\n\nNote that FIPS 186-3 section 4.6 specifies that the hash should be truncated\nto the byte-length of the subgroup. This function does not perform that\ntruncation itself.\n\nGo input arguments: (pub *PublicKey, hash []byte, r *big.Int, s *big.Int)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.crypto.dsa/PublicKey) pub, ^(vector-of Byte) hash, ^(atom-of go.std.math.big/Int) r, ^(atom-of go.std.math.big/Int) s]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "dsa.Verify(_pub, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_hash)), _r, _s)"}
;;   [^dsa/PublicKey _pub, ^Object _hash, ^big/Int _r, ^big/Int _s])

JOKER FUNC crypto/ecdsa.GenerateKey from crypto/ecdsa/ecdsa.go:
;; (defn GenerateKey
;;   "GenerateKey generates a public and private key pair.\n\nGo input arguments: (c elliptic.Curve, rand io.Reader)\n\nGo return type: (*PrivateKey, error)\n\nJoker input arguments: [^go.std.crypto.elliptic/Curve c, ^go.std.io/Reader rand]\n\nJoker return type: [(atom-of go.std.crypto.ecdsa/PrivateKey) Error]"
;;   {:added "1.0"
;;    :go "__generateKey(*_c, *_rand)"}
;;   [^elliptic/Curve _c, ^io/Reader _rand])

JOKER FUNC crypto/ecdsa.Sign from crypto/ecdsa/ecdsa.go:
;; (defn Sign
;;   "Sign signs a hash (which should be the result of hashing a larger message)\nusing the private key, priv. If the hash is longer than the bit-length of the\nprivate key's curve order, the hash will be truncated to that length.  It\nreturns the signature as a pair of integers. The security of the private key\ndepends on the entropy of rand.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, hash []byte)\n\nGo return type: (r *math/big.Int, s *math/big.Int, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.ecdsa/PrivateKey) priv, ^(vector-of Byte) hash]\n\nJoker return type: [(atom-of go.std.math.big/Int) (atom-of go.std.math.big/Int) Error]"
;;   {:added "1.0"
;;    :go "__sign(*_rand, _priv, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_hash)))"}
;;   [^io/Reader _rand, ^ecdsa/PrivateKey _priv, ^Object _hash])

JOKER FUNC crypto/ecdsa.Verify from crypto/ecdsa/ecdsa.go:
;; (defn ^"Boolean" Verify
;;   "Verify verifies the signature in r, s of hash using the public key, pub. Its\nreturn value records whether the signature is valid.\n\nGo input arguments: (pub *PublicKey, hash []byte, r *big.Int, s *big.Int)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.crypto.ecdsa/PublicKey) pub, ^(vector-of Byte) hash, ^(atom-of go.std.math.big/Int) r, ^(atom-of go.std.math.big/Int) s]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "ecdsa.Verify(_pub, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_hash)), _r, _s)"}
;;   [^ecdsa/PublicKey _pub, ^Object _hash, ^big/Int _r, ^big/Int _s])

JOKER TYPE crypto/elliptic.Curve from crypto/elliptic/elliptic.go:
;; (defn ^"GoObject" Curve.
;;   "Constructor for elliptic.Curve"
;;   {:added "1.0"
;;    :go "_ConstructCurve(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/elliptic.CurveParams from crypto/elliptic/elliptic.go:
(defn ^"GoObject" CurveParams.
  "Constructor for elliptic.CurveParams"
  {:added "1.0"
   :go "_ConstructCurveParams(_v)"}
  [^Object _v])

JOKER FUNC crypto/elliptic.GenerateKey from crypto/elliptic/elliptic.go:
;; (defn GenerateKey
;;   "GenerateKey returns a public/private key pair. The private key is\ngenerated using the given reader, which must return random data.\n\nGo input arguments: (curve Curve, rand io.Reader)\n\nGo return type: (priv []byte, x *math/big.Int, y *math/big.Int, err error)\n\nJoker input arguments: [^go.std.crypto.elliptic/Curve curve, ^go.std.io/Reader rand]\n\nJoker return type: [(vector-of Int) (atom-of go.std.math.big/Int) (atom-of go.std.math.big/Int) Error]"
;;   {:added "1.0"
;;    :go "__generateKey(*_curve, *_rand)"}
;;   [^elliptic/Curve _curve, ^io/Reader _rand])

JOKER FUNC crypto/elliptic.Marshal from crypto/elliptic/elliptic.go:
;; (defn Marshal
;;   "Marshal converts a point into the uncompressed form specified in section 4.3.6 of ANSI X9.62.\n\nGo input arguments: (curve Curve, x *big.Int, y *big.Int)\n\nGo return type: []byte\n\nJoker input arguments: [^go.std.crypto.elliptic/Curve curve, ^(atom-of go.std.math.big/Int) x, ^(atom-of go.std.math.big/Int) y]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__marshal(*_curve, _x, _y)"}
;;   [^elliptic/Curve _curve, ^big/Int _x, ^big/Int _y])

JOKER FUNC crypto/elliptic.P224 from crypto/elliptic/p224.go:
(defn P224
  "P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2).\n\nThe cryptographic operations are implemented using constant-time algorithms.\n\nGo return type: Curve\n\nJoker input arguments: []\n\nJoker return type: go.std.crypto.elliptic/Curve"
  {:added "1.0"
   :go "__p224()"}
  [])

JOKER FUNC crypto/elliptic.P256 from crypto/elliptic/elliptic.go:
(defn P256
  "P256 returns a Curve which implements P-256 (see FIPS 186-3, section D.2.3)\n\nThe cryptographic operations are implemented using constant-time algorithms.\n\nGo return type: Curve\n\nJoker input arguments: []\n\nJoker return type: go.std.crypto.elliptic/Curve"
  {:added "1.0"
   :go "__p256()"}
  [])

JOKER FUNC crypto/elliptic.P384 from crypto/elliptic/elliptic.go:
(defn P384
  "P384 returns a Curve which implements P-384 (see FIPS 186-3, section D.2.4)\n\nThe cryptographic operations do not use constant-time algorithms.\n\nGo return type: Curve\n\nJoker input arguments: []\n\nJoker return type: go.std.crypto.elliptic/Curve"
  {:added "1.0"
   :go "__p384()"}
  [])

JOKER FUNC crypto/elliptic.P521 from crypto/elliptic/elliptic.go:
(defn P521
  "P521 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5)\n\nThe cryptographic operations do not use constant-time algorithms.\n\nGo return type: Curve\n\nJoker input arguments: []\n\nJoker return type: go.std.crypto.elliptic/Curve"
  {:added "1.0"
   :go "__p521()"}
  [])

JOKER FUNC crypto/elliptic.Unmarshal from crypto/elliptic/elliptic.go:
;; (defn Unmarshal
;;   "Unmarshal converts a point, serialized by Marshal, into an x, y pair.\nIt is an error if the point is not in uncompressed form or is not on the curve.\nOn error, x = nil.\n\nGo input arguments: (curve Curve, data []byte)\n\nGo return type: (x *math/big.Int, y *math/big.Int)\n\nJoker input arguments: [^go.std.crypto.elliptic/Curve curve, ^(vector-of Byte) data]\n\nJoker return type: [(atom-of go.std.math.big/Int) (atom-of go.std.math.big/Int)]"
;;   {:added "1.0"
;;    :go "__unmarshal(*_curve, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^elliptic/Curve _curve, ^Object _data])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/elliptic package."
    :empty false}
  go.std.crypto.elliptic)
JOKER FUNC crypto/hmac.Equal from crypto/hmac/hmac.go:
;; (defn ^"Boolean" Equal
;;   "Equal compares two MACs for equality without leaking timing information.\n\nGo input arguments: (mac1 []byte, mac2 []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) mac1, ^(vector-of Byte) mac2]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "hmac.Equal(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_mac1)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_mac2)))"}
;;   [^Object _mac1, ^Object _mac2])

JOKER FUNC crypto/hmac.New from crypto/hmac/hmac.go:
;; (defn New
;;   "New returns a new HMAC hash using the given hash.Hash type and key.\nNote that unlike other hash implementations in the standard library,\nthe returned Hash does not implement encoding.BinaryMarshaler\nor encoding.BinaryUnmarshaler.\n\nGo input arguments: (h func, key []byte)\n\nGo return type: hash.Hash\n\nJoker input arguments: [^fn h, ^(vector-of Byte) key]\n\nJoker return type: go.std.hash/Hash"
;;   {:added "1.0"
;;    :go "__new(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_key)))"}
;;   [^fn _h, ^Object _key])

JOKER FUNC crypto/md5.New from crypto/md5/md5.go:
(defn New
  "New returns a new hash.Hash computing the MD5 checksum. The Hash also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new()"}
  [])

JOKER FUNC crypto/md5.Sum from crypto/md5/md5.go:
;; (defn Sum
;;   "Sum returns the MD5 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/md5 package."
    :empty false}
  go.std.crypto.md5)
JOKER FUNC crypto/rand.Int from crypto/rand/util.go:
;; (defn Int
;;   "Int returns a uniform random value in [0, max). It panics if max <= 0.\n\nGo input arguments: (rand io.Reader, max *big.Int)\n\nGo return type: (n *math/big.Int, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.math.big/Int) max]\n\nJoker return type: [(atom-of go.std.math.big/Int) Error]"
;;   {:added "1.0"
;;    :go "__int(*_rand, _max)"}
;;   [^io/Reader _rand, ^big/Int _max])

JOKER FUNC crypto/rand.Prime from crypto/rand/util.go:
;; (defn Prime
;;   "Prime returns a number, p, of the given size, such that p is prime\nwith high probability.\nPrime will return error for any error returned by rand.Read or if bits < 2.\n\nGo input arguments: (rand io.Reader, bits int)\n\nGo return type: (p *math/big.Int, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^Int bits]\n\nJoker return type: [(atom-of go.std.math.big/Int) Error]"
;;   {:added "1.0"
;;    :go "__prime(*_rand, _bits)"}
;;   [^io/Reader _rand, ^Int _bits])

JOKER FUNC crypto/rand.Read from crypto/rand/rand.go:
;; (defn Read
;;   "Read is a helper function that calls Reader.Read using io.ReadFull.\nOn return, n == len(b) if and only if err == nil.\n\nGo input arguments: (b []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__read(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _b])

JOKER FUNC crypto/rc4.NewCipher from crypto/rc4/rc4.go:
;; (defn NewCipher
;;   "NewCipher creates and returns a new Cipher. The key argument should be the\nRC4 key, at least 1 byte and at most 256 bytes.\n\nGo input arguments: (key []byte)\n\nGo return type: (*Cipher, error)\n\nJoker input arguments: [^(vector-of Byte) key]\n\nJoker return type: [(atom-of go.std.crypto.rc4/Cipher) Error]"
;;   {:added "1.0"
;;    :go "__newCipher(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_key)))"}
;;   [^Object _key])

JOKER FUNC crypto/rsa.DecryptOAEP from crypto/rsa/rsa.go:
;; (defn DecryptOAEP
;;   "OAEP is parameterised by a hash function that is used as a random oracle.\nEncryption and decryption of a given message must use the same hash function\nand sha256.New() is a reasonable choice.\n\nThe random parameter, if not nil, is used to blind the private-key operation\nand avoid timing side-channel attacks. Blinding is purely internal to this\nfunction – the random data need not match that used when encrypting.\n\nThe label parameter must match the value given when encrypting. See\nEncryptOAEP for details.\n\nGo input arguments: (hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.hash/Hash hash, ^go.std.io/Reader random, ^(atom-of go.std.crypto.rsa/PrivateKey) priv, ^(vector-of Byte) ciphertext, ^(vector-of Byte) label]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__decryptOAEP(*_hash, *_random, _priv, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_ciphertext)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_label)))"}
;;   [^hash/Hash _hash, ^io/Reader _random, ^rsa/PrivateKey _priv, ^Object _ciphertext, ^Object _label])

JOKER FUNC crypto/rsa.DecryptPKCS1v15 from crypto/rsa/pkcs1v15.go:
;; (defn DecryptPKCS1v15
;;   "DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5.\nIf rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\n\nNote that whether this function returns an error or not discloses secret\ninformation. If an attacker can cause this function to run repeatedly and\nlearn whether each instance returned an error then they can decrypt and\nforge signatures as if they had the private key. See\nDecryptPKCS1v15SessionKey for a way of solving this problem.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, ciphertext []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.rsa/PrivateKey) priv, ^(vector-of Byte) ciphertext]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__decryptPKCS1v15(*_rand, _priv, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_ciphertext)))"}
;;   [^io/Reader _rand, ^rsa/PrivateKey _priv, ^Object _ciphertext])

JOKER FUNC crypto/rsa.DecryptPKCS1v15SessionKey from crypto/rsa/pkcs1v15.go:
;; (defn ^"Error" DecryptPKCS1v15SessionKey
;;   "DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding scheme from PKCS#1 v1.5.\nIf rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\nIt returns an error if the ciphertext is the wrong length or if the\nciphertext is greater than the public modulus. Otherwise, no error is\nreturned. If the padding is valid, the resulting plaintext message is copied\ninto key. Otherwise, key is unchanged. These alternatives occur in constant\ntime. It is intended that the user of this function generate a random\nsession key beforehand and continue the protocol with the resulting value.\nThis will remove any possibility that an attacker can learn any information\nabout the plaintext.\nSee ``Chosen Ciphertext Attacks Against Protocols Based on the RSA\nEncryption Standard PKCS #1'', Daniel Bleichenbacher, Advances in Cryptology\n(Crypto '98).\n\nNote that if the session key is too small then it may be possible for an\nattacker to brute-force it. If they can do that then they can learn whether\na random value was used (because it'll be different for the same ciphertext)\nand thus whether the padding was correct. This defeats the point of this\nfunction. Using at least a 16-byte key will protect against this attack.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, ciphertext []byte, key []byte)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.rsa/PrivateKey) priv, ^(vector-of Byte) ciphertext, ^(vector-of Byte) key]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rsa.DecryptPKCS1v15SessionKey(*_rand, _priv, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_ciphertext)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_key)))"}
;;   [^io/Reader _rand, ^rsa/PrivateKey _priv, ^Object _ciphertext, ^Object _key])

JOKER FUNC crypto/rsa.EncryptOAEP from crypto/rsa/rsa.go:
;; (defn EncryptOAEP
;;   "EncryptOAEP encrypts the given message with RSA-OAEP.\n\nOAEP is parameterised by a hash function that is used as a random oracle.\nEncryption and decryption of a given message must use the same hash function\nand sha256.New() is a reasonable choice.\n\nThe random parameter is used as a source of entropy to ensure that\nencrypting the same message twice doesn't result in the same ciphertext.\n\nThe label parameter may contain arbitrary data that will not be encrypted,\nbut which gives important context to the message. For example, if a given\npublic key is used to decrypt two types of messages then distinct label\nvalues could be used to ensure that a ciphertext for one purpose cannot be\nused for another by an attacker. If not required it can be empty.\n\nThe message must be no longer than the length of the public modulus minus\ntwice the hash length, minus a further 2.\n\nGo input arguments: (hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.hash/Hash hash, ^go.std.io/Reader random, ^(atom-of go.std.crypto.rsa/PublicKey) pub, ^(vector-of Byte) msg, ^(vector-of Byte) label]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__encryptOAEP(*_hash, *_random, _pub, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_msg)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_label)))"}
;;   [^hash/Hash _hash, ^io/Reader _random, ^rsa/PublicKey _pub, ^Object _msg, ^Object _label])

JOKER FUNC crypto/rsa.EncryptPKCS1v15 from crypto/rsa/pkcs1v15.go:
;; (defn EncryptPKCS1v15
;;   "EncryptPKCS1v15 encrypts the given message with RSA and the padding\nscheme from PKCS#1 v1.5.  The message must be no longer than the\nlength of the public modulus minus 11 bytes.\n\nThe rand parameter is used as a source of entropy to ensure that\nencrypting the same message twice doesn't result in the same\nciphertext.\n\nWARNING: use of this function to encrypt plaintexts other than\nsession keys is dangerous. Use RSA OAEP in new protocols.\n\nGo input arguments: (rand io.Reader, pub *PublicKey, msg []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.rsa/PublicKey) pub, ^(vector-of Byte) msg]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__encryptPKCS1v15(*_rand, _pub, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_msg)))"}
;;   [^io/Reader _rand, ^rsa/PublicKey _pub, ^Object _msg])

JOKER FUNC crypto/rsa.GenerateKey from crypto/rsa/rsa.go:
;; (defn GenerateKey
;;   "GenerateKey generates an RSA keypair of the given bit size using the\nrandom source random (for example, crypto/rand.Reader).\n\nGo input arguments: (random io.Reader, bits int)\n\nGo return type: (*PrivateKey, error)\n\nJoker input arguments: [^go.std.io/Reader random, ^Int bits]\n\nJoker return type: [(atom-of go.std.crypto.rsa/PrivateKey) Error]"
;;   {:added "1.0"
;;    :go "__generateKey(*_random, _bits)"}
;;   [^io/Reader _random, ^Int _bits])

JOKER FUNC crypto/rsa.GenerateMultiPrimeKey from crypto/rsa/rsa.go:
;; (defn GenerateMultiPrimeKey
;;   "GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit\nsize and the given random source, as suggested in [1]. Although the public\nkeys are compatible (actually, indistinguishable) from the 2-prime case,\nthe private keys are not. Thus it may not be possible to export multi-prime\nprivate keys in certain formats or to subsequently import them into other\ncode.\n\nTable 1 in [2] suggests maximum numbers of primes for a given size.\n\n[1] US patent 4405829 (1972, expired)\n[2] http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf\n\nGo input arguments: (random io.Reader, nprimes int, bits int)\n\nGo return type: (*PrivateKey, error)\n\nJoker input arguments: [^go.std.io/Reader random, ^Int nprimes, ^Int bits]\n\nJoker return type: [(atom-of go.std.crypto.rsa/PrivateKey) Error]"
;;   {:added "1.0"
;;    :go "__generateMultiPrimeKey(*_random, _nprimes, _bits)"}
;;   [^io/Reader _random, ^Int _nprimes, ^Int _bits])

JOKER FUNC crypto/rsa.SignPKCS1v15 from crypto/rsa/pkcs1v15.go:
;; (defn SignPKCS1v15
;;   "SignPKCS1v15 calculates the signature of hashed using\nRSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5.  Note that hashed must\nbe the result of hashing the input message using the given hash\nfunction. If hash is zero, hashed is signed directly. This isn't\nadvisable except for interoperability.\n\nIf rand is not nil then RSA blinding will be used to avoid timing\nside-channel attacks.\n\nThis function is deterministic. Thus, if the set of possible\nmessages is small, an attacker may be able to build a map from\nmessages to signatures and identify the signed messages. As ever,\nsignatures provide authenticity, not confidentiality.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.rsa/PrivateKey) priv, ^go.std.crypto/Hash hash, ^(vector-of Byte) hashed]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__signPKCS1v15(*_rand, _priv, *_hash, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_hashed)))"}
;;   [^io/Reader _rand, ^rsa/PrivateKey _priv, ^crypto/Hash _hash, ^Object _hashed])

JOKER FUNC crypto/rsa.SignPSS from crypto/rsa/pss.go:
;; (defn SignPSS
;;   "SignPSS calculates the signature of hashed using RSASSA-PSS [1].\nNote that hashed must be the result of hashing the input message using the\ngiven hash function. The opts argument may be nil, in which case sensible\ndefaults are used.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte, opts *PSSOptions)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.rsa/PrivateKey) priv, ^go.std.crypto/Hash hash, ^(vector-of Byte) hashed, ^(atom-of go.std.crypto.rsa/PSSOptions) opts]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__signPSS(*_rand, _priv, *_hash, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_hashed)), _opts)"}
;;   [^io/Reader _rand, ^rsa/PrivateKey _priv, ^crypto/Hash _hash, ^Object _hashed, ^rsa/PSSOptions _opts])

JOKER FUNC crypto/rsa.VerifyPKCS1v15 from crypto/rsa/pkcs1v15.go:
;; (defn ^"Error" VerifyPKCS1v15
;;   "VerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature.\nhashed is the result of hashing the input message using the given hash\nfunction and sig is the signature. A valid signature is indicated by\nreturning a nil error. If hash is zero then hashed is used directly. This\nisn't advisable except for interoperability.\n\nGo input arguments: (pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.crypto.rsa/PublicKey) pub, ^go.std.crypto/Hash hash, ^(vector-of Byte) hashed, ^(vector-of Byte) sig]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rsa.VerifyPKCS1v15(_pub, *_hash, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_hashed)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_sig)))"}
;;   [^rsa/PublicKey _pub, ^crypto/Hash _hash, ^Object _hashed, ^Object _sig])

JOKER FUNC crypto/rsa.VerifyPSS from crypto/rsa/pss.go:
;; (defn ^"Error" VerifyPSS
;;   "VerifyPSS verifies a PSS signature.\nhashed is the result of hashing the input message using the given hash\nfunction and sig is the signature. A valid signature is indicated by\nreturning a nil error. The opts argument may be nil, in which case sensible\ndefaults are used.\n\nGo input arguments: (pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte, opts *PSSOptions)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.crypto.rsa/PublicKey) pub, ^go.std.crypto/Hash hash, ^(vector-of Byte) hashed, ^(vector-of Byte) sig, ^(atom-of go.std.crypto.rsa/PSSOptions) opts]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rsa.VerifyPSS(_pub, *_hash, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_hashed)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_sig)), _opts)"}
;;   [^rsa/PublicKey _pub, ^crypto/Hash _hash, ^Object _hashed, ^Object _sig, ^rsa/PSSOptions _opts])

JOKER FUNC crypto/sha1.New from crypto/sha1/sha1.go:
(defn New
  "New returns a new hash.Hash computing the SHA1 checksum. The Hash also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new()"}
  [])

JOKER FUNC crypto/sha1.Sum from crypto/sha1/sha1.go:
;; (defn Sum
;;   "Sum returns the SHA-1 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/sha1 package."
    :empty false}
  go.std.crypto.sha1)
JOKER FUNC crypto/sha256.New from crypto/sha256/sha256.go:
(defn New
  "New returns a new hash.Hash computing the SHA256 checksum. The Hash\nalso implements encoding.BinaryMarshaler and\nencoding.BinaryUnmarshaler to marshal and unmarshal the internal\nstate of the hash.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new()"}
  [])

JOKER FUNC crypto/sha256.New224 from crypto/sha256/sha256.go:
(defn New224
  "New224 returns a new hash.Hash computing the SHA224 checksum.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new224()"}
  [])

JOKER FUNC crypto/sha256.Sum224 from crypto/sha256/sha256.go:
;; (defn Sum224
;;   "Sum224 returns the SHA224 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum224(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC crypto/sha256.Sum256 from crypto/sha256/sha256.go:
;; (defn Sum256
;;   "Sum256 returns the SHA256 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum256(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/sha256 package."
    :empty false}
  go.std.crypto.sha256)
JOKER FUNC crypto/sha512.New from crypto/sha512/sha512.go:
(defn New
  "New returns a new hash.Hash computing the SHA-512 checksum.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new()"}
  [])

JOKER FUNC crypto/sha512.New384 from crypto/sha512/sha512.go:
(defn New384
  "New384 returns a new hash.Hash computing the SHA-384 checksum.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new384()"}
  [])

JOKER FUNC crypto/sha512.New512_224 from crypto/sha512/sha512.go:
(defn New512_224
  "New512_224 returns a new hash.Hash computing the SHA-512/224 checksum.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new512_224()"}
  [])

JOKER FUNC crypto/sha512.New512_256 from crypto/sha512/sha512.go:
(defn New512_256
  "New512_256 returns a new hash.Hash computing the SHA-512/256 checksum.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new512_256()"}
  [])

JOKER FUNC crypto/sha512.Sum384 from crypto/sha512/sha512.go:
;; (defn Sum384
;;   "Sum384 returns the SHA384 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum384(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC crypto/sha512.Sum512 from crypto/sha512/sha512.go:
;; (defn Sum512
;;   "Sum512 returns the SHA512 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum512(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC crypto/sha512.Sum512_224 from crypto/sha512/sha512.go:
;; (defn Sum512_224
;;   "Sum512_224 returns the Sum512/224 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum512_224(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC crypto/sha512.Sum512_256 from crypto/sha512/sha512.go:
;; (defn Sum512_256
;;   "Sum512_256 returns the Sum512/256 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum512_256(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/sha512 package."
    :empty false}
  go.std.crypto.sha512)
JOKER FUNC crypto/subtle.ConstantTimeByteEq from crypto/subtle/constant_time.go:
;; (defn ^"Int" ConstantTimeByteEq
;;   "ConstantTimeByteEq returns 1 if x == y and 0 otherwise.\n\nGo input arguments: (x uint8, y uint8)\n\nGo return type: int\n\nJoker input arguments: [^uint8 x, ^uint8 y]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "subtle.ConstantTimeByteEq(_x, _y)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint8) _x, ^ABEND044(pre.go: unsupported built-in type uint8) _y])

JOKER FUNC crypto/subtle.ConstantTimeCompare from crypto/subtle/constant_time.go:
;; (defn ^"Int" ConstantTimeCompare
;;   "ConstantTimeCompare returns 1 if and only if the two slices, x\nand y, have equal contents. The time taken is a function of the length of\nthe slices and is independent of the contents.\n\nGo input arguments: (x []byte, y []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) x, ^(vector-of Byte) y]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "subtle.ConstantTimeCompare(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_x)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_y)))"}
;;   [^Object _x, ^Object _y])

JOKER FUNC crypto/subtle.ConstantTimeCopy from crypto/subtle/constant_time.go:
;; (defn ConstantTimeCopy
;;   "ConstantTimeCopy copies the contents of y into x (a slice of equal length)\nif v == 1. If v == 0, x is left unchanged. Its behavior is undefined if v\ntakes any other value.\n\nGo input arguments: (v int, x []byte, y []byte)\n\nJoker input arguments: [^Int v, ^(vector-of Byte) x, ^(vector-of Byte) y]"
;;   {:added "1.0"
;;    :go "__constantTimeCopy(_v, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_x)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_y)))"}
;;   [^Int _v, ^Object _x, ^Object _y])

JOKER FUNC crypto/subtle.ConstantTimeEq from crypto/subtle/constant_time.go:
(defn ^"Int" ConstantTimeEq
  "ConstantTimeEq returns 1 if x == y and 0 otherwise.\n\nGo input arguments: (x int32, y int32)\n\nGo return type: int\n\nJoker input arguments: [^Int32 x, ^Int32 y]\n\nJoker return type: Int"
  {:added "1.0"
   :go "subtle.ConstantTimeEq(_x, _y)"}
  [^Int32 _x, ^Int32 _y])

JOKER FUNC crypto/subtle.ConstantTimeLessOrEq from crypto/subtle/constant_time.go:
(defn ^"Int" ConstantTimeLessOrEq
  "ConstantTimeLessOrEq returns 1 if x <= y and 0 otherwise.\nIts behavior is undefined if x or y are negative or > 2**31 - 1.\n\nGo input arguments: (x int, y int)\n\nGo return type: int\n\nJoker input arguments: [^Int x, ^Int y]\n\nJoker return type: Int"
  {:added "1.0"
   :go "subtle.ConstantTimeLessOrEq(_x, _y)"}
  [^Int _x, ^Int _y])

JOKER FUNC crypto/subtle.ConstantTimeSelect from crypto/subtle/constant_time.go:
(defn ^"Int" ConstantTimeSelect
  "ConstantTimeSelect returns x if v is 1 and y if v is 0.\nIts behavior is undefined if v takes any other value.\n\nGo input arguments: (v int, x int, y int)\n\nGo return type: int\n\nJoker input arguments: [^Int v, ^Int x, ^Int y]\n\nJoker return type: Int"
  {:added "1.0"
   :go "subtle.ConstantTimeSelect(_v, _x, _y)"}
  [^Int _v, ^Int _x, ^Int _y])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["crypto/subtle"]
    :doc "Provides a low-level interface to the crypto/subtle package."
    :empty false}
  go.std.crypto.subtle)
JOKER TYPE crypto/tls.Certificate from crypto/tls/common.go:
(defn ^"GoObject" Certificate.
  "Constructor for tls.Certificate"
  {:added "1.0"
   :go "_ConstructCertificate(_v)"}
  [^Object _v])

JOKER TYPE crypto/tls.CertificateRequestInfo from crypto/tls/common.go:
(defn ^"GoObject" CertificateRequestInfo.
  "Constructor for tls.CertificateRequestInfo"
  {:added "1.0"
   :go "_ConstructCertificateRequestInfo(_v)"}
  [^Object _v])

JOKER TYPE crypto/tls.ClientAuthType from crypto/tls/common.go:
(defn ^"GoObject" ClientAuthType.
  "Constructor for tls.ClientAuthType"
  {:added "1.0"
   :go "_ConstructClientAuthType(_v)"}
  [^Object _v])

JOKER TYPE crypto/tls.ClientHelloInfo from crypto/tls/common.go:
(defn ^"GoObject" ClientHelloInfo.
  "Constructor for tls.ClientHelloInfo"
  {:added "1.0"
   :go "_ConstructClientHelloInfo(_v)"}
  [^Object _v])

JOKER TYPE crypto/tls.ClientSessionCache from crypto/tls/common.go:
;; (defn ^"GoObject" ClientSessionCache.
;;   "Constructor for tls.ClientSessionCache"
;;   {:added "1.0"
;;    :go "_ConstructClientSessionCache(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/tls.ClientSessionState from crypto/tls/common.go:
(defn ^"GoObject" ClientSessionState.
  "Constructor for tls.ClientSessionState"
  {:added "1.0"
   :go "_ConstructClientSessionState(_v)"}
  [^Object _v])

JOKER TYPE crypto/tls.Config from crypto/tls/common.go:
(defn ^"GoObject" Config.
  "Constructor for tls.Config"
  {:added "1.0"
   :go "_ConstructConfig(_v)"}
  [^Object _v])

JOKER TYPE crypto/tls.Conn from crypto/tls/conn.go:
(defn ^"GoObject" Conn.
  "Constructor for tls.Conn"
  {:added "1.0"
   :go "_ConstructConn(_v)"}
  [^Object _v])

JOKER TYPE crypto/tls.ConnectionState from crypto/tls/common.go:
(defn ^"GoObject" ConnectionState.
  "Constructor for tls.ConnectionState"
  {:added "1.0"
   :go "_ConstructConnectionState(_v)"}
  [^Object _v])

JOKER TYPE crypto/tls.CurveID from crypto/tls/common.go:
;; (defn ^"GoObject" CurveID.
;;   "Constructor for tls.CurveID"
;;   {:added "1.0"
;;    :go "_ConstructCurveID(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/tls.RecordHeaderError from crypto/tls/conn.go:
(defn ^"GoObject" RecordHeaderError.
  "Constructor for tls.RecordHeaderError"
  {:added "1.0"
   :go "_ConstructRecordHeaderError(_v)"}
  [^Object _v])

JOKER TYPE crypto/tls.RenegotiationSupport from crypto/tls/common.go:
(defn ^"GoObject" RenegotiationSupport.
  "Constructor for tls.RenegotiationSupport"
  {:added "1.0"
   :go "_ConstructRenegotiationSupport(_v)"}
  [^Object _v])

JOKER TYPE crypto/tls.SignatureScheme from crypto/tls/common.go:
;; (defn ^"GoObject" SignatureScheme.
;;   "Constructor for tls.SignatureScheme"
;;   {:added "1.0"
;;    :go "_ConstructSignatureScheme(_v)"}
;;   [^Object _v])

JOKER FUNC crypto/tls.Client from crypto/tls/tls.go:
;; (defn Client
;;   "Client returns a new TLS client side connection\nusing conn as the underlying transport.\nThe config cannot be nil: users must set either ServerName or\nInsecureSkipVerify in the config.\n\nGo input arguments: (conn net.Conn, config *Config)\n\nGo return type: *Conn\n\nJoker input arguments: [^go.std.net/Conn conn, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: (atom-of go.std.crypto.tls/Conn)"
;;   {:added "1.0"
;;    :go "__client(*_conn, _config)"}
;;   [^net/Conn _conn, ^tls/Config _config])

JOKER FUNC crypto/tls.Dial from crypto/tls/tls.go:
(defn Dial
  "Dial connects to the given network address using net.Dial\nand then initiates a TLS handshake, returning the resulting\nTLS connection.\nDial interprets a nil configuration as equivalent to\nthe zero configuration; see the documentation of Config\nfor the defaults.\n\nGo input arguments: (network string, addr string, config *Config)\n\nGo return type: (*Conn, error)\n\nJoker input arguments: [^String network, ^String addr, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: [(atom-of go.std.crypto.tls/Conn) Error]"
  {:added "1.0"
   :go "__dial(_network, _addr, _config)"}
  [^String _network, ^String _addr, ^tls/Config _config])

JOKER FUNC crypto/tls.DialWithDialer from crypto/tls/tls.go:
;; (defn DialWithDialer
;;   "DialWithDialer connects to the given network address using dialer.Dial and\nthen initiates a TLS handshake, returning the resulting TLS connection. Any\ntimeout or deadline given in the dialer apply to connection and TLS\nhandshake as a whole.\n\nDialWithDialer interprets a nil configuration as equivalent to the zero\nconfiguration; see the documentation of Config for the defaults.\n\nGo input arguments: (dialer *net.Dialer, network string, addr string, config *Config)\n\nGo return type: (*Conn, error)\n\nJoker input arguments: [^(atom-of go.std.net/Dialer) dialer, ^String network, ^String addr, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: [(atom-of go.std.crypto.tls/Conn) Error]"
;;   {:added "1.0"
;;    :go "__dialWithDialer(_dialer, _network, _addr, _config)"}
;;   [^net/Dialer _dialer, ^String _network, ^String _addr, ^tls/Config _config])

JOKER FUNC crypto/tls.Listen from crypto/tls/tls.go:
(defn Listen
  "Listen creates a TLS listener accepting connections on the\ngiven network address using net.Listen.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\n\nGo input arguments: (network string, laddr string, config *Config)\n\nGo return type: (net.Listener, error)\n\nJoker input arguments: [^String network, ^String laddr, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: [go.std.net/Listener Error]"
  {:added "1.0"
   :go "__listen(_network, _laddr, _config)"}
  [^String _network, ^String _laddr, ^tls/Config _config])

JOKER FUNC crypto/tls.LoadX509KeyPair from crypto/tls/tls.go:
(defn LoadX509KeyPair
  "LoadX509KeyPair reads and parses a public/private key pair from a pair\nof files. The files must contain PEM encoded data. The certificate file\nmay contain intermediate certificates following the leaf certificate to\nform a certificate chain. On successful return, Certificate.Leaf will\nbe nil because the parsed form of the certificate is not retained.\n\nGo input arguments: (certFile string, keyFile string)\n\nGo return type: (Certificate, error)\n\nJoker input arguments: [^String certFile, ^String keyFile]\n\nJoker return type: [go.std.crypto.tls/Certificate Error]"
  {:added "1.0"
   :go "__loadX509KeyPair(_certFile, _keyFile)"}
  [^String _certFile, ^String _keyFile])

JOKER FUNC crypto/tls.NewLRUClientSessionCache from crypto/tls/common.go:
(defn NewLRUClientSessionCache
  "NewLRUClientSessionCache returns a ClientSessionCache with the given\ncapacity that uses an LRU strategy. If capacity is < 1, a default capacity\nis used instead.\n\nGo input arguments: (capacity int)\n\nGo return type: ClientSessionCache\n\nJoker input arguments: [^Int capacity]\n\nJoker return type: go.std.crypto.tls/ClientSessionCache"
  {:added "1.0"
   :go "__newLRUClientSessionCache(_capacity)"}
  [^Int _capacity])

JOKER FUNC crypto/tls.NewListener from crypto/tls/tls.go:
;; (defn NewListener
;;   "NewListener creates a Listener which accepts connections from an inner\nListener and wraps each connection with Server.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\n\nGo input arguments: (inner net.Listener, config *Config)\n\nGo return type: net.Listener\n\nJoker input arguments: [^go.std.net/Listener inner, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: go.std.net/Listener"
;;   {:added "1.0"
;;    :go "__newListener(*_inner, _config)"}
;;   [^net/Listener _inner, ^tls/Config _config])

JOKER FUNC crypto/tls.Server from crypto/tls/tls.go:
;; (defn Server
;;   "Server returns a new TLS server side connection\nusing conn as the underlying transport.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\n\nGo input arguments: (conn net.Conn, config *Config)\n\nGo return type: *Conn\n\nJoker input arguments: [^go.std.net/Conn conn, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: (atom-of go.std.crypto.tls/Conn)"
;;   {:added "1.0"
;;    :go "__server(*_conn, _config)"}
;;   [^net/Conn _conn, ^tls/Config _config])

JOKER FUNC crypto/tls.X509KeyPair from crypto/tls/tls.go:
;; (defn X509KeyPair
;;   "X509KeyPair parses a public/private key pair from a pair of\nPEM encoded data. On successful return, Certificate.Leaf will be nil because\nthe parsed form of the certificate is not retained.\n\nGo input arguments: (certPEMBlock []byte, keyPEMBlock []byte)\n\nGo return type: (Certificate, error)\n\nJoker input arguments: [^(vector-of Byte) certPEMBlock, ^(vector-of Byte) keyPEMBlock]\n\nJoker return type: [go.std.crypto.tls/Certificate Error]"
;;   {:added "1.0"
;;    :go "__x509KeyPair(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_certPEMBlock)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_keyPEMBlock)))"}
;;   [^Object _certPEMBlock, ^Object _keyPEMBlock])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/tls package."
    :empty false}
  go.std.crypto.tls)
JOKER TYPE crypto/x509.CertPool from crypto/x509/cert_pool.go:
(defn ^"GoObject" CertPool.
  "Constructor for x509.CertPool"
  {:added "1.0"
   :go "_ConstructCertPool(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.Certificate from crypto/x509/x509.go:
(defn ^"GoObject" Certificate.
  "Constructor for x509.Certificate"
  {:added "1.0"
   :go "_ConstructCertificate(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.CertificateInvalidError from crypto/x509/verify.go:
(defn ^"GoObject" CertificateInvalidError.
  "Constructor for x509.CertificateInvalidError"
  {:added "1.0"
   :go "_ConstructCertificateInvalidError(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.CertificateRequest from crypto/x509/x509.go:
(defn ^"GoObject" CertificateRequest.
  "Constructor for x509.CertificateRequest"
  {:added "1.0"
   :go "_ConstructCertificateRequest(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.ConstraintViolationError from crypto/x509/x509.go:
(defn ^"GoObject" ConstraintViolationError.
  "Constructor for x509.ConstraintViolationError"
  {:added "1.0"
   :go "_ConstructConstraintViolationError(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.ExtKeyUsage from crypto/x509/x509.go:
(defn ^"GoObject" ExtKeyUsage.
  "Constructor for x509.ExtKeyUsage"
  {:added "1.0"
   :go "_ConstructExtKeyUsage(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.HostnameError from crypto/x509/verify.go:
(defn ^"GoObject" HostnameError.
  "Constructor for x509.HostnameError"
  {:added "1.0"
   :go "_ConstructHostnameError(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.InsecureAlgorithmError from crypto/x509/x509.go:
;; (defn ^"GoObject" InsecureAlgorithmError.
;;   "Constructor for x509.InsecureAlgorithmError"
;;   {:added "1.0"
;;    :go "_ConstructInsecureAlgorithmError(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509.InvalidReason from crypto/x509/verify.go:
(defn ^"GoObject" InvalidReason.
  "Constructor for x509.InvalidReason"
  {:added "1.0"
   :go "_ConstructInvalidReason(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.KeyUsage from crypto/x509/x509.go:
(defn ^"GoObject" KeyUsage.
  "Constructor for x509.KeyUsage"
  {:added "1.0"
   :go "_ConstructKeyUsage(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.PEMCipher from crypto/x509/pem_decrypt.go:
(defn ^"GoObject" PEMCipher.
  "Constructor for x509.PEMCipher"
  {:added "1.0"
   :go "_ConstructPEMCipher(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.PublicKeyAlgorithm from crypto/x509/x509.go:
(defn ^"GoObject" PublicKeyAlgorithm.
  "Constructor for x509.PublicKeyAlgorithm"
  {:added "1.0"
   :go "_ConstructPublicKeyAlgorithm(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.SignatureAlgorithm from crypto/x509/x509.go:
(defn ^"GoObject" SignatureAlgorithm.
  "Constructor for x509.SignatureAlgorithm"
  {:added "1.0"
   :go "_ConstructSignatureAlgorithm(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.SystemRootsError from crypto/x509/verify.go:
(defn ^"GoObject" SystemRootsError.
  "Constructor for x509.SystemRootsError"
  {:added "1.0"
   :go "_ConstructSystemRootsError(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.UnhandledCriticalExtension from crypto/x509/x509.go:
(defn ^"GoObject" UnhandledCriticalExtension.
  "Constructor for x509.UnhandledCriticalExtension"
  {:added "1.0"
   :go "_ConstructUnhandledCriticalExtension(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.UnknownAuthorityError from crypto/x509/verify.go:
(defn ^"GoObject" UnknownAuthorityError.
  "Constructor for x509.UnknownAuthorityError"
  {:added "1.0"
   :go "_ConstructUnknownAuthorityError(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.VerifyOptions from crypto/x509/verify.go:
(defn ^"GoObject" VerifyOptions.
  "Constructor for x509.VerifyOptions"
  {:added "1.0"
   :go "_ConstructVerifyOptions(_v)"}
  [^Object _v])

JOKER FUNC crypto/x509.CreateCertificate from crypto/x509/x509.go:
;; (defn CreateCertificate
;;   "CreateCertificate creates a new X.509v3 certificate based on a template.\nThe following members of template are used:\n\n - AuthorityKeyId\n - BasicConstraintsValid\n - CRLDistributionPoints\n - DNSNames\n - EmailAddresses\n - ExcludedDNSDomains\n - ExcludedEmailAddresses\n - ExcludedIPRanges\n - ExcludedURIDomains\n - ExtKeyUsage\n - ExtraExtensions\n - IsCA\n - IssuingCertificateURL\n - KeyUsage\n - MaxPathLen\n - MaxPathLenZero\n - NotAfter\n - NotBefore\n - OCSPServer\n - PermittedDNSDomains\n - PermittedDNSDomainsCritical\n - PermittedEmailAddresses\n - PermittedIPRanges\n - PermittedURIDomains\n - PolicyIdentifiers\n - SerialNumber\n - SignatureAlgorithm\n - Subject\n - SubjectKeyId\n - URIs\n - UnknownExtKeyUsage\n\nThe certificate is signed by parent. If parent is equal to template then the\ncertificate is self-signed. The parameter pub is the public key of the\nsignee and priv is the private key of the signer.\n\nThe returned slice is the certificate in DER encoding.\n\nAll keys types that are implemented via crypto.Signer are supported (This\nincludes *rsa.PublicKey and *ecdsa.PublicKey.)\n\nThe AuthorityKeyId will be taken from the SubjectKeyId of parent, if any,\nunless the resulting certificate is self-signed. Otherwise the value from\ntemplate will be used.\n\nGo input arguments: (rand io.Reader, template *Certificate, parent *Certificate, pub interface {}, priv interface {})\n\nGo return type: (cert []byte, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.x509/Certificate) template, ^(atom-of go.std.crypto.x509/Certificate) parent, ^<protocol-or-something> pub, ^<protocol-or-something> priv]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__createCertificate(*_rand, _template, _parent, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io/Reader _rand, ^x509/Certificate _template, ^x509/Certificate _parent, ^<protocol-or-something> _pub, ^<protocol-or-something> _priv])

JOKER FUNC crypto/x509.CreateCertificateRequest from crypto/x509/x509.go:
;; (defn CreateCertificateRequest
;;   "CreateCertificateRequest creates a new certificate request based on a\ntemplate. The following members of template are used:\n\n - Attributes\n - DNSNames\n - EmailAddresses\n - ExtraExtensions\n - IPAddresses\n - URIs\n - SignatureAlgorithm\n - Subject\n\nThe private key is the private key of the signer.\n\nThe returned slice is the certificate request in DER encoding.\n\nAll keys types that are implemented via crypto.Signer are supported (This\nincludes *rsa.PublicKey and *ecdsa.PublicKey.)\n\nGo input arguments: (rand io.Reader, template *CertificateRequest, priv interface {})\n\nGo return type: (csr []byte, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.x509/CertificateRequest) template, ^<protocol-or-something> priv]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__createCertificateRequest(*_rand, _template, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io/Reader _rand, ^x509/CertificateRequest _template, ^<protocol-or-something> _priv])

JOKER FUNC crypto/x509.DecryptPEMBlock from crypto/x509/pem_decrypt.go:
;; (defn DecryptPEMBlock
;;   "DecryptPEMBlock takes a password encrypted PEM block and the password used to\nencrypt it and returns a slice of decrypted DER encoded bytes. It inspects\nthe DEK-Info header to determine the algorithm used for decryption. If no\nDEK-Info header is present, an error is returned. If an incorrect password\nis detected an IncorrectPasswordError is returned. Because of deficiencies\nin the encrypted-PEM format, it's not always possible to detect an incorrect\npassword. In these cases no error will be returned but the decrypted DER\nbytes will be random noise.\n\nGo input arguments: (b *pem.Block, password []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.encoding.pem/Block) b, ^(vector-of Byte) password]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__decryptPEMBlock(_b, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_password)))"}
;;   [^pem/Block _b, ^Object _password])

JOKER FUNC crypto/x509.EncryptPEMBlock from crypto/x509/pem_decrypt.go:
;; (defn EncryptPEMBlock
;;   "EncryptPEMBlock returns a PEM block of the specified type holding the\ngiven DER-encoded data encrypted with the specified algorithm and\npassword.\n\nGo input arguments: (rand io.Reader, blockType string, data []byte, password []byte, alg PEMCipher)\n\nGo return type: (*encoding/pem.Block, error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^String blockType, ^(vector-of Byte) data, ^(vector-of Byte) password, ^go.std.crypto.x509/PEMCipher alg]\n\nJoker return type: [(atom-of go.std.encoding.pem/Block) Error]"
;;   {:added "1.0"
;;    :go "__encryptPEMBlock(*_rand, _blockType, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_password)), *_alg)"}
;;   [^io/Reader _rand, ^String _blockType, ^Object _data, ^Object _password, ^x509/PEMCipher _alg])

JOKER FUNC crypto/x509.IsEncryptedPEMBlock from crypto/x509/pem_decrypt.go:
;; (defn ^"Boolean" IsEncryptedPEMBlock
;;   "IsEncryptedPEMBlock returns if the PEM block is password encrypted.\n\nGo input arguments: (b *pem.Block)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.encoding.pem/Block) b]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "x509.IsEncryptedPEMBlock(_b)"}
;;   [^pem/Block _b])

JOKER FUNC crypto/x509.MarshalECPrivateKey from crypto/x509/sec1.go:
;; (defn MarshalECPrivateKey
;;   "MarshalECPrivateKey marshals an EC private key into ASN.1, DER format.\n\nGo input arguments: (key *ecdsa.PrivateKey)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.crypto.ecdsa/PrivateKey) key]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshalECPrivateKey(_key)"}
;;   [^ecdsa/PrivateKey _key])

JOKER FUNC crypto/x509.MarshalPKCS1PrivateKey from crypto/x509/pkcs1.go:
;; (defn MarshalPKCS1PrivateKey
;;   "MarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form.\n\nGo input arguments: (key *rsa.PrivateKey)\n\nGo return type: []byte\n\nJoker input arguments: [^(atom-of go.std.crypto.rsa/PrivateKey) key]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__marshalPKCS1PrivateKey(_key)"}
;;   [^rsa/PrivateKey _key])

JOKER FUNC crypto/x509.MarshalPKCS1PublicKey from crypto/x509/pkcs1.go:
;; (defn MarshalPKCS1PublicKey
;;   "MarshalPKCS1PublicKey converts an RSA public key to PKCS#1, ASN.1 DER form.\n\nGo input arguments: (key *rsa.PublicKey)\n\nGo return type: []byte\n\nJoker input arguments: [^(atom-of go.std.crypto.rsa/PublicKey) key]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__marshalPKCS1PublicKey(_key)"}
;;   [^rsa/PublicKey _key])

JOKER FUNC crypto/x509.MarshalPKCS8PrivateKey from crypto/x509/pkcs8.go:
;; (defn MarshalPKCS8PrivateKey
;;   "MarshalPKCS8PrivateKey converts a private key to PKCS#8 encoded form.\nThe following key types are supported: *rsa.PrivateKey, *ecdsa.PrivateKey.\nUnsupported key types result in an error.\n\nSee RFC 5208.\n\nGo input arguments: (key interface {})\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> key]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshalPKCS8PrivateKey(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _key])

JOKER FUNC crypto/x509.MarshalPKIXPublicKey from crypto/x509/x509.go:
;; (defn MarshalPKIXPublicKey
;;   "MarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format.\n\nGo input arguments: (pub interface {})\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> pub]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshalPKIXPublicKey(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _pub])

JOKER FUNC crypto/x509.NewCertPool from crypto/x509/cert_pool.go:
(defn NewCertPool
  "NewCertPool returns a new, empty CertPool.\n\nGo return type: *CertPool\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.crypto.x509/CertPool)"
  {:added "1.0"
   :go "__newCertPool()"}
  [])

JOKER FUNC crypto/x509.ParseCRL from crypto/x509/x509.go:
;; (defn ParseCRL
;;   "ParseCRL parses a CRL from the given bytes. It's often the case that PEM\nencoded CRLs will appear where they should be DER encoded, so this function\nwill transparently handle PEM encoding as long as there isn't any leading\ngarbage.\n\nGo input arguments: (crlBytes []byte)\n\nGo return type: (*crypto/x509/pkix.CertificateList, error)\n\nJoker input arguments: [^(vector-of Byte) crlBytes]\n\nJoker return type: [(atom-of go.std.crypto.x509.pkix/CertificateList) Error]"
;;   {:added "1.0"
;;    :go "__parseCRL(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_crlBytes)))"}
;;   [^Object _crlBytes])

JOKER FUNC crypto/x509.ParseCertificate from crypto/x509/x509.go:
;; (defn ParseCertificate
;;   "ParseCertificate parses a single certificate from the given ASN.1 DER data.\n\nGo input arguments: (asn1Data []byte)\n\nGo return type: (*Certificate, error)\n\nJoker input arguments: [^(vector-of Byte) asn1Data]\n\nJoker return type: [(atom-of go.std.crypto.x509/Certificate) Error]"
;;   {:added "1.0"
;;    :go "__parseCertificate(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_asn1Data)))"}
;;   [^Object _asn1Data])

JOKER FUNC crypto/x509.ParseCertificateRequest from crypto/x509/x509.go:
;; (defn ParseCertificateRequest
;;   "ParseCertificateRequest parses a single certificate request from the\ngiven ASN.1 DER data.\n\nGo input arguments: (asn1Data []byte)\n\nGo return type: (*CertificateRequest, error)\n\nJoker input arguments: [^(vector-of Byte) asn1Data]\n\nJoker return type: [(atom-of go.std.crypto.x509/CertificateRequest) Error]"
;;   {:added "1.0"
;;    :go "__parseCertificateRequest(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_asn1Data)))"}
;;   [^Object _asn1Data])

JOKER FUNC crypto/x509.ParseCertificates from crypto/x509/x509.go:
;; (defn ParseCertificates
;;   "ParseCertificates parses one or more certificates from the given ASN.1 DER\ndata. The certificates must be concatenated with no intermediate padding.\n\nGo input arguments: (asn1Data []byte)\n\nGo return type: ([]*Certificate, error)\n\nJoker input arguments: [^(vector-of Byte) asn1Data]\n\nJoker return type: [(vector-of (atom-of go.std.crypto.x509/Certificate)) Error]"
;;   {:added "1.0"
;;    :go "__parseCertificates(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_asn1Data)))"}
;;   [^Object _asn1Data])

JOKER FUNC crypto/x509.ParseDERCRL from crypto/x509/x509.go:
;; (defn ParseDERCRL
;;   "ParseDERCRL parses a DER encoded CRL from the given bytes.\n\nGo input arguments: (derBytes []byte)\n\nGo return type: (*crypto/x509/pkix.CertificateList, error)\n\nJoker input arguments: [^(vector-of Byte) derBytes]\n\nJoker return type: [(atom-of go.std.crypto.x509.pkix/CertificateList) Error]"
;;   {:added "1.0"
;;    :go "__parseDERCRL(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_derBytes)))"}
;;   [^Object _derBytes])

JOKER FUNC crypto/x509.ParseECPrivateKey from crypto/x509/sec1.go:
;; (defn ParseECPrivateKey
;;   "ParseECPrivateKey parses an ASN.1 Elliptic Curve Private Key Structure.\n\nGo input arguments: (der []byte)\n\nGo return type: (*crypto/ecdsa.PrivateKey, error)\n\nJoker input arguments: [^(vector-of Byte) der]\n\nJoker return type: [(atom-of go.std.crypto.ecdsa/PrivateKey) Error]"
;;   {:added "1.0"
;;    :go "__parseECPrivateKey(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_der)))"}
;;   [^Object _der])

JOKER FUNC crypto/x509.ParsePKCS1PrivateKey from crypto/x509/pkcs1.go:
;; (defn ParsePKCS1PrivateKey
;;   "ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form.\n\nGo input arguments: (der []byte)\n\nGo return type: (*crypto/rsa.PrivateKey, error)\n\nJoker input arguments: [^(vector-of Byte) der]\n\nJoker return type: [(atom-of go.std.crypto.rsa/PrivateKey) Error]"
;;   {:added "1.0"
;;    :go "__parsePKCS1PrivateKey(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_der)))"}
;;   [^Object _der])

JOKER FUNC crypto/x509.ParsePKCS1PublicKey from crypto/x509/pkcs1.go:
;; (defn ParsePKCS1PublicKey
;;   "ParsePKCS1PublicKey parses a PKCS#1 public key in ASN.1 DER form.\n\nGo input arguments: (der []byte)\n\nGo return type: (*crypto/rsa.PublicKey, error)\n\nJoker input arguments: [^(vector-of Byte) der]\n\nJoker return type: [(atom-of go.std.crypto.rsa/PublicKey) Error]"
;;   {:added "1.0"
;;    :go "__parsePKCS1PublicKey(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_der)))"}
;;   [^Object _der])

JOKER FUNC crypto/x509.ParsePKCS8PrivateKey from crypto/x509/pkcs8.go:
;; (defn ParsePKCS8PrivateKey
;;   "ParsePKCS8PrivateKey parses an unencrypted, PKCS#8 private key.\nSee RFC 5208.\n\nGo input arguments: (der []byte)\n\nGo return type: (key ..., err error)\n\nJoker input arguments: [^(vector-of Byte) der]\n\nJoker return type: [ABEND883(post.go: unrecognized Expr type *ast.InterfaceType at: /usr/local/go-1.11.5/src/crypto/x509/pkcs8.go:28:44) Error]"
;;   {:added "1.0"
;;    :go "__parsePKCS8PrivateKey(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_der)))"}
;;   [^Object _der])

JOKER FUNC crypto/x509.ParsePKIXPublicKey from crypto/x509/x509.go:
;; (defn ParsePKIXPublicKey
;;   "ParsePKIXPublicKey parses a DER encoded public key. These values are\ntypically found in PEM blocks with \"BEGIN PUBLIC KEY\".\n\nSupported key types include RSA, DSA, and ECDSA. Unknown key\ntypes result in an error.\n\nOn success, pub will be of type *rsa.PublicKey, *dsa.PublicKey,\nor *ecdsa.PublicKey.\n\nGo input arguments: (derBytes []byte)\n\nGo return type: (pub ..., err error)\n\nJoker input arguments: [^(vector-of Byte) derBytes]\n\nJoker return type: [ABEND883(post.go: unrecognized Expr type *ast.InterfaceType at: /usr/local/go-1.11.5/src/crypto/x509/x509.go:55:47) Error]"
;;   {:added "1.0"
;;    :go "__parsePKIXPublicKey(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_derBytes)))"}
;;   [^Object _derBytes])

JOKER FUNC crypto/x509.SystemCertPool from crypto/x509/cert_pool.go:
(defn SystemCertPool
  "SystemCertPool returns a copy of the system cert pool.\n\nAny mutations to the returned pool are not written to disk and do\nnot affect any other pool.\n\nNew changes in the the system cert pool might not be reflected\nin subsequent calls.\n\nGo return type: (*CertPool, error)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.crypto.x509/CertPool) Error]"
  {:added "1.0"
   :go "__systemCertPool()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/x509 package."
    :empty false}
  go.std.crypto.x509)
JOKER TYPE database/sql.ColumnType from database/sql/sql.go:
(defn ^"GoObject" ColumnType.
  "Constructor for sql.ColumnType"
  {:added "1.0"
   :go "_ConstructColumnType(_v)"}
  [^Object _v])

JOKER TYPE database/sql.Conn from database/sql/sql.go:
(defn ^"GoObject" Conn.
  "Constructor for sql.Conn"
  {:added "1.0"
   :go "_ConstructConn(_v)"}
  [^Object _v])

JOKER TYPE database/sql.DB from database/sql/sql.go:
(defn ^"GoObject" DB.
  "Constructor for sql.DB"
  {:added "1.0"
   :go "_ConstructDB(_v)"}
  [^Object _v])

JOKER TYPE database/sql.DBStats from database/sql/sql.go:
(defn ^"GoObject" DBStats.
  "Constructor for sql.DBStats"
  {:added "1.0"
   :go "_ConstructDBStats(_v)"}
  [^Object _v])

JOKER TYPE database/sql.IsolationLevel from database/sql/sql.go:
(defn ^"GoObject" IsolationLevel.
  "Constructor for sql.IsolationLevel"
  {:added "1.0"
   :go "_ConstructIsolationLevel(_v)"}
  [^Object _v])

JOKER TYPE database/sql.NamedArg from database/sql/sql.go:
(defn ^"GoObject" NamedArg.
  "Constructor for sql.NamedArg"
  {:added "1.0"
   :go "_ConstructNamedArg(_v)"}
  [^Object _v])

JOKER TYPE database/sql.NullBool from database/sql/sql.go:
(defn ^"GoObject" NullBool.
  "Constructor for sql.NullBool"
  {:added "1.0"
   :go "_ConstructNullBool(_v)"}
  [^Object _v])

JOKER TYPE database/sql.NullFloat64 from database/sql/sql.go:
(defn ^"GoObject" NullFloat64.
  "Constructor for sql.NullFloat64"
  {:added "1.0"
   :go "_ConstructNullFloat64(_v)"}
  [^Object _v])

JOKER TYPE database/sql.NullInt64 from database/sql/sql.go:
(defn ^"GoObject" NullInt64.
  "Constructor for sql.NullInt64"
  {:added "1.0"
   :go "_ConstructNullInt64(_v)"}
  [^Object _v])

JOKER TYPE database/sql.NullString from database/sql/sql.go:
(defn ^"GoObject" NullString.
  "Constructor for sql.NullString"
  {:added "1.0"
   :go "_ConstructNullString(_v)"}
  [^Object _v])

JOKER TYPE database/sql.Out from database/sql/sql.go:
(defn ^"GoObject" Out.
  "Constructor for sql.Out"
  {:added "1.0"
   :go "_ConstructOut(_v)"}
  [^Object _v])

JOKER TYPE database/sql.RawBytes from database/sql/sql.go:
;; (defn ^"GoObject" RawBytes.
;;   "Constructor for sql.RawBytes"
;;   {:added "1.0"
;;    :go "_ConstructRawBytes(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql.Result from database/sql/sql.go:
;; (defn ^"GoObject" Result.
;;   "Constructor for sql.Result"
;;   {:added "1.0"
;;    :go "_ConstructResult(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql.Row from database/sql/sql.go:
(defn ^"GoObject" Row.
  "Constructor for sql.Row"
  {:added "1.0"
   :go "_ConstructRow(_v)"}
  [^Object _v])

JOKER TYPE database/sql.Rows from database/sql/sql.go:
(defn ^"GoObject" Rows.
  "Constructor for sql.Rows"
  {:added "1.0"
   :go "_ConstructRows(_v)"}
  [^Object _v])

JOKER TYPE database/sql.Scanner from database/sql/sql.go:
;; (defn ^"GoObject" Scanner.
;;   "Constructor for sql.Scanner"
;;   {:added "1.0"
;;    :go "_ConstructScanner(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql.Stmt from database/sql/sql.go:
(defn ^"GoObject" Stmt.
  "Constructor for sql.Stmt"
  {:added "1.0"
   :go "_ConstructStmt(_v)"}
  [^Object _v])

JOKER TYPE database/sql.Tx from database/sql/sql.go:
(defn ^"GoObject" Tx.
  "Constructor for sql.Tx"
  {:added "1.0"
   :go "_ConstructTx(_v)"}
  [^Object _v])

JOKER TYPE database/sql.TxOptions from database/sql/sql.go:
(defn ^"GoObject" TxOptions.
  "Constructor for sql.TxOptions"
  {:added "1.0"
   :go "_ConstructTxOptions(_v)"}
  [^Object _v])

JOKER FUNC database/sql.Drivers from database/sql/sql.go:
(defn Drivers
  "Drivers returns a sorted list of the names of the registered drivers.\n\nGo return type: []string\n\nJoker input arguments: []\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__drivers()"}
  [])

JOKER FUNC database/sql.Named from database/sql/sql.go:
;; (defn Named
;;   "Named provides a more concise way to create NamedArg values.\n\nExample usage:\n\n    db.ExecContext(ctx, `\n        delete from Invoice\n        where\n            TimeCreated < @end\n            and TimeCreated >= @start;`,\n        sql.Named(\"start\", startTime),\n        sql.Named(\"end\", endTime),\n    )\n\nGo input arguments: (name string, value interface {})\n\nGo return type: NamedArg\n\nJoker input arguments: [^String name, ^<protocol-or-something> value]\n\nJoker return type: go.std.database.sql/NamedArg"
;;   {:added "1.0"
;;    :go "__named(_name, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^String _name, ^<protocol-or-something> _value])

JOKER FUNC database/sql.Open from database/sql/sql.go:
(defn Open
  "Open opens a database specified by its database driver name and a\ndriver-specific data source name, usually consisting of at least a\ndatabase name and connection information.\n\nMost users will open a database via a driver-specific connection\nhelper function that returns a *DB. No database drivers are included\nin the Go standard library. See https://golang.org/s/sqldrivers for\na list of third-party drivers.\n\nOpen may just validate its arguments without creating a connection\nto the database. To verify that the data source name is valid, call\nPing.\n\nThe returned DB is safe for concurrent use by multiple goroutines\nand maintains its own pool of idle connections. Thus, the Open\nfunction should be called just once. It is rarely necessary to\nclose a DB.\n\nGo input arguments: (driverName string, dataSourceName string)\n\nGo return type: (*DB, error)\n\nJoker input arguments: [^String driverName, ^String dataSourceName]\n\nJoker return type: [(atom-of go.std.database.sql/DB) Error]"
  {:added "1.0"
   :go "__open(_driverName, _dataSourceName)"}
  [^String _driverName, ^String _dataSourceName])

JOKER FUNC database/sql.OpenDB from database/sql/sql.go:
;; (defn OpenDB
;;   "OpenDB opens a database using a Connector, allowing drivers to\nbypass a string based data source name.\n\nMost users will open a database via a driver-specific connection\nhelper function that returns a *DB. No database drivers are included\nin the Go standard library. See https://golang.org/s/sqldrivers for\na list of third-party drivers.\n\nOpenDB may just validate its arguments without creating a connection\nto the database. To verify that the data source name is valid, call\nPing.\n\nThe returned DB is safe for concurrent use by multiple goroutines\nand maintains its own pool of idle connections. Thus, the OpenDB\nfunction should be called just once. It is rarely necessary to\nclose a DB.\n\nGo input arguments: (c driver.Connector)\n\nGo return type: *DB\n\nJoker input arguments: [^go.std.database.sql.driver/Connector c]\n\nJoker return type: (atom-of go.std.database.sql/DB)"
;;   {:added "1.0"
;;    :go "__openDB(*_c)"}
;;   [^driver/Connector _c])

JOKER FUNC database/sql.Register from database/sql/sql.go:
;; (defn Register
;;   "Register makes a database driver available by the provided name.\nIf Register is called twice with the same name or if driver is nil,\nit panics.\n\nGo input arguments: (name string, driver driver.Driver)\n\nJoker input arguments: [^String name, ^go.std.database.sql.driver/Driver driver]"
;;   {:added "1.0"
;;    :go "__register(_name, *_driver)"}
;;   [^String _name, ^driver/Driver _driver])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the database/sql package."
    :empty false}
  go.std.database.sql)
JOKER FUNC database/sql/driver.IsScanValue from database/sql/driver/types.go:
;; (defn ^"Boolean" IsScanValue
;;   "IsScanValue is equivalent to IsValue.\nIt exists for compatibility.\n\nGo input arguments: (v interface {})\n\nGo return type: bool\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "driver.IsScanValue(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC database/sql/driver.IsValue from database/sql/driver/types.go:
;; (defn ^"Boolean" IsValue
;;   "IsValue reports whether v is a valid Value parameter type.\n\nGo input arguments: (v interface {})\n\nGo return type: bool\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "driver.IsValue(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC debug/dwarf.New from debug/dwarf/open.go:
;; (defn New
;;   "New returns a new Data object initialized from the given parameters.\nRather than calling this function directly, clients should typically use\nthe DWARF method of the File type of the appropriate package debug/elf,\ndebug/macho, or debug/pe.\n\nThe []byte arguments are the data from the corresponding debug section\nin the object file; for example, for an ELF object, abbrev is the contents of\nthe \".debug_abbrev\" section.\n\nGo input arguments: (abbrev []byte, aranges []byte, frame []byte, info []byte, line []byte, pubnames []byte, ranges []byte, str []byte)\n\nGo return type: (*Data, error)\n\nJoker input arguments: [^(vector-of Byte) abbrev, ^(vector-of Byte) aranges, ^(vector-of Byte) frame, ^(vector-of Byte) info, ^(vector-of Byte) line, ^(vector-of Byte) pubnames, ^(vector-of Byte) ranges, ^(vector-of Byte) str]\n\nJoker return type: [(atom-of go.std.debug.dwarf/Data) Error]"
;;   {:added "1.0"
;;    :go "__new(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_abbrev)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_aranges)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_frame)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_info)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_line)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_pubnames)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_ranges)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_str)))"}
;;   [^Object _abbrev, ^Object _aranges, ^Object _frame, ^Object _info, ^Object _line, ^Object _pubnames, ^Object _ranges, ^Object _str])

JOKER TYPE debug/elf.Chdr32 from debug/elf/elf.go:
(defn ^"GoObject" Chdr32.
  "Constructor for elf.Chdr32"
  {:added "1.0"
   :go "_ConstructChdr32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Chdr64 from debug/elf/elf.go:
(defn ^"GoObject" Chdr64.
  "Constructor for elf.Chdr64"
  {:added "1.0"
   :go "_ConstructChdr64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Class from debug/elf/elf.go:
(defn ^"GoObject" Class.
  "Constructor for elf.Class"
  {:added "1.0"
   :go "_ConstructClass(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.CompressionType from debug/elf/elf.go:
(defn ^"GoObject" CompressionType.
  "Constructor for elf.CompressionType"
  {:added "1.0"
   :go "_ConstructCompressionType(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Data from debug/elf/elf.go:
(defn ^"GoObject" Data.
  "Constructor for elf.Data"
  {:added "1.0"
   :go "_ConstructData(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Dyn32 from debug/elf/elf.go:
(defn ^"GoObject" Dyn32.
  "Constructor for elf.Dyn32"
  {:added "1.0"
   :go "_ConstructDyn32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Dyn64 from debug/elf/elf.go:
(defn ^"GoObject" Dyn64.
  "Constructor for elf.Dyn64"
  {:added "1.0"
   :go "_ConstructDyn64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.DynFlag from debug/elf/elf.go:
(defn ^"GoObject" DynFlag.
  "Constructor for elf.DynFlag"
  {:added "1.0"
   :go "_ConstructDynFlag(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.DynTag from debug/elf/elf.go:
(defn ^"GoObject" DynTag.
  "Constructor for elf.DynTag"
  {:added "1.0"
   :go "_ConstructDynTag(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.File from debug/elf/file.go:
(defn ^"GoObject" File.
  "Constructor for elf.File"
  {:added "1.0"
   :go "_ConstructFile(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.FileHeader from debug/elf/file.go:
(defn ^"GoObject" FileHeader.
  "Constructor for elf.FileHeader"
  {:added "1.0"
   :go "_ConstructFileHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.FormatError from debug/elf/file.go:
(defn ^"GoObject" FormatError.
  "Constructor for elf.FormatError"
  {:added "1.0"
   :go "_ConstructFormatError(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Header32 from debug/elf/elf.go:
(defn ^"GoObject" Header32.
  "Constructor for elf.Header32"
  {:added "1.0"
   :go "_ConstructHeader32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Header64 from debug/elf/elf.go:
(defn ^"GoObject" Header64.
  "Constructor for elf.Header64"
  {:added "1.0"
   :go "_ConstructHeader64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.ImportedSymbol from debug/elf/file.go:
(defn ^"GoObject" ImportedSymbol.
  "Constructor for elf.ImportedSymbol"
  {:added "1.0"
   :go "_ConstructImportedSymbol(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Machine from debug/elf/elf.go:
;; (defn ^"GoObject" Machine.
;;   "Constructor for elf.Machine"
;;   {:added "1.0"
;;    :go "_ConstructMachine(_v)"}
;;   [^Object _v])

JOKER TYPE debug/elf.NType from debug/elf/elf.go:
(defn ^"GoObject" NType.
  "Constructor for elf.NType"
  {:added "1.0"
   :go "_ConstructNType(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.OSABI from debug/elf/elf.go:
(defn ^"GoObject" OSABI.
  "Constructor for elf.OSABI"
  {:added "1.0"
   :go "_ConstructOSABI(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Prog from debug/elf/file.go:
(defn ^"GoObject" Prog.
  "Constructor for elf.Prog"
  {:added "1.0"
   :go "_ConstructProg(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Prog32 from debug/elf/elf.go:
(defn ^"GoObject" Prog32.
  "Constructor for elf.Prog32"
  {:added "1.0"
   :go "_ConstructProg32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Prog64 from debug/elf/elf.go:
(defn ^"GoObject" Prog64.
  "Constructor for elf.Prog64"
  {:added "1.0"
   :go "_ConstructProg64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.ProgFlag from debug/elf/elf.go:
(defn ^"GoObject" ProgFlag.
  "Constructor for elf.ProgFlag"
  {:added "1.0"
   :go "_ConstructProgFlag(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.ProgHeader from debug/elf/file.go:
(defn ^"GoObject" ProgHeader.
  "Constructor for elf.ProgHeader"
  {:added "1.0"
   :go "_ConstructProgHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.ProgType from debug/elf/elf.go:
(defn ^"GoObject" ProgType.
  "Constructor for elf.ProgType"
  {:added "1.0"
   :go "_ConstructProgType(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_386 from debug/elf/elf.go:
(defn ^"GoObject" R_386.
  "Constructor for elf.R_386"
  {:added "1.0"
   :go "_ConstructR_386(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_390 from debug/elf/elf.go:
(defn ^"GoObject" R_390.
  "Constructor for elf.R_390"
  {:added "1.0"
   :go "_ConstructR_390(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_AARCH64 from debug/elf/elf.go:
(defn ^"GoObject" R_AARCH64.
  "Constructor for elf.R_AARCH64"
  {:added "1.0"
   :go "_ConstructR_AARCH64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_ALPHA from debug/elf/elf.go:
(defn ^"GoObject" R_ALPHA.
  "Constructor for elf.R_ALPHA"
  {:added "1.0"
   :go "_ConstructR_ALPHA(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_ARM from debug/elf/elf.go:
(defn ^"GoObject" R_ARM.
  "Constructor for elf.R_ARM"
  {:added "1.0"
   :go "_ConstructR_ARM(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_MIPS from debug/elf/elf.go:
(defn ^"GoObject" R_MIPS.
  "Constructor for elf.R_MIPS"
  {:added "1.0"
   :go "_ConstructR_MIPS(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_PPC from debug/elf/elf.go:
(defn ^"GoObject" R_PPC.
  "Constructor for elf.R_PPC"
  {:added "1.0"
   :go "_ConstructR_PPC(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_PPC64 from debug/elf/elf.go:
(defn ^"GoObject" R_PPC64.
  "Constructor for elf.R_PPC64"
  {:added "1.0"
   :go "_ConstructR_PPC64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_RISCV from debug/elf/elf.go:
(defn ^"GoObject" R_RISCV.
  "Constructor for elf.R_RISCV"
  {:added "1.0"
   :go "_ConstructR_RISCV(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_SPARC from debug/elf/elf.go:
(defn ^"GoObject" R_SPARC.
  "Constructor for elf.R_SPARC"
  {:added "1.0"
   :go "_ConstructR_SPARC(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_X86_64 from debug/elf/elf.go:
(defn ^"GoObject" R_X86_64.
  "Constructor for elf.R_X86_64"
  {:added "1.0"
   :go "_ConstructR_X86_64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Rel32 from debug/elf/elf.go:
(defn ^"GoObject" Rel32.
  "Constructor for elf.Rel32"
  {:added "1.0"
   :go "_ConstructRel32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Rel64 from debug/elf/elf.go:
(defn ^"GoObject" Rel64.
  "Constructor for elf.Rel64"
  {:added "1.0"
   :go "_ConstructRel64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Rela32 from debug/elf/elf.go:
(defn ^"GoObject" Rela32.
  "Constructor for elf.Rela32"
  {:added "1.0"
   :go "_ConstructRela32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Rela64 from debug/elf/elf.go:
(defn ^"GoObject" Rela64.
  "Constructor for elf.Rela64"
  {:added "1.0"
   :go "_ConstructRela64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Section from debug/elf/file.go:
(defn ^"GoObject" Section.
  "Constructor for elf.Section"
  {:added "1.0"
   :go "_ConstructSection(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Section32 from debug/elf/elf.go:
(defn ^"GoObject" Section32.
  "Constructor for elf.Section32"
  {:added "1.0"
   :go "_ConstructSection32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Section64 from debug/elf/elf.go:
(defn ^"GoObject" Section64.
  "Constructor for elf.Section64"
  {:added "1.0"
   :go "_ConstructSection64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.SectionFlag from debug/elf/elf.go:
(defn ^"GoObject" SectionFlag.
  "Constructor for elf.SectionFlag"
  {:added "1.0"
   :go "_ConstructSectionFlag(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.SectionHeader from debug/elf/file.go:
(defn ^"GoObject" SectionHeader.
  "Constructor for elf.SectionHeader"
  {:added "1.0"
   :go "_ConstructSectionHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.SectionIndex from debug/elf/elf.go:
(defn ^"GoObject" SectionIndex.
  "Constructor for elf.SectionIndex"
  {:added "1.0"
   :go "_ConstructSectionIndex(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.SectionType from debug/elf/elf.go:
(defn ^"GoObject" SectionType.
  "Constructor for elf.SectionType"
  {:added "1.0"
   :go "_ConstructSectionType(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Sym32 from debug/elf/elf.go:
(defn ^"GoObject" Sym32.
  "Constructor for elf.Sym32"
  {:added "1.0"
   :go "_ConstructSym32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Sym64 from debug/elf/elf.go:
(defn ^"GoObject" Sym64.
  "Constructor for elf.Sym64"
  {:added "1.0"
   :go "_ConstructSym64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.SymBind from debug/elf/elf.go:
(defn ^"GoObject" SymBind.
  "Constructor for elf.SymBind"
  {:added "1.0"
   :go "_ConstructSymBind(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.SymType from debug/elf/elf.go:
(defn ^"GoObject" SymType.
  "Constructor for elf.SymType"
  {:added "1.0"
   :go "_ConstructSymType(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.SymVis from debug/elf/elf.go:
(defn ^"GoObject" SymVis.
  "Constructor for elf.SymVis"
  {:added "1.0"
   :go "_ConstructSymVis(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Symbol from debug/elf/file.go:
(defn ^"GoObject" Symbol.
  "Constructor for elf.Symbol"
  {:added "1.0"
   :go "_ConstructSymbol(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Type from debug/elf/elf.go:
;; (defn ^"GoObject" Type.
;;   "Constructor for elf.Type"
;;   {:added "1.0"
;;    :go "_ConstructType(_v)"}
;;   [^Object _v])

JOKER TYPE debug/elf.Version from debug/elf/elf.go:
(defn ^"GoObject" Version.
  "Constructor for elf.Version"
  {:added "1.0"
   :go "_ConstructVersion(_v)"}
  [^Object _v])

JOKER FUNC debug/elf.NewFile from debug/elf/file.go:
;; (defn NewFile
;;   "NewFile creates a new File for accessing an ELF binary in an underlying reader.\nThe ELF binary is expected to start at position 0 in the ReaderAt.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r]\n\nJoker return type: [(atom-of go.std.debug.elf/File) Error]"
;;   {:added "1.0"
;;    :go "__newFile(*_r)"}
;;   [^io/ReaderAt _r])

JOKER FUNC debug/elf.Open from debug/elf/file.go:
(defn Open
  "Open opens the named file using os.Open and prepares it for use as an ELF binary.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.debug.elf/File) Error]"
  {:added "1.0"
   :go "__open(_name)"}
  [^String _name])

JOKER FUNC debug/elf.R_INFO from debug/elf/elf.go:
(defn R_INFO
  "Go input arguments: (sym uint32, typ uint32)\n\nGo return type: uint64\n\nJoker input arguments: [^UInt32 sym, ^UInt32 typ]\n\nJoker return type: BigInt"
  {:added "1.0"
   :go "__r_INFO(_sym, _typ)"}
  [^UInt32 _sym, ^UInt32 _typ])

JOKER FUNC debug/elf.R_INFO32 from debug/elf/elf.go:
(defn R_INFO32
  "Go input arguments: (sym uint32, typ uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^UInt32 sym, ^UInt32 typ]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__r_INFO32(_sym, _typ)"}
  [^UInt32 _sym, ^UInt32 _typ])

JOKER FUNC debug/elf.R_SYM32 from debug/elf/elf.go:
(defn R_SYM32
  "Go input arguments: (info uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^UInt32 info]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__r_SYM32(_info)"}
  [^UInt32 _info])

JOKER FUNC debug/elf.R_SYM64 from debug/elf/elf.go:
;; (defn R_SYM64
;;   "Go input arguments: (info uint64)\n\nGo return type: uint32\n\nJoker input arguments: [^uint64 info]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__r_SYM64(_info)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint64) _info])

JOKER FUNC debug/elf.R_TYPE32 from debug/elf/elf.go:
(defn R_TYPE32
  "Go input arguments: (info uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^UInt32 info]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__r_TYPE32(_info)"}
  [^UInt32 _info])

JOKER FUNC debug/elf.R_TYPE64 from debug/elf/elf.go:
;; (defn R_TYPE64
;;   "Go input arguments: (info uint64)\n\nGo return type: uint32\n\nJoker input arguments: [^uint64 info]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__r_TYPE64(_info)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint64) _info])

JOKER FUNC debug/elf.ST_BIND from debug/elf/elf.go:
;; (defn ST_BIND
;;   "Go input arguments: (info uint8)\n\nGo return type: SymBind\n\nJoker input arguments: [^uint8 info]\n\nJoker return type: go.std.debug.elf/SymBind"
;;   {:added "1.0"
;;    :go "__sT_BIND(_info)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint8) _info])

JOKER FUNC debug/elf.ST_INFO from debug/elf/elf.go:
;; (defn ST_INFO
;;   "Go input arguments: (bind SymBind, typ SymType)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.debug.elf/SymBind bind, ^go.std.debug.elf/SymType typ]\n\nJoker return type: ABEND043(post.go: unsupported built-in type uint8)"
;;   {:added "1.0"
;;    :go "__sT_INFO(*_bind, *_typ)"}
;;   [^elf/SymBind _bind, ^elf/SymType _typ])

JOKER FUNC debug/elf.ST_TYPE from debug/elf/elf.go:
;; (defn ST_TYPE
;;   "Go input arguments: (info uint8)\n\nGo return type: SymType\n\nJoker input arguments: [^uint8 info]\n\nJoker return type: go.std.debug.elf/SymType"
;;   {:added "1.0"
;;    :go "__sT_TYPE(_info)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint8) _info])

JOKER FUNC debug/elf.ST_VISIBILITY from debug/elf/elf.go:
;; (defn ST_VISIBILITY
;;   "Go input arguments: (other uint8)\n\nGo return type: SymVis\n\nJoker input arguments: [^uint8 other]\n\nJoker return type: go.std.debug.elf/SymVis"
;;   {:added "1.0"
;;    :go "__sT_VISIBILITY(_other)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint8) _other])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the debug/elf package."
    :empty false}
  go.std.debug.elf)
JOKER FUNC debug/gosym.NewLineTable from debug/gosym/pclntab.go:
;; (defn NewLineTable
;;   "NewLineTable returns a new PC/line table\ncorresponding to the encoded data.\nText must be the start address of the\ncorresponding text segment.\n\nGo input arguments: (data []byte, text uint64)\n\nGo return type: *LineTable\n\nJoker input arguments: [^(vector-of Byte) data, ^uint64 text]\n\nJoker return type: (atom-of go.std.debug.gosym/LineTable)"
;;   {:added "1.0"
;;    :go "__newLineTable(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), _text)"}
;;   [^Object _data, ^ABEND044(pre.go: unsupported built-in type uint64) _text])

JOKER FUNC debug/gosym.NewTable from debug/gosym/symtab.go:
;; (defn NewTable
;;   "NewTable decodes the Go symbol table (the \".gosymtab\" section in ELF),\nreturning an in-memory representation.\nStarting with Go 1.3, the Go symbol table no longer includes symbol data.\n\nGo input arguments: (symtab []byte, pcln *LineTable)\n\nGo return type: (*Table, error)\n\nJoker input arguments: [^(vector-of Byte) symtab, ^(atom-of go.std.debug.gosym/LineTable) pcln]\n\nJoker return type: [(atom-of go.std.debug.gosym/Table) Error]"
;;   {:added "1.0"
;;    :go "__newTable(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_symtab)), _pcln)"}
;;   [^Object _symtab, ^gosym/LineTable _pcln])

JOKER TYPE debug/macho.Cpu from debug/macho/macho.go:
(defn ^"GoObject" Cpu.
  "Constructor for macho.Cpu"
  {:added "1.0"
   :go "_ConstructCpu(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Dylib from debug/macho/file.go:
(defn ^"GoObject" Dylib.
  "Constructor for macho.Dylib"
  {:added "1.0"
   :go "_ConstructDylib(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.DylibCmd from debug/macho/macho.go:
(defn ^"GoObject" DylibCmd.
  "Constructor for macho.DylibCmd"
  {:added "1.0"
   :go "_ConstructDylibCmd(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Dysymtab from debug/macho/file.go:
(defn ^"GoObject" Dysymtab.
  "Constructor for macho.Dysymtab"
  {:added "1.0"
   :go "_ConstructDysymtab(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.DysymtabCmd from debug/macho/macho.go:
(defn ^"GoObject" DysymtabCmd.
  "Constructor for macho.DysymtabCmd"
  {:added "1.0"
   :go "_ConstructDysymtabCmd(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.FatArch from debug/macho/fat.go:
(defn ^"GoObject" FatArch.
  "Constructor for macho.FatArch"
  {:added "1.0"
   :go "_ConstructFatArch(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.FatArchHeader from debug/macho/fat.go:
(defn ^"GoObject" FatArchHeader.
  "Constructor for macho.FatArchHeader"
  {:added "1.0"
   :go "_ConstructFatArchHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.FatFile from debug/macho/fat.go:
(defn ^"GoObject" FatFile.
  "Constructor for macho.FatFile"
  {:added "1.0"
   :go "_ConstructFatFile(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.File from debug/macho/file.go:
(defn ^"GoObject" File.
  "Constructor for macho.File"
  {:added "1.0"
   :go "_ConstructFile(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.FileHeader from debug/macho/macho.go:
(defn ^"GoObject" FileHeader.
  "Constructor for macho.FileHeader"
  {:added "1.0"
   :go "_ConstructFileHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.FormatError from debug/macho/file.go:
(defn ^"GoObject" FormatError.
  "Constructor for macho.FormatError"
  {:added "1.0"
   :go "_ConstructFormatError(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Load from debug/macho/file.go:
;; (defn ^"GoObject" Load.
;;   "Constructor for macho.Load"
;;   {:added "1.0"
;;    :go "_ConstructLoad(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.LoadBytes from debug/macho/file.go:
;; (defn ^"GoObject" LoadBytes.
;;   "Constructor for macho.LoadBytes"
;;   {:added "1.0"
;;    :go "_ConstructLoadBytes(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.LoadCmd from debug/macho/macho.go:
(defn ^"GoObject" LoadCmd.
  "Constructor for macho.LoadCmd"
  {:added "1.0"
   :go "_ConstructLoadCmd(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Nlist32 from debug/macho/macho.go:
(defn ^"GoObject" Nlist32.
  "Constructor for macho.Nlist32"
  {:added "1.0"
   :go "_ConstructNlist32(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Nlist64 from debug/macho/macho.go:
(defn ^"GoObject" Nlist64.
  "Constructor for macho.Nlist64"
  {:added "1.0"
   :go "_ConstructNlist64(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Regs386 from debug/macho/macho.go:
(defn ^"GoObject" Regs386.
  "Constructor for macho.Regs386"
  {:added "1.0"
   :go "_ConstructRegs386(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.RegsAMD64 from debug/macho/macho.go:
(defn ^"GoObject" RegsAMD64.
  "Constructor for macho.RegsAMD64"
  {:added "1.0"
   :go "_ConstructRegsAMD64(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Reloc from debug/macho/file.go:
(defn ^"GoObject" Reloc.
  "Constructor for macho.Reloc"
  {:added "1.0"
   :go "_ConstructReloc(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.RelocTypeARM from debug/macho/reloctype.go:
(defn ^"GoObject" RelocTypeARM.
  "Constructor for macho.RelocTypeARM"
  {:added "1.0"
   :go "_ConstructRelocTypeARM(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.RelocTypeARM64 from debug/macho/reloctype.go:
(defn ^"GoObject" RelocTypeARM64.
  "Constructor for macho.RelocTypeARM64"
  {:added "1.0"
   :go "_ConstructRelocTypeARM64(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.RelocTypeGeneric from debug/macho/reloctype.go:
(defn ^"GoObject" RelocTypeGeneric.
  "Constructor for macho.RelocTypeGeneric"
  {:added "1.0"
   :go "_ConstructRelocTypeGeneric(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.RelocTypeX86_64 from debug/macho/reloctype.go:
(defn ^"GoObject" RelocTypeX86_64.
  "Constructor for macho.RelocTypeX86_64"
  {:added "1.0"
   :go "_ConstructRelocTypeX86_64(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Rpath from debug/macho/file.go:
(defn ^"GoObject" Rpath.
  "Constructor for macho.Rpath"
  {:added "1.0"
   :go "_ConstructRpath(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.RpathCmd from debug/macho/macho.go:
(defn ^"GoObject" RpathCmd.
  "Constructor for macho.RpathCmd"
  {:added "1.0"
   :go "_ConstructRpathCmd(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Section from debug/macho/file.go:
(defn ^"GoObject" Section.
  "Constructor for macho.Section"
  {:added "1.0"
   :go "_ConstructSection(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Section32 from debug/macho/macho.go:
(defn ^"GoObject" Section32.
  "Constructor for macho.Section32"
  {:added "1.0"
   :go "_ConstructSection32(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Section64 from debug/macho/macho.go:
(defn ^"GoObject" Section64.
  "Constructor for macho.Section64"
  {:added "1.0"
   :go "_ConstructSection64(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.SectionHeader from debug/macho/file.go:
(defn ^"GoObject" SectionHeader.
  "Constructor for macho.SectionHeader"
  {:added "1.0"
   :go "_ConstructSectionHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Segment from debug/macho/file.go:
(defn ^"GoObject" Segment.
  "Constructor for macho.Segment"
  {:added "1.0"
   :go "_ConstructSegment(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Segment32 from debug/macho/macho.go:
(defn ^"GoObject" Segment32.
  "Constructor for macho.Segment32"
  {:added "1.0"
   :go "_ConstructSegment32(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Segment64 from debug/macho/macho.go:
(defn ^"GoObject" Segment64.
  "Constructor for macho.Segment64"
  {:added "1.0"
   :go "_ConstructSegment64(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.SegmentHeader from debug/macho/file.go:
(defn ^"GoObject" SegmentHeader.
  "Constructor for macho.SegmentHeader"
  {:added "1.0"
   :go "_ConstructSegmentHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Symbol from debug/macho/file.go:
(defn ^"GoObject" Symbol.
  "Constructor for macho.Symbol"
  {:added "1.0"
   :go "_ConstructSymbol(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Symtab from debug/macho/file.go:
(defn ^"GoObject" Symtab.
  "Constructor for macho.Symtab"
  {:added "1.0"
   :go "_ConstructSymtab(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.SymtabCmd from debug/macho/macho.go:
(defn ^"GoObject" SymtabCmd.
  "Constructor for macho.SymtabCmd"
  {:added "1.0"
   :go "_ConstructSymtabCmd(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Thread from debug/macho/macho.go:
(defn ^"GoObject" Thread.
  "Constructor for macho.Thread"
  {:added "1.0"
   :go "_ConstructThread(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Type from debug/macho/macho.go:
(defn ^"GoObject" Type.
  "Constructor for macho.Type"
  {:added "1.0"
   :go "_ConstructType(_v)"}
  [^Object _v])

JOKER FUNC debug/macho.NewFatFile from debug/macho/fat.go:
;; (defn NewFatFile
;;   "NewFatFile creates a new FatFile for accessing all the Mach-O images in a\nuniversal binary. The Mach-O binary is expected to start at position 0 in\nthe ReaderAt.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*FatFile, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r]\n\nJoker return type: [(atom-of go.std.debug.macho/FatFile) Error]"
;;   {:added "1.0"
;;    :go "__newFatFile(*_r)"}
;;   [^io/ReaderAt _r])

JOKER FUNC debug/macho.NewFile from debug/macho/file.go:
;; (defn NewFile
;;   "NewFile creates a new File for accessing a Mach-O binary in an underlying reader.\nThe Mach-O binary is expected to start at position 0 in the ReaderAt.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r]\n\nJoker return type: [(atom-of go.std.debug.macho/File) Error]"
;;   {:added "1.0"
;;    :go "__newFile(*_r)"}
;;   [^io/ReaderAt _r])

JOKER FUNC debug/macho.Open from debug/macho/file.go:
(defn Open
  "Open opens the named file using os.Open and prepares it for use as a Mach-O binary.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.debug.macho/File) Error]"
  {:added "1.0"
   :go "__open(_name)"}
  [^String _name])

JOKER FUNC debug/macho.OpenFat from debug/macho/fat.go:
(defn OpenFat
  "OpenFat opens the named file using os.Open and prepares it for use as a Mach-O\nuniversal binary.\n\nGo input arguments: (name string)\n\nGo return type: (*FatFile, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.debug.macho/FatFile) Error]"
  {:added "1.0"
   :go "__openFat(_name)"}
  [^String _name])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the debug/macho package."
    :empty false}
  go.std.debug.macho)
JOKER TYPE debug/pe.COFFSymbol from debug/pe/symbol.go:
(defn ^"GoObject" COFFSymbol.
  "Constructor for pe.COFFSymbol"
  {:added "1.0"
   :go "_ConstructCOFFSymbol(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.DataDirectory from debug/pe/pe.go:
(defn ^"GoObject" DataDirectory.
  "Constructor for pe.DataDirectory"
  {:added "1.0"
   :go "_ConstructDataDirectory(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.File from debug/pe/file.go:
(defn ^"GoObject" File.
  "Constructor for pe.File"
  {:added "1.0"
   :go "_ConstructFile(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.FileHeader from debug/pe/pe.go:
(defn ^"GoObject" FileHeader.
  "Constructor for pe.FileHeader"
  {:added "1.0"
   :go "_ConstructFileHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.FormatError from debug/pe/file.go:
(defn ^"GoObject" FormatError.
  "Constructor for pe.FormatError"
  {:added "1.0"
   :go "_ConstructFormatError(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.ImportDirectory from debug/pe/file.go:
(defn ^"GoObject" ImportDirectory.
  "Constructor for pe.ImportDirectory"
  {:added "1.0"
   :go "_ConstructImportDirectory(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.OptionalHeader32 from debug/pe/pe.go:
(defn ^"GoObject" OptionalHeader32.
  "Constructor for pe.OptionalHeader32"
  {:added "1.0"
   :go "_ConstructOptionalHeader32(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.OptionalHeader64 from debug/pe/pe.go:
(defn ^"GoObject" OptionalHeader64.
  "Constructor for pe.OptionalHeader64"
  {:added "1.0"
   :go "_ConstructOptionalHeader64(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.Reloc from debug/pe/section.go:
(defn ^"GoObject" Reloc.
  "Constructor for pe.Reloc"
  {:added "1.0"
   :go "_ConstructReloc(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.Section from debug/pe/section.go:
(defn ^"GoObject" Section.
  "Constructor for pe.Section"
  {:added "1.0"
   :go "_ConstructSection(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.SectionHeader from debug/pe/section.go:
(defn ^"GoObject" SectionHeader.
  "Constructor for pe.SectionHeader"
  {:added "1.0"
   :go "_ConstructSectionHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.SectionHeader32 from debug/pe/section.go:
(defn ^"GoObject" SectionHeader32.
  "Constructor for pe.SectionHeader32"
  {:added "1.0"
   :go "_ConstructSectionHeader32(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.StringTable from debug/pe/string.go:
;; (defn ^"GoObject" StringTable.
;;   "Constructor for pe.StringTable"
;;   {:added "1.0"
;;    :go "_ConstructStringTable(_v)"}
;;   [^Object _v])

JOKER TYPE debug/pe.Symbol from debug/pe/symbol.go:
(defn ^"GoObject" Symbol.
  "Constructor for pe.Symbol"
  {:added "1.0"
   :go "_ConstructSymbol(_v)"}
  [^Object _v])

JOKER FUNC debug/pe.NewFile from debug/pe/file.go:
;; (defn NewFile
;;   "NewFile creates a new File for accessing a PE binary in an underlying reader.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r]\n\nJoker return type: [(atom-of go.std.debug.pe/File) Error]"
;;   {:added "1.0"
;;    :go "__newFile(*_r)"}
;;   [^io/ReaderAt _r])

JOKER FUNC debug/pe.Open from debug/pe/file.go:
(defn Open
  "Open opens the named file using os.Open and prepares it for use as a PE binary.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.debug.pe/File) Error]"
  {:added "1.0"
   :go "__open(_name)"}
  [^String _name])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the debug/pe package."
    :empty false}
  go.std.debug.pe)
JOKER TYPE debug/plan9obj.File from debug/plan9obj/file.go:
(defn ^"GoObject" File.
  "Constructor for plan9obj.File"
  {:added "1.0"
   :go "_ConstructFile(_v)"}
  [^Object _v])

JOKER TYPE debug/plan9obj.FileHeader from debug/plan9obj/file.go:
(defn ^"GoObject" FileHeader.
  "Constructor for plan9obj.FileHeader"
  {:added "1.0"
   :go "_ConstructFileHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/plan9obj.Section from debug/plan9obj/file.go:
(defn ^"GoObject" Section.
  "Constructor for plan9obj.Section"
  {:added "1.0"
   :go "_ConstructSection(_v)"}
  [^Object _v])

JOKER TYPE debug/plan9obj.SectionHeader from debug/plan9obj/file.go:
(defn ^"GoObject" SectionHeader.
  "Constructor for plan9obj.SectionHeader"
  {:added "1.0"
   :go "_ConstructSectionHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/plan9obj.Sym from debug/plan9obj/file.go:
(defn ^"GoObject" Sym.
  "Constructor for plan9obj.Sym"
  {:added "1.0"
   :go "_ConstructSym(_v)"}
  [^Object _v])

JOKER FUNC debug/plan9obj.NewFile from debug/plan9obj/file.go:
;; (defn NewFile
;;   "NewFile creates a new File for accessing a Plan 9 binary in an underlying reader.\nThe Plan 9 binary is expected to start at position 0 in the ReaderAt.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r]\n\nJoker return type: [(atom-of go.std.debug.plan9obj/File) Error]"
;;   {:added "1.0"
;;    :go "__newFile(*_r)"}
;;   [^io/ReaderAt _r])

JOKER FUNC debug/plan9obj.Open from debug/plan9obj/file.go:
(defn Open
  "Open opens the named file using os.Open and prepares it for use as a Plan 9 a.out binary.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.debug.plan9obj/File) Error]"
  {:added "1.0"
   :go "__open(_name)"}
  [^String _name])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the debug/plan9obj package."
    :empty false}
  go.std.debug.plan9obj)
JOKER TYPE encoding/ascii85.CorruptInputError from encoding/ascii85/ascii85.go:
(defn ^"GoObject" CorruptInputError.
  "Constructor for ascii85.CorruptInputError"
  {:added "1.0"
   :go "_ConstructCorruptInputError(_v)"}
  [^Object _v])

JOKER FUNC encoding/ascii85.Decode from encoding/ascii85/ascii85.go:
;; (defn Decode
;;   "Decode decodes src into dst, returning both the number\nof bytes written to dst and the number consumed from src.\nIf src contains invalid ascii85 data, Decode will return the\nnumber of bytes successfully written and a CorruptInputError.\nDecode ignores space and control characters in src.\nOften, ascii85-encoded data is wrapped in <~ and ~> symbols.\nDecode expects these to have been stripped by the caller.\n\nIf flush is true, Decode assumes that src represents the\nend of the input stream and processes it completely rather\nthan wait for the completion of another 32-bit block.\n\nNewDecoder wraps an io.Reader interface around Decode.\n\nGo input arguments: (dst []byte, src []byte, flush bool)\n\nGo return type: (ndst int, nsrc int, err error)\n\nJoker input arguments: [^(vector-of Byte) dst, ^(vector-of Byte) src, ^Boolean flush]\n\nJoker return type: [Int Int Error]"
;;   {:added "1.0"
;;    :go "__decode(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_src)), _flush)"}
;;   [^Object _dst, ^Object _src, ^Boolean _flush])

JOKER FUNC encoding/ascii85.Encode from encoding/ascii85/ascii85.go:
;; (defn ^"Int" Encode
;;   "Encode encodes src into at most MaxEncodedLen(len(src))\nbytes of dst, returning the actual number of bytes written.\n\nThe encoding handles 4-byte chunks, using a special encoding\nfor the last fragment, so Encode is not appropriate for use on\nindividual blocks of a large data stream. Use NewEncoder() instead.\n\nOften, ascii85-encoded data is wrapped in <~ and ~> symbols.\nEncode does not add these.\n\nGo input arguments: (dst []byte, src []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) dst, ^(vector-of Byte) src]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "ascii85.Encode(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_src)))"}
;;   [^Object _dst, ^Object _src])

JOKER FUNC encoding/ascii85.MaxEncodedLen from encoding/ascii85/ascii85.go:
(defn ^"Int" MaxEncodedLen
  "MaxEncodedLen returns the maximum length of an encoding of n source bytes.\n\nGo input arguments: (n int)\n\nGo return type: int\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "ascii85.MaxEncodedLen(_n)"}
  [^Int _n])

JOKER FUNC encoding/ascii85.NewDecoder from encoding/ascii85/ascii85.go:
;; (defn NewDecoder
;;   "NewDecoder constructs a new ascii85 stream decoder.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__newDecoder(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC encoding/ascii85.NewEncoder from encoding/ascii85/ascii85.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new ascii85 stream encoder. Data written to\nthe returned writer will be encoded and then written to w.\nAscii85 encodings operate in 32-bit blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\ntrailing partial block.\n\nGo input arguments: (w io.Writer)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "__newEncoder(*_w)"}
;;   [^io/Writer _w])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["encoding/ascii85"]
    :doc "Provides a low-level interface to the encoding/ascii85 package."
    :empty false}
  go.std.encoding.ascii85)
JOKER FUNC encoding/asn1.Marshal from encoding/asn1/marshal.go:
;; (defn Marshal
;;   "Marshal returns the ASN.1 encoding of val.\n\nIn addition to the struct tags recognised by Unmarshal, the following can be\nused:\n\n\tia5:         causes strings to be marshaled as ASN.1, IA5String values\n\tomitempty:   causes empty slices to be skipped\n\tprintable:   causes strings to be marshaled as ASN.1, PrintableString values\n\tutf8:        causes strings to be marshaled as ASN.1, UTF8String values\n\tutc:         causes time.Time to be marshaled as ASN.1, UTCTime values\n\tgeneralized: causes time.Time to be marshaled as ASN.1, GeneralizedTime values\n\nGo input arguments: (val interface {})\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> val]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshal(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _val])

JOKER FUNC encoding/asn1.MarshalWithParams from encoding/asn1/marshal.go:
;; (defn MarshalWithParams
;;   "MarshalWithParams allows field parameters to be specified for the\ntop-level element. The form of the params is the same as the field tags.\n\nGo input arguments: (val interface {}, params string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> val, ^String params]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshalWithParams(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), _params)"}
;;   [^<protocol-or-something> _val, ^String _params])

JOKER FUNC encoding/asn1.Unmarshal from encoding/asn1/asn1.go:
;; (defn Unmarshal
;;   "Unmarshal parses the DER-encoded ASN.1 data structure b\nand uses the reflect package to fill in an arbitrary value pointed at by val.\nBecause Unmarshal uses the reflect package, the structs\nbeing written to must use upper case field names.\n\nAn ASN.1 INTEGER can be written to an int, int32, int64,\nor *big.Int (from the math/big package).\nIf the encoded value does not fit in the Go type,\nUnmarshal returns a parse error.\n\nAn ASN.1 BIT STRING can be written to a BitString.\n\nAn ASN.1 OCTET STRING can be written to a []byte.\n\nAn ASN.1 OBJECT IDENTIFIER can be written to an\nObjectIdentifier.\n\nAn ASN.1 ENUMERATED can be written to an Enumerated.\n\nAn ASN.1 UTCTIME or GENERALIZEDTIME can be written to a time.Time.\n\nAn ASN.1 PrintableString, IA5String, or NumericString can be written to a string.\n\nAny of the above ASN.1 values can be written to an interface{}.\nThe value stored in the interface has the corresponding Go type.\nFor integers, that type is int64.\n\nAn ASN.1 SEQUENCE OF x or SET OF x can be written\nto a slice if an x can be written to the slice's element type.\n\nAn ASN.1 SEQUENCE or SET can be written to a struct\nif each of the elements in the sequence can be\nwritten to the corresponding element in the struct.\n\nThe following tags on struct fields have special meaning to Unmarshal:\n\n\tapplication specifies that an APPLICATION tag is used\n\tprivate     specifies that a PRIVATE tag is used\n\tdefault:x   sets the default value for optional integer fields (only used if optional is also present)\n\texplicit    specifies that an additional, explicit tag wraps the implicit one\n\toptional    marks the field as ASN.1 OPTIONAL\n\tset         causes a SET, rather than a SEQUENCE type to be expected\n\ttag:x       specifies the ASN.1 tag number; implies ASN.1 CONTEXT SPECIFIC\n\nIf the type of the first field of a structure is RawContent then the raw\nASN1 contents of the struct will be stored in it.\n\nIf the type name of a slice element ends with \"SET\" then it's treated as if\nthe \"set\" tag was set on it. This can be used with nested slices where a\nstruct tag cannot be given.\n\nOther ASN.1 types are not supported; if it encounters them,\nUnmarshal returns a parse error.\n\nGo input arguments: (b []byte, val interface {})\n\nGo return type: (rest []byte, err error)\n\nJoker input arguments: [^(vector-of Byte) b, ^<protocol-or-something> val]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__unmarshal(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^Object _b, ^<protocol-or-something> _val])

JOKER FUNC encoding/asn1.UnmarshalWithParams from encoding/asn1/asn1.go:
;; (defn UnmarshalWithParams
;;   "UnmarshalWithParams allows field parameters to be specified for the\ntop-level element. The form of the params is the same as the field tags.\n\nGo input arguments: (b []byte, val interface {}, params string)\n\nGo return type: (rest []byte, err error)\n\nJoker input arguments: [^(vector-of Byte) b, ^<protocol-or-something> val, ^String params]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__unmarshalWithParams(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), _params)"}
;;   [^Object _b, ^<protocol-or-something> _val, ^String _params])

JOKER TYPE encoding/base32.CorruptInputError from encoding/base32/base32.go:
(defn ^"GoObject" CorruptInputError.
  "Constructor for base32.CorruptInputError"
  {:added "1.0"
   :go "_ConstructCorruptInputError(_v)"}
  [^Object _v])

JOKER TYPE encoding/base32.Encoding from encoding/base32/base32.go:
(defn ^"GoObject" Encoding.
  "Constructor for base32.Encoding"
  {:added "1.0"
   :go "_ConstructEncoding(_v)"}
  [^Object _v])

JOKER FUNC encoding/base32.NewDecoder from encoding/base32/base32.go:
;; (defn NewDecoder
;;   "NewDecoder constructs a new base32 stream decoder.\n\nGo input arguments: (enc *Encoding, r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^(atom-of go.std.encoding.base32/Encoding) enc, ^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__newDecoder(_enc, *_r)"}
;;   [^base32/Encoding _enc, ^io/Reader _r])

JOKER FUNC encoding/base32.NewEncoder from encoding/base32/base32.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new base32 stream encoder. Data written to\nthe returned writer will be encoded using enc and then written to w.\nBase32 encodings operate in 5-byte blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\npartially written blocks.\n\nGo input arguments: (enc *Encoding, w io.Writer)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^(atom-of go.std.encoding.base32/Encoding) enc, ^go.std.io/Writer w]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "__newEncoder(_enc, *_w)"}
;;   [^base32/Encoding _enc, ^io/Writer _w])

JOKER FUNC encoding/base32.NewEncoding from encoding/base32/base32.go:
(defn NewEncoding
  "NewEncoding returns a new Encoding defined by the given alphabet,\nwhich must be a 32-byte string.\n\nGo input arguments: (encoder string)\n\nGo return type: *Encoding\n\nJoker input arguments: [^String encoder]\n\nJoker return type: (atom-of go.std.encoding.base32/Encoding)"
  {:added "1.0"
   :go "__newEncoding(_encoder)"}
  [^String _encoder])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the encoding/base32 package."
    :empty false}
  go.std.encoding.base32)
JOKER TYPE encoding/base64.CorruptInputError from encoding/base64/base64.go:
(defn ^"GoObject" CorruptInputError.
  "Constructor for base64.CorruptInputError"
  {:added "1.0"
   :go "_ConstructCorruptInputError(_v)"}
  [^Object _v])

JOKER TYPE encoding/base64.Encoding from encoding/base64/base64.go:
(defn ^"GoObject" Encoding.
  "Constructor for base64.Encoding"
  {:added "1.0"
   :go "_ConstructEncoding(_v)"}
  [^Object _v])

JOKER FUNC encoding/base64.NewDecoder from encoding/base64/base64.go:
;; (defn NewDecoder
;;   "NewDecoder constructs a new base64 stream decoder.\n\nGo input arguments: (enc *Encoding, r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^(atom-of go.std.encoding.base64/Encoding) enc, ^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__newDecoder(_enc, *_r)"}
;;   [^base64/Encoding _enc, ^io/Reader _r])

JOKER FUNC encoding/base64.NewEncoder from encoding/base64/base64.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new base64 stream encoder. Data written to\nthe returned writer will be encoded using enc and then written to w.\nBase64 encodings operate in 4-byte blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\npartially written blocks.\n\nGo input arguments: (enc *Encoding, w io.Writer)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^(atom-of go.std.encoding.base64/Encoding) enc, ^go.std.io/Writer w]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "__newEncoder(_enc, *_w)"}
;;   [^base64/Encoding _enc, ^io/Writer _w])

JOKER FUNC encoding/base64.NewEncoding from encoding/base64/base64.go:
(defn NewEncoding
  "NewEncoding returns a new padded Encoding defined by the given alphabet,\nwhich must be a 64-byte string that does not contain the padding character\nor CR / LF ('\\r', '\\n').\nThe resulting Encoding uses the default padding character ('='),\nwhich may be changed or disabled via WithPadding.\n\nGo input arguments: (encoder string)\n\nGo return type: *Encoding\n\nJoker input arguments: [^String encoder]\n\nJoker return type: (atom-of go.std.encoding.base64/Encoding)"
  {:added "1.0"
   :go "__newEncoding(_encoder)"}
  [^String _encoder])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the encoding/base64 package."
    :empty false}
  go.std.encoding.base64)
JOKER FUNC encoding/binary.PutUvarint from encoding/binary/varint.go:
;; (defn ^"Int" PutUvarint
;;   "PutUvarint encodes a uint64 into buf and returns the number of bytes written.\nIf the buffer is too small, PutUvarint will panic.\n\nGo input arguments: (buf []byte, x uint64)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) buf, ^uint64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "binary.PutUvarint(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)), _x)"}
;;   [^Object _buf, ^ABEND044(pre.go: unsupported built-in type uint64) _x])

JOKER FUNC encoding/binary.PutVarint from encoding/binary/varint.go:
;; (defn ^"Int" PutVarint
;;   "PutVarint encodes an int64 into buf and returns the number of bytes written.\nIf the buffer is too small, PutVarint will panic.\n\nGo input arguments: (buf []byte, x int64)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) buf, ^Int64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "binary.PutVarint(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)), _x)"}
;;   [^Object _buf, ^Int64 _x])

JOKER FUNC encoding/binary.Read from encoding/binary/binary.go:
;; (defn ^"Error" Read
;;   "Read reads structured binary data from r into data.\nData must be a pointer to a fixed-size value or a slice\nof fixed-size values.\nBytes read from r are decoded using the specified byte order\nand written to successive fields of the data.\nWhen decoding boolean values, a zero byte is decoded as false, and\nany other non-zero byte is decoded as true.\nWhen reading into structs, the field data for fields with\nblank (_) field names is skipped; i.e., blank field names\nmay be used for padding.\nWhen reading into a struct, all non-blank fields must be exported\nor Read may panic.\n\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading some but not all the bytes,\nRead returns ErrUnexpectedEOF.\n\nGo input arguments: (r io.Reader, order ByteOrder, data interface {})\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Reader r, ^go.std.encoding.binary/ByteOrder order, ^<protocol-or-something> data]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "binary.Read(*_r, *_order, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io/Reader _r, ^binary/ByteOrder _order, ^<protocol-or-something> _data])

JOKER FUNC encoding/binary.ReadUvarint from encoding/binary/varint.go:
;; (defn ReadUvarint
;;   "ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.\n\nGo input arguments: (r io.ByteReader)\n\nGo return type: (uint64, error)\n\nJoker input arguments: [^go.std.io/ByteReader r]\n\nJoker return type: [BigInt Error]"
;;   {:added "1.0"
;;    :go "__readUvarint(*_r)"}
;;   [^io/ByteReader _r])

JOKER FUNC encoding/binary.ReadVarint from encoding/binary/varint.go:
;; (defn ReadVarint
;;   "ReadVarint reads an encoded signed integer from r and returns it as an int64.\n\nGo input arguments: (r io.ByteReader)\n\nGo return type: (int64, error)\n\nJoker input arguments: [^go.std.io/ByteReader r]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__readVarint(*_r)"}
;;   [^io/ByteReader _r])

JOKER FUNC encoding/binary.Size from encoding/binary/binary.go:
;; (defn ^"Int" Size
;;   "Size returns how many bytes Write would generate to encode the value v, which\nmust be a fixed-size value or a slice of fixed-size values, or a pointer to such data.\nIf v is neither of these, Size returns -1.\n\nGo input arguments: (v interface {})\n\nGo return type: int\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "binary.Size(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC encoding/binary.Uvarint from encoding/binary/varint.go:
;; (defn Uvarint
;;   "Uvarint decodes a uint64 from buf and returns that value and the\nnumber of bytes read (> 0). If an error occurred, the value is 0\nand the number of bytes n is <= 0 meaning:\n\n\tn == 0: buf too small\n\tn  < 0: value larger than 64 bits (overflow)\n\t        and -n is the number of bytes read\n\nGo input arguments: (buf []byte)\n\nGo return type: (uint64, int)\n\nJoker input arguments: [^(vector-of Byte) buf]\n\nJoker return type: [BigInt Int]"
;;   {:added "1.0"
;;    :go "__uvarint(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)))"}
;;   [^Object _buf])

JOKER FUNC encoding/binary.Varint from encoding/binary/varint.go:
;; (defn Varint
;;   "Varint decodes an int64 from buf and returns that value and the\nnumber of bytes read (> 0). If an error occurred, the value is 0\nand the number of bytes n is <= 0 with the following meaning:\n\n\tn == 0: buf too small\n\tn  < 0: value larger than 64 bits (overflow)\n\t        and -n is the number of bytes read\n\nGo input arguments: (buf []byte)\n\nGo return type: (int64, int)\n\nJoker input arguments: [^(vector-of Byte) buf]\n\nJoker return type: [Int Int]"
;;   {:added "1.0"
;;    :go "__varint(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)))"}
;;   [^Object _buf])

JOKER FUNC encoding/binary.Write from encoding/binary/binary.go:
;; (defn ^"Error" Write
;;   "Write writes the binary representation of data into w.\nData must be a fixed-size value or a slice of fixed-size\nvalues, or a pointer to such data.\nBoolean values encode as one byte: 1 for true, and 0 for false.\nBytes written to w are encoded using the specified byte order\nand read from successive fields of the data.\nWhen writing structs, zero values are written for fields\nwith blank (_) field names.\n\nGo input arguments: (w io.Writer, order ByteOrder, data interface {})\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^go.std.encoding.binary/ByteOrder order, ^<protocol-or-something> data]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "binary.Write(*_w, *_order, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io/Writer _w, ^binary/ByteOrder _order, ^<protocol-or-something> _data])

JOKER FUNC encoding/csv.NewReader from encoding/csv/reader.go:
;; (defn NewReader
;;   "NewReader returns a new Reader that reads from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.encoding.csv/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC encoding/csv.NewWriter from encoding/csv/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer that writes to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.encoding.csv/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*_w)"}
;;   [^io/Writer _w])

JOKER FUNC encoding/gob.NewDecoder from encoding/gob/decoder.go:
;; (defn NewDecoder
;;   "NewDecoder returns a new decoder that reads from the io.Reader.\nIf r does not also implement io.ByteReader, it will be wrapped in a\nbufio.Reader.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Decoder\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.encoding.gob/Decoder)"
;;   {:added "1.0"
;;    :go "__newDecoder(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC encoding/gob.NewEncoder from encoding/gob/encoder.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new encoder that will transmit on the io.Writer.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Encoder\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.encoding.gob/Encoder)"
;;   {:added "1.0"
;;    :go "__newEncoder(*_w)"}
;;   [^io/Writer _w])

JOKER FUNC encoding/gob.Register from encoding/gob/type.go:
;; (defn Register
;;   "Register records a type, identified by a value for that type, under its\ninternal type name. That name will identify the concrete type of a value\nsent or received as an interface variable. Only types that will be\ntransferred as implementations of interface values need to be registered.\nExpecting to be used only during initialization, it panics if the mapping\nbetween types and names is not a bijection.\n\nGo input arguments: (value interface {})\n\nJoker input arguments: [^<protocol-or-something> value]"
;;   {:added "1.0"
;;    :go "__register(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _value])

JOKER FUNC encoding/gob.RegisterName from encoding/gob/type.go:
;; (defn RegisterName
;;   "RegisterName is like Register but uses the provided name rather than the\ntype's default.\n\nGo input arguments: (name string, value interface {})\n\nJoker input arguments: [^String name, ^<protocol-or-something> value]"
;;   {:added "1.0"
;;    :go "__registerName(_name, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^String _name, ^<protocol-or-something> _value])

JOKER TYPE encoding/hex.InvalidByteError from encoding/hex/hex.go:
(defn ^"GoObject" InvalidByteError.
  "Constructor for hex.InvalidByteError"
  {:added "1.0"
   :go "_ConstructInvalidByteError(_v)"}
  [^Object _v])

JOKER FUNC encoding/hex.Decode from encoding/hex/hex.go:
;; (defn Decode
;;   "Decode decodes src into DecodedLen(len(src)) bytes,\nreturning the actual number of bytes written to dst.\n\nDecode expects that src contains only hexadecimal\ncharacters and that src has even length.\nIf the input is malformed, Decode returns the number\nof bytes decoded before the error.\n\nGo input arguments: (dst []byte, src []byte)\n\nGo return type: (int, error)\n\nJoker input arguments: [^(vector-of Byte) dst, ^(vector-of Byte) src]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__decode(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_src)))"}
;;   [^Object _dst, ^Object _src])

JOKER FUNC encoding/hex.DecodeString from encoding/hex/hex.go:
(defn DecodeString
  "DecodeString returns the bytes represented by the hexadecimal string s.\n\nDecodeString expects that src contains only hexadecimal\ncharacters and that src has even length.\nIf the input is malformed, DecodeString returns\nthe bytes decoded before the error.\n\nGo input arguments: (s string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__decodeString(_s)"}
  [^String _s])

JOKER FUNC encoding/hex.DecodedLen from encoding/hex/hex.go:
(defn ^"Int" DecodedLen
  "DecodedLen returns the length of a decoding of x source bytes.\nSpecifically, it returns x / 2.\n\nGo input arguments: (x int)\n\nGo return type: int\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "hex.DecodedLen(_x)"}
  [^Int _x])

JOKER FUNC encoding/hex.Dump from encoding/hex/hex.go:
;; (defn ^"String" Dump
;;   "Dump returns a string that contains a hex dump of the given data. The format\nof the hex dump matches the output of `hexdump -C` on the command line.\n\nGo input arguments: (data []byte)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "hex.Dump(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC encoding/hex.Dumper from encoding/hex/hex.go:
;; (defn Dumper
;;   "Dumper returns a WriteCloser that writes a hex dump of all written data to\nw. The format of the dump matches the output of `hexdump -C` on the command\nline.\n\nGo input arguments: (w io.Writer)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "__dumper(*_w)"}
;;   [^io/Writer _w])

JOKER FUNC encoding/hex.Encode from encoding/hex/hex.go:
;; (defn ^"Int" Encode
;;   "Encode encodes src into EncodedLen(len(src))\nbytes of dst. As a convenience, it returns the number\nof bytes written to dst, but this value is always EncodedLen(len(src)).\nEncode implements hexadecimal encoding.\n\nGo input arguments: (dst []byte, src []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) dst, ^(vector-of Byte) src]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "hex.Encode(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_src)))"}
;;   [^Object _dst, ^Object _src])

JOKER FUNC encoding/hex.EncodeToString from encoding/hex/hex.go:
;; (defn ^"String" EncodeToString
;;   "EncodeToString returns the hexadecimal encoding of src.\n\nGo input arguments: (src []byte)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of Byte) src]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "hex.EncodeToString(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_src)))"}
;;   [^Object _src])

JOKER FUNC encoding/hex.EncodedLen from encoding/hex/hex.go:
(defn ^"Int" EncodedLen
  "EncodedLen returns the length of an encoding of n source bytes.\nSpecifically, it returns n * 2.\n\nGo input arguments: (n int)\n\nGo return type: int\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "hex.EncodedLen(_n)"}
  [^Int _n])

JOKER FUNC encoding/hex.NewDecoder from encoding/hex/hex.go:
;; (defn NewDecoder
;;   "NewDecoder returns an io.Reader that decodes hexadecimal characters from r.\nNewDecoder expects that r contain only an even number of hexadecimal characters.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__newDecoder(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC encoding/hex.NewEncoder from encoding/hex/hex.go:
;; (defn NewEncoder
;;   "NewEncoder returns an io.Writer that writes lowercase hexadecimal characters to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: io.Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: go.std.io/Writer"
;;   {:added "1.0"
;;    :go "__newEncoder(*_w)"}
;;   [^io/Writer _w])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["encoding/hex"]
    :doc "Provides a low-level interface to the encoding/hex package."
    :empty false}
  go.std.encoding.hex)
JOKER FUNC encoding/json.Compact from encoding/json/indent.go:
;; (defn ^"Error" Compact
;;   "Compact appends to dst the JSON-encoded src with\ninsignificant space characters elided.\n\nGo input arguments: (dst *bytes.Buffer, src []byte)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) dst, ^(vector-of Byte) src]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "json.Compact(_dst, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_src)))"}
;;   [^bytes/Buffer _dst, ^Object _src])

JOKER FUNC encoding/json.HTMLEscape from encoding/json/encode.go:
;; (defn HTMLEscape
;;   "HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and U+2029\ncharacters inside string literals changed to \\u003c, \\u003e, \\u0026, \\u2028, \\u2029\nso that the JSON will be safe to embed inside HTML <script> tags.\nFor historical reasons, web browsers don't honor standard HTML\nescaping within <script> tags, so an alternative JSON encoding must\nbe used.\n\nGo input arguments: (dst *bytes.Buffer, src []byte)\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) dst, ^(vector-of Byte) src]"
;;   {:added "1.0"
;;    :go "__hTMLEscape(_dst, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_src)))"}
;;   [^bytes/Buffer _dst, ^Object _src])

JOKER FUNC encoding/json.Indent from encoding/json/indent.go:
;; (defn ^"Error" Indent
;;   "Indent appends to dst an indented form of the JSON-encoded src.\nEach element in a JSON object or array begins on a new,\nindented line beginning with prefix followed by one or more\ncopies of indent according to the indentation nesting.\nThe data appended to dst does not begin with the prefix nor\nany indentation, to make it easier to embed inside other formatted JSON data.\nAlthough leading space characters (space, tab, carriage return, newline)\nat the beginning of src are dropped, trailing space characters\nat the end of src are preserved and copied to dst.\nFor example, if src has no trailing spaces, neither will dst;\nif src ends in a trailing newline, so will dst.\n\nGo input arguments: (dst *bytes.Buffer, src []byte, prefix string, indent string)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) dst, ^(vector-of Byte) src, ^String prefix, ^String indent]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "json.Indent(_dst, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_src)), _prefix, _indent)"}
;;   [^bytes/Buffer _dst, ^Object _src, ^String _prefix, ^String _indent])

JOKER FUNC encoding/json.Marshal from encoding/json/encode.go:
;; (defn Marshal
;;   "Marshal returns the JSON encoding of v.\n\nMarshal traverses the value v recursively.\nIf an encountered value implements the Marshaler interface\nand is not a nil pointer, Marshal calls its MarshalJSON method\nto produce JSON. If no MarshalJSON method is present but the\nvalue implements encoding.TextMarshaler instead, Marshal calls\nits MarshalText method and encodes the result as a JSON string.\nThe nil pointer exception is not strictly necessary\nbut mimics a similar, necessary exception in the behavior of\nUnmarshalJSON.\n\nOtherwise, Marshal uses the following type-dependent default encodings:\n\nBoolean values encode as JSON booleans.\n\nFloating point, integer, and Number values encode as JSON numbers.\n\nString values encode as JSON strings coerced to valid UTF-8,\nreplacing invalid bytes with the Unicode replacement rune.\nThe angle brackets \"<\" and \">\" are escaped to \"\\u003c\" and \"\\u003e\"\nto keep some browsers from misinterpreting JSON output as HTML.\nAmpersand \"&\" is also escaped to \"\\u0026\" for the same reason.\nThis escaping can be disabled using an Encoder that had SetEscapeHTML(false)\ncalled on it.\n\nArray and slice values encode as JSON arrays, except that\n[]byte encodes as a base64-encoded string, and a nil slice\nencodes as the null JSON value.\n\nStruct values encode as JSON objects.\nEach exported struct field becomes a member of the object, using the\nfield name as the object key, unless the field is omitted for one of the\nreasons given below.\n\nThe encoding of each struct field can be customized by the format string\nstored under the \"json\" key in the struct field's tag.\nThe format string gives the name of the field, possibly followed by a\ncomma-separated list of options. The name may be empty in order to\nspecify options without overriding the default field name.\n\nThe \"omitempty\" option specifies that the field should be omitted\nfrom the encoding if the field has an empty value, defined as\nfalse, 0, a nil pointer, a nil interface value, and any empty array,\nslice, map, or string.\n\nAs a special case, if the field tag is \"-\", the field is always omitted.\nNote that a field with name \"-\" can still be generated using the tag \"-,\".\n\nExamples of struct field tags and their meanings:\n\n  // Field appears in JSON as key \"myName\".\n  Field int `json:\"myName\"`\n\n  // Field appears in JSON as key \"myName\" and\n  // the field is omitted from the object if its value is empty,\n  // as defined above.\n  Field int `json:\"myName,omitempty\"`\n\n  // Field appears in JSON as key \"Field\" (the default), but\n  // the field is skipped if empty.\n  // Note the leading comma.\n  Field int `json:\",omitempty\"`\n\n  // Field is ignored by this package.\n  Field int `json:\"-\"`\n\n  // Field appears in JSON as key \"-\".\n  Field int `json:\"-,\"`\n\nThe \"string\" option signals that a field is stored as JSON inside a\nJSON-encoded string. It applies only to fields of string, floating point,\ninteger, or boolean types. This extra level of encoding is sometimes used\nwhen communicating with JavaScript programs:\n\n   Int64String int64 `json:\",string\"`\n\nThe key name will be used if it's a non-empty string consisting of\nonly Unicode letters, digits, and ASCII punctuation except quotation\nmarks, backslash, and comma.\n\nAnonymous struct fields are usually marshaled as if their inner exported fields\nwere fields in the outer struct, subject to the usual Go visibility rules amended\nas described in the next paragraph.\nAn anonymous struct field with a name given in its JSON tag is treated as\nhaving that name, rather than being anonymous.\nAn anonymous struct field of interface type is treated the same as having\nthat type as its name, rather than being anonymous.\n\nThe Go visibility rules for struct fields are amended for JSON when\ndeciding which field to marshal or unmarshal. If there are\nmultiple fields at the same level, and that level is the least\nnested (and would therefore be the nesting level selected by the\nusual Go rules), the following extra rules apply:\n\n1) Of those fields, if any are JSON-tagged, only tagged fields are considered,\neven if there are multiple untagged fields that would otherwise conflict.\n\n2) If there is exactly one field (tagged or not according to the first rule), that is selected.\n\n3) Otherwise there are multiple fields, and all are ignored; no error occurs.\n\nHandling of anonymous struct fields is new in Go 1.1.\nPrior to Go 1.1, anonymous struct fields were ignored. To force ignoring of\nan anonymous struct field in both current and earlier versions, give the field\na JSON tag of \"-\".\n\nMap values encode as JSON objects. The map's key type must either be a\nstring, an integer type, or implement encoding.TextMarshaler. The map keys\nare sorted and used as JSON object keys by applying the following rules,\nsubject to the UTF-8 coercion described for string values above:\n  - string keys are used directly\n  - encoding.TextMarshalers are marshaled\n  - integer keys are converted to strings\n\nPointer values encode as the value pointed to.\nA nil pointer encodes as the null JSON value.\n\nInterface values encode as the value contained in the interface.\nA nil interface value encodes as the null JSON value.\n\nChannel, complex, and function values cannot be encoded in JSON.\nAttempting to encode such a value causes Marshal to return\nan UnsupportedTypeError.\n\nJSON cannot represent cyclic data structures and Marshal does not\nhandle them. Passing cyclic structures to Marshal will result in\nan infinite recursion.\n\nGo input arguments: (v interface {})\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshal(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC encoding/json.MarshalIndent from encoding/json/encode.go:
;; (defn MarshalIndent
;;   "MarshalIndent is like Marshal but applies Indent to format the output.\nEach JSON element in the output will begin on a new line beginning with prefix\nfollowed by one or more copies of indent according to the indentation nesting.\n\nGo input arguments: (v interface {}, prefix string, indent string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> v, ^String prefix, ^String indent]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshalIndent(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), _prefix, _indent)"}
;;   [^<protocol-or-something> _v, ^String _prefix, ^String _indent])

JOKER FUNC encoding/json.NewDecoder from encoding/json/stream.go:
;; (defn NewDecoder
;;   "NewDecoder returns a new decoder that reads from r.\n\nThe decoder introduces its own buffering and may\nread data from r beyond the JSON values requested.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Decoder\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.encoding.json/Decoder)"
;;   {:added "1.0"
;;    :go "__newDecoder(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC encoding/json.NewEncoder from encoding/json/stream.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new encoder that writes to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Encoder\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.encoding.json/Encoder)"
;;   {:added "1.0"
;;    :go "__newEncoder(*_w)"}
;;   [^io/Writer _w])

JOKER FUNC encoding/json.Unmarshal from encoding/json/decode.go:
;; (defn ^"Error" Unmarshal
;;   "Unmarshal parses the JSON-encoded data and stores the result\nin the value pointed to by v. If v is nil or not a pointer,\nUnmarshal returns an InvalidUnmarshalError.\n\nUnmarshal uses the inverse of the encodings that\nMarshal uses, allocating maps, slices, and pointers as necessary,\nwith the following additional rules:\n\nTo unmarshal JSON into a pointer, Unmarshal first handles the case of\nthe JSON being the JSON literal null. In that case, Unmarshal sets\nthe pointer to nil. Otherwise, Unmarshal unmarshals the JSON into\nthe value pointed at by the pointer. If the pointer is nil, Unmarshal\nallocates a new value for it to point to.\n\nTo unmarshal JSON into a value implementing the Unmarshaler interface,\nUnmarshal calls that value's UnmarshalJSON method, including\nwhen the input is a JSON null.\nOtherwise, if the value implements encoding.TextUnmarshaler\nand the input is a JSON quoted string, Unmarshal calls that value's\nUnmarshalText method with the unquoted form of the string.\n\nTo unmarshal JSON into a struct, Unmarshal matches incoming object\nkeys to the keys used by Marshal (either the struct field name or its tag),\npreferring an exact match but also accepting a case-insensitive match. By\ndefault, object keys which don't have a corresponding struct field are\nignored (see Decoder.DisallowUnknownFields for an alternative).\n\nTo unmarshal JSON into an interface value,\nUnmarshal stores one of these in the interface value:\n\n\tbool, for JSON booleans\n\tfloat64, for JSON numbers\n\tstring, for JSON strings\n\t[]interface{}, for JSON arrays\n\tmap[string]interface{}, for JSON objects\n\tnil for JSON null\n\nTo unmarshal a JSON array into a slice, Unmarshal resets the slice length\nto zero and then appends each element to the slice.\nAs a special case, to unmarshal an empty JSON array into a slice,\nUnmarshal replaces the slice with a new empty slice.\n\nTo unmarshal a JSON array into a Go array, Unmarshal decodes\nJSON array elements into corresponding Go array elements.\nIf the Go array is smaller than the JSON array,\nthe additional JSON array elements are discarded.\nIf the JSON array is smaller than the Go array,\nthe additional Go array elements are set to zero values.\n\nTo unmarshal a JSON object into a map, Unmarshal first establishes a map to\nuse. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal\nreuses the existing map, keeping existing entries. Unmarshal then stores\nkey-value pairs from the JSON object into the map. The map's key type must\neither be a string, an integer, or implement encoding.TextUnmarshaler.\n\nIf a JSON value is not appropriate for a given target type,\nor if a JSON number overflows the target type, Unmarshal\nskips that field and completes the unmarshaling as best it can.\nIf no more serious errors are encountered, Unmarshal returns\nan UnmarshalTypeError describing the earliest such error. In any\ncase, it's not guaranteed that all the remaining fields following\nthe problematic one will be unmarshaled into the target object.\n\nThe JSON null value unmarshals into an interface, map, pointer, or slice\nby setting that Go value to nil. Because null is often used in JSON to mean\n``not present,'' unmarshaling a JSON null into any other Go type has no effect\non the value and produces no error.\n\nWhen unmarshaling quoted strings, invalid UTF-8 or\ninvalid UTF-16 surrogate pairs are not treated as an error.\nInstead, they are replaced by the Unicode replacement\ncharacter U+FFFD.\n\nGo input arguments: (data []byte, v interface {})\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) data, ^<protocol-or-something> v]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "json.Unmarshal(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^Object _data, ^<protocol-or-something> _v])

JOKER FUNC encoding/json.Valid from encoding/json/scanner.go:
;; (defn ^"Boolean" Valid
;;   "Valid reports whether data is a valid JSON encoding.\n\nGo input arguments: (data []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "json.Valid(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER TYPE encoding/pem.Block from encoding/pem/pem.go:
(defn ^"GoObject" Block.
  "Constructor for pem.Block"
  {:added "1.0"
   :go "_ConstructBlock(_v)"}
  [^Object _v])

JOKER FUNC encoding/pem.Decode from encoding/pem/pem.go:
;; (defn Decode
;;   "Decode will find the next PEM formatted block (certificate, private key\netc) in the input. It returns that block and the remainder of the input. If\nno PEM data is found, p is nil and the whole of the input is returned in\nrest.\n\nGo input arguments: (data []byte)\n\nGo return type: (p *Block, rest []byte)\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: [(atom-of go.std.encoding.pem/Block) (vector-of Int)]"
;;   {:added "1.0"
;;    :go "__decode(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC encoding/pem.Encode from encoding/pem/pem.go:
;; (defn ^"Error" Encode
;;   "Encode writes the PEM encoding of b to out.\n\nGo input arguments: (out io.Writer, b *Block)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer out, ^(atom-of go.std.encoding.pem/Block) b]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "pem.Encode(*_out, _b)"}
;;   [^io/Writer _out, ^pem/Block _b])

JOKER FUNC encoding/pem.EncodeToMemory from encoding/pem/pem.go:
(defn EncodeToMemory
  "EncodeToMemory returns the PEM encoding of b.\n\nIf b has invalid headers and cannot be encoded,\nEncodeToMemory returns nil. If it is important to\nreport details about this error case, use Encode instead.\n\nGo input arguments: (b *Block)\n\nGo return type: []byte\n\nJoker input arguments: [^(atom-of go.std.encoding.pem/Block) b]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__encodeToMemory(_b)"}
  [^pem/Block _b])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the encoding/pem package."
    :empty false}
  go.std.encoding.pem)
JOKER TYPE encoding/xml.Attr from encoding/xml/xml.go:
(defn ^"GoObject" Attr.
  "Constructor for xml.Attr"
  {:added "1.0"
   :go "_ConstructAttr(_v)"}
  [^Object _v])

JOKER TYPE encoding/xml.CharData from encoding/xml/xml.go:
;; (defn ^"GoObject" CharData.
;;   "Constructor for xml.CharData"
;;   {:added "1.0"
;;    :go "_ConstructCharData(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.Comment from encoding/xml/xml.go:
;; (defn ^"GoObject" Comment.
;;   "Constructor for xml.Comment"
;;   {:added "1.0"
;;    :go "_ConstructComment(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.Decoder from encoding/xml/xml.go:
(defn ^"GoObject" Decoder.
  "Constructor for xml.Decoder"
  {:added "1.0"
   :go "_ConstructDecoder(_v)"}
  [^Object _v])

JOKER TYPE encoding/xml.Directive from encoding/xml/xml.go:
;; (defn ^"GoObject" Directive.
;;   "Constructor for xml.Directive"
;;   {:added "1.0"
;;    :go "_ConstructDirective(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.Encoder from encoding/xml/marshal.go:
(defn ^"GoObject" Encoder.
  "Constructor for xml.Encoder"
  {:added "1.0"
   :go "_ConstructEncoder(_v)"}
  [^Object _v])

JOKER TYPE encoding/xml.EndElement from encoding/xml/xml.go:
(defn ^"GoObject" EndElement.
  "Constructor for xml.EndElement"
  {:added "1.0"
   :go "_ConstructEndElement(_v)"}
  [^Object _v])

JOKER TYPE encoding/xml.Marshaler from encoding/xml/marshal.go:
;; (defn ^"GoObject" Marshaler.
;;   "Constructor for xml.Marshaler"
;;   {:added "1.0"
;;    :go "_ConstructMarshaler(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.MarshalerAttr from encoding/xml/marshal.go:
;; (defn ^"GoObject" MarshalerAttr.
;;   "Constructor for xml.MarshalerAttr"
;;   {:added "1.0"
;;    :go "_ConstructMarshalerAttr(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.Name from encoding/xml/xml.go:
(defn ^"GoObject" Name.
  "Constructor for xml.Name"
  {:added "1.0"
   :go "_ConstructName(_v)"}
  [^Object _v])

JOKER TYPE encoding/xml.ProcInst from encoding/xml/xml.go:
(defn ^"GoObject" ProcInst.
  "Constructor for xml.ProcInst"
  {:added "1.0"
   :go "_ConstructProcInst(_v)"}
  [^Object _v])

JOKER TYPE encoding/xml.StartElement from encoding/xml/xml.go:
(defn ^"GoObject" StartElement.
  "Constructor for xml.StartElement"
  {:added "1.0"
   :go "_ConstructStartElement(_v)"}
  [^Object _v])

JOKER TYPE encoding/xml.SyntaxError from encoding/xml/xml.go:
(defn ^"GoObject" SyntaxError.
  "Constructor for xml.SyntaxError"
  {:added "1.0"
   :go "_ConstructSyntaxError(_v)"}
  [^Object _v])

JOKER TYPE encoding/xml.TagPathError from encoding/xml/typeinfo.go:
(defn ^"GoObject" TagPathError.
  "Constructor for xml.TagPathError"
  {:added "1.0"
   :go "_ConstructTagPathError(_v)"}
  [^Object _v])

JOKER TYPE encoding/xml.Token from encoding/xml/xml.go:
;; (defn ^"GoObject" Token.
;;   "Constructor for xml.Token"
;;   {:added "1.0"
;;    :go "_ConstructToken(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.TokenReader from encoding/xml/xml.go:
;; (defn ^"GoObject" TokenReader.
;;   "Constructor for xml.TokenReader"
;;   {:added "1.0"
;;    :go "_ConstructTokenReader(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.UnmarshalError from encoding/xml/read.go:
(defn ^"GoObject" UnmarshalError.
  "Constructor for xml.UnmarshalError"
  {:added "1.0"
   :go "_ConstructUnmarshalError(_v)"}
  [^Object _v])

JOKER TYPE encoding/xml.Unmarshaler from encoding/xml/read.go:
;; (defn ^"GoObject" Unmarshaler.
;;   "Constructor for xml.Unmarshaler"
;;   {:added "1.0"
;;    :go "_ConstructUnmarshaler(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.UnmarshalerAttr from encoding/xml/read.go:
;; (defn ^"GoObject" UnmarshalerAttr.
;;   "Constructor for xml.UnmarshalerAttr"
;;   {:added "1.0"
;;    :go "_ConstructUnmarshalerAttr(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.UnsupportedTypeError from encoding/xml/marshal.go:
(defn ^"GoObject" UnsupportedTypeError.
  "Constructor for xml.UnsupportedTypeError"
  {:added "1.0"
   :go "_ConstructUnsupportedTypeError(_v)"}
  [^Object _v])

JOKER FUNC encoding/xml.CopyToken from encoding/xml/xml.go:
(defn CopyToken
  "CopyToken returns a copy of a Token.\n\nGo input arguments: (t Token)\n\nGo return type: Token\n\nJoker input arguments: [^go.std.encoding.xml/Token t]\n\nJoker return type: go.std.encoding.xml/Token"
  {:added "1.0"
   :go "__copyToken(*_t)"}
  [^xml/Token _t])

JOKER FUNC encoding/xml.Escape from encoding/xml/xml.go:
;; (defn Escape
;;   "Escape is like EscapeText but omits the error return value.\nIt is provided for backwards compatibility with Go 1.0.\nCode targeting Go 1.1 or later should use EscapeText.\n\nGo input arguments: (w io.Writer, s []byte)\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Byte) s]"
;;   {:added "1.0"
;;    :go "__escape(*_w, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^io/Writer _w, ^Object _s])

JOKER FUNC encoding/xml.EscapeText from encoding/xml/xml.go:
;; (defn ^"Error" EscapeText
;;   "EscapeText writes to w the properly escaped XML equivalent\nof the plain text data s.\n\nGo input arguments: (w io.Writer, s []byte)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Byte) s]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "xml.EscapeText(*_w, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^io/Writer _w, ^Object _s])

JOKER FUNC encoding/xml.Marshal from encoding/xml/marshal.go:
;; (defn Marshal
;;   "Marshal returns the XML encoding of v.\n\nMarshal handles an array or slice by marshaling each of the elements.\nMarshal handles a pointer by marshaling the value it points at or, if the\npointer is nil, by writing nothing. Marshal handles an interface value by\nmarshaling the value it contains or, if the interface value is nil, by\nwriting nothing. Marshal handles all other data by writing one or more XML\nelements containing the data.\n\nThe name for the XML elements is taken from, in order of preference:\n    - the tag on the XMLName field, if the data is a struct\n    - the value of the XMLName field of type Name\n    - the tag of the struct field used to obtain the data\n    - the name of the struct field used to obtain the data\n    - the name of the marshaled type\n\nThe XML element for a struct contains marshaled elements for each of the\nexported fields of the struct, with these exceptions:\n    - the XMLName field, described above, is omitted.\n    - a field with tag \"-\" is omitted.\n    - a field with tag \"name,attr\" becomes an attribute with\n      the given name in the XML element.\n    - a field with tag \",attr\" becomes an attribute with the\n      field name in the XML element.\n    - a field with tag \",chardata\" is written as character data,\n      not as an XML element.\n    - a field with tag \",cdata\" is written as character data\n      wrapped in one or more <![CDATA[ ... ]]> tags, not as an XML element.\n    - a field with tag \",innerxml\" is written verbatim, not subject\n      to the usual marshaling procedure.\n    - a field with tag \",comment\" is written as an XML comment, not\n      subject to the usual marshaling procedure. It must not contain\n      the \"--\" string within it.\n    - a field with a tag including the \"omitempty\" option is omitted\n      if the field value is empty. The empty values are false, 0, any\n      nil pointer or interface value, and any array, slice, map, or\n      string of length zero.\n    - an anonymous struct field is handled as if the fields of its\n      value were part of the outer struct.\n\nIf a field uses a tag \"a>b>c\", then the element c will be nested inside\nparent elements a and b. Fields that appear next to each other that name\nthe same parent will be enclosed in one XML element.\n\nIf the XML name for a struct field is defined by both the field tag and the\nstruct's XMLName field, the names must match.\n\nSee MarshalIndent for an example.\n\nMarshal will return an error if asked to marshal a channel, function, or map.\n\nGo input arguments: (v interface {})\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshal(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC encoding/xml.MarshalIndent from encoding/xml/marshal.go:
;; (defn MarshalIndent
;;   "MarshalIndent works like Marshal, but each XML element begins on a new\nindented line that starts with prefix and is followed by one or more\ncopies of indent according to the nesting depth.\n\nGo input arguments: (v interface {}, prefix string, indent string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> v, ^String prefix, ^String indent]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshalIndent(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), _prefix, _indent)"}
;;   [^<protocol-or-something> _v, ^String _prefix, ^String _indent])

JOKER FUNC encoding/xml.NewDecoder from encoding/xml/xml.go:
;; (defn NewDecoder
;;   "NewDecoder creates a new XML parser reading from r.\nIf r does not implement io.ByteReader, NewDecoder will\ndo its own buffering.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Decoder\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.encoding.xml/Decoder)"
;;   {:added "1.0"
;;    :go "__newDecoder(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC encoding/xml.NewEncoder from encoding/xml/marshal.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new encoder that writes to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Encoder\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.encoding.xml/Encoder)"
;;   {:added "1.0"
;;    :go "__newEncoder(*_w)"}
;;   [^io/Writer _w])

JOKER FUNC encoding/xml.NewTokenDecoder from encoding/xml/xml.go:
(defn NewTokenDecoder
  "NewTokenDecoder creates a new XML parser using an underlying token stream.\n\nGo input arguments: (t TokenReader)\n\nGo return type: *Decoder\n\nJoker input arguments: [^go.std.encoding.xml/TokenReader t]\n\nJoker return type: (atom-of go.std.encoding.xml/Decoder)"
  {:added "1.0"
   :go "__newTokenDecoder(*_t)"}
  [^xml/TokenReader _t])

JOKER FUNC encoding/xml.Unmarshal from encoding/xml/read.go:
;; (defn ^"Error" Unmarshal
;;   "Unmarshal parses the XML-encoded data and stores the result in\nthe value pointed to by v, which must be an arbitrary struct,\nslice, or string. Well-formed data that does not fit into v is\ndiscarded.\n\nBecause Unmarshal uses the reflect package, it can only assign\nto exported (upper case) fields. Unmarshal uses a case-sensitive\ncomparison to match XML element names to tag values and struct\nfield names.\n\nUnmarshal maps an XML element to a struct using the following rules.\nIn the rules, the tag of a field refers to the value associated with the\nkey 'xml' in the struct field's tag (see the example above).\n\n  * If the struct has a field of type []byte or string with tag\n     \",innerxml\", Unmarshal accumulates the raw XML nested inside the\n     element in that field. The rest of the rules still apply.\n\n  * If the struct has a field named XMLName of type Name,\n     Unmarshal records the element name in that field.\n\n  * If the XMLName field has an associated tag of the form\n     \"name\" or \"namespace-URL name\", the XML element must have\n     the given name (and, optionally, name space) or else Unmarshal\n     returns an error.\n\n  * If the XML element has an attribute whose name matches a\n     struct field name with an associated tag containing \",attr\" or\n     the explicit name in a struct field tag of the form \"name,attr\",\n     Unmarshal records the attribute value in that field.\n\n  * If the XML element has an attribute not handled by the previous\n     rule and the struct has a field with an associated tag containing\n     \",any,attr\", Unmarshal records the attribute value in the first\n     such field.\n\n  * If the XML element contains character data, that data is\n     accumulated in the first struct field that has tag \",chardata\".\n     The struct field may have type []byte or string.\n     If there is no such field, the character data is discarded.\n\n  * If the XML element contains comments, they are accumulated in\n     the first struct field that has tag \",comment\".  The struct\n     field may have type []byte or string. If there is no such\n     field, the comments are discarded.\n\n  * If the XML element contains a sub-element whose name matches\n     the prefix of a tag formatted as \"a\" or \"a>b>c\", unmarshal\n     will descend into the XML structure looking for elements with the\n     given names, and will map the innermost elements to that struct\n     field. A tag starting with \">\" is equivalent to one starting\n     with the field name followed by \">\".\n\n  * If the XML element contains a sub-element whose name matches\n     a struct field's XMLName tag and the struct field has no\n     explicit name tag as per the previous rule, unmarshal maps\n     the sub-element to that struct field.\n\n  * If the XML element contains a sub-element whose name matches a\n     field without any mode flags (\",attr\", \",chardata\", etc), Unmarshal\n     maps the sub-element to that struct field.\n\n  * If the XML element contains a sub-element that hasn't matched any\n     of the above rules and the struct has a field with tag \",any\",\n     unmarshal maps the sub-element to that struct field.\n\n  * An anonymous struct field is handled as if the fields of its\n     value were part of the outer struct.\n\n  * A struct field with tag \"-\" is never unmarshaled into.\n\nUnmarshal maps an XML element to a string or []byte by saving the\nconcatenation of that element's character data in the string or\n[]byte. The saved []byte is never nil.\n\nUnmarshal maps an attribute value to a string or []byte by saving\nthe value in the string or slice.\n\nUnmarshal maps an attribute value to an Attr by saving the attribute,\nincluding its name, in the Attr.\n\nUnmarshal maps an XML element or attribute value to a slice by\nextending the length of the slice and mapping the element or attribute\nto the newly created value.\n\nUnmarshal maps an XML element or attribute value to a bool by\nsetting it to the boolean value represented by the string. Whitespace\nis trimmed and ignored.\n\nUnmarshal maps an XML element or attribute value to an integer or\nfloating-point field by setting the field to the result of\ninterpreting the string value in decimal. There is no check for\noverflow. Whitespace is trimmed and ignored.\n\nUnmarshal maps an XML element to a Name by recording the element\nname.\n\nUnmarshal maps an XML element to a pointer by setting the pointer\nto a freshly allocated value and then mapping the element to that value.\n\nA missing element or empty attribute value will be unmarshaled as a zero value.\nIf the field is a slice, a zero value will be appended to the field. Otherwise, the\nfield will be set to its zero value.\n\nGo input arguments: (data []byte, v interface {})\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) data, ^<protocol-or-something> v]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "xml.Unmarshal(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^Object _data, ^<protocol-or-something> _v])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the encoding/xml package."
    :empty false}
  go.std.encoding.xml)
JOKER FUNC errors.New from errors/errors.go:
(defn ^"Error" New
  "New returns an error that formats as the given text.\n\nGo input arguments: (text string)\n\nGo return type: error\n\nJoker input arguments: [^String text]\n\nJoker return type: Error"
  {:added "1.0"
   :go "errors.New(_text)"}
  [^String _text])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["errors"]
    :doc "Provides a low-level interface to the errors package."
    :empty false}
  go.std.errors)
JOKER TYPE expvar.Float from expvar/expvar.go:
(defn ^"GoObject" Float.
  "Constructor for expvar.Float"
  {:added "1.0"
   :go "_ConstructFloat(_v)"}
  [^Object _v])

JOKER TYPE expvar.Func from expvar/expvar.go:
;; (defn ^"GoObject" Func.
;;   "Constructor for expvar.Func"
;;   {:added "1.0"
;;    :go "_ConstructFunc(_v)"}
;;   [^Object _v])

JOKER TYPE expvar.Int from expvar/expvar.go:
(defn ^"GoObject" Int.
  "Constructor for expvar.Int"
  {:added "1.0"
   :go "_ConstructInt(_v)"}
  [^Object _v])

JOKER TYPE expvar.KeyValue from expvar/expvar.go:
(defn ^"GoObject" KeyValue.
  "Constructor for expvar.KeyValue"
  {:added "1.0"
   :go "_ConstructKeyValue(_v)"}
  [^Object _v])

JOKER TYPE expvar.Map from expvar/expvar.go:
(defn ^"GoObject" Map.
  "Constructor for expvar.Map"
  {:added "1.0"
   :go "_ConstructMap(_v)"}
  [^Object _v])

JOKER TYPE expvar.String from expvar/expvar.go:
(defn ^"GoObject" String.
  "Constructor for expvar.String"
  {:added "1.0"
   :go "_ConstructString(_v)"}
  [^Object _v])

JOKER TYPE expvar.Var from expvar/expvar.go:
;; (defn ^"GoObject" Var.
;;   "Constructor for expvar.Var"
;;   {:added "1.0"
;;    :go "_ConstructVar(_v)"}
;;   [^Object _v])

JOKER FUNC expvar.Do from expvar/expvar.go:
;; (defn Do
;;   "Do calls f for each exported variable.\nThe global variable map is locked during the iteration,\nbut existing entries may be concurrently updated.\n\nGo input arguments: (f func)\n\nJoker input arguments: [^fn f]"
;;   {:added "1.0"
;;    :go "__do(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^fn _f])

JOKER FUNC expvar.Get from expvar/expvar.go:
(defn Get
  "Get retrieves a named exported variable. It returns nil if the name has\nnot been registered.\n\nGo input arguments: (name string)\n\nGo return type: Var\n\nJoker input arguments: [^String name]\n\nJoker return type: go.std.expvar/Var"
  {:added "1.0"
   :go "__get(_name)"}
  [^String _name])

JOKER FUNC expvar.Handler from expvar/expvar.go:
(defn Handler
  "Handler returns the expvar HTTP Handler.\n\nThis is only needed to install the handler in a non-standard location.\n\nGo return type: net/http.Handler\n\nJoker input arguments: []\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__handler()"}
  [])

JOKER FUNC expvar.NewFloat from expvar/expvar.go:
(defn NewFloat
  "Go input arguments: (name string)\n\nGo return type: *Float\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.expvar/Float)"
  {:added "1.0"
   :go "__newFloat(_name)"}
  [^String _name])

JOKER FUNC expvar.NewInt from expvar/expvar.go:
(defn NewInt
  "Go input arguments: (name string)\n\nGo return type: *Int\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.expvar/Int)"
  {:added "1.0"
   :go "__newInt(_name)"}
  [^String _name])

JOKER FUNC expvar.NewMap from expvar/expvar.go:
(defn NewMap
  "Go input arguments: (name string)\n\nGo return type: *Map\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.expvar/Map)"
  {:added "1.0"
   :go "__newMap(_name)"}
  [^String _name])

JOKER FUNC expvar.NewString from expvar/expvar.go:
(defn NewString
  "Go input arguments: (name string)\n\nGo return type: *String\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.expvar/String)"
  {:added "1.0"
   :go "__newString(_name)"}
  [^String _name])

JOKER FUNC expvar.Publish from expvar/expvar.go:
;; (defn Publish
;;   "Publish declares a named exported variable. This should be called from a\npackage's init function when it creates its Vars. If the name is already\nregistered then this will log.Panic.\n\nGo input arguments: (name string, v Var)\n\nJoker input arguments: [^String name, ^go.std.expvar/Var v]"
;;   {:added "1.0"
;;    :go "__publish(_name, *_v)"}
;;   [^String _name, ^expvar/Var _v])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the expvar package."
    :empty false}
  go.std.expvar)
JOKER TYPE flag.ErrorHandling from flag/flag.go:
(defn ^"GoObject" ErrorHandling.
  "Constructor for flag.ErrorHandling"
  {:added "1.0"
   :go "_ConstructErrorHandling(_v)"}
  [^Object _v])

JOKER TYPE flag.Flag from flag/flag.go:
(defn ^"GoObject" Flag.
  "Constructor for flag.Flag"
  {:added "1.0"
   :go "_ConstructFlag(_v)"}
  [^Object _v])

JOKER TYPE flag.FlagSet from flag/flag.go:
(defn ^"GoObject" FlagSet.
  "Constructor for flag.FlagSet"
  {:added "1.0"
   :go "_ConstructFlagSet(_v)"}
  [^Object _v])

JOKER TYPE flag.Getter from flag/flag.go:
;; (defn ^"GoObject" Getter.
;;   "Constructor for flag.Getter"
;;   {:added "1.0"
;;    :go "_ConstructGetter(_v)"}
;;   [^Object _v])

JOKER TYPE flag.Value from flag/flag.go:
;; (defn ^"GoObject" Value.
;;   "Constructor for flag.Value"
;;   {:added "1.0"
;;    :go "_ConstructValue(_v)"}
;;   [^Object _v])

JOKER FUNC flag.Arg from flag/flag.go:
(defn ^"String" Arg
  "Arg returns the i'th command-line argument. Arg(0) is the first remaining argument\nafter flags have been processed. Arg returns an empty string if the\nrequested element does not exist.\n\nGo input arguments: (i int)\n\nGo return type: string\n\nJoker input arguments: [^Int i]\n\nJoker return type: String"
  {:added "1.0"
   :go "flag.Arg(_i)"}
  [^Int _i])

JOKER FUNC flag.Args from flag/flag.go:
(defn Args
  "Args returns the non-flag command-line arguments.\n\nGo return type: []string\n\nJoker input arguments: []\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__args()"}
  [])

JOKER FUNC flag.Bool from flag/flag.go:
(defn Bool
  "Bool defines a bool flag with specified name, default value, and usage string.\nThe return value is the address of a bool variable that stores the value of the flag.\n\nGo input arguments: (name string, value bool, usage string)\n\nGo return type: *bool\n\nJoker input arguments: [^String name, ^Boolean value, ^String usage]\n\nJoker return type: (atom-of Boolean)"
  {:added "1.0"
   :go "__bool(_name, _value, _usage)"}
  [^String _name, ^Boolean _value, ^String _usage])

JOKER FUNC flag.BoolVar from flag/flag.go:
;; (defn BoolVar
;;   "BoolVar defines a bool flag with specified name, default value, and usage string.\nThe argument p points to a bool variable in which to store the value of the flag.\n\nGo input arguments: (p *bool, name string, value bool, usage string)\n\nJoker input arguments: [^(atom-of Boolean) p, ^String name, ^Boolean value, ^String usage]"
;;   {:added "1.0"
;;    :go "__boolVar(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfbool(_p)), _name, _value, _usage)"}
;;   [^Object _p, ^String _name, ^Boolean _value, ^String _usage])

JOKER FUNC flag.Duration from flag/flag.go:
;; (defn Duration
;;   "Duration defines a time.Duration flag with specified name, default value, and usage string.\nThe return value is the address of a time.Duration variable that stores the value of the flag.\nThe flag accepts a value acceptable to time.ParseDuration.\n\nGo input arguments: (name string, value time.Duration, usage string)\n\nGo return type: *time.Duration\n\nJoker input arguments: [^String name, ^go.std.time/Duration value, ^String usage]\n\nJoker return type: (atom-of go.std.time/Duration)"
;;   {:added "1.0"
;;    :go "__duration(_name, *_value, _usage)"}
;;   [^String _name, ^time/Duration _value, ^String _usage])

JOKER FUNC flag.DurationVar from flag/flag.go:
;; (defn DurationVar
;;   "DurationVar defines a time.Duration flag with specified name, default value, and usage string.\nThe argument p points to a time.Duration variable in which to store the value of the flag.\nThe flag accepts a value acceptable to time.ParseDuration.\n\nGo input arguments: (p *time.Duration, name string, value time.Duration, usage string)\n\nJoker input arguments: [^(atom-of go.std.time/Duration) p, ^String name, ^go.std.time/Duration value, ^String usage]"
;;   {:added "1.0"
;;    :go "__durationVar(_p, _name, *_value, _usage)"}
;;   [^time/Duration _p, ^String _name, ^time/Duration _value, ^String _usage])

JOKER FUNC flag.Float64 from flag/flag.go:
;; (defn Float64
;;   "Float64 defines a float64 flag with specified name, default value, and usage string.\nThe return value is the address of a float64 variable that stores the value of the flag.\n\nGo input arguments: (name string, value float64, usage string)\n\nGo return type: *...\n\nJoker input arguments: [^String name, ^float64 value, ^String usage]\n\nJoker return type: (atom-of ABEND043(post.go: unsupported built-in type float64))"
;;   {:added "1.0"
;;    :go "__float64(_name, _value, _usage)"}
;;   [^String _name, ^ABEND044(pre.go: unsupported built-in type float64) _value, ^String _usage])

JOKER FUNC flag.Float64Var from flag/flag.go:
;; (defn Float64Var
;;   "Float64Var defines a float64 flag with specified name, default value, and usage string.\nThe argument p points to a float64 variable in which to store the value of the flag.\n\nGo input arguments: (p *float64, name string, value float64, usage string)\n\nJoker input arguments: [^(atom-of float64) p, ^String name, ^float64 value, ^String usage]"
;;   {:added "1.0"
;;    :go "__float64Var(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOffloat64(_p)), _name, _value, _usage)"}
;;   [^Object _p, ^String _name, ^ABEND044(pre.go: unsupported built-in type float64) _value, ^String _usage])

JOKER FUNC flag.Int from flag/flag.go:
(defn Int
  "Int defines an int flag with specified name, default value, and usage string.\nThe return value is the address of an int variable that stores the value of the flag.\n\nGo input arguments: (name string, value int, usage string)\n\nGo return type: *int\n\nJoker input arguments: [^String name, ^Int value, ^String usage]\n\nJoker return type: (atom-of Int)"
  {:added "1.0"
   :go "__int(_name, _value, _usage)"}
  [^String _name, ^Int _value, ^String _usage])

JOKER FUNC flag.Int64 from flag/flag.go:
(defn Int64
  "Int64 defines an int64 flag with specified name, default value, and usage string.\nThe return value is the address of an int64 variable that stores the value of the flag.\n\nGo input arguments: (name string, value int64, usage string)\n\nGo return type: *int64\n\nJoker input arguments: [^String name, ^Int64 value, ^String usage]\n\nJoker return type: (atom-of Int)"
  {:added "1.0"
   :go "__int64(_name, _value, _usage)"}
  [^String _name, ^Int64 _value, ^String _usage])

JOKER FUNC flag.Int64Var from flag/flag.go:
;; (defn Int64Var
;;   "Int64Var defines an int64 flag with specified name, default value, and usage string.\nThe argument p points to an int64 variable in which to store the value of the flag.\n\nGo input arguments: (p *int64, name string, value int64, usage string)\n\nJoker input arguments: [^(atom-of Int64) p, ^String name, ^Int64 value, ^String usage]"
;;   {:added "1.0"
;;    :go "__int64Var(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(_p)), _name, _value, _usage)"}
;;   [^Object _p, ^String _name, ^Int64 _value, ^String _usage])

JOKER FUNC flag.IntVar from flag/flag.go:
;; (defn IntVar
;;   "IntVar defines an int flag with specified name, default value, and usage string.\nThe argument p points to an int variable in which to store the value of the flag.\n\nGo input arguments: (p *int, name string, value int, usage string)\n\nJoker input arguments: [^(atom-of Int) p, ^String name, ^Int value, ^String usage]"
;;   {:added "1.0"
;;    :go "__intVar(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint(_p)), _name, _value, _usage)"}
;;   [^Object _p, ^String _name, ^Int _value, ^String _usage])

JOKER FUNC flag.Lookup from flag/flag.go:
(defn Lookup
  "Lookup returns the Flag structure of the named command-line flag,\nreturning nil if none exists.\n\nGo input arguments: (name string)\n\nGo return type: *Flag\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.flag/Flag)"
  {:added "1.0"
   :go "__lookup(_name)"}
  [^String _name])

JOKER FUNC flag.NArg from flag/flag.go:
(defn ^"Int" NArg
  "NArg is the number of arguments remaining after flags have been processed.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "flag.NArg()"}
  [])

JOKER FUNC flag.NFlag from flag/flag.go:
(defn ^"Int" NFlag
  "NFlag returns the number of command-line flags that have been set.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "flag.NFlag()"}
  [])

JOKER FUNC flag.NewFlagSet from flag/flag.go:
(defn NewFlagSet
  "NewFlagSet returns a new, empty flag set with the specified name and\nerror handling property. If the name is not empty, it will be printed\nin the default usage message and in error messages.\n\nGo input arguments: (name string, errorHandling ErrorHandling)\n\nGo return type: *FlagSet\n\nJoker input arguments: [^String name, ^go.std.flag/ErrorHandling errorHandling]\n\nJoker return type: (atom-of go.std.flag/FlagSet)"
  {:added "1.0"
   :go "__newFlagSet(_name, *_errorHandling)"}
  [^String _name, ^flag/ErrorHandling _errorHandling])

JOKER FUNC flag.Parse from flag/flag.go:
;; (defn Parse
;;   "Parse parses the command-line flags from os.Args[1:]. Must be called\nafter all flags are defined and before flags are accessed by the program.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__parse()"}
;;   [])

JOKER FUNC flag.Parsed from flag/flag.go:
(defn ^"Boolean" Parsed
  "Parsed reports whether the command-line flags have been parsed.\n\nGo return type: bool\n\nJoker input arguments: []\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "flag.Parsed()"}
  [])

JOKER FUNC flag.PrintDefaults from flag/flag.go:
;; (defn PrintDefaults
;;   "PrintDefaults prints, to standard error unless configured otherwise,\na usage message showing the default settings of all defined\ncommand-line flags.\nFor an integer valued flag x, the default output has the form\n\t-x int\n\t\tusage-message-for-x (default 7)\nThe usage message will appear on a separate line for anything but\na bool flag with a one-byte name. For bool flags, the type is\nomitted and if the flag name is one byte the usage message appears\non the same line. The parenthetical default is omitted if the\ndefault is the zero value for the type. The listed type, here int,\ncan be changed by placing a back-quoted name in the flag's usage\nstring; the first such item in the message is taken to be a parameter\nname to show in the message and the back quotes are stripped from\nthe message when displayed. For instance, given\n\tflag.String(\"I\", \"\", \"search `directory` for include files\")\nthe output will be\n\t-I directory\n\t\tsearch directory for include files.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__printDefaults()"}
;;   [])

JOKER FUNC flag.Set from flag/flag.go:
(defn ^"Error" Set
  "Set sets the value of the named command-line flag.\n\nGo input arguments: (name string, value string)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^String value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "flag.Set(_name, _value)"}
  [^String _name, ^String _value])

JOKER FUNC flag.String from flag/flag.go:
(defn String
  "String defines a string flag with specified name, default value, and usage string.\nThe return value is the address of a string variable that stores the value of the flag.\n\nGo input arguments: (name string, value string, usage string)\n\nGo return type: *string\n\nJoker input arguments: [^String name, ^String value, ^String usage]\n\nJoker return type: (atom-of String)"
  {:added "1.0"
   :go "__string(_name, _value, _usage)"}
  [^String _name, ^String _value, ^String _usage])

JOKER FUNC flag.StringVar from flag/flag.go:
;; (defn StringVar
;;   "StringVar defines a string flag with specified name, default value, and usage string.\nThe argument p points to a string variable in which to store the value of the flag.\n\nGo input arguments: (p *string, name string, value string, usage string)\n\nJoker input arguments: [^(atom-of String) p, ^String name, ^String value, ^String usage]"
;;   {:added "1.0"
;;    :go "__stringVar(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfstring(_p)), _name, _value, _usage)"}
;;   [^Object _p, ^String _name, ^String _value, ^String _usage])

JOKER FUNC flag.Uint from flag/flag.go:
(defn Uint
  "Uint defines a uint flag with specified name, default value, and usage string.\nThe return value is the address of a uint variable that stores the value of the flag.\n\nGo input arguments: (name string, value uint, usage string)\n\nGo return type: *uint\n\nJoker input arguments: [^String name, ^UInt value, ^String usage]\n\nJoker return type: (atom-of Int)"
  {:added "1.0"
   :go "__uint(_name, _value, _usage)"}
  [^String _name, ^UInt _value, ^String _usage])

JOKER FUNC flag.Uint64 from flag/flag.go:
;; (defn Uint64
;;   "Uint64 defines a uint64 flag with specified name, default value, and usage string.\nThe return value is the address of a uint64 variable that stores the value of the flag.\n\nGo input arguments: (name string, value uint64, usage string)\n\nGo return type: *uint64\n\nJoker input arguments: [^String name, ^uint64 value, ^String usage]\n\nJoker return type: (atom-of BigInt)"
;;   {:added "1.0"
;;    :go "__uint64(_name, _value, _usage)"}
;;   [^String _name, ^ABEND044(pre.go: unsupported built-in type uint64) _value, ^String _usage])

JOKER FUNC flag.Uint64Var from flag/flag.go:
;; (defn Uint64Var
;;   "Uint64Var defines a uint64 flag with specified name, default value, and usage string.\nThe argument p points to a uint64 variable in which to store the value of the flag.\n\nGo input arguments: (p *uint64, name string, value uint64, usage string)\n\nJoker input arguments: [^(atom-of uint64) p, ^String name, ^uint64 value, ^String usage]"
;;   {:added "1.0"
;;    :go "__uint64Var(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint64(_p)), _name, _value, _usage)"}
;;   [^Object _p, ^String _name, ^ABEND044(pre.go: unsupported built-in type uint64) _value, ^String _usage])

JOKER FUNC flag.UintVar from flag/flag.go:
;; (defn UintVar
;;   "UintVar defines a uint flag with specified name, default value, and usage string.\nThe argument p points to a uint variable in which to store the value of the flag.\n\nGo input arguments: (p *uint, name string, value uint, usage string)\n\nJoker input arguments: [^(atom-of UInt) p, ^String name, ^UInt value, ^String usage]"
;;   {:added "1.0"
;;    :go "__uintVar(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint(_p)), _name, _value, _usage)"}
;;   [^Object _p, ^String _name, ^UInt _value, ^String _usage])

JOKER FUNC flag.UnquoteUsage from flag/flag.go:
(defn UnquoteUsage
  "UnquoteUsage extracts a back-quoted name from the usage\nstring for a flag and returns it and the un-quoted usage.\nGiven \"a `name` to show\" it returns (\"name\", \"a name to show\").\nIf there are no back quotes, the name is an educated guess of the\ntype of the flag's value, or the empty string if the flag is boolean.\n\nGo input arguments: (flag *Flag)\n\nGo return type: (name string, usage string)\n\nJoker input arguments: [^(atom-of go.std.flag/Flag) flag]\n\nJoker return type: [String String]"
  {:added "1.0"
   :go "__unquoteUsage(_flag)"}
  [^flag/Flag _flag])

JOKER FUNC flag.Var from flag/flag.go:
;; (defn Var
;;   "Var defines a flag with the specified name and usage string. The type and\nvalue of the flag are represented by the first argument, of type Value, which\ntypically holds a user-defined implementation of Value. For instance, the\ncaller could create a flag that turns a comma-separated string into a slice\nof strings by giving the slice the methods of Value; in particular, Set would\ndecompose the comma-separated string into the slice.\n\nGo input arguments: (value Value, name string, usage string)\n\nJoker input arguments: [^go.std.flag/Value value, ^String name, ^String usage]"
;;   {:added "1.0"
;;    :go "__var(*_value, _name, _usage)"}
;;   [^flag/Value _value, ^String _name, ^String _usage])

JOKER FUNC flag.Visit from flag/flag.go:
;; (defn Visit
;;   "Visit visits the command-line flags in lexicographical order, calling fn\nfor each. It visits only those flags that have been set.\n\nGo input arguments: (fn func)\n\nJoker input arguments: [^fn fn]"
;;   {:added "1.0"
;;    :go "__visit(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^fn _fn])

JOKER FUNC flag.VisitAll from flag/flag.go:
;; (defn VisitAll
;;   "VisitAll visits the command-line flags in lexicographical order, calling\nfn for each. It visits all flags, even those not set.\n\nGo input arguments: (fn func)\n\nJoker input arguments: [^fn fn]"
;;   {:added "1.0"
;;    :go "__visitAll(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^fn _fn])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["flag"]
    :doc "Provides a low-level interface to the flag package."
    :empty false}
  go.std.flag)
JOKER FUNC fmt.Errorf from fmt/print.go:
;; (defn ^"Error" Errorf
;;   "Errorf formats according to a format specifier and returns the string\nas a value that satisfies error.\n\nGo input arguments: (format string, a ...interface {})\n\nGo return type: error\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "fmt.Errorf(_format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _format, ^<protocol-or-something> _a])

JOKER FUNC fmt.Fprint from fmt/print.go:
;; (defn Fprint
;;   "Fprint formats using the default formats for its operands and writes to w.\nSpaces are added between operands when neither is a string.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (w io.Writer, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Writer w, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__fprint(*_w, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io/Writer _w, ^<protocol-or-something> _a])

JOKER FUNC fmt.Fprintf from fmt/print.go:
;; (defn Fprintf
;;   "Fprintf formats according to a format specifier and writes to w.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (w io.Writer, format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Writer w, ^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__fprintf(*_w, _format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io/Writer _w, ^String _format, ^<protocol-or-something> _a])

JOKER FUNC fmt.Fprintln from fmt/print.go:
;; (defn Fprintln
;;   "Fprintln formats using the default formats for its operands and writes to w.\nSpaces are always added between operands and a newline is appended.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (w io.Writer, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Writer w, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__fprintln(*_w, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io/Writer _w, ^<protocol-or-something> _a])

JOKER FUNC fmt.Fscan from fmt/scan.go:
;; (defn Fscan
;;   "Fscan scans text read from r, storing successive space-separated\nvalues into successive arguments. Newlines count as space. It\nreturns the number of items successfully scanned. If that is less\nthan the number of arguments, err will report why.\n\nGo input arguments: (r io.Reader, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Reader r, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__fscan(*_r, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io/Reader _r, ^<protocol-or-something> _a])

JOKER FUNC fmt.Fscanf from fmt/scan.go:
;; (defn Fscanf
;;   "Fscanf scans text read from r, storing successive space-separated\nvalues into successive arguments as determined by the format. It\nreturns the number of items successfully parsed.\nNewlines in the input must match newlines in the format.\n\nGo input arguments: (r io.Reader, format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Reader r, ^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__fscanf(*_r, _format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io/Reader _r, ^String _format, ^<protocol-or-something> _a])

JOKER FUNC fmt.Fscanln from fmt/scan.go:
;; (defn Fscanln
;;   "Fscanln is similar to Fscan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\n\nGo input arguments: (r io.Reader, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Reader r, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__fscanln(*_r, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io/Reader _r, ^<protocol-or-something> _a])

JOKER FUNC fmt.Print from fmt/print.go:
;; (defn Print
;;   "Print formats using the default formats for its operands and writes to standard output.\nSpaces are added between operands when neither is a string.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__print(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _a])

JOKER FUNC fmt.Printf from fmt/print.go:
;; (defn Printf
;;   "Printf formats according to a format specifier and writes to standard output.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__printf(_format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _format, ^<protocol-or-something> _a])

JOKER FUNC fmt.Println from fmt/print.go:
;; (defn Println
;;   "Println formats using the default formats for its operands and writes to standard output.\nSpaces are always added between operands and a newline is appended.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__println(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _a])

JOKER FUNC fmt.Scan from fmt/scan.go:
;; (defn Scan
;;   "Scan scans text read from standard input, storing successive\nspace-separated values into successive arguments. Newlines count\nas space. It returns the number of items successfully scanned.\nIf that is less than the number of arguments, err will report why.\n\nGo input arguments: (a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__scan(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _a])

JOKER FUNC fmt.Scanf from fmt/scan.go:
;; (defn Scanf
;;   "Scanf scans text read from standard input, storing successive\nspace-separated values into successive arguments as determined by\nthe format. It returns the number of items successfully scanned.\nIf that is less than the number of arguments, err will report why.\nNewlines in the input must match newlines in the format.\nThe one exception: the verb %c always scans the next rune in the\ninput, even if it is a space (or tab etc.) or newline.\n\nGo input arguments: (format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__scanf(_format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _format, ^<protocol-or-something> _a])

JOKER FUNC fmt.Scanln from fmt/scan.go:
;; (defn Scanln
;;   "Scanln is similar to Scan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\n\nGo input arguments: (a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__scanln(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _a])

JOKER FUNC fmt.Sprint from fmt/print.go:
;; (defn ^"String" Sprint
;;   "Sprint formats using the default formats for its operands and returns the resulting string.\nSpaces are added between operands when neither is a string.\n\nGo input arguments: (a ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "fmt.Sprint(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _a])

JOKER FUNC fmt.Sprintf from fmt/print.go:
;; (defn ^"String" Sprintf
;;   "Sprintf formats according to a format specifier and returns the resulting string.\n\nGo input arguments: (format string, a ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "fmt.Sprintf(_format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _format, ^<protocol-or-something> _a])

JOKER FUNC fmt.Sprintln from fmt/print.go:
;; (defn ^"String" Sprintln
;;   "Sprintln formats using the default formats for its operands and returns the resulting string.\nSpaces are always added between operands and a newline is appended.\n\nGo input arguments: (a ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "fmt.Sprintln(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _a])

JOKER FUNC fmt.Sscan from fmt/scan.go:
;; (defn Sscan
;;   "Sscan scans the argument string, storing successive space-separated\nvalues into successive arguments. Newlines count as space. It\nreturns the number of items successfully scanned. If that is less\nthan the number of arguments, err will report why.\n\nGo input arguments: (str string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String str, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__sscan(_str, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _str, ^<protocol-or-something> _a])

JOKER FUNC fmt.Sscanf from fmt/scan.go:
;; (defn Sscanf
;;   "Sscanf scans the argument string, storing successive space-separated\nvalues into successive arguments as determined by the format. It\nreturns the number of items successfully parsed.\nNewlines in the input must match newlines in the format.\n\nGo input arguments: (str string, format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String str, ^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__sscanf(_str, _format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _str, ^String _format, ^<protocol-or-something> _a])

JOKER FUNC fmt.Sscanln from fmt/scan.go:
;; (defn Sscanln
;;   "Sscanln is similar to Sscan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\n\nGo input arguments: (str string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String str, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__sscanln(_str, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _str, ^<protocol-or-something> _a])

JOKER TYPE go/ast.ArrayType from go/ast/ast.go:
(defn ^"GoObject" ArrayType.
  "Constructor for ast.ArrayType"
  {:added "1.0"
   :go "_ConstructArrayType(_v)"}
  [^Object _v])

JOKER TYPE go/ast.AssignStmt from go/ast/ast.go:
(defn ^"GoObject" AssignStmt.
  "Constructor for ast.AssignStmt"
  {:added "1.0"
   :go "_ConstructAssignStmt(_v)"}
  [^Object _v])

JOKER TYPE go/ast.BadDecl from go/ast/ast.go:
(defn ^"GoObject" BadDecl.
  "Constructor for ast.BadDecl"
  {:added "1.0"
   :go "_ConstructBadDecl(_v)"}
  [^Object _v])

JOKER TYPE go/ast.BadExpr from go/ast/ast.go:
(defn ^"GoObject" BadExpr.
  "Constructor for ast.BadExpr"
  {:added "1.0"
   :go "_ConstructBadExpr(_v)"}
  [^Object _v])

JOKER TYPE go/ast.BadStmt from go/ast/ast.go:
(defn ^"GoObject" BadStmt.
  "Constructor for ast.BadStmt"
  {:added "1.0"
   :go "_ConstructBadStmt(_v)"}
  [^Object _v])

JOKER TYPE go/ast.BasicLit from go/ast/ast.go:
(defn ^"GoObject" BasicLit.
  "Constructor for ast.BasicLit"
  {:added "1.0"
   :go "_ConstructBasicLit(_v)"}
  [^Object _v])

JOKER TYPE go/ast.BinaryExpr from go/ast/ast.go:
(defn ^"GoObject" BinaryExpr.
  "Constructor for ast.BinaryExpr"
  {:added "1.0"
   :go "_ConstructBinaryExpr(_v)"}
  [^Object _v])

JOKER TYPE go/ast.BlockStmt from go/ast/ast.go:
(defn ^"GoObject" BlockStmt.
  "Constructor for ast.BlockStmt"
  {:added "1.0"
   :go "_ConstructBlockStmt(_v)"}
  [^Object _v])

JOKER TYPE go/ast.BranchStmt from go/ast/ast.go:
(defn ^"GoObject" BranchStmt.
  "Constructor for ast.BranchStmt"
  {:added "1.0"
   :go "_ConstructBranchStmt(_v)"}
  [^Object _v])

JOKER TYPE go/ast.CallExpr from go/ast/ast.go:
(defn ^"GoObject" CallExpr.
  "Constructor for ast.CallExpr"
  {:added "1.0"
   :go "_ConstructCallExpr(_v)"}
  [^Object _v])

JOKER TYPE go/ast.CaseClause from go/ast/ast.go:
(defn ^"GoObject" CaseClause.
  "Constructor for ast.CaseClause"
  {:added "1.0"
   :go "_ConstructCaseClause(_v)"}
  [^Object _v])

JOKER TYPE go/ast.ChanDir from go/ast/ast.go:
(defn ^"GoObject" ChanDir.
  "Constructor for ast.ChanDir"
  {:added "1.0"
   :go "_ConstructChanDir(_v)"}
  [^Object _v])

JOKER TYPE go/ast.ChanType from go/ast/ast.go:
(defn ^"GoObject" ChanType.
  "Constructor for ast.ChanType"
  {:added "1.0"
   :go "_ConstructChanType(_v)"}
  [^Object _v])

JOKER TYPE go/ast.CommClause from go/ast/ast.go:
(defn ^"GoObject" CommClause.
  "Constructor for ast.CommClause"
  {:added "1.0"
   :go "_ConstructCommClause(_v)"}
  [^Object _v])

JOKER TYPE go/ast.Comment from go/ast/ast.go:
(defn ^"GoObject" Comment.
  "Constructor for ast.Comment"
  {:added "1.0"
   :go "_ConstructComment(_v)"}
  [^Object _v])

JOKER TYPE go/ast.CommentGroup from go/ast/ast.go:
(defn ^"GoObject" CommentGroup.
  "Constructor for ast.CommentGroup"
  {:added "1.0"
   :go "_ConstructCommentGroup(_v)"}
  [^Object _v])

JOKER TYPE go/ast.CommentMap from go/ast/commentmap.go:
;; (defn ^"GoObject" CommentMap.
;;   "Constructor for ast.CommentMap"
;;   {:added "1.0"
;;    :go "_ConstructCommentMap(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.CompositeLit from go/ast/ast.go:
(defn ^"GoObject" CompositeLit.
  "Constructor for ast.CompositeLit"
  {:added "1.0"
   :go "_ConstructCompositeLit(_v)"}
  [^Object _v])

JOKER TYPE go/ast.Decl from go/ast/ast.go:
;; (defn ^"GoObject" Decl.
;;   "Constructor for ast.Decl"
;;   {:added "1.0"
;;    :go "_ConstructDecl(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.DeclStmt from go/ast/ast.go:
(defn ^"GoObject" DeclStmt.
  "Constructor for ast.DeclStmt"
  {:added "1.0"
   :go "_ConstructDeclStmt(_v)"}
  [^Object _v])

JOKER TYPE go/ast.DeferStmt from go/ast/ast.go:
(defn ^"GoObject" DeferStmt.
  "Constructor for ast.DeferStmt"
  {:added "1.0"
   :go "_ConstructDeferStmt(_v)"}
  [^Object _v])

JOKER TYPE go/ast.Ellipsis from go/ast/ast.go:
(defn ^"GoObject" Ellipsis.
  "Constructor for ast.Ellipsis"
  {:added "1.0"
   :go "_ConstructEllipsis(_v)"}
  [^Object _v])

JOKER TYPE go/ast.EmptyStmt from go/ast/ast.go:
(defn ^"GoObject" EmptyStmt.
  "Constructor for ast.EmptyStmt"
  {:added "1.0"
   :go "_ConstructEmptyStmt(_v)"}
  [^Object _v])

JOKER TYPE go/ast.Expr from go/ast/ast.go:
;; (defn ^"GoObject" Expr.
;;   "Constructor for ast.Expr"
;;   {:added "1.0"
;;    :go "_ConstructExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.ExprStmt from go/ast/ast.go:
(defn ^"GoObject" ExprStmt.
  "Constructor for ast.ExprStmt"
  {:added "1.0"
   :go "_ConstructExprStmt(_v)"}
  [^Object _v])

JOKER TYPE go/ast.Field from go/ast/ast.go:
(defn ^"GoObject" Field.
  "Constructor for ast.Field"
  {:added "1.0"
   :go "_ConstructField(_v)"}
  [^Object _v])

JOKER TYPE go/ast.FieldFilter from go/ast/print.go:
;; (defn ^"GoObject" FieldFilter.
;;   "Constructor for ast.FieldFilter"
;;   {:added "1.0"
;;    :go "_ConstructFieldFilter(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.FieldList from go/ast/ast.go:
(defn ^"GoObject" FieldList.
  "Constructor for ast.FieldList"
  {:added "1.0"
   :go "_ConstructFieldList(_v)"}
  [^Object _v])

JOKER TYPE go/ast.File from go/ast/ast.go:
(defn ^"GoObject" File.
  "Constructor for ast.File"
  {:added "1.0"
   :go "_ConstructFile(_v)"}
  [^Object _v])

JOKER TYPE go/ast.Filter from go/ast/filter.go:
;; (defn ^"GoObject" Filter.
;;   "Constructor for ast.Filter"
;;   {:added "1.0"
;;    :go "_ConstructFilter(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.ForStmt from go/ast/ast.go:
(defn ^"GoObject" ForStmt.
  "Constructor for ast.ForStmt"
  {:added "1.0"
   :go "_ConstructForStmt(_v)"}
  [^Object _v])

JOKER TYPE go/ast.FuncDecl from go/ast/ast.go:
(defn ^"GoObject" FuncDecl.
  "Constructor for ast.FuncDecl"
  {:added "1.0"
   :go "_ConstructFuncDecl(_v)"}
  [^Object _v])

JOKER TYPE go/ast.FuncLit from go/ast/ast.go:
(defn ^"GoObject" FuncLit.
  "Constructor for ast.FuncLit"
  {:added "1.0"
   :go "_ConstructFuncLit(_v)"}
  [^Object _v])

JOKER TYPE go/ast.FuncType from go/ast/ast.go:
(defn ^"GoObject" FuncType.
  "Constructor for ast.FuncType"
  {:added "1.0"
   :go "_ConstructFuncType(_v)"}
  [^Object _v])

JOKER TYPE go/ast.GenDecl from go/ast/ast.go:
(defn ^"GoObject" GenDecl.
  "Constructor for ast.GenDecl"
  {:added "1.0"
   :go "_ConstructGenDecl(_v)"}
  [^Object _v])

JOKER TYPE go/ast.GoStmt from go/ast/ast.go:
(defn ^"GoObject" GoStmt.
  "Constructor for ast.GoStmt"
  {:added "1.0"
   :go "_ConstructGoStmt(_v)"}
  [^Object _v])

JOKER TYPE go/ast.Ident from go/ast/ast.go:
(defn ^"GoObject" Ident.
  "Constructor for ast.Ident"
  {:added "1.0"
   :go "_ConstructIdent(_v)"}
  [^Object _v])

JOKER TYPE go/ast.IfStmt from go/ast/ast.go:
(defn ^"GoObject" IfStmt.
  "Constructor for ast.IfStmt"
  {:added "1.0"
   :go "_ConstructIfStmt(_v)"}
  [^Object _v])

JOKER TYPE go/ast.ImportSpec from go/ast/ast.go:
(defn ^"GoObject" ImportSpec.
  "Constructor for ast.ImportSpec"
  {:added "1.0"
   :go "_ConstructImportSpec(_v)"}
  [^Object _v])

JOKER TYPE go/ast.Importer from go/ast/resolve.go:
;; (defn ^"GoObject" Importer.
;;   "Constructor for ast.Importer"
;;   {:added "1.0"
;;    :go "_ConstructImporter(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.IncDecStmt from go/ast/ast.go:
(defn ^"GoObject" IncDecStmt.
  "Constructor for ast.IncDecStmt"
  {:added "1.0"
   :go "_ConstructIncDecStmt(_v)"}
  [^Object _v])

JOKER TYPE go/ast.IndexExpr from go/ast/ast.go:
(defn ^"GoObject" IndexExpr.
  "Constructor for ast.IndexExpr"
  {:added "1.0"
   :go "_ConstructIndexExpr(_v)"}
  [^Object _v])

JOKER TYPE go/ast.InterfaceType from go/ast/ast.go:
(defn ^"GoObject" InterfaceType.
  "Constructor for ast.InterfaceType"
  {:added "1.0"
   :go "_ConstructInterfaceType(_v)"}
  [^Object _v])

JOKER TYPE go/ast.KeyValueExpr from go/ast/ast.go:
(defn ^"GoObject" KeyValueExpr.
  "Constructor for ast.KeyValueExpr"
  {:added "1.0"
   :go "_ConstructKeyValueExpr(_v)"}
  [^Object _v])

JOKER TYPE go/ast.LabeledStmt from go/ast/ast.go:
(defn ^"GoObject" LabeledStmt.
  "Constructor for ast.LabeledStmt"
  {:added "1.0"
   :go "_ConstructLabeledStmt(_v)"}
  [^Object _v])

JOKER TYPE go/ast.MapType from go/ast/ast.go:
(defn ^"GoObject" MapType.
  "Constructor for ast.MapType"
  {:added "1.0"
   :go "_ConstructMapType(_v)"}
  [^Object _v])

JOKER TYPE go/ast.MergeMode from go/ast/filter.go:
(defn ^"GoObject" MergeMode.
  "Constructor for ast.MergeMode"
  {:added "1.0"
   :go "_ConstructMergeMode(_v)"}
  [^Object _v])

JOKER TYPE go/ast.Node from go/ast/ast.go:
;; (defn ^"GoObject" Node.
;;   "Constructor for ast.Node"
;;   {:added "1.0"
;;    :go "_ConstructNode(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.ObjKind from go/ast/scope.go:
(defn ^"GoObject" ObjKind.
  "Constructor for ast.ObjKind"
  {:added "1.0"
   :go "_ConstructObjKind(_v)"}
  [^Object _v])

JOKER TYPE go/ast.Object from go/ast/scope.go:
(defn ^"GoObject" Object.
  "Constructor for ast.Object"
  {:added "1.0"
   :go "_ConstructObject(_v)"}
  [^Object _v])

JOKER TYPE go/ast.Package from go/ast/ast.go:
(defn ^"GoObject" Package.
  "Constructor for ast.Package"
  {:added "1.0"
   :go "_ConstructPackage(_v)"}
  [^Object _v])

JOKER TYPE go/ast.ParenExpr from go/ast/ast.go:
(defn ^"GoObject" ParenExpr.
  "Constructor for ast.ParenExpr"
  {:added "1.0"
   :go "_ConstructParenExpr(_v)"}
  [^Object _v])

JOKER TYPE go/ast.RangeStmt from go/ast/ast.go:
(defn ^"GoObject" RangeStmt.
  "Constructor for ast.RangeStmt"
  {:added "1.0"
   :go "_ConstructRangeStmt(_v)"}
  [^Object _v])

JOKER TYPE go/ast.ReturnStmt from go/ast/ast.go:
(defn ^"GoObject" ReturnStmt.
  "Constructor for ast.ReturnStmt"
  {:added "1.0"
   :go "_ConstructReturnStmt(_v)"}
  [^Object _v])

JOKER TYPE go/ast.Scope from go/ast/scope.go:
(defn ^"GoObject" Scope.
  "Constructor for ast.Scope"
  {:added "1.0"
   :go "_ConstructScope(_v)"}
  [^Object _v])

JOKER TYPE go/ast.SelectStmt from go/ast/ast.go:
(defn ^"GoObject" SelectStmt.
  "Constructor for ast.SelectStmt"
  {:added "1.0"
   :go "_ConstructSelectStmt(_v)"}
  [^Object _v])

JOKER TYPE go/ast.SelectorExpr from go/ast/ast.go:
(defn ^"GoObject" SelectorExpr.
  "Constructor for ast.SelectorExpr"
  {:added "1.0"
   :go "_ConstructSelectorExpr(_v)"}
  [^Object _v])

JOKER TYPE go/ast.SendStmt from go/ast/ast.go:
(defn ^"GoObject" SendStmt.
  "Constructor for ast.SendStmt"
  {:added "1.0"
   :go "_ConstructSendStmt(_v)"}
  [^Object _v])

JOKER TYPE go/ast.SliceExpr from go/ast/ast.go:
(defn ^"GoObject" SliceExpr.
  "Constructor for ast.SliceExpr"
  {:added "1.0"
   :go "_ConstructSliceExpr(_v)"}
  [^Object _v])

JOKER TYPE go/ast.Spec from go/ast/ast.go:
;; (defn ^"GoObject" Spec.
;;   "Constructor for ast.Spec"
;;   {:added "1.0"
;;    :go "_ConstructSpec(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.StarExpr from go/ast/ast.go:
(defn ^"GoObject" StarExpr.
  "Constructor for ast.StarExpr"
  {:added "1.0"
   :go "_ConstructStarExpr(_v)"}
  [^Object _v])

JOKER TYPE go/ast.Stmt from go/ast/ast.go:
;; (defn ^"GoObject" Stmt.
;;   "Constructor for ast.Stmt"
;;   {:added "1.0"
;;    :go "_ConstructStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.StructType from go/ast/ast.go:
(defn ^"GoObject" StructType.
  "Constructor for ast.StructType"
  {:added "1.0"
   :go "_ConstructStructType(_v)"}
  [^Object _v])

JOKER TYPE go/ast.SwitchStmt from go/ast/ast.go:
(defn ^"GoObject" SwitchStmt.
  "Constructor for ast.SwitchStmt"
  {:added "1.0"
   :go "_ConstructSwitchStmt(_v)"}
  [^Object _v])

JOKER TYPE go/ast.TypeAssertExpr from go/ast/ast.go:
(defn ^"GoObject" TypeAssertExpr.
  "Constructor for ast.TypeAssertExpr"
  {:added "1.0"
   :go "_ConstructTypeAssertExpr(_v)"}
  [^Object _v])

JOKER TYPE go/ast.TypeSpec from go/ast/ast.go:
(defn ^"GoObject" TypeSpec.
  "Constructor for ast.TypeSpec"
  {:added "1.0"
   :go "_ConstructTypeSpec(_v)"}
  [^Object _v])

JOKER TYPE go/ast.TypeSwitchStmt from go/ast/ast.go:
(defn ^"GoObject" TypeSwitchStmt.
  "Constructor for ast.TypeSwitchStmt"
  {:added "1.0"
   :go "_ConstructTypeSwitchStmt(_v)"}
  [^Object _v])

JOKER TYPE go/ast.UnaryExpr from go/ast/ast.go:
(defn ^"GoObject" UnaryExpr.
  "Constructor for ast.UnaryExpr"
  {:added "1.0"
   :go "_ConstructUnaryExpr(_v)"}
  [^Object _v])

JOKER TYPE go/ast.ValueSpec from go/ast/ast.go:
(defn ^"GoObject" ValueSpec.
  "Constructor for ast.ValueSpec"
  {:added "1.0"
   :go "_ConstructValueSpec(_v)"}
  [^Object _v])

JOKER TYPE go/ast.Visitor from go/ast/walk.go:
;; (defn ^"GoObject" Visitor.
;;   "Constructor for ast.Visitor"
;;   {:added "1.0"
;;    :go "_ConstructVisitor(_v)"}
;;   [^Object _v])

JOKER FUNC go/ast.FileExports from go/ast/filter.go:
(defn ^"Boolean" FileExports
  "FileExports trims the AST for a Go source file in place such that\nonly exported nodes remain: all top-level identifiers which are not exported\nand their associated information (such as type, initial value, or function\nbody) are removed. Non-exported fields and methods of exported types are\nstripped. The File.Comments list is not changed.\n\nFileExports reports whether there are exported declarations.\n\nGo input arguments: (src *File)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.go.ast/File) src]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "ast.FileExports(_src)"}
  [^ast/File _src])

JOKER FUNC go/ast.FilterDecl from go/ast/filter.go:
(defn ^"Boolean" FilterDecl
  "FilterDecl trims the AST for a Go declaration in place by removing\nall names (including struct field and interface method names, but\nnot from parameter lists) that don't pass through the filter f.\n\nFilterDecl reports whether there are any declared names left after\nfiltering.\n\nGo input arguments: (decl Decl, f Filter)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.ast/Decl decl, ^go.std.go.ast/Filter f]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "ast.FilterDecl(*_decl, *_f)"}
  [^ast/Decl _decl, ^ast/Filter _f])

JOKER FUNC go/ast.FilterFile from go/ast/filter.go:
(defn ^"Boolean" FilterFile
  "FilterFile trims the AST for a Go file in place by removing all\nnames from top-level declarations (including struct field and\ninterface method names, but not from parameter lists) that don't\npass through the filter f. If the declaration is empty afterwards,\nthe declaration is removed from the AST. Import declarations are\nalways removed. The File.Comments list is not changed.\n\nFilterFile reports whether there are any top-level declarations\nleft after filtering.\n\nGo input arguments: (src *File, f Filter)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.go.ast/File) src, ^go.std.go.ast/Filter f]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "ast.FilterFile(_src, *_f)"}
  [^ast/File _src, ^ast/Filter _f])

JOKER FUNC go/ast.FilterPackage from go/ast/filter.go:
(defn ^"Boolean" FilterPackage
  "FilterPackage trims the AST for a Go package in place by removing\nall names from top-level declarations (including struct field and\ninterface method names, but not from parameter lists) that don't\npass through the filter f. If the declaration is empty afterwards,\nthe declaration is removed from the AST. The pkg.Files list is not\nchanged, so that file names and top-level package comments don't get\nlost.\n\nFilterPackage reports whether there are any top-level declarations\nleft after filtering.\n\nGo input arguments: (pkg *Package, f Filter)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.go.ast/Package) pkg, ^go.std.go.ast/Filter f]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "ast.FilterPackage(_pkg, *_f)"}
  [^ast/Package _pkg, ^ast/Filter _f])

JOKER FUNC go/ast.Fprint from go/ast/print.go:
;; (defn ^"Error" Fprint
;;   "Fprint prints the (sub-)tree starting at AST node x to w.\nIf fset != nil, position information is interpreted relative\nto that file set. Otherwise positions are printed as integer\nvalues (file set specific offsets).\n\nA non-nil FieldFilter f may be provided to control the output:\nstruct fields for which f(fieldname, fieldvalue) is true are\nprinted; all others are filtered from the output. Unexported\nstruct fields are never printed.\n\nGo input arguments: (w io.Writer, fset *token.FileSet, x interface {}, f FieldFilter)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^(atom-of go.std.go.token/FileSet) fset, ^<protocol-or-something> x, ^go.std.go.ast/FieldFilter f]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "ast.Fprint(*_w, _fset, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), *_f)"}
;;   [^io/Writer _w, ^token/FileSet _fset, ^<protocol-or-something> _x, ^ast/FieldFilter _f])

JOKER FUNC go/ast.Inspect from go/ast/walk.go:
;; (defn Inspect
;;   "Inspect traverses an AST in depth-first order: It starts by calling\nf(node); node must not be nil. If f returns true, Inspect invokes f\nrecursively for each of the non-nil children of node, followed by a\ncall of f(nil).\n\nGo input arguments: (node Node, f func)\n\nJoker input arguments: [^go.std.go.ast/Node node, ^fn f]"
;;   {:added "1.0"
;;    :go "__inspect(*_node, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^ast/Node _node, ^fn _f])

JOKER FUNC go/ast.IsExported from go/ast/ast.go:
(defn ^"Boolean" IsExported
  "IsExported reports whether name is an exported Go symbol\n(that is, whether it begins with an upper-case letter).\n\nGo input arguments: (name string)\n\nGo return type: bool\n\nJoker input arguments: [^String name]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "ast.IsExported(_name)"}
  [^String _name])

JOKER FUNC go/ast.MergePackageFiles from go/ast/filter.go:
(defn MergePackageFiles
  "MergePackageFiles creates a file AST by merging the ASTs of the\nfiles belonging to a package. The mode flags control merging behavior.\n\nGo input arguments: (pkg *Package, mode MergeMode)\n\nGo return type: *File\n\nJoker input arguments: [^(atom-of go.std.go.ast/Package) pkg, ^go.std.go.ast/MergeMode mode]\n\nJoker return type: (atom-of go.std.go.ast/File)"
  {:added "1.0"
   :go "__mergePackageFiles(_pkg, *_mode)"}
  [^ast/Package _pkg, ^ast/MergeMode _mode])

JOKER FUNC go/ast.NewCommentMap from go/ast/commentmap.go:
;; (defn NewCommentMap
;;   "NewCommentMap creates a new comment map by associating comment groups\nof the comments list with the nodes of the AST specified by node.\n\nA comment group g is associated with a node n if:\n\n  - g starts on the same line as n ends\n  - g starts on the line immediately following n, and there is\n    at least one empty line after g and before the next node\n  - g starts before n and is not associated to the node before n\n    via the previous rules\n\nNewCommentMap tries to associate a comment group to the \"largest\"\nnode possible: For instance, if the comment is a line comment\ntrailing an assignment, the comment is associated with the entire\nassignment rather than just the last operand in the assignment.\n\nGo input arguments: (fset *token.FileSet, node Node, comments []*CommentGroup)\n\nGo return type: CommentMap\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^go.std.go.ast/Node node, ^(vector-of (atom-of go.std.go.ast/CommentGroup)) comments]\n\nJoker return type: go.std.go.ast/CommentMap"
;;   {:added "1.0"
;;    :go "__newCommentMap(_fset, *_node, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_ast.CommentGroup(_comments)))"}
;;   [^token/FileSet _fset, ^ast/Node _node, ^Object _comments])

JOKER FUNC go/ast.NewIdent from go/ast/ast.go:
(defn NewIdent
  "NewIdent creates a new Ident without position.\nUseful for ASTs generated by code other than the Go parser.\n\nGo input arguments: (name string)\n\nGo return type: *Ident\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.go.ast/Ident)"
  {:added "1.0"
   :go "__newIdent(_name)"}
  [^String _name])

JOKER FUNC go/ast.NewObj from go/ast/scope.go:
(defn NewObj
  "NewObj creates a new object of a given kind and name.\n\nGo input arguments: (kind ObjKind, name string)\n\nGo return type: *Object\n\nJoker input arguments: [^go.std.go.ast/ObjKind kind, ^String name]\n\nJoker return type: (atom-of go.std.go.ast/Object)"
  {:added "1.0"
   :go "__newObj(*_kind, _name)"}
  [^ast/ObjKind _kind, ^String _name])

JOKER FUNC go/ast.NewPackage from go/ast/resolve.go:
;; (defn NewPackage
;;   "NewPackage creates a new Package node from a set of File nodes. It resolves\nunresolved identifiers across files and updates each file's Unresolved list\naccordingly. If a non-nil importer and universe scope are provided, they are\nused to resolve identifiers not declared in any of the package files. Any\nremaining unresolved identifiers are reported as undeclared. If the files\nbelong to different packages, one package name is selected and files with\ndifferent package names are reported and then ignored.\nThe result is a package node and a scanner.ErrorList if there were errors.\n\nGo input arguments: (fset *token.FileSet, files map[], importer Importer, universe *Scope)\n\nGo return type: (*Package, error)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^{} files, ^go.std.go.ast/Importer importer, ^(atom-of go.std.go.ast/Scope) universe]\n\nJoker return type: [(atom-of go.std.go.ast/Package) Error]"
;;   {:added "1.0"
;;    :go "__newPackage(_fset, ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa()), *_importer, _universe)"}
;;   [^token/FileSet _fset, ^{} _files, ^ast/Importer _importer, ^ast/Scope _universe])

JOKER FUNC go/ast.NewScope from go/ast/scope.go:
(defn NewScope
  "NewScope creates a new scope nested in the outer scope.\n\nGo input arguments: (outer *Scope)\n\nGo return type: *Scope\n\nJoker input arguments: [^(atom-of go.std.go.ast/Scope) outer]\n\nJoker return type: (atom-of go.std.go.ast/Scope)"
  {:added "1.0"
   :go "__newScope(_outer)"}
  [^ast/Scope _outer])

JOKER FUNC go/ast.NotNilFilter from go/ast/print.go:
;; (defn ^"Boolean" NotNilFilter
;;   "NotNilFilter returns true for field values that are not nil;\nit returns false otherwise.\n\nGo input arguments: (_ string, v reflect.Value)\n\nGo return type: bool\n\nJoker input arguments: [^String _, ^go.std.reflect/Value v]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "ast.NotNilFilter(__, *_v)"}
;;   [^String __, ^reflect/Value _v])

JOKER FUNC go/ast.PackageExports from go/ast/filter.go:
(defn ^"Boolean" PackageExports
  "PackageExports trims the AST for a Go package in place such that\nonly exported nodes remain. The pkg.Files list is not changed, so that\nfile names and top-level package comments don't get lost.\n\nPackageExports reports whether there are exported declarations;\nit returns false otherwise.\n\nGo input arguments: (pkg *Package)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.go.ast/Package) pkg]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "ast.PackageExports(_pkg)"}
  [^ast/Package _pkg])

JOKER FUNC go/ast.Print from go/ast/print.go:
;; (defn ^"Error" Print
;;   "Print prints x to standard output, skipping nil fields.\nPrint(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter).\n\nGo input arguments: (fset *token.FileSet, x interface {})\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^<protocol-or-something> x]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "ast.Print(_fset, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^token/FileSet _fset, ^<protocol-or-something> _x])

JOKER FUNC go/ast.SortImports from go/ast/import.go:
;; (defn SortImports
;;   "SortImports sorts runs of consecutive import lines in import blocks in f.\nIt also removes duplicate imports when it is possible to do so without data loss.\n\nGo input arguments: (fset *token.FileSet, f *File)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^(atom-of go.std.go.ast/File) f]"
;;   {:added "1.0"
;;    :go "__sortImports(_fset, _f)"}
;;   [^token/FileSet _fset, ^ast/File _f])

JOKER FUNC go/ast.Walk from go/ast/walk.go:
;; (defn Walk
;;   "Walk traverses an AST in depth-first order: It starts by calling\nv.Visit(node); node must not be nil. If the visitor w returned by\nv.Visit(node) is not nil, Walk is invoked recursively with visitor\nw for each of the non-nil children of node, followed by a call of\nw.Visit(nil).\n\nGo input arguments: (v Visitor, node Node)\n\nJoker input arguments: [^go.std.go.ast/Visitor v, ^go.std.go.ast/Node node]"
;;   {:added "1.0"
;;    :go "__walk(*_v, *_node)"}
;;   [^ast/Visitor _v, ^ast/Node _node])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/ast"]
    :doc "Provides a low-level interface to the go/ast package."
    :empty false}
  go.std.go.ast)
JOKER TYPE go/build.Context from go/build/build.go:
(defn ^"GoObject" Context.
  "Constructor for build.Context"
  {:added "1.0"
   :go "_ConstructContext(_v)"}
  [^Object _v])

JOKER TYPE go/build.ImportMode from go/build/build.go:
(defn ^"GoObject" ImportMode.
  "Constructor for build.ImportMode"
  {:added "1.0"
   :go "_ConstructImportMode(_v)"}
  [^Object _v])

JOKER TYPE go/build.MultiplePackageError from go/build/build.go:
(defn ^"GoObject" MultiplePackageError.
  "Constructor for build.MultiplePackageError"
  {:added "1.0"
   :go "_ConstructMultiplePackageError(_v)"}
  [^Object _v])

JOKER TYPE go/build.NoGoError from go/build/build.go:
(defn ^"GoObject" NoGoError.
  "Constructor for build.NoGoError"
  {:added "1.0"
   :go "_ConstructNoGoError(_v)"}
  [^Object _v])

JOKER TYPE go/build.Package from go/build/build.go:
(defn ^"GoObject" Package.
  "Constructor for build.Package"
  {:added "1.0"
   :go "_ConstructPackage(_v)"}
  [^Object _v])

JOKER FUNC go/build.ArchChar from go/build/build.go:
(defn ArchChar
  "ArchChar returns \"?\" and an error.\nIn earlier versions of Go, the returned string was used to derive\nthe compiler and linker tool names, the default object file suffix,\nand the default linker output name. As of Go 1.5, those strings\nno longer vary by architecture; they are compile, link, .o, and a.out, respectively.\n\nGo input arguments: (goarch string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String goarch]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__archChar(_goarch)"}
  [^String _goarch])

JOKER FUNC go/build.Import from go/build/build.go:
(defn Import
  "Import is shorthand for Default.Import.\n\nGo input arguments: (path string, srcDir string, mode ImportMode)\n\nGo return type: (*Package, error)\n\nJoker input arguments: [^String path, ^String srcDir, ^go.std.go.build/ImportMode mode]\n\nJoker return type: [(atom-of go.std.go.build/Package) Error]"
  {:added "1.0"
   :go "__import(_path, _srcDir, *_mode)"}
  [^String _path, ^String _srcDir, ^build/ImportMode _mode])

JOKER FUNC go/build.ImportDir from go/build/build.go:
(defn ImportDir
  "ImportDir is shorthand for Default.ImportDir.\n\nGo input arguments: (dir string, mode ImportMode)\n\nGo return type: (*Package, error)\n\nJoker input arguments: [^String dir, ^go.std.go.build/ImportMode mode]\n\nJoker return type: [(atom-of go.std.go.build/Package) Error]"
  {:added "1.0"
   :go "__importDir(_dir, *_mode)"}
  [^String _dir, ^build/ImportMode _mode])

JOKER FUNC go/build.IsLocalImport from go/build/build.go:
(defn ^"Boolean" IsLocalImport
  "IsLocalImport reports whether the import path is\na local import path, like \".\", \"..\", \"./foo\", or \"../foo\".\n\nGo input arguments: (path string)\n\nGo return type: bool\n\nJoker input arguments: [^String path]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "build.IsLocalImport(_path)"}
  [^String _path])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/build"]
    :doc "Provides a low-level interface to the go/build package."
    :empty false}
  go.std.go.build)
JOKER TYPE go/constant.Kind from go/constant/value.go:
(defn ^"GoObject" Kind.
  "Constructor for constant.Kind"
  {:added "1.0"
   :go "_ConstructKind(_v)"}
  [^Object _v])

JOKER TYPE go/constant.Value from go/constant/value.go:
;; (defn ^"GoObject" Value.
;;   "Constructor for constant.Value"
;;   {:added "1.0"
;;    :go "_ConstructValue(_v)"}
;;   [^Object _v])

JOKER FUNC go/constant.BinaryOp from go/constant/value.go:
;; (defn BinaryOp
;;   "BinaryOp returns the result of the binary expression x op y.\nThe operation must be defined for the operands. If one of the\noperands is Unknown, the result is Unknown.\nBinaryOp doesn't handle comparisons or shifts; use Compare\nor Shift instead.\n\nTo force integer division of Int operands, use op == token.QUO_ASSIGN\ninstead of token.QUO; the result is guaranteed to be Int in this case.\nDivision by zero leads to a run-time panic.\n\nGo input arguments: (x_ Value, op token.Token, y_ Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x_, ^go.std.go.token/Token op, ^go.std.go.constant/Value y_]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "__binaryOp(*_x_, *_op, *_y_)"}
;;   [^constant/Value _x_, ^token/Token _op, ^constant/Value _y_])

JOKER FUNC go/constant.BitLen from go/constant/value.go:
(defn ^"Int" BitLen
  "BitLen returns the number of bits required to represent\nthe absolute value x in binary representation; x must be an Int or an Unknown.\nIf x is Unknown, the result is 0.\n\nGo input arguments: (x Value)\n\nGo return type: int\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "constant.BitLen(*_x)"}
  [^constant/Value _x])

JOKER FUNC go/constant.BoolVal from go/constant/value.go:
(defn ^"Boolean" BoolVal
  "BoolVal returns the Go boolean value of x, which must be a Bool or an Unknown.\nIf x is Unknown, the result is false.\n\nGo input arguments: (x Value)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "constant.BoolVal(*_x)"}
  [^constant/Value _x])

JOKER FUNC go/constant.Bytes from go/constant/value.go:
(defn Bytes
  "Bytes returns the bytes for the absolute value of x in little-\nendian binary representation; x must be an Int.\n\nGo input arguments: (x Value)\n\nGo return type: []byte\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__bytes(*_x)"}
  [^constant/Value _x])

JOKER FUNC go/constant.Compare from go/constant/value.go:
;; (defn ^"Boolean" Compare
;;   "Compare returns the result of the comparison x op y.\nThe comparison must be defined for the operands.\nIf one of the operands is Unknown, the result is\nfalse.\n\nGo input arguments: (x_ Value, op token.Token, y_ Value)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.constant/Value x_, ^go.std.go.token/Token op, ^go.std.go.constant/Value y_]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "constant.Compare(*_x_, *_op, *_y_)"}
;;   [^constant/Value _x_, ^token/Token _op, ^constant/Value _y_])

JOKER FUNC go/constant.Denom from go/constant/value.go:
(defn Denom
  "Denom returns the denominator of x; x must be Int, Float, or Unknown.\nIf x is Unknown, or if it is too large or small to represent as a\nfraction, the result is Unknown. Otherwise the result is an Int >= 1.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__denom(*_x)"}
  [^constant/Value _x])

JOKER FUNC go/constant.Float32Val from go/constant/value.go:
;; (defn Float32Val
;;   "Float32Val is like Float64Val but for float32 instead of float64.\n\nGo input arguments: (x Value)\n\nGo return type: (..., bool)\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: [ABEND043(post.go: unsupported built-in type float32) Boolean]"
;;   {:added "1.0"
;;    :go "__float32Val(*_x)"}
;;   [^constant/Value _x])

JOKER FUNC go/constant.Float64Val from go/constant/value.go:
;; (defn Float64Val
;;   "Float64Val returns the nearest Go float64 value of x and whether the result is exact;\nx must be numeric or an Unknown, but not Complex. For values too small (too close to 0)\nto represent as float64, Float64Val silently underflows to 0. The result sign always\nmatches the sign of x, even for 0.\nIf x is Unknown, the result is (0, false).\n\nGo input arguments: (x Value)\n\nGo return type: (..., bool)\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: [ABEND043(post.go: unsupported built-in type float64) Boolean]"
;;   {:added "1.0"
;;    :go "__float64Val(*_x)"}
;;   [^constant/Value _x])

JOKER FUNC go/constant.Imag from go/constant/value.go:
(defn Imag
  "Imag returns the imaginary part of x, which must be a numeric or unknown value.\nIf x is Unknown, the result is Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__imag(*_x)"}
  [^constant/Value _x])

JOKER FUNC go/constant.Int64Val from go/constant/value.go:
(defn Int64Val
  "Int64Val returns the Go int64 value of x and whether the result is exact;\nx must be an Int or an Unknown. If the result is not exact, its value is undefined.\nIf x is Unknown, the result is (0, false).\n\nGo input arguments: (x Value)\n\nGo return type: (int64, bool)\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: [Int Boolean]"
  {:added "1.0"
   :go "__int64Val(*_x)"}
  [^constant/Value _x])

JOKER FUNC go/constant.MakeBool from go/constant/value.go:
(defn MakeBool
  "MakeBool returns the Bool value for b.\n\nGo input arguments: (b bool)\n\nGo return type: Value\n\nJoker input arguments: [^Boolean b]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__makeBool(_b)"}
  [^Boolean _b])

JOKER FUNC go/constant.MakeFloat64 from go/constant/value.go:
;; (defn MakeFloat64
;;   "MakeFloat64 returns the Float value for x.\nIf x is not finite, the result is an Unknown.\n\nGo input arguments: (x float64)\n\nGo return type: Value\n\nJoker input arguments: [^float64 x]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "__makeFloat64(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC go/constant.MakeFromBytes from go/constant/value.go:
;; (defn MakeFromBytes
;;   "MakeFromBytes returns the Int value given the bytes of its little-endian\nbinary representation. An empty byte slice argument represents 0.\n\nGo input arguments: (bytes []byte)\n\nGo return type: Value\n\nJoker input arguments: [^(vector-of Byte) bytes]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "__makeFromBytes(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_bytes)))"}
;;   [^Object _bytes])

JOKER FUNC go/constant.MakeFromLiteral from go/constant/value.go:
;; (defn MakeFromLiteral
;;   "MakeFromLiteral returns the corresponding integer, floating-point,\nimaginary, character, or string value for a Go literal string. The\ntok value must be one of token.INT, token.FLOAT, token.IMAG,\ntoken.CHAR, or token.STRING. The final argument must be zero.\nIf the literal string syntax is invalid, the result is an Unknown.\n\nGo input arguments: (lit string, tok token.Token, zero uint)\n\nGo return type: Value\n\nJoker input arguments: [^String lit, ^go.std.go.token/Token tok, ^UInt zero]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "__makeFromLiteral(_lit, *_tok, _zero)"}
;;   [^String _lit, ^token/Token _tok, ^UInt _zero])

JOKER FUNC go/constant.MakeImag from go/constant/value.go:
(defn MakeImag
  "MakeImag returns the Complex value x*i;\nx must be Int, Float, or Unknown.\nIf x is Unknown, the result is Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__makeImag(*_x)"}
  [^constant/Value _x])

JOKER FUNC go/constant.MakeInt64 from go/constant/value.go:
(defn MakeInt64
  "MakeInt64 returns the Int value for x.\n\nGo input arguments: (x int64)\n\nGo return type: Value\n\nJoker input arguments: [^Int64 x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__makeInt64(_x)"}
  [^Int64 _x])

JOKER FUNC go/constant.MakeString from go/constant/value.go:
(defn MakeString
  "MakeString returns the String value for s.\n\nGo input arguments: (s string)\n\nGo return type: Value\n\nJoker input arguments: [^String s]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__makeString(_s)"}
  [^String _s])

JOKER FUNC go/constant.MakeUint64 from go/constant/value.go:
;; (defn MakeUint64
;;   "MakeUint64 returns the Int value for x.\n\nGo input arguments: (x uint64)\n\nGo return type: Value\n\nJoker input arguments: [^uint64 x]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "__makeUint64(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint64) _x])

JOKER FUNC go/constant.MakeUnknown from go/constant/value.go:
(defn MakeUnknown
  "MakeUnknown returns the Unknown value.\n\nGo return type: Value\n\nJoker input arguments: []\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__makeUnknown()"}
  [])

JOKER FUNC go/constant.Num from go/constant/value.go:
(defn Num
  "Num returns the numerator of x; x must be Int, Float, or Unknown.\nIf x is Unknown, or if it is too large or small to represent as a\nfraction, the result is Unknown. Otherwise the result is an Int\nwith the same sign as x.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__num(*_x)"}
  [^constant/Value _x])

JOKER FUNC go/constant.Real from go/constant/value.go:
(defn Real
  "Real returns the real part of x, which must be a numeric or unknown value.\nIf x is Unknown, the result is Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__real(*_x)"}
  [^constant/Value _x])

JOKER FUNC go/constant.Shift from go/constant/value.go:
;; (defn Shift
;;   "Shift returns the result of the shift expression x op s\nwith op == token.SHL or token.SHR (<< or >>). x must be\nan Int or an Unknown. If x is Unknown, the result is x.\n\nGo input arguments: (x Value, op token.Token, s uint)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x, ^go.std.go.token/Token op, ^UInt s]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "__shift(*_x, *_op, _s)"}
;;   [^constant/Value _x, ^token/Token _op, ^UInt _s])

JOKER FUNC go/constant.Sign from go/constant/value.go:
(defn ^"Int" Sign
  "Sign returns -1, 0, or 1 depending on whether x < 0, x == 0, or x > 0;\nx must be numeric or Unknown. For complex values x, the sign is 0 if x == 0,\notherwise it is != 0. If x is Unknown, the result is 1.\n\nGo input arguments: (x Value)\n\nGo return type: int\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "constant.Sign(*_x)"}
  [^constant/Value _x])

JOKER FUNC go/constant.StringVal from go/constant/value.go:
(defn ^"String" StringVal
  "StringVal returns the Go string value of x, which must be a String or an Unknown.\nIf x is Unknown, the result is \"\".\n\nGo input arguments: (x Value)\n\nGo return type: string\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: String"
  {:added "1.0"
   :go "constant.StringVal(*_x)"}
  [^constant/Value _x])

JOKER FUNC go/constant.ToComplex from go/constant/value.go:
(defn ToComplex
  "ToComplex converts x to a Complex value if x is representable as a Complex.\nOtherwise it returns an Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__toComplex(*_x)"}
  [^constant/Value _x])

JOKER FUNC go/constant.ToFloat from go/constant/value.go:
(defn ToFloat
  "ToFloat converts x to a Float value if x is representable as a Float.\nOtherwise it returns an Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__toFloat(*_x)"}
  [^constant/Value _x])

JOKER FUNC go/constant.ToInt from go/constant/value.go:
(defn ToInt
  "ToInt converts x to an Int value if x is representable as an Int.\nOtherwise it returns an Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__toInt(*_x)"}
  [^constant/Value _x])

JOKER FUNC go/constant.Uint64Val from go/constant/value.go:
(defn Uint64Val
  "Uint64Val returns the Go uint64 value of x and whether the result is exact;\nx must be an Int or an Unknown. If the result is not exact, its value is undefined.\nIf x is Unknown, the result is (0, false).\n\nGo input arguments: (x Value)\n\nGo return type: (uint64, bool)\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: [BigInt Boolean]"
  {:added "1.0"
   :go "__uint64Val(*_x)"}
  [^constant/Value _x])

JOKER FUNC go/constant.UnaryOp from go/constant/value.go:
;; (defn UnaryOp
;;   "UnaryOp returns the result of the unary expression op y.\nThe operation must be defined for the operand.\nIf prec > 0 it specifies the ^ (xor) result size in bits.\nIf y is Unknown, the result is Unknown.\n\nGo input arguments: (op token.Token, y Value, prec uint)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.token/Token op, ^go.std.go.constant/Value y, ^UInt prec]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "__unaryOp(*_op, *_y, _prec)"}
;;   [^token/Token _op, ^constant/Value _y, ^UInt _prec])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/constant"]
    :doc "Provides a low-level interface to the go/constant package."
    :empty false}
  go.std.go.constant)
JOKER TYPE go/doc.Example from go/doc/example.go:
(defn ^"GoObject" Example.
  "Constructor for doc.Example"
  {:added "1.0"
   :go "_ConstructExample(_v)"}
  [^Object _v])

JOKER TYPE go/doc.Filter from go/doc/filter.go:
;; (defn ^"GoObject" Filter.
;;   "Constructor for doc.Filter"
;;   {:added "1.0"
;;    :go "_ConstructFilter(_v)"}
;;   [^Object _v])

JOKER TYPE go/doc.Func from go/doc/doc.go:
(defn ^"GoObject" Func.
  "Constructor for doc.Func"
  {:added "1.0"
   :go "_ConstructFunc(_v)"}
  [^Object _v])

JOKER TYPE go/doc.Mode from go/doc/doc.go:
(defn ^"GoObject" Mode.
  "Constructor for doc.Mode"
  {:added "1.0"
   :go "_ConstructMode(_v)"}
  [^Object _v])

JOKER TYPE go/doc.Note from go/doc/doc.go:
(defn ^"GoObject" Note.
  "Constructor for doc.Note"
  {:added "1.0"
   :go "_ConstructNote(_v)"}
  [^Object _v])

JOKER TYPE go/doc.Package from go/doc/doc.go:
(defn ^"GoObject" Package.
  "Constructor for doc.Package"
  {:added "1.0"
   :go "_ConstructPackage(_v)"}
  [^Object _v])

JOKER TYPE go/doc.Type from go/doc/doc.go:
(defn ^"GoObject" Type.
  "Constructor for doc.Type"
  {:added "1.0"
   :go "_ConstructType(_v)"}
  [^Object _v])

JOKER TYPE go/doc.Value from go/doc/doc.go:
(defn ^"GoObject" Value.
  "Constructor for doc.Value"
  {:added "1.0"
   :go "_ConstructValue(_v)"}
  [^Object _v])

JOKER FUNC go/doc.Examples from go/doc/example.go:
;; (defn Examples
;;   "Examples returns the examples found in the files, sorted by Name field.\nThe Order fields record the order in which the examples were encountered.\n\nPlayable Examples must be in a package whose name ends in \"_test\".\nAn Example is \"playable\" (the Play field is non-nil) in either of these\ncircumstances:\n  - The example function is self-contained: the function references only\n    identifiers from other packages (or predeclared identifiers, such as\n    \"int\") and the test file does not include a dot import.\n  - The entire test file is the example: the file contains exactly one\n    example function, zero test or benchmark functions, and at least one\n    top-level function, type, variable, or constant declaration other\n    than the example function.\n\nGo input arguments: (files ...*ast.File)\n\nGo return type: []*Example\n\nJoker input arguments: [^(ellipsis-somehow ast/File) files]\n\nJoker return type: (vector-of (atom-of go.std.go.doc/Example))"
;;   {:added "1.0"
;;    :go "__examples(ConvertToEllipsisHaHa*ABEND987(genutils.go: imports not yet supported: ast.File)(_files))"}
;;   [^ast/File _files])

JOKER FUNC go/doc.IsPredeclared from go/doc/reader.go:
(defn ^"Boolean" IsPredeclared
  "IsPredeclared reports whether s is a predeclared identifier.\n\nGo input arguments: (s string)\n\nGo return type: bool\n\nJoker input arguments: [^String s]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "doc.IsPredeclared(_s)"}
  [^String _s])

JOKER FUNC go/doc.New from go/doc/doc.go:
;; (defn New
;;   "New computes the package documentation for the given package AST.\nNew takes ownership of the AST pkg and may edit or overwrite it.\n\nGo input arguments: (pkg *ast.Package, importPath string, mode Mode)\n\nGo return type: *Package\n\nJoker input arguments: [^(atom-of go.std.go.ast/Package) pkg, ^String importPath, ^go.std.go.doc/Mode mode]\n\nJoker return type: (atom-of go.std.go.doc/Package)"
;;   {:added "1.0"
;;    :go "__new(_pkg, _importPath, *_mode)"}
;;   [^ast/Package _pkg, ^String _importPath, ^doc/Mode _mode])

JOKER FUNC go/doc.Synopsis from go/doc/synopsis.go:
(defn ^"String" Synopsis
  "Synopsis returns a cleaned version of the first sentence in s.\nThat sentence ends after the first period followed by space and\nnot preceded by exactly one uppercase letter. The result string\nhas no \\n, \\r, or \\t characters and uses only single spaces between\nwords. If s starts with any of the IllegalPrefixes, the result\nis the empty string.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "doc.Synopsis(_s)"}
  [^String _s])

JOKER FUNC go/doc.ToHTML from go/doc/comment.go:
;; (defn ToHTML
;;   "ToHTML converts comment text to formatted HTML.\nThe comment was prepared by DocReader,\nso it is known not to have leading, trailing blank lines\nnor to have trailing spaces at the end of lines.\nThe comment markers have already been removed.\n\nEach span of unindented non-blank lines is converted into\na single paragraph. There is one exception to the rule: a span that\nconsists of a single line, is followed by another paragraph span,\nbegins with a capital letter, and contains no punctuation\nother than parentheses and commas is formatted as a heading.\n\nA span of indented lines is converted into a <pre> block,\nwith the common indent prefix removed.\n\nURLs in the comment text are converted into links; if the URL also appears\nin the words map, the link is taken from the map (if the corresponding map\nvalue is the empty string, the URL is not converted into a link).\n\nGo identifiers that appear in the words map are italicized; if the corresponding\nmap value is not the empty string, it is considered a URL and the word is converted\ninto a link.\n\nGo input arguments: (w io.Writer, text string, words map[])\n\nJoker input arguments: [^go.std.io/Writer w, ^String text, ^{} words]"
;;   {:added "1.0"
;;    :go "__toHTML(*_w, _text, ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa()))"}
;;   [^io/Writer _w, ^String _text, ^{} _words])

JOKER FUNC go/doc.ToText from go/doc/comment.go:
;; (defn ToText
;;   "ToText prepares comment text for presentation in textual output.\nIt wraps paragraphs of text to width or fewer Unicode code points\nand then prefixes each line with the indent. In preformatted sections\n(such as program text), it prefixes each non-blank line with preIndent.\n\nGo input arguments: (w io.Writer, text string, indent string, preIndent string, width int)\n\nJoker input arguments: [^go.std.io/Writer w, ^String text, ^String indent, ^String preIndent, ^Int width]"
;;   {:added "1.0"
;;    :go "__toText(*_w, _text, _indent, _preIndent, _width)"}
;;   [^io/Writer _w, ^String _text, ^String _indent, ^String _preIndent, ^Int _width])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/doc"]
    :doc "Provides a low-level interface to the go/doc package."
    :empty false}
  go.std.go.doc)
JOKER FUNC go/format.Node from go/format/format.go:
;; (defn ^"Error" Node
;;   "Node formats node in canonical gofmt style and writes the result to dst.\n\nThe node type must be *ast.File, *printer.CommentedNode, []ast.Decl,\n[]ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec,\nor ast.Stmt. Node does not modify node. Imports are not sorted for\nnodes representing partial source files (for instance, if the node is\nnot an *ast.File or a *printer.CommentedNode not wrapping an *ast.File).\n\nThe function may return early (before the entire result is written)\nand return a formatting error, for instance due to an incorrect AST.\n\nGo input arguments: (dst io.Writer, fset *token.FileSet, node interface {})\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer dst, ^(atom-of go.std.go.token/FileSet) fset, ^<protocol-or-something> node]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "format.Node(*_dst, _fset, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io/Writer _dst, ^token/FileSet _fset, ^<protocol-or-something> _node])

JOKER FUNC go/format.Source from go/format/format.go:
;; (defn Source
;;   "Source formats src in canonical gofmt style and returns the result\nor an (I/O or syntax) error. src is expected to be a syntactically\ncorrect Go source file, or a list of Go declarations or statements.\n\nIf src is a partial source file, the leading and trailing space of src\nis applied to the result (such that it has the same leading and trailing\nspace as src), and the result is indented by the same amount as the first\nline of src containing code. Imports are not sorted for partial source files.\n\nGo input arguments: (src []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(vector-of Byte) src]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__source(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_src)))"}
;;   [^Object _src])

JOKER TYPE go/importer.Lookup from go/importer/importer.go:
;; (defn ^"GoObject" Lookup.
;;   "Constructor for importer.Lookup"
;;   {:added "1.0"
;;    :go "_ConstructLookup(_v)"}
;;   [^Object _v])

JOKER FUNC go/importer.Default from go/importer/importer.go:
(defn Default
  "Default returns an Importer for the compiler that built the running binary.\nIf available, the result implements types.ImporterFrom.\n\nGo return type: go/types.Importer\n\nJoker input arguments: []\n\nJoker return type: go.std.go.types/Importer"
  {:added "1.0"
   :go "__default()"}
  [])

JOKER FUNC go/importer.For from go/importer/importer.go:
(defn For
  "For returns an Importer for importing from installed packages\nfor the compilers \"gc\" and \"gccgo\", or for importing directly\nfrom the source if the compiler argument is \"source\". In this\nlatter case, importing may fail under circumstances where the\nexported API is not entirely defined in pure Go source code\n(if the package API depends on cgo-defined entities, the type\nchecker won't have access to those).\n\nIf lookup is nil, the default package lookup mechanism for the\ngiven compiler is used, and the resulting importer attempts\nto resolve relative and absolute import paths to canonical\nimport path IDs before finding the imported file.\n\nIf lookup is non-nil, then the returned importer calls lookup\neach time it needs to resolve an import path. In this mode\nthe importer can only be invoked with canonical import paths\n(not relative or absolute ones); it is assumed that the translation\nto canonical import paths is being done by the client of the\nimporter.\n\nGo input arguments: (compiler string, lookup Lookup)\n\nGo return type: go/types.Importer\n\nJoker input arguments: [^String compiler, ^go.std.go.importer/Lookup lookup]\n\nJoker return type: go.std.go.types/Importer"
  {:added "1.0"
   :go "__for(_compiler, *_lookup)"}
  [^String _compiler, ^importer/Lookup _lookup])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the go/importer package."
    :empty false}
  go.std.go.importer)
JOKER TYPE go/parser.Mode from go/parser/interface.go:
(defn ^"GoObject" Mode.
  "Constructor for parser.Mode"
  {:added "1.0"
   :go "_ConstructMode(_v)"}
  [^Object _v])

JOKER FUNC go/parser.ParseDir from go/parser/interface.go:
;; (defn ParseDir
;;   "ParseDir calls ParseFile for all files with names ending in \".go\" in the\ndirectory specified by path and returns a map of package name -> package\nAST with all the packages found.\n\nIf filter != nil, only the files with os.FileInfo entries passing through\nthe filter (and ending in \".go\") are considered. The mode bits are passed\nto ParseFile unchanged. Position information is recorded in fset, which\nmust not be nil.\n\nIf the directory couldn't be read, a nil map and the respective error are\nreturned. If a parse error occurred, a non-nil but incomplete map and the\nfirst error encountered are returned.\n\nGo input arguments: (fset *token.FileSet, path string, filter func, mode Mode)\n\nGo return type: (pkgs ..., first error)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^String path, ^fn filter, ^go.std.go.parser/Mode mode]\n\nJoker return type: [ABEND883(post.go: unrecognized Expr type *ast.MapType at: /usr/local/go-1.11.5/src/go/parser/interface.go:135:97) Error]"
;;   {:added "1.0"
;;    :go "__parseDir(_fset, _path, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), *_mode)"}
;;   [^token/FileSet _fset, ^String _path, ^fn _filter, ^parser/Mode _mode])

JOKER FUNC go/parser.ParseExpr from go/parser/interface.go:
(defn ParseExpr
  "ParseExpr is a convenience function for obtaining the AST of an expression x.\nThe position information recorded in the AST is undefined. The filename used\nin error messages is the empty string.\n\nGo input arguments: (x string)\n\nGo return type: (go/ast.Expr, error)\n\nJoker input arguments: [^String x]\n\nJoker return type: [go.std.go.ast/Expr Error]"
  {:added "1.0"
   :go "__parseExpr(_x)"}
  [^String _x])

JOKER FUNC go/parser.ParseExprFrom from go/parser/interface.go:
;; (defn ParseExprFrom
;;   "ParseExprFrom is a convenience function for parsing an expression.\nThe arguments have the same meaning as for ParseFile, but the source must\nbe a valid Go (type or value) expression. Specifically, fset must not\nbe nil.\n\nGo input arguments: (fset *token.FileSet, filename string, src interface {}, mode Mode)\n\nGo return type: (go/ast.Expr, error)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^String filename, ^<protocol-or-something> src, ^go.std.go.parser/Mode mode]\n\nJoker return type: [go.std.go.ast/Expr Error]"
;;   {:added "1.0"
;;    :go "__parseExprFrom(_fset, _filename, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), *_mode)"}
;;   [^token/FileSet _fset, ^String _filename, ^<protocol-or-something> _src, ^parser/Mode _mode])

JOKER FUNC go/parser.ParseFile from go/parser/interface.go:
;; (defn ParseFile
;;   "ParseFile parses the source code of a single Go source file and returns\nthe corresponding ast.File node. The source code may be provided via\nthe filename of the source file, or via the src parameter.\n\nIf src != nil, ParseFile parses the source from src and the filename is\nonly used when recording position information. The type of the argument\nfor the src parameter must be string, []byte, or io.Reader.\nIf src == nil, ParseFile parses the file specified by filename.\n\nThe mode parameter controls the amount of source text parsed and other\noptional parser functionality. Position information is recorded in the\nfile set fset, which must not be nil.\n\nIf the source couldn't be read, the returned AST is nil and the error\nindicates the specific failure. If the source was read but syntax\nerrors were found, the result is a partial AST (with ast.Bad* nodes\nrepresenting the fragments of erroneous source code). Multiple errors\nare returned via a scanner.ErrorList which is sorted by file position.\n\nGo input arguments: (fset *token.FileSet, filename string, src interface {}, mode Mode)\n\nGo return type: (f *go/ast.File, err error)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^String filename, ^<protocol-or-something> src, ^go.std.go.parser/Mode mode]\n\nJoker return type: [(atom-of go.std.go.ast/File) Error]"
;;   {:added "1.0"
;;    :go "__parseFile(_fset, _filename, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), *_mode)"}
;;   [^token/FileSet _fset, ^String _filename, ^<protocol-or-something> _src, ^parser/Mode _mode])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the go/parser package."
    :empty false}
  go.std.go.parser)
JOKER FUNC go/printer.Fprint from go/printer/printer.go:
;; (defn ^"Error" Fprint
;;   "Fprint \"pretty-prints\" an AST node to output.\nIt calls Config.Fprint with default settings.\nNote that gofmt uses tabs for indentation but spaces for alignment;\nuse format.Node (package go/format) for output that matches gofmt.\n\nGo input arguments: (output io.Writer, fset *token.FileSet, node interface {})\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer output, ^(atom-of go.std.go.token/FileSet) fset, ^<protocol-or-something> node]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "printer.Fprint(*_output, _fset, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io/Writer _output, ^token/FileSet _fset, ^<protocol-or-something> _node])

JOKER FUNC go/scanner.PrintError from go/scanner/errors.go:
;; (defn PrintError
;;   "PrintError is a utility function that prints a list of errors to w,\none error per line, if the err parameter is an ErrorList. Otherwise\nit prints the err string.\n\nGo input arguments: (w io.Writer, err error)\n\nJoker input arguments: [^go.std.io/Writer w, ^ABEND885(pre.go: unrecognized type error at: /usr/local/go-1.11.5/src/go/scanner/errors.go:116:34) err]"
;;   {:added "1.0"
;;    :go "__printError(*_w, _err)"}
;;   [^io/Writer _w, ^ABEND885(pre.go: unrecognized type error at: /usr/local/go-1.11.5/src/go/scanner/errors.go:116:34) _err])

JOKER TYPE go/token.File from go/token/position.go:
(defn ^"GoObject" File.
  "Constructor for token.File"
  {:added "1.0"
   :go "_ConstructFile(_v)"}
  [^Object _v])

JOKER TYPE go/token.FileSet from go/token/position.go:
(defn ^"GoObject" FileSet.
  "Constructor for token.FileSet"
  {:added "1.0"
   :go "_ConstructFileSet(_v)"}
  [^Object _v])

JOKER TYPE go/token.Pos from go/token/position.go:
(defn ^"GoObject" Pos.
  "Constructor for token.Pos"
  {:added "1.0"
   :go "_ConstructPos(_v)"}
  [^Object _v])

JOKER TYPE go/token.Position from go/token/position.go:
(defn ^"GoObject" Position.
  "Constructor for token.Position"
  {:added "1.0"
   :go "_ConstructPosition(_v)"}
  [^Object _v])

JOKER TYPE go/token.Token from go/token/token.go:
(defn ^"GoObject" Token.
  "Constructor for token.Token"
  {:added "1.0"
   :go "_ConstructToken(_v)"}
  [^Object _v])

JOKER FUNC go/token.Lookup from go/token/token.go:
(defn Lookup
  "Lookup maps an identifier to its keyword token or IDENT (if not a keyword).\n\nGo input arguments: (ident string)\n\nGo return type: Token\n\nJoker input arguments: [^String ident]\n\nJoker return type: go.std.go.token/Token"
  {:added "1.0"
   :go "__lookup(_ident)"}
  [^String _ident])

JOKER FUNC go/token.NewFileSet from go/token/position.go:
(defn NewFileSet
  "NewFileSet creates a new file set.\n\nGo return type: *FileSet\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.go.token/FileSet)"
  {:added "1.0"
   :go "__newFileSet()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the go/token package."
    :empty false}
  go.std.go.token)
JOKER TYPE go/types.Array from go/types/type.go:
(defn ^"GoObject" Array.
  "Constructor for types.Array"
  {:added "1.0"
   :go "_ConstructArray(_v)"}
  [^Object _v])

JOKER TYPE go/types.Basic from go/types/type.go:
(defn ^"GoObject" Basic.
  "Constructor for types.Basic"
  {:added "1.0"
   :go "_ConstructBasic(_v)"}
  [^Object _v])

JOKER TYPE go/types.BasicInfo from go/types/type.go:
(defn ^"GoObject" BasicInfo.
  "Constructor for types.BasicInfo"
  {:added "1.0"
   :go "_ConstructBasicInfo(_v)"}
  [^Object _v])

JOKER TYPE go/types.BasicKind from go/types/type.go:
(defn ^"GoObject" BasicKind.
  "Constructor for types.BasicKind"
  {:added "1.0"
   :go "_ConstructBasicKind(_v)"}
  [^Object _v])

JOKER TYPE go/types.Builtin from go/types/object.go:
(defn ^"GoObject" Builtin.
  "Constructor for types.Builtin"
  {:added "1.0"
   :go "_ConstructBuiltin(_v)"}
  [^Object _v])

JOKER TYPE go/types.Chan from go/types/type.go:
(defn ^"GoObject" Chan.
  "Constructor for types.Chan"
  {:added "1.0"
   :go "_ConstructChan(_v)"}
  [^Object _v])

JOKER TYPE go/types.ChanDir from go/types/type.go:
(defn ^"GoObject" ChanDir.
  "Constructor for types.ChanDir"
  {:added "1.0"
   :go "_ConstructChanDir(_v)"}
  [^Object _v])

JOKER TYPE go/types.Checker from go/types/check.go:
(defn ^"GoObject" Checker.
  "Constructor for types.Checker"
  {:added "1.0"
   :go "_ConstructChecker(_v)"}
  [^Object _v])

JOKER TYPE go/types.Config from go/types/api.go:
(defn ^"GoObject" Config.
  "Constructor for types.Config"
  {:added "1.0"
   :go "_ConstructConfig(_v)"}
  [^Object _v])

JOKER TYPE go/types.Const from go/types/object.go:
(defn ^"GoObject" Const.
  "Constructor for types.Const"
  {:added "1.0"
   :go "_ConstructConst(_v)"}
  [^Object _v])

JOKER TYPE go/types.Error from go/types/api.go:
(defn ^"GoObject" Error.
  "Constructor for types.Error"
  {:added "1.0"
   :go "_ConstructError(_v)"}
  [^Object _v])

JOKER TYPE go/types.Func from go/types/object.go:
(defn ^"GoObject" Func.
  "Constructor for types.Func"
  {:added "1.0"
   :go "_ConstructFunc(_v)"}
  [^Object _v])

JOKER TYPE go/types.ImportMode from go/types/api.go:
(defn ^"GoObject" ImportMode.
  "Constructor for types.ImportMode"
  {:added "1.0"
   :go "_ConstructImportMode(_v)"}
  [^Object _v])

JOKER TYPE go/types.Importer from go/types/api.go:
;; (defn ^"GoObject" Importer.
;;   "Constructor for types.Importer"
;;   {:added "1.0"
;;    :go "_ConstructImporter(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.ImporterFrom from go/types/api.go:
;; (defn ^"GoObject" ImporterFrom.
;;   "Constructor for types.ImporterFrom"
;;   {:added "1.0"
;;    :go "_ConstructImporterFrom(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.Info from go/types/api.go:
(defn ^"GoObject" Info.
  "Constructor for types.Info"
  {:added "1.0"
   :go "_ConstructInfo(_v)"}
  [^Object _v])

JOKER TYPE go/types.Initializer from go/types/api.go:
(defn ^"GoObject" Initializer.
  "Constructor for types.Initializer"
  {:added "1.0"
   :go "_ConstructInitializer(_v)"}
  [^Object _v])

JOKER TYPE go/types.Interface from go/types/type.go:
(defn ^"GoObject" Interface.
  "Constructor for types.Interface"
  {:added "1.0"
   :go "_ConstructInterface(_v)"}
  [^Object _v])

JOKER TYPE go/types.Label from go/types/object.go:
(defn ^"GoObject" Label.
  "Constructor for types.Label"
  {:added "1.0"
   :go "_ConstructLabel(_v)"}
  [^Object _v])

JOKER TYPE go/types.Map from go/types/type.go:
(defn ^"GoObject" Map.
  "Constructor for types.Map"
  {:added "1.0"
   :go "_ConstructMap(_v)"}
  [^Object _v])

JOKER TYPE go/types.MethodSet from go/types/methodset.go:
(defn ^"GoObject" MethodSet.
  "Constructor for types.MethodSet"
  {:added "1.0"
   :go "_ConstructMethodSet(_v)"}
  [^Object _v])

JOKER TYPE go/types.Named from go/types/type.go:
(defn ^"GoObject" Named.
  "Constructor for types.Named"
  {:added "1.0"
   :go "_ConstructNamed(_v)"}
  [^Object _v])

JOKER TYPE go/types.Nil from go/types/object.go:
(defn ^"GoObject" Nil.
  "Constructor for types.Nil"
  {:added "1.0"
   :go "_ConstructNil(_v)"}
  [^Object _v])

JOKER TYPE go/types.Object from go/types/object.go:
;; (defn ^"GoObject" Object.
;;   "Constructor for types.Object"
;;   {:added "1.0"
;;    :go "_ConstructObject(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.Package from go/types/package.go:
(defn ^"GoObject" Package.
  "Constructor for types.Package"
  {:added "1.0"
   :go "_ConstructPackage(_v)"}
  [^Object _v])

JOKER TYPE go/types.PkgName from go/types/object.go:
(defn ^"GoObject" PkgName.
  "Constructor for types.PkgName"
  {:added "1.0"
   :go "_ConstructPkgName(_v)"}
  [^Object _v])

JOKER TYPE go/types.Pointer from go/types/type.go:
(defn ^"GoObject" Pointer.
  "Constructor for types.Pointer"
  {:added "1.0"
   :go "_ConstructPointer(_v)"}
  [^Object _v])

JOKER TYPE go/types.Qualifier from go/types/typestring.go:
;; (defn ^"GoObject" Qualifier.
;;   "Constructor for types.Qualifier"
;;   {:added "1.0"
;;    :go "_ConstructQualifier(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.Scope from go/types/scope.go:
(defn ^"GoObject" Scope.
  "Constructor for types.Scope"
  {:added "1.0"
   :go "_ConstructScope(_v)"}
  [^Object _v])

JOKER TYPE go/types.Selection from go/types/selection.go:
(defn ^"GoObject" Selection.
  "Constructor for types.Selection"
  {:added "1.0"
   :go "_ConstructSelection(_v)"}
  [^Object _v])

JOKER TYPE go/types.SelectionKind from go/types/selection.go:
(defn ^"GoObject" SelectionKind.
  "Constructor for types.SelectionKind"
  {:added "1.0"
   :go "_ConstructSelectionKind(_v)"}
  [^Object _v])

JOKER TYPE go/types.Signature from go/types/type.go:
(defn ^"GoObject" Signature.
  "Constructor for types.Signature"
  {:added "1.0"
   :go "_ConstructSignature(_v)"}
  [^Object _v])

JOKER TYPE go/types.Sizes from go/types/sizes.go:
;; (defn ^"GoObject" Sizes.
;;   "Constructor for types.Sizes"
;;   {:added "1.0"
;;    :go "_ConstructSizes(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.Slice from go/types/type.go:
(defn ^"GoObject" Slice.
  "Constructor for types.Slice"
  {:added "1.0"
   :go "_ConstructSlice(_v)"}
  [^Object _v])

JOKER TYPE go/types.StdSizes from go/types/sizes.go:
(defn ^"GoObject" StdSizes.
  "Constructor for types.StdSizes"
  {:added "1.0"
   :go "_ConstructStdSizes(_v)"}
  [^Object _v])

JOKER TYPE go/types.Struct from go/types/type.go:
(defn ^"GoObject" Struct.
  "Constructor for types.Struct"
  {:added "1.0"
   :go "_ConstructStruct(_v)"}
  [^Object _v])

JOKER TYPE go/types.Tuple from go/types/type.go:
(defn ^"GoObject" Tuple.
  "Constructor for types.Tuple"
  {:added "1.0"
   :go "_ConstructTuple(_v)"}
  [^Object _v])

JOKER TYPE go/types.Type from go/types/type.go:
;; (defn ^"GoObject" Type.
;;   "Constructor for types.Type"
;;   {:added "1.0"
;;    :go "_ConstructType(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.TypeAndValue from go/types/api.go:
(defn ^"GoObject" TypeAndValue.
  "Constructor for types.TypeAndValue"
  {:added "1.0"
   :go "_ConstructTypeAndValue(_v)"}
  [^Object _v])

JOKER TYPE go/types.TypeName from go/types/object.go:
(defn ^"GoObject" TypeName.
  "Constructor for types.TypeName"
  {:added "1.0"
   :go "_ConstructTypeName(_v)"}
  [^Object _v])

JOKER TYPE go/types.Var from go/types/object.go:
(defn ^"GoObject" Var.
  "Constructor for types.Var"
  {:added "1.0"
   :go "_ConstructVar(_v)"}
  [^Object _v])

JOKER FUNC go/types.AssertableTo from go/types/api.go:
(defn ^"Boolean" AssertableTo
  "AssertableTo reports whether a value of type V can be asserted to have type T.\n\nGo input arguments: (V *Interface, T Type)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.go.types/Interface) V, ^go.std.go.types/Type T]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.AssertableTo(_V, *_T)"}
  [^types/Interface _V, ^types/Type _T])

JOKER FUNC go/types.AssignableTo from go/types/api.go:
(defn ^"Boolean" AssignableTo
  "AssignableTo reports whether a value of type V is assignable to a variable of type T.\n\nGo input arguments: (V Type, T Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type V, ^go.std.go.types/Type T]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.AssignableTo(*_V, *_T)"}
  [^types/Type _V, ^types/Type _T])

JOKER FUNC go/types.Comparable from go/types/predicates.go:
(defn ^"Boolean" Comparable
  "Comparable reports whether values of type T are comparable.\n\nGo input arguments: (T Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type T]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.Comparable(*_T)"}
  [^types/Type _T])

JOKER FUNC go/types.ConvertibleTo from go/types/api.go:
(defn ^"Boolean" ConvertibleTo
  "ConvertibleTo reports whether a value of type V is convertible to a value of type T.\n\nGo input arguments: (V Type, T Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type V, ^go.std.go.types/Type T]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.ConvertibleTo(*_V, *_T)"}
  [^types/Type _V, ^types/Type _T])

JOKER FUNC go/types.DefPredeclaredTestFuncs from go/types/universe.go:
;; (defn DefPredeclaredTestFuncs
;;   "DefPredeclaredTestFuncs defines the assert and trace built-ins.\nThese built-ins are intended for debugging and testing of this\npackage only.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__defPredeclaredTestFuncs()"}
;;   [])

JOKER FUNC go/types.Default from go/types/predicates.go:
(defn Default
  "Default returns the default \"typed\" type for an \"untyped\" type;\nit returns the incoming type for all other types. The default type\nfor untyped nil is untyped nil.\n\nGo input arguments: (typ Type)\n\nGo return type: Type\n\nJoker input arguments: [^go.std.go.types/Type typ]\n\nJoker return type: go.std.go.types/Type"
  {:added "1.0"
   :go "__default(*_typ)"}
  [^types/Type _typ])

JOKER FUNC go/types.Eval from go/types/eval.go:
;; (defn Eval
;;   "Eval returns the type and, if constant, the value for the\nexpression expr, evaluated at position pos of package pkg,\nwhich must have been derived from type-checking an AST with\ncomplete position information relative to the provided file\nset.\n\nIf pkg == nil, the Universe scope is used and the provided\nposition pos is ignored. If pkg != nil, and pos is invalid,\nthe package scope is used. Otherwise, pos must belong to the\npackage.\n\nAn error is returned if pos is not within the package or\nif the node cannot be evaluated.\n\nNote: Eval should not be used instead of running Check to compute\ntypes and values, but in addition to Check. Eval will re-evaluate\nits argument each time, and it also does not know about the context\nin which an expression is used (e.g., an assignment). Thus, top-\nlevel untyped constants will return an untyped type rather then the\nrespective context-specific type.\n\nGo input arguments: (fset *token.FileSet, pkg *Package, pos token.Pos, expr string)\n\nGo return type: (_ TypeAndValue, err error)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^(atom-of go.std.go.types/Package) pkg, ^go.std.go.token/Pos pos, ^String expr]\n\nJoker return type: [go.std.go.types/TypeAndValue Error]"
;;   {:added "1.0"
;;    :go "__eval(_fset, _pkg, *_pos, _expr)"}
;;   [^token/FileSet _fset, ^types/Package _pkg, ^token/Pos _pos, ^String _expr])

JOKER FUNC go/types.ExprString from go/types/exprstring.go:
;; (defn ^"String" ExprString
;;   "ExprString returns the (possibly shortened) string representation for x.\nShortened representations are suitable for user interfaces but may not\nnecessarily follow Go syntax.\n\nGo input arguments: (x ast.Expr)\n\nGo return type: string\n\nJoker input arguments: [^go.std.go.ast/Expr x]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "types.ExprString(*_x)"}
;;   [^ast/Expr _x])

JOKER FUNC go/types.Id from go/types/object.go:
(defn ^"String" Id
  "Id returns name if it is exported, otherwise it\nreturns the name qualified with the package path.\n\nGo input arguments: (pkg *Package, name string)\n\nGo return type: string\n\nJoker input arguments: [^(atom-of go.std.go.types/Package) pkg, ^String name]\n\nJoker return type: String"
  {:added "1.0"
   :go "types.Id(_pkg, _name)"}
  [^types/Package _pkg, ^String _name])

JOKER FUNC go/types.Identical from go/types/predicates.go:
(defn ^"Boolean" Identical
  "Identical reports whether x and y are identical types.\nReceivers of Signature types are ignored.\n\nGo input arguments: (x Type, y Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type x, ^go.std.go.types/Type y]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.Identical(*_x, *_y)"}
  [^types/Type _x, ^types/Type _y])

JOKER FUNC go/types.IdenticalIgnoreTags from go/types/predicates.go:
(defn ^"Boolean" IdenticalIgnoreTags
  "IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored.\nReceivers of Signature types are ignored.\n\nGo input arguments: (x Type, y Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type x, ^go.std.go.types/Type y]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.IdenticalIgnoreTags(*_x, *_y)"}
  [^types/Type _x, ^types/Type _y])

JOKER FUNC go/types.Implements from go/types/api.go:
(defn ^"Boolean" Implements
  "Implements reports whether type V implements interface T.\n\nGo input arguments: (V Type, T *Interface)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type V, ^(atom-of go.std.go.types/Interface) T]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.Implements(*_V, _T)"}
  [^types/Type _V, ^types/Interface _T])

JOKER FUNC go/types.IsInterface from go/types/predicates.go:
(defn ^"Boolean" IsInterface
  "IsInterface reports whether typ is an interface type.\n\nGo input arguments: (typ Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type typ]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.IsInterface(*_typ)"}
  [^types/Type _typ])

JOKER FUNC go/types.LookupFieldOrMethod from go/types/lookup.go:
(defn LookupFieldOrMethod
  "LookupFieldOrMethod looks up a field or method with given package and name\nin T and returns the corresponding *Var or *Func, an index sequence, and a\nbool indicating if there were any pointer indirections on the path to the\nfield or method. If addressable is set, T is the type of an addressable\nvariable (only matters for method lookups).\n\nThe last index entry is the field or method index in the (possibly embedded)\ntype where the entry was found, either:\n\n\t1) the list of declared methods of a named type; or\n\t2) the list of all methods (method set) of an interface type; or\n\t3) the list of fields of a struct type.\n\nThe earlier index entries are the indices of the embedded struct fields\ntraversed to get to the found entry, starting at depth 0.\n\nIf no entry is found, a nil object is returned. In this case, the returned\nindex and indirect values have the following meaning:\n\n\t- If index != nil, the index sequence points to an ambiguous entry\n\t(the same name appeared more than once at the same embedding level).\n\n\t- If indirect is set, a method with a pointer receiver type was found\n     but there was no pointer on the path from the actual receiver type to\n\tthe method's formal receiver base type, nor was the receiver addressable.\n\nGo input arguments: (T Type, addressable bool, pkg *Package, name string)\n\nGo return type: (obj Object, index []int, indirect bool)\n\nJoker input arguments: [^go.std.go.types/Type T, ^Boolean addressable, ^(atom-of go.std.go.types/Package) pkg, ^String name]\n\nJoker return type: [go.std.go.types/Object (vector-of Int) Boolean]"
  {:added "1.0"
   :go "__lookupFieldOrMethod(*_T, _addressable, _pkg, _name)"}
  [^types/Type _T, ^Boolean _addressable, ^types/Package _pkg, ^String _name])

JOKER FUNC go/types.MissingMethod from go/types/lookup.go:
(defn MissingMethod
  "MissingMethod returns (nil, false) if V implements T, otherwise it\nreturns a missing method required by T and whether it is missing or\njust has the wrong type.\n\nFor non-interface types V, or if static is set, V implements T if all\nmethods of T are present in V. Otherwise (V is an interface and static\nis not set), MissingMethod only checks that methods of T which are also\npresent in V have matching types (e.g., for a type assertion x.(T) where\nx is of interface type V).\n\nGo input arguments: (V Type, T *Interface, static bool)\n\nGo return type: (method *Func, wrongType bool)\n\nJoker input arguments: [^go.std.go.types/Type V, ^(atom-of go.std.go.types/Interface) T, ^Boolean static]\n\nJoker return type: [(atom-of go.std.go.types/Func) Boolean]"
  {:added "1.0"
   :go "__missingMethod(*_V, _T, _static)"}
  [^types/Type _V, ^types/Interface _T, ^Boolean _static])

JOKER FUNC go/types.NewArray from go/types/type.go:
(defn NewArray
  "NewArray returns a new array type for the given element type and length.\nA negative length indicates an unknown length.\n\nGo input arguments: (elem Type, len int64)\n\nGo return type: *Array\n\nJoker input arguments: [^go.std.go.types/Type elem, ^Int64 len]\n\nJoker return type: (atom-of go.std.go.types/Array)"
  {:added "1.0"
   :go "__newArray(*_elem, _len)"}
  [^types/Type _elem, ^Int64 _len])

JOKER FUNC go/types.NewChan from go/types/type.go:
(defn NewChan
  "NewChan returns a new channel type for the given direction and element type.\n\nGo input arguments: (dir ChanDir, elem Type)\n\nGo return type: *Chan\n\nJoker input arguments: [^go.std.go.types/ChanDir dir, ^go.std.go.types/Type elem]\n\nJoker return type: (atom-of go.std.go.types/Chan)"
  {:added "1.0"
   :go "__newChan(*_dir, *_elem)"}
  [^types/ChanDir _dir, ^types/Type _elem])

JOKER FUNC go/types.NewChecker from go/types/check.go:
;; (defn NewChecker
;;   "NewChecker returns a new Checker instance for a given package.\nPackage files may be added incrementally via checker.Files.\n\nGo input arguments: (conf *Config, fset *token.FileSet, pkg *Package, info *Info)\n\nGo return type: *Checker\n\nJoker input arguments: [^(atom-of go.std.go.types/Config) conf, ^(atom-of go.std.go.token/FileSet) fset, ^(atom-of go.std.go.types/Package) pkg, ^(atom-of go.std.go.types/Info) info]\n\nJoker return type: (atom-of go.std.go.types/Checker)"
;;   {:added "1.0"
;;    :go "__newChecker(_conf, _fset, _pkg, _info)"}
;;   [^types/Config _conf, ^token/FileSet _fset, ^types/Package _pkg, ^types/Info _info])

JOKER FUNC go/types.NewConst from go/types/object.go:
;; (defn NewConst
;;   "NewConst returns a new constant with value val.\nThe remaining arguments set the attributes found with all Objects.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, typ Type, val constant.Value)\n\nGo return type: *Const\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^go.std.go.types/Type typ, ^go.std.go.constant/Value val]\n\nJoker return type: (atom-of go.std.go.types/Const)"
;;   {:added "1.0"
;;    :go "__newConst(*_pos, _pkg, _name, *_typ, *_val)"}
;;   [^token/Pos _pos, ^types/Package _pkg, ^String _name, ^types/Type _typ, ^constant/Value _val])

JOKER FUNC go/types.NewField from go/types/object.go:
;; (defn NewField
;;   "NewField returns a new variable representing a struct field.\nFor embedded fields, the name is the unqualified type name\n/ under which the field is accessible.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, typ Type, embedded bool)\n\nGo return type: *Var\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^go.std.go.types/Type typ, ^Boolean embedded]\n\nJoker return type: (atom-of go.std.go.types/Var)"
;;   {:added "1.0"
;;    :go "__newField(*_pos, _pkg, _name, *_typ, _embedded)"}
;;   [^token/Pos _pos, ^types/Package _pkg, ^String _name, ^types/Type _typ, ^Boolean _embedded])

JOKER FUNC go/types.NewFunc from go/types/object.go:
;; (defn NewFunc
;;   "NewFunc returns a new function with the given signature, representing\nthe function's type.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, sig *Signature)\n\nGo return type: *Func\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^(atom-of go.std.go.types/Signature) sig]\n\nJoker return type: (atom-of go.std.go.types/Func)"
;;   {:added "1.0"
;;    :go "__newFunc(*_pos, _pkg, _name, _sig)"}
;;   [^token/Pos _pos, ^types/Package _pkg, ^String _name, ^types/Signature _sig])

JOKER FUNC go/types.NewInterface from go/types/type.go:
;; (defn NewInterface
;;   "NewInterface returns a new (incomplete) interface for the given methods and embedded types.\nEach embedded type must have an underlying type of interface type.\nNewInterface takes ownership of the provided methods and may modify their types by setting\nmissing receivers. To compute the method set of the interface, Complete must be called.\n\nDeprecated: Use NewInterfaceType instead which allows any (even non-defined) interface types\nto be embedded. This is necessary for interfaces that embed alias type names referring to\nnon-defined (literal) interface types.\n\nGo input arguments: (methods []*Func, embeddeds []*Named)\n\nGo return type: *Interface\n\nJoker input arguments: [^(vector-of (atom-of go.std.go.types/Func)) methods, ^(vector-of (atom-of go.std.go.types/Named)) embeddeds]\n\nJoker return type: (atom-of go.std.go.types/Interface)"
;;   {:added "1.0"
;;    :go "__newInterface(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_types.Func(_methods)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_types.Named(_embeddeds)))"}
;;   [^Object _methods, ^Object _embeddeds])

JOKER FUNC go/types.NewInterfaceType from go/types/type.go:
;; (defn NewInterfaceType
;;   "NewInterfaceType returns a new (incomplete) interface for the given methods and embedded types.\nEach embedded type must have an underlying type of interface type (this property is not\nverified for defined types, which may be in the process of being set up and which don't\nhave a valid underlying type yet).\nNewInterfaceType takes ownership of the provided methods and may modify their types by setting\nmissing receivers. To compute the method set of the interface, Complete must be called.\n\nGo input arguments: (methods []*Func, embeddeds []Type)\n\nGo return type: *Interface\n\nJoker input arguments: [^(vector-of (atom-of go.std.go.types/Func)) methods, ^(vector-of go.std.go.types/Type) embeddeds]\n\nJoker return type: (atom-of go.std.go.types/Interface)"
;;   {:added "1.0"
;;    :go "__newInterfaceType(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_types.Func(_methods)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_types.Type(*_embeddeds)))"}
;;   [^Object _methods, ^Object _embeddeds])

JOKER FUNC go/types.NewLabel from go/types/object.go:
;; (defn NewLabel
;;   "NewLabel returns a new label.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string)\n\nGo return type: *Label\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name]\n\nJoker return type: (atom-of go.std.go.types/Label)"
;;   {:added "1.0"
;;    :go "__newLabel(*_pos, _pkg, _name)"}
;;   [^token/Pos _pos, ^types/Package _pkg, ^String _name])

JOKER FUNC go/types.NewMap from go/types/type.go:
(defn NewMap
  "NewMap returns a new map for the given key and element types.\n\nGo input arguments: (key Type, elem Type)\n\nGo return type: *Map\n\nJoker input arguments: [^go.std.go.types/Type key, ^go.std.go.types/Type elem]\n\nJoker return type: (atom-of go.std.go.types/Map)"
  {:added "1.0"
   :go "__newMap(*_key, *_elem)"}
  [^types/Type _key, ^types/Type _elem])

JOKER FUNC go/types.NewMethodSet from go/types/methodset.go:
(defn NewMethodSet
  "NewMethodSet returns the method set for the given type T.\nIt always returns a non-nil method set, even if it is empty.\n\nGo input arguments: (T Type)\n\nGo return type: *MethodSet\n\nJoker input arguments: [^go.std.go.types/Type T]\n\nJoker return type: (atom-of go.std.go.types/MethodSet)"
  {:added "1.0"
   :go "__newMethodSet(*_T)"}
  [^types/Type _T])

JOKER FUNC go/types.NewNamed from go/types/type.go:
;; (defn NewNamed
;;   "NewNamed returns a new named type for the given type name, underlying type, and associated methods.\nIf the given type name obj doesn't have a type yet, its type is set to the returned named type.\nThe underlying type must not be a *Named.\n\nGo input arguments: (obj *TypeName, underlying Type, methods []*Func)\n\nGo return type: *Named\n\nJoker input arguments: [^(atom-of go.std.go.types/TypeName) obj, ^go.std.go.types/Type underlying, ^(vector-of (atom-of go.std.go.types/Func)) methods]\n\nJoker return type: (atom-of go.std.go.types/Named)"
;;   {:added "1.0"
;;    :go "__newNamed(_obj, *_underlying, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_types.Func(_methods)))"}
;;   [^types/TypeName _obj, ^types/Type _underlying, ^Object _methods])

JOKER FUNC go/types.NewPackage from go/types/package.go:
(defn NewPackage
  "NewPackage returns a new Package for the given package path and name.\nThe package is not complete and contains no explicit imports.\n\nGo input arguments: (path string, name string)\n\nGo return type: *Package\n\nJoker input arguments: [^String path, ^String name]\n\nJoker return type: (atom-of go.std.go.types/Package)"
  {:added "1.0"
   :go "__newPackage(_path, _name)"}
  [^String _path, ^String _name])

JOKER FUNC go/types.NewParam from go/types/object.go:
;; (defn NewParam
;;   "NewParam returns a new variable representing a function parameter.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, typ Type)\n\nGo return type: *Var\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^go.std.go.types/Type typ]\n\nJoker return type: (atom-of go.std.go.types/Var)"
;;   {:added "1.0"
;;    :go "__newParam(*_pos, _pkg, _name, *_typ)"}
;;   [^token/Pos _pos, ^types/Package _pkg, ^String _name, ^types/Type _typ])

JOKER FUNC go/types.NewPkgName from go/types/object.go:
;; (defn NewPkgName
;;   "NewPkgName returns a new PkgName object representing an imported package.\nThe remaining arguments set the attributes found with all Objects.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, imported *Package)\n\nGo return type: *PkgName\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^(atom-of go.std.go.types/Package) imported]\n\nJoker return type: (atom-of go.std.go.types/PkgName)"
;;   {:added "1.0"
;;    :go "__newPkgName(*_pos, _pkg, _name, _imported)"}
;;   [^token/Pos _pos, ^types/Package _pkg, ^String _name, ^types/Package _imported])

JOKER FUNC go/types.NewPointer from go/types/type.go:
(defn NewPointer
  "NewPointer returns a new pointer type for the given element (base) type.\n\nGo input arguments: (elem Type)\n\nGo return type: *Pointer\n\nJoker input arguments: [^go.std.go.types/Type elem]\n\nJoker return type: (atom-of go.std.go.types/Pointer)"
  {:added "1.0"
   :go "__newPointer(*_elem)"}
  [^types/Type _elem])

JOKER FUNC go/types.NewScope from go/types/scope.go:
;; (defn NewScope
;;   "NewScope returns a new, empty scope contained in the given parent\nscope, if any. The comment is for debugging only.\n\nGo input arguments: (parent *Scope, pos token.Pos, end token.Pos, comment string)\n\nGo return type: *Scope\n\nJoker input arguments: [^(atom-of go.std.go.types/Scope) parent, ^go.std.go.token/Pos pos, ^go.std.go.token/Pos end, ^String comment]\n\nJoker return type: (atom-of go.std.go.types/Scope)"
;;   {:added "1.0"
;;    :go "__newScope(_parent, *_pos, *_end, _comment)"}
;;   [^types/Scope _parent, ^token/Pos _pos, ^token/Pos _end, ^String _comment])

JOKER FUNC go/types.NewSignature from go/types/type.go:
(defn NewSignature
  "NewSignature returns a new function type for the given receiver, parameters,\nand results, either of which may be nil. If variadic is set, the function\nis variadic, it must have at least one parameter, and the last parameter\nmust be of unnamed slice type.\n\nGo input arguments: (recv *Var, params *Tuple, results *Tuple, variadic bool)\n\nGo return type: *Signature\n\nJoker input arguments: [^(atom-of go.std.go.types/Var) recv, ^(atom-of go.std.go.types/Tuple) params, ^(atom-of go.std.go.types/Tuple) results, ^Boolean variadic]\n\nJoker return type: (atom-of go.std.go.types/Signature)"
  {:added "1.0"
   :go "__newSignature(_recv, _params, _results, _variadic)"}
  [^types/Var _recv, ^types/Tuple _params, ^types/Tuple _results, ^Boolean _variadic])

JOKER FUNC go/types.NewSlice from go/types/type.go:
(defn NewSlice
  "NewSlice returns a new slice type for the given element type.\n\nGo input arguments: (elem Type)\n\nGo return type: *Slice\n\nJoker input arguments: [^go.std.go.types/Type elem]\n\nJoker return type: (atom-of go.std.go.types/Slice)"
  {:added "1.0"
   :go "__newSlice(*_elem)"}
  [^types/Type _elem])

JOKER FUNC go/types.NewStruct from go/types/type.go:
;; (defn NewStruct
;;   "NewStruct returns a new struct with the given fields and corresponding field tags.\nIf a field with index i has a tag, tags[i] must be that tag, but len(tags) may be\nonly as long as required to hold the tag with the largest index i. Consequently,\nif no field has a tag, tags may be nil.\n\nGo input arguments: (fields []*Var, tags []string)\n\nGo return type: *Struct\n\nJoker input arguments: [^(vector-of (atom-of go.std.go.types/Var)) fields, ^(vector-of String) tags]\n\nJoker return type: (atom-of go.std.go.types/Struct)"
;;   {:added "1.0"
;;    :go "__newStruct(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_types.Var(_fields)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(_tags)))"}
;;   [^Object _fields, ^Object _tags])

JOKER FUNC go/types.NewTuple from go/types/type.go:
;; (defn NewTuple
;;   "NewTuple returns a new tuple for the given variables.\n\nGo input arguments: (x ...*Var)\n\nGo return type: *Tuple\n\nJoker input arguments: [^(ellipsis-somehow types/Var) x]\n\nJoker return type: (atom-of go.std.go.types/Tuple)"
;;   {:added "1.0"
;;    :go "__newTuple(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHa*_types.Var(_x)))"}
;;   [^types/Var _x])

JOKER FUNC go/types.NewTypeName from go/types/object.go:
;; (defn NewTypeName
;;   "NewTypeName returns a new type name denoting the given typ.\nThe remaining arguments set the attributes found with all Objects.\n\nThe typ argument may be a defined (Named) type or an alias type.\nIt may also be nil such that the returned TypeName can be used as\nargument for NewNamed, which will set the TypeName's type as a side-\neffect.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, typ Type)\n\nGo return type: *TypeName\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^go.std.go.types/Type typ]\n\nJoker return type: (atom-of go.std.go.types/TypeName)"
;;   {:added "1.0"
;;    :go "__newTypeName(*_pos, _pkg, _name, *_typ)"}
;;   [^token/Pos _pos, ^types/Package _pkg, ^String _name, ^types/Type _typ])

JOKER FUNC go/types.NewVar from go/types/object.go:
;; (defn NewVar
;;   "NewVar returns a new variable.\nThe arguments set the attributes found with all Objects.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, typ Type)\n\nGo return type: *Var\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^go.std.go.types/Type typ]\n\nJoker return type: (atom-of go.std.go.types/Var)"
;;   {:added "1.0"
;;    :go "__newVar(*_pos, _pkg, _name, *_typ)"}
;;   [^token/Pos _pos, ^types/Package _pkg, ^String _name, ^types/Type _typ])

JOKER FUNC go/types.ObjectString from go/types/object.go:
(defn ^"String" ObjectString
  "ObjectString returns the string form of obj.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo input arguments: (obj Object, qf Qualifier)\n\nGo return type: string\n\nJoker input arguments: [^go.std.go.types/Object obj, ^go.std.go.types/Qualifier qf]\n\nJoker return type: String"
  {:added "1.0"
   :go "types.ObjectString(*_obj, *_qf)"}
  [^types/Object _obj, ^types/Qualifier _qf])

JOKER FUNC go/types.RelativeTo from go/types/typestring.go:
(defn RelativeTo
  "RelativeTo(pkg) returns a Qualifier that fully qualifies members of\nall packages other than pkg.\n\nGo input arguments: (pkg *Package)\n\nGo return type: Qualifier\n\nJoker input arguments: [^(atom-of go.std.go.types/Package) pkg]\n\nJoker return type: go.std.go.types/Qualifier"
  {:added "1.0"
   :go "__relativeTo(_pkg)"}
  [^types/Package _pkg])

JOKER FUNC go/types.SelectionString from go/types/selection.go:
(defn ^"String" SelectionString
  "SelectionString returns the string form of s.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nExamples:\n\t\"field (T) f int\"\n\t\"method (T) f(X) Y\"\n\t\"method expr (T) f(X) Y\"\n\nGo input arguments: (s *Selection, qf Qualifier)\n\nGo return type: string\n\nJoker input arguments: [^(atom-of go.std.go.types/Selection) s, ^go.std.go.types/Qualifier qf]\n\nJoker return type: String"
  {:added "1.0"
   :go "types.SelectionString(_s, *_qf)"}
  [^types/Selection _s, ^types/Qualifier _qf])

JOKER FUNC go/types.SizesFor from go/types/sizes.go:
(defn SizesFor
  "SizesFor returns the Sizes used by a compiler for an architecture.\nThe result is nil if a compiler/architecture pair is not known.\n\nSupported architectures for compiler \"gc\":\n\"386\", \"arm\", \"arm64\", \"amd64\", \"amd64p32\", \"mips\", \"mipsle\",\n\"mips64\", \"mips64le\", \"ppc64\", \"ppc64le\", \"riscv64\", \"s390x\", \"wasm\".\n\nGo input arguments: (compiler string, arch string)\n\nGo return type: Sizes\n\nJoker input arguments: [^String compiler, ^String arch]\n\nJoker return type: go.std.go.types/Sizes"
  {:added "1.0"
   :go "__sizesFor(_compiler, _arch)"}
  [^String _compiler, ^String _arch])

JOKER FUNC go/types.TypeString from go/types/typestring.go:
(defn ^"String" TypeString
  "TypeString returns the string representation of typ.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo input arguments: (typ Type, qf Qualifier)\n\nGo return type: string\n\nJoker input arguments: [^go.std.go.types/Type typ, ^go.std.go.types/Qualifier qf]\n\nJoker return type: String"
  {:added "1.0"
   :go "types.TypeString(*_typ, *_qf)"}
  [^types/Type _typ, ^types/Qualifier _qf])

JOKER FUNC go/types.WriteExpr from go/types/exprstring.go:
;; (defn WriteExpr
;;   "WriteExpr writes the (possibly shortened) string representation for x to buf.\nShortened representations are suitable for user interfaces but may not\nnecessarily follow Go syntax.\n\nGo input arguments: (buf *bytes.Buffer, x ast.Expr)\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) buf, ^go.std.go.ast/Expr x]"
;;   {:added "1.0"
;;    :go "__writeExpr(_buf, *_x)"}
;;   [^bytes/Buffer _buf, ^ast/Expr _x])

JOKER FUNC go/types.WriteSignature from go/types/typestring.go:
;; (defn WriteSignature
;;   "WriteSignature writes the representation of the signature sig to buf,\nwithout a leading \"func\" keyword.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo input arguments: (buf *bytes.Buffer, sig *Signature, qf Qualifier)\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) buf, ^(atom-of go.std.go.types/Signature) sig, ^go.std.go.types/Qualifier qf]"
;;   {:added "1.0"
;;    :go "__writeSignature(_buf, _sig, *_qf)"}
;;   [^bytes/Buffer _buf, ^types/Signature _sig, ^types/Qualifier _qf])

JOKER FUNC go/types.WriteType from go/types/typestring.go:
;; (defn WriteType
;;   "WriteType writes the string representation of typ to buf.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo input arguments: (buf *bytes.Buffer, typ Type, qf Qualifier)\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) buf, ^go.std.go.types/Type typ, ^go.std.go.types/Qualifier qf]"
;;   {:added "1.0"
;;    :go "__writeType(_buf, *_typ, *_qf)"}
;;   [^bytes/Buffer _buf, ^types/Type _typ, ^types/Qualifier _qf])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/types"]
    :doc "Provides a low-level interface to the go/types package."
    :empty false}
  go.std.go.types)
JOKER FUNC hash/adler32.Checksum from hash/adler32/adler32.go:
;; (defn Checksum
;;   "Checksum returns the Adler-32 checksum of data.\n\nGo input arguments: (data []byte)\n\nGo return type: uint32\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__checksum(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC hash/adler32.New from hash/adler32/adler32.go:
(defn New
  "New returns a new hash.Hash32 computing the Adler-32 checksum. Its\nSum method will lay the value out in big-endian byte order. The\nreturned Hash32 also implements encoding.BinaryMarshaler and\nencoding.BinaryUnmarshaler to marshal and unmarshal the internal\nstate of the hash.\n\nGo return type: hash.Hash32\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash32"
  {:added "1.0"
   :go "__new()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the hash/adler32 package."
    :empty false}
  go.std.hash.adler32)
JOKER TYPE hash/crc32.Table from hash/crc32/crc32.go:
;; (defn ^"GoObject" Table.
;;   "Constructor for crc32.Table"
;;   {:added "1.0"
;;    :go "_ConstructTable(_v)"}
;;   [^Object _v])

JOKER FUNC hash/crc32.Checksum from hash/crc32/crc32.go:
;; (defn Checksum
;;   "Checksum returns the CRC-32 checksum of data\nusing the polynomial represented by the Table.\n\nGo input arguments: (data []byte, tab *Table)\n\nGo return type: uint32\n\nJoker input arguments: [^(vector-of Byte) data, ^(atom-of go.std.hash.crc32/Table) tab]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__checksum(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), _tab)"}
;;   [^Object _data, ^crc32/Table _tab])

JOKER FUNC hash/crc32.ChecksumIEEE from hash/crc32/crc32.go:
;; (defn ChecksumIEEE
;;   "ChecksumIEEE returns the CRC-32 checksum of data\nusing the IEEE polynomial.\n\nGo input arguments: (data []byte)\n\nGo return type: uint32\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__checksumIEEE(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC hash/crc32.MakeTable from hash/crc32/crc32.go:
(defn MakeTable
  "MakeTable returns a Table constructed from the specified polynomial.\nThe contents of this Table must not be modified.\n\nGo input arguments: (poly uint32)\n\nGo return type: *Table\n\nJoker input arguments: [^UInt32 poly]\n\nJoker return type: (atom-of go.std.hash.crc32/Table)"
  {:added "1.0"
   :go "__makeTable(_poly)"}
  [^UInt32 _poly])

JOKER FUNC hash/crc32.New from hash/crc32/crc32.go:
(defn New
  "New creates a new hash.Hash32 computing the CRC-32 checksum using the\npolynomial represented by the Table. Its Sum method will lay the\nvalue out in big-endian byte order. The returned Hash32 also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo input arguments: (tab *Table)\n\nGo return type: hash.Hash32\n\nJoker input arguments: [^(atom-of go.std.hash.crc32/Table) tab]\n\nJoker return type: go.std.hash/Hash32"
  {:added "1.0"
   :go "__new(_tab)"}
  [^crc32/Table _tab])

JOKER FUNC hash/crc32.NewIEEE from hash/crc32/crc32.go:
(defn NewIEEE
  "NewIEEE creates a new hash.Hash32 computing the CRC-32 checksum using\nthe IEEE polynomial. Its Sum method will lay the value out in\nbig-endian byte order. The returned Hash32 also implements\nencoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal\nand unmarshal the internal state of the hash.\n\nGo return type: hash.Hash32\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash32"
  {:added "1.0"
   :go "__newIEEE()"}
  [])

JOKER FUNC hash/crc32.Update from hash/crc32/crc32.go:
;; (defn Update
;;   "Update returns the result of adding the bytes in p to the crc.\n\nGo input arguments: (crc uint32, tab *Table, p []byte)\n\nGo return type: uint32\n\nJoker input arguments: [^UInt32 crc, ^(atom-of go.std.hash.crc32/Table) tab, ^(vector-of Byte) p]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__update(_crc, _tab, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^UInt32 _crc, ^crc32/Table _tab, ^Object _p])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the hash/crc32 package."
    :empty false}
  go.std.hash.crc32)
JOKER TYPE hash/crc64.Table from hash/crc64/crc64.go:
;; (defn ^"GoObject" Table.
;;   "Constructor for crc64.Table"
;;   {:added "1.0"
;;    :go "_ConstructTable(_v)"}
;;   [^Object _v])

JOKER FUNC hash/crc64.Checksum from hash/crc64/crc64.go:
;; (defn Checksum
;;   "Checksum returns the CRC-64 checksum of data\nusing the polynomial represented by the Table.\n\nGo input arguments: (data []byte, tab *Table)\n\nGo return type: uint64\n\nJoker input arguments: [^(vector-of Byte) data, ^(atom-of go.std.hash.crc64/Table) tab]\n\nJoker return type: BigInt"
;;   {:added "1.0"
;;    :go "__checksum(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), _tab)"}
;;   [^Object _data, ^crc64/Table _tab])

JOKER FUNC hash/crc64.MakeTable from hash/crc64/crc64.go:
;; (defn MakeTable
;;   "MakeTable returns a Table constructed from the specified polynomial.\nThe contents of this Table must not be modified.\n\nGo input arguments: (poly uint64)\n\nGo return type: *Table\n\nJoker input arguments: [^uint64 poly]\n\nJoker return type: (atom-of go.std.hash.crc64/Table)"
;;   {:added "1.0"
;;    :go "__makeTable(_poly)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint64) _poly])

JOKER FUNC hash/crc64.New from hash/crc64/crc64.go:
(defn New
  "New creates a new hash.Hash64 computing the CRC-64 checksum using the\npolynomial represented by the Table. Its Sum method will lay the\nvalue out in big-endian byte order. The returned Hash64 also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo input arguments: (tab *Table)\n\nGo return type: hash.Hash64\n\nJoker input arguments: [^(atom-of go.std.hash.crc64/Table) tab]\n\nJoker return type: go.std.hash/Hash64"
  {:added "1.0"
   :go "__new(_tab)"}
  [^crc64/Table _tab])

JOKER FUNC hash/crc64.Update from hash/crc64/crc64.go:
;; (defn Update
;;   "Update returns the result of adding the bytes in p to the crc.\n\nGo input arguments: (crc uint64, tab *Table, p []byte)\n\nGo return type: uint64\n\nJoker input arguments: [^uint64 crc, ^(atom-of go.std.hash.crc64/Table) tab, ^(vector-of Byte) p]\n\nJoker return type: BigInt"
;;   {:added "1.0"
;;    :go "__update(_crc, _tab, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^ABEND044(pre.go: unsupported built-in type uint64) _crc, ^crc64/Table _tab, ^Object _p])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the hash/crc64 package."
    :empty false}
  go.std.hash.crc64)
JOKER FUNC hash/fnv.New128 from hash/fnv/fnv.go:
(defn New128
  "New128 returns a new 128-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new128()"}
  [])

JOKER FUNC hash/fnv.New128a from hash/fnv/fnv.go:
(defn New128a
  "New128a returns a new 128-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new128a()"}
  [])

JOKER FUNC hash/fnv.New32 from hash/fnv/fnv.go:
(defn New32
  "New32 returns a new 32-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash32\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash32"
  {:added "1.0"
   :go "__new32()"}
  [])

JOKER FUNC hash/fnv.New32a from hash/fnv/fnv.go:
(defn New32a
  "New32a returns a new 32-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash32\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash32"
  {:added "1.0"
   :go "__new32a()"}
  [])

JOKER FUNC hash/fnv.New64 from hash/fnv/fnv.go:
(defn New64
  "New64 returns a new 64-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash64\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash64"
  {:added "1.0"
   :go "__new64()"}
  [])

JOKER FUNC hash/fnv.New64a from hash/fnv/fnv.go:
(defn New64a
  "New64a returns a new 64-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash64\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash64"
  {:added "1.0"
   :go "__new64a()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the hash/fnv package."
    :empty false}
  go.std.hash.fnv)
JOKER FUNC html.EscapeString from html/escape.go:
(defn ^"String" EscapeString
  "EscapeString escapes special characters like \"<\" to become \"&lt;\". It\nescapes only five such characters: <, >, &, ' and \".\nUnescapeString(EscapeString(s)) == s always holds, but the converse isn't\nalways true.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "html.EscapeString(_s)"}
  [^String _s])

JOKER FUNC html.UnescapeString from html/escape.go:
(defn ^"String" UnescapeString
  "UnescapeString unescapes entities like \"&lt;\" to become \"<\". It unescapes a\nlarger range of entities than EscapeString escapes. For example, \"&aacute;\"\nunescapes to \"á\", as does \"&#225;\" and \"&#xE1;\".\nUnescapeString(EscapeString(s)) == s always holds, but the converse isn't\nalways true.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "html.UnescapeString(_s)"}
  [^String _s])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["html"]
    :doc "Provides a low-level interface to the html package."
    :empty false}
  go.std.html)
JOKER TYPE html/template.CSS from html/template/content.go:
(defn ^"GoObject" CSS.
  "Constructor for template.CSS"
  {:added "1.0"
   :go "_ConstructCSS(_v)"}
  [^Object _v])

JOKER TYPE html/template.Error from html/template/error.go:
(defn ^"GoObject" Error.
  "Constructor for template.Error"
  {:added "1.0"
   :go "_ConstructError(_v)"}
  [^Object _v])

JOKER TYPE html/template.ErrorCode from html/template/error.go:
(defn ^"GoObject" ErrorCode.
  "Constructor for template.ErrorCode"
  {:added "1.0"
   :go "_ConstructErrorCode(_v)"}
  [^Object _v])

JOKER TYPE html/template.FuncMap from html/template/template.go:
;; (defn ^"GoObject" FuncMap.
;;   "Constructor for template.FuncMap"
;;   {:added "1.0"
;;    :go "_ConstructFuncMap(_v)"}
;;   [^Object _v])

JOKER TYPE html/template.HTML from html/template/content.go:
(defn ^"GoObject" HTML.
  "Constructor for template.HTML"
  {:added "1.0"
   :go "_ConstructHTML(_v)"}
  [^Object _v])

JOKER TYPE html/template.HTMLAttr from html/template/content.go:
(defn ^"GoObject" HTMLAttr.
  "Constructor for template.HTMLAttr"
  {:added "1.0"
   :go "_ConstructHTMLAttr(_v)"}
  [^Object _v])

JOKER TYPE html/template.JS from html/template/content.go:
(defn ^"GoObject" JS.
  "Constructor for template.JS"
  {:added "1.0"
   :go "_ConstructJS(_v)"}
  [^Object _v])

JOKER TYPE html/template.JSStr from html/template/content.go:
(defn ^"GoObject" JSStr.
  "Constructor for template.JSStr"
  {:added "1.0"
   :go "_ConstructJSStr(_v)"}
  [^Object _v])

JOKER TYPE html/template.Srcset from html/template/content.go:
(defn ^"GoObject" Srcset.
  "Constructor for template.Srcset"
  {:added "1.0"
   :go "_ConstructSrcset(_v)"}
  [^Object _v])

JOKER TYPE html/template.Template from html/template/template.go:
(defn ^"GoObject" Template.
  "Constructor for template.Template"
  {:added "1.0"
   :go "_ConstructTemplate(_v)"}
  [^Object _v])

JOKER TYPE html/template.URL from html/template/content.go:
(defn ^"GoObject" URL.
  "Constructor for template.URL"
  {:added "1.0"
   :go "_ConstructURL(_v)"}
  [^Object _v])

JOKER FUNC html/template.HTMLEscape from html/template/escape.go:
;; (defn HTMLEscape
;;   "HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.\n\nGo input arguments: (w io.Writer, b []byte)\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Byte) b]"
;;   {:added "1.0"
;;    :go "__hTMLEscape(*_w, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^io/Writer _w, ^Object _b])

JOKER FUNC html/template.HTMLEscapeString from html/template/escape.go:
(defn ^"String" HTMLEscapeString
  "HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "template.HTMLEscapeString(_s)"}
  [^String _s])

JOKER FUNC html/template.HTMLEscaper from html/template/escape.go:
;; (defn ^"String" HTMLEscaper
;;   "HTMLEscaper returns the escaped HTML equivalent of the textual\nrepresentation of its arguments.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.HTMLEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _args])

JOKER FUNC html/template.IsTrue from html/template/template.go:
;; (defn IsTrue
;;   "IsTrue reports whether the value is 'true', in the sense of not the zero of its type,\nand whether the value has a meaningful truth value. This is the definition of\ntruth used by if and other such actions.\n\nGo input arguments: (val interface {})\n\nGo return type: (truth bool, ok bool)\n\nJoker input arguments: [^<protocol-or-something> val]\n\nJoker return type: [Boolean Boolean]"
;;   {:added "1.0"
;;    :go "__isTrue(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _val])

JOKER FUNC html/template.JSEscape from html/template/escape.go:
;; (defn JSEscape
;;   "JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.\n\nGo input arguments: (w io.Writer, b []byte)\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Byte) b]"
;;   {:added "1.0"
;;    :go "__jSEscape(*_w, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^io/Writer _w, ^Object _b])

JOKER FUNC html/template.JSEscapeString from html/template/escape.go:
(defn ^"String" JSEscapeString
  "JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "template.JSEscapeString(_s)"}
  [^String _s])

JOKER FUNC html/template.JSEscaper from html/template/escape.go:
;; (defn ^"String" JSEscaper
;;   "JSEscaper returns the escaped JavaScript equivalent of the textual\nrepresentation of its arguments.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.JSEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _args])

JOKER FUNC html/template.Must from html/template/template.go:
;; (defn Must
;;   "Must is a helper that wraps a call to a function returning (*Template, error)\nand panics if the error is non-nil. It is intended for use in variable initializations\nsuch as\n\tvar t = template.Must(template.New(\"name\").Parse(\"html\"))\n\nGo input arguments: (t *Template, err error)\n\nGo return type: *Template\n\nJoker input arguments: [^(atom-of go.std.html.template/Template) t, ^ABEND885(pre.go: unrecognized type error at: /usr/local/go-1.11.5/src/html/template/template.go:370:28) err]\n\nJoker return type: (atom-of go.std.html.template/Template)"
;;   {:added "1.0"
;;    :go "__must(_t, _err)"}
;;   [^template/Template _t, ^ABEND885(pre.go: unrecognized type error at: /usr/local/go-1.11.5/src/html/template/template.go:370:28) _err])

JOKER FUNC html/template.New from html/template/template.go:
(defn New
  "New allocates a new HTML template with the given name.\n\nGo input arguments: (name string)\n\nGo return type: *Template\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.html.template/Template)"
  {:added "1.0"
   :go "__new(_name)"}
  [^String _name])

JOKER FUNC html/template.ParseFiles from html/template/template.go:
;; (defn ParseFiles
;;   "ParseFiles creates a new Template and parses the template definitions from\nthe named files. The returned template's name will have the (base) name and\n(parsed) contents of the first file. There must be at least one file.\nIf an error occurs, parsing stops and the returned *Template is nil.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\nFor instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template\nnamed \"foo\", while \"a/foo\" is unavailable.\n\nGo input arguments: (filenames ...string)\n\nGo return type: (*Template, error)\n\nJoker input arguments: [^(ellipsis-somehow String) filenames]\n\nJoker return type: [(atom-of go.std.html.template/Template) Error]"
;;   {:added "1.0"
;;    :go "__parseFiles(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(_filenames)))"}
;;   [^String _filenames])

JOKER FUNC html/template.ParseGlob from html/template/template.go:
(defn ParseGlob
  "ParseGlob creates a new Template and parses the template definitions from the\nfiles identified by the pattern, which must match at least one file. The\nreturned template will have the (base) name and (parsed) contents of the\nfirst file matched by the pattern. ParseGlob is equivalent to calling\nParseFiles with the list of files matched by the pattern.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\n\nGo input arguments: (pattern string)\n\nGo return type: (*Template, error)\n\nJoker input arguments: [^String pattern]\n\nJoker return type: [(atom-of go.std.html.template/Template) Error]"
  {:added "1.0"
   :go "__parseGlob(_pattern)"}
  [^String _pattern])

JOKER FUNC html/template.URLQueryEscaper from html/template/escape.go:
;; (defn ^"String" URLQueryEscaper
;;   "URLQueryEscaper returns the escaped value of the textual representation of\nits arguments in a form suitable for embedding in a URL query.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.URLQueryEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _args])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["html/template"]
    :doc "Provides a low-level interface to the html/template package."
    :empty false}
  go.std.html.template)
JOKER TYPE image.Alpha from image/image.go:
(defn ^"GoObject" Alpha.
  "Constructor for image.Alpha"
  {:added "1.0"
   :go "_ConstructAlpha(_v)"}
  [^Object _v])

JOKER TYPE image.Alpha16 from image/image.go:
(defn ^"GoObject" Alpha16.
  "Constructor for image.Alpha16"
  {:added "1.0"
   :go "_ConstructAlpha16(_v)"}
  [^Object _v])

JOKER TYPE image.CMYK from image/image.go:
(defn ^"GoObject" CMYK.
  "Constructor for image.CMYK"
  {:added "1.0"
   :go "_ConstructCMYK(_v)"}
  [^Object _v])

JOKER TYPE image.Config from image/image.go:
(defn ^"GoObject" Config.
  "Constructor for image.Config"
  {:added "1.0"
   :go "_ConstructConfig(_v)"}
  [^Object _v])

JOKER TYPE image.Gray from image/image.go:
(defn ^"GoObject" Gray.
  "Constructor for image.Gray"
  {:added "1.0"
   :go "_ConstructGray(_v)"}
  [^Object _v])

JOKER TYPE image.Gray16 from image/image.go:
(defn ^"GoObject" Gray16.
  "Constructor for image.Gray16"
  {:added "1.0"
   :go "_ConstructGray16(_v)"}
  [^Object _v])

JOKER TYPE image.Image from image/image.go:
;; (defn ^"GoObject" Image.
;;   "Constructor for image.Image"
;;   {:added "1.0"
;;    :go "_ConstructImage(_v)"}
;;   [^Object _v])

JOKER TYPE image.NRGBA from image/image.go:
(defn ^"GoObject" NRGBA.
  "Constructor for image.NRGBA"
  {:added "1.0"
   :go "_ConstructNRGBA(_v)"}
  [^Object _v])

JOKER TYPE image.NRGBA64 from image/image.go:
(defn ^"GoObject" NRGBA64.
  "Constructor for image.NRGBA64"
  {:added "1.0"
   :go "_ConstructNRGBA64(_v)"}
  [^Object _v])

JOKER TYPE image.NYCbCrA from image/ycbcr.go:
(defn ^"GoObject" NYCbCrA.
  "Constructor for image.NYCbCrA"
  {:added "1.0"
   :go "_ConstructNYCbCrA(_v)"}
  [^Object _v])

JOKER TYPE image.Paletted from image/image.go:
(defn ^"GoObject" Paletted.
  "Constructor for image.Paletted"
  {:added "1.0"
   :go "_ConstructPaletted(_v)"}
  [^Object _v])

JOKER TYPE image.PalettedImage from image/image.go:
;; (defn ^"GoObject" PalettedImage.
;;   "Constructor for image.PalettedImage"
;;   {:added "1.0"
;;    :go "_ConstructPalettedImage(_v)"}
;;   [^Object _v])

JOKER TYPE image.Point from image/geom.go:
(defn ^"GoObject" Point.
  "Constructor for image.Point"
  {:added "1.0"
   :go "_ConstructPoint(_v)"}
  [^Object _v])

JOKER TYPE image.RGBA from image/image.go:
(defn ^"GoObject" RGBA.
  "Constructor for image.RGBA"
  {:added "1.0"
   :go "_ConstructRGBA(_v)"}
  [^Object _v])

JOKER TYPE image.RGBA64 from image/image.go:
(defn ^"GoObject" RGBA64.
  "Constructor for image.RGBA64"
  {:added "1.0"
   :go "_ConstructRGBA64(_v)"}
  [^Object _v])

JOKER TYPE image.Rectangle from image/geom.go:
(defn ^"GoObject" Rectangle.
  "Constructor for image.Rectangle"
  {:added "1.0"
   :go "_ConstructRectangle(_v)"}
  [^Object _v])

JOKER TYPE image.Uniform from image/names.go:
(defn ^"GoObject" Uniform.
  "Constructor for image.Uniform"
  {:added "1.0"
   :go "_ConstructUniform(_v)"}
  [^Object _v])

JOKER TYPE image.YCbCr from image/ycbcr.go:
(defn ^"GoObject" YCbCr.
  "Constructor for image.YCbCr"
  {:added "1.0"
   :go "_ConstructYCbCr(_v)"}
  [^Object _v])

JOKER TYPE image.YCbCrSubsampleRatio from image/ycbcr.go:
(defn ^"GoObject" YCbCrSubsampleRatio.
  "Constructor for image.YCbCrSubsampleRatio"
  {:added "1.0"
   :go "_ConstructYCbCrSubsampleRatio(_v)"}
  [^Object _v])

JOKER FUNC image.Decode from image/format.go:
;; (defn Decode
;;   "Decode decodes an image that has been encoded in a registered format.\nThe string returned is the format name used during format registration.\nFormat registration is typically done by an init function in the codec-\nspecific package.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (Image, string, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Image String Error]"
;;   {:added "1.0"
;;    :go "__decode(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC image.DecodeConfig from image/format.go:
;; (defn DecodeConfig
;;   "DecodeConfig decodes the color model and dimensions of an image that has\nbeen encoded in a registered format. The string returned is the format name\nused during format registration. Format registration is typically done by\nan init function in the codec-specific package.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (Config, string, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Config String Error]"
;;   {:added "1.0"
;;    :go "__decodeConfig(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC image.NewAlpha from image/image.go:
(defn NewAlpha
  "NewAlpha returns a new Alpha image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *Alpha\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/Alpha)"
  {:added "1.0"
   :go "__newAlpha(*_r)"}
  [^image/Rectangle _r])

JOKER FUNC image.NewAlpha16 from image/image.go:
(defn NewAlpha16
  "NewAlpha16 returns a new Alpha16 image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *Alpha16\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/Alpha16)"
  {:added "1.0"
   :go "__newAlpha16(*_r)"}
  [^image/Rectangle _r])

JOKER FUNC image.NewCMYK from image/image.go:
(defn NewCMYK
  "NewCMYK returns a new CMYK image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *CMYK\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/CMYK)"
  {:added "1.0"
   :go "__newCMYK(*_r)"}
  [^image/Rectangle _r])

JOKER FUNC image.NewGray from image/image.go:
(defn NewGray
  "NewGray returns a new Gray image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *Gray\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/Gray)"
  {:added "1.0"
   :go "__newGray(*_r)"}
  [^image/Rectangle _r])

JOKER FUNC image.NewGray16 from image/image.go:
(defn NewGray16
  "NewGray16 returns a new Gray16 image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *Gray16\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/Gray16)"
  {:added "1.0"
   :go "__newGray16(*_r)"}
  [^image/Rectangle _r])

JOKER FUNC image.NewNRGBA from image/image.go:
(defn NewNRGBA
  "NewNRGBA returns a new NRGBA image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *NRGBA\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/NRGBA)"
  {:added "1.0"
   :go "__newNRGBA(*_r)"}
  [^image/Rectangle _r])

JOKER FUNC image.NewNRGBA64 from image/image.go:
(defn NewNRGBA64
  "NewNRGBA64 returns a new NRGBA64 image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *NRGBA64\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/NRGBA64)"
  {:added "1.0"
   :go "__newNRGBA64(*_r)"}
  [^image/Rectangle _r])

JOKER FUNC image.NewNYCbCrA from image/ycbcr.go:
(defn NewNYCbCrA
  "NewNYCbCrA returns a new NYCbCrA image with the given bounds and subsample\nratio.\n\nGo input arguments: (r Rectangle, subsampleRatio YCbCrSubsampleRatio)\n\nGo return type: *NYCbCrA\n\nJoker input arguments: [^go.std.image/Rectangle r, ^go.std.image/YCbCrSubsampleRatio subsampleRatio]\n\nJoker return type: (atom-of go.std.image/NYCbCrA)"
  {:added "1.0"
   :go "__newNYCbCrA(*_r, *_subsampleRatio)"}
  [^image/Rectangle _r, ^image/YCbCrSubsampleRatio _subsampleRatio])

JOKER FUNC image.NewPaletted from image/image.go:
;; (defn NewPaletted
;;   "NewPaletted returns a new Paletted image with the given width, height and\npalette.\n\nGo input arguments: (r Rectangle, p color.Palette)\n\nGo return type: *Paletted\n\nJoker input arguments: [^go.std.image/Rectangle r, ^go.std.image.color/Palette p]\n\nJoker return type: (atom-of go.std.image/Paletted)"
;;   {:added "1.0"
;;    :go "__newPaletted(*_r, *_p)"}
;;   [^image/Rectangle _r, ^color/Palette _p])

JOKER FUNC image.NewRGBA from image/image.go:
(defn NewRGBA
  "NewRGBA returns a new RGBA image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *RGBA\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/RGBA)"
  {:added "1.0"
   :go "__newRGBA(*_r)"}
  [^image/Rectangle _r])

JOKER FUNC image.NewRGBA64 from image/image.go:
(defn NewRGBA64
  "NewRGBA64 returns a new RGBA64 image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *RGBA64\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/RGBA64)"
  {:added "1.0"
   :go "__newRGBA64(*_r)"}
  [^image/Rectangle _r])

JOKER FUNC image.NewUniform from image/names.go:
;; (defn NewUniform
;;   "Go input arguments: (c color.Color)\n\nGo return type: *Uniform\n\nJoker input arguments: [^go.std.image.color/Color c]\n\nJoker return type: (atom-of go.std.image/Uniform)"
;;   {:added "1.0"
;;    :go "__newUniform(*_c)"}
;;   [^color/Color _c])

JOKER FUNC image.NewYCbCr from image/ycbcr.go:
(defn NewYCbCr
  "NewYCbCr returns a new YCbCr image with the given bounds and subsample\nratio.\n\nGo input arguments: (r Rectangle, subsampleRatio YCbCrSubsampleRatio)\n\nGo return type: *YCbCr\n\nJoker input arguments: [^go.std.image/Rectangle r, ^go.std.image/YCbCrSubsampleRatio subsampleRatio]\n\nJoker return type: (atom-of go.std.image/YCbCr)"
  {:added "1.0"
   :go "__newYCbCr(*_r, *_subsampleRatio)"}
  [^image/Rectangle _r, ^image/YCbCrSubsampleRatio _subsampleRatio])

JOKER FUNC image.Pt from image/geom.go:
(defn Pt
  "Pt is shorthand for Point{X, Y}.\n\nGo input arguments: (X int, Y int)\n\nGo return type: Point\n\nJoker input arguments: [^Int X, ^Int Y]\n\nJoker return type: go.std.image/Point"
  {:added "1.0"
   :go "__pt(_X, _Y)"}
  [^Int _X, ^Int _Y])

JOKER FUNC image.Rect from image/geom.go:
(defn Rect
  "Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}. The returned\nrectangle has minimum and maximum coordinates swapped if necessary so that\nit is well-formed.\n\nGo input arguments: (x0 int, y0 int, x1 int, y1 int)\n\nGo return type: Rectangle\n\nJoker input arguments: [^Int x0, ^Int y0, ^Int x1, ^Int y1]\n\nJoker return type: go.std.image/Rectangle"
  {:added "1.0"
   :go "__rect(_x0, _y0, _x1, _y1)"}
  [^Int _x0, ^Int _y0, ^Int _x1, ^Int _y1])

JOKER FUNC image.RegisterFormat from image/format.go:
;; (defn RegisterFormat
;;   "RegisterFormat registers an image format for use by Decode.\nName is the name of the format, like \"jpeg\" or \"png\".\nMagic is the magic prefix that identifies the format's encoding. The magic\nstring can contain \"?\" wildcards that each match any one byte.\nDecode is the function that decodes the encoded image.\nDecodeConfig is the function that decodes just its configuration.\n\nGo input arguments: (name string, magic string, decode func, decodeConfig func)\n\nJoker input arguments: [^String name, ^String magic, ^fn decode, ^fn decodeConfig]"
;;   {:added "1.0"
;;    :go "__registerFormat(_name, _magic, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String _name, ^String _magic, ^fn _decode, ^fn _decodeConfig])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the image package."
    :empty false}
  go.std.image)
JOKER FUNC image/color.CMYKToRGB from image/color/ycbcr.go:
;; (defn CMYKToRGB
;;   "CMYKToRGB converts a CMYK quadruple to an RGB triple.\n\nGo input arguments: (c uint8, m uint8, y uint8, k uint8)\n\nGo return type: (..., ..., ...)\n\nJoker input arguments: [^uint8 c, ^uint8 m, ^uint8 y, ^uint8 k]\n\nJoker return type: [ABEND043(post.go: unsupported built-in type uint8) ABEND043(post.go: unsupported built-in type uint8) ABEND043(post.go: unsupported built-in type uint8)]"
;;   {:added "1.0"
;;    :go "__cMYKToRGB(_c, _m, _y, _k)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint8) _c, ^ABEND044(pre.go: unsupported built-in type uint8) _m, ^ABEND044(pre.go: unsupported built-in type uint8) _y, ^ABEND044(pre.go: unsupported built-in type uint8) _k])

JOKER FUNC image/color.ModelFunc from image/color/color.go:
;; (defn ModelFunc
;;   "ModelFunc returns a Model that invokes f to implement the conversion.\n\nGo input arguments: (f func)\n\nGo return type: Model\n\nJoker input arguments: [^fn f]\n\nJoker return type: go.std.image.color/Model"
;;   {:added "1.0"
;;    :go "__modelFunc(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^fn _f])

JOKER FUNC image/color.RGBToCMYK from image/color/ycbcr.go:
;; (defn RGBToCMYK
;;   "RGBToCMYK converts an RGB triple to a CMYK quadruple.\n\nGo input arguments: (r uint8, g uint8, b uint8)\n\nGo return type: (..., ..., ..., ...)\n\nJoker input arguments: [^uint8 r, ^uint8 g, ^uint8 b]\n\nJoker return type: [ABEND043(post.go: unsupported built-in type uint8) ABEND043(post.go: unsupported built-in type uint8) ABEND043(post.go: unsupported built-in type uint8) ABEND043(post.go: unsupported built-in type uint8)]"
;;   {:added "1.0"
;;    :go "__rGBToCMYK(_r, _g, _b)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint8) _r, ^ABEND044(pre.go: unsupported built-in type uint8) _g, ^ABEND044(pre.go: unsupported built-in type uint8) _b])

JOKER FUNC image/color.RGBToYCbCr from image/color/ycbcr.go:
;; (defn RGBToYCbCr
;;   "RGBToYCbCr converts an RGB triple to a Y'CbCr triple.\n\nGo input arguments: (r uint8, g uint8, b uint8)\n\nGo return type: (..., ..., ...)\n\nJoker input arguments: [^uint8 r, ^uint8 g, ^uint8 b]\n\nJoker return type: [ABEND043(post.go: unsupported built-in type uint8) ABEND043(post.go: unsupported built-in type uint8) ABEND043(post.go: unsupported built-in type uint8)]"
;;   {:added "1.0"
;;    :go "__rGBToYCbCr(_r, _g, _b)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint8) _r, ^ABEND044(pre.go: unsupported built-in type uint8) _g, ^ABEND044(pre.go: unsupported built-in type uint8) _b])

JOKER FUNC image/color.YCbCrToRGB from image/color/ycbcr.go:
;; (defn YCbCrToRGB
;;   "YCbCrToRGB converts a Y'CbCr triple to an RGB triple.\n\nGo input arguments: (y uint8, cb uint8, cr uint8)\n\nGo return type: (..., ..., ...)\n\nJoker input arguments: [^uint8 y, ^uint8 cb, ^uint8 cr]\n\nJoker return type: [ABEND043(post.go: unsupported built-in type uint8) ABEND043(post.go: unsupported built-in type uint8) ABEND043(post.go: unsupported built-in type uint8)]"
;;   {:added "1.0"
;;    :go "__yCbCrToRGB(_y, _cb, _cr)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint8) _y, ^ABEND044(pre.go: unsupported built-in type uint8) _cb, ^ABEND044(pre.go: unsupported built-in type uint8) _cr])

JOKER FUNC image/draw.Draw from image/draw/draw.go:
;; (defn Draw
;;   "Draw calls DrawMask with a nil mask.\n\nGo input arguments: (dst Image, r image.Rectangle, src image.Image, sp image.Point, op Op)\n\nJoker input arguments: [^go.std.image.draw/Image dst, ^go.std.image/Rectangle r, ^go.std.image/Image src, ^go.std.image/Point sp, ^go.std.image.draw/Op op]"
;;   {:added "1.0"
;;    :go "__draw(*_dst, *_r, *_src, *_sp, *_op)"}
;;   [^draw/Image _dst, ^image/Rectangle _r, ^image/Image _src, ^image/Point _sp, ^draw/Op _op])

JOKER FUNC image/draw.DrawMask from image/draw/draw.go:
;; (defn DrawMask
;;   "DrawMask aligns r.Min in dst with sp in src and mp in mask and then replaces the rectangle r\nin dst with the result of a Porter-Duff composition. A nil mask is treated as opaque.\n\nGo input arguments: (dst Image, r image.Rectangle, src image.Image, sp image.Point, mask image.Image, mp image.Point, op Op)\n\nJoker input arguments: [^go.std.image.draw/Image dst, ^go.std.image/Rectangle r, ^go.std.image/Image src, ^go.std.image/Point sp, ^go.std.image/Image mask, ^go.std.image/Point mp, ^go.std.image.draw/Op op]"
;;   {:added "1.0"
;;    :go "__drawMask(*_dst, *_r, *_src, *_sp, *_mask, *_mp, *_op)"}
;;   [^draw/Image _dst, ^image/Rectangle _r, ^image/Image _src, ^image/Point _sp, ^image/Image _mask, ^image/Point _mp, ^draw/Op _op])

JOKER FUNC image/gif.Decode from image/gif/reader.go:
;; (defn Decode
;;   "Decode reads a GIF image from r and returns the first embedded\nimage as an image.Image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Image, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Image Error]"
;;   {:added "1.0"
;;    :go "__decode(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC image/gif.DecodeAll from image/gif/reader.go:
;; (defn DecodeAll
;;   "DecodeAll reads a GIF image from r and returns the sequential frames\nand timing information.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (*GIF, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [(atom-of go.std.image.gif/GIF) Error]"
;;   {:added "1.0"
;;    :go "__decodeAll(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC image/gif.DecodeConfig from image/gif/reader.go:
;; (defn DecodeConfig
;;   "DecodeConfig returns the global color model and dimensions of a GIF image\nwithout decoding the entire image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Config, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Config Error]"
;;   {:added "1.0"
;;    :go "__decodeConfig(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC image/gif.Encode from image/gif/writer.go:
;; (defn ^"Error" Encode
;;   "Encode writes the Image m to w in GIF format.\n\nGo input arguments: (w io.Writer, m image.Image, o *Options)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^go.std.image/Image m, ^(atom-of go.std.image.gif/Options) o]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "gif.Encode(*_w, *_m, _o)"}
;;   [^io/Writer _w, ^image/Image _m, ^gif/Options _o])

JOKER FUNC image/gif.EncodeAll from image/gif/writer.go:
;; (defn ^"Error" EncodeAll
;;   "EncodeAll writes the images in g to w in GIF format with the\ngiven loop count and delay between frames.\n\nGo input arguments: (w io.Writer, g *GIF)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^(atom-of go.std.image.gif/GIF) g]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "gif.EncodeAll(*_w, _g)"}
;;   [^io/Writer _w, ^gif/GIF _g])

JOKER FUNC image/jpeg.Decode from image/jpeg/reader.go:
;; (defn Decode
;;   "Decode reads a JPEG image from r and returns it as an image.Image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Image, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Image Error]"
;;   {:added "1.0"
;;    :go "__decode(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC image/jpeg.DecodeConfig from image/jpeg/reader.go:
;; (defn DecodeConfig
;;   "DecodeConfig returns the color model and dimensions of a JPEG image without\ndecoding the entire image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Config, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Config Error]"
;;   {:added "1.0"
;;    :go "__decodeConfig(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC image/jpeg.Encode from image/jpeg/writer.go:
;; (defn ^"Error" Encode
;;   "Encode writes the Image m to w in JPEG 4:2:0 baseline format with the given\noptions. Default parameters are used if a nil *Options is passed.\n\nGo input arguments: (w io.Writer, m image.Image, o *Options)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^go.std.image/Image m, ^(atom-of go.std.image.jpeg/Options) o]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "jpeg.Encode(*_w, *_m, _o)"}
;;   [^io/Writer _w, ^image/Image _m, ^jpeg/Options _o])

JOKER FUNC image/png.Decode from image/png/reader.go:
;; (defn Decode
;;   "Decode reads a PNG image from r and returns it as an image.Image.\nThe type of Image returned depends on the PNG contents.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Image, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Image Error]"
;;   {:added "1.0"
;;    :go "__decode(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC image/png.DecodeConfig from image/png/reader.go:
;; (defn DecodeConfig
;;   "DecodeConfig returns the color model and dimensions of a PNG image without\ndecoding the entire image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Config, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Config Error]"
;;   {:added "1.0"
;;    :go "__decodeConfig(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC image/png.Encode from image/png/writer.go:
;; (defn ^"Error" Encode
;;   "Encode writes the Image m to w in PNG format. Any Image may be\nencoded, but images that are not image.NRGBA might be encoded lossily.\n\nGo input arguments: (w io.Writer, m image.Image)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^go.std.image/Image m]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "png.Encode(*_w, *_m)"}
;;   [^io/Writer _w, ^image/Image _m])

JOKER FUNC index/suffixarray.New from index/suffixarray/suffixarray.go:
;; (defn New
;;   "New creates a new Index for data.\nIndex creation time is O(N*log(N)) for N = len(data).\n\nGo input arguments: (data []byte)\n\nGo return type: *Index\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (atom-of go.std.index.suffixarray/Index)"
;;   {:added "1.0"
;;    :go "__new(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER TYPE io.ByteReader from io/io.go:
;; (defn ^"GoObject" ByteReader.
;;   "Constructor for io.ByteReader"
;;   {:added "1.0"
;;    :go "_ConstructByteReader(_v)"}
;;   [^Object _v])

JOKER TYPE io.ByteScanner from io/io.go:
;; (defn ^"GoObject" ByteScanner.
;;   "Constructor for io.ByteScanner"
;;   {:added "1.0"
;;    :go "_ConstructByteScanner(_v)"}
;;   [^Object _v])

JOKER TYPE io.ByteWriter from io/io.go:
;; (defn ^"GoObject" ByteWriter.
;;   "Constructor for io.ByteWriter"
;;   {:added "1.0"
;;    :go "_ConstructByteWriter(_v)"}
;;   [^Object _v])

JOKER TYPE io.Closer from io/io.go:
;; (defn ^"GoObject" Closer.
;;   "Constructor for io.Closer"
;;   {:added "1.0"
;;    :go "_ConstructCloser(_v)"}
;;   [^Object _v])

JOKER TYPE io.LimitedReader from io/io.go:
(defn ^"GoObject" LimitedReader.
  "Constructor for io.LimitedReader"
  {:added "1.0"
   :go "_ConstructLimitedReader(_v)"}
  [^Object _v])

JOKER TYPE io.PipeReader from io/pipe.go:
(defn ^"GoObject" PipeReader.
  "Constructor for io.PipeReader"
  {:added "1.0"
   :go "_ConstructPipeReader(_v)"}
  [^Object _v])

JOKER TYPE io.PipeWriter from io/pipe.go:
(defn ^"GoObject" PipeWriter.
  "Constructor for io.PipeWriter"
  {:added "1.0"
   :go "_ConstructPipeWriter(_v)"}
  [^Object _v])

JOKER TYPE io.ReadCloser from io/io.go:
;; (defn ^"GoObject" ReadCloser.
;;   "Constructor for io.ReadCloser"
;;   {:added "1.0"
;;    :go "_ConstructReadCloser(_v)"}
;;   [^Object _v])

JOKER TYPE io.ReadSeeker from io/io.go:
;; (defn ^"GoObject" ReadSeeker.
;;   "Constructor for io.ReadSeeker"
;;   {:added "1.0"
;;    :go "_ConstructReadSeeker(_v)"}
;;   [^Object _v])

JOKER TYPE io.ReadWriteCloser from io/io.go:
;; (defn ^"GoObject" ReadWriteCloser.
;;   "Constructor for io.ReadWriteCloser"
;;   {:added "1.0"
;;    :go "_ConstructReadWriteCloser(_v)"}
;;   [^Object _v])

JOKER TYPE io.ReadWriteSeeker from io/io.go:
;; (defn ^"GoObject" ReadWriteSeeker.
;;   "Constructor for io.ReadWriteSeeker"
;;   {:added "1.0"
;;    :go "_ConstructReadWriteSeeker(_v)"}
;;   [^Object _v])

JOKER TYPE io.ReadWriter from io/io.go:
;; (defn ^"GoObject" ReadWriter.
;;   "Constructor for io.ReadWriter"
;;   {:added "1.0"
;;    :go "_ConstructReadWriter(_v)"}
;;   [^Object _v])

JOKER TYPE io.Reader from io/io.go:
;; (defn ^"GoObject" Reader.
;;   "Constructor for io.Reader"
;;   {:added "1.0"
;;    :go "_ConstructReader(_v)"}
;;   [^Object _v])

JOKER TYPE io.ReaderAt from io/io.go:
;; (defn ^"GoObject" ReaderAt.
;;   "Constructor for io.ReaderAt"
;;   {:added "1.0"
;;    :go "_ConstructReaderAt(_v)"}
;;   [^Object _v])

JOKER TYPE io.ReaderFrom from io/io.go:
;; (defn ^"GoObject" ReaderFrom.
;;   "Constructor for io.ReaderFrom"
;;   {:added "1.0"
;;    :go "_ConstructReaderFrom(_v)"}
;;   [^Object _v])

JOKER TYPE io.RuneReader from io/io.go:
;; (defn ^"GoObject" RuneReader.
;;   "Constructor for io.RuneReader"
;;   {:added "1.0"
;;    :go "_ConstructRuneReader(_v)"}
;;   [^Object _v])

JOKER TYPE io.RuneScanner from io/io.go:
;; (defn ^"GoObject" RuneScanner.
;;   "Constructor for io.RuneScanner"
;;   {:added "1.0"
;;    :go "_ConstructRuneScanner(_v)"}
;;   [^Object _v])

JOKER TYPE io.SectionReader from io/io.go:
(defn ^"GoObject" SectionReader.
  "Constructor for io.SectionReader"
  {:added "1.0"
   :go "_ConstructSectionReader(_v)"}
  [^Object _v])

JOKER TYPE io.Seeker from io/io.go:
;; (defn ^"GoObject" Seeker.
;;   "Constructor for io.Seeker"
;;   {:added "1.0"
;;    :go "_ConstructSeeker(_v)"}
;;   [^Object _v])

JOKER TYPE io.WriteCloser from io/io.go:
;; (defn ^"GoObject" WriteCloser.
;;   "Constructor for io.WriteCloser"
;;   {:added "1.0"
;;    :go "_ConstructWriteCloser(_v)"}
;;   [^Object _v])

JOKER TYPE io.WriteSeeker from io/io.go:
;; (defn ^"GoObject" WriteSeeker.
;;   "Constructor for io.WriteSeeker"
;;   {:added "1.0"
;;    :go "_ConstructWriteSeeker(_v)"}
;;   [^Object _v])

JOKER TYPE io.Writer from io/io.go:
;; (defn ^"GoObject" Writer.
;;   "Constructor for io.Writer"
;;   {:added "1.0"
;;    :go "_ConstructWriter(_v)"}
;;   [^Object _v])

JOKER TYPE io.WriterAt from io/io.go:
;; (defn ^"GoObject" WriterAt.
;;   "Constructor for io.WriterAt"
;;   {:added "1.0"
;;    :go "_ConstructWriterAt(_v)"}
;;   [^Object _v])

JOKER TYPE io.WriterTo from io/io.go:
;; (defn ^"GoObject" WriterTo.
;;   "Constructor for io.WriterTo"
;;   {:added "1.0"
;;    :go "_ConstructWriterTo(_v)"}
;;   [^Object _v])

JOKER FUNC io.Copy from io/io.go:
(defn Copy
  "Copy copies from src to dst until either EOF is reached\non src or an error occurs. It returns the number of bytes\ncopied and the first error encountered while copying, if any.\n\nA successful Copy returns err == nil, not err == EOF.\nBecause Copy is defined to read from src until EOF, it does\nnot treat an EOF from Read as an error to be reported.\n\nIf src implements the WriterTo interface,\nthe copy is implemented by calling src.WriteTo(dst).\nOtherwise, if dst implements the ReaderFrom interface,\nthe copy is implemented by calling dst.ReadFrom(src).\n\nGo input arguments: (dst Writer, src Reader)\n\nGo return type: (written int64, err error)\n\nJoker input arguments: [^go.std.io/Writer dst, ^go.std.io/Reader src]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__copy(*_dst, *_src)"}
  [^io/Writer _dst, ^io/Reader _src])

JOKER FUNC io.CopyBuffer from io/io.go:
;; (defn CopyBuffer
;;   "CopyBuffer is identical to Copy except that it stages through the\nprovided buffer (if one is required) rather than allocating a\ntemporary one. If buf is nil, one is allocated; otherwise if it has\nzero length, CopyBuffer panics.\n\nGo input arguments: (dst Writer, src Reader, buf []byte)\n\nGo return type: (written int64, err error)\n\nJoker input arguments: [^go.std.io/Writer dst, ^go.std.io/Reader src, ^(vector-of Byte) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__copyBuffer(*_dst, *_src, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)))"}
;;   [^io/Writer _dst, ^io/Reader _src, ^Object _buf])

JOKER FUNC io.CopyN from io/io.go:
(defn CopyN
  "CopyN copies n bytes (or until an error) from src to dst.\nIt returns the number of bytes copied and the earliest\nerror encountered while copying.\nOn return, written == n if and only if err == nil.\n\nIf dst implements the ReaderFrom interface,\nthe copy is implemented using it.\n\nGo input arguments: (dst Writer, src Reader, n int64)\n\nGo return type: (written int64, err error)\n\nJoker input arguments: [^go.std.io/Writer dst, ^go.std.io/Reader src, ^Int64 n]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__copyN(*_dst, *_src, _n)"}
  [^io/Writer _dst, ^io/Reader _src, ^Int64 _n])

JOKER FUNC io.LimitReader from io/io.go:
(defn LimitReader
  "LimitReader returns a Reader that reads from r\nbut stops with EOF after n bytes.\nThe underlying implementation is a *LimitedReader.\n\nGo input arguments: (r Reader, n int64)\n\nGo return type: Reader\n\nJoker input arguments: [^go.std.io/Reader r, ^Int64 n]\n\nJoker return type: go.std.io/Reader"
  {:added "1.0"
   :go "__limitReader(*_r, _n)"}
  [^io/Reader _r, ^Int64 _n])

JOKER FUNC io.MultiReader from io/multi.go:
;; (defn MultiReader
;;   "MultiReader returns a Reader that's the logical concatenation of\nthe provided input readers. They're read sequentially. Once all\ninputs have returned EOF, Read will return EOF.  If any of the readers\nreturn a non-nil, non-EOF error, Read will return that error.\n\nGo input arguments: (readers ...Reader)\n\nGo return type: Reader\n\nJoker input arguments: [^(ellipsis-somehow io/Reader) readers]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__multiReader(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHa_io.Reader(*_readers)))"}
;;   [^io/Reader _readers])

JOKER FUNC io.MultiWriter from io/multi.go:
;; (defn MultiWriter
;;   "MultiWriter creates a writer that duplicates its writes to all the\nprovided writers, similar to the Unix tee(1) command.\n\nEach write is written to each listed writer, one at a time.\nIf a listed writer returns an error, that overall write operation\nstops and returns the error; it does not continue down the list.\n\nGo input arguments: (writers ...Writer)\n\nGo return type: Writer\n\nJoker input arguments: [^(ellipsis-somehow io/Writer) writers]\n\nJoker return type: go.std.io/Writer"
;;   {:added "1.0"
;;    :go "__multiWriter(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHa_io.Writer(*_writers)))"}
;;   [^io/Writer _writers])

JOKER FUNC io.NewSectionReader from io/io.go:
(defn NewSectionReader
  "NewSectionReader returns a SectionReader that reads from r\nstarting at offset off and stops with EOF after n bytes.\n\nGo input arguments: (r ReaderAt, off int64, n int64)\n\nGo return type: *SectionReader\n\nJoker input arguments: [^go.std.io/ReaderAt r, ^Int64 off, ^Int64 n]\n\nJoker return type: (atom-of go.std.io/SectionReader)"
  {:added "1.0"
   :go "__newSectionReader(*_r, _off, _n)"}
  [^io/ReaderAt _r, ^Int64 _off, ^Int64 _n])

JOKER FUNC io.Pipe from io/pipe.go:
(defn Pipe
  "Pipe creates a synchronous in-memory pipe.\nIt can be used to connect code expecting an io.Reader\nwith code expecting an io.Writer.\n\nReads and Writes on the pipe are matched one to one\nexcept when multiple Reads are needed to consume a single Write.\nThat is, each Write to the PipeWriter blocks until it has satisfied\none or more Reads from the PipeReader that fully consume\nthe written data.\nThe data is copied directly from the Write to the corresponding\nRead (or Reads); there is no internal buffering.\n\nIt is safe to call Read and Write in parallel with each other or with Close.\nParallel calls to Read and parallel calls to Write are also safe:\nthe individual calls will be gated sequentially.\n\nGo return type: (*PipeReader, *PipeWriter)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.io/PipeReader) (atom-of go.std.io/PipeWriter)]"
  {:added "1.0"
   :go "__pipe()"}
  [])

JOKER FUNC io.ReadAtLeast from io/io.go:
;; (defn ReadAtLeast
;;   "ReadAtLeast reads from r into buf until it has read at least min bytes.\nIt returns the number of bytes copied and an error if fewer bytes were read.\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading fewer than min bytes,\nReadAtLeast returns ErrUnexpectedEOF.\nIf min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer.\nOn return, n >= min if and only if err == nil.\nIf r returns an error having read at least min bytes, the error is dropped.\n\nGo input arguments: (r Reader, buf []byte, min int)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Reader r, ^(vector-of Byte) buf, ^Int min]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__readAtLeast(*_r, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)), _min)"}
;;   [^io/Reader _r, ^Object _buf, ^Int _min])

JOKER FUNC io.ReadFull from io/io.go:
;; (defn ReadFull
;;   "ReadFull reads exactly len(buf) bytes from r into buf.\nIt returns the number of bytes copied and an error if fewer bytes were read.\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading some but not all the bytes,\nReadFull returns ErrUnexpectedEOF.\nOn return, n == len(buf) if and only if err == nil.\nIf r returns an error having read at least len(buf) bytes, the error is dropped.\n\nGo input arguments: (r Reader, buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Reader r, ^(vector-of Byte) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__readFull(*_r, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)))"}
;;   [^io/Reader _r, ^Object _buf])

JOKER FUNC io.TeeReader from io/io.go:
(defn TeeReader
  "TeeReader returns a Reader that writes to w what it reads from r.\nAll reads from r performed through it are matched with\ncorresponding writes to w. There is no internal buffering -\nthe write must complete before the read completes.\nAny error encountered while writing is reported as a read error.\n\nGo input arguments: (r Reader, w Writer)\n\nGo return type: Reader\n\nJoker input arguments: [^go.std.io/Reader r, ^go.std.io/Writer w]\n\nJoker return type: go.std.io/Reader"
  {:added "1.0"
   :go "__teeReader(*_r, *_w)"}
  [^io/Reader _r, ^io/Writer _w])

JOKER FUNC io.WriteString from io/io.go:
(defn WriteString
  "WriteString writes the contents of the string s to w, which accepts a slice of bytes.\nIf w implements a WriteString method, it is invoked directly.\nOtherwise, w.Write is called exactly once.\n\nGo input arguments: (w Writer, s string)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Writer w, ^String s]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__writeString(*_w, _s)"}
  [^io/Writer _w, ^String _s])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the io package."
    :empty false}
  go.std.io)
JOKER FUNC io/ioutil.NopCloser from io/ioutil/ioutil.go:
;; (defn NopCloser
;;   "NopCloser returns a ReadCloser with a no-op Close method wrapping\nthe provided Reader r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.ReadCloser\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "__nopCloser(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC io/ioutil.ReadAll from io/ioutil/ioutil.go:
;; (defn ReadAll
;;   "ReadAll reads from r until an error or EOF and returns the data it read.\nA successful call returns err == nil, not err == EOF. Because ReadAll is\ndefined to read from src until EOF, it does not treat an EOF from Read\nas an error to be reported.\n\nGo input arguments: (r io.Reader)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__readAll(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC io/ioutil.ReadDir from io/ioutil/ioutil.go:
(defn ReadDir
  "ReadDir reads the directory named by dirname and returns\na list of directory entries sorted by filename.\n\nGo input arguments: (dirname string)\n\nGo return type: ([]os.FileInfo, error)\n\nJoker input arguments: [^String dirname]\n\nJoker return type: [(vector-of go.std.os/FileInfo) Error]"
  {:added "1.0"
   :go "__readDir(_dirname)"}
  [^String _dirname])

JOKER FUNC io/ioutil.ReadFile from io/ioutil/ioutil.go:
(defn ReadFile
  "ReadFile reads the file named by filename and returns the contents.\nA successful call returns err == nil, not err == EOF. Because ReadFile\nreads the whole file, it does not treat an EOF from Read as an error\nto be reported.\n\nGo input arguments: (filename string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^String filename]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__readFile(_filename)"}
  [^String _filename])

JOKER FUNC io/ioutil.TempDir from io/ioutil/tempfile.go:
(defn TempDir
  "TempDir creates a new temporary directory in the directory dir\nwith a name beginning with prefix and returns the path of the\nnew directory. If dir is the empty string, TempDir uses the\ndefault directory for temporary files (see os.TempDir).\nMultiple programs calling TempDir simultaneously\nwill not choose the same directory. It is the caller's responsibility\nto remove the directory when no longer needed.\n\nGo input arguments: (dir string, prefix string)\n\nGo return type: (name string, err error)\n\nJoker input arguments: [^String dir, ^String prefix]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__tempDir(_dir, _prefix)"}
  [^String _dir, ^String _prefix])

JOKER FUNC io/ioutil.TempFile from io/ioutil/tempfile.go:
(defn TempFile
  "TempFile creates a new temporary file in the directory dir,\nopens the file for reading and writing, and returns the resulting *os.File.\nThe filename is generated by taking pattern and adding a random\nstring to the end. If pattern includes a \"*\", the random string\nreplaces the last \"*\".\nIf dir is the empty string, TempFile uses the default directory\nfor temporary files (see os.TempDir).\nMultiple programs calling TempFile simultaneously\nwill not choose the same file. The caller can use f.Name()\nto find the pathname of the file. It is the caller's responsibility\nto remove the file when no longer needed.\n\nGo input arguments: (dir string, pattern string)\n\nGo return type: (f *os.File, err error)\n\nJoker input arguments: [^String dir, ^String pattern]\n\nJoker return type: [(atom-of go.std.os/File) Error]"
  {:added "1.0"
   :go "__tempFile(_dir, _pattern)"}
  [^String _dir, ^String _pattern])

JOKER FUNC io/ioutil.WriteFile from io/ioutil/ioutil.go:
;; (defn ^"Error" WriteFile
;;   "WriteFile writes data to a file named by filename.\nIf the file does not exist, WriteFile creates it with permissions perm;\notherwise WriteFile truncates it before writing.\n\nGo input arguments: (filename string, data []byte, perm os.FileMode)\n\nGo return type: error\n\nJoker input arguments: [^String filename, ^(vector-of Byte) data, ^go.std.os/FileMode perm]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "ioutil.WriteFile(_filename, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), *_perm)"}
;;   [^String _filename, ^Object _data, ^os/FileMode _perm])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the io/ioutil package."
    :empty false}
  go.std.io.ioutil)
JOKER TYPE log.Logger from log/log.go:
(defn ^"GoObject" Logger.
  "Constructor for log.Logger"
  {:added "1.0"
   :go "_ConstructLogger(_v)"}
  [^Object _v])

JOKER FUNC log.Fatal from log/log.go:
;; (defn Fatal
;;   "Fatal is equivalent to Print() followed by a call to os.Exit(1).\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__fatal(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC log.Fatalf from log/log.go:
;; (defn Fatalf
;;   "Fatalf is equivalent to Printf() followed by a call to os.Exit(1).\n\nGo input arguments: (format string, v ...interface {})\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__fatalf(_format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _format, ^<protocol-or-something> _v])

JOKER FUNC log.Fatalln from log/log.go:
;; (defn Fatalln
;;   "Fatalln is equivalent to Println() followed by a call to os.Exit(1).\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__fatalln(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC log.Flags from log/log.go:
(defn ^"Int" Flags
  "Flags returns the output flags for the standard logger.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "log.Flags()"}
  [])

JOKER FUNC log.New from log/log.go:
;; (defn New
;;   "New creates a new Logger. The out variable sets the\ndestination to which log data will be written.\nThe prefix appears at the beginning of each generated log line.\nThe flag argument defines the logging properties.\n\nGo input arguments: (out io.Writer, prefix string, flag int)\n\nGo return type: *Logger\n\nJoker input arguments: [^go.std.io/Writer out, ^String prefix, ^Int flag]\n\nJoker return type: (atom-of go.std.log/Logger)"
;;   {:added "1.0"
;;    :go "__new(*_out, _prefix, _flag)"}
;;   [^io/Writer _out, ^String _prefix, ^Int _flag])

JOKER FUNC log.Output from log/log.go:
(defn ^"Error" Output
  "Output writes the output for a logging event. The string s contains\nthe text to print after the prefix specified by the flags of the\nLogger. A newline is appended if the last character of s is not\nalready a newline. Calldepth is the count of the number of\nframes to skip when computing the file name and line number\nif Llongfile or Lshortfile is set; a value of 1 will print the details\nfor the caller of Output.\n\nGo input arguments: (calldepth int, s string)\n\nGo return type: error\n\nJoker input arguments: [^Int calldepth, ^String s]\n\nJoker return type: Error"
  {:added "1.0"
   :go "log.Output(_calldepth, _s)"}
  [^Int _calldepth, ^String _s])

JOKER FUNC log.Panic from log/log.go:
;; (defn Panic
;;   "Panic is equivalent to Print() followed by a call to panic().\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__panic(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC log.Panicf from log/log.go:
;; (defn Panicf
;;   "Panicf is equivalent to Printf() followed by a call to panic().\n\nGo input arguments: (format string, v ...interface {})\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__panicf(_format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _format, ^<protocol-or-something> _v])

JOKER FUNC log.Panicln from log/log.go:
;; (defn Panicln
;;   "Panicln is equivalent to Println() followed by a call to panic().\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__panicln(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC log.Prefix from log/log.go:
(defn ^"String" Prefix
  "Prefix returns the output prefix for the standard logger.\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "log.Prefix()"}
  [])

JOKER FUNC log.Print from log/log.go:
;; (defn Print
;;   "Print calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Print.\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__print(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC log.Printf from log/log.go:
;; (defn Printf
;;   "Printf calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Printf.\n\nGo input arguments: (format string, v ...interface {})\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__printf(_format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _format, ^<protocol-or-something> _v])

JOKER FUNC log.Println from log/log.go:
;; (defn Println
;;   "Println calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Println.\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__println(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC log.SetFlags from log/log.go:
;; (defn SetFlags
;;   "SetFlags sets the output flags for the standard logger.\n\nGo input arguments: (flag int)\n\nJoker input arguments: [^Int flag]"
;;   {:added "1.0"
;;    :go "__setFlags(_flag)"}
;;   [^Int _flag])

JOKER FUNC log.SetOutput from log/log.go:
;; (defn SetOutput
;;   "SetOutput sets the output destination for the standard logger.\n\nGo input arguments: (w io.Writer)\n\nJoker input arguments: [^go.std.io/Writer w]"
;;   {:added "1.0"
;;    :go "__setOutput(*_w)"}
;;   [^io/Writer _w])

JOKER FUNC log.SetPrefix from log/log.go:
;; (defn SetPrefix
;;   "SetPrefix sets the output prefix for the standard logger.\n\nGo input arguments: (prefix string)\n\nJoker input arguments: [^String prefix]"
;;   {:added "1.0"
;;    :go "__setPrefix(_prefix)"}
;;   [^String _prefix])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["log"]
    :doc "Provides a low-level interface to the log package."
    :empty false}
  go.std.log)
JOKER TYPE log/syslog.Priority from log/syslog/syslog.go:
(defn ^"GoObject" Priority.
  "Constructor for syslog.Priority"
  {:added "1.0"
   :go "_ConstructPriority(_v)"}
  [^Object _v])

JOKER TYPE log/syslog.Writer from log/syslog/syslog.go:
(defn ^"GoObject" Writer.
  "Constructor for syslog.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC log/syslog.Dial from log/syslog/syslog.go:
(defn Dial
  "Dial establishes a connection to a log daemon by connecting to\naddress raddr on the specified network. Each write to the returned\nwriter sends a log message with the facility and severity\n(from priority) and tag. If tag is empty, the os.Args[0] is used.\nIf network is empty, Dial will connect to the local syslog server.\nOtherwise, see the documentation for net.Dial for valid values\nof network and raddr.\n\nGo input arguments: (network string, raddr string, priority Priority, tag string)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^String network, ^String raddr, ^go.std.log.syslog/Priority priority, ^String tag]\n\nJoker return type: [(atom-of go.std.log.syslog/Writer) Error]"
  {:added "1.0"
   :go "__dial(_network, _raddr, *_priority, _tag)"}
  [^String _network, ^String _raddr, ^syslog/Priority _priority, ^String _tag])

JOKER FUNC log/syslog.New from log/syslog/syslog.go:
(defn New
  "New establishes a new connection to the system log daemon. Each\nwrite to the returned writer sends a log message with the given\npriority (a combination of the syslog facility and severity) and\nprefix tag. If tag is empty, the os.Args[0] is used.\n\nGo input arguments: (priority Priority, tag string)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.log.syslog/Priority priority, ^String tag]\n\nJoker return type: [(atom-of go.std.log.syslog/Writer) Error]"
  {:added "1.0"
   :go "__new(*_priority, _tag)"}
  [^syslog/Priority _priority, ^String _tag])

JOKER FUNC log/syslog.NewLogger from log/syslog/syslog.go:
(defn NewLogger
  "NewLogger creates a log.Logger whose output is written to the\nsystem log service with the specified priority, a combination of\nthe syslog facility and severity. The logFlag argument is the flag\nset passed through to log.New to create the Logger.\n\nGo input arguments: (p Priority, logFlag int)\n\nGo return type: (*log.Logger, error)\n\nJoker input arguments: [^go.std.log.syslog/Priority p, ^Int logFlag]\n\nJoker return type: [(atom-of go.std.log/Logger) Error]"
  {:added "1.0"
   :go "__newLogger(*_p, _logFlag)"}
  [^syslog/Priority _p, ^Int _logFlag])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the log/syslog package."
    :empty false}
  go.std.log.syslog)
JOKER FUNC math.Abs from math/abs.go:
;; (defn Abs
;;   "Abs returns the absolute value of x.\n\nSpecial cases are:\n\tAbs(±Inf) = +Inf\n\tAbs(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__abs(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Acos from math/asin.go:
;; (defn Acos
;;   "Acos returns the arccosine, in radians, of x.\n\nSpecial case is:\n\tAcos(x) = NaN if x < -1 or x > 1\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__acos(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Acosh from math/acosh.go:
;; (defn Acosh
;;   "Acosh returns the inverse hyperbolic cosine of x.\n\nSpecial cases are:\n\tAcosh(+Inf) = +Inf\n\tAcosh(x) = NaN if x < 1\n\tAcosh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__acosh(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Asin from math/asin.go:
;; (defn Asin
;;   "Asin returns the arcsine, in radians, of x.\n\nSpecial cases are:\n\tAsin(±0) = ±0\n\tAsin(x) = NaN if x < -1 or x > 1\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__asin(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Asinh from math/asinh.go:
;; (defn Asinh
;;   "Asinh returns the inverse hyperbolic sine of x.\n\nSpecial cases are:\n\tAsinh(±0) = ±0\n\tAsinh(±Inf) = ±Inf\n\tAsinh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__asinh(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Atan from math/atan.go:
;; (defn Atan
;;   "Atan returns the arctangent, in radians, of x.\n\nSpecial cases are:\n     Atan(±0) = ±0\n     Atan(±Inf) = ±Pi/2\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__atan(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Atan2 from math/atan2.go:
;; (defn Atan2
;;   "Atan2 returns the arc tangent of y/x, using\nthe signs of the two to determine the quadrant\nof the return value.\n\nSpecial cases are (in order):\n\tAtan2(y, NaN) = NaN\n\tAtan2(NaN, x) = NaN\n\tAtan2(+0, x>=0) = +0\n\tAtan2(-0, x>=0) = -0\n\tAtan2(+0, x<=-0) = +Pi\n\tAtan2(-0, x<=-0) = -Pi\n\tAtan2(y>0, 0) = +Pi/2\n\tAtan2(y<0, 0) = -Pi/2\n\tAtan2(+Inf, +Inf) = +Pi/4\n\tAtan2(-Inf, +Inf) = -Pi/4\n\tAtan2(+Inf, -Inf) = 3Pi/4\n\tAtan2(-Inf, -Inf) = -3Pi/4\n\tAtan2(y, +Inf) = 0\n\tAtan2(y>0, -Inf) = +Pi\n\tAtan2(y<0, -Inf) = -Pi\n\tAtan2(+Inf, x) = +Pi/2\n\tAtan2(-Inf, x) = -Pi/2\n\nGo input arguments: (y float64, x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 y, ^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__atan2(_y, _x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _y, ^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Atanh from math/atanh.go:
;; (defn Atanh
;;   "Atanh returns the inverse hyperbolic tangent of x.\n\nSpecial cases are:\n\tAtanh(1) = +Inf\n\tAtanh(±0) = ±0\n\tAtanh(-1) = -Inf\n\tAtanh(x) = NaN if x < -1 or x > 1\n\tAtanh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__atanh(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Cbrt from math/cbrt.go:
;; (defn Cbrt
;;   "Cbrt returns the cube root of x.\n\nSpecial cases are:\n\tCbrt(±0) = ±0\n\tCbrt(±Inf) = ±Inf\n\tCbrt(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__cbrt(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Ceil from math/floor.go:
;; (defn Ceil
;;   "Ceil returns the least integer value greater than or equal to x.\n\nSpecial cases are:\n\tCeil(±0) = ±0\n\tCeil(±Inf) = ±Inf\n\tCeil(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__ceil(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Copysign from math/copysign.go:
;; (defn Copysign
;;   "Copysign returns a value with the magnitude\nof x and the sign of y.\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__copysign(_x, _y)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x, ^ABEND044(pre.go: unsupported built-in type float64) _y])

JOKER FUNC math.Cos from math/sin.go:
;; (defn Cos
;;   "Cos returns the cosine of the radian argument x.\n\nSpecial cases are:\n\tCos(±Inf) = NaN\n\tCos(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__cos(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Cosh from math/sinh.go:
;; (defn Cosh
;;   "Cosh returns the hyperbolic cosine of x.\n\nSpecial cases are:\n\tCosh(±0) = 1\n\tCosh(±Inf) = +Inf\n\tCosh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__cosh(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Dim from math/dim.go:
;; (defn Dim
;;   "Dim returns the maximum of x-y or 0.\n\nSpecial cases are:\n\tDim(+Inf, +Inf) = NaN\n\tDim(-Inf, -Inf) = NaN\n\tDim(x, NaN) = Dim(NaN, x) = NaN\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__dim(_x, _y)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x, ^ABEND044(pre.go: unsupported built-in type float64) _y])

JOKER FUNC math.Erf from math/erf.go:
;; (defn Erf
;;   "Erf returns the error function of x.\n\nSpecial cases are:\n\tErf(+Inf) = 1\n\tErf(-Inf) = -1\n\tErf(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__erf(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Erfc from math/erf.go:
;; (defn Erfc
;;   "Erfc returns the complementary error function of x.\n\nSpecial cases are:\n\tErfc(+Inf) = 0\n\tErfc(-Inf) = 2\n\tErfc(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__erfc(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Erfcinv from math/erfinv.go:
;; (defn Erfcinv
;;   "Erfcinv returns the inverse of Erfc(x).\n\nSpecial cases are:\n\tErfcinv(0) = +Inf\n\tErfcinv(2) = -Inf\n\tErfcinv(x) = NaN if x < 0 or x > 2\n\tErfcinv(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__erfcinv(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Erfinv from math/erfinv.go:
;; (defn Erfinv
;;   "Erfinv returns the inverse error function of x.\n\nSpecial cases are:\n\tErfinv(1) = +Inf\n\tErfinv(-1) = -Inf\n\tErfinv(x) = NaN if x < -1 or x > 1\n\tErfinv(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__erfinv(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Exp from math/exp.go:
;; (defn Exp
;;   "Exp returns e**x, the base-e exponential of x.\n\nSpecial cases are:\n\tExp(+Inf) = +Inf\n\tExp(NaN) = NaN\nVery large values overflow to 0 or +Inf.\nVery small values underflow to 1.\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__exp(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Exp2 from math/exp.go:
;; (defn Exp2
;;   "Exp2 returns 2**x, the base-2 exponential of x.\n\nSpecial cases are the same as Exp.\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__exp2(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Expm1 from math/expm1.go:
;; (defn Expm1
;;   "Expm1 returns e**x - 1, the base-e exponential of x minus 1.\nIt is more accurate than Exp(x) - 1 when x is near zero.\n\nSpecial cases are:\n\tExpm1(+Inf) = +Inf\n\tExpm1(-Inf) = -1\n\tExpm1(NaN) = NaN\nVery large values overflow to -1 or +Inf.\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__expm1(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Float32bits from math/unsafe.go:
;; (defn Float32bits
;;   "Float32bits returns the IEEE 754 binary representation of f.\n\nGo input arguments: (f float32)\n\nGo return type: uint32\n\nJoker input arguments: [^float32 f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__float32bits(_f)"}
;;   [^ABEND044(pre.go: unsupported built-in type float32) _f])

JOKER FUNC math.Float32frombits from math/unsafe.go:
;; (defn Float32frombits
;;   "Float32frombits returns the floating point number corresponding\nto the IEEE 754 binary representation b.\n\nGo input arguments: (b uint32)\n\nGo return type: ...\n\nJoker input arguments: [^UInt32 b]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float32)"
;;   {:added "1.0"
;;    :go "__float32frombits(_b)"}
;;   [^UInt32 _b])

JOKER FUNC math.Float64bits from math/unsafe.go:
;; (defn Float64bits
;;   "Float64bits returns the IEEE 754 binary representation of f.\n\nGo input arguments: (f float64)\n\nGo return type: uint64\n\nJoker input arguments: [^float64 f]\n\nJoker return type: BigInt"
;;   {:added "1.0"
;;    :go "__float64bits(_f)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _f])

JOKER FUNC math.Float64frombits from math/unsafe.go:
;; (defn Float64frombits
;;   "Float64frombits returns the floating point number corresponding\nthe IEEE 754 binary representation b.\n\nGo input arguments: (b uint64)\n\nGo return type: ...\n\nJoker input arguments: [^uint64 b]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__float64frombits(_b)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint64) _b])

JOKER FUNC math.Floor from math/floor.go:
;; (defn Floor
;;   "Floor returns the greatest integer value less than or equal to x.\n\nSpecial cases are:\n\tFloor(±0) = ±0\n\tFloor(±Inf) = ±Inf\n\tFloor(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__floor(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Frexp from math/frexp.go:
;; (defn Frexp
;;   "Frexp breaks f into a normalized fraction\nand an integral power of two.\nIt returns frac and exp satisfying f == frac × 2**exp,\nwith the absolute value of frac in the interval [½, 1).\n\nSpecial cases are:\n\tFrexp(±0) = ±0, 0\n\tFrexp(±Inf) = ±Inf, 0\n\tFrexp(NaN) = NaN, 0\n\nGo input arguments: (f float64)\n\nGo return type: (frac ..., exp int)\n\nJoker input arguments: [^float64 f]\n\nJoker return type: [ABEND043(post.go: unsupported built-in type float64) Int]"
;;   {:added "1.0"
;;    :go "__frexp(_f)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _f])

JOKER FUNC math.Gamma from math/gamma.go:
;; (defn Gamma
;;   "Gamma returns the Gamma function of x.\n\nSpecial cases are:\n\tGamma(+Inf) = +Inf\n\tGamma(+0) = +Inf\n\tGamma(-0) = -Inf\n\tGamma(x) = NaN for integer x < 0\n\tGamma(-Inf) = NaN\n\tGamma(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__gamma(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Hypot from math/hypot.go:
;; (defn Hypot
;;   "Hypot returns Sqrt(p*p + q*q), taking care to avoid\nunnecessary overflow and underflow.\n\nSpecial cases are:\n\tHypot(±Inf, q) = +Inf\n\tHypot(p, ±Inf) = +Inf\n\tHypot(NaN, q) = NaN\n\tHypot(p, NaN) = NaN\n\nGo input arguments: (p float64, q float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 p, ^float64 q]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__hypot(_p, _q)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _p, ^ABEND044(pre.go: unsupported built-in type float64) _q])

JOKER FUNC math.Ilogb from math/logb.go:
;; (defn ^"Int" Ilogb
;;   "Ilogb returns the binary exponent of x as an integer.\n\nSpecial cases are:\n\tIlogb(±Inf) = MaxInt32\n\tIlogb(0) = MinInt32\n\tIlogb(NaN) = MaxInt32\n\nGo input arguments: (x float64)\n\nGo return type: int\n\nJoker input arguments: [^float64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "math.Ilogb(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Inf from math/bits.go:
;; (defn Inf
;;   "Inf returns positive infinity if sign >= 0, negative infinity if sign < 0.\n\nGo input arguments: (sign int)\n\nGo return type: ...\n\nJoker input arguments: [^Int sign]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__inf(_sign)"}
;;   [^Int _sign])

JOKER FUNC math.IsInf from math/bits.go:
;; (defn ^"Boolean" IsInf
;;   "IsInf reports whether f is an infinity, according to sign.\nIf sign > 0, IsInf reports whether f is positive infinity.\nIf sign < 0, IsInf reports whether f is negative infinity.\nIf sign == 0, IsInf reports whether f is either infinity.\n\nGo input arguments: (f float64, sign int)\n\nGo return type: bool\n\nJoker input arguments: [^float64 f, ^Int sign]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "math.IsInf(_f, _sign)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _f, ^Int _sign])

JOKER FUNC math.IsNaN from math/bits.go:
;; (defn ^"Boolean" IsNaN
;;   "IsNaN reports whether f is an IEEE 754 ``not-a-number'' value.\n\nGo input arguments: (f float64)\n\nGo return type: bool\n\nJoker input arguments: [^float64 f]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "math.IsNaN(_f)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _f])

JOKER FUNC math.J0 from math/j0.go:
;; (defn J0
;;   "J0 returns the order-zero Bessel function of the first kind.\n\nSpecial cases are:\n\tJ0(±Inf) = 0\n\tJ0(0) = 1\n\tJ0(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__j0(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.J1 from math/j1.go:
;; (defn J1
;;   "J1 returns the order-one Bessel function of the first kind.\n\nSpecial cases are:\n\tJ1(±Inf) = 0\n\tJ1(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__j1(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Jn from math/jn.go:
;; (defn Jn
;;   "Jn returns the order-n Bessel function of the first kind.\n\nSpecial cases are:\n\tJn(n, ±Inf) = 0\n\tJn(n, NaN) = NaN\n\nGo input arguments: (n int, x float64)\n\nGo return type: ...\n\nJoker input arguments: [^Int n, ^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__jn(_n, _x)"}
;;   [^Int _n, ^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Ldexp from math/ldexp.go:
;; (defn Ldexp
;;   "Ldexp is the inverse of Frexp.\nIt returns frac × 2**exp.\n\nSpecial cases are:\n\tLdexp(±0, exp) = ±0\n\tLdexp(±Inf, exp) = ±Inf\n\tLdexp(NaN, exp) = NaN\n\nGo input arguments: (frac float64, exp int)\n\nGo return type: ...\n\nJoker input arguments: [^float64 frac, ^Int exp]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__ldexp(_frac, _exp)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _frac, ^Int _exp])

JOKER FUNC math.Lgamma from math/lgamma.go:
;; (defn Lgamma
;;   "Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).\n\nSpecial cases are:\n\tLgamma(+Inf) = +Inf\n\tLgamma(0) = +Inf\n\tLgamma(-integer) = +Inf\n\tLgamma(-Inf) = -Inf\n\tLgamma(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: (lgamma ..., sign int)\n\nJoker input arguments: [^float64 x]\n\nJoker return type: [ABEND043(post.go: unsupported built-in type float64) Int]"
;;   {:added "1.0"
;;    :go "__lgamma(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Log from math/log.go:
;; (defn Log
;;   "Log returns the natural logarithm of x.\n\nSpecial cases are:\n\tLog(+Inf) = +Inf\n\tLog(0) = -Inf\n\tLog(x < 0) = NaN\n\tLog(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__log(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Log10 from math/log10.go:
;; (defn Log10
;;   "Log10 returns the decimal logarithm of x.\nThe special cases are the same as for Log.\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__log10(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Log1p from math/log1p.go:
;; (defn Log1p
;;   "Log1p returns the natural logarithm of 1 plus its argument x.\nIt is more accurate than Log(1 + x) when x is near zero.\n\nSpecial cases are:\n\tLog1p(+Inf) = +Inf\n\tLog1p(±0) = ±0\n\tLog1p(-1) = -Inf\n\tLog1p(x < -1) = NaN\n\tLog1p(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__log1p(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Log2 from math/log10.go:
;; (defn Log2
;;   "Log2 returns the binary logarithm of x.\nThe special cases are the same as for Log.\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__log2(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Logb from math/logb.go:
;; (defn Logb
;;   "Logb returns the binary exponent of x.\n\nSpecial cases are:\n\tLogb(±Inf) = +Inf\n\tLogb(0) = -Inf\n\tLogb(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__logb(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Max from math/dim.go:
;; (defn Max
;;   "Max returns the larger of x or y.\n\nSpecial cases are:\n\tMax(x, +Inf) = Max(+Inf, x) = +Inf\n\tMax(x, NaN) = Max(NaN, x) = NaN\n\tMax(+0, ±0) = Max(±0, +0) = +0\n\tMax(-0, -0) = -0\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__max(_x, _y)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x, ^ABEND044(pre.go: unsupported built-in type float64) _y])

JOKER FUNC math.Min from math/dim.go:
;; (defn Min
;;   "Min returns the smaller of x or y.\n\nSpecial cases are:\n\tMin(x, -Inf) = Min(-Inf, x) = -Inf\n\tMin(x, NaN) = Min(NaN, x) = NaN\n\tMin(-0, ±0) = Min(±0, -0) = -0\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__min(_x, _y)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x, ^ABEND044(pre.go: unsupported built-in type float64) _y])

JOKER FUNC math.Mod from math/mod.go:
;; (defn Mod
;;   "Mod returns the floating-point remainder of x/y.\nThe magnitude of the result is less than y and its\nsign agrees with that of x.\n\nSpecial cases are:\n\tMod(±Inf, y) = NaN\n\tMod(NaN, y) = NaN\n\tMod(x, 0) = NaN\n\tMod(x, ±Inf) = x\n\tMod(x, NaN) = NaN\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__mod(_x, _y)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x, ^ABEND044(pre.go: unsupported built-in type float64) _y])

JOKER FUNC math.Modf from math/modf.go:
;; (defn Modf
;;   "Modf returns integer and fractional floating-point numbers\nthat sum to f. Both values have the same sign as f.\n\nSpecial cases are:\n\tModf(±Inf) = ±Inf, NaN\n\tModf(NaN) = NaN, NaN\n\nGo input arguments: (f float64)\n\nGo return type: (int ..., frac ...)\n\nJoker input arguments: [^float64 f]\n\nJoker return type: [ABEND043(post.go: unsupported built-in type float64) ABEND043(post.go: unsupported built-in type float64)]"
;;   {:added "1.0"
;;    :go "__modf(_f)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _f])

JOKER FUNC math.NaN from math/bits.go:
;; (defn NaN
;;   "NaN returns an IEEE 754 ``not-a-number'' value.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__naN()"}
;;   [])

JOKER FUNC math.Nextafter from math/nextafter.go:
;; (defn Nextafter
;;   "Nextafter returns the next representable float64 value after x towards y.\n\nSpecial cases are:\n\tNextafter(x, x)   = x\n\tNextafter(NaN, y) = NaN\n\tNextafter(x, NaN) = NaN\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__nextafter(_x, _y)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x, ^ABEND044(pre.go: unsupported built-in type float64) _y])

JOKER FUNC math.Nextafter32 from math/nextafter.go:
;; (defn Nextafter32
;;   "Nextafter32 returns the next representable float32 value after x towards y.\n\nSpecial cases are:\n\tNextafter32(x, x)   = x\n\tNextafter32(NaN, y) = NaN\n\tNextafter32(x, NaN) = NaN\n\nGo input arguments: (x float32, y float32)\n\nGo return type: ...\n\nJoker input arguments: [^float32 x, ^float32 y]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float32)"
;;   {:added "1.0"
;;    :go "__nextafter32(_x, _y)"}
;;   [^ABEND044(pre.go: unsupported built-in type float32) _x, ^ABEND044(pre.go: unsupported built-in type float32) _y])

JOKER FUNC math.Pow from math/pow.go:
;; (defn Pow
;;   "Pow returns x**y, the base-x exponential of y.\n\nSpecial cases are (in order):\n\tPow(x, ±0) = 1 for any x\n\tPow(1, y) = 1 for any y\n\tPow(x, 1) = x for any x\n\tPow(NaN, y) = NaN\n\tPow(x, NaN) = NaN\n\tPow(±0, y) = ±Inf for y an odd integer < 0\n\tPow(±0, -Inf) = +Inf\n\tPow(±0, +Inf) = +0\n\tPow(±0, y) = +Inf for finite y < 0 and not an odd integer\n\tPow(±0, y) = ±0 for y an odd integer > 0\n\tPow(±0, y) = +0 for finite y > 0 and not an odd integer\n\tPow(-1, ±Inf) = 1\n\tPow(x, +Inf) = +Inf for |x| > 1\n\tPow(x, -Inf) = +0 for |x| > 1\n\tPow(x, +Inf) = +0 for |x| < 1\n\tPow(x, -Inf) = +Inf for |x| < 1\n\tPow(+Inf, y) = +Inf for y > 0\n\tPow(+Inf, y) = +0 for y < 0\n\tPow(-Inf, y) = Pow(-0, -y)\n\tPow(x, y) = NaN for finite x < 0 and finite non-integer y\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__pow(_x, _y)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x, ^ABEND044(pre.go: unsupported built-in type float64) _y])

JOKER FUNC math.Pow10 from math/pow10.go:
;; (defn Pow10
;;   "Pow10 returns 10**n, the base-10 exponential of n.\n\nSpecial cases are:\n\tPow10(n) =    0 for n < -323\n\tPow10(n) = +Inf for n > 308\n\nGo input arguments: (n int)\n\nGo return type: ...\n\nJoker input arguments: [^Int n]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__pow10(_n)"}
;;   [^Int _n])

JOKER FUNC math.Remainder from math/remainder.go:
;; (defn Remainder
;;   "Remainder returns the IEEE 754 floating-point remainder of x/y.\n\nSpecial cases are:\n\tRemainder(±Inf, y) = NaN\n\tRemainder(NaN, y) = NaN\n\tRemainder(x, 0) = NaN\n\tRemainder(x, ±Inf) = x\n\tRemainder(x, NaN) = NaN\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__remainder(_x, _y)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x, ^ABEND044(pre.go: unsupported built-in type float64) _y])

JOKER FUNC math.Round from math/floor.go:
;; (defn Round
;;   "Round returns the nearest integer, rounding half away from zero.\n\nSpecial cases are:\n\tRound(±0) = ±0\n\tRound(±Inf) = ±Inf\n\tRound(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__round(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.RoundToEven from math/floor.go:
;; (defn RoundToEven
;;   "RoundToEven returns the nearest integer, rounding ties to even.\n\nSpecial cases are:\n\tRoundToEven(±0) = ±0\n\tRoundToEven(±Inf) = ±Inf\n\tRoundToEven(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__roundToEven(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Signbit from math/signbit.go:
;; (defn ^"Boolean" Signbit
;;   "Signbit returns true if x is negative or negative zero.\n\nGo input arguments: (x float64)\n\nGo return type: bool\n\nJoker input arguments: [^float64 x]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "math.Signbit(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Sin from math/sin.go:
;; (defn Sin
;;   "Sin returns the sine of the radian argument x.\n\nSpecial cases are:\n\tSin(±0) = ±0\n\tSin(±Inf) = NaN\n\tSin(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__sin(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Sincos from math/sincos.go:
;; (defn Sincos
;;   "Sincos returns Sin(x), Cos(x).\n\nSpecial cases are:\n\tSincos(±0) = ±0, 1\n\tSincos(±Inf) = NaN, NaN\n\tSincos(NaN) = NaN, NaN\n\nGo input arguments: (x float64)\n\nGo return type: (sin ..., cos ...)\n\nJoker input arguments: [^float64 x]\n\nJoker return type: [ABEND043(post.go: unsupported built-in type float64) ABEND043(post.go: unsupported built-in type float64)]"
;;   {:added "1.0"
;;    :go "__sincos(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Sinh from math/sinh.go:
;; (defn Sinh
;;   "Sinh returns the hyperbolic sine of x.\n\nSpecial cases are:\n\tSinh(±0) = ±0\n\tSinh(±Inf) = ±Inf\n\tSinh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__sinh(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Sqrt from math/sqrt.go:
;; (defn Sqrt
;;   "Sqrt returns the square root of x.\n\nSpecial cases are:\n\tSqrt(+Inf) = +Inf\n\tSqrt(±0) = ±0\n\tSqrt(x < 0) = NaN\n\tSqrt(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__sqrt(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Tan from math/tan.go:
;; (defn Tan
;;   "Tan returns the tangent of the radian argument x.\n\nSpecial cases are:\n\tTan(±0) = ±0\n\tTan(±Inf) = NaN\n\tTan(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__tan(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Tanh from math/tanh.go:
;; (defn Tanh
;;   "Tanh returns the hyperbolic tangent of x.\n\nSpecial cases are:\n\tTanh(±0) = ±0\n\tTanh(±Inf) = ±1\n\tTanh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__tanh(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Trunc from math/floor.go:
;; (defn Trunc
;;   "Trunc returns the integer value of x.\n\nSpecial cases are:\n\tTrunc(±0) = ±0\n\tTrunc(±Inf) = ±Inf\n\tTrunc(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__trunc(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Y0 from math/j0.go:
;; (defn Y0
;;   "Y0 returns the order-zero Bessel function of the second kind.\n\nSpecial cases are:\n\tY0(+Inf) = 0\n\tY0(0) = -Inf\n\tY0(x < 0) = NaN\n\tY0(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__y0(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Y1 from math/j1.go:
;; (defn Y1
;;   "Y1 returns the order-one Bessel function of the second kind.\n\nSpecial cases are:\n\tY1(+Inf) = 0\n\tY1(0) = -Inf\n\tY1(x < 0) = NaN\n\tY1(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__y1(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math.Yn from math/jn.go:
;; (defn Yn
;;   "Yn returns the order-n Bessel function of the second kind.\n\nSpecial cases are:\n\tYn(n, +Inf) = 0\n\tYn(n ≥ 0, 0) = -Inf\n\tYn(n < 0, 0) = +Inf if n is odd, -Inf if n is even\n\tYn(n, x < 0) = NaN\n\tYn(n, NaN) = NaN\n\nGo input arguments: (n int, x float64)\n\nGo return type: ...\n\nJoker input arguments: [^Int n, ^float64 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__yn(_n, _x)"}
;;   [^Int _n, ^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER TYPE math/big.Accuracy from math/big/float.go:
(defn ^"GoObject" Accuracy.
  "Constructor for big.Accuracy"
  {:added "1.0"
   :go "_ConstructAccuracy(_v)"}
  [^Object _v])

JOKER TYPE math/big.ErrNaN from math/big/float.go:
(defn ^"GoObject" ErrNaN.
  "Constructor for big.ErrNaN"
  {:added "1.0"
   :go "_ConstructErrNaN(_v)"}
  [^Object _v])

JOKER TYPE math/big.Float from math/big/float.go:
(defn ^"GoObject" Float.
  "Constructor for big.Float"
  {:added "1.0"
   :go "_ConstructFloat(_v)"}
  [^Object _v])

JOKER TYPE math/big.Int from math/big/int.go:
(defn ^"GoObject" Int.
  "Constructor for big.Int"
  {:added "1.0"
   :go "_ConstructInt(_v)"}
  [^Object _v])

JOKER TYPE math/big.Rat from math/big/rat.go:
(defn ^"GoObject" Rat.
  "Constructor for big.Rat"
  {:added "1.0"
   :go "_ConstructRat(_v)"}
  [^Object _v])

JOKER TYPE math/big.RoundingMode from math/big/float.go:
(defn ^"GoObject" RoundingMode.
  "Constructor for big.RoundingMode"
  {:added "1.0"
   :go "_ConstructRoundingMode(_v)"}
  [^Object _v])

JOKER TYPE math/big.Word from math/big/arith.go:
(defn ^"GoObject" Word.
  "Constructor for big.Word"
  {:added "1.0"
   :go "_ConstructWord(_v)"}
  [^Object _v])

JOKER FUNC math/big.Jacobi from math/big/int.go:
(defn ^"Int" Jacobi
  "Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0.\nThe y argument must be an odd integer.\n\nGo input arguments: (x *Int, y *Int)\n\nGo return type: int\n\nJoker input arguments: [^(atom-of go.std.math.big/Int) x, ^(atom-of go.std.math.big/Int) y]\n\nJoker return type: Int"
  {:added "1.0"
   :go "big.Jacobi(_x, _y)"}
  [^big/Int _x, ^big/Int _y])

JOKER FUNC math/big.NewFloat from math/big/float.go:
;; (defn NewFloat
;;   "NewFloat allocates and returns a new Float set to x,\nwith precision 53 and rounding mode ToNearestEven.\nNewFloat panics with ErrNaN if x is a NaN.\n\nGo input arguments: (x float64)\n\nGo return type: *Float\n\nJoker input arguments: [^float64 x]\n\nJoker return type: (atom-of go.std.math.big/Float)"
;;   {:added "1.0"
;;    :go "__newFloat(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC math/big.NewInt from math/big/int.go:
(defn NewInt
  "NewInt allocates and returns a new Int set to x.\n\nGo input arguments: (x int64)\n\nGo return type: *Int\n\nJoker input arguments: [^Int64 x]\n\nJoker return type: (atom-of go.std.math.big/Int)"
  {:added "1.0"
   :go "__newInt(_x)"}
  [^Int64 _x])

JOKER FUNC math/big.NewRat from math/big/rat.go:
(defn NewRat
  "NewRat creates a new Rat with numerator a and denominator b.\n\nGo input arguments: (a int64, b int64)\n\nGo return type: *Rat\n\nJoker input arguments: [^Int64 a, ^Int64 b]\n\nJoker return type: (atom-of go.std.math.big/Rat)"
  {:added "1.0"
   :go "__newRat(_a, _b)"}
  [^Int64 _a, ^Int64 _b])

JOKER FUNC math/big.ParseFloat from math/big/floatconv.go:
(defn ParseFloat
  "ParseFloat is like f.Parse(s, base) with f set to the given precision\nand rounding mode.\n\nGo input arguments: (s string, base int, prec uint, mode RoundingMode)\n\nGo return type: (f *Float, b int, err error)\n\nJoker input arguments: [^String s, ^Int base, ^UInt prec, ^go.std.math.big/RoundingMode mode]\n\nJoker return type: [(atom-of go.std.math.big/Float) Int Error]"
  {:added "1.0"
   :go "__parseFloat(_s, _base, _prec, *_mode)"}
  [^String _s, ^Int _base, ^UInt _prec, ^big/RoundingMode _mode])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["math/big"]
    :doc "Provides a low-level interface to the math/big package."
    :empty false}
  go.std.math.big)
JOKER FUNC math/bits.LeadingZeros from math/bits/bits.go:
(defn ^"Int" LeadingZeros
  "LeadingZeros returns the number of leading zero bits in x; the result is UintSize for x == 0.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^UInt x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros(_x)"}
  [^UInt _x])

JOKER FUNC math/bits.LeadingZeros16 from math/bits/bits.go:
(defn ^"Int" LeadingZeros16
  "LeadingZeros16 returns the number of leading zero bits in x; the result is 16 for x == 0.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^UInt16 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros16(_x)"}
  [^UInt16 _x])

JOKER FUNC math/bits.LeadingZeros32 from math/bits/bits.go:
(defn ^"Int" LeadingZeros32
  "LeadingZeros32 returns the number of leading zero bits in x; the result is 32 for x == 0.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^UInt32 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros32(_x)"}
  [^UInt32 _x])

JOKER FUNC math/bits.LeadingZeros64 from math/bits/bits.go:
;; (defn ^"Int" LeadingZeros64
;;   "LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0.\n\nGo input arguments: (x uint64)\n\nGo return type: int\n\nJoker input arguments: [^uint64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.LeadingZeros64(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint64) _x])

JOKER FUNC math/bits.LeadingZeros8 from math/bits/bits.go:
;; (defn ^"Int" LeadingZeros8
;;   "LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0.\n\nGo input arguments: (x uint8)\n\nGo return type: int\n\nJoker input arguments: [^uint8 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.LeadingZeros8(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint8) _x])

JOKER FUNC math/bits.Len from math/bits/bits.go:
(defn ^"Int" Len
  "Len returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^UInt x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len(_x)"}
  [^UInt _x])

JOKER FUNC math/bits.Len16 from math/bits/bits.go:
(defn ^"Int" Len16
  "Len16 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^UInt16 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len16(_x)"}
  [^UInt16 _x])

JOKER FUNC math/bits.Len32 from math/bits/bits.go:
(defn ^"Int" Len32
  "Len32 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^UInt32 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len32(_x)"}
  [^UInt32 _x])

JOKER FUNC math/bits.Len64 from math/bits/bits.go:
;; (defn ^"Int" Len64
;;   "Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint64)\n\nGo return type: int\n\nJoker input arguments: [^uint64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.Len64(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint64) _x])

JOKER FUNC math/bits.Len8 from math/bits/bits.go:
;; (defn ^"Int" Len8
;;   "Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint8)\n\nGo return type: int\n\nJoker input arguments: [^uint8 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.Len8(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint8) _x])

JOKER FUNC math/bits.OnesCount from math/bits/bits.go:
(defn ^"Int" OnesCount
  "OnesCount returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^UInt x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount(_x)"}
  [^UInt _x])

JOKER FUNC math/bits.OnesCount16 from math/bits/bits.go:
(defn ^"Int" OnesCount16
  "OnesCount16 returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^UInt16 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount16(_x)"}
  [^UInt16 _x])

JOKER FUNC math/bits.OnesCount32 from math/bits/bits.go:
(defn ^"Int" OnesCount32
  "OnesCount32 returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^UInt32 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount32(_x)"}
  [^UInt32 _x])

JOKER FUNC math/bits.OnesCount64 from math/bits/bits.go:
;; (defn ^"Int" OnesCount64
;;   "OnesCount64 returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint64)\n\nGo return type: int\n\nJoker input arguments: [^uint64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.OnesCount64(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint64) _x])

JOKER FUNC math/bits.OnesCount8 from math/bits/bits.go:
;; (defn ^"Int" OnesCount8
;;   "OnesCount8 returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint8)\n\nGo return type: int\n\nJoker input arguments: [^uint8 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.OnesCount8(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint8) _x])

JOKER FUNC math/bits.Reverse from math/bits/bits.go:
(defn Reverse
  "Reverse returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint)\n\nGo return type: uint\n\nJoker input arguments: [^UInt x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__reverse(_x)"}
  [^UInt _x])

JOKER FUNC math/bits.Reverse16 from math/bits/bits.go:
(defn Reverse16
  "Reverse16 returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint16)\n\nGo return type: uint16\n\nJoker input arguments: [^UInt16 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__reverse16(_x)"}
  [^UInt16 _x])

JOKER FUNC math/bits.Reverse32 from math/bits/bits.go:
(defn Reverse32
  "Reverse32 returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^UInt32 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__reverse32(_x)"}
  [^UInt32 _x])

JOKER FUNC math/bits.Reverse64 from math/bits/bits.go:
;; (defn Reverse64
;;   "Reverse64 returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint64)\n\nGo return type: uint64\n\nJoker input arguments: [^uint64 x]\n\nJoker return type: BigInt"
;;   {:added "1.0"
;;    :go "__reverse64(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint64) _x])

JOKER FUNC math/bits.Reverse8 from math/bits/bits.go:
;; (defn Reverse8
;;   "Reverse8 returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint8)\n\nGo return type: ...\n\nJoker input arguments: [^uint8 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type uint8)"
;;   {:added "1.0"
;;    :go "__reverse8(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint8) _x])

JOKER FUNC math/bits.ReverseBytes from math/bits/bits.go:
(defn ReverseBytes
  "ReverseBytes returns the value of x with its bytes in reversed order.\n\nGo input arguments: (x uint)\n\nGo return type: uint\n\nJoker input arguments: [^UInt x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__reverseBytes(_x)"}
  [^UInt _x])

JOKER FUNC math/bits.ReverseBytes16 from math/bits/bits.go:
(defn ReverseBytes16
  "ReverseBytes16 returns the value of x with its bytes in reversed order.\n\nGo input arguments: (x uint16)\n\nGo return type: uint16\n\nJoker input arguments: [^UInt16 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__reverseBytes16(_x)"}
  [^UInt16 _x])

JOKER FUNC math/bits.ReverseBytes32 from math/bits/bits.go:
(defn ReverseBytes32
  "ReverseBytes32 returns the value of x with its bytes in reversed order.\n\nGo input arguments: (x uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^UInt32 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__reverseBytes32(_x)"}
  [^UInt32 _x])

JOKER FUNC math/bits.ReverseBytes64 from math/bits/bits.go:
;; (defn ReverseBytes64
;;   "ReverseBytes64 returns the value of x with its bytes in reversed order.\n\nGo input arguments: (x uint64)\n\nGo return type: uint64\n\nJoker input arguments: [^uint64 x]\n\nJoker return type: BigInt"
;;   {:added "1.0"
;;    :go "__reverseBytes64(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint64) _x])

JOKER FUNC math/bits.RotateLeft from math/bits/bits.go:
(defn RotateLeft
  "RotateLeft returns the value of x rotated left by (k mod UintSize) bits.\nTo rotate x right by k bits, call RotateLeft(x, -k).\n\nGo input arguments: (x uint, k int)\n\nGo return type: uint\n\nJoker input arguments: [^UInt x, ^Int k]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__rotateLeft(_x, _k)"}
  [^UInt _x, ^Int _k])

JOKER FUNC math/bits.RotateLeft16 from math/bits/bits.go:
(defn RotateLeft16
  "RotateLeft16 returns the value of x rotated left by (k mod 16) bits.\nTo rotate x right by k bits, call RotateLeft16(x, -k).\n\nGo input arguments: (x uint16, k int)\n\nGo return type: uint16\n\nJoker input arguments: [^UInt16 x, ^Int k]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__rotateLeft16(_x, _k)"}
  [^UInt16 _x, ^Int _k])

JOKER FUNC math/bits.RotateLeft32 from math/bits/bits.go:
(defn RotateLeft32
  "RotateLeft32 returns the value of x rotated left by (k mod 32) bits.\nTo rotate x right by k bits, call RotateLeft32(x, -k).\n\nGo input arguments: (x uint32, k int)\n\nGo return type: uint32\n\nJoker input arguments: [^UInt32 x, ^Int k]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__rotateLeft32(_x, _k)"}
  [^UInt32 _x, ^Int _k])

JOKER FUNC math/bits.RotateLeft64 from math/bits/bits.go:
;; (defn RotateLeft64
;;   "RotateLeft64 returns the value of x rotated left by (k mod 64) bits.\nTo rotate x right by k bits, call RotateLeft64(x, -k).\n\nGo input arguments: (x uint64, k int)\n\nGo return type: uint64\n\nJoker input arguments: [^uint64 x, ^Int k]\n\nJoker return type: BigInt"
;;   {:added "1.0"
;;    :go "__rotateLeft64(_x, _k)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint64) _x, ^Int _k])

JOKER FUNC math/bits.RotateLeft8 from math/bits/bits.go:
;; (defn RotateLeft8
;;   "RotateLeft8 returns the value of x rotated left by (k mod 8) bits.\nTo rotate x right by k bits, call RotateLeft8(x, -k).\n\nGo input arguments: (x uint8, k int)\n\nGo return type: ...\n\nJoker input arguments: [^uint8 x, ^Int k]\n\nJoker return type: ABEND043(post.go: unsupported built-in type uint8)"
;;   {:added "1.0"
;;    :go "__rotateLeft8(_x, _k)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint8) _x, ^Int _k])

JOKER FUNC math/bits.TrailingZeros from math/bits/bits.go:
(defn ^"Int" TrailingZeros
  "TrailingZeros returns the number of trailing zero bits in x; the result is UintSize for x == 0.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^UInt x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros(_x)"}
  [^UInt _x])

JOKER FUNC math/bits.TrailingZeros16 from math/bits/bits.go:
(defn ^"Int" TrailingZeros16
  "TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^UInt16 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros16(_x)"}
  [^UInt16 _x])

JOKER FUNC math/bits.TrailingZeros32 from math/bits/bits.go:
(defn ^"Int" TrailingZeros32
  "TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^UInt32 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros32(_x)"}
  [^UInt32 _x])

JOKER FUNC math/bits.TrailingZeros64 from math/bits/bits.go:
;; (defn ^"Int" TrailingZeros64
;;   "TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.\n\nGo input arguments: (x uint64)\n\nGo return type: int\n\nJoker input arguments: [^uint64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.TrailingZeros64(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint64) _x])

JOKER FUNC math/bits.TrailingZeros8 from math/bits/bits.go:
;; (defn ^"Int" TrailingZeros8
;;   "TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.\n\nGo input arguments: (x uint8)\n\nGo return type: int\n\nJoker input arguments: [^uint8 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.TrailingZeros8(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint8) _x])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["math/bits"]
    :doc "Provides a low-level interface to the math/bits package."
    :empty false}
  go.std.math.bits)
JOKER FUNC math/cmplx.Abs from math/cmplx/abs.go:
;; (defn Abs
;;   "Abs returns the absolute value (also called the modulus) of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__abs(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Acos from math/cmplx/asin.go:
;; (defn Acos
;;   "Acos returns the inverse cosine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__acos(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Acosh from math/cmplx/asin.go:
;; (defn Acosh
;;   "Acosh returns the inverse hyperbolic cosine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__acosh(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Asin from math/cmplx/asin.go:
;; (defn Asin
;;   "Asin returns the inverse sine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__asin(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Asinh from math/cmplx/asin.go:
;; (defn Asinh
;;   "Asinh returns the inverse hyperbolic sine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__asinh(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Atan from math/cmplx/asin.go:
;; (defn Atan
;;   "Atan returns the inverse tangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__atan(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Atanh from math/cmplx/asin.go:
;; (defn Atanh
;;   "Atanh returns the inverse hyperbolic tangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__atanh(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Conj from math/cmplx/conj.go:
;; (defn Conj
;;   "Conj returns the complex conjugate of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__conj(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Cos from math/cmplx/sin.go:
;; (defn Cos
;;   "Cos returns the cosine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__cos(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Cosh from math/cmplx/sin.go:
;; (defn Cosh
;;   "Cosh returns the hyperbolic cosine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__cosh(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Cot from math/cmplx/tan.go:
;; (defn Cot
;;   "Cot returns the cotangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__cot(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Exp from math/cmplx/exp.go:
;; (defn Exp
;;   "Exp returns e**x, the base-e exponential of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__exp(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Inf from math/cmplx/isinf.go:
;; (defn Inf
;;   "Inf returns a complex infinity, complex(+Inf, +Inf).\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__inf()"}
;;   [])

JOKER FUNC math/cmplx.IsInf from math/cmplx/isinf.go:
;; (defn ^"Boolean" IsInf
;;   "IsInf returns true if either real(x) or imag(x) is an infinity.\n\nGo input arguments: (x complex128)\n\nGo return type: bool\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "cmplx.IsInf(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.IsNaN from math/cmplx/isnan.go:
;; (defn ^"Boolean" IsNaN
;;   "IsNaN returns true if either real(x) or imag(x) is NaN\nand neither is an infinity.\n\nGo input arguments: (x complex128)\n\nGo return type: bool\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "cmplx.IsNaN(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Log from math/cmplx/log.go:
;; (defn Log
;;   "Log returns the natural logarithm of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__log(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Log10 from math/cmplx/log.go:
;; (defn Log10
;;   "Log10 returns the decimal logarithm of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__log10(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.NaN from math/cmplx/isnan.go:
;; (defn NaN
;;   "NaN returns a complex ``not-a-number'' value.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__naN()"}
;;   [])

JOKER FUNC math/cmplx.Phase from math/cmplx/phase.go:
;; (defn Phase
;;   "Phase returns the phase (also called the argument) of x.\nThe returned value is in the range [-Pi, Pi].\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__phase(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Polar from math/cmplx/polar.go:
;; (defn Polar
;;   "Polar returns the absolute value r and phase θ of x,\nsuch that x = r * e**θi.\nThe phase is in the range [-Pi, Pi].\n\nGo input arguments: (x complex128)\n\nGo return type: (r ..., θ ...)\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: [ABEND043(post.go: unsupported built-in type float64) ABEND043(post.go: unsupported built-in type float64)]"
;;   {:added "1.0"
;;    :go "__polar(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Pow from math/cmplx/pow.go:
;; (defn Pow
;;   "Pow returns x**y, the base-x exponential of y.\nFor generalized compatibility with math.Pow:\n\tPow(0, ±0) returns 1+0i\n\tPow(0, c) for real(c)<0 returns Inf+0i if imag(c) is zero, otherwise Inf+Inf i.\n\nGo input arguments: (x complex128, y complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x, ^complex128 y]\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__pow(_x, _y)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x, ^ABEND044(pre.go: unsupported built-in type complex128) _y])

JOKER FUNC math/cmplx.Rect from math/cmplx/rect.go:
;; (defn Rect
;;   "Rect returns the complex number x with polar coordinates r, θ.\n\nGo input arguments: (r float64, θ float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 r, ^float64 θ]\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__rect(_r, _θ)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _r, ^ABEND044(pre.go: unsupported built-in type float64) _θ])

JOKER FUNC math/cmplx.Sin from math/cmplx/sin.go:
;; (defn Sin
;;   "Sin returns the sine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__sin(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Sinh from math/cmplx/sin.go:
;; (defn Sinh
;;   "Sinh returns the hyperbolic sine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__sinh(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Sqrt from math/cmplx/sqrt.go:
;; (defn Sqrt
;;   "Sqrt returns the square root of x.\nThe result r is chosen so that real(r) ≥ 0 and imag(r) has the same sign as imag(x).\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__sqrt(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Tan from math/cmplx/tan.go:
;; (defn Tan
;;   "Tan returns the tangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__tan(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Tanh from math/cmplx/tan.go:
;; (defn Tanh
;;   "Tanh returns the hyperbolic tangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(post.go: unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "__tanh(_x)"}
;;   [^ABEND044(pre.go: unsupported built-in type complex128) _x])

JOKER TYPE math/rand.Rand from math/rand/rand.go:
(defn ^"GoObject" Rand.
  "Constructor for rand.Rand"
  {:added "1.0"
   :go "_ConstructRand(_v)"}
  [^Object _v])

JOKER TYPE math/rand.Source from math/rand/rand.go:
;; (defn ^"GoObject" Source.
;;   "Constructor for rand.Source"
;;   {:added "1.0"
;;    :go "_ConstructSource(_v)"}
;;   [^Object _v])

JOKER TYPE math/rand.Source64 from math/rand/rand.go:
;; (defn ^"GoObject" Source64.
;;   "Constructor for rand.Source64"
;;   {:added "1.0"
;;    :go "_ConstructSource64(_v)"}
;;   [^Object _v])

JOKER TYPE math/rand.Zipf from math/rand/zipf.go:
(defn ^"GoObject" Zipf.
  "Constructor for rand.Zipf"
  {:added "1.0"
   :go "_ConstructZipf(_v)"}
  [^Object _v])

JOKER FUNC math/rand.ExpFloat64 from math/rand/rand.go:
;; (defn ExpFloat64
;;   "ExpFloat64 returns an exponentially distributed float64 in the range\n(0, +math.MaxFloat64] with an exponential distribution whose rate parameter\n(lambda) is 1 and whose mean is 1/lambda (1) from the default Source.\nTo produce a distribution with a different rate parameter,\ncallers can adjust the output using:\n\n sample = ExpFloat64() / desiredRateParameter\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__expFloat64()"}
;;   [])

JOKER FUNC math/rand.Float32 from math/rand/rand.go:
;; (defn Float32
;;   "Float32 returns, as a float32, a pseudo-random number in [0.0,1.0)\nfrom the default Source.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(post.go: unsupported built-in type float32)"
;;   {:added "1.0"
;;    :go "__float32()"}
;;   [])

JOKER FUNC math/rand.Float64 from math/rand/rand.go:
;; (defn Float64
;;   "Float64 returns, as a float64, a pseudo-random number in [0.0,1.0)\nfrom the default Source.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__float64()"}
;;   [])

JOKER FUNC math/rand.Int from math/rand/rand.go:
(defn ^"Int" Int
  "Int returns a non-negative pseudo-random int from the default Source.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "rand.Int()"}
  [])

JOKER FUNC math/rand.Int31 from math/rand/rand.go:
(defn Int31
  "Int31 returns a non-negative pseudo-random 31-bit integer as an int32\nfrom the default Source.\n\nGo return type: int32\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "__int31()"}
  [])

JOKER FUNC math/rand.Int31n from math/rand/rand.go:
(defn Int31n
  "Int31n returns, as an int32, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\n\nGo input arguments: (n int32)\n\nGo return type: int32\n\nJoker input arguments: [^Int32 n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__int31n(_n)"}
  [^Int32 _n])

JOKER FUNC math/rand.Int63 from math/rand/rand.go:
(defn Int63
  "Int63 returns a non-negative pseudo-random 63-bit integer as an int64\nfrom the default Source.\n\nGo return type: int64\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "__int63()"}
  [])

JOKER FUNC math/rand.Int63n from math/rand/rand.go:
(defn Int63n
  "Int63n returns, as an int64, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\n\nGo input arguments: (n int64)\n\nGo return type: int64\n\nJoker input arguments: [^Int64 n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__int63n(_n)"}
  [^Int64 _n])

JOKER FUNC math/rand.Intn from math/rand/rand.go:
(defn ^"Int" Intn
  "Intn returns, as an int, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\n\nGo input arguments: (n int)\n\nGo return type: int\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "rand.Intn(_n)"}
  [^Int _n])

JOKER FUNC math/rand.New from math/rand/rand.go:
(defn New
  "New returns a new Rand that uses random values from src\nto generate other random values.\n\nGo input arguments: (src Source)\n\nGo return type: *Rand\n\nJoker input arguments: [^go.std.math.rand/Source src]\n\nJoker return type: (atom-of go.std.math.rand/Rand)"
  {:added "1.0"
   :go "__new(*_src)"}
  [^rand/Source _src])

JOKER FUNC math/rand.NewSource from math/rand/rand.go:
(defn NewSource
  "NewSource returns a new pseudo-random Source seeded with the given value.\nUnlike the default Source used by top-level functions, this source is not\nsafe for concurrent use by multiple goroutines.\n\nGo input arguments: (seed int64)\n\nGo return type: Source\n\nJoker input arguments: [^Int64 seed]\n\nJoker return type: go.std.math.rand/Source"
  {:added "1.0"
   :go "__newSource(_seed)"}
  [^Int64 _seed])

JOKER FUNC math/rand.NewZipf from math/rand/zipf.go:
;; (defn NewZipf
;;   "NewZipf returns a Zipf variate generator.\nThe generator generates values k ∈ [0, imax]\nsuch that P(k) is proportional to (v + k) ** (-s).\nRequirements: s > 1 and v >= 1.\n\nGo input arguments: (r *Rand, s float64, v float64, imax uint64)\n\nGo return type: *Zipf\n\nJoker input arguments: [^(atom-of go.std.math.rand/Rand) r, ^float64 s, ^float64 v, ^uint64 imax]\n\nJoker return type: (atom-of go.std.math.rand/Zipf)"
;;   {:added "1.0"
;;    :go "__newZipf(_r, _s, _v, _imax)"}
;;   [^rand/Rand _r, ^ABEND044(pre.go: unsupported built-in type float64) _s, ^ABEND044(pre.go: unsupported built-in type float64) _v, ^ABEND044(pre.go: unsupported built-in type uint64) _imax])

JOKER FUNC math/rand.NormFloat64 from math/rand/rand.go:
;; (defn NormFloat64
;;   "NormFloat64 returns a normally distributed float64 in the range\n[-math.MaxFloat64, +math.MaxFloat64] with\nstandard normal distribution (mean = 0, stddev = 1)\nfrom the default Source.\nTo produce a different normal distribution, callers can\nadjust the output using:\n\n sample = NormFloat64() * desiredStdDev + desiredMean\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__normFloat64()"}
;;   [])

JOKER FUNC math/rand.Perm from math/rand/rand.go:
(defn Perm
  "Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n)\nfrom the default Source.\n\nGo input arguments: (n int)\n\nGo return type: []int\n\nJoker input arguments: [^Int n]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__perm(_n)"}
  [^Int _n])

JOKER FUNC math/rand.Read from math/rand/rand.go:
;; (defn Read
;;   "Read generates len(p) random bytes from the default Source and\nwrites them into p. It always returns len(p) and a nil error.\nRead, unlike the Rand.Read method, is safe for concurrent use.\n\nGo input arguments: (p []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__read(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^Object _p])

JOKER FUNC math/rand.Seed from math/rand/rand.go:
;; (defn Seed
;;   "Seed uses the provided seed value to initialize the default Source to a\ndeterministic state. If Seed is not called, the generator behaves as\nif seeded by Seed(1). Seed values that have the same remainder when\ndivided by 2^31-1 generate the same pseudo-random sequence.\nSeed, unlike the Rand.Seed method, is safe for concurrent use.\n\nGo input arguments: (seed int64)\n\nJoker input arguments: [^Int64 seed]"
;;   {:added "1.0"
;;    :go "__seed(_seed)"}
;;   [^Int64 _seed])

JOKER FUNC math/rand.Shuffle from math/rand/rand.go:
;; (defn Shuffle
;;   "Shuffle pseudo-randomizes the order of elements using the default Source.\nn is the number of elements. Shuffle panics if n < 0.\nswap swaps the elements with indexes i and j.\n\nGo input arguments: (n int, swap func)\n\nJoker input arguments: [^Int n, ^fn swap]"
;;   {:added "1.0"
;;    :go "__shuffle(_n, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Int _n, ^fn _swap])

JOKER FUNC math/rand.Uint32 from math/rand/rand.go:
(defn Uint32
  "Uint32 returns a pseudo-random 32-bit value as a uint32\nfrom the default Source.\n\nGo return type: uint32\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "__uint32()"}
  [])

JOKER FUNC math/rand.Uint64 from math/rand/rand.go:
(defn Uint64
  "Uint64 returns a pseudo-random 64-bit value as a uint64\nfrom the default Source.\n\nGo return type: uint64\n\nJoker input arguments: []\n\nJoker return type: BigInt"
  {:added "1.0"
   :go "__uint64()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["math/rand"]
    :doc "Provides a low-level interface to the math/rand package."
    :empty false}
  go.std.math.rand)
JOKER TYPE mime.WordDecoder from mime/encodedword.go:
(defn ^"GoObject" WordDecoder.
  "Constructor for mime.WordDecoder"
  {:added "1.0"
   :go "_ConstructWordDecoder(_v)"}
  [^Object _v])

JOKER TYPE mime.WordEncoder from mime/encodedword.go:
(defn ^"GoObject" WordEncoder.
  "Constructor for mime.WordEncoder"
  {:added "1.0"
   :go "_ConstructWordEncoder(_v)"}
  [^Object _v])

JOKER FUNC mime.AddExtensionType from mime/type.go:
(defn ^"Error" AddExtensionType
  "AddExtensionType sets the MIME type associated with\nthe extension ext to typ. The extension should begin with\na leading dot, as in \".html\".\n\nGo input arguments: (ext string, typ string)\n\nGo return type: error\n\nJoker input arguments: [^String ext, ^String typ]\n\nJoker return type: Error"
  {:added "1.0"
   :go "mime.AddExtensionType(_ext, _typ)"}
  [^String _ext, ^String _typ])

JOKER FUNC mime.ExtensionsByType from mime/type.go:
(defn ExtensionsByType
  "ExtensionsByType returns the extensions known to be associated with the MIME\ntype typ. The returned extensions will each begin with a leading dot, as in\n\".html\". When typ has no associated extensions, ExtensionsByType returns an\nnil slice.\n\nGo input arguments: (typ string)\n\nGo return type: ([]string, error)\n\nJoker input arguments: [^String typ]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__extensionsByType(_typ)"}
  [^String _typ])

JOKER FUNC mime.FormatMediaType from mime/mediatype.go:
;; (defn ^"String" FormatMediaType
;;   "FormatMediaType serializes mediatype t and the parameters\nparam as a media type conforming to RFC 2045 and RFC 2616.\nThe type and parameter names are written in lower-case.\nWhen any of the arguments result in a standard violation then\nFormatMediaType returns the empty string.\n\nGo input arguments: (t string, param map[])\n\nGo return type: string\n\nJoker input arguments: [^String t, ^{} param]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "mime.FormatMediaType(_t, ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa()))"}
;;   [^String _t, ^{} _param])

JOKER FUNC mime.ParseMediaType from mime/mediatype.go:
;; (defn ParseMediaType
;;   "ParseMediaType parses a media type value and any optional\nparameters, per RFC 1521.  Media types are the values in\nContent-Type and Content-Disposition headers (RFC 2183).\nOn success, ParseMediaType returns the media type converted\nto lowercase and trimmed of white space and a non-nil map.\nIf there is an error parsing the optional parameter,\nthe media type will be returned along with the error\nErrInvalidMediaParameter.\nThe returned map, params, maps from the lowercase\nattribute to the attribute value with its case preserved.\n\nGo input arguments: (v string)\n\nGo return type: (mediatype string, params ..., err error)\n\nJoker input arguments: [^String v]\n\nJoker return type: [String ABEND883(post.go: unrecognized Expr type *ast.MapType at: /usr/local/go-1.11.5/src/mime/mediatype.go:111:57) Error]"
;;   {:added "1.0"
;;    :go "__parseMediaType(_v)"}
;;   [^String _v])

JOKER FUNC mime.TypeByExtension from mime/type.go:
(defn ^"String" TypeByExtension
  "TypeByExtension returns the MIME type associated with the file extension ext.\nThe extension ext should begin with a leading dot, as in \".html\".\nWhen ext has no associated type, TypeByExtension returns \"\".\n\nExtensions are looked up first case-sensitively, then case-insensitively.\n\nThe built-in table is small but on unix it is augmented by the local\nsystem's mime.types file(s) if available under one or more of these\nnames:\n\n  /etc/mime.types\n  /etc/apache2/mime.types\n  /etc/apache/mime.types\n\nOn Windows, MIME types are extracted from the registry.\n\nText types have the charset parameter set to \"utf-8\" by default.\n\nGo input arguments: (ext string)\n\nGo return type: string\n\nJoker input arguments: [^String ext]\n\nJoker return type: String"
  {:added "1.0"
   :go "mime.TypeByExtension(_ext)"}
  [^String _ext])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["mime"]
    :doc "Provides a low-level interface to the mime package."
    :empty false}
  go.std.mime)
JOKER FUNC mime/multipart.NewReader from mime/multipart/multipart.go:
;; (defn NewReader
;;   "NewReader creates a new multipart Reader reading from r using the\ngiven MIME boundary.\n\nThe boundary is usually obtained from the \"boundary\" parameter of\nthe message's \"Content-Type\" header. Use mime.ParseMediaType to\nparse such headers.\n\nGo input arguments: (r io.Reader, boundary string)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader r, ^String boundary]\n\nJoker return type: (atom-of go.std.mime.multipart/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(*_r, _boundary)"}
;;   [^io/Reader _r, ^String _boundary])

JOKER FUNC mime/multipart.NewWriter from mime/multipart/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new multipart Writer with a random boundary,\nwriting to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.mime.multipart/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*_w)"}
;;   [^io/Writer _w])

JOKER FUNC mime/quotedprintable.NewReader from mime/quotedprintable/reader.go:
;; (defn NewReader
;;   "NewReader returns a quoted-printable reader, decoding from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.mime.quotedprintable/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC mime/quotedprintable.NewWriter from mime/quotedprintable/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer that writes to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.mime.quotedprintable/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*_w)"}
;;   [^io/Writer _w])

JOKER TYPE net.Addr from net/net.go:
;; (defn ^"GoObject" Addr.
;;   "Constructor for net.Addr"
;;   {:added "1.0"
;;    :go "_ConstructAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.AddrError from net/net.go:
(defn ^"GoObject" AddrError.
  "Constructor for net.AddrError"
  {:added "1.0"
   :go "_ConstructAddrError(_v)"}
  [^Object _v])

JOKER TYPE net.Buffers from net/net.go:
;; (defn ^"GoObject" Buffers.
;;   "Constructor for net.Buffers"
;;   {:added "1.0"
;;    :go "_ConstructBuffers(_v)"}
;;   [^Object _v])

JOKER TYPE net.Conn from net/net.go:
;; (defn ^"GoObject" Conn.
;;   "Constructor for net.Conn"
;;   {:added "1.0"
;;    :go "_ConstructConn(_v)"}
;;   [^Object _v])

JOKER TYPE net.DNSConfigError from net/net.go:
(defn ^"GoObject" DNSConfigError.
  "Constructor for net.DNSConfigError"
  {:added "1.0"
   :go "_ConstructDNSConfigError(_v)"}
  [^Object _v])

JOKER TYPE net.DNSError from net/net.go:
(defn ^"GoObject" DNSError.
  "Constructor for net.DNSError"
  {:added "1.0"
   :go "_ConstructDNSError(_v)"}
  [^Object _v])

JOKER TYPE net.Dialer from net/dial.go:
(defn ^"GoObject" Dialer.
  "Constructor for net.Dialer"
  {:added "1.0"
   :go "_ConstructDialer(_v)"}
  [^Object _v])

JOKER TYPE net.Error from net/net.go:
;; (defn ^"GoObject" Error.
;;   "Constructor for net.Error"
;;   {:added "1.0"
;;    :go "_ConstructError(_v)"}
;;   [^Object _v])

JOKER TYPE net.Flags from net/interface.go:
(defn ^"GoObject" Flags.
  "Constructor for net.Flags"
  {:added "1.0"
   :go "_ConstructFlags(_v)"}
  [^Object _v])

JOKER TYPE net.HardwareAddr from net/mac.go:
;; (defn ^"GoObject" HardwareAddr.
;;   "Constructor for net.HardwareAddr"
;;   {:added "1.0"
;;    :go "_ConstructHardwareAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.IP from net/ip.go:
;; (defn ^"GoObject" IP.
;;   "Constructor for net.IP"
;;   {:added "1.0"
;;    :go "_ConstructIP(_v)"}
;;   [^Object _v])

JOKER TYPE net.IPAddr from net/iprawsock.go:
(defn ^"GoObject" IPAddr.
  "Constructor for net.IPAddr"
  {:added "1.0"
   :go "_ConstructIPAddr(_v)"}
  [^Object _v])

JOKER TYPE net.IPConn from net/iprawsock.go:
(defn ^"GoObject" IPConn.
  "Constructor for net.IPConn"
  {:added "1.0"
   :go "_ConstructIPConn(_v)"}
  [^Object _v])

JOKER TYPE net.IPMask from net/ip.go:
;; (defn ^"GoObject" IPMask.
;;   "Constructor for net.IPMask"
;;   {:added "1.0"
;;    :go "_ConstructIPMask(_v)"}
;;   [^Object _v])

JOKER TYPE net.IPNet from net/ip.go:
(defn ^"GoObject" IPNet.
  "Constructor for net.IPNet"
  {:added "1.0"
   :go "_ConstructIPNet(_v)"}
  [^Object _v])

JOKER TYPE net.Interface from net/interface.go:
(defn ^"GoObject" Interface.
  "Constructor for net.Interface"
  {:added "1.0"
   :go "_ConstructInterface(_v)"}
  [^Object _v])

JOKER TYPE net.InvalidAddrError from net/net.go:
(defn ^"GoObject" InvalidAddrError.
  "Constructor for net.InvalidAddrError"
  {:added "1.0"
   :go "_ConstructInvalidAddrError(_v)"}
  [^Object _v])

JOKER TYPE net.ListenConfig from net/dial.go:
(defn ^"GoObject" ListenConfig.
  "Constructor for net.ListenConfig"
  {:added "1.0"
   :go "_ConstructListenConfig(_v)"}
  [^Object _v])

JOKER TYPE net.Listener from net/net.go:
;; (defn ^"GoObject" Listener.
;;   "Constructor for net.Listener"
;;   {:added "1.0"
;;    :go "_ConstructListener(_v)"}
;;   [^Object _v])

JOKER TYPE net.MX from net/dnsclient.go:
(defn ^"GoObject" MX.
  "Constructor for net.MX"
  {:added "1.0"
   :go "_ConstructMX(_v)"}
  [^Object _v])

JOKER TYPE net.NS from net/dnsclient.go:
(defn ^"GoObject" NS.
  "Constructor for net.NS"
  {:added "1.0"
   :go "_ConstructNS(_v)"}
  [^Object _v])

JOKER TYPE net.OpError from net/net.go:
(defn ^"GoObject" OpError.
  "Constructor for net.OpError"
  {:added "1.0"
   :go "_ConstructOpError(_v)"}
  [^Object _v])

JOKER TYPE net.PacketConn from net/net.go:
;; (defn ^"GoObject" PacketConn.
;;   "Constructor for net.PacketConn"
;;   {:added "1.0"
;;    :go "_ConstructPacketConn(_v)"}
;;   [^Object _v])

JOKER TYPE net.ParseError from net/net.go:
(defn ^"GoObject" ParseError.
  "Constructor for net.ParseError"
  {:added "1.0"
   :go "_ConstructParseError(_v)"}
  [^Object _v])

JOKER TYPE net.Resolver from net/lookup.go:
(defn ^"GoObject" Resolver.
  "Constructor for net.Resolver"
  {:added "1.0"
   :go "_ConstructResolver(_v)"}
  [^Object _v])

JOKER TYPE net.SRV from net/dnsclient.go:
(defn ^"GoObject" SRV.
  "Constructor for net.SRV"
  {:added "1.0"
   :go "_ConstructSRV(_v)"}
  [^Object _v])

JOKER TYPE net.TCPAddr from net/tcpsock.go:
(defn ^"GoObject" TCPAddr.
  "Constructor for net.TCPAddr"
  {:added "1.0"
   :go "_ConstructTCPAddr(_v)"}
  [^Object _v])

JOKER TYPE net.TCPConn from net/tcpsock.go:
(defn ^"GoObject" TCPConn.
  "Constructor for net.TCPConn"
  {:added "1.0"
   :go "_ConstructTCPConn(_v)"}
  [^Object _v])

JOKER TYPE net.TCPListener from net/tcpsock.go:
(defn ^"GoObject" TCPListener.
  "Constructor for net.TCPListener"
  {:added "1.0"
   :go "_ConstructTCPListener(_v)"}
  [^Object _v])

JOKER TYPE net.UDPAddr from net/udpsock.go:
(defn ^"GoObject" UDPAddr.
  "Constructor for net.UDPAddr"
  {:added "1.0"
   :go "_ConstructUDPAddr(_v)"}
  [^Object _v])

JOKER TYPE net.UDPConn from net/udpsock.go:
(defn ^"GoObject" UDPConn.
  "Constructor for net.UDPConn"
  {:added "1.0"
   :go "_ConstructUDPConn(_v)"}
  [^Object _v])

JOKER TYPE net.UnixAddr from net/unixsock.go:
(defn ^"GoObject" UnixAddr.
  "Constructor for net.UnixAddr"
  {:added "1.0"
   :go "_ConstructUnixAddr(_v)"}
  [^Object _v])

JOKER TYPE net.UnixConn from net/unixsock.go:
(defn ^"GoObject" UnixConn.
  "Constructor for net.UnixConn"
  {:added "1.0"
   :go "_ConstructUnixConn(_v)"}
  [^Object _v])

JOKER TYPE net.UnixListener from net/unixsock.go:
(defn ^"GoObject" UnixListener.
  "Constructor for net.UnixListener"
  {:added "1.0"
   :go "_ConstructUnixListener(_v)"}
  [^Object _v])

JOKER TYPE net.UnknownNetworkError from net/net.go:
(defn ^"GoObject" UnknownNetworkError.
  "Constructor for net.UnknownNetworkError"
  {:added "1.0"
   :go "_ConstructUnknownNetworkError(_v)"}
  [^Object _v])

JOKER FUNC net.CIDRMask from net/ip.go:
(defn CIDRMask
  "CIDRMask returns an IPMask consisting of `ones' 1 bits\nfollowed by 0s up to a total length of `bits' bits.\nFor a mask of this form, CIDRMask is the inverse of IPMask.Size.\n\nGo input arguments: (ones int, bits int)\n\nGo return type: IPMask\n\nJoker input arguments: [^Int ones, ^Int bits]\n\nJoker return type: go.std.net/IPMask"
  {:added "1.0"
   :go "__cIDRMask(_ones, _bits)"}
  [^Int _ones, ^Int _bits])

JOKER FUNC net.Dial from net/dial.go:
(defn Dial
  "Dial connects to the address on the named network.\n\nKnown networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only),\n\"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\"\n(IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and\n\"unixpacket\".\n\nFor TCP and UDP networks, the address has the form \"host:port\".\nThe host must be a literal IP address, or a host name that can be\nresolved to IP addresses.\nThe port must be a literal port number or a service name.\nIf the host is a literal IPv6 address it must be enclosed in square\nbrackets, as in \"[2001:db8::1]:80\" or \"[fe80::1%zone]:80\".\nThe zone specifies the scope of the literal IPv6 address as defined\nin RFC 4007.\nThe functions JoinHostPort and SplitHostPort manipulate a pair of\nhost and port in this form.\nWhen using TCP, and the host resolves to multiple IP addresses,\nDial will try each IP address in order until one succeeds.\n\nExamples:\n\tDial(\"tcp\", \"golang.org:http\")\n\tDial(\"tcp\", \"192.0.2.1:http\")\n\tDial(\"tcp\", \"198.51.100.1:80\")\n\tDial(\"udp\", \"[2001:db8::1]:domain\")\n\tDial(\"udp\", \"[fe80::1%lo0]:53\")\n\tDial(\"tcp\", \":80\")\n\nFor IP networks, the network must be \"ip\", \"ip4\" or \"ip6\" followed\nby a colon and a literal protocol number or a protocol name, and\nthe address has the form \"host\". The host must be a literal IP\naddress or a literal IPv6 address with zone.\nIt depends on each operating system how the operating system\nbehaves with a non-well known protocol number such as \"0\" or \"255\".\n\nExamples:\n\tDial(\"ip4:1\", \"192.0.2.1\")\n\tDial(\"ip6:ipv6-icmp\", \"2001:db8::1\")\n\tDial(\"ip6:58\", \"fe80::1%lo0\")\n\nFor TCP, UDP and IP networks, if the host is empty or a literal\nunspecified IP address, as in \":80\", \"0.0.0.0:80\" or \"[::]:80\" for\nTCP and UDP, \"\", \"0.0.0.0\" or \"::\" for IP, the local system is\nassumed.\n\nFor Unix networks, the address must be a file system path.\n\nGo input arguments: (network string, address string)\n\nGo return type: (Conn, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/Conn Error]"
  {:added "1.0"
   :go "__dial(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.DialIP from net/iprawsock.go:
(defn DialIP
  "DialIP acts like Dial for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *IPAddr, raddr *IPAddr)\n\nGo return type: (*IPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/IPAddr) laddr, ^(atom-of go.std.net/IPAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/IPConn) Error]"
  {:added "1.0"
   :go "__dialIP(_network, _laddr, _raddr)"}
  [^String _network, ^net/IPAddr _laddr, ^net/IPAddr _raddr])

JOKER FUNC net.DialTCP from net/tcpsock.go:
(defn DialTCP
  "DialTCP acts like Dial for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *TCPAddr, raddr *TCPAddr)\n\nGo return type: (*TCPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/TCPAddr) laddr, ^(atom-of go.std.net/TCPAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/TCPConn) Error]"
  {:added "1.0"
   :go "__dialTCP(_network, _laddr, _raddr)"}
  [^String _network, ^net/TCPAddr _laddr, ^net/TCPAddr _raddr])

JOKER FUNC net.DialTimeout from net/dial.go:
;; (defn DialTimeout
;;   "DialTimeout acts like Dial but takes a timeout.\n\nThe timeout includes name resolution, if required.\nWhen using TCP, and the host in the address parameter resolves to\nmultiple IP addresses, the timeout is spread over each consecutive\ndial, such that each is given an appropriate fraction of the time\nto connect.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string, timeout time.Duration)\n\nGo return type: (Conn, error)\n\nJoker input arguments: [^String network, ^String address, ^go.std.time/Duration timeout]\n\nJoker return type: [go.std.net/Conn Error]"
;;   {:added "1.0"
;;    :go "__dialTimeout(_network, _address, *_timeout)"}
;;   [^String _network, ^String _address, ^time/Duration _timeout])

JOKER FUNC net.DialUDP from net/udpsock.go:
(defn DialUDP
  "DialUDP acts like Dial for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *UDPAddr, raddr *UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UDPAddr) laddr, ^(atom-of go.std.net/UDPAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/UDPConn) Error]"
  {:added "1.0"
   :go "__dialUDP(_network, _laddr, _raddr)"}
  [^String _network, ^net/UDPAddr _laddr, ^net/UDPAddr _raddr])

JOKER FUNC net.DialUnix from net/unixsock.go:
(defn DialUnix
  "DialUnix acts like Dial for Unix networks.\n\nThe network must be a Unix network name; see func Dial for details.\n\nIf laddr is non-nil, it is used as the local address for the\nconnection.\n\nGo input arguments: (network string, laddr *UnixAddr, raddr *UnixAddr)\n\nGo return type: (*UnixConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr, ^(atom-of go.std.net/UnixAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/UnixConn) Error]"
  {:added "1.0"
   :go "__dialUnix(_network, _laddr, _raddr)"}
  [^String _network, ^net/UnixAddr _laddr, ^net/UnixAddr _raddr])

JOKER FUNC net.FileConn from net/file.go:
;; (defn FileConn
;;   "FileConn returns a copy of the network connection corresponding to\nthe open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo input arguments: (f *os.File)\n\nGo return type: (c Conn, err error)\n\nJoker input arguments: [^(atom-of go.std.os/File) f]\n\nJoker return type: [go.std.net/Conn Error]"
;;   {:added "1.0"
;;    :go "__fileConn(_f)"}
;;   [^os/File _f])

JOKER FUNC net.FileListener from net/file.go:
;; (defn FileListener
;;   "FileListener returns a copy of the network listener corresponding\nto the open file f.\nIt is the caller's responsibility to close ln when finished.\nClosing ln does not affect f, and closing f does not affect ln.\n\nGo input arguments: (f *os.File)\n\nGo return type: (ln Listener, err error)\n\nJoker input arguments: [^(atom-of go.std.os/File) f]\n\nJoker return type: [go.std.net/Listener Error]"
;;   {:added "1.0"
;;    :go "__fileListener(_f)"}
;;   [^os/File _f])

JOKER FUNC net.FilePacketConn from net/file.go:
;; (defn FilePacketConn
;;   "FilePacketConn returns a copy of the packet network connection\ncorresponding to the open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo input arguments: (f *os.File)\n\nGo return type: (c PacketConn, err error)\n\nJoker input arguments: [^(atom-of go.std.os/File) f]\n\nJoker return type: [go.std.net/PacketConn Error]"
;;   {:added "1.0"
;;    :go "__filePacketConn(_f)"}
;;   [^os/File _f])

JOKER FUNC net.IPv4 from net/ip.go:
(defn IPv4
  "IPv4 returns the IP address (in 16-byte form) of the\nIPv4 address a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo return type: IP\n\nJoker input arguments: [^Byte a, ^Byte b, ^Byte c, ^Byte d]\n\nJoker return type: go.std.net/IP"
  {:added "1.0"
   :go "__iPv4(_a, _b, _c, _d)"}
  [^Byte _a, ^Byte _b, ^Byte _c, ^Byte _d])

JOKER FUNC net.IPv4Mask from net/ip.go:
(defn IPv4Mask
  "IPv4Mask returns the IP mask (in 4-byte form) of the\nIPv4 mask a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo return type: IPMask\n\nJoker input arguments: [^Byte a, ^Byte b, ^Byte c, ^Byte d]\n\nJoker return type: go.std.net/IPMask"
  {:added "1.0"
   :go "__iPv4Mask(_a, _b, _c, _d)"}
  [^Byte _a, ^Byte _b, ^Byte _c, ^Byte _d])

JOKER FUNC net.InterfaceAddrs from net/interface.go:
(defn InterfaceAddrs
  "InterfaceAddrs returns a list of the system's unicast interface\naddresses.\n\nThe returned list does not identify the associated interface; use\nInterfaces and Interface.Addrs for more detail.\n\nGo return type: ([]Addr, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of go.std.net/Addr) Error]"
  {:added "1.0"
   :go "__interfaceAddrs()"}
  [])

JOKER FUNC net.InterfaceByIndex from net/interface.go:
(defn InterfaceByIndex
  "InterfaceByIndex returns the interface specified by index.\n\nOn Solaris, it returns one of the logical network interfaces\nsharing the logical data link; for more precision use\nInterfaceByName.\n\nGo input arguments: (index int)\n\nGo return type: (*Interface, error)\n\nJoker input arguments: [^Int index]\n\nJoker return type: [(atom-of go.std.net/Interface) Error]"
  {:added "1.0"
   :go "__interfaceByIndex(_index)"}
  [^Int _index])

JOKER FUNC net.InterfaceByName from net/interface.go:
(defn InterfaceByName
  "InterfaceByName returns the interface specified by name.\n\nGo input arguments: (name string)\n\nGo return type: (*Interface, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.net/Interface) Error]"
  {:added "1.0"
   :go "__interfaceByName(_name)"}
  [^String _name])

JOKER FUNC net.Interfaces from net/interface.go:
(defn Interfaces
  "Interfaces returns a list of the system's network interfaces.\n\nGo return type: ([]Interface, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of go.std.net/Interface) Error]"
  {:added "1.0"
   :go "__interfaces()"}
  [])

JOKER FUNC net.JoinHostPort from net/ipsock.go:
(defn ^"String" JoinHostPort
  "JoinHostPort combines host and port into a network address of the\nform \"host:port\". If host contains a colon, as found in literal\nIPv6 addresses, then JoinHostPort returns \"[host]:port\".\n\nSee func Dial for a description of the host and port parameters.\n\nGo input arguments: (host string, port string)\n\nGo return type: string\n\nJoker input arguments: [^String host, ^String port]\n\nJoker return type: String"
  {:added "1.0"
   :go "net.JoinHostPort(_host, _port)"}
  [^String _host, ^String _port])

JOKER FUNC net.Listen from net/dial.go:
(defn Listen
  "Listen announces on the local network address.\n\nThe network must be \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\".\n\nFor TCP networks, if the host in the address parameter is empty or\na literal unspecified IP address, Listen listens on all available\nunicast and anycast IP addresses of the local system.\nTo only use IPv4, use network \"tcp4\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe Addr method of Listener can be used to discover the chosen\nport.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (Listener, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/Listener Error]"
  {:added "1.0"
   :go "__listen(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.ListenIP from net/iprawsock.go:
(defn ListenIP
  "ListenIP acts like ListenPacket for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenIP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\n\nGo input arguments: (network string, laddr *IPAddr)\n\nGo return type: (*IPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/IPAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/IPConn) Error]"
  {:added "1.0"
   :go "__listenIP(_network, _laddr)"}
  [^String _network, ^net/IPAddr _laddr])

JOKER FUNC net.ListenMulticastUDP from net/udpsock.go:
(defn ListenMulticastUDP
  "ListenMulticastUDP acts like ListenPacket for UDP networks but\ntakes a group address on a specific network interface.\n\nThe network must be a UDP network name; see func Dial for details.\n\nListenMulticastUDP listens on all available IP addresses of the\nlocal system including the group, multicast IP address.\nIf ifi is nil, ListenMulticastUDP uses the system-assigned\nmulticast interface, although this is not recommended because the\nassignment depends on platforms and sometimes it might require\nrouting configuration.\nIf the Port field of gaddr is 0, a port number is automatically\nchosen.\n\nListenMulticastUDP is just for convenience of simple, small\napplications. There are golang.org/x/net/ipv4 and\ngolang.org/x/net/ipv6 packages for general purpose uses.\n\nGo input arguments: (network string, ifi *Interface, gaddr *UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/Interface) ifi, ^(atom-of go.std.net/UDPAddr) gaddr]\n\nJoker return type: [(atom-of go.std.net/UDPConn) Error]"
  {:added "1.0"
   :go "__listenMulticastUDP(_network, _ifi, _gaddr)"}
  [^String _network, ^net/Interface _ifi, ^net/UDPAddr _gaddr])

JOKER FUNC net.ListenPacket from net/dial.go:
(defn ListenPacket
  "ListenPacket announces on the local network address.\n\nThe network must be \"udp\", \"udp4\", \"udp6\", \"unixgram\", or an IP\ntransport. The IP transports are \"ip\", \"ip4\", or \"ip6\" followed by\na colon and a literal protocol number or a protocol name, as in\n\"ip:1\" or \"ip:icmp\".\n\nFor UDP and IP networks, if the host in the address parameter is\nempty or a literal unspecified IP address, ListenPacket listens on\nall available IP addresses of the local system except multicast IP\naddresses.\nTo only use IPv4, use network \"udp4\" or \"ip4:proto\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe LocalAddr method of PacketConn can be used to discover the\nchosen port.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (PacketConn, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/PacketConn Error]"
  {:added "1.0"
   :go "__listenPacket(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.ListenTCP from net/tcpsock.go:
(defn ListenTCP
  "ListenTCP acts like Listen for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenTCP listens on all available unicast and anycast IP addresses\nof the local system.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo input arguments: (network string, laddr *TCPAddr)\n\nGo return type: (*TCPListener, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/TCPAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/TCPListener) Error]"
  {:added "1.0"
   :go "__listenTCP(_network, _laddr)"}
  [^String _network, ^net/TCPAddr _laddr])

JOKER FUNC net.ListenUDP from net/udpsock.go:
(defn ListenUDP
  "ListenUDP acts like ListenPacket for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenUDP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo input arguments: (network string, laddr *UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UDPAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/UDPConn) Error]"
  {:added "1.0"
   :go "__listenUDP(_network, _laddr)"}
  [^String _network, ^net/UDPAddr _laddr])

JOKER FUNC net.ListenUnix from net/unixsock.go:
(defn ListenUnix
  "ListenUnix acts like Listen for Unix networks.\n\nThe network must be \"unix\" or \"unixpacket\".\n\nGo input arguments: (network string, laddr *UnixAddr)\n\nGo return type: (*UnixListener, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/UnixListener) Error]"
  {:added "1.0"
   :go "__listenUnix(_network, _laddr)"}
  [^String _network, ^net/UnixAddr _laddr])

JOKER FUNC net.ListenUnixgram from net/unixsock.go:
(defn ListenUnixgram
  "ListenUnixgram acts like ListenPacket for Unix networks.\n\nThe network must be \"unixgram\".\n\nGo input arguments: (network string, laddr *UnixAddr)\n\nGo return type: (*UnixConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/UnixConn) Error]"
  {:added "1.0"
   :go "__listenUnixgram(_network, _laddr)"}
  [^String _network, ^net/UnixAddr _laddr])

JOKER FUNC net.LookupAddr from net/lookup.go:
(defn LookupAddr
  "LookupAddr performs a reverse lookup for the given address, returning a list\nof names mapping to that address.\n\nWhen using the host C library resolver, at most one result will be\nreturned. To bypass the host resolver, use a custom Resolver.\n\nGo input arguments: (addr string)\n\nGo return type: (names []string, err error)\n\nJoker input arguments: [^String addr]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__lookupAddr(_addr)"}
  [^String _addr])

JOKER FUNC net.LookupCNAME from net/lookup.go:
(defn LookupCNAME
  "LookupCNAME returns the canonical name for the given host.\nCallers that do not care about the canonical name can call\nLookupHost or LookupIP directly; both take care of resolving\nthe canonical name as part of the lookup.\n\nA canonical name is the final name after following zero\nor more CNAME records.\nLookupCNAME does not return an error if host does not\ncontain DNS \"CNAME\" records, as long as host resolves to\naddress records.\n\nGo input arguments: (host string)\n\nGo return type: (cname string, err error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__lookupCNAME(_host)"}
  [^String _host])

JOKER FUNC net.LookupHost from net/lookup.go:
(defn LookupHost
  "LookupHost looks up the given host using the local resolver.\nIt returns a slice of that host's addresses.\n\nGo input arguments: (host string)\n\nGo return type: (addrs []string, err error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__lookupHost(_host)"}
  [^String _host])

JOKER FUNC net.LookupIP from net/lookup.go:
(defn LookupIP
  "LookupIP looks up host using the local resolver.\nIt returns a slice of that host's IPv4 and IPv6 addresses.\n\nGo input arguments: (host string)\n\nGo return type: ([]IP, error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [(vector-of go.std.net/IP) Error]"
  {:added "1.0"
   :go "__lookupIP(_host)"}
  [^String _host])

JOKER FUNC net.LookupMX from net/lookup.go:
(defn LookupMX
  "LookupMX returns the DNS MX records for the given domain name sorted by preference.\n\nGo input arguments: (name string)\n\nGo return type: ([]*MX, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of (atom-of go.std.net/MX)) Error]"
  {:added "1.0"
   :go "__lookupMX(_name)"}
  [^String _name])

JOKER FUNC net.LookupNS from net/lookup.go:
(defn LookupNS
  "LookupNS returns the DNS NS records for the given domain name.\n\nGo input arguments: (name string)\n\nGo return type: ([]*NS, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of (atom-of go.std.net/NS)) Error]"
  {:added "1.0"
   :go "__lookupNS(_name)"}
  [^String _name])

JOKER FUNC net.LookupPort from net/lookup.go:
(defn LookupPort
  "LookupPort looks up the port for the given network and service.\n\nGo input arguments: (network string, service string)\n\nGo return type: (port int, err error)\n\nJoker input arguments: [^String network, ^String service]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__lookupPort(_network, _service)"}
  [^String _network, ^String _service])

JOKER FUNC net.LookupSRV from net/lookup.go:
(defn LookupSRV
  "LookupSRV tries to resolve an SRV query of the given service,\nprotocol, and domain name. The proto is \"tcp\" or \"udp\".\nThe returned records are sorted by priority and randomized\nby weight within a priority.\n\nLookupSRV constructs the DNS name to look up following RFC 2782.\nThat is, it looks up _service._proto.name. To accommodate services\npublishing SRV records under non-standard names, if both service\nand proto are empty strings, LookupSRV looks up name directly.\n\nGo input arguments: (service string, proto string, name string)\n\nGo return type: (cname string, addrs []*SRV, err error)\n\nJoker input arguments: [^String service, ^String proto, ^String name]\n\nJoker return type: [String (vector-of (atom-of go.std.net/SRV)) Error]"
  {:added "1.0"
   :go "__lookupSRV(_service, _proto, _name)"}
  [^String _service, ^String _proto, ^String _name])

JOKER FUNC net.LookupTXT from net/lookup.go:
(defn LookupTXT
  "LookupTXT returns the DNS TXT records for the given domain name.\n\nGo input arguments: (name string)\n\nGo return type: ([]string, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__lookupTXT(_name)"}
  [^String _name])

JOKER FUNC net.ParseCIDR from net/ip.go:
(defn ParseCIDR
  "ParseCIDR parses s as a CIDR notation IP address and prefix length,\nlike \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in\nRFC 4632 and RFC 4291.\n\nIt returns the IP address and the network implied by the IP and\nprefix length.\nFor example, ParseCIDR(\"192.0.2.1/24\") returns the IP address\n192.0.2.1 and the network 192.0.2.0/24.\n\nGo input arguments: (s string)\n\nGo return type: (IP, *IPNet, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [go.std.net/IP (atom-of go.std.net/IPNet) Error]"
  {:added "1.0"
   :go "__parseCIDR(_s)"}
  [^String _s])

JOKER FUNC net.ParseIP from net/ip.go:
(defn ParseIP
  "ParseIP parses s as an IP address, returning the result.\nThe string s can be in dotted decimal (\"192.0.2.1\")\nor IPv6 (\"2001:db8::68\") form.\nIf s is not a valid textual representation of an IP address,\nParseIP returns nil.\n\nGo input arguments: (s string)\n\nGo return type: IP\n\nJoker input arguments: [^String s]\n\nJoker return type: go.std.net/IP"
  {:added "1.0"
   :go "__parseIP(_s)"}
  [^String _s])

JOKER FUNC net.ParseMAC from net/mac.go:
(defn ParseMAC
  "ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet\nIP over InfiniBand link-layer address using one of the following formats:\n  01:23:45:67:89:ab\n  01:23:45:67:89:ab:cd:ef\n  01:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00\n  01-23-45-67-89-ab\n  01-23-45-67-89-ab-cd-ef\n  01-23-45-67-89-ab-cd-ef-00-00-01-23-45-67-89-ab-cd-ef-00-00\n  0123.4567.89ab\n  0123.4567.89ab.cdef\n  0123.4567.89ab.cdef.0000.0123.4567.89ab.cdef.0000\n\nGo input arguments: (s string)\n\nGo return type: (hw HardwareAddr, err error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [go.std.net/HardwareAddr Error]"
  {:added "1.0"
   :go "__parseMAC(_s)"}
  [^String _s])

JOKER FUNC net.Pipe from net/pipe.go:
(defn Pipe
  "Pipe creates a synchronous, in-memory, full duplex\nnetwork connection; both ends implement the Conn interface.\nReads on one end are matched with writes on the other,\ncopying data directly between the two; there is no internal\nbuffering.\n\nGo return type: (Conn, Conn)\n\nJoker input arguments: []\n\nJoker return type: [go.std.net/Conn go.std.net/Conn]"
  {:added "1.0"
   :go "__pipe()"}
  [])

JOKER FUNC net.ResolveIPAddr from net/iprawsock.go:
(defn ResolveIPAddr
  "ResolveIPAddr returns an address of IP end point.\n\nThe network must be an IP network name.\n\nIf the host in the address parameter is not a literal IP address,\nResolveIPAddr resolves the address to an address of IP end point.\nOtherwise, it parses the address as a literal IP address.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*IPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/IPAddr) Error]"
  {:added "1.0"
   :go "__resolveIPAddr(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.ResolveTCPAddr from net/tcpsock.go:
(defn ResolveTCPAddr
  "ResolveTCPAddr returns an address of TCP end point.\n\nThe network must be a TCP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveTCPAddr resolves the\naddress to an address of TCP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*TCPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/TCPAddr) Error]"
  {:added "1.0"
   :go "__resolveTCPAddr(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.ResolveUDPAddr from net/udpsock.go:
(defn ResolveUDPAddr
  "ResolveUDPAddr returns an address of UDP end point.\n\nThe network must be a UDP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveUDPAddr resolves the\naddress to an address of UDP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*UDPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/UDPAddr) Error]"
  {:added "1.0"
   :go "__resolveUDPAddr(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.ResolveUnixAddr from net/unixsock.go:
(defn ResolveUnixAddr
  "ResolveUnixAddr returns an address of Unix domain socket end point.\n\nThe network must be a Unix network name.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*UnixAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/UnixAddr) Error]"
  {:added "1.0"
   :go "__resolveUnixAddr(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.SplitHostPort from net/ipsock.go:
(defn SplitHostPort
  "SplitHostPort splits a network address of the form \"host:port\",\n\"host%zone:port\", \"[host]:port\" or \"[host%zone]:port\" into host or\nhost%zone and port.\n\nA literal IPv6 address in hostport must be enclosed in square\nbrackets, as in \"[::1]:80\", \"[::1%lo0]:80\".\n\nSee func Dial for a description of the hostport parameter, and host\nand port results.\n\nGo input arguments: (hostport string)\n\nGo return type: (host string, port string, err error)\n\nJoker input arguments: [^String hostport]\n\nJoker return type: [String String Error]"
  {:added "1.0"
   :go "__splitHostPort(_hostport)"}
  [^String _hostport])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net"]
    :doc "Provides a low-level interface to the net package."
    :empty false}
  go.std.net)
JOKER TYPE net/http.Client from net/http/client.go:
(defn ^"GoObject" Client.
  "Constructor for http.Client"
  {:added "1.0"
   :go "_ConstructClient(_v)"}
  [^Object _v])

JOKER TYPE net/http.CloseNotifier from net/http/server.go:
;; (defn ^"GoObject" CloseNotifier.
;;   "Constructor for http.CloseNotifier"
;;   {:added "1.0"
;;    :go "_ConstructCloseNotifier(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.ConnState from net/http/server.go:
(defn ^"GoObject" ConnState.
  "Constructor for http.ConnState"
  {:added "1.0"
   :go "_ConstructConnState(_v)"}
  [^Object _v])

JOKER TYPE net/http.Cookie from net/http/cookie.go:
(defn ^"GoObject" Cookie.
  "Constructor for http.Cookie"
  {:added "1.0"
   :go "_ConstructCookie(_v)"}
  [^Object _v])

JOKER TYPE net/http.CookieJar from net/http/jar.go:
;; (defn ^"GoObject" CookieJar.
;;   "Constructor for http.CookieJar"
;;   {:added "1.0"
;;    :go "_ConstructCookieJar(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Dir from net/http/fs.go:
(defn ^"GoObject" Dir.
  "Constructor for http.Dir"
  {:added "1.0"
   :go "_ConstructDir(_v)"}
  [^Object _v])

JOKER TYPE net/http.File from net/http/fs.go:
;; (defn ^"GoObject" File.
;;   "Constructor for http.File"
;;   {:added "1.0"
;;    :go "_ConstructFile(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.FileSystem from net/http/fs.go:
;; (defn ^"GoObject" FileSystem.
;;   "Constructor for http.FileSystem"
;;   {:added "1.0"
;;    :go "_ConstructFileSystem(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Flusher from net/http/server.go:
;; (defn ^"GoObject" Flusher.
;;   "Constructor for http.Flusher"
;;   {:added "1.0"
;;    :go "_ConstructFlusher(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Handler from net/http/server.go:
;; (defn ^"GoObject" Handler.
;;   "Constructor for http.Handler"
;;   {:added "1.0"
;;    :go "_ConstructHandler(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.HandlerFunc from net/http/server.go:
;; (defn ^"GoObject" HandlerFunc.
;;   "Constructor for http.HandlerFunc"
;;   {:added "1.0"
;;    :go "_ConstructHandlerFunc(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Header from net/http/header.go:
;; (defn ^"GoObject" Header.
;;   "Constructor for http.Header"
;;   {:added "1.0"
;;    :go "_ConstructHeader(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Hijacker from net/http/server.go:
;; (defn ^"GoObject" Hijacker.
;;   "Constructor for http.Hijacker"
;;   {:added "1.0"
;;    :go "_ConstructHijacker(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.ProtocolError from net/http/request.go:
(defn ^"GoObject" ProtocolError.
  "Constructor for http.ProtocolError"
  {:added "1.0"
   :go "_ConstructProtocolError(_v)"}
  [^Object _v])

JOKER TYPE net/http.PushOptions from net/http/http.go:
(defn ^"GoObject" PushOptions.
  "Constructor for http.PushOptions"
  {:added "1.0"
   :go "_ConstructPushOptions(_v)"}
  [^Object _v])

JOKER TYPE net/http.Pusher from net/http/http.go:
;; (defn ^"GoObject" Pusher.
;;   "Constructor for http.Pusher"
;;   {:added "1.0"
;;    :go "_ConstructPusher(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Request from net/http/request.go:
(defn ^"GoObject" Request.
  "Constructor for http.Request"
  {:added "1.0"
   :go "_ConstructRequest(_v)"}
  [^Object _v])

JOKER TYPE net/http.Response from net/http/response.go:
(defn ^"GoObject" Response.
  "Constructor for http.Response"
  {:added "1.0"
   :go "_ConstructResponse(_v)"}
  [^Object _v])

JOKER TYPE net/http.ResponseWriter from net/http/server.go:
;; (defn ^"GoObject" ResponseWriter.
;;   "Constructor for http.ResponseWriter"
;;   {:added "1.0"
;;    :go "_ConstructResponseWriter(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.RoundTripper from net/http/client.go:
;; (defn ^"GoObject" RoundTripper.
;;   "Constructor for http.RoundTripper"
;;   {:added "1.0"
;;    :go "_ConstructRoundTripper(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.SameSite from net/http/cookie.go:
(defn ^"GoObject" SameSite.
  "Constructor for http.SameSite"
  {:added "1.0"
   :go "_ConstructSameSite(_v)"}
  [^Object _v])

JOKER TYPE net/http.ServeMux from net/http/server.go:
(defn ^"GoObject" ServeMux.
  "Constructor for http.ServeMux"
  {:added "1.0"
   :go "_ConstructServeMux(_v)"}
  [^Object _v])

JOKER TYPE net/http.Server from net/http/server.go:
(defn ^"GoObject" Server.
  "Constructor for http.Server"
  {:added "1.0"
   :go "_ConstructServer(_v)"}
  [^Object _v])

JOKER TYPE net/http.Transport from net/http/transport.go:
(defn ^"GoObject" Transport.
  "Constructor for http.Transport"
  {:added "1.0"
   :go "_ConstructTransport(_v)"}
  [^Object _v])

JOKER FUNC net/http.CanonicalHeaderKey from net/http/header.go:
(defn ^"String" CanonicalHeaderKey
  "CanonicalHeaderKey returns the canonical format of the\nheader key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.CanonicalHeaderKey(_s)"}
  [^String _s])

JOKER FUNC net/http.DetectContentType from net/http/sniff.go:
;; (defn ^"String" DetectContentType
;;   "DetectContentType implements the algorithm described\nat https://mimesniff.spec.whatwg.org/ to determine the\nContent-Type of the given data. It considers at most the\nfirst 512 bytes of data. DetectContentType always returns\na valid MIME type: if it cannot determine a more specific one, it\nreturns \"application/octet-stream\".\n\nGo input arguments: (data []byte)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "http.DetectContentType(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC net/http.Error from net/http/server.go:
;; (defn Error
;;   "Error replies to the request with the specified error message and HTTP code.\nIt does not otherwise end the request; the caller should ensure no further\nwrites are done to w.\nThe error message should be plain text.\n\nGo input arguments: (w ResponseWriter, error string, code int)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^String error, ^Int code]"
;;   {:added "1.0"
;;    :go "__error(*_w, _error, _code)"}
;;   [^http/ResponseWriter _w, ^String _error, ^Int _code])

JOKER FUNC net/http.FileServer from net/http/fs.go:
(defn FileServer
  "FileServer returns a handler that serves HTTP requests\nwith the contents of the file system rooted at root.\n\nTo use the operating system's file system implementation,\nuse http.Dir:\n\n    http.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))\n\nAs a special case, the returned file server redirects any request\nending in \"/index.html\" to the same path, without the final\n\"index.html\".\n\nGo input arguments: (root FileSystem)\n\nGo return type: Handler\n\nJoker input arguments: [^go.std.net.http/FileSystem root]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__fileServer(*_root)"}
  [^http/FileSystem _root])

JOKER FUNC net/http.Get from net/http/client.go:
(defn Get
  "Get issues a GET to the specified URL. If the response is one of\nthe following redirect codes, Get follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nAn error is returned if there were too many redirects or if there\nwas an HTTP protocol error. A non-2xx response doesn't cause an\nerror. Any returned error will be of type *url.Error. The url.Error\nvalue's Timeout method will report true if request timed out or was\ncanceled.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nGet is a wrapper around DefaultClient.Get.\n\nTo make a request with custom headers, use NewRequest and\nDefaultClient.Do.\n\nGo input arguments: (url string)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
  {:added "1.0"
   :go "__get(_url)"}
  [^String _url])

JOKER FUNC net/http.Handle from net/http/server.go:
;; (defn Handle
;;   "Handle registers the handler for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler Handler)\n\nJoker input arguments: [^String pattern, ^go.std.net.http/Handler handler]"
;;   {:added "1.0"
;;    :go "__handle(_pattern, *_handler)"}
;;   [^String _pattern, ^http/Handler _handler])

JOKER FUNC net/http.HandleFunc from net/http/server.go:
;; (defn HandleFunc
;;   "HandleFunc registers the handler function for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler func)\n\nJoker input arguments: [^String pattern, ^fn handler]"
;;   {:added "1.0"
;;    :go "__handleFunc(_pattern, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String _pattern, ^fn _handler])

JOKER FUNC net/http.Head from net/http/client.go:
(defn Head
  "Head issues a HEAD to the specified URL. If the response is one of\nthe following redirect codes, Head follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nHead is a wrapper around DefaultClient.Head\n\nGo input arguments: (url string)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
  {:added "1.0"
   :go "__head(_url)"}
  [^String _url])

JOKER FUNC net/http.ListenAndServe from net/http/server.go:
(defn ^"Error" ListenAndServe
  "ListenAndServe listens on the TCP network address addr and then calls\nServe with handler to handle requests on incoming connections.\nAccepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error.\n\nGo input arguments: (addr string, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
  {:added "1.0"
   :go "http.ListenAndServe(_addr, *_handler)"}
  [^String _addr, ^http/Handler _handler])

JOKER FUNC net/http.ListenAndServeTLS from net/http/server.go:
(defn ^"Error" ListenAndServeTLS
  "ListenAndServeTLS acts identically to ListenAndServe, except that it\nexpects HTTPS connections. Additionally, files containing a certificate and\nmatching private key for the server must be provided. If the certificate\nis signed by a certificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nGo input arguments: (addr string, certFile string, keyFile string, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^String certFile, ^String keyFile, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
  {:added "1.0"
   :go "http.ListenAndServeTLS(_addr, _certFile, _keyFile, *_handler)"}
  [^String _addr, ^String _certFile, ^String _keyFile, ^http/Handler _handler])

JOKER FUNC net/http.MaxBytesReader from net/http/request.go:
;; (defn MaxBytesReader
;;   "MaxBytesReader is similar to io.LimitReader but is intended for\nlimiting the size of incoming request bodies. In contrast to\nio.LimitReader, MaxBytesReader's result is a ReadCloser, returns a\nnon-EOF error for a Read beyond the limit, and closes the\nunderlying reader when its Close method is called.\n\nMaxBytesReader prevents clients from accidentally or maliciously\nsending a large request and wasting server resources.\n\nGo input arguments: (w ResponseWriter, r io.ReadCloser, n int64)\n\nGo return type: io.ReadCloser\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^go.std.io/ReadCloser r, ^Int64 n]\n\nJoker return type: go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "__maxBytesReader(*_w, *_r, _n)"}
;;   [^http/ResponseWriter _w, ^io/ReadCloser _r, ^Int64 _n])

JOKER FUNC net/http.NewFileTransport from net/http/filetransport.go:
(defn NewFileTransport
  "NewFileTransport returns a new RoundTripper, serving the provided\nFileSystem. The returned RoundTripper ignores the URL host in its\nincoming requests, as well as most other properties of the\nrequest.\n\nThe typical use case for NewFileTransport is to register the \"file\"\nprotocol with a Transport, as in:\n\n  t := &http.Transport{}\n  t.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))\n  c := &http.Client{Transport: t}\n  res, err := c.Get(\"file:///etc/passwd\")\n  ...\n\nGo input arguments: (fs FileSystem)\n\nGo return type: RoundTripper\n\nJoker input arguments: [^go.std.net.http/FileSystem fs]\n\nJoker return type: go.std.net.http/RoundTripper"
  {:added "1.0"
   :go "__newFileTransport(*_fs)"}
  [^http/FileSystem _fs])

JOKER FUNC net/http.NewRequest from net/http/request.go:
;; (defn NewRequest
;;   "NewRequest returns a new Request given a method, URL, and optional body.\n\nIf the provided body is also an io.Closer, the returned\nRequest.Body is set to body and will be closed by the Client\nmethods Do, Post, and PostForm, and Transport.RoundTrip.\n\nNewRequest returns a Request suitable for use with Client.Do or\nTransport.RoundTrip. To create a request for use with testing a\nServer Handler, either use the NewRequest function in the\nnet/http/httptest package, use ReadRequest, or manually update the\nRequest fields. See the Request type's documentation for the\ndifference between inbound and outbound request fields.\n\nIf body is of type *bytes.Buffer, *bytes.Reader, or\n*strings.Reader, the returned request's ContentLength is set to its\nexact value (instead of -1), GetBody is populated (so 307 and 308\nredirects can replay the body), and Body is set to NoBody if the\nContentLength is 0.\n\nGo input arguments: (method string, url string, body io.Reader)\n\nGo return type: (*Request, error)\n\nJoker input arguments: [^String method, ^String url, ^go.std.io/Reader body]\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
;;   {:added "1.0"
;;    :go "__newRequest(_method, _url, *_body)"}
;;   [^String _method, ^String _url, ^io/Reader _body])

JOKER FUNC net/http.NewServeMux from net/http/server.go:
(defn NewServeMux
  "NewServeMux allocates and returns a new ServeMux.\n\nGo return type: *ServeMux\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.net.http/ServeMux)"
  {:added "1.0"
   :go "__newServeMux()"}
  [])

JOKER FUNC net/http.NotFound from net/http/server.go:
;; (defn NotFound
;;   "NotFound replies to the request with an HTTP 404 not found error.\n\nGo input arguments: (w ResponseWriter, r *Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__notFound(*_w, _r)"}
;;   [^http/ResponseWriter _w, ^http/Request _r])

JOKER FUNC net/http.NotFoundHandler from net/http/server.go:
(defn NotFoundHandler
  "NotFoundHandler returns a simple request handler\nthat replies to each request with a ``404 page not found'' reply.\n\nGo return type: Handler\n\nJoker input arguments: []\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__notFoundHandler()"}
  [])

JOKER FUNC net/http.ParseHTTPVersion from net/http/request.go:
(defn ParseHTTPVersion
  "ParseHTTPVersion parses a HTTP version string.\n\"HTTP/1.0\" returns (1, 0, true).\n\nGo input arguments: (vers string)\n\nGo return type: (major int, minor int, ok bool)\n\nJoker input arguments: [^String vers]\n\nJoker return type: [Int Int Boolean]"
  {:added "1.0"
   :go "__parseHTTPVersion(_vers)"}
  [^String _vers])

JOKER FUNC net/http.ParseTime from net/http/header.go:
(defn ParseTime
  "ParseTime parses a time header (such as the Date: header),\ntrying each of the three formats allowed by HTTP/1.1:\nTimeFormat, time.RFC850, and time.ANSIC.\n\nGo input arguments: (text string)\n\nGo return type: (t time.Time, err error)\n\nJoker input arguments: [^String text]\n\nJoker return type: [go.std.time/Time Error]"
  {:added "1.0"
   :go "__parseTime(_text)"}
  [^String _text])

JOKER FUNC net/http.Post from net/http/client.go:
;; (defn Post
;;   "Post issues a POST to the specified URL.\n\nCaller should close resp.Body when done reading from it.\n\nIf the provided body is an io.Closer, it is closed after the\nrequest.\n\nPost is a wrapper around DefaultClient.Post.\n\nTo set custom headers, use NewRequest and DefaultClient.Do.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, contentType string, body io.Reader)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^String contentType, ^go.std.io/Reader body]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
;;   {:added "1.0"
;;    :go "__post(_url, _contentType, *_body)"}
;;   [^String _url, ^String _contentType, ^io/Reader _body])

JOKER FUNC net/http.PostForm from net/http/client.go:
;; (defn PostForm
;;   "PostForm issues a POST to the specified URL, with data's keys and\nvalues URL-encoded as the request body.\n\nThe Content-Type header is set to application/x-www-form-urlencoded.\nTo set other headers, use NewRequest and DefaultClient.Do.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nPostForm is a wrapper around DefaultClient.PostForm.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, data url.Values)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^go.std.net.url/Values data]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
;;   {:added "1.0"
;;    :go "__postForm(_url, *_data)"}
;;   [^String _url, ^url/Values _data])

JOKER FUNC net/http.ProxyFromEnvironment from net/http/transport.go:
(defn ProxyFromEnvironment
  "ProxyFromEnvironment returns the URL of the proxy to use for a\ngiven request, as indicated by the environment variables\nHTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions\nthereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https\nrequests.\n\nThe environment values may be either a complete URL or a\n\"host[:port]\", in which case the \"http\" scheme is assumed.\nAn error is returned if the value is a different form.\n\nA nil URL and nil error are returned if no proxy is defined in the\nenvironment, or a proxy should not be used for the given request,\nas defined by NO_PROXY.\n\nAs a special case, if req.URL.Host is \"localhost\" (with or without\na port number), then a nil URL and nil error will be returned.\n\nGo input arguments: (req *Request)\n\nGo return type: (*net/url.URL, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req]\n\nJoker return type: [(atom-of go.std.net.url/URL) Error]"
  {:added "1.0"
   :go "__proxyFromEnvironment(_req)"}
  [^http/Request _req])

JOKER FUNC net/http.ProxyURL from net/http/transport.go:
;; (defn ProxyURL
;;   "ProxyURL returns a proxy function (for use in a Transport)\nthat always returns the same URL.\n\nGo input arguments: (fixedURL *url.URL)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of go.std.net.url/URL) fixedURL]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.FuncType at: /usr/local/go-1.11.5/src/net/http/transport.go:351:34)"
;;   {:added "1.0"
;;    :go "__proxyURL(_fixedURL)"}
;;   [^url/URL _fixedURL])

JOKER FUNC net/http.ReadRequest from net/http/request.go:
;; (defn ReadRequest
;;   "ReadRequest reads and parses an incoming request from b.\n\nReadRequest is a low-level function and should only be used for\nspecialized applications; most code should use the Server to read\nrequests and handle them via the Handler interface. ReadRequest\nonly supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.\n\nGo input arguments: (b *bufio.Reader)\n\nGo return type: (*Request, error)\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) b]\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
;;   {:added "1.0"
;;    :go "__readRequest(_b)"}
;;   [^bufio/Reader _b])

JOKER FUNC net/http.ReadResponse from net/http/response.go:
;; (defn ReadResponse
;;   "ReadResponse reads and returns an HTTP response from r.\nThe req parameter optionally specifies the Request that corresponds\nto this Response. If nil, a GET request is assumed.\nClients must call resp.Body.Close when finished reading resp.Body.\nAfter that call, clients can inspect resp.Trailer to find key/value\npairs included in the response trailer.\n\nGo input arguments: (r *bufio.Reader, req *Request)\n\nGo return type: (*Response, error)\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) r, ^(atom-of go.std.net.http/Request) req]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
;;   {:added "1.0"
;;    :go "__readResponse(_r, _req)"}
;;   [^bufio/Reader _r, ^http/Request _req])

JOKER FUNC net/http.Redirect from net/http/server.go:
;; (defn Redirect
;;   "Redirect replies to the request with a redirect to url,\nwhich may be a path relative to the request path.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nIf the Content-Type header has not been set, Redirect sets it\nto \"text/html; charset=utf-8\" and writes a small HTML body.\nSetting the Content-Type header to any value, including nil,\ndisables that behavior.\n\nGo input arguments: (w ResponseWriter, r *Request, url string, code int)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r, ^String url, ^Int code]"
;;   {:added "1.0"
;;    :go "__redirect(*_w, _r, _url, _code)"}
;;   [^http/ResponseWriter _w, ^http/Request _r, ^String _url, ^Int _code])

JOKER FUNC net/http.RedirectHandler from net/http/server.go:
(defn RedirectHandler
  "RedirectHandler returns a request handler that redirects\neach request it receives to the given url using the given\nstatus code.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nGo input arguments: (url string, code int)\n\nGo return type: Handler\n\nJoker input arguments: [^String url, ^Int code]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__redirectHandler(_url, _code)"}
  [^String _url, ^Int _code])

JOKER FUNC net/http.Serve from net/http/server.go:
;; (defn ^"Error" Serve
;;   "Serve accepts incoming HTTP connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nHTTP/2 support is only enabled if the Listener returns *tls.Conn\nconnections and they were configured with \"h2\" in the TLS\nConfig.NextProtos.\n\nServe always returns a non-nil error.\n\nGo input arguments: (l net.Listener, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.Serve(*_l, *_handler)"}
;;   [^net/Listener _l, ^http/Handler _handler])

JOKER FUNC net/http.ServeContent from net/http/fs.go:
;; (defn ServeContent
;;   "ServeContent replies to the request using the content in the\nprovided ReadSeeker. The main benefit of ServeContent over io.Copy\nis that it handles Range requests properly, sets the MIME type, and\nhandles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,\nand If-Range requests.\n\nIf the response's Content-Type header is not set, ServeContent\nfirst tries to deduce the type from name's file extension and,\nif that fails, falls back to reading the first block of the content\nand passing it to DetectContentType.\nThe name is otherwise unused; in particular it can be empty and is\nnever sent in the response.\n\nIf modtime is not the zero time or Unix epoch, ServeContent\nincludes it in a Last-Modified header in the response. If the\nrequest includes an If-Modified-Since header, ServeContent uses\nmodtime to decide whether the content needs to be sent at all.\n\nThe content's Seek method must work: ServeContent uses\na seek to the end of the content to determine its size.\n\nIf the caller has set w's ETag header formatted per RFC 7232, section 2.3,\nServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.\n\nNote that *os.File implements the io.ReadSeeker interface.\n\nGo input arguments: (w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) req, ^String name, ^go.std.time/Time modtime, ^go.std.io/ReadSeeker content]"
;;   {:added "1.0"
;;    :go "__serveContent(*_w, _req, _name, *_modtime, *_content)"}
;;   [^http/ResponseWriter _w, ^http/Request _req, ^String _name, ^time/Time _modtime, ^io/ReadSeeker _content])

JOKER FUNC net/http.ServeFile from net/http/fs.go:
;; (defn ServeFile
;;   "ServeFile replies to the request with the contents of the named\nfile or directory.\n\nIf the provided file or directory name is a relative path, it is\ninterpreted relative to the current directory and may ascend to\nparent directories. If the provided name is constructed from user\ninput, it should be sanitized before calling ServeFile.\n\nAs a precaution, ServeFile will reject requests where r.URL.Path\ncontains a \"..\" path element; this protects against callers who\nmight unsafely use filepath.Join on r.URL.Path without sanitizing\nit and then use that filepath.Join result as the name argument.\n\nAs another special case, ServeFile redirects any request where r.URL.Path\nends in \"/index.html\" to the same path, without the final\n\"index.html\". To avoid such redirects either modify the path or\nuse ServeContent.\n\nOutside of those two special cases, ServeFile does not use\nr.URL.Path for selecting the file or directory to serve; only the\nfile or directory provided in the name argument is used.\n\nGo input arguments: (w ResponseWriter, r *Request, name string)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r, ^String name]"
;;   {:added "1.0"
;;    :go "__serveFile(*_w, _r, _name)"}
;;   [^http/ResponseWriter _w, ^http/Request _r, ^String _name])

JOKER FUNC net/http.ServeTLS from net/http/server.go:
;; (defn ^"Error" ServeTLS
;;   "ServeTLS accepts incoming HTTPS connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nAdditionally, files containing a certificate and matching private key\nfor the server must be provided. If the certificate is signed by a\ncertificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nServeTLS always returns a non-nil error.\n\nGo input arguments: (l net.Listener, handler Handler, certFile string, keyFile string)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler, ^String certFile, ^String keyFile]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.ServeTLS(*_l, *_handler, _certFile, _keyFile)"}
;;   [^net/Listener _l, ^http/Handler _handler, ^String _certFile, ^String _keyFile])

JOKER FUNC net/http.SetCookie from net/http/cookie.go:
;; (defn SetCookie
;;   "SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.\nThe provided cookie must have a valid Name. Invalid cookies may be\nsilently dropped.\n\nGo input arguments: (w ResponseWriter, cookie *Cookie)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Cookie) cookie]"
;;   {:added "1.0"
;;    :go "__setCookie(*_w, _cookie)"}
;;   [^http/ResponseWriter _w, ^http/Cookie _cookie])

JOKER FUNC net/http.StatusText from net/http/status.go:
(defn ^"String" StatusText
  "StatusText returns a text for the HTTP status code. It returns the empty\nstring if the code is unknown.\n\nGo input arguments: (code int)\n\nGo return type: string\n\nJoker input arguments: [^Int code]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.StatusText(_code)"}
  [^Int _code])

JOKER FUNC net/http.StripPrefix from net/http/server.go:
(defn StripPrefix
  "StripPrefix returns a handler that serves HTTP requests\nby removing the given prefix from the request URL's Path\nand invoking the handler h. StripPrefix handles a\nrequest for a path that doesn't begin with prefix by\nreplying with an HTTP 404 not found error.\n\nGo input arguments: (prefix string, h Handler)\n\nGo return type: Handler\n\nJoker input arguments: [^String prefix, ^go.std.net.http/Handler h]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__stripPrefix(_prefix, *_h)"}
  [^String _prefix, ^http/Handler _h])

JOKER FUNC net/http.TimeoutHandler from net/http/server.go:
;; (defn TimeoutHandler
;;   "TimeoutHandler returns a Handler that runs h with the given time limit.\n\nThe new Handler calls h.ServeHTTP to handle each request, but if a\ncall runs for longer than its time limit, the handler responds with\na 503 Service Unavailable error and the given message in its body.\n(If msg is empty, a suitable default message will be sent.)\nAfter such a timeout, writes by h to its ResponseWriter will return\nErrHandlerTimeout.\n\nTimeoutHandler buffers all Handler writes to memory and does not\nsupport the Hijacker or Flusher interfaces.\n\nGo input arguments: (h Handler, dt time.Duration, msg string)\n\nGo return type: Handler\n\nJoker input arguments: [^go.std.net.http/Handler h, ^go.std.time/Duration dt, ^String msg]\n\nJoker return type: go.std.net.http/Handler"
;;   {:added "1.0"
;;    :go "__timeoutHandler(*_h, *_dt, _msg)"}
;;   [^http/Handler _h, ^time/Duration _dt, ^String _msg])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net/http"]
    :doc "Provides a low-level interface to the net/http package."
    :empty false}
  go.std.net.http)
JOKER TYPE net/http/cgi.Handler from net/http/cgi/host.go:
(defn ^"GoObject" Handler.
  "Constructor for cgi.Handler"
  {:added "1.0"
   :go "_ConstructHandler(_v)"}
  [^Object _v])

JOKER FUNC net/http/cgi.Request from net/http/cgi/child.go:
(defn Request
  "Request returns the HTTP request as represented in the current\nenvironment. This assumes the current program is being run\nby a web server in a CGI environment.\nThe returned Request's Body is populated, if applicable.\n\nGo return type: (*net/http.Request, error)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
  {:added "1.0"
   :go "__request()"}
  [])

JOKER FUNC net/http/cgi.RequestFromMap from net/http/cgi/child.go:
;; (defn RequestFromMap
;;   "RequestFromMap creates an http.Request from CGI variables.\nThe returned Request's Body field is not populated.\n\nGo input arguments: (params map[])\n\nGo return type: (*net/http.Request, error)\n\nJoker input arguments: [^{} params]\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
;;   {:added "1.0"
;;    :go "__requestFromMap(ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa()))"}
;;   [^{} _params])

JOKER FUNC net/http/cgi.Serve from net/http/cgi/child.go:
;; (defn ^"Error" Serve
;;   "Serve executes the provided Handler on the currently active CGI\nrequest, if any. If there's no current CGI environment\nan error is returned. The provided handler may be nil to use\nhttp.DefaultServeMux.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "cgi.Serve(*_handler)"}
;;   [^http/Handler _handler])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/http/cgi package."
    :empty false}
  go.std.net.http.cgi)
JOKER TYPE net/http/cookiejar.Jar from net/http/cookiejar/jar.go:
(defn ^"GoObject" Jar.
  "Constructor for cookiejar.Jar"
  {:added "1.0"
   :go "_ConstructJar(_v)"}
  [^Object _v])

JOKER TYPE net/http/cookiejar.Options from net/http/cookiejar/jar.go:
(defn ^"GoObject" Options.
  "Constructor for cookiejar.Options"
  {:added "1.0"
   :go "_ConstructOptions(_v)"}
  [^Object _v])

JOKER TYPE net/http/cookiejar.PublicSuffixList from net/http/cookiejar/jar.go:
;; (defn ^"GoObject" PublicSuffixList.
;;   "Constructor for cookiejar.PublicSuffixList"
;;   {:added "1.0"
;;    :go "_ConstructPublicSuffixList(_v)"}
;;   [^Object _v])

JOKER FUNC net/http/cookiejar.New from net/http/cookiejar/jar.go:
(defn New
  "New returns a new cookie jar. A nil *Options is equivalent to a zero\nOptions.\n\nGo input arguments: (o *Options)\n\nGo return type: (*Jar, error)\n\nJoker input arguments: [^(atom-of go.std.net.http.cookiejar/Options) o]\n\nJoker return type: [(atom-of go.std.net.http.cookiejar/Jar) Error]"
  {:added "1.0"
   :go "__new(_o)"}
  [^cookiejar/Options _o])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/http/cookiejar package."
    :empty false}
  go.std.net.http.cookiejar)
JOKER FUNC net/http/fcgi.ProcessEnv from net/http/fcgi/child.go:
;; (defn ProcessEnv
;;   "ProcessEnv returns FastCGI environment variables associated with the request r\nfor which no effort was made to be included in the request itself - the data\nis hidden in the request's context. As an example, if REMOTE_USER is set for a\nrequest, it will not be found anywhere in r, but it will be included in\nProcessEnv's response (via r's context).\n\nGo input arguments: (r *http.Request)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) r]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.MapType at: /usr/local/go-1.11.5/src/net/http/fcgi/child.go:358:34)"
;;   {:added "1.0"
;;    :go "__processEnv(_r)"}
;;   [^http/Request _r])

JOKER FUNC net/http/fcgi.Serve from net/http/fcgi/child.go:
;; (defn ^"Error" Serve
;;   "Serve accepts incoming FastCGI connections on the listener l, creating a new\ngoroutine for each. The goroutine reads requests and then calls handler\nto reply to them.\nIf l is nil, Serve accepts connections from os.Stdin.\nIf handler is nil, http.DefaultServeMux is used.\n\nGo input arguments: (l net.Listener, handler http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "fcgi.Serve(*_l, *_handler)"}
;;   [^net/Listener _l, ^http/Handler _handler])

JOKER TYPE net/http/httptest.ResponseRecorder from net/http/httptest/recorder.go:
(defn ^"GoObject" ResponseRecorder.
  "Constructor for httptest.ResponseRecorder"
  {:added "1.0"
   :go "_ConstructResponseRecorder(_v)"}
  [^Object _v])

JOKER TYPE net/http/httptest.Server from net/http/httptest/server.go:
(defn ^"GoObject" Server.
  "Constructor for httptest.Server"
  {:added "1.0"
   :go "_ConstructServer(_v)"}
  [^Object _v])

JOKER FUNC net/http/httptest.NewRecorder from net/http/httptest/recorder.go:
(defn NewRecorder
  "NewRecorder returns an initialized ResponseRecorder.\n\nGo return type: *ResponseRecorder\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.net.http.httptest/ResponseRecorder)"
  {:added "1.0"
   :go "__newRecorder()"}
  [])

JOKER FUNC net/http/httptest.NewRequest from net/http/httptest/httptest.go:
;; (defn NewRequest
;;   "NewRequest returns a new incoming server Request, suitable\nfor passing to an http.Handler for testing.\n\nThe target is the RFC 7230 \"request-target\": it may be either a\npath or an absolute URL. If target is an absolute URL, the host name\nfrom the URL is used. Otherwise, \"example.com\" is used.\n\nThe TLS field is set to a non-nil dummy value if target has scheme\n\"https\".\n\nThe Request.Proto is always HTTP/1.1.\n\nAn empty method means \"GET\".\n\nThe provided body may be nil. If the body is of type *bytes.Reader,\n*strings.Reader, or *bytes.Buffer, the Request.ContentLength is\nset.\n\nNewRequest panics on error for ease of use in testing, where a\npanic is acceptable.\n\nTo generate a client HTTP request instead of a server request, see\nthe NewRequest function in the net/http package.\n\nGo input arguments: (method string, target string, body io.Reader)\n\nGo return type: *net/http.Request\n\nJoker input arguments: [^String method, ^String target, ^go.std.io/Reader body]\n\nJoker return type: (atom-of go.std.net.http/Request)"
;;   {:added "1.0"
;;    :go "__newRequest(_method, _target, *_body)"}
;;   [^String _method, ^String _target, ^io/Reader _body])

JOKER FUNC net/http/httptest.NewServer from net/http/httptest/server.go:
;; (defn NewServer
;;   "NewServer starts and returns a new Server.\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: (atom-of go.std.net.http.httptest/Server)"
;;   {:added "1.0"
;;    :go "__newServer(*_handler)"}
;;   [^http/Handler _handler])

JOKER FUNC net/http/httptest.NewTLSServer from net/http/httptest/server.go:
;; (defn NewTLSServer
;;   "NewTLSServer starts and returns a new Server using TLS.\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: (atom-of go.std.net.http.httptest/Server)"
;;   {:added "1.0"
;;    :go "__newTLSServer(*_handler)"}
;;   [^http/Handler _handler])

JOKER FUNC net/http/httptest.NewUnstartedServer from net/http/httptest/server.go:
;; (defn NewUnstartedServer
;;   "NewUnstartedServer returns a new Server but doesn't start it.\n\nAfter changing its configuration, the caller should call Start or\nStartTLS.\n\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: (atom-of go.std.net.http.httptest/Server)"
;;   {:added "1.0"
;;    :go "__newUnstartedServer(*_handler)"}
;;   [^http/Handler _handler])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/http/httptest package."
    :empty false}
  go.std.net.http.httptest)
JOKER FUNC net/http/httptrace.ContextClientTrace from net/http/httptrace/trace.go:
;; (defn ContextClientTrace
;;   "ContextClientTrace returns the ClientTrace associated with the\nprovided context. If none, it returns nil.\n\nGo input arguments: (ctx context.Context)\n\nGo return type: *ClientTrace\n\nJoker input arguments: [^go.std.context/Context ctx]\n\nJoker return type: (atom-of go.std.net.http.httptrace/ClientTrace)"
;;   {:added "1.0"
;;    :go "__contextClientTrace(*_ctx)"}
;;   [^context/Context _ctx])

JOKER FUNC net/http/httptrace.WithClientTrace from net/http/httptrace/trace.go:
;; (defn WithClientTrace
;;   "WithClientTrace returns a new context based on the provided parent\nctx. HTTP client requests made with the returned context will use\nthe provided trace hooks, in addition to any previous hooks\nregistered with ctx. Any hooks defined in the provided trace will\nbe called first.\n\nGo input arguments: (ctx context.Context, trace *ClientTrace)\n\nGo return type: context.Context\n\nJoker input arguments: [^go.std.context/Context ctx, ^(atom-of go.std.net.http.httptrace/ClientTrace) trace]\n\nJoker return type: go.std.context/Context"
;;   {:added "1.0"
;;    :go "__withClientTrace(*_ctx, _trace)"}
;;   [^context/Context _ctx, ^httptrace/ClientTrace _trace])

JOKER FUNC net/http/httputil.DumpRequest from net/http/httputil/dump.go:
;; (defn DumpRequest
;;   "DumpRequest returns the given request in its HTTP/1.x wire\nrepresentation. It should only be used by servers to debug client\nrequests. The returned representation is an approximation only;\nsome details of the initial request are lost while parsing it into\nan http.Request. In particular, the order and case of header field\nnames are lost. The order of values in multi-valued headers is kept\nintact. HTTP/2 requests are dumped in HTTP/1.x form, not in their\noriginal binary representations.\n\nIf body is true, DumpRequest also returns the body. To do so, it\nconsumes req.Body and then replaces it with a new io.ReadCloser\nthat yields the same bytes. If DumpRequest returns an error,\nthe state of req is undefined.\n\nThe documentation for http.Request.Write details which fields\nof req are included in the dump.\n\nGo input arguments: (req *http.Request, body bool)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req, ^Boolean body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__dumpRequest(_req, _body)"}
;;   [^http/Request _req, ^Boolean _body])

JOKER FUNC net/http/httputil.DumpRequestOut from net/http/httputil/dump.go:
;; (defn DumpRequestOut
;;   "DumpRequestOut is like DumpRequest but for outgoing client requests. It\nincludes any headers that the standard http.Transport adds, such as\nUser-Agent.\n\nGo input arguments: (req *http.Request, body bool)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req, ^Boolean body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__dumpRequestOut(_req, _body)"}
;;   [^http/Request _req, ^Boolean _body])

JOKER FUNC net/http/httputil.DumpResponse from net/http/httputil/dump.go:
;; (defn DumpResponse
;;   "DumpResponse is like DumpRequest but dumps a response.\n\nGo input arguments: (resp *http.Response, body bool)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Response) resp, ^Boolean body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__dumpResponse(_resp, _body)"}
;;   [^http/Response _resp, ^Boolean _body])

JOKER FUNC net/http/httputil.NewChunkedReader from net/http/httputil/httputil.go:
;; (defn NewChunkedReader
;;   "NewChunkedReader returns a new chunkedReader that translates the data read from r\nout of HTTP \"chunked\" format before returning it.\nThe chunkedReader returns io.EOF when the final 0-length chunk is read.\n\nNewChunkedReader is not needed by normal applications. The http package\nautomatically decodes chunking when reading response bodies.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__newChunkedReader(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC net/http/httputil.NewChunkedWriter from net/http/httputil/httputil.go:
;; (defn NewChunkedWriter
;;   "NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP\n\"chunked\" format before writing them to w. Closing the returned chunkedWriter\nsends the final 0-length chunk that marks the end of the stream but does\nnot send the final CRLF that appears after trailers; trailers and the last\nCRLF must be written separately.\n\nNewChunkedWriter is not needed by normal applications. The http\npackage adds chunking automatically if handlers don't set a\nContent-Length header. Using NewChunkedWriter inside a handler\nwould result in double chunking or chunking with a Content-Length\nlength, both of which are wrong.\n\nGo input arguments: (w io.Writer)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "__newChunkedWriter(*_w)"}
;;   [^io/Writer _w])

JOKER FUNC net/http/httputil.NewClientConn from net/http/httputil/persist.go:
;; (defn NewClientConn
;;   "NewClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo input arguments: (c net.Conn, r *bufio.Reader)\n\nGo return type: *ClientConn\n\nJoker input arguments: [^go.std.net/Conn c, ^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.http.httputil/ClientConn)"
;;   {:added "1.0"
;;    :go "__newClientConn(*_c, _r)"}
;;   [^net/Conn _c, ^bufio/Reader _r])

JOKER FUNC net/http/httputil.NewProxyClientConn from net/http/httputil/persist.go:
;; (defn NewProxyClientConn
;;   "NewProxyClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo input arguments: (c net.Conn, r *bufio.Reader)\n\nGo return type: *ClientConn\n\nJoker input arguments: [^go.std.net/Conn c, ^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.http.httputil/ClientConn)"
;;   {:added "1.0"
;;    :go "__newProxyClientConn(*_c, _r)"}
;;   [^net/Conn _c, ^bufio/Reader _r])

JOKER FUNC net/http/httputil.NewServerConn from net/http/httputil/persist.go:
;; (defn NewServerConn
;;   "NewServerConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Server in package net/http instead.\n\nGo input arguments: (c net.Conn, r *bufio.Reader)\n\nGo return type: *ServerConn\n\nJoker input arguments: [^go.std.net/Conn c, ^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.http.httputil/ServerConn)"
;;   {:added "1.0"
;;    :go "__newServerConn(*_c, _r)"}
;;   [^net/Conn _c, ^bufio/Reader _r])

JOKER FUNC net/http/httputil.NewSingleHostReverseProxy from net/http/httputil/reverseproxy.go:
;; (defn NewSingleHostReverseProxy
;;   "NewSingleHostReverseProxy returns a new ReverseProxy that routes\nURLs to the scheme, host, and base path provided in target. If the\ntarget's path is \"/base\" and the incoming request was for \"/dir\",\nthe target request will be for /base/dir.\nNewSingleHostReverseProxy does not rewrite the Host header.\nTo rewrite Host headers, use ReverseProxy directly with a custom\nDirector policy.\n\nGo input arguments: (target *url.URL)\n\nGo return type: *ReverseProxy\n\nJoker input arguments: [^(atom-of go.std.net.url/URL) target]\n\nJoker return type: (atom-of go.std.net.http.httputil/ReverseProxy)"
;;   {:added "1.0"
;;    :go "__newSingleHostReverseProxy(_target)"}
;;   [^url/URL _target])

JOKER FUNC net/http/pprof.Cmdline from net/http/pprof/pprof.go:
;; (defn Cmdline
;;   "Cmdline responds with the running program's\ncommand line, with arguments separated by NUL bytes.\nThe package initialization registers it as /debug/pprof/cmdline.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__cmdline(*_w, _r)"}
;;   [^http/ResponseWriter _w, ^http/Request _r])

JOKER FUNC net/http/pprof.Handler from net/http/pprof/pprof.go:
(defn Handler
  "Handler returns an HTTP handler that serves the named profile.\n\nGo input arguments: (name string)\n\nGo return type: net/http.Handler\n\nJoker input arguments: [^String name]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__handler(_name)"}
  [^String _name])

JOKER FUNC net/http/pprof.Index from net/http/pprof/pprof.go:
;; (defn Index
;;   "Index responds with the pprof-formatted profile named by the request.\nFor example, \"/debug/pprof/heap\" serves the \"heap\" profile.\nIndex responds to a request for \"/debug/pprof/\" with an HTML page\nlisting the available profiles.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__index(*_w, _r)"}
;;   [^http/ResponseWriter _w, ^http/Request _r])

JOKER FUNC net/http/pprof.Profile from net/http/pprof/pprof.go:
;; (defn Profile
;;   "Profile responds with the pprof-formatted cpu profile.\nProfiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.\nThe package initialization registers it as /debug/pprof/profile.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__profile(*_w, _r)"}
;;   [^http/ResponseWriter _w, ^http/Request _r])

JOKER FUNC net/http/pprof.Symbol from net/http/pprof/pprof.go:
;; (defn Symbol
;;   "Symbol looks up the program counters listed in the request,\nresponding with a table mapping program counters to function names.\nThe package initialization registers it as /debug/pprof/symbol.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__symbol(*_w, _r)"}
;;   [^http/ResponseWriter _w, ^http/Request _r])

JOKER FUNC net/http/pprof.Trace from net/http/pprof/pprof.go:
;; (defn Trace
;;   "Trace responds with the execution trace in binary form.\nTracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.\nThe package initialization registers it as /debug/pprof/trace.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__trace(*_w, _r)"}
;;   [^http/ResponseWriter _w, ^http/Request _r])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/http/pprof package."
    :empty false}
  go.std.net.http.pprof)
JOKER TYPE net/mail.Address from net/mail/message.go:
(defn ^"GoObject" Address.
  "Constructor for mail.Address"
  {:added "1.0"
   :go "_ConstructAddress(_v)"}
  [^Object _v])

JOKER TYPE net/mail.AddressParser from net/mail/message.go:
(defn ^"GoObject" AddressParser.
  "Constructor for mail.AddressParser"
  {:added "1.0"
   :go "_ConstructAddressParser(_v)"}
  [^Object _v])

JOKER TYPE net/mail.Header from net/mail/message.go:
;; (defn ^"GoObject" Header.
;;   "Constructor for mail.Header"
;;   {:added "1.0"
;;    :go "_ConstructHeader(_v)"}
;;   [^Object _v])

JOKER TYPE net/mail.Message from net/mail/message.go:
(defn ^"GoObject" Message.
  "Constructor for mail.Message"
  {:added "1.0"
   :go "_ConstructMessage(_v)"}
  [^Object _v])

JOKER FUNC net/mail.ParseAddress from net/mail/message.go:
(defn ParseAddress
  "Parses a single RFC 5322 address, e.g. \"Barry Gibbs <bg@example.com>\"\n\nGo input arguments: (address string)\n\nGo return type: (*Address, error)\n\nJoker input arguments: [^String address]\n\nJoker return type: [(atom-of go.std.net.mail/Address) Error]"
  {:added "1.0"
   :go "__parseAddress(_address)"}
  [^String _address])

JOKER FUNC net/mail.ParseAddressList from net/mail/message.go:
(defn ParseAddressList
  "ParseAddressList parses the given string as a list of addresses.\n\nGo input arguments: (list string)\n\nGo return type: ([]*Address, error)\n\nJoker input arguments: [^String list]\n\nJoker return type: [(vector-of (atom-of go.std.net.mail/Address)) Error]"
  {:added "1.0"
   :go "__parseAddressList(_list)"}
  [^String _list])

JOKER FUNC net/mail.ParseDate from net/mail/message.go:
(defn ParseDate
  "ParseDate parses an RFC 5322 date string.\n\nGo input arguments: (date string)\n\nGo return type: (time.Time, error)\n\nJoker input arguments: [^String date]\n\nJoker return type: [go.std.time/Time Error]"
  {:added "1.0"
   :go "__parseDate(_date)"}
  [^String _date])

JOKER FUNC net/mail.ReadMessage from net/mail/message.go:
;; (defn ReadMessage
;;   "ReadMessage reads a message from r.\nThe headers are parsed, and the body of the message will be available\nfor reading from msg.Body.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (msg *Message, err error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [(atom-of go.std.net.mail/Message) Error]"
;;   {:added "1.0"
;;    :go "__readMessage(*_r)"}
;;   [^io/Reader _r])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/mail package."
    :empty false}
  go.std.net.mail)
JOKER TYPE net/rpc.Call from net/rpc/client.go:
(defn ^"GoObject" Call.
  "Constructor for rpc.Call"
  {:added "1.0"
   :go "_ConstructCall(_v)"}
  [^Object _v])

JOKER TYPE net/rpc.Client from net/rpc/client.go:
(defn ^"GoObject" Client.
  "Constructor for rpc.Client"
  {:added "1.0"
   :go "_ConstructClient(_v)"}
  [^Object _v])

JOKER TYPE net/rpc.ClientCodec from net/rpc/client.go:
;; (defn ^"GoObject" ClientCodec.
;;   "Constructor for rpc.ClientCodec"
;;   {:added "1.0"
;;    :go "_ConstructClientCodec(_v)"}
;;   [^Object _v])

JOKER TYPE net/rpc.Request from net/rpc/server.go:
(defn ^"GoObject" Request.
  "Constructor for rpc.Request"
  {:added "1.0"
   :go "_ConstructRequest(_v)"}
  [^Object _v])

JOKER TYPE net/rpc.Response from net/rpc/server.go:
(defn ^"GoObject" Response.
  "Constructor for rpc.Response"
  {:added "1.0"
   :go "_ConstructResponse(_v)"}
  [^Object _v])

JOKER TYPE net/rpc.Server from net/rpc/server.go:
(defn ^"GoObject" Server.
  "Constructor for rpc.Server"
  {:added "1.0"
   :go "_ConstructServer(_v)"}
  [^Object _v])

JOKER TYPE net/rpc.ServerCodec from net/rpc/server.go:
;; (defn ^"GoObject" ServerCodec.
;;   "Constructor for rpc.ServerCodec"
;;   {:added "1.0"
;;    :go "_ConstructServerCodec(_v)"}
;;   [^Object _v])

JOKER TYPE net/rpc.ServerError from net/rpc/client.go:
(defn ^"GoObject" ServerError.
  "Constructor for rpc.ServerError"
  {:added "1.0"
   :go "_ConstructServerError(_v)"}
  [^Object _v])

JOKER FUNC net/rpc.Accept from net/rpc/server.go:
;; (defn Accept
;;   "Accept accepts connections on the listener and serves requests\nto DefaultServer for each incoming connection.\nAccept blocks; the caller typically invokes it in a go statement.\n\nGo input arguments: (lis net.Listener)\n\nJoker input arguments: [^go.std.net/Listener lis]"
;;   {:added "1.0"
;;    :go "__accept(*_lis)"}
;;   [^net/Listener _lis])

JOKER FUNC net/rpc.Dial from net/rpc/client.go:
(defn Dial
  "Dial connects to an RPC server at the specified network address.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dial(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net/rpc.DialHTTP from net/rpc/client.go:
(defn DialHTTP
  "DialHTTP connects to an HTTP RPC server at the specified network address\nlistening on the default HTTP RPC path.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dialHTTP(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net/rpc.DialHTTPPath from net/rpc/client.go:
(defn DialHTTPPath
  "DialHTTPPath connects to an HTTP RPC server\nat the specified network address and path.\n\nGo input arguments: (network string, address string, path string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address, ^String path]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dialHTTPPath(_network, _address, _path)"}
  [^String _network, ^String _address, ^String _path])

JOKER FUNC net/rpc.HandleHTTP from net/rpc/server.go:
;; (defn HandleHTTP
;;   "HandleHTTP registers an HTTP handler for RPC messages to DefaultServer\non DefaultRPCPath and a debugging handler on DefaultDebugPath.\nIt is still necessary to invoke http.Serve(), typically in a go statement.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__handleHTTP()"}
;;   [])

JOKER FUNC net/rpc.NewClient from net/rpc/client.go:
;; (defn NewClient
;;   "NewClient returns a new Client to handle requests to the\nset of services at the other end of the connection.\nIt adds a buffer to the write side of the connection so\nthe header and payload are sent as a unit.\n\nThe read and write halves of the connection are serialized independently,\nso no interlocking is required. However each half may be accessed\nconcurrently so the implementation of conn should protect against\nconcurrent reads or concurrent writes.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *Client\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: (atom-of go.std.net.rpc/Client)"
;;   {:added "1.0"
;;    :go "__newClient(*_conn)"}
;;   [^io/ReadWriteCloser _conn])

JOKER FUNC net/rpc.NewClientWithCodec from net/rpc/client.go:
(defn NewClientWithCodec
  "NewClientWithCodec is like NewClient but uses the specified\ncodec to encode requests and decode responses.\n\nGo input arguments: (codec ClientCodec)\n\nGo return type: *Client\n\nJoker input arguments: [^go.std.net.rpc/ClientCodec codec]\n\nJoker return type: (atom-of go.std.net.rpc/Client)"
  {:added "1.0"
   :go "__newClientWithCodec(*_codec)"}
  [^rpc/ClientCodec _codec])

JOKER FUNC net/rpc.NewServer from net/rpc/server.go:
(defn NewServer
  "NewServer returns a new Server.\n\nGo return type: *Server\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.net.rpc/Server)"
  {:added "1.0"
   :go "__newServer()"}
  [])

JOKER FUNC net/rpc.Register from net/rpc/server.go:
;; (defn ^"Error" Register
;;   "Register publishes the receiver's methods in the DefaultServer.\n\nGo input arguments: (rcvr interface {})\n\nGo return type: error\n\nJoker input arguments: [^<protocol-or-something> rcvr]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.Register(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _rcvr])

JOKER FUNC net/rpc.RegisterName from net/rpc/server.go:
;; (defn ^"Error" RegisterName
;;   "RegisterName is like Register but uses the provided name for the type\ninstead of the receiver's concrete type.\n\nGo input arguments: (name string, rcvr interface {})\n\nGo return type: error\n\nJoker input arguments: [^String name, ^<protocol-or-something> rcvr]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.RegisterName(_name, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^String _name, ^<protocol-or-something> _rcvr])

JOKER FUNC net/rpc.ServeCodec from net/rpc/server.go:
;; (defn ServeCodec
;;   "ServeCodec is like ServeConn but uses the specified codec to\ndecode requests and encode responses.\n\nGo input arguments: (codec ServerCodec)\n\nJoker input arguments: [^go.std.net.rpc/ServerCodec codec]"
;;   {:added "1.0"
;;    :go "__serveCodec(*_codec)"}
;;   [^rpc/ServerCodec _codec])

JOKER FUNC net/rpc.ServeConn from net/rpc/server.go:
;; (defn ServeConn
;;   "ServeConn runs the DefaultServer on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\nServeConn uses the gob wire format (see package gob) on the\nconnection. To use an alternate codec, use ServeCodec.\nSee NewClient's comment for information about concurrent access.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]"
;;   {:added "1.0"
;;    :go "__serveConn(*_conn)"}
;;   [^io/ReadWriteCloser _conn])

JOKER FUNC net/rpc.ServeRequest from net/rpc/server.go:
(defn ^"Error" ServeRequest
  "ServeRequest is like ServeCodec but synchronously serves a single request.\nIt does not close the codec upon completion.\n\nGo input arguments: (codec ServerCodec)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net.rpc/ServerCodec codec]\n\nJoker return type: Error"
  {:added "1.0"
   :go "rpc.ServeRequest(*_codec)"}
  [^rpc/ServerCodec _codec])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net/rpc"]
    :doc "Provides a low-level interface to the net/rpc package."
    :empty false}
  go.std.net.rpc)
JOKER FUNC net/rpc/jsonrpc.Dial from net/rpc/jsonrpc/client.go:
(defn Dial
  "Dial connects to a JSON-RPC server at the specified network address.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*net/rpc.Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dial(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net/rpc/jsonrpc.NewClient from net/rpc/jsonrpc/client.go:
;; (defn NewClient
;;   "NewClient returns a new rpc.Client to handle requests to the\nset of services at the other end of the connection.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *net/rpc.Client\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: (atom-of go.std.net.rpc/Client)"
;;   {:added "1.0"
;;    :go "__newClient(*_conn)"}
;;   [^io/ReadWriteCloser _conn])

JOKER FUNC net/rpc/jsonrpc.NewClientCodec from net/rpc/jsonrpc/client.go:
;; (defn NewClientCodec
;;   "NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: net/rpc.ClientCodec\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: go.std.net.rpc/ClientCodec"
;;   {:added "1.0"
;;    :go "__newClientCodec(*_conn)"}
;;   [^io/ReadWriteCloser _conn])

JOKER FUNC net/rpc/jsonrpc.NewServerCodec from net/rpc/jsonrpc/server.go:
;; (defn NewServerCodec
;;   "NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: net/rpc.ServerCodec\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: go.std.net.rpc/ServerCodec"
;;   {:added "1.0"
;;    :go "__newServerCodec(*_conn)"}
;;   [^io/ReadWriteCloser _conn])

JOKER FUNC net/rpc/jsonrpc.ServeConn from net/rpc/jsonrpc/server.go:
;; (defn ServeConn
;;   "ServeConn runs the JSON-RPC server on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]"
;;   {:added "1.0"
;;    :go "__serveConn(*_conn)"}
;;   [^io/ReadWriteCloser _conn])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/rpc/jsonrpc package."
    :empty false}
  go.std.net.rpc.jsonrpc)
JOKER TYPE net/smtp.Auth from net/smtp/auth.go:
;; (defn ^"GoObject" Auth.
;;   "Constructor for smtp.Auth"
;;   {:added "1.0"
;;    :go "_ConstructAuth(_v)"}
;;   [^Object _v])

JOKER TYPE net/smtp.Client from net/smtp/smtp.go:
(defn ^"GoObject" Client.
  "Constructor for smtp.Client"
  {:added "1.0"
   :go "_ConstructClient(_v)"}
  [^Object _v])

JOKER TYPE net/smtp.ServerInfo from net/smtp/auth.go:
(defn ^"GoObject" ServerInfo.
  "Constructor for smtp.ServerInfo"
  {:added "1.0"
   :go "_ConstructServerInfo(_v)"}
  [^Object _v])

JOKER FUNC net/smtp.CRAMMD5Auth from net/smtp/auth.go:
(defn CRAMMD5Auth
  "CRAMMD5Auth returns an Auth that implements the CRAM-MD5 authentication\nmechanism as defined in RFC 2195.\nThe returned Auth uses the given username and secret to authenticate\nto the server using the challenge-response mechanism.\n\nGo input arguments: (username string, secret string)\n\nGo return type: Auth\n\nJoker input arguments: [^String username, ^String secret]\n\nJoker return type: go.std.net.smtp/Auth"
  {:added "1.0"
   :go "__cRAMMD5Auth(_username, _secret)"}
  [^String _username, ^String _secret])

JOKER FUNC net/smtp.Dial from net/smtp/smtp.go:
(defn Dial
  "Dial returns a new Client connected to an SMTP server at addr.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nGo input arguments: (addr string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String addr]\n\nJoker return type: [(atom-of go.std.net.smtp/Client) Error]"
  {:added "1.0"
   :go "__dial(_addr)"}
  [^String _addr])

JOKER FUNC net/smtp.NewClient from net/smtp/smtp.go:
;; (defn NewClient
;;   "NewClient returns a new Client using an existing connection and host as a\nserver name to be used when authenticating.\n\nGo input arguments: (conn net.Conn, host string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^go.std.net/Conn conn, ^String host]\n\nJoker return type: [(atom-of go.std.net.smtp/Client) Error]"
;;   {:added "1.0"
;;    :go "__newClient(*_conn, _host)"}
;;   [^net/Conn _conn, ^String _host])

JOKER FUNC net/smtp.PlainAuth from net/smtp/auth.go:
(defn PlainAuth
  "PlainAuth returns an Auth that implements the PLAIN authentication\nmechanism as defined in RFC 4616. The returned Auth uses the given\nusername and password to authenticate to host and act as identity.\nUsually identity should be the empty string, to act as username.\n\nPlainAuth will only send the credentials if the connection is using TLS\nor is connected to localhost. Otherwise authentication will fail with an\nerror, without sending the credentials.\n\nGo input arguments: (identity string, username string, password string, host string)\n\nGo return type: Auth\n\nJoker input arguments: [^String identity, ^String username, ^String password, ^String host]\n\nJoker return type: go.std.net.smtp/Auth"
  {:added "1.0"
   :go "__plainAuth(_identity, _username, _password, _host)"}
  [^String _identity, ^String _username, ^String _password, ^String _host])

JOKER FUNC net/smtp.SendMail from net/smtp/smtp.go:
;; (defn ^"Error" SendMail
;;   "SendMail connects to the server at addr, switches to TLS if\npossible, authenticates with the optional mechanism a if possible,\nand then sends an email from address from, to addresses to, with\nmessage msg.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nThe addresses in the to parameter are the SMTP RCPT addresses.\n\nThe msg parameter should be an RFC 822-style email with headers\nfirst, a blank line, and then the message body. The lines of msg\nshould be CRLF terminated. The msg headers should usually include\nfields such as \"From\", \"To\", \"Subject\", and \"Cc\".  Sending \"Bcc\"\nmessages is accomplished by including an email address in the to\nparameter but not including it in the msg headers.\n\nThe SendMail function and the net/smtp package are low-level\nmechanisms and provide no support for DKIM signing, MIME\nattachments (see the mime/multipart package), or other mail\nfunctionality. Higher-level packages exist outside of the standard\nlibrary.\n\nGo input arguments: (addr string, a Auth, from string, to []string, msg []byte)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^go.std.net.smtp/Auth a, ^String from, ^(vector-of String) to, ^(vector-of Byte) msg]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "smtp.SendMail(_addr, *_a, _from, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(_to)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_msg)))"}
;;   [^String _addr, ^smtp/Auth _a, ^String _from, ^Object _to, ^Object _msg])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/smtp package."
    :empty false}
  go.std.net.smtp)
JOKER TYPE net/textproto.Conn from net/textproto/textproto.go:
(defn ^"GoObject" Conn.
  "Constructor for textproto.Conn"
  {:added "1.0"
   :go "_ConstructConn(_v)"}
  [^Object _v])

JOKER TYPE net/textproto.Error from net/textproto/textproto.go:
(defn ^"GoObject" Error.
  "Constructor for textproto.Error"
  {:added "1.0"
   :go "_ConstructError(_v)"}
  [^Object _v])

JOKER TYPE net/textproto.MIMEHeader from net/textproto/header.go:
;; (defn ^"GoObject" MIMEHeader.
;;   "Constructor for textproto.MIMEHeader"
;;   {:added "1.0"
;;    :go "_ConstructMIMEHeader(_v)"}
;;   [^Object _v])

JOKER TYPE net/textproto.Pipeline from net/textproto/pipeline.go:
(defn ^"GoObject" Pipeline.
  "Constructor for textproto.Pipeline"
  {:added "1.0"
   :go "_ConstructPipeline(_v)"}
  [^Object _v])

JOKER TYPE net/textproto.ProtocolError from net/textproto/textproto.go:
(defn ^"GoObject" ProtocolError.
  "Constructor for textproto.ProtocolError"
  {:added "1.0"
   :go "_ConstructProtocolError(_v)"}
  [^Object _v])

JOKER TYPE net/textproto.Reader from net/textproto/reader.go:
(defn ^"GoObject" Reader.
  "Constructor for textproto.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER TYPE net/textproto.Writer from net/textproto/writer.go:
(defn ^"GoObject" Writer.
  "Constructor for textproto.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC net/textproto.CanonicalMIMEHeaderKey from net/textproto/reader.go:
(defn ^"String" CanonicalMIMEHeaderKey
  "CanonicalMIMEHeaderKey returns the canonical format of the\nMIME header key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nMIME header keys are assumed to be ASCII only.\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "textproto.CanonicalMIMEHeaderKey(_s)"}
  [^String _s])

JOKER FUNC net/textproto.Dial from net/textproto/textproto.go:
(defn Dial
  "Dial connects to the given address on the given network using net.Dial\nand then returns a new Conn for the connection.\n\nGo input arguments: (network string, addr string)\n\nGo return type: (*Conn, error)\n\nJoker input arguments: [^String network, ^String addr]\n\nJoker return type: [(atom-of go.std.net.textproto/Conn) Error]"
  {:added "1.0"
   :go "__dial(_network, _addr)"}
  [^String _network, ^String _addr])

JOKER FUNC net/textproto.NewConn from net/textproto/textproto.go:
;; (defn NewConn
;;   "NewConn returns a new Conn using conn for I/O.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *Conn\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: (atom-of go.std.net.textproto/Conn)"
;;   {:added "1.0"
;;    :go "__newConn(*_conn)"}
;;   [^io/ReadWriteCloser _conn])

JOKER FUNC net/textproto.NewReader from net/textproto/reader.go:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from r.\n\nTo avoid denial of service attacks, the provided bufio.Reader\nshould be reading from an io.LimitReader or similar Reader to bound\nthe size of responses.\n\nGo input arguments: (r *bufio.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.textproto/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(_r)"}
;;   [^bufio/Reader _r])

JOKER FUNC net/textproto.NewWriter from net/textproto/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer writing to w.\n\nGo input arguments: (w *bufio.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^(atom-of go.std.bufio/Writer) w]\n\nJoker return type: (atom-of go.std.net.textproto/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(_w)"}
;;   [^bufio/Writer _w])

JOKER FUNC net/textproto.TrimBytes from net/textproto/textproto.go:
;; (defn TrimBytes
;;   "TrimBytes returns b without leading and trailing ASCII space.\n\nGo input arguments: (b []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimBytes(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _b])

JOKER FUNC net/textproto.TrimString from net/textproto/textproto.go:
(defn ^"String" TrimString
  "TrimString returns s without leading and trailing ASCII space.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "textproto.TrimString(_s)"}
  [^String _s])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net/textproto"]
    :doc "Provides a low-level interface to the net/textproto package."
    :empty false}
  go.std.net.textproto)
JOKER TYPE net/url.Error from net/url/url.go:
(defn ^"GoObject" Error.
  "Constructor for url.Error"
  {:added "1.0"
   :go "_ConstructError(_v)"}
  [^Object _v])

JOKER TYPE net/url.EscapeError from net/url/url.go:
(defn ^"GoObject" EscapeError.
  "Constructor for url.EscapeError"
  {:added "1.0"
   :go "_ConstructEscapeError(_v)"}
  [^Object _v])

JOKER TYPE net/url.InvalidHostError from net/url/url.go:
(defn ^"GoObject" InvalidHostError.
  "Constructor for url.InvalidHostError"
  {:added "1.0"
   :go "_ConstructInvalidHostError(_v)"}
  [^Object _v])

JOKER TYPE net/url.URL from net/url/url.go:
(defn ^"GoObject" URL.
  "Constructor for url.URL"
  {:added "1.0"
   :go "_ConstructURL(_v)"}
  [^Object _v])

JOKER TYPE net/url.Userinfo from net/url/url.go:
(defn ^"GoObject" Userinfo.
  "Constructor for url.Userinfo"
  {:added "1.0"
   :go "_ConstructUserinfo(_v)"}
  [^Object _v])

JOKER TYPE net/url.Values from net/url/url.go:
;; (defn ^"GoObject" Values.
;;   "Constructor for url.Values"
;;   {:added "1.0"
;;    :go "_ConstructValues(_v)"}
;;   [^Object _v])

JOKER FUNC net/url.Parse from net/url/url.go:
(defn Parse
  "Parse parses rawurl into a URL structure.\n\nThe rawurl may be relative (a path, without a host) or absolute\n(starting with a scheme). Trying to parse a hostname and path\nwithout a scheme is invalid but may not necessarily return an\nerror, due to parsing ambiguities.\n\nGo input arguments: (rawurl string)\n\nGo return type: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker return type: [(atom-of go.std.net.url/URL) Error]"
  {:added "1.0"
   :go "__parse(_rawurl)"}
  [^String _rawurl])

JOKER FUNC net/url.ParseQuery from net/url/url.go:
(defn ParseQuery
  "ParseQuery parses the URL-encoded query string and returns\na map listing the values specified for each key.\nParseQuery always returns a non-nil map containing all the\nvalid query parameters found; err describes the first decoding error\nencountered, if any.\n\nQuery is expected to be a list of key=value settings separated by\nampersands or semicolons. A setting without an equals sign is\ninterpreted as a key set to an empty value.\n\nGo input arguments: (query string)\n\nGo return type: (Values, error)\n\nJoker input arguments: [^String query]\n\nJoker return type: [go.std.net.url/Values Error]"
  {:added "1.0"
   :go "__parseQuery(_query)"}
  [^String _query])

JOKER FUNC net/url.ParseRequestURI from net/url/url.go:
(defn ParseRequestURI
  "ParseRequestURI parses rawurl into a URL structure. It assumes that\nrawurl was received in an HTTP request, so the rawurl is interpreted\nonly as an absolute URI or an absolute path.\nThe string rawurl is assumed not to have a #fragment suffix.\n(Web browsers strip #fragment before sending the URL to a web server.)\n\nGo input arguments: (rawurl string)\n\nGo return type: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker return type: [(atom-of go.std.net.url/URL) Error]"
  {:added "1.0"
   :go "__parseRequestURI(_rawurl)"}
  [^String _rawurl])

JOKER FUNC net/url.PathEscape from net/url/url.go:
(defn ^"String" PathEscape
  "PathEscape escapes the string so it can be safely placed\ninside a URL path segment.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "url.PathEscape(_s)"}
  [^String _s])

JOKER FUNC net/url.PathUnescape from net/url/url.go:
(defn PathUnescape
  "PathUnescape does the inverse transformation of PathEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB. It returns an error if any % is not followed\nby two hexadecimal digits.\n\nPathUnescape is identical to QueryUnescape except that it does not\nunescape '+' to ' ' (space).\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__pathUnescape(_s)"}
  [^String _s])

JOKER FUNC net/url.QueryEscape from net/url/url.go:
(defn ^"String" QueryEscape
  "QueryEscape escapes the string so it can be safely placed\ninside a URL query.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "url.QueryEscape(_s)"}
  [^String _s])

JOKER FUNC net/url.QueryUnescape from net/url/url.go:
(defn QueryUnescape
  "QueryUnescape does the inverse transformation of QueryEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB.\nIt returns an error if any % is not followed by two hexadecimal\ndigits.\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__queryUnescape(_s)"}
  [^String _s])

JOKER FUNC net/url.User from net/url/url.go:
(defn User
  "User returns a Userinfo containing the provided username\nand no password set.\n\nGo input arguments: (username string)\n\nGo return type: *Userinfo\n\nJoker input arguments: [^String username]\n\nJoker return type: (atom-of go.std.net.url/Userinfo)"
  {:added "1.0"
   :go "__user(_username)"}
  [^String _username])

JOKER FUNC net/url.UserPassword from net/url/url.go:
(defn UserPassword
  "UserPassword returns a Userinfo containing the provided username\nand password.\n\nThis functionality should only be used with legacy web sites.\nRFC 2396 warns that interpreting Userinfo this way\n``is NOT RECOMMENDED, because the passing of authentication\ninformation in clear text (such as URI) has proven to be a\nsecurity risk in almost every case where it has been used.''\n\nGo input arguments: (username string, password string)\n\nGo return type: *Userinfo\n\nJoker input arguments: [^String username, ^String password]\n\nJoker return type: (atom-of go.std.net.url/Userinfo)"
  {:added "1.0"
   :go "__userPassword(_username, _password)"}
  [^String _username, ^String _password])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net/url"]
    :doc "Provides a low-level interface to the net/url package."
    :empty false}
  go.std.net.url)
JOKER TYPE os.File from os/types.go:
(defn ^"GoObject" File.
  "Constructor for os.File"
  {:added "1.0"
   :go "_ConstructFile(_v)"}
  [^Object _v])

JOKER TYPE os.FileInfo from os/types.go:
;; (defn ^"GoObject" FileInfo.
;;   "Constructor for os.FileInfo"
;;   {:added "1.0"
;;    :go "_ConstructFileInfo(_v)"}
;;   [^Object _v])

JOKER TYPE os.FileMode from os/types.go:
(defn ^"GoObject" FileMode.
  "Constructor for os.FileMode"
  {:added "1.0"
   :go "_ConstructFileMode(_v)"}
  [^Object _v])

JOKER TYPE os.LinkError from os/file.go:
(defn ^"GoObject" LinkError.
  "Constructor for os.LinkError"
  {:added "1.0"
   :go "_ConstructLinkError(_v)"}
  [^Object _v])

JOKER TYPE os.PathError from os/error.go:
(defn ^"GoObject" PathError.
  "Constructor for os.PathError"
  {:added "1.0"
   :go "_ConstructPathError(_v)"}
  [^Object _v])

JOKER TYPE os.ProcAttr from os/exec.go:
(defn ^"GoObject" ProcAttr.
  "Constructor for os.ProcAttr"
  {:added "1.0"
   :go "_ConstructProcAttr(_v)"}
  [^Object _v])

JOKER TYPE os.Process from os/exec.go:
(defn ^"GoObject" Process.
  "Constructor for os.Process"
  {:added "1.0"
   :go "_ConstructProcess(_v)"}
  [^Object _v])

JOKER TYPE os.ProcessState from os/exec_posix.go:
(defn ^"GoObject" ProcessState.
  "Constructor for os.ProcessState"
  {:added "1.0"
   :go "_ConstructProcessState(_v)"}
  [^Object _v])

JOKER TYPE os.Signal from os/exec.go:
;; (defn ^"GoObject" Signal.
;;   "Constructor for os.Signal"
;;   {:added "1.0"
;;    :go "_ConstructSignal(_v)"}
;;   [^Object _v])

JOKER TYPE os.SyscallError from os/error.go:
(defn ^"GoObject" SyscallError.
  "Constructor for os.SyscallError"
  {:added "1.0"
   :go "_ConstructSyscallError(_v)"}
  [^Object _v])

JOKER FUNC os.Chdir from os/file.go:
(defn ^"Error" Chdir
  "Chdir changes the current working directory to the named directory.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (dir string)\n\nGo return type: error\n\nJoker input arguments: [^String dir]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Chdir(_dir)"}
  [^String _dir])

JOKER FUNC os.Chmod from os/file.go:
(defn ^"Error" Chmod
  "Chmod changes the mode of the named file to mode.\nIf the file is a symbolic link, it changes the mode of the link's target.\nIf there is an error, it will be of type *PathError.\n\nA different subset of the mode bits are used, depending on the\noperating system.\n\nOn Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and\nModeSticky are used.\n\nOn Windows, the mode must be non-zero but otherwise only the 0200\nbit (owner writable) of mode is used; it controls whether the\nfile's read-only attribute is set or cleared. attribute. The other\nbits are currently unused. Use mode 0400 for a read-only file and\n0600 for a readable+writable file.\n\nOn Plan 9, the mode's permission bits, ModeAppend, ModeExclusive,\nand ModeTemporary are used.\n\nGo input arguments: (name string, mode FileMode)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^go.std.os/FileMode mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Chmod(_name, *_mode)"}
  [^String _name, ^os/FileMode _mode])

JOKER FUNC os.Chown from os/file_posix.go:
(defn ^"Error" Chown
  "Chown changes the numeric uid and gid of the named file.\nIf the file is a symbolic link, it changes the uid and gid of the link's target.\nA uid or gid of -1 means to not change that value.\nIf there is an error, it will be of type *PathError.\n\nOn Windows or Plan 9, Chown always returns the syscall.EWINDOWS or\nEPLAN9 error, wrapped in *PathError.\n\nGo input arguments: (name string, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Chown(_name, _uid, _gid)"}
  [^String _name, ^Int _uid, ^Int _gid])

JOKER FUNC os.Chtimes from os/file_posix.go:
;; (defn ^"Error" Chtimes
;;   "Chtimes changes the access and modification times of the named\nfile, similar to the Unix utime() or utimes() functions.\n\nThe underlying filesystem may truncate or round the values to a\nless precise time unit.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, atime time.Time, mtime time.Time)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^go.std.time/Time atime, ^go.std.time/Time mtime]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "os.Chtimes(_name, *_atime, *_mtime)"}
;;   [^String _name, ^time/Time _atime, ^time/Time _mtime])

JOKER FUNC os.Clearenv from os/env.go:
;; (defn Clearenv
;;   "Clearenv deletes all environment variables.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__clearenv()"}
;;   [])

JOKER FUNC os.Create from os/file.go:
(defn Create
  "Create creates the named file with mode 0666 (before umask), truncating\nit if it already exists. If successful, methods on the returned\nFile can be used for I/O; the associated file descriptor has mode\nO_RDWR.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.os/File) Error]"
  {:added "1.0"
   :go "__create(_name)"}
  [^String _name])

JOKER FUNC os.Environ from os/env.go:
(defn Environ
  "Environ returns a copy of strings representing the environment,\nin the form \"key=value\".\n\nGo return type: []string\n\nJoker input arguments: []\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__environ()"}
  [])

JOKER FUNC os.Executable from os/executable.go:
(defn Executable
  "Executable returns the path name for the executable that started\nthe current process. There is no guarantee that the path is still\npointing to the correct executable. If a symlink was used to start\nthe process, depending on the operating system, the result might\nbe the symlink or the path it pointed to. If a stable result is\nneeded, path/filepath.EvalSymlinks might help.\n\nExecutable returns an absolute path unless an error occurred.\n\nThe main use case is finding resources located relative to an\nexecutable.\n\nExecutable is not supported on nacl.\n\nGo return type: (string, error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__executable()"}
  [])

JOKER FUNC os.Exit from os/proc.go:
;; (defn Exit
;;   "Exit causes the current program to exit with the given status code.\nConventionally, code zero indicates success, non-zero an error.\nThe program terminates immediately; deferred functions are not run.\n\nGo input arguments: (code int)\n\nJoker input arguments: [^Int code]"
;;   {:added "1.0"
;;    :go "__exit(_code)"}
;;   [^Int _code])

JOKER FUNC os.Expand from os/env.go:
;; (defn ^"String" Expand
;;   "Expand replaces ${var} or $var in the string based on the mapping function.\nFor example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv).\n\nGo input arguments: (s string, mapping func)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^fn mapping]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "os.Expand(_s, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String _s, ^fn _mapping])

JOKER FUNC os.ExpandEnv from os/env.go:
(defn ^"String" ExpandEnv
  "ExpandEnv replaces ${var} or $var in the string according to the values\nof the current environment variables. References to undefined\nvariables are replaced by the empty string.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "os.ExpandEnv(_s)"}
  [^String _s])

JOKER FUNC os.FindProcess from os/exec.go:
(defn FindProcess
  "FindProcess looks for a running process by its pid.\n\nThe Process it returns can be used to obtain information\nabout the underlying operating system process.\n\nOn Unix systems, FindProcess always succeeds and returns a Process\nfor the given pid, regardless of whether the process exists.\n\nGo input arguments: (pid int)\n\nGo return type: (*Process, error)\n\nJoker input arguments: [^Int pid]\n\nJoker return type: [(atom-of go.std.os/Process) Error]"
  {:added "1.0"
   :go "__findProcess(_pid)"}
  [^Int _pid])

JOKER FUNC os.Getegid from os/proc.go:
(defn ^"Int" Getegid
  "Getegid returns the numeric effective group id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getegid()"}
  [])

JOKER FUNC os.Getenv from os/env.go:
(defn ^"String" Getenv
  "Getenv retrieves the value of the environment variable named by the key.\nIt returns the value, which will be empty if the variable is not present.\nTo distinguish between an empty value and an unset value, use LookupEnv.\n\nGo input arguments: (key string)\n\nGo return type: string\n\nJoker input arguments: [^String key]\n\nJoker return type: String"
  {:added "1.0"
   :go "os.Getenv(_key)"}
  [^String _key])

JOKER FUNC os.Geteuid from os/proc.go:
(defn ^"Int" Geteuid
  "Geteuid returns the numeric effective user id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Geteuid()"}
  [])

JOKER FUNC os.Getgid from os/proc.go:
(defn ^"Int" Getgid
  "Getgid returns the numeric group id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getgid()"}
  [])

JOKER FUNC os.Getgroups from os/proc.go:
(defn Getgroups
  "Getgroups returns a list of the numeric ids of groups that the caller belongs to.\n\nOn Windows, it returns syscall.EWINDOWS. See the os/user package\nfor a possible alternative.\n\nGo return type: ([]int, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__getgroups()"}
  [])

JOKER FUNC os.Getpagesize from os/types.go:
(defn ^"Int" Getpagesize
  "Getpagesize returns the underlying system's memory page size.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getpagesize()"}
  [])

JOKER FUNC os.Getpid from os/exec.go:
(defn ^"Int" Getpid
  "Getpid returns the process id of the caller.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getpid()"}
  [])

JOKER FUNC os.Getppid from os/exec.go:
(defn ^"Int" Getppid
  "Getppid returns the process id of the caller's parent.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getppid()"}
  [])

JOKER FUNC os.Getuid from os/proc.go:
(defn ^"Int" Getuid
  "Getuid returns the numeric user id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getuid()"}
  [])

JOKER FUNC os.Getwd from os/getwd.go:
(defn Getwd
  "Getwd returns a rooted path name corresponding to the\ncurrent directory. If the current directory can be\nreached via multiple paths (due to symbolic links),\nGetwd may return any one of them.\n\nGo return type: (dir string, err error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__getwd()"}
  [])

JOKER FUNC os.Hostname from os/sys.go:
(defn Hostname
  "Hostname returns the host name reported by the kernel.\n\nGo return type: (name string, err error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__hostname()"}
  [])

JOKER FUNC os.IsExist from os/error.go:
;; (defn ^"Boolean" IsExist
;;   "IsExist returns a boolean indicating whether the error is known to report\nthat a file or directory already exists. It is satisfied by ErrExist as\nwell as some syscall errors.\n\nGo input arguments: (err error)\n\nGo return type: bool\n\nJoker input arguments: [^ABEND885(pre.go: unrecognized type error at: /usr/local/go-1.11.5/src/os/error.go:68:18) err]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "os.IsExist(_err)"}
;;   [^ABEND885(pre.go: unrecognized type error at: /usr/local/go-1.11.5/src/os/error.go:68:18) _err])

JOKER FUNC os.IsNotExist from os/error.go:
;; (defn ^"Boolean" IsNotExist
;;   "IsNotExist returns a boolean indicating whether the error is known to\nreport that a file or directory does not exist. It is satisfied by\nErrNotExist as well as some syscall errors.\n\nGo input arguments: (err error)\n\nGo return type: bool\n\nJoker input arguments: [^ABEND885(pre.go: unrecognized type error at: /usr/local/go-1.11.5/src/os/error.go:75:21) err]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "os.IsNotExist(_err)"}
;;   [^ABEND885(pre.go: unrecognized type error at: /usr/local/go-1.11.5/src/os/error.go:75:21) _err])

JOKER FUNC os.IsPathSeparator from os/path_unix.go:
;; (defn ^"Boolean" IsPathSeparator
;;   "IsPathSeparator reports whether c is a directory separator character.\n\nGo input arguments: (c uint8)\n\nGo return type: bool\n\nJoker input arguments: [^uint8 c]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "os.IsPathSeparator(_c)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint8) _c])

JOKER FUNC os.IsPermission from os/error.go:
;; (defn ^"Boolean" IsPermission
;;   "IsPermission returns a boolean indicating whether the error is known to\nreport that permission is denied. It is satisfied by ErrPermission as well\nas some syscall errors.\n\nGo input arguments: (err error)\n\nGo return type: bool\n\nJoker input arguments: [^ABEND885(pre.go: unrecognized type error at: /usr/local/go-1.11.5/src/os/error.go:82:23) err]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "os.IsPermission(_err)"}
;;   [^ABEND885(pre.go: unrecognized type error at: /usr/local/go-1.11.5/src/os/error.go:82:23) _err])

JOKER FUNC os.IsTimeout from os/error.go:
;; (defn ^"Boolean" IsTimeout
;;   "IsTimeout returns a boolean indicating whether the error is known\nto report that a timeout occurred.\n\nGo input arguments: (err error)\n\nGo return type: bool\n\nJoker input arguments: [^ABEND885(pre.go: unrecognized type error at: /usr/local/go-1.11.5/src/os/error.go:88:20) err]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "os.IsTimeout(_err)"}
;;   [^ABEND885(pre.go: unrecognized type error at: /usr/local/go-1.11.5/src/os/error.go:88:20) _err])

JOKER FUNC os.Lchown from os/file_posix.go:
(defn ^"Error" Lchown
  "Lchown changes the numeric uid and gid of the named file.\nIf the file is a symbolic link, it changes the uid and gid of the link itself.\nIf there is an error, it will be of type *PathError.\n\nOn Windows, it always returns the syscall.EWINDOWS error, wrapped\nin *PathError.\n\nGo input arguments: (name string, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Lchown(_name, _uid, _gid)"}
  [^String _name, ^Int _uid, ^Int _gid])

JOKER FUNC os.Link from os/file_unix.go:
(defn ^"Error" Link
  "Link creates newname as a hard link to the oldname file.\nIf there is an error, it will be of type *LinkError.\n\nGo input arguments: (oldname string, newname string)\n\nGo return type: error\n\nJoker input arguments: [^String oldname, ^String newname]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Link(_oldname, _newname)"}
  [^String _oldname, ^String _newname])

JOKER FUNC os.LookupEnv from os/env.go:
(defn LookupEnv
  "LookupEnv retrieves the value of the environment variable named\nby the key. If the variable is present in the environment the\nvalue (which may be empty) is returned and the boolean is true.\nOtherwise the returned value will be empty and the boolean will\nbe false.\n\nGo input arguments: (key string)\n\nGo return type: (string, bool)\n\nJoker input arguments: [^String key]\n\nJoker return type: [String Boolean]"
  {:added "1.0"
   :go "__lookupEnv(_key)"}
  [^String _key])

JOKER FUNC os.Lstat from os/stat.go:
(defn Lstat
  "Lstat returns a FileInfo describing the named file.\nIf the file is a symbolic link, the returned FileInfo\ndescribes the symbolic link. Lstat makes no attempt to follow the link.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (FileInfo, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [go.std.os/FileInfo Error]"
  {:added "1.0"
   :go "__lstat(_name)"}
  [^String _name])

JOKER FUNC os.Mkdir from os/file.go:
(defn ^"Error" Mkdir
  "Mkdir creates a new directory with the specified name and permission\nbits (before umask).\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, perm FileMode)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^go.std.os/FileMode perm]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Mkdir(_name, *_perm)"}
  [^String _name, ^os/FileMode _perm])

JOKER FUNC os.MkdirAll from os/path.go:
(defn ^"Error" MkdirAll
  "MkdirAll creates a directory named path,\nalong with any necessary parents, and returns nil,\nor else returns an error.\nThe permission bits perm (before umask) are used for all\ndirectories that MkdirAll creates.\nIf path is already a directory, MkdirAll does nothing\nand returns nil.\n\nGo input arguments: (path string, perm FileMode)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^go.std.os/FileMode perm]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.MkdirAll(_path, *_perm)"}
  [^String _path, ^os/FileMode _perm])

JOKER FUNC os.NewFile from os/file_unix.go:
(defn NewFile
  "NewFile returns a new File with the given file descriptor and\nname. The returned value will be nil if fd is not a valid file\ndescriptor. On Unix systems, if the file descriptor is in\nnon-blocking mode, NewFile will attempt to return a pollable File\n(one for which the SetDeadline methods work).\n\nGo input arguments: (fd uintptr, name string)\n\nGo return type: *File\n\nJoker input arguments: [^UIntPtr fd, ^String name]\n\nJoker return type: (atom-of go.std.os/File)"
  {:added "1.0"
   :go "__newFile(_fd, _name)"}
  [^UIntPtr _fd, ^String _name])

JOKER FUNC os.NewSyscallError from os/error.go:
;; (defn ^"Error" NewSyscallError
;;   "NewSyscallError returns, as an error, a new SyscallError\nwith the given system call name and error details.\nAs a convenience, if err is nil, NewSyscallError returns nil.\n\nGo input arguments: (syscall string, err error)\n\nGo return type: error\n\nJoker input arguments: [^String syscall, ^ABEND885(pre.go: unrecognized type error at: /usr/local/go-1.11.5/src/os/error.go:58:42) err]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "os.NewSyscallError(_syscall, _err)"}
;;   [^String _syscall, ^ABEND885(pre.go: unrecognized type error at: /usr/local/go-1.11.5/src/os/error.go:58:42) _err])

JOKER FUNC os.Open from os/file.go:
(defn Open
  "Open opens the named file for reading. If successful, methods on\nthe returned file can be used for reading; the associated file\ndescriptor has mode O_RDONLY.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.os/File) Error]"
  {:added "1.0"
   :go "__open(_name)"}
  [^String _name])

JOKER FUNC os.OpenFile from os/file.go:
(defn OpenFile
  "OpenFile is the generalized open call; most users will use Open\nor Create instead. It opens the named file with specified flag\n(O_RDONLY etc.) and perm (before umask), if applicable. If successful,\nmethods on the returned File can be used for I/O.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, flag int, perm FileMode)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name, ^Int flag, ^go.std.os/FileMode perm]\n\nJoker return type: [(atom-of go.std.os/File) Error]"
  {:added "1.0"
   :go "__openFile(_name, _flag, *_perm)"}
  [^String _name, ^Int _flag, ^os/FileMode _perm])

JOKER FUNC os.Pipe from os/pipe_linux.go:
(defn Pipe
  "Pipe returns a connected pair of Files; reads from r return bytes written to w.\nIt returns the files and an error, if any.\n\nGo return type: (r *File, w *File, err error)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.os/File) (atom-of go.std.os/File) Error]"
  {:added "1.0"
   :go "__pipe()"}
  [])

JOKER FUNC os.Readlink from os/file_posix.go:
(defn Readlink
  "Readlink returns the destination of the named symbolic link.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__readlink(_name)"}
  [^String _name])

JOKER FUNC os.Remove from os/file_unix.go:
(defn ^"Error" Remove
  "Remove removes the named file or (empty) directory.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: error\n\nJoker input arguments: [^String name]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Remove(_name)"}
  [^String _name])

JOKER FUNC os.RemoveAll from os/path.go:
(defn ^"Error" RemoveAll
  "RemoveAll removes path and any children it contains.\nIt removes everything it can but returns the first error\nit encounters. If the path does not exist, RemoveAll\nreturns nil (no error).\n\nGo input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.RemoveAll(_path)"}
  [^String _path])

JOKER FUNC os.Rename from os/file.go:
(defn ^"Error" Rename
  "Rename renames (moves) oldpath to newpath.\nIf newpath already exists and is not a directory, Rename replaces it.\nOS-specific restrictions may apply when oldpath and newpath are in different directories.\nIf there is an error, it will be of type *LinkError.\n\nGo input arguments: (oldpath string, newpath string)\n\nGo return type: error\n\nJoker input arguments: [^String oldpath, ^String newpath]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Rename(_oldpath, _newpath)"}
  [^String _oldpath, ^String _newpath])

JOKER FUNC os.SameFile from os/types.go:
(defn ^"Boolean" SameFile
  "SameFile reports whether fi1 and fi2 describe the same file.\nFor example, on Unix this means that the device and inode fields\nof the two underlying structures are identical; on other systems\nthe decision may be based on the path names.\nSameFile only applies to results returned by this package's Stat.\nIt returns false in other cases.\n\nGo input arguments: (fi1 FileInfo, fi2 FileInfo)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.os/FileInfo fi1, ^go.std.os/FileInfo fi2]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "os.SameFile(*_fi1, *_fi2)"}
  [^os/FileInfo _fi1, ^os/FileInfo _fi2])

JOKER FUNC os.Setenv from os/env.go:
(defn ^"Error" Setenv
  "Setenv sets the value of the environment variable named by the key.\nIt returns an error, if any.\n\nGo input arguments: (key string, value string)\n\nGo return type: error\n\nJoker input arguments: [^String key, ^String value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Setenv(_key, _value)"}
  [^String _key, ^String _value])

JOKER FUNC os.StartProcess from os/exec.go:
;; (defn StartProcess
;;   "StartProcess starts a new process with the program, arguments and attributes\nspecified by name, argv and attr. The argv slice will become os.Args in the\nnew process, so it normally starts with the program name.\n\nIf the calling goroutine has locked the operating system thread\nwith runtime.LockOSThread and modified any inheritable OS-level\nthread state (for example, Linux or Plan 9 name spaces), the new\nprocess will inherit the caller's thread state.\n\nStartProcess is a low-level interface. The os/exec package provides\nhigher-level interfaces.\n\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, argv []string, attr *ProcAttr)\n\nGo return type: (*Process, error)\n\nJoker input arguments: [^String name, ^(vector-of String) argv, ^(atom-of go.std.os/ProcAttr) attr]\n\nJoker return type: [(atom-of go.std.os/Process) Error]"
;;   {:added "1.0"
;;    :go "__startProcess(_name, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(_argv)), _attr)"}
;;   [^String _name, ^Object _argv, ^os/ProcAttr _attr])

JOKER FUNC os.Stat from os/stat.go:
(defn Stat
  "Stat returns a FileInfo describing the named file.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (FileInfo, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [go.std.os/FileInfo Error]"
  {:added "1.0"
   :go "__stat(_name)"}
  [^String _name])

JOKER FUNC os.Symlink from os/file_unix.go:
(defn ^"Error" Symlink
  "Symlink creates newname as a symbolic link to oldname.\nIf there is an error, it will be of type *LinkError.\n\nGo input arguments: (oldname string, newname string)\n\nGo return type: error\n\nJoker input arguments: [^String oldname, ^String newname]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Symlink(_oldname, _newname)"}
  [^String _oldname, ^String _newname])

JOKER FUNC os.TempDir from os/file.go:
(defn ^"String" TempDir
  "TempDir returns the default directory to use for temporary files.\n\nOn Unix systems, it returns $TMPDIR if non-empty, else /tmp.\nOn Windows, it uses GetTempPath, returning the first non-empty\nvalue from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory.\nOn Plan 9, it returns /tmp.\n\nThe directory is neither guaranteed to exist nor have accessible\npermissions.\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "os.TempDir()"}
  [])

JOKER FUNC os.Truncate from os/file_unix.go:
(defn ^"Error" Truncate
  "Truncate changes the size of the named file.\nIf the file is a symbolic link, it changes the size of the link's target.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, size int64)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^Int64 size]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Truncate(_name, _size)"}
  [^String _name, ^Int64 _size])

JOKER FUNC os.Unsetenv from os/env.go:
(defn ^"Error" Unsetenv
  "Unsetenv unsets a single environment variable.\n\nGo input arguments: (key string)\n\nGo return type: error\n\nJoker input arguments: [^String key]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Unsetenv(_key)"}
  [^String _key])

JOKER FUNC os.UserCacheDir from os/file.go:
(defn UserCacheDir
  "UserCacheDir returns the default root directory to use for user-specific\ncached data. Users should create their own application-specific subdirectory\nwithin this one and use that.\n\nOn Unix systems, it returns $XDG_CACHE_HOME as specified by\nhttps://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html if\nnon-empty, else $HOME/.cache.\nOn Darwin, it returns $HOME/Library/Caches.\nOn Windows, it returns %LocalAppData%.\nOn Plan 9, it returns $home/lib/cache.\n\nIf the location cannot be determined (for example, $HOME is not defined),\nthen it will return an error.\n\nGo return type: (string, error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__userCacheDir()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["os"]
    :doc "Provides a low-level interface to the os package."
    :empty false}
  go.std.os)
JOKER TYPE os/exec.Cmd from os/exec/exec.go:
(defn ^"GoObject" Cmd.
  "Constructor for exec.Cmd"
  {:added "1.0"
   :go "_ConstructCmd(_v)"}
  [^Object _v])

JOKER TYPE os/exec.Error from os/exec/exec.go:
(defn ^"GoObject" Error.
  "Constructor for exec.Error"
  {:added "1.0"
   :go "_ConstructError(_v)"}
  [^Object _v])

JOKER TYPE os/exec.ExitError from os/exec/exec.go:
(defn ^"GoObject" ExitError.
  "Constructor for exec.ExitError"
  {:added "1.0"
   :go "_ConstructExitError(_v)"}
  [^Object _v])

JOKER FUNC os/exec.Command from os/exec/exec.go:
;; (defn Command
;;   "Command returns the Cmd struct to execute the named program with\nthe given arguments.\n\nIt sets only the Path and Args in the returned structure.\n\nIf name contains no path separators, Command uses LookPath to\nresolve name to a complete path if possible. Otherwise it uses name\ndirectly as Path.\n\nThe returned Cmd's Args field is constructed from the command name\nfollowed by the elements of arg, so arg should not include the\ncommand name itself. For example, Command(\"echo\", \"hello\").\nArgs[0] is always name, not the possibly resolved Path.\n\nGo input arguments: (name string, arg ...string)\n\nGo return type: *Cmd\n\nJoker input arguments: [^String name, ^(ellipsis-somehow String) arg]\n\nJoker return type: (atom-of go.std.os.exec/Cmd)"
;;   {:added "1.0"
;;    :go "__command(_name, ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(_arg)))"}
;;   [^String _name, ^String _arg])

JOKER FUNC os/exec.CommandContext from os/exec/exec.go:
;; (defn CommandContext
;;   "CommandContext is like Command but includes a context.\n\nThe provided context is used to kill the process (by calling\nos.Process.Kill) if the context becomes done before the command\ncompletes on its own.\n\nGo input arguments: (ctx context.Context, name string, arg ...string)\n\nGo return type: *Cmd\n\nJoker input arguments: [^go.std.context/Context ctx, ^String name, ^(ellipsis-somehow String) arg]\n\nJoker return type: (atom-of go.std.os.exec/Cmd)"
;;   {:added "1.0"
;;    :go "__commandContext(*_ctx, _name, ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(_arg)))"}
;;   [^context/Context _ctx, ^String _name, ^String _arg])

JOKER FUNC os/exec.LookPath from os/exec/lp_unix.go:
(defn LookPath
  "LookPath searches for an executable named file in the\ndirectories named by the PATH environment variable.\nIf file contains a slash, it is tried directly and the PATH is not consulted.\nThe result may be an absolute path or a path relative to the current directory.\n\nGo input arguments: (file string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String file]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__lookPath(_file)"}
  [^String _file])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the os/exec package."
    :empty false}
  go.std.os.exec)
JOKER FUNC os/signal.Ignore from os/signal/signal.go:
;; (defn Ignore
;;   "Ignore causes the provided signals to be ignored. If they are received by\nthe program, nothing will happen. Ignore undoes the effect of any prior\ncalls to Notify for the provided signals.\nIf no signals are provided, all incoming signals will be ignored.\n\nGo input arguments: (sig ...os.Signal)\n\nJoker input arguments: [^(ellipsis-somehow os/Signal) sig]"
;;   {:added "1.0"
;;    :go "__ignore(ConvertToEllipsisHaHaABEND987(genutils.go: imports not yet supported: os.Signal)(*_sig))"}
;;   [^os/Signal _sig])

JOKER FUNC os/signal.Ignored from os/signal/signal.go:
;; (defn ^"Boolean" Ignored
;;   "Ignored reports whether sig is currently ignored.\n\nGo input arguments: (sig os.Signal)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.os/Signal sig]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "signal.Ignored(*_sig)"}
;;   [^os/Signal _sig])

JOKER FUNC os/signal.Notify from os/signal/signal.go:
;; (defn Notify
;;   "Notify causes package signal to relay incoming signals to c.\nIf no signals are provided, all incoming signals will be relayed to c.\nOtherwise, just the provided signals will.\n\nPackage signal will not block sending to c: the caller must ensure\nthat c has sufficient buffer space to keep up with the expected\nsignal rate. For a channel used for notification of just one signal value,\na buffer of size 1 is sufficient.\n\nIt is allowed to call Notify multiple times with the same channel:\neach call expands the set of signals sent to that channel.\nThe only way to remove signals from the set is to call Stop.\n\nIt is allowed to call Notify multiple times with different channels\nand the same signals: each channel receives copies of incoming\nsignals independently.\n\nGo input arguments: (c <-chan, sig ...os.Signal)\n\nJoker input arguments: [^<no-idea-about-chan-yet> c, ^(ellipsis-somehow os/Signal) sig]"
;;   {:added "1.0"
;;    :go "__notify(ABEND909(pre.go: custom-runtime routine not implemented: ConvertToChanTypeHaHa()), ConvertToEllipsisHaHaABEND987(genutils.go: imports not yet supported: os.Signal)(*_sig))"}
;;   [^<no-idea-about-chan-yet> _c, ^os/Signal _sig])

JOKER FUNC os/signal.Reset from os/signal/signal.go:
;; (defn Reset
;;   "Reset undoes the effect of any prior calls to Notify for the provided\nsignals.\nIf no signals are provided, all signal handlers will be reset.\n\nGo input arguments: (sig ...os.Signal)\n\nJoker input arguments: [^(ellipsis-somehow os/Signal) sig]"
;;   {:added "1.0"
;;    :go "__reset(ConvertToEllipsisHaHaABEND987(genutils.go: imports not yet supported: os.Signal)(*_sig))"}
;;   [^os/Signal _sig])

JOKER FUNC os/signal.Stop from os/signal/signal.go:
;; (defn Stop
;;   "Stop causes package signal to stop relaying incoming signals to c.\nIt undoes the effect of all prior calls to Notify using c.\nWhen Stop returns, it is guaranteed that c will receive no more signals.\n\nGo input arguments: (c <-chan)\n\nJoker input arguments: [^<no-idea-about-chan-yet> c]"
;;   {:added "1.0"
;;    :go "__stop(ABEND909(pre.go: custom-runtime routine not implemented: ConvertToChanTypeHaHa()))"}
;;   [^<no-idea-about-chan-yet> _c])

JOKER TYPE os/user.Group from os/user/user.go:
(defn ^"GoObject" Group.
  "Constructor for user.Group"
  {:added "1.0"
   :go "_ConstructGroup(_v)"}
  [^Object _v])

JOKER TYPE os/user.UnknownGroupError from os/user/user.go:
(defn ^"GoObject" UnknownGroupError.
  "Constructor for user.UnknownGroupError"
  {:added "1.0"
   :go "_ConstructUnknownGroupError(_v)"}
  [^Object _v])

JOKER TYPE os/user.UnknownGroupIdError from os/user/user.go:
(defn ^"GoObject" UnknownGroupIdError.
  "Constructor for user.UnknownGroupIdError"
  {:added "1.0"
   :go "_ConstructUnknownGroupIdError(_v)"}
  [^Object _v])

JOKER TYPE os/user.UnknownUserError from os/user/user.go:
(defn ^"GoObject" UnknownUserError.
  "Constructor for user.UnknownUserError"
  {:added "1.0"
   :go "_ConstructUnknownUserError(_v)"}
  [^Object _v])

JOKER TYPE os/user.UnknownUserIdError from os/user/user.go:
(defn ^"GoObject" UnknownUserIdError.
  "Constructor for user.UnknownUserIdError"
  {:added "1.0"
   :go "_ConstructUnknownUserIdError(_v)"}
  [^Object _v])

JOKER TYPE os/user.User from os/user/user.go:
(defn ^"GoObject" User.
  "Constructor for user.User"
  {:added "1.0"
   :go "_ConstructUser(_v)"}
  [^Object _v])

JOKER FUNC os/user.Current from os/user/lookup.go:
(defn Current
  "Current returns the current user.\n\nGo return type: (*User, error)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.os.user/User) Error]"
  {:added "1.0"
   :go "__current()"}
  [])

JOKER FUNC os/user.Lookup from os/user/lookup.go:
(defn Lookup
  "Lookup looks up a user by username. If the user cannot be found, the\nreturned error is of type UnknownUserError.\n\nGo input arguments: (username string)\n\nGo return type: (*User, error)\n\nJoker input arguments: [^String username]\n\nJoker return type: [(atom-of go.std.os.user/User) Error]"
  {:added "1.0"
   :go "__lookup(_username)"}
  [^String _username])

JOKER FUNC os/user.LookupGroup from os/user/lookup.go:
(defn LookupGroup
  "LookupGroup looks up a group by name. If the group cannot be found, the\nreturned error is of type UnknownGroupError.\n\nGo input arguments: (name string)\n\nGo return type: (*Group, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.os.user/Group) Error]"
  {:added "1.0"
   :go "__lookupGroup(_name)"}
  [^String _name])

JOKER FUNC os/user.LookupGroupId from os/user/lookup.go:
(defn LookupGroupId
  "LookupGroupId looks up a group by groupid. If the group cannot be found, the\nreturned error is of type UnknownGroupIdError.\n\nGo input arguments: (gid string)\n\nGo return type: (*Group, error)\n\nJoker input arguments: [^String gid]\n\nJoker return type: [(atom-of go.std.os.user/Group) Error]"
  {:added "1.0"
   :go "__lookupGroupId(_gid)"}
  [^String _gid])

JOKER FUNC os/user.LookupId from os/user/lookup.go:
(defn LookupId
  "LookupId looks up a user by userid. If the user cannot be found, the\nreturned error is of type UnknownUserIdError.\n\nGo input arguments: (uid string)\n\nGo return type: (*User, error)\n\nJoker input arguments: [^String uid]\n\nJoker return type: [(atom-of go.std.os.user/User) Error]"
  {:added "1.0"
   :go "__lookupId(_uid)"}
  [^String _uid])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the os/user package."
    :empty false}
  go.std.os.user)
JOKER FUNC path.Base from path/path.go:
(defn ^"String" Base
  "Base returns the last element of path.\nTrailing slashes are removed before extracting the last element.\nIf the path is empty, Base returns \".\".\nIf the path consists entirely of slashes, Base returns \"/\".\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Base(_path)"}
  [^String _path])

JOKER FUNC path.Clean from path/path.go:
(defn ^"String" Clean
  "Clean returns the shortest path name equivalent to path\nby purely lexical processing. It applies the following rules\niteratively until no further processing can be done:\n\n\t1. Replace multiple slashes with a single slash.\n\t2. Eliminate each . path name element (the current directory).\n\t3. Eliminate each inner .. path name element (the parent directory)\n\t   along with the non-.. element that precedes it.\n\t4. Eliminate .. elements that begin a rooted path:\n\t   that is, replace \"/..\" by \"/\" at the beginning of a path.\n\nThe returned path ends in a slash only if it is the root \"/\".\n\nIf the result of this process is an empty string, Clean\nreturns the string \".\".\n\nSee also Rob Pike, ``Lexical File Names in Plan 9 or\nGetting Dot-Dot Right,''\nhttps://9p.io/sys/doc/lexnames.html\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Clean(_path)"}
  [^String _path])

JOKER FUNC path.Dir from path/path.go:
(defn ^"String" Dir
  "Dir returns all but the last element of path, typically the path's directory.\nAfter dropping the final element using Split, the path is Cleaned and trailing\nslashes are removed.\nIf the path is empty, Dir returns \".\".\nIf the path consists entirely of slashes followed by non-slash bytes, Dir\nreturns a single slash. In any other case, the returned path does not end in a\nslash.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Dir(_path)"}
  [^String _path])

JOKER FUNC path.Ext from path/path.go:
(defn ^"String" Ext
  "Ext returns the file name extension used by path.\nThe extension is the suffix beginning at the final dot\nin the final slash-separated element of path;\nit is empty if there is no dot.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Ext(_path)"}
  [^String _path])

JOKER FUNC path.IsAbs from path/path.go:
(defn ^"Boolean" IsAbs
  "IsAbs reports whether the path is absolute.\n\nGo input arguments: (path string)\n\nGo return type: bool\n\nJoker input arguments: [^String path]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "path.IsAbs(_path)"}
  [^String _path])

JOKER FUNC path.Join from path/path.go:
;; (defn ^"String" Join
;;   "Join joins any number of path elements into a single path, adding a\nseparating slash if necessary. The result is Cleaned; in particular,\nall empty strings are ignored.\n\nGo input arguments: (elem ...string)\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow String) elem]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "path.Join(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(_elem)))"}
;;   [^String _elem])

JOKER FUNC path.Match from path/match.go:
(defn Match
  "Match reports whether name matches the shell pattern.\nThe pattern syntax is:\n\n\tpattern:\n\t\t{ term }\n\tterm:\n\t\t'*'         matches any sequence of non-/ characters\n\t\t'?'         matches any single non-/ character\n\t\t'[' [ '^' ] { character-range } ']'\n\t\t            character class (must be non-empty)\n\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n\t\t'\\\\' c      matches character c\n\n\tcharacter-range:\n\t\tc           matches character c (c != '\\\\', '-', ']')\n\t\t'\\\\' c      matches character c\n\t\tlo '-' hi   matches character c for lo <= c <= hi\n\nMatch requires pattern to match all of name, not just a substring.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n\nGo input arguments: (pattern string, name string)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^String name]\n\nJoker return type: [Boolean Error]"
  {:added "1.0"
   :go "__match(_pattern, _name)"}
  [^String _pattern, ^String _name])

JOKER FUNC path.Split from path/path.go:
(defn Split
  "Split splits path immediately following the final slash,\nseparating it into a directory and file name component.\nIf there is no slash in path, Split returns an empty dir and\nfile set to path.\nThe returned values have the property that path = dir+file.\n\nGo input arguments: (path string)\n\nGo return type: (dir string, file string)\n\nJoker input arguments: [^String path]\n\nJoker return type: [String String]"
  {:added "1.0"
   :go "__split(_path)"}
  [^String _path])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["path"]
    :doc "Provides a low-level interface to the path package."
    :empty false}
  go.std.path)
JOKER TYPE path/filepath.WalkFunc from path/filepath/path.go:
;; (defn ^"GoObject" WalkFunc.
;;   "Constructor for filepath.WalkFunc"
;;   {:added "1.0"
;;    :go "_ConstructWalkFunc(_v)"}
;;   [^Object _v])

JOKER FUNC path/filepath.Abs from path/filepath/path.go:
(defn Abs
  "Abs returns an absolute representation of path.\nIf the path is not absolute it will be joined with the current\nworking directory to turn it into an absolute path. The absolute\npath name for a given file is not guaranteed to be unique.\nAbs calls Clean on the result.\n\nGo input arguments: (path string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String path]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__abs(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Base from path/filepath/path.go:
(defn ^"String" Base
  "Base returns the last element of path.\nTrailing path separators are removed before extracting the last element.\nIf the path is empty, Base returns \".\".\nIf the path consists entirely of separators, Base returns a single separator.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Base(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Clean from path/filepath/path.go:
(defn ^"String" Clean
  "Clean returns the shortest path name equivalent to path\nby purely lexical processing. It applies the following rules\niteratively until no further processing can be done:\n\n\t1. Replace multiple Separator elements with a single one.\n\t2. Eliminate each . path name element (the current directory).\n\t3. Eliminate each inner .. path name element (the parent directory)\n\t   along with the non-.. element that precedes it.\n\t4. Eliminate .. elements that begin a rooted path:\n\t   that is, replace \"/..\" by \"/\" at the beginning of a path,\n\t   assuming Separator is '/'.\n\nThe returned path ends in a slash only if it represents a root directory,\nsuch as \"/\" on Unix or `C:\\` on Windows.\n\nFinally, any occurrences of slash are replaced by Separator.\n\nIf the result of this process is an empty string, Clean\nreturns the string \".\".\n\nSee also Rob Pike, ``Lexical File Names in Plan 9 or\nGetting Dot-Dot Right,''\nhttps://9p.io/sys/doc/lexnames.html\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Clean(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Dir from path/filepath/path.go:
(defn ^"String" Dir
  "Dir returns all but the last element of path, typically the path's directory.\nAfter dropping the final element, Dir calls Clean on the path and trailing\nslashes are removed.\nIf the path is empty, Dir returns \".\".\nIf the path consists entirely of separators, Dir returns a single separator.\nThe returned path does not end in a separator unless it is the root directory.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Dir(_path)"}
  [^String _path])

JOKER FUNC path/filepath.EvalSymlinks from path/filepath/path.go:
(defn EvalSymlinks
  "EvalSymlinks returns the path name after the evaluation of any symbolic\nlinks.\nIf path is relative the result will be relative to the current directory,\nunless one of the components is an absolute symbolic link.\nEvalSymlinks calls Clean on the result.\n\nGo input arguments: (path string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String path]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__evalSymlinks(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Ext from path/filepath/path.go:
(defn ^"String" Ext
  "Ext returns the file name extension used by path.\nThe extension is the suffix beginning at the final dot\nin the final element of path; it is empty if there is\nno dot.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Ext(_path)"}
  [^String _path])

JOKER FUNC path/filepath.FromSlash from path/filepath/path.go:
(defn ^"String" FromSlash
  "FromSlash returns the result of replacing each slash ('/') character\nin path with a separator character. Multiple slashes are replaced\nby multiple separators.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.FromSlash(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Glob from path/filepath/match.go:
(defn Glob
  "Glob returns the names of all files matching pattern or nil\nif there is no matching file. The syntax of patterns is the same\nas in Match. The pattern may describe hierarchical names such as\n/usr/*/bin/ed (assuming the Separator is '/').\n\nGlob ignores file system errors such as I/O errors reading directories.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n\nGo input arguments: (pattern string)\n\nGo return type: (matches []string, err error)\n\nJoker input arguments: [^String pattern]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__glob(_pattern)"}
  [^String _pattern])

JOKER FUNC path/filepath.HasPrefix from path/filepath/path_unix.go:
(defn ^"Boolean" HasPrefix
  "HasPrefix exists for historical compatibility and should not be used.\n\nDeprecated: HasPrefix does not respect path boundaries and\ndoes not ignore case when required.\n\nGo input arguments: (p string, prefix string)\n\nGo return type: bool\n\nJoker input arguments: [^String p, ^String prefix]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "filepath.HasPrefix(_p, _prefix)"}
  [^String _p, ^String _prefix])

JOKER FUNC path/filepath.IsAbs from path/filepath/path_unix.go:
(defn ^"Boolean" IsAbs
  "IsAbs reports whether the path is absolute.\n\nGo input arguments: (path string)\n\nGo return type: bool\n\nJoker input arguments: [^String path]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "filepath.IsAbs(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Join from path/filepath/path.go:
;; (defn ^"String" Join
;;   "Join joins any number of path elements into a single path, adding\na Separator if necessary. Join calls Clean on the result; in particular,\nall empty strings are ignored.\nOn Windows, the result is a UNC path if and only if the first path\nelement is a UNC path.\n\nGo input arguments: (elem ...string)\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow String) elem]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "filepath.Join(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(_elem)))"}
;;   [^String _elem])

JOKER FUNC path/filepath.Match from path/filepath/match.go:
(defn Match
  "Match reports whether name matches the shell file name pattern.\nThe pattern syntax is:\n\n\tpattern:\n\t\t{ term }\n\tterm:\n\t\t'*'         matches any sequence of non-Separator characters\n\t\t'?'         matches any single non-Separator character\n\t\t'[' [ '^' ] { character-range } ']'\n\t\t            character class (must be non-empty)\n\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n\t\t'\\\\' c      matches character c\n\n\tcharacter-range:\n\t\tc           matches character c (c != '\\\\', '-', ']')\n\t\t'\\\\' c      matches character c\n\t\tlo '-' hi   matches character c for lo <= c <= hi\n\nMatch requires pattern to match all of name, not just a substring.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n\nOn Windows, escaping is disabled. Instead, '\\\\' is treated as\npath separator.\n\nGo input arguments: (pattern string, name string)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^String name]\n\nJoker return type: [Boolean Error]"
  {:added "1.0"
   :go "__match(_pattern, _name)"}
  [^String _pattern, ^String _name])

JOKER FUNC path/filepath.Rel from path/filepath/path.go:
(defn Rel
  "Rel returns a relative path that is lexically equivalent to targpath when\njoined to basepath with an intervening separator. That is,\nJoin(basepath, Rel(basepath, targpath)) is equivalent to targpath itself.\nOn success, the returned path will always be relative to basepath,\neven if basepath and targpath share no elements.\nAn error is returned if targpath can't be made relative to basepath or if\nknowing the current working directory would be necessary to compute it.\nRel calls Clean on the result.\n\nGo input arguments: (basepath string, targpath string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String basepath, ^String targpath]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__rel(_basepath, _targpath)"}
  [^String _basepath, ^String _targpath])

JOKER FUNC path/filepath.Split from path/filepath/path.go:
(defn Split
  "Split splits path immediately following the final Separator,\nseparating it into a directory and file name component.\nIf there is no Separator in path, Split returns an empty dir\nand file set to path.\nThe returned values have the property that path = dir+file.\n\nGo input arguments: (path string)\n\nGo return type: (dir string, file string)\n\nJoker input arguments: [^String path]\n\nJoker return type: [String String]"
  {:added "1.0"
   :go "__split(_path)"}
  [^String _path])

JOKER FUNC path/filepath.SplitList from path/filepath/path.go:
(defn SplitList
  "SplitList splits a list of paths joined by the OS-specific ListSeparator,\nusually found in PATH or GOPATH environment variables.\nUnlike strings.Split, SplitList returns an empty slice when passed an empty\nstring.\n\nGo input arguments: (path string)\n\nGo return type: []string\n\nJoker input arguments: [^String path]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__splitList(_path)"}
  [^String _path])

JOKER FUNC path/filepath.ToSlash from path/filepath/path.go:
(defn ^"String" ToSlash
  "ToSlash returns the result of replacing each separator character\nin path with a slash ('/') character. Multiple separators are\nreplaced by multiple slashes.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.ToSlash(_path)"}
  [^String _path])

JOKER FUNC path/filepath.VolumeName from path/filepath/path.go:
(defn ^"String" VolumeName
  "VolumeName returns leading volume name.\nGiven \"C:\\foo\\bar\" it returns \"C:\" on Windows.\nGiven \"\\\\host\\share\\foo\" it returns \"\\\\host\\share\".\nOn other platforms it returns \"\".\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.VolumeName(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Walk from path/filepath/path.go:
(defn ^"Error" Walk
  "Walk walks the file tree rooted at root, calling walkFn for each file or\ndirectory in the tree, including root. All errors that arise visiting files\nand directories are filtered by walkFn. The files are walked in lexical\norder, which makes the output deterministic but means that for very\nlarge directories Walk can be inefficient.\nWalk does not follow symbolic links.\n\nGo input arguments: (root string, walkFn WalkFunc)\n\nGo return type: error\n\nJoker input arguments: [^String root, ^go.std.path.filepath/WalkFunc walkFn]\n\nJoker return type: Error"
  {:added "1.0"
   :go "filepath.Walk(_root, *_walkFn)"}
  [^String _root, ^filepath/WalkFunc _walkFn])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["path/filepath"]
    :doc "Provides a low-level interface to the path/filepath package."
    :empty false}
  go.std.path.filepath)
JOKER TYPE plugin.Plugin from plugin/plugin.go:
(defn ^"GoObject" Plugin.
  "Constructor for plugin.Plugin"
  {:added "1.0"
   :go "_ConstructPlugin(_v)"}
  [^Object _v])

JOKER TYPE plugin.Symbol from plugin/plugin.go:
;; (defn ^"GoObject" Symbol.
;;   "Constructor for plugin.Symbol"
;;   {:added "1.0"
;;    :go "_ConstructSymbol(_v)"}
;;   [^Object _v])

JOKER FUNC plugin.Open from plugin/plugin.go:
(defn Open
  "Open opens a Go plugin.\nIf a path has already been opened, then the existing *Plugin is returned.\nIt is safe for concurrent use by multiple goroutines.\n\nGo input arguments: (path string)\n\nGo return type: (*Plugin, error)\n\nJoker input arguments: [^String path]\n\nJoker return type: [(atom-of go.std.plugin/Plugin) Error]"
  {:added "1.0"
   :go "__open(_path)"}
  [^String _path])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the plugin package."
    :empty false}
  go.std.plugin)
JOKER TYPE reflect.ChanDir from reflect/type.go:
(defn ^"GoObject" ChanDir.
  "Constructor for reflect.ChanDir"
  {:added "1.0"
   :go "_ConstructChanDir(_v)"}
  [^Object _v])

JOKER TYPE reflect.Kind from reflect/type.go:
(defn ^"GoObject" Kind.
  "Constructor for reflect.Kind"
  {:added "1.0"
   :go "_ConstructKind(_v)"}
  [^Object _v])

JOKER TYPE reflect.Method from reflect/type.go:
(defn ^"GoObject" Method.
  "Constructor for reflect.Method"
  {:added "1.0"
   :go "_ConstructMethod(_v)"}
  [^Object _v])

JOKER TYPE reflect.SelectCase from reflect/value.go:
(defn ^"GoObject" SelectCase.
  "Constructor for reflect.SelectCase"
  {:added "1.0"
   :go "_ConstructSelectCase(_v)"}
  [^Object _v])

JOKER TYPE reflect.SelectDir from reflect/value.go:
(defn ^"GoObject" SelectDir.
  "Constructor for reflect.SelectDir"
  {:added "1.0"
   :go "_ConstructSelectDir(_v)"}
  [^Object _v])

JOKER TYPE reflect.SliceHeader from reflect/value.go:
(defn ^"GoObject" SliceHeader.
  "Constructor for reflect.SliceHeader"
  {:added "1.0"
   :go "_ConstructSliceHeader(_v)"}
  [^Object _v])

JOKER TYPE reflect.StringHeader from reflect/value.go:
(defn ^"GoObject" StringHeader.
  "Constructor for reflect.StringHeader"
  {:added "1.0"
   :go "_ConstructStringHeader(_v)"}
  [^Object _v])

JOKER TYPE reflect.StructField from reflect/type.go:
(defn ^"GoObject" StructField.
  "Constructor for reflect.StructField"
  {:added "1.0"
   :go "_ConstructStructField(_v)"}
  [^Object _v])

JOKER TYPE reflect.StructTag from reflect/type.go:
(defn ^"GoObject" StructTag.
  "Constructor for reflect.StructTag"
  {:added "1.0"
   :go "_ConstructStructTag(_v)"}
  [^Object _v])

JOKER TYPE reflect.Type from reflect/type.go:
;; (defn ^"GoObject" Type.
;;   "Constructor for reflect.Type"
;;   {:added "1.0"
;;    :go "_ConstructType(_v)"}
;;   [^Object _v])

JOKER TYPE reflect.Value from reflect/value.go:
(defn ^"GoObject" Value.
  "Constructor for reflect.Value"
  {:added "1.0"
   :go "_ConstructValue(_v)"}
  [^Object _v])

JOKER TYPE reflect.ValueError from reflect/value.go:
(defn ^"GoObject" ValueError.
  "Constructor for reflect.ValueError"
  {:added "1.0"
   :go "_ConstructValueError(_v)"}
  [^Object _v])

JOKER FUNC reflect.Append from reflect/value.go:
;; (defn Append
;;   "Append appends the values x to a slice s and returns the resulting slice.\nAs in Go, each x's value must be assignable to the slice's element type.\n\nGo input arguments: (s Value, x ...Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Value s, ^(ellipsis-somehow reflect/Value) x]\n\nJoker return type: go.std.reflect/Value"
;;   {:added "1.0"
;;    :go "__append(*_s, ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHa_reflect.Value(*_x)))"}
;;   [^reflect/Value _s, ^reflect/Value _x])

JOKER FUNC reflect.AppendSlice from reflect/value.go:
(defn AppendSlice
  "AppendSlice appends a slice t to a slice s and returns the resulting slice.\nThe slices s and t must have the same element type.\n\nGo input arguments: (s Value, t Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Value s, ^go.std.reflect/Value t]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__appendSlice(*_s, *_t)"}
  [^reflect/Value _s, ^reflect/Value _t])

JOKER FUNC reflect.ArrayOf from reflect/type.go:
(defn ArrayOf
  "ArrayOf returns the array type with the given count and element type.\nFor example, if t represents int, ArrayOf(5, t) represents [5]int.\n\nIf the resulting type would be larger than the available address space,\nArrayOf panics.\n\nGo input arguments: (count int, elem Type)\n\nGo return type: Type\n\nJoker input arguments: [^Int count, ^go.std.reflect/Type elem]\n\nJoker return type: go.std.reflect/Type"
  {:added "1.0"
   :go "__arrayOf(_count, *_elem)"}
  [^Int _count, ^reflect/Type _elem])

JOKER FUNC reflect.ChanOf from reflect/type.go:
(defn ChanOf
  "ChanOf returns the channel type with the given direction and element type.\nFor example, if t represents int, ChanOf(RecvDir, t) represents <-chan int.\n\nThe gc runtime imposes a limit of 64 kB on channel element types.\nIf t's size is equal to or exceeds this limit, ChanOf panics.\n\nGo input arguments: (dir ChanDir, t Type)\n\nGo return type: Type\n\nJoker input arguments: [^go.std.reflect/ChanDir dir, ^go.std.reflect/Type t]\n\nJoker return type: go.std.reflect/Type"
  {:added "1.0"
   :go "__chanOf(*_dir, *_t)"}
  [^reflect/ChanDir _dir, ^reflect/Type _t])

JOKER FUNC reflect.Copy from reflect/value.go:
(defn ^"Int" Copy
  "Copy copies the contents of src into dst until either\ndst has been filled or src has been exhausted.\nIt returns the number of elements copied.\nDst and src each must have kind Slice or Array, and\ndst and src must have the same element type.\n\nAs a special case, src can have kind String if the element type of dst is kind Uint8.\n\nGo input arguments: (dst Value, src Value)\n\nGo return type: int\n\nJoker input arguments: [^go.std.reflect/Value dst, ^go.std.reflect/Value src]\n\nJoker return type: Int"
  {:added "1.0"
   :go "reflect.Copy(*_dst, *_src)"}
  [^reflect/Value _dst, ^reflect/Value _src])

JOKER FUNC reflect.DeepEqual from reflect/deepequal.go:
;; (defn ^"Boolean" DeepEqual
;;   "DeepEqual reports whether x and y are ``deeply equal,'' defined as follows.\nTwo values of identical type are deeply equal if one of the following cases applies.\nValues of distinct types are never deeply equal.\n\nArray values are deeply equal when their corresponding elements are deeply equal.\n\nStruct values are deeply equal if their corresponding fields,\nboth exported and unexported, are deeply equal.\n\nFunc values are deeply equal if both are nil; otherwise they are not deeply equal.\n\nInterface values are deeply equal if they hold deeply equal concrete values.\n\nMap values are deeply equal when all of the following are true:\nthey are both nil or both non-nil, they have the same length,\nand either they are the same map object or their corresponding keys\n(matched using Go equality) map to deeply equal values.\n\nPointer values are deeply equal if they are equal using Go's == operator\nor if they point to deeply equal values.\n\nSlice values are deeply equal when all of the following are true:\nthey are both nil or both non-nil, they have the same length,\nand either they point to the same initial entry of the same underlying array\n(that is, &x[0] == &y[0]) or their corresponding elements (up to length) are deeply equal.\nNote that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil))\nare not deeply equal.\n\nOther values - numbers, bools, strings, and channels - are deeply equal\nif they are equal using Go's == operator.\n\nIn general DeepEqual is a recursive relaxation of Go's == operator.\nHowever, this idea is impossible to implement without some inconsistency.\nSpecifically, it is possible for a value to be unequal to itself,\neither because it is of func type (uncomparable in general)\nor because it is a floating-point NaN value (not equal to itself in floating-point comparison),\nor because it is an array, struct, or interface containing\nsuch a value.\nOn the other hand, pointer values are always equal to themselves,\neven if they point at or contain such problematic values,\nbecause they compare equal using Go's == operator, and that\nis a sufficient condition to be deeply equal, regardless of content.\nDeepEqual has been defined so that the same short-cut applies\nto slices and maps: if x and y are the same slice or the same map,\nthey are deeply equal regardless of content.\n\nAs DeepEqual traverses the data values it may find a cycle. The\nsecond and subsequent times that DeepEqual compares two pointer\nvalues that have been compared before, it treats the values as\nequal rather than examining the values to which they point.\nThis ensures that DeepEqual terminates.\n\nGo input arguments: (x interface {}, y interface {})\n\nGo return type: bool\n\nJoker input arguments: [^<protocol-or-something> x, ^<protocol-or-something> y]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "reflect.DeepEqual(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _x, ^<protocol-or-something> _y])

JOKER FUNC reflect.FuncOf from reflect/type.go:
;; (defn FuncOf
;;   "FuncOf returns the function type with the given argument and result types.\nFor example if k represents int and e represents string,\nFuncOf([]Type{k}, []Type{e}, false) represents func(int) string.\n\nThe variadic argument controls whether the function is variadic. FuncOf\npanics if the in[len(in)-1] does not represent a slice and variadic is\ntrue.\n\nGo input arguments: (in []Type, out []Type, variadic bool)\n\nGo return type: Type\n\nJoker input arguments: [^(vector-of go.std.reflect/Type) in, ^(vector-of go.std.reflect/Type) out, ^Boolean variadic]\n\nJoker return type: go.std.reflect/Type"
;;   {:added "1.0"
;;    :go "__funcOf(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_reflect.Type(*_in)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_reflect.Type(*_out)), _variadic)"}
;;   [^Object _in, ^Object _out, ^Boolean _variadic])

JOKER FUNC reflect.Indirect from reflect/value.go:
(defn Indirect
  "Indirect returns the value that v points to.\nIf v is a nil pointer, Indirect returns a zero Value.\nIf v is not a pointer, Indirect returns v.\n\nGo input arguments: (v Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Value v]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__indirect(*_v)"}
  [^reflect/Value _v])

JOKER FUNC reflect.MakeChan from reflect/value.go:
(defn MakeChan
  "MakeChan creates a new channel with the specified type and buffer size.\n\nGo input arguments: (typ Type, buffer int)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ, ^Int buffer]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__makeChan(*_typ, _buffer)"}
  [^reflect/Type _typ, ^Int _buffer])

JOKER FUNC reflect.MakeFunc from reflect/makefunc.go:
;; (defn MakeFunc
;;   "MakeFunc returns a new function of the given Type\nthat wraps the function fn. When called, that new function\ndoes the following:\n\n\t- converts its arguments to a slice of Values.\n\t- runs results := fn(args).\n\t- returns the results as a slice of Values, one per formal result.\n\nThe implementation fn can assume that the argument Value slice\nhas the number and type of arguments given by typ.\nIf typ describes a variadic function, the final Value is itself\na slice representing the variadic arguments, as in the\nbody of a variadic function. The result Value slice returned by fn\nmust have the number and type of results given by typ.\n\nThe Value.Call method allows the caller to invoke a typed function\nin terms of Values; in contrast, MakeFunc allows the caller to implement\na typed function in terms of Values.\n\nThe Examples section of the documentation includes an illustration\nof how to use MakeFunc to build a swap function for different types.\n\nGo input arguments: (typ Type, fn func)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ, ^fn fn]\n\nJoker return type: go.std.reflect/Value"
;;   {:added "1.0"
;;    :go "__makeFunc(*_typ, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^reflect/Type _typ, ^fn _fn])

JOKER FUNC reflect.MakeMap from reflect/value.go:
(defn MakeMap
  "MakeMap creates a new map with the specified type.\n\nGo input arguments: (typ Type)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__makeMap(*_typ)"}
  [^reflect/Type _typ])

JOKER FUNC reflect.MakeMapWithSize from reflect/value.go:
(defn MakeMapWithSize
  "MakeMapWithSize creates a new map with the specified type\nand initial space for approximately n elements.\n\nGo input arguments: (typ Type, n int)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ, ^Int n]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__makeMapWithSize(*_typ, _n)"}
  [^reflect/Type _typ, ^Int _n])

JOKER FUNC reflect.MakeSlice from reflect/value.go:
(defn MakeSlice
  "MakeSlice creates a new zero-initialized slice value\nfor the specified slice type, length, and capacity.\n\nGo input arguments: (typ Type, len int, cap int)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ, ^Int len, ^Int cap]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__makeSlice(*_typ, _len, _cap)"}
  [^reflect/Type _typ, ^Int _len, ^Int _cap])

JOKER FUNC reflect.MapOf from reflect/type.go:
(defn MapOf
  "MapOf returns the map type with the given key and element types.\nFor example, if k represents int and e represents string,\nMapOf(k, e) represents map[int]string.\n\nIf the key type is not a valid map key type (that is, if it does\nnot implement Go's == operator), MapOf panics.\n\nGo input arguments: (key Type, elem Type)\n\nGo return type: Type\n\nJoker input arguments: [^go.std.reflect/Type key, ^go.std.reflect/Type elem]\n\nJoker return type: go.std.reflect/Type"
  {:added "1.0"
   :go "__mapOf(*_key, *_elem)"}
  [^reflect/Type _key, ^reflect/Type _elem])

JOKER FUNC reflect.New from reflect/value.go:
(defn New
  "New returns a Value representing a pointer to a new zero value\nfor the specified type. That is, the returned Value's Type is PtrTo(typ).\n\nGo input arguments: (typ Type)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__new(*_typ)"}
  [^reflect/Type _typ])

JOKER FUNC reflect.NewAt from reflect/value.go:
;; (defn NewAt
;;   "NewAt returns a Value representing a pointer to a value of the\nspecified type, using p as that pointer.\n\nGo input arguments: (typ Type, p unsafe.Pointer)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ, ^go.std.unsafe/Pointer p]\n\nJoker return type: go.std.reflect/Value"
;;   {:added "1.0"
;;    :go "__newAt(*_typ, *_p)"}
;;   [^reflect/Type _typ, ^unsafe/Pointer _p])

JOKER FUNC reflect.PtrTo from reflect/type.go:
(defn PtrTo
  "PtrTo returns the pointer type with element t.\nFor example, if t represents type Foo, PtrTo(t) represents *Foo.\n\nGo input arguments: (t Type)\n\nGo return type: Type\n\nJoker input arguments: [^go.std.reflect/Type t]\n\nJoker return type: go.std.reflect/Type"
  {:added "1.0"
   :go "__ptrTo(*_t)"}
  [^reflect/Type _t])

JOKER FUNC reflect.Select from reflect/value.go:
;; (defn Select
;;   "Select executes a select operation described by the list of cases.\nLike the Go select statement, it blocks until at least one of the cases\ncan proceed, makes a uniform pseudo-random choice,\nand then executes that case. It returns the index of the chosen case\nand, if that case was a receive operation, the value received and a\nboolean indicating whether the value corresponds to a send on the channel\n(as opposed to a zero value received because the channel is closed).\n\nGo input arguments: (cases []SelectCase)\n\nGo return type: (chosen int, recv Value, recvOK bool)\n\nJoker input arguments: [^(vector-of go.std.reflect/SelectCase) cases]\n\nJoker return type: [Int go.std.reflect/Value Boolean]"
;;   {:added "1.0"
;;    :go "__select(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_reflect.SelectCase(*_cases)))"}
;;   [^Object _cases])

JOKER FUNC reflect.SliceOf from reflect/type.go:
(defn SliceOf
  "SliceOf returns the slice type with element type t.\nFor example, if t represents int, SliceOf(t) represents []int.\n\nGo input arguments: (t Type)\n\nGo return type: Type\n\nJoker input arguments: [^go.std.reflect/Type t]\n\nJoker return type: go.std.reflect/Type"
  {:added "1.0"
   :go "__sliceOf(*_t)"}
  [^reflect/Type _t])

JOKER FUNC reflect.StructOf from reflect/type.go:
;; (defn StructOf
;;   "StructOf returns the struct type containing fields.\nThe Offset and Index fields are ignored and computed as they would be\nby the compiler.\n\nStructOf currently does not generate wrapper methods for embedded\nfields and panics if passed unexported StructFields.\nThese limitations may be lifted in a future version.\n\nGo input arguments: (fields []StructField)\n\nGo return type: Type\n\nJoker input arguments: [^(vector-of go.std.reflect/StructField) fields]\n\nJoker return type: go.std.reflect/Type"
;;   {:added "1.0"
;;    :go "__structOf(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_reflect.StructField(*_fields)))"}
;;   [^Object _fields])

JOKER FUNC reflect.Swapper from reflect/swapper.go:
;; (defn Swapper
;;   "Swapper returns a function that swaps the elements in the provided\nslice.\n\nSwapper panics if the provided interface is not a slice.\n\nGo input arguments: (slice interface {})\n\nGo return type: ...\n\nJoker input arguments: [^<protocol-or-something> slice]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.FuncType at: /usr/local/go-1.11.5/src/reflect/swapper.go:13:33)"
;;   {:added "1.0"
;;    :go "__swapper(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _slice])

JOKER FUNC reflect.TypeOf from reflect/type.go:
;; (defn TypeOf
;;   "TypeOf returns the reflection Type that represents the dynamic type of i.\nIf i is a nil interface value, TypeOf returns nil.\n\nGo input arguments: (i interface {})\n\nGo return type: Type\n\nJoker input arguments: [^<protocol-or-something> i]\n\nJoker return type: go.std.reflect/Type"
;;   {:added "1.0"
;;    :go "__typeOf(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _i])

JOKER FUNC reflect.ValueOf from reflect/value.go:
;; (defn ValueOf
;;   "ValueOf returns a new Value initialized to the concrete value\nstored in the interface i. ValueOf(nil) returns the zero Value.\n\nGo input arguments: (i interface {})\n\nGo return type: Value\n\nJoker input arguments: [^<protocol-or-something> i]\n\nJoker return type: go.std.reflect/Value"
;;   {:added "1.0"
;;    :go "__valueOf(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _i])

JOKER FUNC reflect.Zero from reflect/value.go:
(defn Zero
  "Zero returns a Value representing the zero value for the specified type.\nThe result is different from the zero value of the Value struct,\nwhich represents no value at all.\nFor example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0.\nThe returned value is neither addressable nor settable.\n\nGo input arguments: (typ Type)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__zero(*_typ)"}
  [^reflect/Type _typ])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["reflect"]
    :doc "Provides a low-level interface to the reflect package."
    :empty false}
  go.std.reflect)
JOKER TYPE regexp.Regexp from regexp/regexp.go:
(defn ^"GoObject" Regexp.
  "Constructor for regexp.Regexp"
  {:added "1.0"
   :go "_ConstructRegexp(_v)"}
  [^Object _v])

JOKER FUNC regexp.Compile from regexp/regexp.go:
(defn Compile
  "Compile parses a regular expression and returns, if successful,\na Regexp object that can be used to match against text.\n\nWhen matching against text, the regexp returns a match that\nbegins as early as possible in the input (leftmost), and among those\nit chooses the one that a backtracking search would have found first.\nThis so-called leftmost-first matching is the same semantics\nthat Perl, Python, and other implementations use, although this\npackage implements it without the expense of backtracking.\nFor POSIX leftmost-longest matching, see CompilePOSIX.\n\nGo input arguments: (expr string)\n\nGo return type: (*Regexp, error)\n\nJoker input arguments: [^String expr]\n\nJoker return type: [(atom-of go.std.regexp/Regexp) Error]"
  {:added "1.0"
   :go "__compile(_expr)"}
  [^String _expr])

JOKER FUNC regexp.CompilePOSIX from regexp/regexp.go:
(defn CompilePOSIX
  "CompilePOSIX is like Compile but restricts the regular expression\nto POSIX ERE (egrep) syntax and changes the match semantics to\nleftmost-longest.\n\nThat is, when matching against text, the regexp returns a match that\nbegins as early as possible in the input (leftmost), and among those\nit chooses a match that is as long as possible.\nThis so-called leftmost-longest matching is the same semantics\nthat early regular expression implementations used and that POSIX\nspecifies.\n\nHowever, there can be multiple leftmost-longest matches, with different\nsubmatch choices, and here this package diverges from POSIX.\nAmong the possible leftmost-longest matches, this package chooses\nthe one that a backtracking search would have found first, while POSIX\nspecifies that the match be chosen to maximize the length of the first\nsubexpression, then the second, and so on from left to right.\nThe POSIX rule is computationally prohibitive and not even well-defined.\nSee https://swtch.com/~rsc/regexp/regexp2.html#posix for details.\n\nGo input arguments: (expr string)\n\nGo return type: (*Regexp, error)\n\nJoker input arguments: [^String expr]\n\nJoker return type: [(atom-of go.std.regexp/Regexp) Error]"
  {:added "1.0"
   :go "__compilePOSIX(_expr)"}
  [^String _expr])

JOKER FUNC regexp.Match from regexp/regexp.go:
;; (defn Match
;;   "MatchString reports whether the byte slice b\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\n\nGo input arguments: (pattern string, b []byte)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^(vector-of Byte) b]\n\nJoker return type: [Boolean Error]"
;;   {:added "1.0"
;;    :go "__match(_pattern, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^String _pattern, ^Object _b])

JOKER FUNC regexp.MatchReader from regexp/regexp.go:
;; (defn MatchReader
;;   "MatchReader reports whether the text returned by the RuneReader\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\n\nGo input arguments: (pattern string, r io.RuneReader)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^go.std.io/RuneReader r]\n\nJoker return type: [Boolean Error]"
;;   {:added "1.0"
;;    :go "__matchReader(_pattern, *_r)"}
;;   [^String _pattern, ^io/RuneReader _r])

JOKER FUNC regexp.MatchString from regexp/regexp.go:
(defn MatchString
  "MatchString reports whether the string s\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\n\nGo input arguments: (pattern string, s string)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^String s]\n\nJoker return type: [Boolean Error]"
  {:added "1.0"
   :go "__matchString(_pattern, _s)"}
  [^String _pattern, ^String _s])

JOKER FUNC regexp.MustCompile from regexp/regexp.go:
(defn MustCompile
  "MustCompile is like Compile but panics if the expression cannot be parsed.\nIt simplifies safe initialization of global variables holding compiled regular\nexpressions.\n\nGo input arguments: (str string)\n\nGo return type: *Regexp\n\nJoker input arguments: [^String str]\n\nJoker return type: (atom-of go.std.regexp/Regexp)"
  {:added "1.0"
   :go "__mustCompile(_str)"}
  [^String _str])

JOKER FUNC regexp.MustCompilePOSIX from regexp/regexp.go:
(defn MustCompilePOSIX
  "MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed.\nIt simplifies safe initialization of global variables holding compiled regular\nexpressions.\n\nGo input arguments: (str string)\n\nGo return type: *Regexp\n\nJoker input arguments: [^String str]\n\nJoker return type: (atom-of go.std.regexp/Regexp)"
  {:added "1.0"
   :go "__mustCompilePOSIX(_str)"}
  [^String _str])

JOKER FUNC regexp.QuoteMeta from regexp/regexp.go:
(defn ^"String" QuoteMeta
  "QuoteMeta returns a string that escapes all regular expression metacharacters\ninside the argument text; the returned string is a regular expression matching\nthe literal text.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "regexp.QuoteMeta(_s)"}
  [^String _s])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["regexp"]
    :doc "Provides a low-level interface to the regexp package."
    :empty false}
  go.std.regexp)
JOKER TYPE regexp/syntax.EmptyOp from regexp/syntax/prog.go:
(defn ^"GoObject" EmptyOp.
  "Constructor for syntax.EmptyOp"
  {:added "1.0"
   :go "_ConstructEmptyOp(_v)"}
  [^Object _v])

JOKER TYPE regexp/syntax.Error from regexp/syntax/parse.go:
(defn ^"GoObject" Error.
  "Constructor for syntax.Error"
  {:added "1.0"
   :go "_ConstructError(_v)"}
  [^Object _v])

JOKER TYPE regexp/syntax.ErrorCode from regexp/syntax/parse.go:
(defn ^"GoObject" ErrorCode.
  "Constructor for syntax.ErrorCode"
  {:added "1.0"
   :go "_ConstructErrorCode(_v)"}
  [^Object _v])

JOKER TYPE regexp/syntax.Flags from regexp/syntax/parse.go:
;; (defn ^"GoObject" Flags.
;;   "Constructor for syntax.Flags"
;;   {:added "1.0"
;;    :go "_ConstructFlags(_v)"}
;;   [^Object _v])

JOKER TYPE regexp/syntax.Inst from regexp/syntax/prog.go:
(defn ^"GoObject" Inst.
  "Constructor for syntax.Inst"
  {:added "1.0"
   :go "_ConstructInst(_v)"}
  [^Object _v])

JOKER TYPE regexp/syntax.InstOp from regexp/syntax/prog.go:
(defn ^"GoObject" InstOp.
  "Constructor for syntax.InstOp"
  {:added "1.0"
   :go "_ConstructInstOp(_v)"}
  [^Object _v])

JOKER TYPE regexp/syntax.Op from regexp/syntax/regexp.go:
(defn ^"GoObject" Op.
  "Constructor for syntax.Op"
  {:added "1.0"
   :go "_ConstructOp(_v)"}
  [^Object _v])

JOKER TYPE regexp/syntax.Prog from regexp/syntax/prog.go:
(defn ^"GoObject" Prog.
  "Constructor for syntax.Prog"
  {:added "1.0"
   :go "_ConstructProg(_v)"}
  [^Object _v])

JOKER TYPE regexp/syntax.Regexp from regexp/syntax/regexp.go:
(defn ^"GoObject" Regexp.
  "Constructor for syntax.Regexp"
  {:added "1.0"
   :go "_ConstructRegexp(_v)"}
  [^Object _v])

JOKER FUNC regexp/syntax.Compile from regexp/syntax/compile.go:
(defn Compile
  "Compile compiles the regexp into a program to be executed.\nThe regexp should have been simplified already (returned from re.Simplify).\n\nGo input arguments: (re *Regexp)\n\nGo return type: (*Prog, error)\n\nJoker input arguments: [^(atom-of go.std.regexp.syntax/Regexp) re]\n\nJoker return type: [(atom-of go.std.regexp.syntax/Prog) Error]"
  {:added "1.0"
   :go "__compile(_re)"}
  [^syntax/Regexp _re])

JOKER FUNC regexp/syntax.EmptyOpContext from regexp/syntax/prog.go:
;; (defn EmptyOpContext
;;   "EmptyOpContext returns the zero-width assertions\nsatisfied at the position between the runes r1 and r2.\nPassing r1 == -1 indicates that the position is\nat the beginning of the text.\nPassing r2 == -1 indicates that the position is\nat the end of the text.\n\nGo input arguments: (r1 rune, r2 rune)\n\nGo return type: EmptyOp\n\nJoker input arguments: [^rune r1, ^rune r2]\n\nJoker return type: go.std.regexp.syntax/EmptyOp"
;;   {:added "1.0"
;;    :go "__emptyOpContext(_r1, _r2)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r1, ^ABEND044(pre.go: unsupported built-in type rune) _r2])

JOKER FUNC regexp/syntax.IsWordChar from regexp/syntax/prog.go:
;; (defn ^"Boolean" IsWordChar
;;   "IsWordChar reports whether r is consider a ``word character''\nduring the evaluation of the \\b and \\B zero-width assertions.\nThese assertions are ASCII-only: the word characters are [A-Za-z0-9_].\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "syntax.IsWordChar(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC regexp/syntax.Parse from regexp/syntax/parse.go:
(defn Parse
  "Parse parses a regular expression string s, controlled by the specified\nFlags, and returns a regular expression parse tree. The syntax is\ndescribed in the top-level comment.\n\nGo input arguments: (s string, flags Flags)\n\nGo return type: (*Regexp, error)\n\nJoker input arguments: [^String s, ^go.std.regexp.syntax/Flags flags]\n\nJoker return type: [(atom-of go.std.regexp.syntax/Regexp) Error]"
  {:added "1.0"
   :go "__parse(_s, *_flags)"}
  [^String _s, ^syntax/Flags _flags])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the regexp/syntax package."
    :empty false}
  go.std.regexp.syntax)
JOKER TYPE runtime.BlockProfileRecord from runtime/mprof.go:
(defn ^"GoObject" BlockProfileRecord.
  "Constructor for runtime.BlockProfileRecord"
  {:added "1.0"
   :go "_ConstructBlockProfileRecord(_v)"}
  [^Object _v])

JOKER TYPE runtime.Error from runtime/error.go:
;; (defn ^"GoObject" Error.
;;   "Constructor for runtime.Error"
;;   {:added "1.0"
;;    :go "_ConstructError(_v)"}
;;   [^Object _v])

JOKER TYPE runtime.Frame from runtime/symtab.go:
(defn ^"GoObject" Frame.
  "Constructor for runtime.Frame"
  {:added "1.0"
   :go "_ConstructFrame(_v)"}
  [^Object _v])

JOKER TYPE runtime.Frames from runtime/symtab.go:
(defn ^"GoObject" Frames.
  "Constructor for runtime.Frames"
  {:added "1.0"
   :go "_ConstructFrames(_v)"}
  [^Object _v])

JOKER TYPE runtime.Func from runtime/symtab.go:
(defn ^"GoObject" Func.
  "Constructor for runtime.Func"
  {:added "1.0"
   :go "_ConstructFunc(_v)"}
  [^Object _v])

JOKER TYPE runtime.MemProfileRecord from runtime/mprof.go:
(defn ^"GoObject" MemProfileRecord.
  "Constructor for runtime.MemProfileRecord"
  {:added "1.0"
   :go "_ConstructMemProfileRecord(_v)"}
  [^Object _v])

JOKER TYPE runtime.MemStats from runtime/mstats.go:
(defn ^"GoObject" MemStats.
  "Constructor for runtime.MemStats"
  {:added "1.0"
   :go "_ConstructMemStats(_v)"}
  [^Object _v])

JOKER TYPE runtime.StackRecord from runtime/mprof.go:
(defn ^"GoObject" StackRecord.
  "Constructor for runtime.StackRecord"
  {:added "1.0"
   :go "_ConstructStackRecord(_v)"}
  [^Object _v])

JOKER TYPE runtime.TypeAssertionError from runtime/error.go:
(defn ^"GoObject" TypeAssertionError.
  "Constructor for runtime.TypeAssertionError"
  {:added "1.0"
   :go "_ConstructTypeAssertionError(_v)"}
  [^Object _v])

JOKER FUNC runtime.BlockProfile from runtime/mprof.go:
;; (defn BlockProfile
;;   "BlockProfile returns n, the number of records in the current blocking profile.\nIf len(p) >= n, BlockProfile copies the profile into p and returns n, true.\nIf len(p) < n, BlockProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.blockprofile flag instead\nof calling BlockProfile directly.\n\nGo input arguments: (p []BlockProfileRecord)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of go.std.runtime/BlockProfileRecord) p]\n\nJoker return type: [Int Boolean]"
;;   {:added "1.0"
;;    :go "__blockProfile(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_runtime.BlockProfileRecord(*_p)))"}
;;   [^Object _p])

JOKER FUNC runtime.Breakpoint from runtime/proc.go:
;; (defn Breakpoint
;;   "Breakpoint executes a breakpoint trap.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__breakpoint()"}
;;   [])

JOKER FUNC runtime.CPUProfile from runtime/cpuprof.go:
(defn CPUProfile
  "CPUProfile panics.\nIt formerly provided raw access to chunks of\na pprof-format profile generated by the runtime.\nThe details of generating that format have changed,\nso this functionality has been removed.\n\nDeprecated: use the runtime/pprof package,\nor the handlers in the net/http/pprof package,\nor the testing package's -test.cpuprofile flag instead.\n\nGo return type: []byte\n\nJoker input arguments: []\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__cPUProfile()"}
  [])

JOKER FUNC runtime.Caller from runtime/extern.go:
(defn Caller
  "Caller reports file and line number information about function invocations on\nthe calling goroutine's stack. The argument skip is the number of stack frames\nto ascend, with 0 identifying the caller of Caller.  (For historical reasons the\nmeaning of skip differs between Caller and Callers.) The return values report the\nprogram counter, file name, and line number within the file of the corresponding\ncall. The boolean ok is false if it was not possible to recover the information.\n\nGo input arguments: (skip int)\n\nGo return type: (pc uintptr, file string, line int, ok bool)\n\nJoker input arguments: [^Int skip]\n\nJoker return type: [BigInt String Int Boolean]"
  {:added "1.0"
   :go "__caller(_skip)"}
  [^Int _skip])

JOKER FUNC runtime.Callers from runtime/extern.go:
;; (defn ^"Int" Callers
;;   "Callers fills the slice pc with the return program counters of function invocations\non the calling goroutine's stack. The argument skip is the number of stack frames\nto skip before recording in pc, with 0 identifying the frame for Callers itself and\n1 identifying the caller of Callers.\nIt returns the number of entries written to pc.\n\nTo translate these PCs into symbolic information such as function\nnames and line numbers, use CallersFrames. CallersFrames accounts\nfor inlined functions and adjusts the return program counters into\ncall program counters. Iterating over the returned slice of PCs\ndirectly is discouraged, as is using FuncForPC on any of the\nreturned PCs, since these cannot account for inlining or return\nprogram counter adjustment.\n\nGo input arguments: (skip int, pc []uintptr)\n\nGo return type: int\n\nJoker input arguments: [^Int skip, ^(vector-of UIntPtr) pc]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "runtime.Callers(_skip, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfuintptr(_pc)))"}
;;   [^Int _skip, ^Object _pc])

JOKER FUNC runtime.CallersFrames from runtime/symtab.go:
;; (defn CallersFrames
;;   "CallersFrames takes a slice of PC values returned by Callers and\nprepares to return function/file/line information.\nDo not change the slice until you are done with the Frames.\n\nGo input arguments: (callers []uintptr)\n\nGo return type: *Frames\n\nJoker input arguments: [^(vector-of UIntPtr) callers]\n\nJoker return type: (atom-of go.std.runtime/Frames)"
;;   {:added "1.0"
;;    :go "__callersFrames(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfuintptr(_callers)))"}
;;   [^Object _callers])

JOKER FUNC runtime.FuncForPC from runtime/symtab.go:
(defn FuncForPC
  "FuncForPC returns a *Func describing the function that contains the\ngiven program counter address, or else nil.\n\nIf pc represents multiple functions because of inlining, it returns\nthe *Func describing the outermost function.\n\nGo input arguments: (pc uintptr)\n\nGo return type: *Func\n\nJoker input arguments: [^UIntPtr pc]\n\nJoker return type: (atom-of go.std.runtime/Func)"
  {:added "1.0"
   :go "__funcForPC(_pc)"}
  [^UIntPtr _pc])

JOKER FUNC runtime.GC from runtime/mgc.go:
;; (defn GC
;;   "GC runs a garbage collection and blocks the caller until the\ngarbage collection is complete. It may also block the entire\nprogram.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__gC()"}
;;   [])

JOKER FUNC runtime.GOMAXPROCS from runtime/debug.go:
(defn ^"Int" GOMAXPROCS
  "GOMAXPROCS sets the maximum number of CPUs that can be executing\nsimultaneously and returns the previous setting. If n < 1, it does not\nchange the current setting.\nThe number of logical CPUs on the local machine can be queried with NumCPU.\nThis call will go away when the scheduler improves.\n\nGo input arguments: (n int)\n\nGo return type: int\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.GOMAXPROCS(_n)"}
  [^Int _n])

JOKER FUNC runtime.GOROOT from runtime/extern.go:
(defn ^"String" GOROOT
  "GOROOT returns the root of the Go tree. It uses the\nGOROOT environment variable, if set at process start,\nor else the root used during the Go build.\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "runtime.GOROOT()"}
  [])

JOKER FUNC runtime.Goexit from runtime/panic.go:
;; (defn Goexit
;;   "Goexit terminates the goroutine that calls it. No other goroutine is affected.\nGoexit runs all deferred calls before terminating the goroutine. Because Goexit\nis not a panic, any recover calls in those deferred functions will return nil.\n\nCalling Goexit from the main goroutine terminates that goroutine\nwithout func main returning. Since func main has not returned,\nthe program continues execution of other goroutines.\nIf all other goroutines exit, the program crashes.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__goexit()"}
;;   [])

JOKER FUNC runtime.GoroutineProfile from runtime/mprof.go:
;; (defn GoroutineProfile
;;   "GoroutineProfile returns n, the number of records in the active goroutine stack profile.\nIf len(p) >= n, GoroutineProfile copies the profile into p and returns n, true.\nIf len(p) < n, GoroutineProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package instead\nof calling GoroutineProfile directly.\n\nGo input arguments: (p []StackRecord)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of go.std.runtime/StackRecord) p]\n\nJoker return type: [Int Boolean]"
;;   {:added "1.0"
;;    :go "__goroutineProfile(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_runtime.StackRecord(*_p)))"}
;;   [^Object _p])

JOKER FUNC runtime.Gosched from runtime/proc.go:
;; (defn Gosched
;;   "Gosched yields the processor, allowing other goroutines to run. It does not\nsuspend the current goroutine, so execution resumes automatically.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__gosched()"}
;;   [])

JOKER FUNC runtime.KeepAlive from runtime/mfinal.go:
;; (defn KeepAlive
;;   "KeepAlive marks its argument as currently reachable.\nThis ensures that the object is not freed, and its finalizer is not run,\nbefore the point in the program where KeepAlive is called.\n\nA very simplified example showing where KeepAlive is required:\n\ttype File struct { d int }\n\td, err := syscall.Open(\"/file/path\", syscall.O_RDONLY, 0)\n\t// ... do something if err != nil ...\n\tp := &File{d}\n\truntime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })\n\tvar buf [10]byte\n\tn, err := syscall.Read(p.d, buf[:])\n\t// Ensure p is not finalized until Read returns.\n\truntime.KeepAlive(p)\n\t// No more uses of p after this point.\n\nWithout the KeepAlive call, the finalizer could run at the start of\nsyscall.Read, closing the file descriptor before syscall.Read makes\nthe actual system call.\n\nGo input arguments: (x interface {})\n\nJoker input arguments: [^<protocol-or-something> x]"
;;   {:added "1.0"
;;    :go "__keepAlive(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _x])

JOKER FUNC runtime.LockOSThread from runtime/proc.go:
;; (defn LockOSThread
;;   "LockOSThread wires the calling goroutine to its current operating system thread.\nThe calling goroutine will always execute in that thread,\nand no other goroutine will execute in it,\nuntil the calling goroutine has made as many calls to\nUnlockOSThread as to LockOSThread.\nIf the calling goroutine exits without unlocking the thread,\nthe thread will be terminated.\n\nAll init functions are run on the startup thread. Calling LockOSThread\nfrom an init function will cause the main function to be invoked on\nthat thread.\n\nA goroutine should call LockOSThread before calling OS services or\nnon-Go library functions that depend on per-thread state.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__lockOSThread()"}
;;   [])

JOKER FUNC runtime.MemProfile from runtime/mprof.go:
;; (defn MemProfile
;;   "MemProfile returns a profile of memory allocated and freed per allocation\nsite.\n\nMemProfile returns n, the number of records in the current memory profile.\nIf len(p) >= n, MemProfile copies the profile into p and returns n, true.\nIf len(p) < n, MemProfile does not change p and returns n, false.\n\nIf inuseZero is true, the profile includes allocation records\nwhere r.AllocBytes > 0 but r.AllocBytes == r.FreeBytes.\nThese are sites where memory was allocated, but it has all\nbeen released back to the runtime.\n\nThe returned profile may be up to two garbage collection cycles old.\nThis is to avoid skewing the profile toward allocations; because\nallocations happen in real time but frees are delayed until the garbage\ncollector performs sweeping, the profile only accounts for allocations\nthat have had a chance to be freed by the garbage collector.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.memprofile flag instead\nof calling MemProfile directly.\n\nGo input arguments: (p []MemProfileRecord, inuseZero bool)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of go.std.runtime/MemProfileRecord) p, ^Boolean inuseZero]\n\nJoker return type: [Int Boolean]"
;;   {:added "1.0"
;;    :go "__memProfile(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_runtime.MemProfileRecord(*_p)), _inuseZero)"}
;;   [^Object _p, ^Boolean _inuseZero])

JOKER FUNC runtime.MutexProfile from runtime/mprof.go:
;; (defn MutexProfile
;;   "MutexProfile returns n, the number of records in the current mutex profile.\nIf len(p) >= n, MutexProfile copies the profile into p and returns n, true.\nOtherwise, MutexProfile does not change p, and returns n, false.\n\nMost clients should use the runtime/pprof package\ninstead of calling MutexProfile directly.\n\nGo input arguments: (p []BlockProfileRecord)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of go.std.runtime/BlockProfileRecord) p]\n\nJoker return type: [Int Boolean]"
;;   {:added "1.0"
;;    :go "__mutexProfile(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_runtime.BlockProfileRecord(*_p)))"}
;;   [^Object _p])

JOKER FUNC runtime.NumCPU from runtime/debug.go:
(defn ^"Int" NumCPU
  "NumCPU returns the number of logical CPUs usable by the current process.\n\nThe set of available CPUs is checked by querying the operating system\nat process startup. Changes to operating system CPU allocation after\nprocess startup are not reflected.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.NumCPU()"}
  [])

JOKER FUNC runtime.NumCgoCall from runtime/debug.go:
(defn NumCgoCall
  "NumCgoCall returns the number of cgo calls made by the current process.\n\nGo return type: int64\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "__numCgoCall()"}
  [])

JOKER FUNC runtime.NumGoroutine from runtime/debug.go:
(defn ^"Int" NumGoroutine
  "NumGoroutine returns the number of goroutines that currently exist.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.NumGoroutine()"}
  [])

JOKER FUNC runtime.ReadMemStats from runtime/mstats.go:
;; (defn ReadMemStats
;;   "ReadMemStats populates m with memory allocator statistics.\n\nThe returned memory allocator statistics are up to date as of the\ncall to ReadMemStats. This is in contrast with a heap profile,\nwhich is a snapshot as of the most recently completed garbage\ncollection cycle.\n\nGo input arguments: (m *MemStats)\n\nJoker input arguments: [^(atom-of go.std.runtime/MemStats) m]"
;;   {:added "1.0"
;;    :go "__readMemStats(_m)"}
;;   [^runtime/MemStats _m])

JOKER FUNC runtime.ReadTrace from runtime/trace.go:
(defn ReadTrace
  "ReadTrace returns the next chunk of binary tracing data, blocking until data\nis available. If tracing is turned off and all the data accumulated while it\nwas on has been returned, ReadTrace returns nil. The caller must copy the\nreturned data before calling ReadTrace again.\nReadTrace must be called from one goroutine at a time.\n\nGo return type: []byte\n\nJoker input arguments: []\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__readTrace()"}
  [])

JOKER FUNC runtime.SetBlockProfileRate from runtime/mprof.go:
;; (defn SetBlockProfileRate
;;   "SetBlockProfileRate controls the fraction of goroutine blocking events\nthat are reported in the blocking profile. The profiler aims to sample\nan average of one blocking event per rate nanoseconds spent blocked.\n\nTo include every blocking event in the profile, pass rate = 1.\nTo turn off profiling entirely, pass rate <= 0.\n\nGo input arguments: (rate int)\n\nJoker input arguments: [^Int rate]"
;;   {:added "1.0"
;;    :go "__setBlockProfileRate(_rate)"}
;;   [^Int _rate])

JOKER FUNC runtime.SetCPUProfileRate from runtime/cpuprof.go:
;; (defn SetCPUProfileRate
;;   "SetCPUProfileRate sets the CPU profiling rate to hz samples per second.\nIf hz <= 0, SetCPUProfileRate turns off profiling.\nIf the profiler is on, the rate cannot be changed without first turning it off.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.cpuprofile flag instead of calling\nSetCPUProfileRate directly.\n\nGo input arguments: (hz int)\n\nJoker input arguments: [^Int hz]"
;;   {:added "1.0"
;;    :go "__setCPUProfileRate(_hz)"}
;;   [^Int _hz])

JOKER FUNC runtime.SetCgoTraceback from runtime/traceback.go:
;; (defn SetCgoTraceback
;;   "SetCgoTraceback records three C functions to use to gather\ntraceback information from C code and to convert that traceback\ninformation into symbolic information. These are used when printing\nstack traces for a program that uses cgo.\n\nThe traceback and context functions may be called from a signal\nhandler, and must therefore use only async-signal safe functions.\nThe symbolizer function may be called while the program is\ncrashing, and so must be cautious about using memory.  None of the\nfunctions may call back into Go.\n\nThe context function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tContext uintptr\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t Context;\n\t};\n\nIf the Context field is 0, the context function is being called to\nrecord the current traceback context. It should record in the\nContext field whatever information is needed about the current\npoint of execution to later produce a stack trace, probably the\nstack pointer and PC. In this case the context function will be\ncalled from C code.\n\nIf the Context field is not 0, then it is a value returned by a\nprevious call to the context function. This case is called when the\ncontext is no longer needed; that is, when the Go code is returning\nto its C code caller. This permits the context function to release\nany associated resources.\n\nWhile it would be correct for the context function to record a\ncomplete a stack trace whenever it is called, and simply copy that\nout in the traceback function, in a typical program the context\nfunction will be called many times without ever recording a\ntraceback for that context. Recording a complete stack trace in a\ncall to the context function is likely to be inefficient.\n\nThe traceback function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tContext    uintptr\n\t\tSigContext uintptr\n\t\tBuf        *uintptr\n\t\tMax        uintptr\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t  Context;\n\t\tuintptr_t  SigContext;\n\t\tuintptr_t* Buf;\n\t\tuintptr_t  Max;\n\t};\n\nThe Context field will be zero to gather a traceback from the\ncurrent program execution point. In this case, the traceback\nfunction will be called from C code.\n\nOtherwise Context will be a value previously returned by a call to\nthe context function. The traceback function should gather a stack\ntrace from that saved point in the program execution. The traceback\nfunction may be called from an execution thread other than the one\nthat recorded the context, but only when the context is known to be\nvalid and unchanging. The traceback function may also be called\ndeeper in the call stack on the same thread that recorded the\ncontext. The traceback function may be called multiple times with\nthe same Context value; it will usually be appropriate to cache the\nresult, if possible, the first time this is called for a specific\ncontext value.\n\nIf the traceback function is called from a signal handler on a Unix\nsystem, SigContext will be the signal context argument passed to\nthe signal handler (a C ucontext_t* cast to uintptr_t). This may be\nused to start tracing at the point where the signal occurred. If\nthe traceback function is not called from a signal handler,\nSigContext will be zero.\n\nBuf is where the traceback information should be stored. It should\nbe PC values, such that Buf[0] is the PC of the caller, Buf[1] is\nthe PC of that function's caller, and so on.  Max is the maximum\nnumber of entries to store.  The function should store a zero to\nindicate the top of the stack, or that the caller is on a different\nstack, presumably a Go stack.\n\nUnlike runtime.Callers, the PC values returned should, when passed\nto the symbolizer function, return the file/line of the call\ninstruction.  No additional subtraction is required or appropriate.\n\nOn all platforms, the traceback function is invoked when a call from\nGo to C to Go requests a stack trace. On linux/amd64, linux/ppc64le,\nand freebsd/amd64, the traceback function is also invoked when a\nsignal is received by a thread that is executing a cgo call. The\ntraceback function should not make assumptions about when it is\ncalled, as future versions of Go may make additional calls.\n\nThe symbolizer function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tPC      uintptr // program counter to fetch information for\n\t\tFile    *byte   // file name (NUL terminated)\n\t\tLineno  uintptr // line number\n\t\tFunc    *byte   // function name (NUL terminated)\n\t\tEntry   uintptr // function entry point\n\t\tMore    uintptr // set non-zero if more info for this PC\n\t\tData    uintptr // unused by runtime, available for function\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t PC;\n\t\tchar*     File;\n\t\tuintptr_t Lineno;\n\t\tchar*     Func;\n\t\tuintptr_t Entry;\n\t\tuintptr_t More;\n\t\tuintptr_t Data;\n\t};\n\nThe PC field will be a value returned by a call to the traceback\nfunction.\n\nThe first time the function is called for a particular traceback,\nall the fields except PC will be 0. The function should fill in the\nother fields if possible, setting them to 0/nil if the information\nis not available. The Data field may be used to store any useful\ninformation across calls. The More field should be set to non-zero\nif there is more information for this PC, zero otherwise. If More\nis set non-zero, the function will be called again with the same\nPC, and may return different information (this is intended for use\nwith inlined functions). If More is zero, the function will be\ncalled with the next PC value in the traceback. When the traceback\nis complete, the function will be called once more with PC set to\nzero; this may be used to free any information. Each call will\nleave the fields of the struct set to the same values they had upon\nreturn, except for the PC field when the More field is zero. The\nfunction must not keep a copy of the struct pointer between calls.\n\nWhen calling SetCgoTraceback, the version argument is the version\nnumber of the structs that the functions expect to receive.\nCurrently this must be zero.\n\nThe symbolizer function may be nil, in which case the results of\nthe traceback function will be displayed as numbers. If the\ntraceback function is nil, the symbolizer function will never be\ncalled. The context function may be nil, in which case the\ntraceback function will only be called with the context field set\nto zero.  If the context function is nil, then calls from Go to C\nto Go will not show a traceback for the C portion of the call stack.\n\nSetCgoTraceback should be called only once, ideally from an init function.\n\nGo input arguments: (version int, traceback unsafe.Pointer, context unsafe.Pointer, symbolizer unsafe.Pointer)\n\nJoker input arguments: [^Int version, ^go.std.unsafe/Pointer traceback, ^go.std.unsafe/Pointer context, ^go.std.unsafe/Pointer symbolizer]"
;;   {:added "1.0"
;;    :go "__setCgoTraceback(_version, *_traceback, *_context, *_symbolizer)"}
;;   [^Int _version, ^unsafe/Pointer _traceback, ^unsafe/Pointer _context, ^unsafe/Pointer _symbolizer])

JOKER FUNC runtime.SetFinalizer from runtime/mfinal.go:
;; (defn SetFinalizer
;;   "SetFinalizer sets the finalizer associated with obj to the provided\nfinalizer function. When the garbage collector finds an unreachable block\nwith an associated finalizer, it clears the association and runs\nfinalizer(obj) in a separate goroutine. This makes obj reachable again,\nbut now without an associated finalizer. Assuming that SetFinalizer\nis not called again, the next time the garbage collector sees\nthat obj is unreachable, it will free obj.\n\nSetFinalizer(obj, nil) clears any finalizer associated with obj.\n\nThe argument obj must be a pointer to an object allocated by calling\nnew, by taking the address of a composite literal, or by taking the\naddress of a local variable.\nThe argument finalizer must be a function that takes a single argument\nto which obj's type can be assigned, and can have arbitrary ignored return\nvalues. If either of these is not true, SetFinalizer may abort the\nprogram.\n\nFinalizers are run in dependency order: if A points at B, both have\nfinalizers, and they are otherwise unreachable, only the finalizer\nfor A runs; once A is freed, the finalizer for B can run.\nIf a cyclic structure includes a block with a finalizer, that\ncycle is not guaranteed to be garbage collected and the finalizer\nis not guaranteed to run, because there is no ordering that\nrespects the dependencies.\n\nThe finalizer is scheduled to run at some arbitrary time after the\nprogram can no longer reach the object to which obj points.\nThere is no guarantee that finalizers will run before a program exits,\nso typically they are useful only for releasing non-memory resources\nassociated with an object during a long-running program.\nFor example, an os.File object could use a finalizer to close the\nassociated operating system file descriptor when a program discards\nan os.File without calling Close, but it would be a mistake\nto depend on a finalizer to flush an in-memory I/O buffer such as a\nbufio.Writer, because the buffer would not be flushed at program exit.\n\nIt is not guaranteed that a finalizer will run if the size of *obj is\nzero bytes.\n\nIt is not guaranteed that a finalizer will run for objects allocated\nin initializers for package-level variables. Such objects may be\nlinker-allocated, not heap-allocated.\n\nA finalizer may run as soon as an object becomes unreachable.\nIn order to use finalizers correctly, the program must ensure that\nthe object is reachable until it is no longer required.\nObjects stored in global variables, or that can be found by tracing\npointers from a global variable, are reachable. For other objects,\npass the object to a call of the KeepAlive function to mark the\nlast point in the function where the object must be reachable.\n\nFor example, if p points to a struct that contains a file descriptor d,\nand p has a finalizer that closes that file descriptor, and if the last\nuse of p in a function is a call to syscall.Write(p.d, buf, size), then\np may be unreachable as soon as the program enters syscall.Write. The\nfinalizer may run at that moment, closing p.d, causing syscall.Write\nto fail because it is writing to a closed file descriptor (or, worse,\nto an entirely different file descriptor opened by a different goroutine).\nTo avoid this problem, call runtime.KeepAlive(p) after the call to\nsyscall.Write.\n\nA single goroutine runs all finalizers for a program, sequentially.\nIf a finalizer must run for a long time, it should do so by starting\na new goroutine.\n\nGo input arguments: (obj interface {}, finalizer interface {})\n\nJoker input arguments: [^<protocol-or-something> obj, ^<protocol-or-something> finalizer]"
;;   {:added "1.0"
;;    :go "__setFinalizer(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _obj, ^<protocol-or-something> _finalizer])

JOKER FUNC runtime.SetMutexProfileFraction from runtime/mprof.go:
(defn ^"Int" SetMutexProfileFraction
  "SetMutexProfileFraction controls the fraction of mutex contention events\nthat are reported in the mutex profile. On average 1/rate events are\nreported. The previous rate is returned.\n\nTo turn off profiling entirely, pass rate 0.\nTo just read the current rate, pass rate < 0.\n(For n>1 the details of sampling may change.)\n\nGo input arguments: (rate int)\n\nGo return type: int\n\nJoker input arguments: [^Int rate]\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.SetMutexProfileFraction(_rate)"}
  [^Int _rate])

JOKER FUNC runtime.Stack from runtime/mprof.go:
;; (defn ^"Int" Stack
;;   "Stack formats a stack trace of the calling goroutine into buf\nand returns the number of bytes written to buf.\nIf all is true, Stack formats stack traces of all other goroutines\ninto buf after the trace for the current goroutine.\n\nGo input arguments: (buf []byte, all bool)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) buf, ^Boolean all]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "runtime.Stack(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)), _all)"}
;;   [^Object _buf, ^Boolean _all])

JOKER FUNC runtime.StartTrace from runtime/trace.go:
(defn ^"Error" StartTrace
  "StartTrace enables tracing for the current process.\nWhile tracing, the data will be buffered and available via ReadTrace.\nStartTrace returns an error if tracing is already enabled.\nMost clients should use the runtime/trace package or the testing package's\n-test.trace flag instead of calling StartTrace directly.\n\nGo return type: error\n\nJoker input arguments: []\n\nJoker return type: Error"
  {:added "1.0"
   :go "runtime.StartTrace()"}
  [])

JOKER FUNC runtime.StopTrace from runtime/trace.go:
;; (defn StopTrace
;;   "StopTrace stops tracing, if it was previously enabled.\nStopTrace only returns after all the reads for the trace have completed.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__stopTrace()"}
;;   [])

JOKER FUNC runtime.ThreadCreateProfile from runtime/mprof.go:
;; (defn ThreadCreateProfile
;;   "ThreadCreateProfile returns n, the number of records in the thread creation profile.\nIf len(p) >= n, ThreadCreateProfile copies the profile into p and returns n, true.\nIf len(p) < n, ThreadCreateProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package instead\nof calling ThreadCreateProfile directly.\n\nGo input arguments: (p []StackRecord)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of go.std.runtime/StackRecord) p]\n\nJoker return type: [Int Boolean]"
;;   {:added "1.0"
;;    :go "__threadCreateProfile(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_runtime.StackRecord(*_p)))"}
;;   [^Object _p])

JOKER FUNC runtime.UnlockOSThread from runtime/proc.go:
;; (defn UnlockOSThread
;;   "UnlockOSThread undoes an earlier call to LockOSThread.\nIf this drops the number of active LockOSThread calls on the\ncalling goroutine to zero, it unwires the calling goroutine from\nits fixed operating system thread.\nIf there are no active LockOSThread calls, this is a no-op.\n\nBefore calling UnlockOSThread, the caller must ensure that the OS\nthread is suitable for running other goroutines. If the caller made\nany permanent changes to the state of the thread that would affect\nother goroutines, it should not call this function and thus leave\nthe goroutine locked to the OS thread until the goroutine (and\nhence the thread) exits.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__unlockOSThread()"}
;;   [])

JOKER FUNC runtime.Version from runtime/extern.go:
(defn ^"String" Version
  "Version returns the Go tree's version string.\nIt is either the commit hash and date at the time of the build or,\nwhen possible, a release tag like \"go1.3\".\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "runtime.Version()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["runtime"]
    :doc "Provides a low-level interface to the runtime package."
    :empty false}
  go.std.runtime)
JOKER TYPE runtime/debug.GCStats from runtime/debug/garbage.go:
(defn ^"GoObject" GCStats.
  "Constructor for debug.GCStats"
  {:added "1.0"
   :go "_ConstructGCStats(_v)"}
  [^Object _v])

JOKER FUNC runtime/debug.FreeOSMemory from runtime/debug/garbage.go:
;; (defn FreeOSMemory
;;   "FreeOSMemory forces a garbage collection followed by an\nattempt to return as much memory to the operating system\nas possible. (Even if this is not called, the runtime gradually\nreturns memory to the operating system in a background task.)\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__freeOSMemory()"}
;;   [])

JOKER FUNC runtime/debug.PrintStack from runtime/debug/stack.go:
;; (defn PrintStack
;;   "PrintStack prints to standard error the stack trace returned by runtime.Stack.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__printStack()"}
;;   [])

JOKER FUNC runtime/debug.ReadGCStats from runtime/debug/garbage.go:
;; (defn ReadGCStats
;;   "ReadGCStats reads statistics about garbage collection into stats.\nThe number of entries in the pause history is system-dependent;\nstats.Pause slice will be reused if large enough, reallocated otherwise.\nReadGCStats may use the full capacity of the stats.Pause slice.\nIf stats.PauseQuantiles is non-empty, ReadGCStats fills it with quantiles\nsummarizing the distribution of pause time. For example, if\nlen(stats.PauseQuantiles) is 5, it will be filled with the minimum,\n25%, 50%, 75%, and maximum pause times.\n\nGo input arguments: (stats *GCStats)\n\nJoker input arguments: [^(atom-of go.std.runtime.debug/GCStats) stats]"
;;   {:added "1.0"
;;    :go "__readGCStats(_stats)"}
;;   [^debug/GCStats _stats])

JOKER FUNC runtime/debug.SetGCPercent from runtime/debug/garbage.go:
(defn ^"Int" SetGCPercent
  "SetGCPercent sets the garbage collection target percentage:\na collection is triggered when the ratio of freshly allocated data\nto live data remaining after the previous collection reaches this percentage.\nSetGCPercent returns the previous setting.\nThe initial setting is the value of the GOGC environment variable\nat startup, or 100 if the variable is not set.\nA negative percentage disables garbage collection.\n\nGo input arguments: (percent int)\n\nGo return type: int\n\nJoker input arguments: [^Int percent]\n\nJoker return type: Int"
  {:added "1.0"
   :go "debug.SetGCPercent(_percent)"}
  [^Int _percent])

JOKER FUNC runtime/debug.SetMaxStack from runtime/debug/garbage.go:
(defn ^"Int" SetMaxStack
  "SetMaxStack sets the maximum amount of memory that\ncan be used by a single goroutine stack.\nIf any goroutine exceeds this limit while growing its stack,\nthe program crashes.\nSetMaxStack returns the previous setting.\nThe initial setting is 1 GB on 64-bit systems, 250 MB on 32-bit systems.\n\nSetMaxStack is useful mainly for limiting the damage done by\ngoroutines that enter an infinite recursion. It only limits future\nstack growth.\n\nGo input arguments: (bytes int)\n\nGo return type: int\n\nJoker input arguments: [^Int bytes]\n\nJoker return type: Int"
  {:added "1.0"
   :go "debug.SetMaxStack(_bytes)"}
  [^Int _bytes])

JOKER FUNC runtime/debug.SetMaxThreads from runtime/debug/garbage.go:
(defn ^"Int" SetMaxThreads
  "SetMaxThreads sets the maximum number of operating system\nthreads that the Go program can use. If it attempts to use more than\nthis many, the program crashes.\nSetMaxThreads returns the previous setting.\nThe initial setting is 10,000 threads.\n\nThe limit controls the number of operating system threads, not the number\nof goroutines. A Go program creates a new thread only when a goroutine\nis ready to run but all the existing threads are blocked in system calls, cgo calls,\nor are locked to other goroutines due to use of runtime.LockOSThread.\n\nSetMaxThreads is useful mainly for limiting the damage done by\nprograms that create an unbounded number of threads. The idea is\nto take down the program before it takes down the operating system.\n\nGo input arguments: (threads int)\n\nGo return type: int\n\nJoker input arguments: [^Int threads]\n\nJoker return type: Int"
  {:added "1.0"
   :go "debug.SetMaxThreads(_threads)"}
  [^Int _threads])

JOKER FUNC runtime/debug.SetPanicOnFault from runtime/debug/garbage.go:
(defn ^"Boolean" SetPanicOnFault
  "SetPanicOnFault controls the runtime's behavior when a program faults\nat an unexpected (non-nil) address. Such faults are typically caused by\nbugs such as runtime memory corruption, so the default response is to crash\nthe program. Programs working with memory-mapped files or unsafe\nmanipulation of memory may cause faults at non-nil addresses in less\ndramatic situations; SetPanicOnFault allows such programs to request\nthat the runtime trigger only a panic, not a crash.\nSetPanicOnFault applies only to the current goroutine.\nIt returns the previous setting.\n\nGo input arguments: (enabled bool)\n\nGo return type: bool\n\nJoker input arguments: [^Boolean enabled]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "debug.SetPanicOnFault(_enabled)"}
  [^Boolean _enabled])

JOKER FUNC runtime/debug.SetTraceback from runtime/debug/garbage.go:
;; (defn SetTraceback
;;   "SetTraceback sets the amount of detail printed by the runtime in\nthe traceback it prints before exiting due to an unrecovered panic\nor an internal runtime error.\nThe level argument takes the same values as the GOTRACEBACK\nenvironment variable. For example, SetTraceback(\"all\") ensure\nthat the program prints all goroutines when it crashes.\nSee the package runtime documentation for details.\nIf SetTraceback is called with a level lower than that of the\nenvironment variable, the call is ignored.\n\nGo input arguments: (level string)\n\nJoker input arguments: [^String level]"
;;   {:added "1.0"
;;    :go "__setTraceback(_level)"}
;;   [^String _level])

JOKER FUNC runtime/debug.Stack from runtime/debug/stack.go:
(defn Stack
  "Stack returns a formatted stack trace of the goroutine that calls it.\nIt calls runtime.Stack with a large enough buffer to capture the entire trace.\n\nGo return type: []byte\n\nJoker input arguments: []\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__stack()"}
  [])

JOKER FUNC runtime/debug.WriteHeapDump from runtime/debug/garbage.go:
;; (defn WriteHeapDump
;;   "WriteHeapDump writes a description of the heap and the objects in\nit to the given file descriptor.\n\nWriteHeapDump suspends the execution of all goroutines until the heap\ndump is completely written.  Thus, the file descriptor must not be\nconnected to a pipe or socket whose other end is in the same Go\nprocess; instead, use a temporary file or network socket.\n\nThe heap dump format is defined at https://golang.org/s/go15heapdump.\n\nGo input arguments: (fd uintptr)\n\nJoker input arguments: [^UIntPtr fd]"
;;   {:added "1.0"
;;    :go "__writeHeapDump(_fd)"}
;;   [^UIntPtr _fd])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["runtime/debug"]
    :doc "Provides a low-level interface to the runtime/debug package."
    :empty false}
  go.std.runtime.debug)
JOKER TYPE runtime/pprof.LabelSet from runtime/pprof/label.go:
(defn ^"GoObject" LabelSet.
  "Constructor for pprof.LabelSet"
  {:added "1.0"
   :go "_ConstructLabelSet(_v)"}
  [^Object _v])

JOKER TYPE runtime/pprof.Profile from runtime/pprof/pprof.go:
(defn ^"GoObject" Profile.
  "Constructor for pprof.Profile"
  {:added "1.0"
   :go "_ConstructProfile(_v)"}
  [^Object _v])

JOKER FUNC runtime/pprof.Do from runtime/pprof/runtime.go:
;; (defn Do
;;   "Do calls f with a copy of the parent context with the\ngiven labels added to the parent's label map.\nEach key/value pair in labels is inserted into the label map in the\norder provided, overriding any previous value for the same key.\nThe augmented label map will be set for the duration of the call to f\nand restored once f returns.\n\nGo input arguments: (ctx context.Context, labels LabelSet, f func)\n\nJoker input arguments: [^go.std.context/Context ctx, ^go.std.runtime.pprof/LabelSet labels, ^fn f]"
;;   {:added "1.0"
;;    :go "__do(*_ctx, *_labels, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^context/Context _ctx, ^pprof/LabelSet _labels, ^fn _f])

JOKER FUNC runtime/pprof.ForLabels from runtime/pprof/label.go:
;; (defn ForLabels
;;   "ForLabels invokes f with each label set on the context.\nThe function f should return true to continue iteration or false to stop iteration early.\n\nGo input arguments: (ctx context.Context, f func)\n\nJoker input arguments: [^go.std.context/Context ctx, ^fn f]"
;;   {:added "1.0"
;;    :go "__forLabels(*_ctx, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^context/Context _ctx, ^fn _f])

JOKER FUNC runtime/pprof.Label from runtime/pprof/label.go:
;; (defn Label
;;   "Label returns the value of the label with the given key on ctx, and a boolean indicating\nwhether that label exists.\n\nGo input arguments: (ctx context.Context, key string)\n\nGo return type: (string, bool)\n\nJoker input arguments: [^go.std.context/Context ctx, ^String key]\n\nJoker return type: [String Boolean]"
;;   {:added "1.0"
;;    :go "__label(*_ctx, _key)"}
;;   [^context/Context _ctx, ^String _key])

JOKER FUNC runtime/pprof.Labels from runtime/pprof/label.go:
;; (defn Labels
;;   "Labels takes an even number of strings representing key-value pairs\nand makes a LabelSet containing them.\nA label overwrites a prior label with the same key.\n\nGo input arguments: (args ...string)\n\nGo return type: LabelSet\n\nJoker input arguments: [^(ellipsis-somehow String) args]\n\nJoker return type: go.std.runtime.pprof/LabelSet"
;;   {:added "1.0"
;;    :go "__labels(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(_args)))"}
;;   [^String _args])

JOKER FUNC runtime/pprof.Lookup from runtime/pprof/pprof.go:
(defn Lookup
  "Lookup returns the profile with the given name, or nil if no such profile exists.\n\nGo input arguments: (name string)\n\nGo return type: *Profile\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.runtime.pprof/Profile)"
  {:added "1.0"
   :go "__lookup(_name)"}
  [^String _name])

JOKER FUNC runtime/pprof.NewProfile from runtime/pprof/pprof.go:
(defn NewProfile
  "NewProfile creates a new profile with the given name.\nIf a profile with that name already exists, NewProfile panics.\nThe convention is to use a 'import/path.' prefix to create\nseparate name spaces for each package.\nFor compatibility with various tools that read pprof data,\nprofile names should not contain spaces.\n\nGo input arguments: (name string)\n\nGo return type: *Profile\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.runtime.pprof/Profile)"
  {:added "1.0"
   :go "__newProfile(_name)"}
  [^String _name])

JOKER FUNC runtime/pprof.Profiles from runtime/pprof/pprof.go:
(defn Profiles
  "Profiles returns a slice of all the known profiles, sorted by name.\n\nGo return type: []*Profile\n\nJoker input arguments: []\n\nJoker return type: (vector-of (atom-of go.std.runtime.pprof/Profile))"
  {:added "1.0"
   :go "__profiles()"}
  [])

JOKER FUNC runtime/pprof.SetGoroutineLabels from runtime/pprof/runtime.go:
;; (defn SetGoroutineLabels
;;   "SetGoroutineLabels sets the current goroutine's labels to match ctx.\nThis is a lower-level API than Do, which should be used instead when possible.\n\nGo input arguments: (ctx context.Context)\n\nJoker input arguments: [^go.std.context/Context ctx]"
;;   {:added "1.0"
;;    :go "__setGoroutineLabels(*_ctx)"}
;;   [^context/Context _ctx])

JOKER FUNC runtime/pprof.StartCPUProfile from runtime/pprof/pprof.go:
;; (defn ^"Error" StartCPUProfile
;;   "StartCPUProfile enables CPU profiling for the current process.\nWhile profiling, the profile will be buffered and written to w.\nStartCPUProfile returns an error if profiling is already enabled.\n\nOn Unix-like systems, StartCPUProfile does not work by default for\nGo code built with -buildmode=c-archive or -buildmode=c-shared.\nStartCPUProfile relies on the SIGPROF signal, but that signal will\nbe delivered to the main program's SIGPROF signal handler (if any)\nnot to the one used by Go. To make it work, call os/signal.Notify\nfor syscall.SIGPROF, but note that doing so may break any profiling\nbeing done by the main program.\n\nGo input arguments: (w io.Writer)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "pprof.StartCPUProfile(*_w)"}
;;   [^io/Writer _w])

JOKER FUNC runtime/pprof.StopCPUProfile from runtime/pprof/pprof.go:
;; (defn StopCPUProfile
;;   "StopCPUProfile stops the current CPU profile, if any.\nStopCPUProfile only returns after all the writes for the\nprofile have completed.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__stopCPUProfile()"}
;;   [])

JOKER FUNC runtime/pprof.WithLabels from runtime/pprof/label.go:
;; (defn WithLabels
;;   "WithLabels returns a new context.Context with the given labels added.\nA label overwrites a prior label with the same key.\n\nGo input arguments: (ctx context.Context, labels LabelSet)\n\nGo return type: context.Context\n\nJoker input arguments: [^go.std.context/Context ctx, ^go.std.runtime.pprof/LabelSet labels]\n\nJoker return type: go.std.context/Context"
;;   {:added "1.0"
;;    :go "__withLabels(*_ctx, *_labels)"}
;;   [^context/Context _ctx, ^pprof/LabelSet _labels])

JOKER FUNC runtime/pprof.WriteHeapProfile from runtime/pprof/pprof.go:
;; (defn ^"Error" WriteHeapProfile
;;   "WriteHeapProfile is shorthand for Lookup(\"heap\").WriteTo(w, 0).\nIt is preserved for backwards compatibility.\n\nGo input arguments: (w io.Writer)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "pprof.WriteHeapProfile(*_w)"}
;;   [^io/Writer _w])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the runtime/pprof package."
    :empty false}
  go.std.runtime.pprof)
JOKER TYPE runtime/trace.Region from runtime/trace/annotation.go:
(defn ^"GoObject" Region.
  "Constructor for trace.Region"
  {:added "1.0"
   :go "_ConstructRegion(_v)"}
  [^Object _v])

JOKER TYPE runtime/trace.Task from runtime/trace/annotation.go:
(defn ^"GoObject" Task.
  "Constructor for trace.Task"
  {:added "1.0"
   :go "_ConstructTask(_v)"}
  [^Object _v])

JOKER FUNC runtime/trace.IsEnabled from runtime/trace/annotation.go:
(defn ^"Boolean" IsEnabled
  "IsEnabled returns whether tracing is enabled.\nThe information is advisory only. The tracing status\nmay have changed by the time this function returns.\n\nGo return type: bool\n\nJoker input arguments: []\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "trace.IsEnabled()"}
  [])

JOKER FUNC runtime/trace.Log from runtime/trace/annotation.go:
;; (defn Log
;;   "Log emits a one-off event with the given category and message.\nCategory can be empty and the API assumes there are only a handful of\nunique categories in the system.\n\nGo input arguments: (ctx context.Context, category string, message string)\n\nJoker input arguments: [^go.std.context/Context ctx, ^String category, ^String message]"
;;   {:added "1.0"
;;    :go "__log(*_ctx, _category, _message)"}
;;   [^context/Context _ctx, ^String _category, ^String _message])

JOKER FUNC runtime/trace.Logf from runtime/trace/annotation.go:
;; (defn Logf
;;   "Logf is like Log, but the value is formatted using the specified format spec.\n\nGo input arguments: (ctx context.Context, category string, format string, args ...interface {})\n\nJoker input arguments: [^go.std.context/Context ctx, ^String category, ^String format, ^(ellipsis-somehow <protocol-or-something>) args]"
;;   {:added "1.0"
;;    :go "__logf(*_ctx, _category, _format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^context/Context _ctx, ^String _category, ^String _format, ^<protocol-or-something> _args])

JOKER FUNC runtime/trace.NewTask from runtime/trace/annotation.go:
;; (defn NewTask
;;   "NewTask creates a task instance with the type taskType and returns\nit along with a Context that carries the task.\nIf the input context contains a task, the new task is its subtask.\n\nThe taskType is used to classify task instances. Analysis tools\nlike the Go execution tracer may assume there are only a bounded\nnumber of unique task types in the system.\n\nThe returned end function is used to mark the task's end.\nThe trace tool measures task latency as the time between task creation\nand when the end function is called, and provides the latency\ndistribution per task type.\nIf the end function is called multiple times, only the first\ncall is used in the latency measurement.\n\n  ctx, task := trace.NewTask(ctx, \"awesomeTask\")\n  trace.WithRegion(ctx, \"preparation\", prepWork)\n  // preparation of the task\n  go func() {  // continue processing the task in a separate goroutine.\n      defer task.End()\n      trace.WithRegion(ctx, \"remainingWork\", remainingWork)\n  }()\n\nGo input arguments: (pctx context.Context, taskType string)\n\nGo return type: (ctx context.Context, task *Task)\n\nJoker input arguments: [^go.std.context/Context pctx, ^String taskType]\n\nJoker return type: [go.std.context/Context (atom-of go.std.runtime.trace/Task)]"
;;   {:added "1.0"
;;    :go "__newTask(*_pctx, _taskType)"}
;;   [^context/Context _pctx, ^String _taskType])

JOKER FUNC runtime/trace.Start from runtime/trace/trace.go:
;; (defn ^"Error" Start
;;   "Start enables tracing for the current program.\nWhile tracing, the trace will be buffered and written to w.\nStart returns an error if tracing is already enabled.\n\nGo input arguments: (w io.Writer)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "trace.Start(*_w)"}
;;   [^io/Writer _w])

JOKER FUNC runtime/trace.StartRegion from runtime/trace/annotation.go:
;; (defn StartRegion
;;   "StartRegion starts a region and returns a function for marking the\nend of the region. The returned Region's End function must be called\nfrom the same goroutine where the region was started.\nWithin each goroutine, regions must nest. That is, regions started\nafter this region must be ended before this region can be ended.\nRecommended usage is\n\n    defer trace.StartRegion(ctx, \"myTracedRegion\").End()\n\nGo input arguments: (ctx context.Context, regionType string)\n\nGo return type: *Region\n\nJoker input arguments: [^go.std.context/Context ctx, ^String regionType]\n\nJoker return type: (atom-of go.std.runtime.trace/Region)"
;;   {:added "1.0"
;;    :go "__startRegion(*_ctx, _regionType)"}
;;   [^context/Context _ctx, ^String _regionType])

JOKER FUNC runtime/trace.Stop from runtime/trace/trace.go:
;; (defn Stop
;;   "Stop stops the current tracing, if any.\nStop only returns after all the writes for the trace have completed.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__stop()"}
;;   [])

JOKER FUNC runtime/trace.WithRegion from runtime/trace/annotation.go:
;; (defn WithRegion
;;   "WithRegion starts a region associated with its calling goroutine, runs fn,\nand then ends the region. If the context carries a task, the region is\nassociated with the task. Otherwise, the region is attached to the background\ntask.\n\nThe regionType is used to classify regions, so there should be only a\nhandful of unique region types.\n\nGo input arguments: (ctx context.Context, regionType string, fn func)\n\nJoker input arguments: [^go.std.context/Context ctx, ^String regionType, ^fn fn]"
;;   {:added "1.0"
;;    :go "__withRegion(*_ctx, _regionType, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^context/Context _ctx, ^String _regionType, ^fn _fn])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["runtime/trace"]
    :doc "Provides a low-level interface to the runtime/trace package."
    :empty false}
  go.std.runtime.trace)
JOKER TYPE sort.Float64Slice from sort/sort.go:
;; (defn ^"GoObject" Float64Slice.
;;   "Constructor for sort.Float64Slice"
;;   {:added "1.0"
;;    :go "_ConstructFloat64Slice(_v)"}
;;   [^Object _v])

JOKER TYPE sort.IntSlice from sort/sort.go:
;; (defn ^"GoObject" IntSlice.
;;   "Constructor for sort.IntSlice"
;;   {:added "1.0"
;;    :go "_ConstructIntSlice(_v)"}
;;   [^Object _v])

JOKER TYPE sort.Interface from sort/sort.go:
;; (defn ^"GoObject" Interface.
;;   "Constructor for sort.Interface"
;;   {:added "1.0"
;;    :go "_ConstructInterface(_v)"}
;;   [^Object _v])

JOKER TYPE sort.StringSlice from sort/sort.go:
;; (defn ^"GoObject" StringSlice.
;;   "Constructor for sort.StringSlice"
;;   {:added "1.0"
;;    :go "_ConstructStringSlice(_v)"}
;;   [^Object _v])

JOKER FUNC sort.Float64s from sort/sort.go:
;; (defn Float64s
;;   "Float64s sorts a slice of float64s in increasing order\n(not-a-number values are treated as less than other values).\n\nGo input arguments: (a []float64)\n\nJoker input arguments: [^(vector-of float64) a]"
;;   {:added "1.0"
;;    :go "__float64s(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOffloat64(_a)))"}
;;   [^Object _a])

JOKER FUNC sort.Float64sAreSorted from sort/sort.go:
;; (defn ^"Boolean" Float64sAreSorted
;;   "Float64sAreSorted tests whether a slice of float64s is sorted in increasing order\n(not-a-number values are treated as less than other values).\n\nGo input arguments: (a []float64)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of float64) a]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "sort.Float64sAreSorted(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOffloat64(_a)))"}
;;   [^Object _a])

JOKER FUNC sort.Ints from sort/sort.go:
;; (defn Ints
;;   "Ints sorts a slice of ints in increasing order.\n\nGo input arguments: (a []int)\n\nJoker input arguments: [^(vector-of Int) a]"
;;   {:added "1.0"
;;    :go "__ints(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfint(_a)))"}
;;   [^Object _a])

JOKER FUNC sort.IntsAreSorted from sort/sort.go:
;; (defn ^"Boolean" IntsAreSorted
;;   "IntsAreSorted tests whether a slice of ints is sorted in increasing order.\n\nGo input arguments: (a []int)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) a]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "sort.IntsAreSorted(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfint(_a)))"}
;;   [^Object _a])

JOKER FUNC sort.IsSorted from sort/sort.go:
(defn ^"Boolean" IsSorted
  "IsSorted reports whether data is sorted.\n\nGo input arguments: (data Interface)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.sort/Interface data]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "sort.IsSorted(*_data)"}
  [^sort/Interface _data])

JOKER FUNC sort.Reverse from sort/sort.go:
(defn Reverse
  "Reverse returns the reverse order for data.\n\nGo input arguments: (data Interface)\n\nGo return type: Interface\n\nJoker input arguments: [^go.std.sort/Interface data]\n\nJoker return type: go.std.sort/Interface"
  {:added "1.0"
   :go "__reverse(*_data)"}
  [^sort/Interface _data])

JOKER FUNC sort.Search from sort/search.go:
;; (defn ^"Int" Search
;;   "Search uses binary search to find and return the smallest index i\nin [0, n) at which f(i) is true, assuming that on the range [0, n),\nf(i) == true implies f(i+1) == true. That is, Search requires that\nf is false for some (possibly empty) prefix of the input range [0, n)\nand then true for the (possibly empty) remainder; Search returns\nthe first true index. If there is no such index, Search returns n.\n(Note that the \"not found\" return value is not -1 as in, for instance,\nstrings.Index.)\nSearch calls f(i) only for i in the range [0, n).\n\nA common use of Search is to find the index i for a value x in\na sorted, indexable data structure such as an array or slice.\nIn this case, the argument f, typically a closure, captures the value\nto be searched for, and how the data structure is indexed and\nordered.\n\nFor instance, given a slice data sorted in ascending order,\nthe call Search(len(data), func(i int) bool { return data[i] >= 23 })\nreturns the smallest index i such that data[i] >= 23. If the caller\nwants to find whether 23 is in the slice, it must test data[i] == 23\nseparately.\n\nSearching data sorted in descending order would use the <=\noperator instead of the >= operator.\n\nTo complete the example above, the following code tries to find the value\nx in an integer slice data sorted in ascending order:\n\n\tx := 23\n\ti := sort.Search(len(data), func(i int) bool { return data[i] >= x })\n\tif i < len(data) && data[i] == x {\n\t\t// x is present at data[i]\n\t} else {\n\t\t// x is not present in data,\n\t\t// but i is the index where it would be inserted.\n\t}\n\nAs a more whimsical example, this program guesses your number:\n\n\tfunc GuessingGame() {\n\t\tvar s string\n\t\tfmt.Printf(\"Pick an integer from 0 to 100.\\n\")\n\t\tanswer := sort.Search(100, func(i int) bool {\n\t\t\tfmt.Printf(\"Is your number <= %d? \", i)\n\t\t\tfmt.Scanf(\"%s\", &s)\n\t\t\treturn s != \"\" && s[0] == 'y'\n\t\t})\n\t\tfmt.Printf(\"Your number is %d.\\n\", answer)\n\t}\n\nGo input arguments: (n int, f func)\n\nGo return type: int\n\nJoker input arguments: [^Int n, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.Search(_n, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Int _n, ^fn _f])

JOKER FUNC sort.SearchFloat64s from sort/search.go:
;; (defn ^"Int" SearchFloat64s
;;   "SearchFloat64s searches for x in a sorted slice of float64s and returns the index\nas specified by Search. The return value is the index to insert x if x is not\npresent (it could be len(a)).\nThe slice must be sorted in ascending order.\n\nGo input arguments: (a []float64, x float64)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of float64) a, ^float64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.SearchFloat64s(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOffloat64(_a)), _x)"}
;;   [^Object _a, ^ABEND044(pre.go: unsupported built-in type float64) _x])

JOKER FUNC sort.SearchInts from sort/search.go:
;; (defn ^"Int" SearchInts
;;   "SearchInts searches for x in a sorted slice of ints and returns the index\nas specified by Search. The return value is the index to insert x if x is\nnot present (it could be len(a)).\nThe slice must be sorted in ascending order.\n\nGo input arguments: (a []int, x int)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) a, ^Int x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.SearchInts(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfint(_a)), _x)"}
;;   [^Object _a, ^Int _x])

JOKER FUNC sort.SearchStrings from sort/search.go:
;; (defn ^"Int" SearchStrings
;;   "SearchStrings searches for x in a sorted slice of strings and returns the index\nas specified by Search. The return value is the index to insert x if x is not\npresent (it could be len(a)).\nThe slice must be sorted in ascending order.\n\nGo input arguments: (a []string, x string)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of String) a, ^String x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.SearchStrings(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(_a)), _x)"}
;;   [^Object _a, ^String _x])

JOKER FUNC sort.Slice from sort/slice.go:
;; (defn Slice
;;   "Slice sorts the provided slice given the provided less function.\n\nThe sort is not guaranteed to be stable. For a stable sort, use\nSliceStable.\n\nThe function panics if the provided interface is not a slice.\n\nGo input arguments: (slice interface {}, less func)\n\nJoker input arguments: [^<protocol-or-something> slice, ^fn less]"
;;   {:added "1.0"
;;    :go "__slice(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^<protocol-or-something> _slice, ^fn _less])

JOKER FUNC sort.SliceIsSorted from sort/slice.go:
;; (defn ^"Boolean" SliceIsSorted
;;   "SliceIsSorted tests whether a slice is sorted.\n\nThe function panics if the provided interface is not a slice.\n\nGo input arguments: (slice interface {}, less func)\n\nGo return type: bool\n\nJoker input arguments: [^<protocol-or-something> slice, ^fn less]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "sort.SliceIsSorted(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^<protocol-or-something> _slice, ^fn _less])

JOKER FUNC sort.SliceStable from sort/slice.go:
;; (defn SliceStable
;;   "SliceStable sorts the provided slice given the provided less\nfunction while keeping the original order of equal elements.\n\nThe function panics if the provided interface is not a slice.\n\nGo input arguments: (slice interface {}, less func)\n\nJoker input arguments: [^<protocol-or-something> slice, ^fn less]"
;;   {:added "1.0"
;;    :go "__sliceStable(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^<protocol-or-something> _slice, ^fn _less])

JOKER FUNC sort.Sort from sort/sort.go:
;; (defn Sort
;;   "Sort sorts data.\nIt makes one call to data.Len to determine n, and O(n*log(n)) calls to\ndata.Less and data.Swap. The sort is not guaranteed to be stable.\n\nGo input arguments: (data Interface)\n\nJoker input arguments: [^go.std.sort/Interface data]"
;;   {:added "1.0"
;;    :go "__sort(*_data)"}
;;   [^sort/Interface _data])

JOKER FUNC sort.Stable from sort/sort.go:
;; (defn Stable
;;   "Stable sorts data while keeping the original order of equal elements.\n\nIt makes one call to data.Len to determine n, O(n*log(n)) calls to\ndata.Less and O(n*log(n)*log(n)) calls to data.Swap.\n\nGo input arguments: (data Interface)\n\nJoker input arguments: [^go.std.sort/Interface data]"
;;   {:added "1.0"
;;    :go "__stable(*_data)"}
;;   [^sort/Interface _data])

JOKER FUNC sort.Strings from sort/sort.go:
;; (defn Strings
;;   "Strings sorts a slice of strings in increasing order.\n\nGo input arguments: (a []string)\n\nJoker input arguments: [^(vector-of String) a]"
;;   {:added "1.0"
;;    :go "__strings(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(_a)))"}
;;   [^Object _a])

JOKER FUNC sort.StringsAreSorted from sort/sort.go:
;; (defn ^"Boolean" StringsAreSorted
;;   "StringsAreSorted tests whether a slice of strings is sorted in increasing order.\n\nGo input arguments: (a []string)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of String) a]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "sort.StringsAreSorted(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(_a)))"}
;;   [^Object _a])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["sort"]
    :doc "Provides a low-level interface to the sort package."
    :empty false}
  go.std.sort)
JOKER TYPE strconv.NumError from strconv/atoi.go:
(defn ^"GoObject" NumError.
  "Constructor for strconv.NumError"
  {:added "1.0"
   :go "_ConstructNumError(_v)"}
  [^Object _v])

JOKER FUNC strconv.AppendBool from strconv/atob.go:
;; (defn AppendBool
;;   "AppendBool appends \"true\" or \"false\", according to the value of b,\nto dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, b bool)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) dst, ^Boolean b]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendBool(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), _b)"}
;;   [^Object _dst, ^Boolean _b])

JOKER FUNC strconv.AppendFloat from strconv/ftoa.go:
;; (defn AppendFloat
;;   "AppendFloat appends the string form of the floating-point number f,\nas generated by FormatFloat, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, f float64, fmt byte, prec int, bitSize int)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) dst, ^float64 f, ^Byte fmt, ^Int prec, ^Int bitSize]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendFloat(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), _f, _fmt, _prec, _bitSize)"}
;;   [^Object _dst, ^ABEND044(pre.go: unsupported built-in type float64) _f, ^Byte _fmt, ^Int _prec, ^Int _bitSize])

JOKER FUNC strconv.AppendInt from strconv/itoa.go:
;; (defn AppendInt
;;   "AppendInt appends the string form of the integer i,\nas generated by FormatInt, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, i int64, base int)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) dst, ^Int64 i, ^Int base]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendInt(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), _i, _base)"}
;;   [^Object _dst, ^Int64 _i, ^Int _base])

JOKER FUNC strconv.AppendQuote from strconv/quote.go:
;; (defn AppendQuote
;;   "AppendQuote appends a double-quoted Go string literal representing s,\nas generated by Quote, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, s string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) dst, ^String s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendQuote(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), _s)"}
;;   [^Object _dst, ^String _s])

JOKER FUNC strconv.AppendQuoteRune from strconv/quote.go:
;; (defn AppendQuoteRune
;;   "AppendQuoteRune appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRune, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, r rune)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) dst, ^rune r]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendQuoteRune(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), _r)"}
;;   [^Object _dst, ^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC strconv.AppendQuoteRuneToASCII from strconv/quote.go:
;; (defn AppendQuoteRuneToASCII
;;   "AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRuneToASCII, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, r rune)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) dst, ^rune r]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendQuoteRuneToASCII(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), _r)"}
;;   [^Object _dst, ^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC strconv.AppendQuoteRuneToGraphic from strconv/quote.go:
;; (defn AppendQuoteRuneToGraphic
;;   "AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRuneToGraphic, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, r rune)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) dst, ^rune r]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendQuoteRuneToGraphic(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), _r)"}
;;   [^Object _dst, ^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC strconv.AppendQuoteToASCII from strconv/quote.go:
;; (defn AppendQuoteToASCII
;;   "AppendQuoteToASCII appends a double-quoted Go string literal representing s,\nas generated by QuoteToASCII, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, s string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) dst, ^String s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendQuoteToASCII(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), _s)"}
;;   [^Object _dst, ^String _s])

JOKER FUNC strconv.AppendQuoteToGraphic from strconv/quote.go:
;; (defn AppendQuoteToGraphic
;;   "AppendQuoteToGraphic appends a double-quoted Go string literal representing s,\nas generated by QuoteToGraphic, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, s string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) dst, ^String s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendQuoteToGraphic(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), _s)"}
;;   [^Object _dst, ^String _s])

JOKER FUNC strconv.AppendUint from strconv/itoa.go:
;; (defn AppendUint
;;   "AppendUint appends the string form of the unsigned integer i,\nas generated by FormatUint, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, i uint64, base int)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) dst, ^uint64 i, ^Int base]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendUint(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), _i, _base)"}
;;   [^Object _dst, ^ABEND044(pre.go: unsupported built-in type uint64) _i, ^Int _base])

JOKER FUNC strconv.Atoi from strconv/atoi.go:
(defn Atoi
  "Atoi returns the result of ParseInt(s, 10, 0) converted to type int.\n\nGo input arguments: (s string)\n\nGo return type: (int, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__atoi(_s)"}
  [^String _s])

JOKER FUNC strconv.CanBackquote from strconv/quote.go:
(defn ^"Boolean" CanBackquote
  "CanBackquote reports whether the string s can be represented\nunchanged as a single-line backquoted string without control\ncharacters other than tab.\n\nGo input arguments: (s string)\n\nGo return type: bool\n\nJoker input arguments: [^String s]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strconv.CanBackquote(_s)"}
  [^String _s])

JOKER FUNC strconv.FormatBool from strconv/atob.go:
(defn ^"String" FormatBool
  "FormatBool returns \"true\" or \"false\" according to the value of b.\n\nGo input arguments: (b bool)\n\nGo return type: string\n\nJoker input arguments: [^Boolean b]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.FormatBool(_b)"}
  [^Boolean _b])

JOKER FUNC strconv.FormatFloat from strconv/ftoa.go:
;; (defn ^"String" FormatFloat
;;   "FormatFloat converts the floating-point number f to a string,\naccording to the format fmt and precision prec. It rounds the\nresult assuming that the original was obtained from a floating-point\nvalue of bitSize bits (32 for float32, 64 for float64).\n\nThe format fmt is one of\n'b' (-ddddp±ddd, a binary exponent),\n'e' (-d.dddde±dd, a decimal exponent),\n'E' (-d.ddddE±dd, a decimal exponent),\n'f' (-ddd.dddd, no exponent),\n'g' ('e' for large exponents, 'f' otherwise), or\n'G' ('E' for large exponents, 'f' otherwise).\n\nThe precision prec controls the number of digits (excluding the exponent)\nprinted by the 'e', 'E', 'f', 'g', and 'G' formats.\nFor 'e', 'E', and 'f' it is the number of digits after the decimal point.\nFor 'g' and 'G' it is the maximum number of significant digits (trailing\nzeros are removed).\nThe special precision -1 uses the smallest number of digits\nnecessary such that ParseFloat will return f exactly.\n\nGo input arguments: (f float64, fmt byte, prec int, bitSize int)\n\nGo return type: string\n\nJoker input arguments: [^float64 f, ^Byte fmt, ^Int prec, ^Int bitSize]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strconv.FormatFloat(_f, _fmt, _prec, _bitSize)"}
;;   [^ABEND044(pre.go: unsupported built-in type float64) _f, ^Byte _fmt, ^Int _prec, ^Int _bitSize])

JOKER FUNC strconv.FormatInt from strconv/itoa.go:
(defn ^"String" FormatInt
  "FormatInt returns the string representation of i in the given base,\nfor 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'\nfor digit values >= 10.\n\nGo input arguments: (i int64, base int)\n\nGo return type: string\n\nJoker input arguments: [^Int64 i, ^Int base]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.FormatInt(_i, _base)"}
  [^Int64 _i, ^Int _base])

JOKER FUNC strconv.FormatUint from strconv/itoa.go:
;; (defn ^"String" FormatUint
;;   "FormatUint returns the string representation of i in the given base,\nfor 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'\nfor digit values >= 10.\n\nGo input arguments: (i uint64, base int)\n\nGo return type: string\n\nJoker input arguments: [^uint64 i, ^Int base]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strconv.FormatUint(_i, _base)"}
;;   [^ABEND044(pre.go: unsupported built-in type uint64) _i, ^Int _base])

JOKER FUNC strconv.IsGraphic from strconv/quote.go:
;; (defn ^"Boolean" IsGraphic
;;   "IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such\ncharacters include letters, marks, numbers, punctuation, symbols, and\nspaces, from categories L, M, N, P, S, and Zs.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "strconv.IsGraphic(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC strconv.IsPrint from strconv/quote.go:
;; (defn ^"Boolean" IsPrint
;;   "IsPrint reports whether the rune is defined as printable by Go, with\nthe same definition as unicode.IsPrint: letters, numbers, punctuation,\nsymbols and ASCII space.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "strconv.IsPrint(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC strconv.Itoa from strconv/itoa.go:
(defn ^"String" Itoa
  "Itoa is shorthand for FormatInt(int64(i), 10).\n\nGo input arguments: (i int)\n\nGo return type: string\n\nJoker input arguments: [^Int i]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.Itoa(_i)"}
  [^Int _i])

JOKER FUNC strconv.ParseBool from strconv/atob.go:
(defn ParseBool
  "ParseBool returns the boolean value represented by the string.\nIt accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False.\nAny other value returns an error.\n\nGo input arguments: (str string)\n\nGo return type: (bool, error)\n\nJoker input arguments: [^String str]\n\nJoker return type: [Boolean Error]"
  {:added "1.0"
   :go "__parseBool(_str)"}
  [^String _str])

JOKER FUNC strconv.ParseFloat from strconv/atof.go:
;; (defn ParseFloat
;;   "ParseFloat converts the string s to a floating-point number\nwith the precision specified by bitSize: 32 for float32, or 64 for float64.\nWhen bitSize=32, the result still has type float64, but it will be\nconvertible to float32 without changing its value.\n\nIf s is well-formed and near a valid floating point number,\nParseFloat returns the nearest floating point number rounded\nusing IEEE754 unbiased rounding.\n\nThe errors that ParseFloat returns have concrete type *NumError\nand include err.Num = s.\n\nIf s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.\n\nIf s is syntactically well-formed but is more than 1/2 ULP\naway from the largest floating point number of the given size,\nParseFloat returns f = ±Inf, err.Err = ErrRange.\n\nGo input arguments: (s string, bitSize int)\n\nGo return type: (..., error)\n\nJoker input arguments: [^String s, ^Int bitSize]\n\nJoker return type: [ABEND043(post.go: unsupported built-in type float64) Error]"
;;   {:added "1.0"
;;    :go "__parseFloat(_s, _bitSize)"}
;;   [^String _s, ^Int _bitSize])

JOKER FUNC strconv.ParseInt from strconv/atoi.go:
(defn ParseInt
  "ParseInt interprets a string s in the given base (0, 2 to 36) and\nbit size (0 to 64) and returns the corresponding value i.\n\nIf base == 0, the base is implied by the string's prefix:\nbase 16 for \"0x\", base 8 for \"0\", and base 10 otherwise.\nFor bases 1, below 0 or above 36 an error is returned.\n\nThe bitSize argument specifies the integer type\nthat the result must fit into. Bit sizes 0, 8, 16, 32, and 64\ncorrespond to int, int8, int16, int32, and int64.\nFor a bitSize below 0 or above 64 an error is returned.\n\nThe errors that ParseInt returns have concrete type *NumError\nand include err.Num = s. If s is empty or contains invalid\ndigits, err.Err = ErrSyntax and the returned value is 0;\nif the value corresponding to s cannot be represented by a\nsigned integer of the given size, err.Err = ErrRange and the\nreturned value is the maximum magnitude integer of the\nappropriate bitSize and sign.\n\nGo input arguments: (s string, base int, bitSize int)\n\nGo return type: (i int64, err error)\n\nJoker input arguments: [^String s, ^Int base, ^Int bitSize]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__parseInt(_s, _base, _bitSize)"}
  [^String _s, ^Int _base, ^Int _bitSize])

JOKER FUNC strconv.ParseUint from strconv/atoi.go:
(defn ParseUint
  "ParseUint is like ParseInt but for unsigned numbers.\n\nGo input arguments: (s string, base int, bitSize int)\n\nGo return type: (uint64, error)\n\nJoker input arguments: [^String s, ^Int base, ^Int bitSize]\n\nJoker return type: [BigInt Error]"
  {:added "1.0"
   :go "__parseUint(_s, _base, _bitSize)"}
  [^String _s, ^Int _base, ^Int _bitSize])

JOKER FUNC strconv.Quote from strconv/quote.go:
(defn ^"String" Quote
  "Quote returns a double-quoted Go string literal representing s. The\nreturned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\ncontrol characters and non-printable characters as defined by\nIsPrint.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.Quote(_s)"}
  [^String _s])

JOKER FUNC strconv.QuoteRune from strconv/quote.go:
;; (defn ^"String" QuoteRune
;;   "QuoteRune returns a single-quoted Go character literal representing the\nrune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100)\nfor control characters and non-printable characters as defined by IsPrint.\n\nGo input arguments: (r rune)\n\nGo return type: string\n\nJoker input arguments: [^rune r]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strconv.QuoteRune(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC strconv.QuoteRuneToASCII from strconv/quote.go:
;; (defn ^"String" QuoteRuneToASCII
;;   "QuoteRuneToASCII returns a single-quoted Go character literal representing\nthe rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n\\u0100) for non-ASCII characters and non-printable characters as defined\nby IsPrint.\n\nGo input arguments: (r rune)\n\nGo return type: string\n\nJoker input arguments: [^rune r]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strconv.QuoteRuneToASCII(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC strconv.QuoteRuneToGraphic from strconv/quote.go:
;; (defn ^"String" QuoteRuneToGraphic
;;   "QuoteRuneToGraphic returns a single-quoted Go character literal representing\nthe rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n\\u0100) for non-ASCII characters and non-printable characters as defined\nby IsGraphic.\n\nGo input arguments: (r rune)\n\nGo return type: string\n\nJoker input arguments: [^rune r]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strconv.QuoteRuneToGraphic(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC strconv.QuoteToASCII from strconv/quote.go:
(defn ^"String" QuoteToASCII
  "QuoteToASCII returns a double-quoted Go string literal representing s.\nThe returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\nnon-ASCII characters and non-printable characters as defined by IsPrint.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.QuoteToASCII(_s)"}
  [^String _s])

JOKER FUNC strconv.QuoteToGraphic from strconv/quote.go:
(defn ^"String" QuoteToGraphic
  "QuoteToGraphic returns a double-quoted Go string literal representing s.\nThe returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\nnon-ASCII characters and non-printable characters as defined by IsGraphic.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.QuoteToGraphic(_s)"}
  [^String _s])

JOKER FUNC strconv.Unquote from strconv/quote.go:
(defn Unquote
  "Unquote interprets s as a single-quoted, double-quoted,\nor backquoted Go string literal, returning the string value\nthat s quotes.  (If s is single-quoted, it would be a Go\ncharacter literal; Unquote returns the corresponding\none-character string.)\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__unquote(_s)"}
  [^String _s])

JOKER FUNC strconv.UnquoteChar from strconv/quote.go:
;; (defn UnquoteChar
;;   "UnquoteChar decodes the first character or byte in the escaped string\nor character literal represented by the string s.\nIt returns four values:\n\n\t1) value, the decoded Unicode code point or byte value;\n\t2) multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;\n\t3) tail, the remainder of the string after the character; and\n\t4) an error that will be nil if the character is syntactically valid.\n\nThe second argument, quote, specifies the type of literal being parsed\nand therefore which escaped quote character is permitted.\nIf set to a single quote, it permits the sequence \\' and disallows unescaped '.\nIf set to a double quote, it permits \\\" and disallows unescaped \".\nIf set to zero, it does not permit either escape and allows both quote characters to appear unescaped.\n\nGo input arguments: (s string, quote byte)\n\nGo return type: (value ..., multibyte bool, tail string, err error)\n\nJoker input arguments: [^String s, ^Byte quote]\n\nJoker return type: [ABEND043(post.go: unsupported built-in type rune) Boolean String Error]"
;;   {:added "1.0"
;;    :go "__unquoteChar(_s, _quote)"}
;;   [^String _s, ^Byte _quote])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["strconv"]
    :doc "Provides a low-level interface to the strconv package."
    :empty false}
  go.std.strconv)
JOKER TYPE strings.Builder from strings/builder.go:
(defn ^"GoObject" Builder.
  "Constructor for strings.Builder"
  {:added "1.0"
   :go "_ConstructBuilder(_v)"}
  [^Object _v])

JOKER TYPE strings.Reader from strings/reader.go:
(defn ^"GoObject" Reader.
  "Constructor for strings.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER TYPE strings.Replacer from strings/replace.go:
(defn ^"GoObject" Replacer.
  "Constructor for strings.Replacer"
  {:added "1.0"
   :go "_ConstructReplacer(_v)"}
  [^Object _v])

JOKER FUNC strings.Compare from strings/compare.go:
(defn ^"Int" Compare
  "Compare returns an integer comparing two strings lexicographically.\nThe result will be 0 if a==b, -1 if a < b, and +1 if a > b.\n\nCompare is included only for symmetry with package bytes.\nIt is usually clearer and always faster to use the built-in\nstring comparison operators ==, <, >, and so on.\n\nGo input arguments: (a string, b string)\n\nGo return type: int\n\nJoker input arguments: [^String a, ^String b]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.Compare(_a, _b)"}
  [^String _a, ^String _b])

JOKER FUNC strings.Contains from strings/strings.go:
(defn ^"Boolean" Contains
  "Contains reports whether substr is within s.\n\nGo input arguments: (s string, substr string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String substr]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strings.Contains(_s, _substr)"}
  [^String _s, ^String _substr])

JOKER FUNC strings.ContainsAny from strings/strings.go:
(defn ^"Boolean" ContainsAny
  "ContainsAny reports whether any Unicode code points in chars are within s.\n\nGo input arguments: (s string, chars string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String chars]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strings.ContainsAny(_s, _chars)"}
  [^String _s, ^String _chars])

JOKER FUNC strings.ContainsRune from strings/strings.go:
;; (defn ^"Boolean" ContainsRune
;;   "ContainsRune reports whether the Unicode code point r is within s.\n\nGo input arguments: (s string, r rune)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "strings.ContainsRune(_s, _r)"}
;;   [^String _s, ^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC strings.Count from strings/strings.go:
(defn ^"Int" Count
  "Count counts the number of non-overlapping instances of substr in s.\nIf substr is an empty string, Count returns 1 + the number of Unicode code points in s.\n\nGo input arguments: (s string, substr string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String substr]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.Count(_s, _substr)"}
  [^String _s, ^String _substr])

JOKER FUNC strings.EqualFold from strings/strings.go:
(defn ^"Boolean" EqualFold
  "EqualFold reports whether s and t, interpreted as UTF-8 strings,\nare equal under Unicode case-folding.\n\nGo input arguments: (s string, t string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String t]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strings.EqualFold(_s, _t)"}
  [^String _s, ^String _t])

JOKER FUNC strings.Fields from strings/strings.go:
(defn Fields
  "Fields splits the string s around each instance of one or more consecutive white space\ncharacters, as defined by unicode.IsSpace, returning a slice of substrings of s or an\nempty slice if s contains only white space.\n\nGo input arguments: (s string)\n\nGo return type: []string\n\nJoker input arguments: [^String s]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__fields(_s)"}
  [^String _s])

JOKER FUNC strings.FieldsFunc from strings/strings.go:
;; (defn FieldsFunc
;;   "FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c)\nand returns an array of slices of s. If all code points in s satisfy f(c) or the\nstring is empty, an empty slice is returned.\nFieldsFunc makes no guarantees about the order in which it calls f(c).\nIf f does not return consistent results for a given c, FieldsFunc may crash.\n\nGo input arguments: (s string, f func)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: (vector-of String)"
;;   {:added "1.0"
;;    :go "__fieldsFunc(_s, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String _s, ^fn _f])

JOKER FUNC strings.HasPrefix from strings/strings.go:
(defn ^"Boolean" HasPrefix
  "HasPrefix tests whether the string s begins with prefix.\n\nGo input arguments: (s string, prefix string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String prefix]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strings.HasPrefix(_s, _prefix)"}
  [^String _s, ^String _prefix])

JOKER FUNC strings.HasSuffix from strings/strings.go:
(defn ^"Boolean" HasSuffix
  "HasSuffix tests whether the string s ends with suffix.\n\nGo input arguments: (s string, suffix string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String suffix]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strings.HasSuffix(_s, _suffix)"}
  [^String _s, ^String _suffix])

JOKER FUNC strings.Index from strings/strings.go:
(defn ^"Int" Index
  "Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.\n\nGo input arguments: (s string, substr string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String substr]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.Index(_s, _substr)"}
  [^String _s, ^String _substr])

JOKER FUNC strings.IndexAny from strings/strings.go:
(defn ^"Int" IndexAny
  "IndexAny returns the index of the first instance of any Unicode code point\nfrom chars in s, or -1 if no Unicode code point from chars is present in s.\n\nGo input arguments: (s string, chars string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String chars]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.IndexAny(_s, _chars)"}
  [^String _s, ^String _chars])

JOKER FUNC strings.IndexByte from strings/strings_decl.go:
(defn ^"Int" IndexByte
  "IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.\n\nGo input arguments: (s string, c byte)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^Byte c]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.IndexByte(_s, _c)"}
  [^String _s, ^Byte _c])

JOKER FUNC strings.IndexFunc from strings/strings.go:
;; (defn ^"Int" IndexFunc
;;   "IndexFunc returns the index into s of the first Unicode\ncode point satisfying f(c), or -1 if none do.\n\nGo input arguments: (s string, f func)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "strings.IndexFunc(_s, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String _s, ^fn _f])

JOKER FUNC strings.IndexRune from strings/strings.go:
;; (defn ^"Int" IndexRune
;;   "IndexRune returns the index of the first instance of the Unicode code point\nr, or -1 if rune is not present in s.\nIf r is utf8.RuneError, it returns the first instance of any\ninvalid UTF-8 byte sequence.\n\nGo input arguments: (s string, r rune)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^rune r]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "strings.IndexRune(_s, _r)"}
;;   [^String _s, ^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC strings.Join from strings/strings.go:
;; (defn ^"String" Join
;;   "Join concatenates the elements of a to create a single string. The separator string\nsep is placed between elements in the resulting string.\n\nGo input arguments: (a []string, sep string)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of String) a, ^String sep]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.Join(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(_a)), _sep)"}
;;   [^Object _a, ^String _sep])

JOKER FUNC strings.LastIndex from strings/strings.go:
(defn ^"Int" LastIndex
  "LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.\n\nGo input arguments: (s string, substr string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String substr]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.LastIndex(_s, _substr)"}
  [^String _s, ^String _substr])

JOKER FUNC strings.LastIndexAny from strings/strings.go:
(defn ^"Int" LastIndexAny
  "LastIndexAny returns the index of the last instance of any Unicode code\npoint from chars in s, or -1 if no Unicode code point from chars is\npresent in s.\n\nGo input arguments: (s string, chars string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String chars]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.LastIndexAny(_s, _chars)"}
  [^String _s, ^String _chars])

JOKER FUNC strings.LastIndexByte from strings/strings.go:
(defn ^"Int" LastIndexByte
  "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.\n\nGo input arguments: (s string, c byte)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^Byte c]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.LastIndexByte(_s, _c)"}
  [^String _s, ^Byte _c])

JOKER FUNC strings.LastIndexFunc from strings/strings.go:
;; (defn ^"Int" LastIndexFunc
;;   "LastIndexFunc returns the index into s of the last\nUnicode code point satisfying f(c), or -1 if none do.\n\nGo input arguments: (s string, f func)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "strings.LastIndexFunc(_s, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String _s, ^fn _f])

JOKER FUNC strings.Map from strings/strings.go:
;; (defn ^"String" Map
;;   "Map returns a copy of the string s with all its characters modified\naccording to the mapping function. If mapping returns a negative value, the character is\ndropped from the string with no replacement.\n\nGo input arguments: (mapping func, s string)\n\nGo return type: string\n\nJoker input arguments: [^fn mapping, ^String s]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.Map(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), _s)"}
;;   [^fn _mapping, ^String _s])

JOKER FUNC strings.NewReader from strings/reader.go:
(defn NewReader
  "NewReader returns a new Reader reading from s.\nIt is similar to bytes.NewBufferString but more efficient and read-only.\n\nGo input arguments: (s string)\n\nGo return type: *Reader\n\nJoker input arguments: [^String s]\n\nJoker return type: (atom-of go.std.strings/Reader)"
  {:added "1.0"
   :go "__newReader(_s)"}
  [^String _s])

JOKER FUNC strings.NewReplacer from strings/replace.go:
;; (defn NewReplacer
;;   "NewReplacer returns a new Replacer from a list of old, new string\npairs. Replacements are performed in the order they appear in the\ntarget string, without overlapping matches.\n\nGo input arguments: (oldnew ...string)\n\nGo return type: *Replacer\n\nJoker input arguments: [^(ellipsis-somehow String) oldnew]\n\nJoker return type: (atom-of go.std.strings/Replacer)"
;;   {:added "1.0"
;;    :go "__newReplacer(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(_oldnew)))"}
;;   [^String _oldnew])

JOKER FUNC strings.Repeat from strings/strings.go:
(defn ^"String" Repeat
  "Repeat returns a new string consisting of count copies of the string s.\n\nIt panics if count is negative or if\nthe result of (len(s) * count) overflows.\n\nGo input arguments: (s string, count int)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^Int count]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Repeat(_s, _count)"}
  [^String _s, ^Int _count])

JOKER FUNC strings.Replace from strings/strings.go:
(defn ^"String" Replace
  "Replace returns a copy of the string s with the first n\nnon-overlapping instances of old replaced by new.\nIf old is empty, it matches at the beginning of the string\nand after each UTF-8 sequence, yielding up to k+1 replacements\nfor a k-rune string.\nIf n < 0, there is no limit on the number of replacements.\n\nGo input arguments: (s string, old string, new string, n int)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String old, ^String new, ^Int n]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Replace(_s, _old, _new, _n)"}
  [^String _s, ^String _old, ^String _new, ^Int _n])

JOKER FUNC strings.Split from strings/strings.go:
(defn Split
  "Split slices s into all substrings separated by sep and returns a slice of\nthe substrings between those separators.\n\nIf s does not contain sep and sep is not empty, Split returns a\nslice of length 1 whose only element is s.\n\nIf sep is empty, Split splits after each UTF-8 sequence. If both s\nand sep are empty, Split returns an empty slice.\n\nIt is equivalent to SplitN with a count of -1.\n\nGo input arguments: (s string, sep string)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^String sep]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__split(_s, _sep)"}
  [^String _s, ^String _sep])

JOKER FUNC strings.SplitAfter from strings/strings.go:
(defn SplitAfter
  "SplitAfter slices s into all substrings after each instance of sep and\nreturns a slice of those substrings.\n\nIf s does not contain sep and sep is not empty, SplitAfter returns\na slice of length 1 whose only element is s.\n\nIf sep is empty, SplitAfter splits after each UTF-8 sequence. If\nboth s and sep are empty, SplitAfter returns an empty slice.\n\nIt is equivalent to SplitAfterN with a count of -1.\n\nGo input arguments: (s string, sep string)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^String sep]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__splitAfter(_s, _sep)"}
  [^String _s, ^String _sep])

JOKER FUNC strings.SplitAfterN from strings/strings.go:
(defn SplitAfterN
  "SplitAfterN slices s into substrings after each instance of sep and\nreturns a slice of those substrings.\n\nThe count determines the number of substrings to return:\n  n > 0: at most n substrings; the last substring will be the unsplit remainder.\n  n == 0: the result is nil (zero substrings)\n  n < 0: all substrings\n\nEdge cases for s and sep (for example, empty strings) are handled\nas described in the documentation for SplitAfter.\n\nGo input arguments: (s string, sep string, n int)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^String sep, ^Int n]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__splitAfterN(_s, _sep, _n)"}
  [^String _s, ^String _sep, ^Int _n])

JOKER FUNC strings.SplitN from strings/strings.go:
(defn SplitN
  "SplitN slices s into substrings separated by sep and returns a slice of\nthe substrings between those separators.\n\nThe count determines the number of substrings to return:\n  n > 0: at most n substrings; the last substring will be the unsplit remainder.\n  n == 0: the result is nil (zero substrings)\n  n < 0: all substrings\n\nEdge cases for s and sep (for example, empty strings) are handled\nas described in the documentation for Split.\n\nGo input arguments: (s string, sep string, n int)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^String sep, ^Int n]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__splitN(_s, _sep, _n)"}
  [^String _s, ^String _sep, ^Int _n])

JOKER FUNC strings.Title from strings/strings.go:
(defn ^"String" Title
  "Title returns a copy of the string s with all Unicode letters that begin words\nmapped to their title case.\n\nBUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Title(_s)"}
  [^String _s])

JOKER FUNC strings.ToLower from strings/strings.go:
(defn ^"String" ToLower
  "ToLower returns a copy of the string s with all Unicode letters mapped to their lower case.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.ToLower(_s)"}
  [^String _s])

JOKER FUNC strings.ToLowerSpecial from strings/strings.go:
;; (defn ^"String" ToLowerSpecial
;;   "ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their\nlower case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s string)\n\nGo return type: string\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^String s]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.ToLowerSpecial(*_c, _s)"}
;;   [^unicode/SpecialCase _c, ^String _s])

JOKER FUNC strings.ToTitle from strings/strings.go:
(defn ^"String" ToTitle
  "ToTitle returns a copy of the string s with all Unicode letters mapped to their title case.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.ToTitle(_s)"}
  [^String _s])

JOKER FUNC strings.ToTitleSpecial from strings/strings.go:
;; (defn ^"String" ToTitleSpecial
;;   "ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their\ntitle case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s string)\n\nGo return type: string\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^String s]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.ToTitleSpecial(*_c, _s)"}
;;   [^unicode/SpecialCase _c, ^String _s])

JOKER FUNC strings.ToUpper from strings/strings.go:
(defn ^"String" ToUpper
  "ToUpper returns a copy of the string s with all Unicode letters mapped to their upper case.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.ToUpper(_s)"}
  [^String _s])

JOKER FUNC strings.ToUpperSpecial from strings/strings.go:
;; (defn ^"String" ToUpperSpecial
;;   "ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their\nupper case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s string)\n\nGo return type: string\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^String s]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.ToUpperSpecial(*_c, _s)"}
;;   [^unicode/SpecialCase _c, ^String _s])

JOKER FUNC strings.Trim from strings/strings.go:
(defn ^"String" Trim
  "Trim returns a slice of the string s with all leading and\ntrailing Unicode code points contained in cutset removed.\n\nGo input arguments: (s string, cutset string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String cutset]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Trim(_s, _cutset)"}
  [^String _s, ^String _cutset])

JOKER FUNC strings.TrimFunc from strings/strings.go:
;; (defn ^"String" TrimFunc
;;   "TrimFunc returns a slice of the string s with all leading\nand trailing Unicode code points c satisfying f(c) removed.\n\nGo input arguments: (s string, f func)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.TrimFunc(_s, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String _s, ^fn _f])

JOKER FUNC strings.TrimLeft from strings/strings.go:
(defn ^"String" TrimLeft
  "TrimLeft returns a slice of the string s with all leading\nUnicode code points contained in cutset removed.\n\nTo remove a prefix, use TrimPrefix instead.\n\nGo input arguments: (s string, cutset string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String cutset]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimLeft(_s, _cutset)"}
  [^String _s, ^String _cutset])

JOKER FUNC strings.TrimLeftFunc from strings/strings.go:
;; (defn ^"String" TrimLeftFunc
;;   "TrimLeftFunc returns a slice of the string s with all leading\nUnicode code points c satisfying f(c) removed.\n\nGo input arguments: (s string, f func)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.TrimLeftFunc(_s, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String _s, ^fn _f])

JOKER FUNC strings.TrimPrefix from strings/strings.go:
(defn ^"String" TrimPrefix
  "TrimPrefix returns s without the provided leading prefix string.\nIf s doesn't start with prefix, s is returned unchanged.\n\nGo input arguments: (s string, prefix string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String prefix]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimPrefix(_s, _prefix)"}
  [^String _s, ^String _prefix])

JOKER FUNC strings.TrimRight from strings/strings.go:
(defn ^"String" TrimRight
  "TrimRight returns a slice of the string s, with all trailing\nUnicode code points contained in cutset removed.\n\nTo remove a suffix, use TrimSuffix instead.\n\nGo input arguments: (s string, cutset string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String cutset]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimRight(_s, _cutset)"}
  [^String _s, ^String _cutset])

JOKER FUNC strings.TrimRightFunc from strings/strings.go:
;; (defn ^"String" TrimRightFunc
;;   "TrimRightFunc returns a slice of the string s with all trailing\nUnicode code points c satisfying f(c) removed.\n\nGo input arguments: (s string, f func)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.TrimRightFunc(_s, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String _s, ^fn _f])

JOKER FUNC strings.TrimSpace from strings/strings.go:
(defn ^"String" TrimSpace
  "TrimSpace returns a slice of the string s, with all leading\nand trailing white space removed, as defined by Unicode.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimSpace(_s)"}
  [^String _s])

JOKER FUNC strings.TrimSuffix from strings/strings.go:
(defn ^"String" TrimSuffix
  "TrimSuffix returns s without the provided trailing suffix string.\nIf s doesn't end with suffix, s is returned unchanged.\n\nGo input arguments: (s string, suffix string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String suffix]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimSuffix(_s, _suffix)"}
  [^String _s, ^String _suffix])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["strings"]
    :doc "Provides a low-level interface to the strings package."
    :empty false}
  go.std.strings)
JOKER TYPE sync.Cond from sync/cond.go:
(defn ^"GoObject" Cond.
  "Constructor for sync.Cond"
  {:added "1.0"
   :go "_ConstructCond(_v)"}
  [^Object _v])

JOKER TYPE sync.Locker from sync/mutex.go:
;; (defn ^"GoObject" Locker.
;;   "Constructor for sync.Locker"
;;   {:added "1.0"
;;    :go "_ConstructLocker(_v)"}
;;   [^Object _v])

JOKER TYPE sync.Map from sync/map.go:
(defn ^"GoObject" Map.
  "Constructor for sync.Map"
  {:added "1.0"
   :go "_ConstructMap(_v)"}
  [^Object _v])

JOKER TYPE sync.Mutex from sync/mutex.go:
(defn ^"GoObject" Mutex.
  "Constructor for sync.Mutex"
  {:added "1.0"
   :go "_ConstructMutex(_v)"}
  [^Object _v])

JOKER TYPE sync.Once from sync/once.go:
(defn ^"GoObject" Once.
  "Constructor for sync.Once"
  {:added "1.0"
   :go "_ConstructOnce(_v)"}
  [^Object _v])

JOKER TYPE sync.Pool from sync/pool.go:
(defn ^"GoObject" Pool.
  "Constructor for sync.Pool"
  {:added "1.0"
   :go "_ConstructPool(_v)"}
  [^Object _v])

JOKER TYPE sync.RWMutex from sync/rwmutex.go:
(defn ^"GoObject" RWMutex.
  "Constructor for sync.RWMutex"
  {:added "1.0"
   :go "_ConstructRWMutex(_v)"}
  [^Object _v])

JOKER TYPE sync.WaitGroup from sync/waitgroup.go:
(defn ^"GoObject" WaitGroup.
  "Constructor for sync.WaitGroup"
  {:added "1.0"
   :go "_ConstructWaitGroup(_v)"}
  [^Object _v])

JOKER FUNC sync.NewCond from sync/cond.go:
(defn NewCond
  "NewCond returns a new Cond with Locker l.\n\nGo input arguments: (l Locker)\n\nGo return type: *Cond\n\nJoker input arguments: [^go.std.sync/Locker l]\n\nJoker return type: (atom-of go.std.sync/Cond)"
  {:added "1.0"
   :go "__newCond(*_l)"}
  [^sync/Locker _l])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the sync package."
    :empty false}
  go.std.sync)
JOKER FUNC sync/atomic.AddInt32 from sync/atomic/doc.go:
;; (defn AddInt32
;;   "AddInt32 atomically adds delta to *addr and returns the new value.\n\nGo input arguments: (addr *int32, delta int32)\n\nGo return type: int32\n\nJoker input arguments: [^(atom-of Int32) addr, ^Int32 delta]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__addInt32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint32(_addr)), _delta)"}
;;   [^Object _addr, ^Int32 _delta])

JOKER FUNC sync/atomic.AddInt64 from sync/atomic/doc.go:
;; (defn AddInt64
;;   "AddInt64 atomically adds delta to *addr and returns the new value.\n\nGo input arguments: (addr *int64, delta int64)\n\nGo return type: int64\n\nJoker input arguments: [^(atom-of Int64) addr, ^Int64 delta]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__addInt64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(_addr)), _delta)"}
;;   [^Object _addr, ^Int64 _delta])

JOKER FUNC sync/atomic.AddUint32 from sync/atomic/doc.go:
;; (defn AddUint32
;;   "AddUint32 atomically adds delta to *addr and returns the new value.\nTo subtract a signed positive constant value c from x, do AddUint32(&x, ^uint32(c-1)).\nIn particular, to decrement x, do AddUint32(&x, ^uint32(0)).\n\nGo input arguments: (addr *uint32, delta uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^(atom-of UInt32) addr, ^UInt32 delta]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__addUint32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint32(_addr)), _delta)"}
;;   [^Object _addr, ^UInt32 _delta])

JOKER FUNC sync/atomic.AddUint64 from sync/atomic/doc.go:
;; (defn AddUint64
;;   "AddUint64 atomically adds delta to *addr and returns the new value.\nTo subtract a signed positive constant value c from x, do AddUint64(&x, ^uint64(c-1)).\nIn particular, to decrement x, do AddUint64(&x, ^uint64(0)).\n\nGo input arguments: (addr *uint64, delta uint64)\n\nGo return type: uint64\n\nJoker input arguments: [^(atom-of uint64) addr, ^uint64 delta]\n\nJoker return type: BigInt"
;;   {:added "1.0"
;;    :go "__addUint64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint64(_addr)), _delta)"}
;;   [^Object _addr, ^ABEND044(pre.go: unsupported built-in type uint64) _delta])

JOKER FUNC sync/atomic.AddUintptr from sync/atomic/doc.go:
;; (defn AddUintptr
;;   "AddUintptr atomically adds delta to *addr and returns the new value.\n\nGo input arguments: (addr *uintptr, delta uintptr)\n\nGo return type: uintptr\n\nJoker input arguments: [^(atom-of UIntPtr) addr, ^UIntPtr delta]\n\nJoker return type: BigInt"
;;   {:added "1.0"
;;    :go "__addUintptr(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuintptr(_addr)), _delta)"}
;;   [^Object _addr, ^UIntPtr _delta])

JOKER FUNC sync/atomic.CompareAndSwapInt32 from sync/atomic/doc.go:
;; (defn ^"Boolean" CompareAndSwapInt32
;;   "CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.\n\nGo input arguments: (addr *int32, old int32, new int32)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of Int32) addr, ^Int32 old, ^Int32 new]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapInt32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint32(_addr)), _old, _new)"}
;;   [^Object _addr, ^Int32 _old, ^Int32 _new])

JOKER FUNC sync/atomic.CompareAndSwapInt64 from sync/atomic/doc.go:
;; (defn ^"Boolean" CompareAndSwapInt64
;;   "CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value.\n\nGo input arguments: (addr *int64, old int64, new int64)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of Int64) addr, ^Int64 old, ^Int64 new]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapInt64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(_addr)), _old, _new)"}
;;   [^Object _addr, ^Int64 _old, ^Int64 _new])

JOKER FUNC sync/atomic.CompareAndSwapPointer from sync/atomic/doc.go:
;; (defn ^"Boolean" CompareAndSwapPointer
;;   "CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value.\n\nGo input arguments: (addr *unsafe.Pointer, old unsafe.Pointer, new unsafe.Pointer)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.unsafe/Pointer) addr, ^go.std.unsafe/Pointer old, ^go.std.unsafe/Pointer new]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapPointer(_addr, *_old, *_new)"}
;;   [^unsafe/Pointer _addr, ^unsafe/Pointer _old, ^unsafe/Pointer _new])

JOKER FUNC sync/atomic.CompareAndSwapUint32 from sync/atomic/doc.go:
;; (defn ^"Boolean" CompareAndSwapUint32
;;   "CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value.\n\nGo input arguments: (addr *uint32, old uint32, new uint32)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of UInt32) addr, ^UInt32 old, ^UInt32 new]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapUint32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint32(_addr)), _old, _new)"}
;;   [^Object _addr, ^UInt32 _old, ^UInt32 _new])

JOKER FUNC sync/atomic.CompareAndSwapUint64 from sync/atomic/doc.go:
;; (defn ^"Boolean" CompareAndSwapUint64
;;   "CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value.\n\nGo input arguments: (addr *uint64, old uint64, new uint64)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of uint64) addr, ^uint64 old, ^uint64 new]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapUint64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint64(_addr)), _old, _new)"}
;;   [^Object _addr, ^ABEND044(pre.go: unsupported built-in type uint64) _old, ^ABEND044(pre.go: unsupported built-in type uint64) _new])

JOKER FUNC sync/atomic.CompareAndSwapUintptr from sync/atomic/doc.go:
;; (defn ^"Boolean" CompareAndSwapUintptr
;;   "CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value.\n\nGo input arguments: (addr *uintptr, old uintptr, new uintptr)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of UIntPtr) addr, ^UIntPtr old, ^UIntPtr new]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapUintptr(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuintptr(_addr)), _old, _new)"}
;;   [^Object _addr, ^UIntPtr _old, ^UIntPtr _new])

JOKER FUNC sync/atomic.LoadInt32 from sync/atomic/doc.go:
;; (defn LoadInt32
;;   "LoadInt32 atomically loads *addr.\n\nGo input arguments: (addr *int32)\n\nGo return type: int32\n\nJoker input arguments: [^(atom-of Int32) addr]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__loadInt32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint32(_addr)))"}
;;   [^Object _addr])

JOKER FUNC sync/atomic.LoadInt64 from sync/atomic/doc.go:
;; (defn LoadInt64
;;   "LoadInt64 atomically loads *addr.\n\nGo input arguments: (addr *int64)\n\nGo return type: int64\n\nJoker input arguments: [^(atom-of Int64) addr]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__loadInt64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(_addr)))"}
;;   [^Object _addr])

JOKER FUNC sync/atomic.LoadPointer from sync/atomic/doc.go:
;; (defn LoadPointer
;;   "LoadPointer atomically loads *addr.\n\nGo input arguments: (addr *unsafe.Pointer)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of go.std.unsafe/Pointer) addr]\n\nJoker return type: ABEND042(post.go: cannot find typename unsafe.Pointer)"
;;   {:added "1.0"
;;    :go "__loadPointer(_addr)"}
;;   [^unsafe/Pointer _addr])

JOKER FUNC sync/atomic.LoadUint32 from sync/atomic/doc.go:
;; (defn LoadUint32
;;   "LoadUint32 atomically loads *addr.\n\nGo input arguments: (addr *uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^(atom-of UInt32) addr]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__loadUint32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint32(_addr)))"}
;;   [^Object _addr])

JOKER FUNC sync/atomic.LoadUint64 from sync/atomic/doc.go:
;; (defn LoadUint64
;;   "LoadUint64 atomically loads *addr.\n\nGo input arguments: (addr *uint64)\n\nGo return type: uint64\n\nJoker input arguments: [^(atom-of uint64) addr]\n\nJoker return type: BigInt"
;;   {:added "1.0"
;;    :go "__loadUint64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint64(_addr)))"}
;;   [^Object _addr])

JOKER FUNC sync/atomic.LoadUintptr from sync/atomic/doc.go:
;; (defn LoadUintptr
;;   "LoadUintptr atomically loads *addr.\n\nGo input arguments: (addr *uintptr)\n\nGo return type: uintptr\n\nJoker input arguments: [^(atom-of UIntPtr) addr]\n\nJoker return type: BigInt"
;;   {:added "1.0"
;;    :go "__loadUintptr(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuintptr(_addr)))"}
;;   [^Object _addr])

JOKER FUNC sync/atomic.StoreInt32 from sync/atomic/doc.go:
;; (defn StoreInt32
;;   "StoreInt32 atomically stores val into *addr.\n\nGo input arguments: (addr *int32, val int32)\n\nJoker input arguments: [^(atom-of Int32) addr, ^Int32 val]"
;;   {:added "1.0"
;;    :go "__storeInt32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint32(_addr)), _val)"}
;;   [^Object _addr, ^Int32 _val])

JOKER FUNC sync/atomic.StoreInt64 from sync/atomic/doc.go:
;; (defn StoreInt64
;;   "StoreInt64 atomically stores val into *addr.\n\nGo input arguments: (addr *int64, val int64)\n\nJoker input arguments: [^(atom-of Int64) addr, ^Int64 val]"
;;   {:added "1.0"
;;    :go "__storeInt64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(_addr)), _val)"}
;;   [^Object _addr, ^Int64 _val])

JOKER FUNC sync/atomic.StorePointer from sync/atomic/doc.go:
;; (defn StorePointer
;;   "StorePointer atomically stores val into *addr.\n\nGo input arguments: (addr *unsafe.Pointer, val unsafe.Pointer)\n\nJoker input arguments: [^(atom-of go.std.unsafe/Pointer) addr, ^go.std.unsafe/Pointer val]"
;;   {:added "1.0"
;;    :go "__storePointer(_addr, *_val)"}
;;   [^unsafe/Pointer _addr, ^unsafe/Pointer _val])

JOKER FUNC sync/atomic.StoreUint32 from sync/atomic/doc.go:
;; (defn StoreUint32
;;   "StoreUint32 atomically stores val into *addr.\n\nGo input arguments: (addr *uint32, val uint32)\n\nJoker input arguments: [^(atom-of UInt32) addr, ^UInt32 val]"
;;   {:added "1.0"
;;    :go "__storeUint32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint32(_addr)), _val)"}
;;   [^Object _addr, ^UInt32 _val])

JOKER FUNC sync/atomic.StoreUint64 from sync/atomic/doc.go:
;; (defn StoreUint64
;;   "StoreUint64 atomically stores val into *addr.\n\nGo input arguments: (addr *uint64, val uint64)\n\nJoker input arguments: [^(atom-of uint64) addr, ^uint64 val]"
;;   {:added "1.0"
;;    :go "__storeUint64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint64(_addr)), _val)"}
;;   [^Object _addr, ^ABEND044(pre.go: unsupported built-in type uint64) _val])

JOKER FUNC sync/atomic.StoreUintptr from sync/atomic/doc.go:
;; (defn StoreUintptr
;;   "StoreUintptr atomically stores val into *addr.\n\nGo input arguments: (addr *uintptr, val uintptr)\n\nJoker input arguments: [^(atom-of UIntPtr) addr, ^UIntPtr val]"
;;   {:added "1.0"
;;    :go "__storeUintptr(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuintptr(_addr)), _val)"}
;;   [^Object _addr, ^UIntPtr _val])

JOKER FUNC sync/atomic.SwapInt32 from sync/atomic/doc.go:
;; (defn SwapInt32
;;   "SwapInt32 atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *int32, new int32)\n\nGo return type: int32\n\nJoker input arguments: [^(atom-of Int32) addr, ^Int32 new]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__swapInt32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint32(_addr)), _new)"}
;;   [^Object _addr, ^Int32 _new])

JOKER FUNC sync/atomic.SwapInt64 from sync/atomic/doc.go:
;; (defn SwapInt64
;;   "SwapInt64 atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *int64, new int64)\n\nGo return type: int64\n\nJoker input arguments: [^(atom-of Int64) addr, ^Int64 new]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__swapInt64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(_addr)), _new)"}
;;   [^Object _addr, ^Int64 _new])

JOKER FUNC sync/atomic.SwapPointer from sync/atomic/doc.go:
;; (defn SwapPointer
;;   "SwapPointer atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *unsafe.Pointer, new unsafe.Pointer)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of go.std.unsafe/Pointer) addr, ^go.std.unsafe/Pointer new]\n\nJoker return type: ABEND042(post.go: cannot find typename unsafe.Pointer)"
;;   {:added "1.0"
;;    :go "__swapPointer(_addr, *_new)"}
;;   [^unsafe/Pointer _addr, ^unsafe/Pointer _new])

JOKER FUNC sync/atomic.SwapUint32 from sync/atomic/doc.go:
;; (defn SwapUint32
;;   "SwapUint32 atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *uint32, new uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^(atom-of UInt32) addr, ^UInt32 new]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__swapUint32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint32(_addr)), _new)"}
;;   [^Object _addr, ^UInt32 _new])

JOKER FUNC sync/atomic.SwapUint64 from sync/atomic/doc.go:
;; (defn SwapUint64
;;   "SwapUint64 atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *uint64, new uint64)\n\nGo return type: uint64\n\nJoker input arguments: [^(atom-of uint64) addr, ^uint64 new]\n\nJoker return type: BigInt"
;;   {:added "1.0"
;;    :go "__swapUint64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint64(_addr)), _new)"}
;;   [^Object _addr, ^ABEND044(pre.go: unsupported built-in type uint64) _new])

JOKER FUNC sync/atomic.SwapUintptr from sync/atomic/doc.go:
;; (defn SwapUintptr
;;   "SwapUintptr atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *uintptr, new uintptr)\n\nGo return type: uintptr\n\nJoker input arguments: [^(atom-of UIntPtr) addr, ^UIntPtr new]\n\nJoker return type: BigInt"
;;   {:added "1.0"
;;    :go "__swapUintptr(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuintptr(_addr)), _new)"}
;;   [^Object _addr, ^UIntPtr _new])

JOKER TYPE syscall.Cmsghdr from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Cmsghdr.
  "Constructor for syscall.Cmsghdr"
  {:added "1.0"
   :go "_ConstructCmsghdr(_v)"}
  [^Object _v])

JOKER TYPE syscall.Conn from syscall/net.go:
;; (defn ^"GoObject" Conn.
;;   "Constructor for syscall.Conn"
;;   {:added "1.0"
;;    :go "_ConstructConn(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Credential from syscall/exec_unix.go:
(defn ^"GoObject" Credential.
  "Constructor for syscall.Credential"
  {:added "1.0"
   :go "_ConstructCredential(_v)"}
  [^Object _v])

JOKER TYPE syscall.Dirent from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Dirent.
  "Constructor for syscall.Dirent"
  {:added "1.0"
   :go "_ConstructDirent(_v)"}
  [^Object _v])

JOKER TYPE syscall.EpollEvent from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" EpollEvent.
  "Constructor for syscall.EpollEvent"
  {:added "1.0"
   :go "_ConstructEpollEvent(_v)"}
  [^Object _v])

JOKER TYPE syscall.Errno from syscall/syscall_unix.go:
(defn ^"GoObject" Errno.
  "Constructor for syscall.Errno"
  {:added "1.0"
   :go "_ConstructErrno(_v)"}
  [^Object _v])

JOKER TYPE syscall.FdSet from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" FdSet.
  "Constructor for syscall.FdSet"
  {:added "1.0"
   :go "_ConstructFdSet(_v)"}
  [^Object _v])

JOKER TYPE syscall.Flock_t from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Flock_t.
  "Constructor for syscall.Flock_t"
  {:added "1.0"
   :go "_ConstructFlock_t(_v)"}
  [^Object _v])

JOKER TYPE syscall.Fsid from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Fsid.
  "Constructor for syscall.Fsid"
  {:added "1.0"
   :go "_ConstructFsid(_v)"}
  [^Object _v])

JOKER TYPE syscall.ICMPv6Filter from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" ICMPv6Filter.
  "Constructor for syscall.ICMPv6Filter"
  {:added "1.0"
   :go "_ConstructICMPv6Filter(_v)"}
  [^Object _v])

JOKER TYPE syscall.IPMreq from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" IPMreq.
  "Constructor for syscall.IPMreq"
  {:added "1.0"
   :go "_ConstructIPMreq(_v)"}
  [^Object _v])

JOKER TYPE syscall.IPMreqn from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" IPMreqn.
  "Constructor for syscall.IPMreqn"
  {:added "1.0"
   :go "_ConstructIPMreqn(_v)"}
  [^Object _v])

JOKER TYPE syscall.IPv6MTUInfo from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" IPv6MTUInfo.
  "Constructor for syscall.IPv6MTUInfo"
  {:added "1.0"
   :go "_ConstructIPv6MTUInfo(_v)"}
  [^Object _v])

JOKER TYPE syscall.IPv6Mreq from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" IPv6Mreq.
  "Constructor for syscall.IPv6Mreq"
  {:added "1.0"
   :go "_ConstructIPv6Mreq(_v)"}
  [^Object _v])

JOKER TYPE syscall.IfAddrmsg from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" IfAddrmsg.
  "Constructor for syscall.IfAddrmsg"
  {:added "1.0"
   :go "_ConstructIfAddrmsg(_v)"}
  [^Object _v])

JOKER TYPE syscall.IfInfomsg from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" IfInfomsg.
  "Constructor for syscall.IfInfomsg"
  {:added "1.0"
   :go "_ConstructIfInfomsg(_v)"}
  [^Object _v])

JOKER TYPE syscall.Inet4Pktinfo from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Inet4Pktinfo.
  "Constructor for syscall.Inet4Pktinfo"
  {:added "1.0"
   :go "_ConstructInet4Pktinfo(_v)"}
  [^Object _v])

JOKER TYPE syscall.Inet6Pktinfo from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Inet6Pktinfo.
  "Constructor for syscall.Inet6Pktinfo"
  {:added "1.0"
   :go "_ConstructInet6Pktinfo(_v)"}
  [^Object _v])

JOKER TYPE syscall.InotifyEvent from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" InotifyEvent.
  "Constructor for syscall.InotifyEvent"
  {:added "1.0"
   :go "_ConstructInotifyEvent(_v)"}
  [^Object _v])

JOKER TYPE syscall.Iovec from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Iovec.
  "Constructor for syscall.Iovec"
  {:added "1.0"
   :go "_ConstructIovec(_v)"}
  [^Object _v])

JOKER TYPE syscall.Linger from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Linger.
  "Constructor for syscall.Linger"
  {:added "1.0"
   :go "_ConstructLinger(_v)"}
  [^Object _v])

JOKER TYPE syscall.Msghdr from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Msghdr.
  "Constructor for syscall.Msghdr"
  {:added "1.0"
   :go "_ConstructMsghdr(_v)"}
  [^Object _v])

JOKER TYPE syscall.NetlinkMessage from syscall/netlink_linux.go:
(defn ^"GoObject" NetlinkMessage.
  "Constructor for syscall.NetlinkMessage"
  {:added "1.0"
   :go "_ConstructNetlinkMessage(_v)"}
  [^Object _v])

JOKER TYPE syscall.NetlinkRouteAttr from syscall/netlink_linux.go:
(defn ^"GoObject" NetlinkRouteAttr.
  "Constructor for syscall.NetlinkRouteAttr"
  {:added "1.0"
   :go "_ConstructNetlinkRouteAttr(_v)"}
  [^Object _v])

JOKER TYPE syscall.NetlinkRouteRequest from syscall/netlink_linux.go:
(defn ^"GoObject" NetlinkRouteRequest.
  "Constructor for syscall.NetlinkRouteRequest"
  {:added "1.0"
   :go "_ConstructNetlinkRouteRequest(_v)"}
  [^Object _v])

JOKER TYPE syscall.NlAttr from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" NlAttr.
  "Constructor for syscall.NlAttr"
  {:added "1.0"
   :go "_ConstructNlAttr(_v)"}
  [^Object _v])

JOKER TYPE syscall.NlMsgerr from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" NlMsgerr.
  "Constructor for syscall.NlMsgerr"
  {:added "1.0"
   :go "_ConstructNlMsgerr(_v)"}
  [^Object _v])

JOKER TYPE syscall.NlMsghdr from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" NlMsghdr.
  "Constructor for syscall.NlMsghdr"
  {:added "1.0"
   :go "_ConstructNlMsghdr(_v)"}
  [^Object _v])

JOKER TYPE syscall.ProcAttr from syscall/exec_unix.go:
(defn ^"GoObject" ProcAttr.
  "Constructor for syscall.ProcAttr"
  {:added "1.0"
   :go "_ConstructProcAttr(_v)"}
  [^Object _v])

JOKER TYPE syscall.PtraceRegs from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" PtraceRegs.
  "Constructor for syscall.PtraceRegs"
  {:added "1.0"
   :go "_ConstructPtraceRegs(_v)"}
  [^Object _v])

JOKER TYPE syscall.RawConn from syscall/net.go:
;; (defn ^"GoObject" RawConn.
;;   "Constructor for syscall.RawConn"
;;   {:added "1.0"
;;    :go "_ConstructRawConn(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.RawSockaddr from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" RawSockaddr.
  "Constructor for syscall.RawSockaddr"
  {:added "1.0"
   :go "_ConstructRawSockaddr(_v)"}
  [^Object _v])

JOKER TYPE syscall.RawSockaddrAny from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" RawSockaddrAny.
  "Constructor for syscall.RawSockaddrAny"
  {:added "1.0"
   :go "_ConstructRawSockaddrAny(_v)"}
  [^Object _v])

JOKER TYPE syscall.RawSockaddrInet4 from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" RawSockaddrInet4.
  "Constructor for syscall.RawSockaddrInet4"
  {:added "1.0"
   :go "_ConstructRawSockaddrInet4(_v)"}
  [^Object _v])

JOKER TYPE syscall.RawSockaddrInet6 from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" RawSockaddrInet6.
  "Constructor for syscall.RawSockaddrInet6"
  {:added "1.0"
   :go "_ConstructRawSockaddrInet6(_v)"}
  [^Object _v])

JOKER TYPE syscall.RawSockaddrLinklayer from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" RawSockaddrLinklayer.
  "Constructor for syscall.RawSockaddrLinklayer"
  {:added "1.0"
   :go "_ConstructRawSockaddrLinklayer(_v)"}
  [^Object _v])

JOKER TYPE syscall.RawSockaddrNetlink from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" RawSockaddrNetlink.
  "Constructor for syscall.RawSockaddrNetlink"
  {:added "1.0"
   :go "_ConstructRawSockaddrNetlink(_v)"}
  [^Object _v])

JOKER TYPE syscall.RawSockaddrUnix from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" RawSockaddrUnix.
  "Constructor for syscall.RawSockaddrUnix"
  {:added "1.0"
   :go "_ConstructRawSockaddrUnix(_v)"}
  [^Object _v])

JOKER TYPE syscall.Rlimit from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Rlimit.
  "Constructor for syscall.Rlimit"
  {:added "1.0"
   :go "_ConstructRlimit(_v)"}
  [^Object _v])

JOKER TYPE syscall.RtAttr from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" RtAttr.
  "Constructor for syscall.RtAttr"
  {:added "1.0"
   :go "_ConstructRtAttr(_v)"}
  [^Object _v])

JOKER TYPE syscall.RtGenmsg from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" RtGenmsg.
  "Constructor for syscall.RtGenmsg"
  {:added "1.0"
   :go "_ConstructRtGenmsg(_v)"}
  [^Object _v])

JOKER TYPE syscall.RtMsg from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" RtMsg.
  "Constructor for syscall.RtMsg"
  {:added "1.0"
   :go "_ConstructRtMsg(_v)"}
  [^Object _v])

JOKER TYPE syscall.RtNexthop from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" RtNexthop.
  "Constructor for syscall.RtNexthop"
  {:added "1.0"
   :go "_ConstructRtNexthop(_v)"}
  [^Object _v])

JOKER TYPE syscall.Rusage from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Rusage.
  "Constructor for syscall.Rusage"
  {:added "1.0"
   :go "_ConstructRusage(_v)"}
  [^Object _v])

JOKER TYPE syscall.Signal from syscall/syscall_unix.go:
(defn ^"GoObject" Signal.
  "Constructor for syscall.Signal"
  {:added "1.0"
   :go "_ConstructSignal(_v)"}
  [^Object _v])

JOKER TYPE syscall.SockFilter from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" SockFilter.
  "Constructor for syscall.SockFilter"
  {:added "1.0"
   :go "_ConstructSockFilter(_v)"}
  [^Object _v])

JOKER TYPE syscall.SockFprog from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" SockFprog.
  "Constructor for syscall.SockFprog"
  {:added "1.0"
   :go "_ConstructSockFprog(_v)"}
  [^Object _v])

JOKER TYPE syscall.Sockaddr from syscall/syscall_unix.go:
;; (defn ^"GoObject" Sockaddr.
;;   "Constructor for syscall.Sockaddr"
;;   {:added "1.0"
;;    :go "_ConstructSockaddr(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.SockaddrInet4 from syscall/syscall_unix.go:
(defn ^"GoObject" SockaddrInet4.
  "Constructor for syscall.SockaddrInet4"
  {:added "1.0"
   :go "_ConstructSockaddrInet4(_v)"}
  [^Object _v])

JOKER TYPE syscall.SockaddrInet6 from syscall/syscall_unix.go:
(defn ^"GoObject" SockaddrInet6.
  "Constructor for syscall.SockaddrInet6"
  {:added "1.0"
   :go "_ConstructSockaddrInet6(_v)"}
  [^Object _v])

JOKER TYPE syscall.SockaddrLinklayer from syscall/syscall_linux.go:
(defn ^"GoObject" SockaddrLinklayer.
  "Constructor for syscall.SockaddrLinklayer"
  {:added "1.0"
   :go "_ConstructSockaddrLinklayer(_v)"}
  [^Object _v])

JOKER TYPE syscall.SockaddrNetlink from syscall/syscall_linux.go:
(defn ^"GoObject" SockaddrNetlink.
  "Constructor for syscall.SockaddrNetlink"
  {:added "1.0"
   :go "_ConstructSockaddrNetlink(_v)"}
  [^Object _v])

JOKER TYPE syscall.SockaddrUnix from syscall/syscall_unix.go:
(defn ^"GoObject" SockaddrUnix.
  "Constructor for syscall.SockaddrUnix"
  {:added "1.0"
   :go "_ConstructSockaddrUnix(_v)"}
  [^Object _v])

JOKER TYPE syscall.SocketControlMessage from syscall/sockcmsg_unix.go:
(defn ^"GoObject" SocketControlMessage.
  "Constructor for syscall.SocketControlMessage"
  {:added "1.0"
   :go "_ConstructSocketControlMessage(_v)"}
  [^Object _v])

JOKER TYPE syscall.Stat_t from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Stat_t.
  "Constructor for syscall.Stat_t"
  {:added "1.0"
   :go "_ConstructStat_t(_v)"}
  [^Object _v])

JOKER TYPE syscall.Statfs_t from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Statfs_t.
  "Constructor for syscall.Statfs_t"
  {:added "1.0"
   :go "_ConstructStatfs_t(_v)"}
  [^Object _v])

JOKER TYPE syscall.SysProcAttr from syscall/exec_linux.go:
(defn ^"GoObject" SysProcAttr.
  "Constructor for syscall.SysProcAttr"
  {:added "1.0"
   :go "_ConstructSysProcAttr(_v)"}
  [^Object _v])

JOKER TYPE syscall.SysProcIDMap from syscall/exec_linux.go:
(defn ^"GoObject" SysProcIDMap.
  "Constructor for syscall.SysProcIDMap"
  {:added "1.0"
   :go "_ConstructSysProcIDMap(_v)"}
  [^Object _v])

JOKER TYPE syscall.Sysinfo_t from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Sysinfo_t.
  "Constructor for syscall.Sysinfo_t"
  {:added "1.0"
   :go "_ConstructSysinfo_t(_v)"}
  [^Object _v])

JOKER TYPE syscall.TCPInfo from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" TCPInfo.
  "Constructor for syscall.TCPInfo"
  {:added "1.0"
   :go "_ConstructTCPInfo(_v)"}
  [^Object _v])

JOKER TYPE syscall.Termios from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Termios.
  "Constructor for syscall.Termios"
  {:added "1.0"
   :go "_ConstructTermios(_v)"}
  [^Object _v])

JOKER TYPE syscall.Time_t from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Time_t.
  "Constructor for syscall.Time_t"
  {:added "1.0"
   :go "_ConstructTime_t(_v)"}
  [^Object _v])

JOKER TYPE syscall.Timespec from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Timespec.
  "Constructor for syscall.Timespec"
  {:added "1.0"
   :go "_ConstructTimespec(_v)"}
  [^Object _v])

JOKER TYPE syscall.Timeval from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Timeval.
  "Constructor for syscall.Timeval"
  {:added "1.0"
   :go "_ConstructTimeval(_v)"}
  [^Object _v])

JOKER TYPE syscall.Timex from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Timex.
  "Constructor for syscall.Timex"
  {:added "1.0"
   :go "_ConstructTimex(_v)"}
  [^Object _v])

JOKER TYPE syscall.Tms from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Tms.
  "Constructor for syscall.Tms"
  {:added "1.0"
   :go "_ConstructTms(_v)"}
  [^Object _v])

JOKER TYPE syscall.Ucred from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Ucred.
  "Constructor for syscall.Ucred"
  {:added "1.0"
   :go "_ConstructUcred(_v)"}
  [^Object _v])

JOKER TYPE syscall.Ustat_t from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Ustat_t.
  "Constructor for syscall.Ustat_t"
  {:added "1.0"
   :go "_ConstructUstat_t(_v)"}
  [^Object _v])

JOKER TYPE syscall.Utimbuf from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Utimbuf.
  "Constructor for syscall.Utimbuf"
  {:added "1.0"
   :go "_ConstructUtimbuf(_v)"}
  [^Object _v])

JOKER TYPE syscall.Utsname from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Utsname.
  "Constructor for syscall.Utsname"
  {:added "1.0"
   :go "_ConstructUtsname(_v)"}
  [^Object _v])

JOKER TYPE syscall.WaitStatus from syscall/syscall_linux.go:
(defn ^"GoObject" WaitStatus.
  "Constructor for syscall.WaitStatus"
  {:added "1.0"
   :go "_ConstructWaitStatus(_v)"}
  [^Object _v])

JOKER FUNC syscall.Accept from syscall/syscall_linux.go:
(defn Accept
  "Go input arguments: (fd int)\n\nGo return type: (nfd int, sa Sockaddr, err error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [Int go.std.syscall/Sockaddr Error]"
  {:added "1.0"
   :go "__accept(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.Accept4 from syscall/syscall_linux.go:
(defn Accept4
  "Go input arguments: (fd int, flags int)\n\nGo return type: (nfd int, sa Sockaddr, err error)\n\nJoker input arguments: [^Int fd, ^Int flags]\n\nJoker return type: [Int go.std.syscall/Sockaddr Error]"
  {:added "1.0"
   :go "__accept4(_fd, _flags)"}
  [^Int _fd, ^Int _flags])

JOKER FUNC syscall.Access from syscall/syscall_linux.go:
(defn ^"Error" Access
  "Go input arguments: (path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^UInt32 mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Access(_path, _mode)"}
  [^String _path, ^UInt32 _mode])

JOKER FUNC syscall.Acct from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Acct
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Acct(_path)"}
  [^String _path])

JOKER FUNC syscall.Adjtimex from syscall/zsyscall_linux_amd64.go:
(defn Adjtimex
  "Go input arguments: (buf *Timex)\n\nGo return type: (state int, err error)\n\nJoker input arguments: [^(atom-of go.std.syscall/Timex) buf]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__adjtimex(_buf)"}
  [^syscall/Timex _buf])

JOKER FUNC syscall.AttachLsf from syscall/lsf_linux.go:
;; (defn ^"Error" AttachLsf
;;   "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int, i []SockFilter)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(vector-of go.std.syscall/SockFilter) i]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.AttachLsf(_fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_syscall.SockFilter(*_i)))"}
;;   [^Int _fd, ^Object _i])

JOKER FUNC syscall.Bind from syscall/syscall_unix.go:
(defn ^"Error" Bind
  "Go input arguments: (fd int, sa Sockaddr)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^go.std.syscall/Sockaddr sa]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Bind(_fd, *_sa)"}
  [^Int _fd, ^syscall/Sockaddr _sa])

JOKER FUNC syscall.BindToDevice from syscall/syscall_linux.go:
(defn ^"Error" BindToDevice
  "BindToDevice binds the socket associated with fd to device.\n\nGo input arguments: (fd int, device string)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^String device]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.BindToDevice(_fd, _device)"}
  [^Int _fd, ^String _device])

JOKER FUNC syscall.BytePtrFromString from syscall/syscall.go:
(defn BytePtrFromString
  "BytePtrFromString returns a pointer to a NUL-terminated array of\nbytes containing the text of s. If s contains a NUL byte at any\nlocation, it returns (nil, EINVAL).\n\nGo input arguments: (s string)\n\nGo return type: (*byte, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [(atom-of Int) Error]"
  {:added "1.0"
   :go "__bytePtrFromString(_s)"}
  [^String _s])

JOKER FUNC syscall.ByteSliceFromString from syscall/syscall.go:
(defn ByteSliceFromString
  "ByteSliceFromString returns a NUL-terminated slice of bytes\ncontaining the text of s. If s contains a NUL byte at any\nlocation, it returns (nil, EINVAL).\n\nGo input arguments: (s string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__byteSliceFromString(_s)"}
  [^String _s])

JOKER FUNC syscall.Chdir from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Chdir
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chdir(_path)"}
  [^String _path])

JOKER FUNC syscall.Chmod from syscall/syscall_linux.go:
(defn ^"Error" Chmod
  "Go input arguments: (path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^UInt32 mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chmod(_path, _mode)"}
  [^String _path, ^UInt32 _mode])

JOKER FUNC syscall.Chown from syscall/syscall_linux.go:
(defn ^"Error" Chown
  "Go input arguments: (path string, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chown(_path, _uid, _gid)"}
  [^String _path, ^Int _uid, ^Int _gid])

JOKER FUNC syscall.Chroot from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Chroot
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chroot(_path)"}
  [^String _path])

JOKER FUNC syscall.Clearenv from syscall/env_unix.go:
;; (defn Clearenv
;;   "Joker input arguments: []"
;;   {:added "1.0"
;;    :go "__clearenv()"}
;;   [])

JOKER FUNC syscall.Close from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Close
  "Go input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Close(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.CloseOnExec from syscall/exec_unix.go:
;; (defn CloseOnExec
;;   "Go input arguments: (fd int)\n\nJoker input arguments: [^Int fd]"
;;   {:added "1.0"
;;    :go "__closeOnExec(_fd)"}
;;   [^Int _fd])

JOKER FUNC syscall.CmsgLen from syscall/sockcmsg_unix.go:
(defn ^"Int" CmsgLen
  "CmsgLen returns the value to store in the Len field of the Cmsghdr\nstructure, taking into account any necessary alignment.\n\nGo input arguments: (datalen int)\n\nGo return type: int\n\nJoker input arguments: [^Int datalen]\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.CmsgLen(_datalen)"}
  [^Int _datalen])

JOKER FUNC syscall.CmsgSpace from syscall/sockcmsg_unix.go:
(defn ^"Int" CmsgSpace
  "CmsgSpace returns the number of bytes an ancillary element with\npayload of the passed data length occupies.\n\nGo input arguments: (datalen int)\n\nGo return type: int\n\nJoker input arguments: [^Int datalen]\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.CmsgSpace(_datalen)"}
  [^Int _datalen])

JOKER FUNC syscall.Connect from syscall/syscall_unix.go:
(defn ^"Error" Connect
  "Go input arguments: (fd int, sa Sockaddr)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^go.std.syscall/Sockaddr sa]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Connect(_fd, *_sa)"}
  [^Int _fd, ^syscall/Sockaddr _sa])

JOKER FUNC syscall.Creat from syscall/syscall_linux.go:
(defn Creat
  "Go input arguments: (path string, mode uint32)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^String path, ^UInt32 mode]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__creat(_path, _mode)"}
  [^String _path, ^UInt32 _mode])

JOKER FUNC syscall.DetachLsf from syscall/lsf_linux.go:
(defn ^"Error" DetachLsf
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.DetachLsf(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.Dup from syscall/zsyscall_linux_amd64.go:
(defn Dup
  "Go input arguments: (oldfd int)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^Int oldfd]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__dup(_oldfd)"}
  [^Int _oldfd])

JOKER FUNC syscall.Dup2 from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Dup2
  "Go input arguments: (oldfd int, newfd int)\n\nGo return type: error\n\nJoker input arguments: [^Int oldfd, ^Int newfd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Dup2(_oldfd, _newfd)"}
  [^Int _oldfd, ^Int _newfd])

JOKER FUNC syscall.Dup3 from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Dup3
  "Go input arguments: (oldfd int, newfd int, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int oldfd, ^Int newfd, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Dup3(_oldfd, _newfd, _flags)"}
  [^Int _oldfd, ^Int _newfd, ^Int _flags])

JOKER FUNC syscall.Environ from syscall/env_unix.go:
(defn Environ
  "Go return type: []string\n\nJoker input arguments: []\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__environ()"}
  [])

JOKER FUNC syscall.EpollCreate from syscall/zsyscall_linux_amd64.go:
(defn EpollCreate
  "Go input arguments: (size int)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^Int size]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__epollCreate(_size)"}
  [^Int _size])

JOKER FUNC syscall.EpollCreate1 from syscall/zsyscall_linux_amd64.go:
(defn EpollCreate1
  "Go input arguments: (flag int)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^Int flag]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__epollCreate1(_flag)"}
  [^Int _flag])

JOKER FUNC syscall.EpollCtl from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" EpollCtl
  "Go input arguments: (epfd int, op int, fd int, event *EpollEvent)\n\nGo return type: error\n\nJoker input arguments: [^Int epfd, ^Int op, ^Int fd, ^(atom-of go.std.syscall/EpollEvent) event]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.EpollCtl(_epfd, _op, _fd, _event)"}
  [^Int _epfd, ^Int _op, ^Int _fd, ^syscall/EpollEvent _event])

JOKER FUNC syscall.EpollWait from syscall/zsyscall_linux_amd64.go:
;; (defn EpollWait
;;   "Go input arguments: (epfd int, events []EpollEvent, msec int)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int epfd, ^(vector-of go.std.syscall/EpollEvent) events, ^Int msec]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__epollWait(_epfd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_syscall.EpollEvent(*_events)), _msec)"}
;;   [^Int _epfd, ^Object _events, ^Int _msec])

JOKER FUNC syscall.Exec from syscall/exec_unix.go:
;; (defn ^"Error" Exec
;;   "Exec invokes the execve(2) system call.\n\nGo input arguments: (argv0 string, argv []string, envv []string)\n\nGo return type: error\n\nJoker input arguments: [^String argv0, ^(vector-of String) argv, ^(vector-of String) envv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Exec(_argv0, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(_argv)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(_envv)))"}
;;   [^String _argv0, ^Object _argv, ^Object _envv])

JOKER FUNC syscall.Exit from syscall/syscall.go:
;; (defn Exit
;;   "Go input arguments: (code int)\n\nJoker input arguments: [^Int code]"
;;   {:added "1.0"
;;    :go "__exit(_code)"}
;;   [^Int _code])

JOKER FUNC syscall.Faccessat from syscall/syscall_linux.go:
(defn ^"Error" Faccessat
  "Go input arguments: (dirfd int, path string, mode uint32, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int dirfd, ^String path, ^UInt32 mode, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Faccessat(_dirfd, _path, _mode, _flags)"}
  [^Int _dirfd, ^String _path, ^UInt32 _mode, ^Int _flags])

JOKER FUNC syscall.Fallocate from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Fallocate
  "Go input arguments: (fd int, mode uint32, off int64, len int64)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^UInt32 mode, ^Int64 off, ^Int64 len]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fallocate(_fd, _mode, _off, _len)"}
  [^Int _fd, ^UInt32 _mode, ^Int64 _off, ^Int64 _len])

JOKER FUNC syscall.Fchdir from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Fchdir
  "Go input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchdir(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.Fchmod from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Fchmod
  "Go input arguments: (fd int, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^UInt32 mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchmod(_fd, _mode)"}
  [^Int _fd, ^UInt32 _mode])

JOKER FUNC syscall.Fchmodat from syscall/syscall_linux.go:
(defn ^"Error" Fchmodat
  "Go input arguments: (dirfd int, path string, mode uint32, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int dirfd, ^String path, ^UInt32 mode, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchmodat(_dirfd, _path, _mode, _flags)"}
  [^Int _dirfd, ^String _path, ^UInt32 _mode, ^Int _flags])

JOKER FUNC syscall.Fchown from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Fchown
  "Go input arguments: (fd int, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchown(_fd, _uid, _gid)"}
  [^Int _fd, ^Int _uid, ^Int _gid])

JOKER FUNC syscall.Fchownat from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Fchownat
  "Go input arguments: (dirfd int, path string, uid int, gid int, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int dirfd, ^String path, ^Int uid, ^Int gid, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchownat(_dirfd, _path, _uid, _gid, _flags)"}
  [^Int _dirfd, ^String _path, ^Int _uid, ^Int _gid, ^Int _flags])

JOKER FUNC syscall.FcntlFlock from syscall/flock.go:
(defn ^"Error" FcntlFlock
  "FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.\n\nGo input arguments: (fd uintptr, cmd int, lk *Flock_t)\n\nGo return type: error\n\nJoker input arguments: [^UIntPtr fd, ^Int cmd, ^(atom-of go.std.syscall/Flock_t) lk]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.FcntlFlock(_fd, _cmd, _lk)"}
  [^UIntPtr _fd, ^Int _cmd, ^syscall/Flock_t _lk])

JOKER FUNC syscall.Fdatasync from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Fdatasync
  "Go input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fdatasync(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.Flock from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Flock
  "Go input arguments: (fd int, how int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int how]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Flock(_fd, _how)"}
  [^Int _fd, ^Int _how])

JOKER FUNC syscall.ForkExec from syscall/exec_unix.go:
;; (defn ForkExec
;;   "Combination of fork and exec, careful to be thread safe.\n\nGo input arguments: (argv0 string, argv []string, attr *ProcAttr)\n\nGo return type: (pid int, err error)\n\nJoker input arguments: [^String argv0, ^(vector-of String) argv, ^(atom-of go.std.syscall/ProcAttr) attr]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__forkExec(_argv0, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(_argv)), _attr)"}
;;   [^String _argv0, ^Object _argv, ^syscall/ProcAttr _attr])

JOKER FUNC syscall.Fstat from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Fstat
  "Go input arguments: (fd int, stat *Stat_t)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(atom-of go.std.syscall/Stat_t) stat]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fstat(_fd, _stat)"}
  [^Int _fd, ^syscall/Stat_t _stat])

JOKER FUNC syscall.Fstatfs from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Fstatfs
  "Go input arguments: (fd int, buf *Statfs_t)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(atom-of go.std.syscall/Statfs_t) buf]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fstatfs(_fd, _buf)"}
  [^Int _fd, ^syscall/Statfs_t _buf])

JOKER FUNC syscall.Fsync from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Fsync
  "Go input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fsync(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.Ftruncate from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Ftruncate
  "Go input arguments: (fd int, length int64)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int64 length]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Ftruncate(_fd, _length)"}
  [^Int _fd, ^Int64 _length])

JOKER FUNC syscall.Futimes from syscall/syscall_linux.go:
;; (defn ^"Error" Futimes
;;   "Go input arguments: (fd int, tv []Timeval)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(vector-of go.std.syscall/Timeval) tv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Futimes(_fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_syscall.Timeval(*_tv)))"}
;;   [^Int _fd, ^Object _tv])

JOKER FUNC syscall.Futimesat from syscall/syscall_linux.go:
;; (defn ^"Error" Futimesat
;;   "Go input arguments: (dirfd int, path string, tv []Timeval)\n\nGo return type: error\n\nJoker input arguments: [^Int dirfd, ^String path, ^(vector-of go.std.syscall/Timeval) tv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Futimesat(_dirfd, _path, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_syscall.Timeval(*_tv)))"}
;;   [^Int _dirfd, ^String _path, ^Object _tv])

JOKER FUNC syscall.Getcwd from syscall/zsyscall_linux_amd64.go:
;; (defn Getcwd
;;   "Go input arguments: (buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(vector-of Byte) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__getcwd(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)))"}
;;   [^Object _buf])

JOKER FUNC syscall.Getdents from syscall/zsyscall_linux_amd64.go:
;; (defn Getdents
;;   "Go input arguments: (fd int, buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__getdents(_fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)))"}
;;   [^Int _fd, ^Object _buf])

JOKER FUNC syscall.Getegid from syscall/zsyscall_linux_amd64.go:
(defn ^"Int" Getegid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getegid()"}
  [])

JOKER FUNC syscall.Getenv from syscall/env_unix.go:
(defn Getenv
  "Go input arguments: (key string)\n\nGo return type: (value string, found bool)\n\nJoker input arguments: [^String key]\n\nJoker return type: [String Boolean]"
  {:added "1.0"
   :go "__getenv(_key)"}
  [^String _key])

JOKER FUNC syscall.Geteuid from syscall/zsyscall_linux_amd64.go:
(defn ^"Int" Geteuid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Geteuid()"}
  [])

JOKER FUNC syscall.Getgid from syscall/zsyscall_linux_amd64.go:
(defn ^"Int" Getgid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getgid()"}
  [])

JOKER FUNC syscall.Getgroups from syscall/syscall_linux.go:
(defn Getgroups
  "Go return type: (gids []int, err error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__getgroups()"}
  [])

JOKER FUNC syscall.Getpagesize from syscall/syscall.go:
(defn ^"Int" Getpagesize
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getpagesize()"}
  [])

JOKER FUNC syscall.Getpeername from syscall/syscall_unix.go:
(defn Getpeername
  "Go input arguments: (fd int)\n\nGo return type: (sa Sockaddr, err error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [go.std.syscall/Sockaddr Error]"
  {:added "1.0"
   :go "__getpeername(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.Getpgid from syscall/zsyscall_linux_amd64.go:
(defn Getpgid
  "Go input arguments: (pid int)\n\nGo return type: (pgid int, err error)\n\nJoker input arguments: [^Int pid]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__getpgid(_pid)"}
  [^Int _pid])

JOKER FUNC syscall.Getpgrp from syscall/syscall_linux.go:
(defn ^"Int" Getpgrp
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getpgrp()"}
  [])

JOKER FUNC syscall.Getpid from syscall/zsyscall_linux_amd64.go:
(defn ^"Int" Getpid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getpid()"}
  [])

JOKER FUNC syscall.Getppid from syscall/zsyscall_linux_amd64.go:
(defn ^"Int" Getppid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getppid()"}
  [])

JOKER FUNC syscall.Getpriority from syscall/zsyscall_linux_amd64.go:
(defn Getpriority
  "Go input arguments: (which int, who int)\n\nGo return type: (prio int, err error)\n\nJoker input arguments: [^Int which, ^Int who]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__getpriority(_which, _who)"}
  [^Int _which, ^Int _who])

JOKER FUNC syscall.Getrlimit from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Getrlimit
  "Go input arguments: (resource int, rlim *Rlimit)\n\nGo return type: error\n\nJoker input arguments: [^Int resource, ^(atom-of go.std.syscall/Rlimit) rlim]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Getrlimit(_resource, _rlim)"}
  [^Int _resource, ^syscall/Rlimit _rlim])

JOKER FUNC syscall.Getrusage from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Getrusage
  "Go input arguments: (who int, rusage *Rusage)\n\nGo return type: error\n\nJoker input arguments: [^Int who, ^(atom-of go.std.syscall/Rusage) rusage]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Getrusage(_who, _rusage)"}
  [^Int _who, ^syscall/Rusage _rusage])

JOKER FUNC syscall.Getsockname from syscall/syscall_linux.go:
(defn Getsockname
  "Go input arguments: (fd int)\n\nGo return type: (sa Sockaddr, err error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [go.std.syscall/Sockaddr Error]"
  {:added "1.0"
   :go "__getsockname(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.GetsockoptICMPv6Filter from syscall/syscall_linux.go:
(defn GetsockoptICMPv6Filter
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*ICMPv6Filter, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(atom-of go.std.syscall/ICMPv6Filter) Error]"
  {:added "1.0"
   :go "__getsockoptICMPv6Filter(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.GetsockoptIPMreq from syscall/syscall_linux.go:
(defn GetsockoptIPMreq
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*IPMreq, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(atom-of go.std.syscall/IPMreq) Error]"
  {:added "1.0"
   :go "__getsockoptIPMreq(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.GetsockoptIPMreqn from syscall/syscall_linux.go:
(defn GetsockoptIPMreqn
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*IPMreqn, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(atom-of go.std.syscall/IPMreqn) Error]"
  {:added "1.0"
   :go "__getsockoptIPMreqn(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.GetsockoptIPv6MTUInfo from syscall/syscall_linux.go:
(defn GetsockoptIPv6MTUInfo
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*IPv6MTUInfo, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(atom-of go.std.syscall/IPv6MTUInfo) Error]"
  {:added "1.0"
   :go "__getsockoptIPv6MTUInfo(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.GetsockoptIPv6Mreq from syscall/syscall_linux.go:
(defn GetsockoptIPv6Mreq
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*IPv6Mreq, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(atom-of go.std.syscall/IPv6Mreq) Error]"
  {:added "1.0"
   :go "__getsockoptIPv6Mreq(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.GetsockoptInet4Addr from syscall/syscall_linux.go:
(defn GetsockoptInet4Addr
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (value []byte, err error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__getsockoptInet4Addr(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.GetsockoptInt from syscall/syscall_unix.go:
(defn GetsockoptInt
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (value int, err error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__getsockoptInt(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.GetsockoptUcred from syscall/syscall_linux.go:
(defn GetsockoptUcred
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*Ucred, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(atom-of go.std.syscall/Ucred) Error]"
  {:added "1.0"
   :go "__getsockoptUcred(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.Gettid from syscall/zsyscall_linux_amd64.go:
(defn ^"Int" Gettid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Gettid()"}
  [])

JOKER FUNC syscall.Gettimeofday from syscall/syscall_linux_amd64.go:
(defn ^"Error" Gettimeofday
  "Go input arguments: (tv *Timeval)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.syscall/Timeval) tv]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Gettimeofday(_tv)"}
  [^syscall/Timeval _tv])

JOKER FUNC syscall.Getuid from syscall/zsyscall_linux_amd64.go:
(defn ^"Int" Getuid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getuid()"}
  [])

JOKER FUNC syscall.Getwd from syscall/syscall_linux.go:
(defn Getwd
  "Go return type: (wd string, err error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__getwd()"}
  [])

JOKER FUNC syscall.Getxattr from syscall/zsyscall_linux_amd64.go:
;; (defn Getxattr
;;   "Go input arguments: (path string, attr string, dest []byte)\n\nGo return type: (sz int, err error)\n\nJoker input arguments: [^String path, ^String attr, ^(vector-of Byte) dest]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__getxattr(_path, _attr, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_dest)))"}
;;   [^String _path, ^String _attr, ^Object _dest])

JOKER FUNC syscall.InotifyAddWatch from syscall/zsyscall_linux_amd64.go:
(defn InotifyAddWatch
  "Go input arguments: (fd int, pathname string, mask uint32)\n\nGo return type: (watchdesc int, err error)\n\nJoker input arguments: [^Int fd, ^String pathname, ^UInt32 mask]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__inotifyAddWatch(_fd, _pathname, _mask)"}
  [^Int _fd, ^String _pathname, ^UInt32 _mask])

JOKER FUNC syscall.InotifyInit from syscall/zsyscall_linux_amd64.go:
(defn InotifyInit
  "Go return type: (fd int, err error)\n\nJoker input arguments: []\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__inotifyInit()"}
  [])

JOKER FUNC syscall.InotifyInit1 from syscall/zsyscall_linux_amd64.go:
(defn InotifyInit1
  "Go input arguments: (flags int)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^Int flags]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__inotifyInit1(_flags)"}
  [^Int _flags])

JOKER FUNC syscall.InotifyRmWatch from syscall/zsyscall_linux_amd64.go:
(defn InotifyRmWatch
  "Go input arguments: (fd int, watchdesc uint32)\n\nGo return type: (success int, err error)\n\nJoker input arguments: [^Int fd, ^UInt32 watchdesc]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__inotifyRmWatch(_fd, _watchdesc)"}
  [^Int _fd, ^UInt32 _watchdesc])

JOKER FUNC syscall.Ioperm from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Ioperm
  "Go input arguments: (from int, num int, on int)\n\nGo return type: error\n\nJoker input arguments: [^Int from, ^Int num, ^Int on]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Ioperm(_from, _num, _on)"}
  [^Int _from, ^Int _num, ^Int _on])

JOKER FUNC syscall.Iopl from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Iopl
  "Go input arguments: (level int)\n\nGo return type: error\n\nJoker input arguments: [^Int level]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Iopl(_level)"}
  [^Int _level])

JOKER FUNC syscall.Kill from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Kill
  "Go input arguments: (pid int, sig Signal)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^go.std.syscall/Signal sig]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Kill(_pid, *_sig)"}
  [^Int _pid, ^syscall/Signal _sig])

JOKER FUNC syscall.Klogctl from syscall/zsyscall_linux_amd64.go:
;; (defn Klogctl
;;   "Go input arguments: (typ int, buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int typ, ^(vector-of Byte) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__klogctl(_typ, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)))"}
;;   [^Int _typ, ^Object _buf])

JOKER FUNC syscall.Lchown from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Lchown
  "Go input arguments: (path string, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Lchown(_path, _uid, _gid)"}
  [^String _path, ^Int _uid, ^Int _gid])

JOKER FUNC syscall.Link from syscall/syscall_linux.go:
(defn ^"Error" Link
  "Go input arguments: (oldpath string, newpath string)\n\nGo return type: error\n\nJoker input arguments: [^String oldpath, ^String newpath]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Link(_oldpath, _newpath)"}
  [^String _oldpath, ^String _newpath])

JOKER FUNC syscall.Listen from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Listen
  "Go input arguments: (s int, n int)\n\nGo return type: error\n\nJoker input arguments: [^Int s, ^Int n]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Listen(_s, _n)"}
  [^Int _s, ^Int _n])

JOKER FUNC syscall.Listxattr from syscall/zsyscall_linux_amd64.go:
;; (defn Listxattr
;;   "Go input arguments: (path string, dest []byte)\n\nGo return type: (sz int, err error)\n\nJoker input arguments: [^String path, ^(vector-of Byte) dest]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__listxattr(_path, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_dest)))"}
;;   [^String _path, ^Object _dest])

JOKER FUNC syscall.LsfJump from syscall/lsf_linux.go:
(defn LsfJump
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (code int, k int, jt int, jf int)\n\nGo return type: *SockFilter\n\nJoker input arguments: [^Int code, ^Int k, ^Int jt, ^Int jf]\n\nJoker return type: (atom-of go.std.syscall/SockFilter)"
  {:added "1.0"
   :go "__lsfJump(_code, _k, _jt, _jf)"}
  [^Int _code, ^Int _k, ^Int _jt, ^Int _jf])

JOKER FUNC syscall.LsfSocket from syscall/lsf_linux.go:
(defn LsfSocket
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (ifindex int, proto int)\n\nGo return type: (int, error)\n\nJoker input arguments: [^Int ifindex, ^Int proto]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__lsfSocket(_ifindex, _proto)"}
  [^Int _ifindex, ^Int _proto])

JOKER FUNC syscall.LsfStmt from syscall/lsf_linux.go:
(defn LsfStmt
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (code int, k int)\n\nGo return type: *SockFilter\n\nJoker input arguments: [^Int code, ^Int k]\n\nJoker return type: (atom-of go.std.syscall/SockFilter)"
  {:added "1.0"
   :go "__lsfStmt(_code, _k)"}
  [^Int _code, ^Int _k])

JOKER FUNC syscall.Lstat from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Lstat
  "Go input arguments: (path string, stat *Stat_t)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(atom-of go.std.syscall/Stat_t) stat]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Lstat(_path, _stat)"}
  [^String _path, ^syscall/Stat_t _stat])

JOKER FUNC syscall.Madvise from syscall/zsyscall_linux_amd64.go:
;; (defn ^"Error" Madvise
;;   "Go input arguments: (b []byte, advice int)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) b, ^Int advice]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Madvise(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)), _advice)"}
;;   [^Object _b, ^Int _advice])

JOKER FUNC syscall.Mkdir from syscall/syscall_linux.go:
(defn ^"Error" Mkdir
  "Go input arguments: (path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^UInt32 mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mkdir(_path, _mode)"}
  [^String _path, ^UInt32 _mode])

JOKER FUNC syscall.Mkdirat from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Mkdirat
  "Go input arguments: (dirfd int, path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^Int dirfd, ^String path, ^UInt32 mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mkdirat(_dirfd, _path, _mode)"}
  [^Int _dirfd, ^String _path, ^UInt32 _mode])

JOKER FUNC syscall.Mkfifo from syscall/syscall_linux.go:
(defn ^"Error" Mkfifo
  "Go input arguments: (path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^UInt32 mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mkfifo(_path, _mode)"}
  [^String _path, ^UInt32 _mode])

JOKER FUNC syscall.Mknod from syscall/syscall_linux.go:
(defn ^"Error" Mknod
  "Go input arguments: (path string, mode uint32, dev int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^UInt32 mode, ^Int dev]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mknod(_path, _mode, _dev)"}
  [^String _path, ^UInt32 _mode, ^Int _dev])

JOKER FUNC syscall.Mknodat from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Mknodat
  "Go input arguments: (dirfd int, path string, mode uint32, dev int)\n\nGo return type: error\n\nJoker input arguments: [^Int dirfd, ^String path, ^UInt32 mode, ^Int dev]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mknodat(_dirfd, _path, _mode, _dev)"}
  [^Int _dirfd, ^String _path, ^UInt32 _mode, ^Int _dev])

JOKER FUNC syscall.Mlock from syscall/zsyscall_linux_amd64.go:
;; (defn ^"Error" Mlock
;;   "Go input arguments: (b []byte)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Mlock(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _b])

JOKER FUNC syscall.Mlockall from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Mlockall
  "Go input arguments: (flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mlockall(_flags)"}
  [^Int _flags])

JOKER FUNC syscall.Mmap from syscall/syscall_linux.go:
(defn Mmap
  "Go input arguments: (fd int, offset int64, length int, prot int, flags int)\n\nGo return type: (data []byte, err error)\n\nJoker input arguments: [^Int fd, ^Int64 offset, ^Int length, ^Int prot, ^Int flags]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__mmap(_fd, _offset, _length, _prot, _flags)"}
  [^Int _fd, ^Int64 _offset, ^Int _length, ^Int _prot, ^Int _flags])

JOKER FUNC syscall.Mount from syscall/syscall_linux.go:
(defn ^"Error" Mount
  "Go input arguments: (source string, target string, fstype string, flags uintptr, data string)\n\nGo return type: error\n\nJoker input arguments: [^String source, ^String target, ^String fstype, ^UIntPtr flags, ^String data]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mount(_source, _target, _fstype, _flags, _data)"}
  [^String _source, ^String _target, ^String _fstype, ^UIntPtr _flags, ^String _data])

JOKER FUNC syscall.Mprotect from syscall/zsyscall_linux_amd64.go:
;; (defn ^"Error" Mprotect
;;   "Go input arguments: (b []byte, prot int)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) b, ^Int prot]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Mprotect(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)), _prot)"}
;;   [^Object _b, ^Int _prot])

JOKER FUNC syscall.Munlock from syscall/zsyscall_linux_amd64.go:
;; (defn ^"Error" Munlock
;;   "Go input arguments: (b []byte)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Munlock(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _b])

JOKER FUNC syscall.Munlockall from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Munlockall
  "Go return type: error\n\nJoker input arguments: []\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Munlockall()"}
  [])

JOKER FUNC syscall.Munmap from syscall/syscall_linux.go:
;; (defn ^"Error" Munmap
;;   "Go input arguments: (b []byte)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Munmap(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _b])

JOKER FUNC syscall.Nanosleep from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Nanosleep
  "Go input arguments: (time *Timespec, leftover *Timespec)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.syscall/Timespec) time, ^(atom-of go.std.syscall/Timespec) leftover]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Nanosleep(_time, _leftover)"}
  [^syscall/Timespec _time, ^syscall/Timespec _leftover])

JOKER FUNC syscall.NetlinkRIB from syscall/netlink_linux.go:
(defn NetlinkRIB
  "NetlinkRIB returns routing information base, as known as RIB, which\nconsists of network facility information, states and parameters.\n\nGo input arguments: (proto int, family int)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^Int proto, ^Int family]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__netlinkRIB(_proto, _family)"}
  [^Int _proto, ^Int _family])

JOKER FUNC syscall.NsecToTimespec from syscall/timestruct.go:
(defn NsecToTimespec
  "NsecToTimespec takes a number of nanoseconds since the Unix epoch\nand returns the corresponding Timespec value.\n\nGo input arguments: (nsec int64)\n\nGo return type: Timespec\n\nJoker input arguments: [^Int64 nsec]\n\nJoker return type: go.std.syscall/Timespec"
  {:added "1.0"
   :go "__nsecToTimespec(_nsec)"}
  [^Int64 _nsec])

JOKER FUNC syscall.NsecToTimeval from syscall/timestruct.go:
(defn NsecToTimeval
  "NsecToTimeval takes a number of nanoseconds since the Unix epoch\nand returns the corresponding Timeval value.\n\nGo input arguments: (nsec int64)\n\nGo return type: Timeval\n\nJoker input arguments: [^Int64 nsec]\n\nJoker return type: go.std.syscall/Timeval"
  {:added "1.0"
   :go "__nsecToTimeval(_nsec)"}
  [^Int64 _nsec])

JOKER FUNC syscall.Open from syscall/syscall_linux.go:
(defn Open
  "Go input arguments: (path string, mode int, perm uint32)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^String path, ^Int mode, ^UInt32 perm]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__open(_path, _mode, _perm)"}
  [^String _path, ^Int _mode, ^UInt32 _perm])

JOKER FUNC syscall.Openat from syscall/syscall_linux.go:
(defn Openat
  "Go input arguments: (dirfd int, path string, flags int, mode uint32)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^Int dirfd, ^String path, ^Int flags, ^UInt32 mode]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__openat(_dirfd, _path, _flags, _mode)"}
  [^Int _dirfd, ^String _path, ^Int _flags, ^UInt32 _mode])

JOKER FUNC syscall.ParseDirent from syscall/dirent.go:
;; (defn ParseDirent
;;   "ParseDirent parses up to max directory entries in buf,\nappending the names to names. It returns the number of\nbytes consumed from buf, the number of entries added\nto names, and the new names slice.\n\nGo input arguments: (buf []byte, max int, names []string)\n\nGo return type: (consumed int, count int, newnames []string)\n\nJoker input arguments: [^(vector-of Byte) buf, ^Int max, ^(vector-of String) names]\n\nJoker return type: [Int Int (vector-of String)]"
;;   {:added "1.0"
;;    :go "__parseDirent(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)), _max, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(_names)))"}
;;   [^Object _buf, ^Int _max, ^Object _names])

JOKER FUNC syscall.ParseNetlinkMessage from syscall/netlink_linux.go:
;; (defn ParseNetlinkMessage
;;   "ParseNetlinkMessage parses b as an array of netlink messages and\nreturns the slice containing the NetlinkMessage structures.\n\nGo input arguments: (b []byte)\n\nGo return type: ([]NetlinkMessage, error)\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: [(vector-of go.std.syscall/NetlinkMessage) Error]"
;;   {:added "1.0"
;;    :go "__parseNetlinkMessage(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _b])

JOKER FUNC syscall.ParseNetlinkRouteAttr from syscall/netlink_linux.go:
(defn ParseNetlinkRouteAttr
  "ParseNetlinkRouteAttr parses m's payload as an array of netlink\nroute attributes and returns the slice containing the\nNetlinkRouteAttr structures.\n\nGo input arguments: (m *NetlinkMessage)\n\nGo return type: ([]NetlinkRouteAttr, error)\n\nJoker input arguments: [^(atom-of go.std.syscall/NetlinkMessage) m]\n\nJoker return type: [(vector-of go.std.syscall/NetlinkRouteAttr) Error]"
  {:added "1.0"
   :go "__parseNetlinkRouteAttr(_m)"}
  [^syscall/NetlinkMessage _m])

JOKER FUNC syscall.ParseSocketControlMessage from syscall/sockcmsg_unix.go:
;; (defn ParseSocketControlMessage
;;   "ParseSocketControlMessage parses b as an array of socket control\nmessages.\n\nGo input arguments: (b []byte)\n\nGo return type: ([]SocketControlMessage, error)\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: [(vector-of go.std.syscall/SocketControlMessage) Error]"
;;   {:added "1.0"
;;    :go "__parseSocketControlMessage(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _b])

JOKER FUNC syscall.ParseUnixCredentials from syscall/sockcmsg_linux.go:
(defn ParseUnixCredentials
  "ParseUnixCredentials decodes a socket control message that contains\ncredentials in a Ucred structure. To receive such a message, the\nSO_PASSCRED option must be enabled on the socket.\n\nGo input arguments: (m *SocketControlMessage)\n\nGo return type: (*Ucred, error)\n\nJoker input arguments: [^(atom-of go.std.syscall/SocketControlMessage) m]\n\nJoker return type: [(atom-of go.std.syscall/Ucred) Error]"
  {:added "1.0"
   :go "__parseUnixCredentials(_m)"}
  [^syscall/SocketControlMessage _m])

JOKER FUNC syscall.ParseUnixRights from syscall/sockcmsg_unix.go:
(defn ParseUnixRights
  "ParseUnixRights decodes a socket control message that contains an\ninteger array of open file descriptors from another process.\n\nGo input arguments: (m *SocketControlMessage)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^(atom-of go.std.syscall/SocketControlMessage) m]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__parseUnixRights(_m)"}
  [^syscall/SocketControlMessage _m])

JOKER FUNC syscall.Pause from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Pause
  "Go return type: error\n\nJoker input arguments: []\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Pause()"}
  [])

JOKER FUNC syscall.Pipe from syscall/syscall_linux_amd64.go:
;; (defn ^"Error" Pipe
;;   "Go input arguments: (p []int)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) p]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Pipe(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfint(_p)))"}
;;   [^Object _p])

JOKER FUNC syscall.Pipe2 from syscall/syscall_linux_amd64.go:
;; (defn ^"Error" Pipe2
;;   "Go input arguments: (p []int, flags int)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) p, ^Int flags]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Pipe2(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfint(_p)), _flags)"}
;;   [^Object _p, ^Int _flags])

JOKER FUNC syscall.PivotRoot from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" PivotRoot
  "Go input arguments: (newroot string, putold string)\n\nGo return type: error\n\nJoker input arguments: [^String newroot, ^String putold]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PivotRoot(_newroot, _putold)"}
  [^String _newroot, ^String _putold])

JOKER FUNC syscall.Pread from syscall/zsyscall_linux_amd64.go:
;; (defn Pread
;;   "Go input arguments: (fd int, p []byte, offset int64)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p, ^Int64 offset]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__pread(_fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)), _offset)"}
;;   [^Int _fd, ^Object _p, ^Int64 _offset])

JOKER FUNC syscall.PtraceAttach from syscall/syscall_linux.go:
(defn ^"Error" PtraceAttach
  "Go input arguments: (pid int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceAttach(_pid)"}
  [^Int _pid])

JOKER FUNC syscall.PtraceCont from syscall/syscall_linux.go:
(defn ^"Error" PtraceCont
  "Go input arguments: (pid int, signal int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^Int signal]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceCont(_pid, _signal)"}
  [^Int _pid, ^Int _signal])

JOKER FUNC syscall.PtraceDetach from syscall/syscall_linux.go:
(defn ^"Error" PtraceDetach
  "Go input arguments: (pid int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceDetach(_pid)"}
  [^Int _pid])

JOKER FUNC syscall.PtraceGetEventMsg from syscall/syscall_linux.go:
(defn PtraceGetEventMsg
  "Go input arguments: (pid int)\n\nGo return type: (msg uint, err error)\n\nJoker input arguments: [^Int pid]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__ptraceGetEventMsg(_pid)"}
  [^Int _pid])

JOKER FUNC syscall.PtraceGetRegs from syscall/syscall_linux.go:
(defn ^"Error" PtraceGetRegs
  "Go input arguments: (pid int, regsout *PtraceRegs)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^(atom-of go.std.syscall/PtraceRegs) regsout]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceGetRegs(_pid, _regsout)"}
  [^Int _pid, ^syscall/PtraceRegs _regsout])

JOKER FUNC syscall.PtracePeekData from syscall/syscall_linux.go:
;; (defn PtracePeekData
;;   "Go input arguments: (pid int, addr uintptr, out []byte)\n\nGo return type: (count int, err error)\n\nJoker input arguments: [^Int pid, ^UIntPtr addr, ^(vector-of Byte) out]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__ptracePeekData(_pid, _addr, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_out)))"}
;;   [^Int _pid, ^UIntPtr _addr, ^Object _out])

JOKER FUNC syscall.PtracePeekText from syscall/syscall_linux.go:
;; (defn PtracePeekText
;;   "Go input arguments: (pid int, addr uintptr, out []byte)\n\nGo return type: (count int, err error)\n\nJoker input arguments: [^Int pid, ^UIntPtr addr, ^(vector-of Byte) out]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__ptracePeekText(_pid, _addr, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_out)))"}
;;   [^Int _pid, ^UIntPtr _addr, ^Object _out])

JOKER FUNC syscall.PtracePokeData from syscall/syscall_linux.go:
;; (defn PtracePokeData
;;   "Go input arguments: (pid int, addr uintptr, data []byte)\n\nGo return type: (count int, err error)\n\nJoker input arguments: [^Int pid, ^UIntPtr addr, ^(vector-of Byte) data]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__ptracePokeData(_pid, _addr, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Int _pid, ^UIntPtr _addr, ^Object _data])

JOKER FUNC syscall.PtracePokeText from syscall/syscall_linux.go:
;; (defn PtracePokeText
;;   "Go input arguments: (pid int, addr uintptr, data []byte)\n\nGo return type: (count int, err error)\n\nJoker input arguments: [^Int pid, ^UIntPtr addr, ^(vector-of Byte) data]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__ptracePokeText(_pid, _addr, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Int _pid, ^UIntPtr _addr, ^Object _data])

JOKER FUNC syscall.PtraceSetOptions from syscall/syscall_linux.go:
(defn ^"Error" PtraceSetOptions
  "Go input arguments: (pid int, options int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^Int options]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceSetOptions(_pid, _options)"}
  [^Int _pid, ^Int _options])

JOKER FUNC syscall.PtraceSetRegs from syscall/syscall_linux.go:
(defn ^"Error" PtraceSetRegs
  "Go input arguments: (pid int, regs *PtraceRegs)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^(atom-of go.std.syscall/PtraceRegs) regs]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceSetRegs(_pid, _regs)"}
  [^Int _pid, ^syscall/PtraceRegs _regs])

JOKER FUNC syscall.PtraceSingleStep from syscall/syscall_linux.go:
(defn ^"Error" PtraceSingleStep
  "Go input arguments: (pid int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceSingleStep(_pid)"}
  [^Int _pid])

JOKER FUNC syscall.PtraceSyscall from syscall/syscall_linux.go:
(defn ^"Error" PtraceSyscall
  "Go input arguments: (pid int, signal int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^Int signal]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceSyscall(_pid, _signal)"}
  [^Int _pid, ^Int _signal])

JOKER FUNC syscall.Pwrite from syscall/zsyscall_linux_amd64.go:
;; (defn Pwrite
;;   "Go input arguments: (fd int, p []byte, offset int64)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p, ^Int64 offset]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__pwrite(_fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)), _offset)"}
;;   [^Int _fd, ^Object _p, ^Int64 _offset])

JOKER FUNC syscall.RawSyscall from syscall/syscall_unix.go:
(defn RawSyscall
  "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr)\n\nGo return type: (r1 uintptr, r2 uintptr, err Errno)\n\nJoker input arguments: [^UIntPtr trap, ^UIntPtr a1, ^UIntPtr a2, ^UIntPtr a3]\n\nJoker return type: [BigInt BigInt go.std.syscall/Errno]"
  {:added "1.0"
   :go "__rawSyscall(_trap, _a1, _a2, _a3)"}
  [^UIntPtr _trap, ^UIntPtr _a1, ^UIntPtr _a2, ^UIntPtr _a3])

JOKER FUNC syscall.RawSyscall6 from syscall/syscall_unix.go:
(defn RawSyscall6
  "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr)\n\nGo return type: (r1 uintptr, r2 uintptr, err Errno)\n\nJoker input arguments: [^UIntPtr trap, ^UIntPtr a1, ^UIntPtr a2, ^UIntPtr a3, ^UIntPtr a4, ^UIntPtr a5, ^UIntPtr a6]\n\nJoker return type: [BigInt BigInt go.std.syscall/Errno]"
  {:added "1.0"
   :go "__rawSyscall6(_trap, _a1, _a2, _a3, _a4, _a5, _a6)"}
  [^UIntPtr _trap, ^UIntPtr _a1, ^UIntPtr _a2, ^UIntPtr _a3, ^UIntPtr _a4, ^UIntPtr _a5, ^UIntPtr _a6])

JOKER FUNC syscall.Read from syscall/syscall_unix.go:
;; (defn Read
;;   "Go input arguments: (fd int, p []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__read(_fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^Int _fd, ^Object _p])

JOKER FUNC syscall.ReadDirent from syscall/syscall_linux.go:
;; (defn ReadDirent
;;   "Go input arguments: (fd int, buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__readDirent(_fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)))"}
;;   [^Int _fd, ^Object _buf])

JOKER FUNC syscall.Readlink from syscall/syscall_linux.go:
;; (defn Readlink
;;   "Go input arguments: (path string, buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String path, ^(vector-of Byte) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__readlink(_path, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)))"}
;;   [^String _path, ^Object _buf])

JOKER FUNC syscall.Reboot from syscall/syscall_linux.go:
(defn ^"Error" Reboot
  "Go input arguments: (cmd int)\n\nGo return type: error\n\nJoker input arguments: [^Int cmd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Reboot(_cmd)"}
  [^Int _cmd])

JOKER FUNC syscall.Recvfrom from syscall/syscall_unix.go:
;; (defn Recvfrom
;;   "Go input arguments: (fd int, p []byte, flags int)\n\nGo return type: (n int, from Sockaddr, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p, ^Int flags]\n\nJoker return type: [Int go.std.syscall/Sockaddr Error]"
;;   {:added "1.0"
;;    :go "__recvfrom(_fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)), _flags)"}
;;   [^Int _fd, ^Object _p, ^Int _flags])

JOKER FUNC syscall.Recvmsg from syscall/syscall_linux.go:
;; (defn Recvmsg
;;   "Go input arguments: (fd int, p []byte, oob []byte, flags int)\n\nGo return type: (n int, oobn int, recvflags int, from Sockaddr, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p, ^(vector-of Byte) oob, ^Int flags]\n\nJoker return type: [Int Int Int go.std.syscall/Sockaddr Error]"
;;   {:added "1.0"
;;    :go "__recvmsg(_fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_oob)), _flags)"}
;;   [^Int _fd, ^Object _p, ^Object _oob, ^Int _flags])

JOKER FUNC syscall.Removexattr from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Removexattr
  "Go input arguments: (path string, attr string)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^String attr]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Removexattr(_path, _attr)"}
  [^String _path, ^String _attr])

JOKER FUNC syscall.Rename from syscall/syscall_linux.go:
(defn ^"Error" Rename
  "Go input arguments: (oldpath string, newpath string)\n\nGo return type: error\n\nJoker input arguments: [^String oldpath, ^String newpath]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Rename(_oldpath, _newpath)"}
  [^String _oldpath, ^String _newpath])

JOKER FUNC syscall.Renameat from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Renameat
  "Go input arguments: (olddirfd int, oldpath string, newdirfd int, newpath string)\n\nGo return type: error\n\nJoker input arguments: [^Int olddirfd, ^String oldpath, ^Int newdirfd, ^String newpath]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Renameat(_olddirfd, _oldpath, _newdirfd, _newpath)"}
  [^Int _olddirfd, ^String _oldpath, ^Int _newdirfd, ^String _newpath])

JOKER FUNC syscall.Rmdir from syscall/syscall_linux.go:
(defn ^"Error" Rmdir
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Rmdir(_path)"}
  [^String _path])

JOKER FUNC syscall.Seek from syscall/zsyscall_linux_amd64.go:
(defn Seek
  "Go input arguments: (fd int, offset int64, whence int)\n\nGo return type: (off int64, err error)\n\nJoker input arguments: [^Int fd, ^Int64 offset, ^Int whence]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__seek(_fd, _offset, _whence)"}
  [^Int _fd, ^Int64 _offset, ^Int _whence])

JOKER FUNC syscall.Select from syscall/zsyscall_linux_amd64.go:
(defn Select
  "Go input arguments: (nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int nfd, ^(atom-of go.std.syscall/FdSet) r, ^(atom-of go.std.syscall/FdSet) w, ^(atom-of go.std.syscall/FdSet) e, ^(atom-of go.std.syscall/Timeval) timeout]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__select(_nfd, _r, _w, _e, _timeout)"}
  [^Int _nfd, ^syscall/FdSet _r, ^syscall/FdSet _w, ^syscall/FdSet _e, ^syscall/Timeval _timeout])

JOKER FUNC syscall.Sendfile from syscall/syscall_unix.go:
;; (defn Sendfile
;;   "Go input arguments: (outfd int, infd int, offset *int64, count int)\n\nGo return type: (written int, err error)\n\nJoker input arguments: [^Int outfd, ^Int infd, ^(atom-of Int64) offset, ^Int count]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__sendfile(_outfd, _infd, ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(_offset)), _count)"}
;;   [^Int _outfd, ^Int _infd, ^Object _offset, ^Int _count])

JOKER FUNC syscall.Sendmsg from syscall/syscall_linux.go:
;; (defn ^"Error" Sendmsg
;;   "Go input arguments: (fd int, p []byte, oob []byte, to Sockaddr, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p, ^(vector-of Byte) oob, ^go.std.syscall/Sockaddr to, ^Int flags]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Sendmsg(_fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_oob)), *_to, _flags)"}
;;   [^Int _fd, ^Object _p, ^Object _oob, ^syscall/Sockaddr _to, ^Int _flags])

JOKER FUNC syscall.SendmsgN from syscall/syscall_linux.go:
;; (defn SendmsgN
;;   "Go input arguments: (fd int, p []byte, oob []byte, to Sockaddr, flags int)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p, ^(vector-of Byte) oob, ^go.std.syscall/Sockaddr to, ^Int flags]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__sendmsgN(_fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_oob)), *_to, _flags)"}
;;   [^Int _fd, ^Object _p, ^Object _oob, ^syscall/Sockaddr _to, ^Int _flags])

JOKER FUNC syscall.Sendto from syscall/syscall_unix.go:
;; (defn ^"Error" Sendto
;;   "Go input arguments: (fd int, p []byte, flags int, to Sockaddr)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p, ^Int flags, ^go.std.syscall/Sockaddr to]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Sendto(_fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)), _flags, *_to)"}
;;   [^Int _fd, ^Object _p, ^Int _flags, ^syscall/Sockaddr _to])

JOKER FUNC syscall.SetLsfPromisc from syscall/lsf_linux.go:
(defn ^"Error" SetLsfPromisc
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (name string, m bool)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^Boolean m]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetLsfPromisc(_name, _m)"}
  [^String _name, ^Boolean _m])

JOKER FUNC syscall.SetNonblock from syscall/exec_unix.go:
(defn ^"Error" SetNonblock
  "Go input arguments: (fd int, nonblocking bool)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Boolean nonblocking]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetNonblock(_fd, _nonblocking)"}
  [^Int _fd, ^Boolean _nonblocking])

JOKER FUNC syscall.Setdomainname from syscall/zsyscall_linux_amd64.go:
;; (defn ^"Error" Setdomainname
;;   "Go input arguments: (p []byte)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Setdomainname(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^Object _p])

JOKER FUNC syscall.Setenv from syscall/env_unix.go:
(defn ^"Error" Setenv
  "Go input arguments: (key string, value string)\n\nGo return type: error\n\nJoker input arguments: [^String key, ^String value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setenv(_key, _value)"}
  [^String _key, ^String _value])

JOKER FUNC syscall.Setfsgid from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Setfsgid
  "Go input arguments: (gid int)\n\nGo return type: error\n\nJoker input arguments: [^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setfsgid(_gid)"}
  [^Int _gid])

JOKER FUNC syscall.Setfsuid from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Setfsuid
  "Go input arguments: (uid int)\n\nGo return type: error\n\nJoker input arguments: [^Int uid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setfsuid(_uid)"}
  [^Int _uid])

JOKER FUNC syscall.Setgid from syscall/syscall_linux.go:
(defn ^"Error" Setgid
  "Go input arguments: (gid int)\n\nGo return type: error\n\nJoker input arguments: [^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setgid(_gid)"}
  [^Int _gid])

JOKER FUNC syscall.Setgroups from syscall/syscall_linux.go:
;; (defn ^"Error" Setgroups
;;   "Go input arguments: (gids []int)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) gids]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Setgroups(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfint(_gids)))"}
;;   [^Object _gids])

JOKER FUNC syscall.Sethostname from syscall/zsyscall_linux_amd64.go:
;; (defn ^"Error" Sethostname
;;   "Go input arguments: (p []byte)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Sethostname(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^Object _p])

JOKER FUNC syscall.Setpgid from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Setpgid
  "Go input arguments: (pid int, pgid int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^Int pgid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setpgid(_pid, _pgid)"}
  [^Int _pid, ^Int _pgid])

JOKER FUNC syscall.Setpriority from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Setpriority
  "Go input arguments: (which int, who int, prio int)\n\nGo return type: error\n\nJoker input arguments: [^Int which, ^Int who, ^Int prio]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setpriority(_which, _who, _prio)"}
  [^Int _which, ^Int _who, ^Int _prio])

JOKER FUNC syscall.Setregid from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Setregid
  "Go input arguments: (rgid int, egid int)\n\nGo return type: error\n\nJoker input arguments: [^Int rgid, ^Int egid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setregid(_rgid, _egid)"}
  [^Int _rgid, ^Int _egid])

JOKER FUNC syscall.Setresgid from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Setresgid
  "Go input arguments: (rgid int, egid int, sgid int)\n\nGo return type: error\n\nJoker input arguments: [^Int rgid, ^Int egid, ^Int sgid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setresgid(_rgid, _egid, _sgid)"}
  [^Int _rgid, ^Int _egid, ^Int _sgid])

JOKER FUNC syscall.Setresuid from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Setresuid
  "Go input arguments: (ruid int, euid int, suid int)\n\nGo return type: error\n\nJoker input arguments: [^Int ruid, ^Int euid, ^Int suid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setresuid(_ruid, _euid, _suid)"}
  [^Int _ruid, ^Int _euid, ^Int _suid])

JOKER FUNC syscall.Setreuid from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Setreuid
  "Go input arguments: (ruid int, euid int)\n\nGo return type: error\n\nJoker input arguments: [^Int ruid, ^Int euid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setreuid(_ruid, _euid)"}
  [^Int _ruid, ^Int _euid])

JOKER FUNC syscall.Setrlimit from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Setrlimit
  "Go input arguments: (resource int, rlim *Rlimit)\n\nGo return type: error\n\nJoker input arguments: [^Int resource, ^(atom-of go.std.syscall/Rlimit) rlim]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setrlimit(_resource, _rlim)"}
  [^Int _resource, ^syscall/Rlimit _rlim])

JOKER FUNC syscall.Setsid from syscall/zsyscall_linux_amd64.go:
(defn Setsid
  "Go return type: (pid int, err error)\n\nJoker input arguments: []\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__setsid()"}
  [])

JOKER FUNC syscall.SetsockoptByte from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptByte
  "Go input arguments: (fd int, level int, opt int, value byte)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^Byte value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptByte(_fd, _level, _opt, _value)"}
  [^Int _fd, ^Int _level, ^Int _opt, ^Byte _value])

JOKER FUNC syscall.SetsockoptICMPv6Filter from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptICMPv6Filter
  "Go input arguments: (fd int, level int, opt int, filter *ICMPv6Filter)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/ICMPv6Filter) filter]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptICMPv6Filter(_fd, _level, _opt, _filter)"}
  [^Int _fd, ^Int _level, ^Int _opt, ^syscall/ICMPv6Filter _filter])

JOKER FUNC syscall.SetsockoptIPMreq from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptIPMreq
  "Go input arguments: (fd int, level int, opt int, mreq *IPMreq)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/IPMreq) mreq]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptIPMreq(_fd, _level, _opt, _mreq)"}
  [^Int _fd, ^Int _level, ^Int _opt, ^syscall/IPMreq _mreq])

JOKER FUNC syscall.SetsockoptIPMreqn from syscall/syscall_linux.go:
(defn ^"Error" SetsockoptIPMreqn
  "Go input arguments: (fd int, level int, opt int, mreq *IPMreqn)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/IPMreqn) mreq]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptIPMreqn(_fd, _level, _opt, _mreq)"}
  [^Int _fd, ^Int _level, ^Int _opt, ^syscall/IPMreqn _mreq])

JOKER FUNC syscall.SetsockoptIPv6Mreq from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptIPv6Mreq
  "Go input arguments: (fd int, level int, opt int, mreq *IPv6Mreq)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/IPv6Mreq) mreq]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptIPv6Mreq(_fd, _level, _opt, _mreq)"}
  [^Int _fd, ^Int _level, ^Int _opt, ^syscall/IPv6Mreq _mreq])

JOKER FUNC syscall.SetsockoptInet4Addr from syscall/syscall_unix.go:
;; (defn ^"Error" SetsockoptInet4Addr
;;   "Go input arguments: (fd int, level int, opt int, value []byte)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(vector-of Byte) value]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptInet4Addr(_fd, _level, _opt, ABEND901(pre.go: specific-length arrays not supported: ConvertToArrayOfbyte(_value)))"}
;;   [^Int _fd, ^Int _level, ^Int _opt, ^Object _value])

JOKER FUNC syscall.SetsockoptInt from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptInt
  "Go input arguments: (fd int, level int, opt int, value int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^Int value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptInt(_fd, _level, _opt, _value)"}
  [^Int _fd, ^Int _level, ^Int _opt, ^Int _value])

JOKER FUNC syscall.SetsockoptLinger from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptLinger
  "Go input arguments: (fd int, level int, opt int, l *Linger)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/Linger) l]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptLinger(_fd, _level, _opt, _l)"}
  [^Int _fd, ^Int _level, ^Int _opt, ^syscall/Linger _l])

JOKER FUNC syscall.SetsockoptString from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptString
  "Go input arguments: (fd int, level int, opt int, s string)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^String s]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptString(_fd, _level, _opt, _s)"}
  [^Int _fd, ^Int _level, ^Int _opt, ^String _s])

JOKER FUNC syscall.SetsockoptTimeval from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptTimeval
  "Go input arguments: (fd int, level int, opt int, tv *Timeval)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/Timeval) tv]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptTimeval(_fd, _level, _opt, _tv)"}
  [^Int _fd, ^Int _level, ^Int _opt, ^syscall/Timeval _tv])

JOKER FUNC syscall.Settimeofday from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Settimeofday
  "Go input arguments: (tv *Timeval)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.syscall/Timeval) tv]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Settimeofday(_tv)"}
  [^syscall/Timeval _tv])

JOKER FUNC syscall.Setuid from syscall/syscall_linux.go:
(defn ^"Error" Setuid
  "Go input arguments: (uid int)\n\nGo return type: error\n\nJoker input arguments: [^Int uid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setuid(_uid)"}
  [^Int _uid])

JOKER FUNC syscall.Setxattr from syscall/zsyscall_linux_amd64.go:
;; (defn ^"Error" Setxattr
;;   "Go input arguments: (path string, attr string, data []byte, flags int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^String attr, ^(vector-of Byte) data, ^Int flags]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Setxattr(_path, _attr, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), _flags)"}
;;   [^String _path, ^String _attr, ^Object _data, ^Int _flags])

JOKER FUNC syscall.Shutdown from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Shutdown
  "Go input arguments: (fd int, how int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int how]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Shutdown(_fd, _how)"}
  [^Int _fd, ^Int _how])

JOKER FUNC syscall.SlicePtrFromStrings from syscall/exec_unix.go:
;; (defn SlicePtrFromStrings
;;   "SlicePtrFromStrings converts a slice of strings to a slice of\npointers to NUL-terminated byte arrays. If any string contains\na NUL byte, it returns (nil, EINVAL).\n\nGo input arguments: (ss []string)\n\nGo return type: ([]*byte, error)\n\nJoker input arguments: [^(vector-of String) ss]\n\nJoker return type: [(vector-of (atom-of Int)) Error]"
;;   {:added "1.0"
;;    :go "__slicePtrFromStrings(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(_ss)))"}
;;   [^Object _ss])

JOKER FUNC syscall.Socket from syscall/syscall_unix.go:
(defn Socket
  "Go input arguments: (domain int, typ int, proto int)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^Int domain, ^Int typ, ^Int proto]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__socket(_domain, _typ, _proto)"}
  [^Int _domain, ^Int _typ, ^Int _proto])

JOKER FUNC syscall.Socketpair from syscall/syscall_unix.go:
(defn Socketpair
  "Go input arguments: (domain int, typ int, proto int)\n\nGo return type: (fd []int, err error)\n\nJoker input arguments: [^Int domain, ^Int typ, ^Int proto]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__socketpair(_domain, _typ, _proto)"}
  [^Int _domain, ^Int _typ, ^Int _proto])

JOKER FUNC syscall.Splice from syscall/zsyscall_linux_amd64.go:
;; (defn Splice
;;   "Go input arguments: (rfd int, roff *int64, wfd int, woff *int64, len int, flags int)\n\nGo return type: (n int64, err error)\n\nJoker input arguments: [^Int rfd, ^(atom-of Int64) roff, ^Int wfd, ^(atom-of Int64) woff, ^Int len, ^Int flags]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__splice(_rfd, ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(_roff)), _wfd, ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(_woff)), _len, _flags)"}
;;   [^Int _rfd, ^Object _roff, ^Int _wfd, ^Object _woff, ^Int _len, ^Int _flags])

JOKER FUNC syscall.StartProcess from syscall/exec_unix.go:
;; (defn StartProcess
;;   "StartProcess wraps ForkExec for package os.\n\nGo input arguments: (argv0 string, argv []string, attr *ProcAttr)\n\nGo return type: (pid int, handle uintptr, err error)\n\nJoker input arguments: [^String argv0, ^(vector-of String) argv, ^(atom-of go.std.syscall/ProcAttr) attr]\n\nJoker return type: [Int BigInt Error]"
;;   {:added "1.0"
;;    :go "__startProcess(_argv0, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(_argv)), _attr)"}
;;   [^String _argv0, ^Object _argv, ^syscall/ProcAttr _attr])

JOKER FUNC syscall.Stat from syscall/syscall_linux_amd64.go:
(defn ^"Error" Stat
  "Go input arguments: (path string, stat *Stat_t)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(atom-of go.std.syscall/Stat_t) stat]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Stat(_path, _stat)"}
  [^String _path, ^syscall/Stat_t _stat])

JOKER FUNC syscall.Statfs from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Statfs
  "Go input arguments: (path string, buf *Statfs_t)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(atom-of go.std.syscall/Statfs_t) buf]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Statfs(_path, _buf)"}
  [^String _path, ^syscall/Statfs_t _buf])

JOKER FUNC syscall.StringBytePtr from syscall/syscall.go:
(defn StringBytePtr
  "StringBytePtr returns a pointer to a NUL-terminated array of bytes.\nIf s contains a NUL byte this function panics instead of returning\nan error.\n\nDeprecated: Use BytePtrFromString instead.\n\nGo input arguments: (s string)\n\nGo return type: *byte\n\nJoker input arguments: [^String s]\n\nJoker return type: (atom-of Int)"
  {:added "1.0"
   :go "__stringBytePtr(_s)"}
  [^String _s])

JOKER FUNC syscall.StringByteSlice from syscall/syscall.go:
(defn StringByteSlice
  "StringByteSlice converts a string to a NUL-terminated []byte,\nIf s contains a NUL byte this function panics instead of\nreturning an error.\n\nDeprecated: Use ByteSliceFromString instead.\n\nGo input arguments: (s string)\n\nGo return type: []byte\n\nJoker input arguments: [^String s]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__stringByteSlice(_s)"}
  [^String _s])

JOKER FUNC syscall.StringSlicePtr from syscall/exec_unix.go:
;; (defn StringSlicePtr
;;   "StringSlicePtr converts a slice of strings to a slice of pointers\nto NUL-terminated byte arrays. If any string contains a NUL byte\nthis function panics instead of returning an error.\n\nDeprecated: Use SlicePtrFromStrings instead.\n\nGo input arguments: (ss []string)\n\nGo return type: []*byte\n\nJoker input arguments: [^(vector-of String) ss]\n\nJoker return type: (vector-of (atom-of Int))"
;;   {:added "1.0"
;;    :go "__stringSlicePtr(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(_ss)))"}
;;   [^Object _ss])

JOKER FUNC syscall.Symlink from syscall/syscall_linux.go:
(defn ^"Error" Symlink
  "Go input arguments: (oldpath string, newpath string)\n\nGo return type: error\n\nJoker input arguments: [^String oldpath, ^String newpath]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Symlink(_oldpath, _newpath)"}
  [^String _oldpath, ^String _newpath])

JOKER FUNC syscall.Sync from syscall/zsyscall_linux_amd64.go:
;; (defn Sync
;;   "Joker input arguments: []"
;;   {:added "1.0"
;;    :go "__sync()"}
;;   [])

JOKER FUNC syscall.SyncFileRange from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" SyncFileRange
  "Go input arguments: (fd int, off int64, n int64, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int64 off, ^Int64 n, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SyncFileRange(_fd, _off, _n, _flags)"}
  [^Int _fd, ^Int64 _off, ^Int64 _n, ^Int _flags])

JOKER FUNC syscall.Syscall from syscall/syscall_unix.go:
(defn Syscall
  "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr)\n\nGo return type: (r1 uintptr, r2 uintptr, err Errno)\n\nJoker input arguments: [^UIntPtr trap, ^UIntPtr a1, ^UIntPtr a2, ^UIntPtr a3]\n\nJoker return type: [BigInt BigInt go.std.syscall/Errno]"
  {:added "1.0"
   :go "__syscall(_trap, _a1, _a2, _a3)"}
  [^UIntPtr _trap, ^UIntPtr _a1, ^UIntPtr _a2, ^UIntPtr _a3])

JOKER FUNC syscall.Syscall6 from syscall/syscall_unix.go:
(defn Syscall6
  "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr)\n\nGo return type: (r1 uintptr, r2 uintptr, err Errno)\n\nJoker input arguments: [^UIntPtr trap, ^UIntPtr a1, ^UIntPtr a2, ^UIntPtr a3, ^UIntPtr a4, ^UIntPtr a5, ^UIntPtr a6]\n\nJoker return type: [BigInt BigInt go.std.syscall/Errno]"
  {:added "1.0"
   :go "__syscall6(_trap, _a1, _a2, _a3, _a4, _a5, _a6)"}
  [^UIntPtr _trap, ^UIntPtr _a1, ^UIntPtr _a2, ^UIntPtr _a3, ^UIntPtr _a4, ^UIntPtr _a5, ^UIntPtr _a6])

JOKER FUNC syscall.Sysinfo from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Sysinfo
  "Go input arguments: (info *Sysinfo_t)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.syscall/Sysinfo_t) info]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Sysinfo(_info)"}
  [^syscall/Sysinfo_t _info])

JOKER FUNC syscall.Tee from syscall/zsyscall_linux_amd64.go:
(defn Tee
  "Go input arguments: (rfd int, wfd int, len int, flags int)\n\nGo return type: (n int64, err error)\n\nJoker input arguments: [^Int rfd, ^Int wfd, ^Int len, ^Int flags]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__tee(_rfd, _wfd, _len, _flags)"}
  [^Int _rfd, ^Int _wfd, ^Int _len, ^Int _flags])

JOKER FUNC syscall.Tgkill from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Tgkill
  "Go input arguments: (tgid int, tid int, sig Signal)\n\nGo return type: error\n\nJoker input arguments: [^Int tgid, ^Int tid, ^go.std.syscall/Signal sig]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Tgkill(_tgid, _tid, *_sig)"}
  [^Int _tgid, ^Int _tid, ^syscall/Signal _sig])

JOKER FUNC syscall.Time from syscall/syscall_linux_amd64.go:
(defn Time
  "Go input arguments: (t *Time_t)\n\nGo return type: (tt Time_t, err error)\n\nJoker input arguments: [^(atom-of go.std.syscall/Time_t) t]\n\nJoker return type: [go.std.syscall/Time_t Error]"
  {:added "1.0"
   :go "__time(_t)"}
  [^syscall/Time_t _t])

JOKER FUNC syscall.Times from syscall/zsyscall_linux_amd64.go:
(defn Times
  "Go input arguments: (tms *Tms)\n\nGo return type: (ticks uintptr, err error)\n\nJoker input arguments: [^(atom-of go.std.syscall/Tms) tms]\n\nJoker return type: [BigInt Error]"
  {:added "1.0"
   :go "__times(_tms)"}
  [^syscall/Tms _tms])

JOKER FUNC syscall.TimespecToNsec from syscall/timestruct.go:
(defn TimespecToNsec
  "TimespecToNsec converts a Timespec value into a number of\nnanoseconds since the Unix epoch.\n\nGo input arguments: (ts Timespec)\n\nGo return type: int64\n\nJoker input arguments: [^go.std.syscall/Timespec ts]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__timespecToNsec(*_ts)"}
  [^syscall/Timespec _ts])

JOKER FUNC syscall.TimevalToNsec from syscall/timestruct.go:
(defn TimevalToNsec
  "TimevalToNsec converts a Timeval value into a number of nanoseconds\nsince the Unix epoch.\n\nGo input arguments: (tv Timeval)\n\nGo return type: int64\n\nJoker input arguments: [^go.std.syscall/Timeval tv]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__timevalToNsec(*_tv)"}
  [^syscall/Timeval _tv])

JOKER FUNC syscall.Truncate from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Truncate
  "Go input arguments: (path string, length int64)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Int64 length]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Truncate(_path, _length)"}
  [^String _path, ^Int64 _length])

JOKER FUNC syscall.Umask from syscall/zsyscall_linux_amd64.go:
(defn ^"Int" Umask
  "Go input arguments: (mask int)\n\nGo return type: int\n\nJoker input arguments: [^Int mask]\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Umask(_mask)"}
  [^Int _mask])

JOKER FUNC syscall.Uname from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Uname
  "Go input arguments: (buf *Utsname)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.syscall/Utsname) buf]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Uname(_buf)"}
  [^syscall/Utsname _buf])

JOKER FUNC syscall.UnixCredentials from syscall/sockcmsg_linux.go:
(defn UnixCredentials
  "UnixCredentials encodes credentials into a socket control message\nfor sending to another process. This can be used for\nauthentication.\n\nGo input arguments: (ucred *Ucred)\n\nGo return type: []byte\n\nJoker input arguments: [^(atom-of go.std.syscall/Ucred) ucred]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__unixCredentials(_ucred)"}
  [^syscall/Ucred _ucred])

JOKER FUNC syscall.UnixRights from syscall/sockcmsg_unix.go:
;; (defn UnixRights
;;   "UnixRights encodes a set of open file descriptors into a socket\ncontrol message for sending to another process.\n\nGo input arguments: (fds ...int)\n\nGo return type: []byte\n\nJoker input arguments: [^(ellipsis-somehow Int) fds]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__unixRights(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHaint(_fds)))"}
;;   [^Int _fds])

JOKER FUNC syscall.Unlink from syscall/syscall_linux.go:
(defn ^"Error" Unlink
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unlink(_path)"}
  [^String _path])

JOKER FUNC syscall.Unlinkat from syscall/syscall_linux.go:
(defn ^"Error" Unlinkat
  "Go input arguments: (dirfd int, path string)\n\nGo return type: error\n\nJoker input arguments: [^Int dirfd, ^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unlinkat(_dirfd, _path)"}
  [^Int _dirfd, ^String _path])

JOKER FUNC syscall.Unmount from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Unmount
  "Go input arguments: (target string, flags int)\n\nGo return type: error\n\nJoker input arguments: [^String target, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unmount(_target, _flags)"}
  [^String _target, ^Int _flags])

JOKER FUNC syscall.Unsetenv from syscall/env_unix.go:
(defn ^"Error" Unsetenv
  "Go input arguments: (key string)\n\nGo return type: error\n\nJoker input arguments: [^String key]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unsetenv(_key)"}
  [^String _key])

JOKER FUNC syscall.Unshare from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Unshare
  "Go input arguments: (flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unshare(_flags)"}
  [^Int _flags])

JOKER FUNC syscall.Ustat from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Ustat
  "Go input arguments: (dev int, ubuf *Ustat_t)\n\nGo return type: error\n\nJoker input arguments: [^Int dev, ^(atom-of go.std.syscall/Ustat_t) ubuf]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Ustat(_dev, _ubuf)"}
  [^Int _dev, ^syscall/Ustat_t _ubuf])

JOKER FUNC syscall.Utime from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Utime
  "Go input arguments: (path string, buf *Utimbuf)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(atom-of go.std.syscall/Utimbuf) buf]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Utime(_path, _buf)"}
  [^String _path, ^syscall/Utimbuf _buf])

JOKER FUNC syscall.Utimes from syscall/syscall_linux.go:
;; (defn ^"Error" Utimes
;;   "Go input arguments: (path string, tv []Timeval)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(vector-of go.std.syscall/Timeval) tv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Utimes(_path, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_syscall.Timeval(*_tv)))"}
;;   [^String _path, ^Object _tv])

JOKER FUNC syscall.UtimesNano from syscall/syscall_linux.go:
;; (defn ^"Error" UtimesNano
;;   "Go input arguments: (path string, ts []Timespec)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(vector-of go.std.syscall/Timespec) ts]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.UtimesNano(_path, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_syscall.Timespec(*_ts)))"}
;;   [^String _path, ^Object _ts])

JOKER FUNC syscall.Wait4 from syscall/syscall_linux.go:
(defn Wait4
  "Go input arguments: (pid int, wstatus *WaitStatus, options int, rusage *Rusage)\n\nGo return type: (wpid int, err error)\n\nJoker input arguments: [^Int pid, ^(atom-of go.std.syscall/WaitStatus) wstatus, ^Int options, ^(atom-of go.std.syscall/Rusage) rusage]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__wait4(_pid, _wstatus, _options, _rusage)"}
  [^Int _pid, ^syscall/WaitStatus _wstatus, ^Int _options, ^syscall/Rusage _rusage])

JOKER FUNC syscall.Write from syscall/syscall_unix.go:
;; (defn Write
;;   "Go input arguments: (fd int, p []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__write(_fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^Int _fd, ^Object _p])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["syscall"]
    :doc "Provides a low-level interface to the syscall package."
    :empty false}
  go.std.syscall)
JOKER TYPE testing.B from testing/benchmark.go:
(defn ^"GoObject" B.
  "Constructor for testing.B"
  {:added "1.0"
   :go "_ConstructB(_v)"}
  [^Object _v])

JOKER TYPE testing.BenchmarkResult from testing/benchmark.go:
(defn ^"GoObject" BenchmarkResult.
  "Constructor for testing.BenchmarkResult"
  {:added "1.0"
   :go "_ConstructBenchmarkResult(_v)"}
  [^Object _v])

JOKER TYPE testing.Cover from testing/cover.go:
(defn ^"GoObject" Cover.
  "Constructor for testing.Cover"
  {:added "1.0"
   :go "_ConstructCover(_v)"}
  [^Object _v])

JOKER TYPE testing.CoverBlock from testing/cover.go:
(defn ^"GoObject" CoverBlock.
  "Constructor for testing.CoverBlock"
  {:added "1.0"
   :go "_ConstructCoverBlock(_v)"}
  [^Object _v])

JOKER TYPE testing.InternalBenchmark from testing/benchmark.go:
(defn ^"GoObject" InternalBenchmark.
  "Constructor for testing.InternalBenchmark"
  {:added "1.0"
   :go "_ConstructInternalBenchmark(_v)"}
  [^Object _v])

JOKER TYPE testing.InternalExample from testing/example.go:
(defn ^"GoObject" InternalExample.
  "Constructor for testing.InternalExample"
  {:added "1.0"
   :go "_ConstructInternalExample(_v)"}
  [^Object _v])

JOKER TYPE testing.InternalTest from testing/testing.go:
(defn ^"GoObject" InternalTest.
  "Constructor for testing.InternalTest"
  {:added "1.0"
   :go "_ConstructInternalTest(_v)"}
  [^Object _v])

JOKER TYPE testing.M from testing/testing.go:
(defn ^"GoObject" M.
  "Constructor for testing.M"
  {:added "1.0"
   :go "_ConstructM(_v)"}
  [^Object _v])

JOKER TYPE testing.PB from testing/benchmark.go:
(defn ^"GoObject" PB.
  "Constructor for testing.PB"
  {:added "1.0"
   :go "_ConstructPB(_v)"}
  [^Object _v])

JOKER TYPE testing.T from testing/testing.go:
(defn ^"GoObject" T.
  "Constructor for testing.T"
  {:added "1.0"
   :go "_ConstructT(_v)"}
  [^Object _v])

JOKER TYPE testing.TB from testing/testing.go:
;; (defn ^"GoObject" TB.
;;   "Constructor for testing.TB"
;;   {:added "1.0"
;;    :go "_ConstructTB(_v)"}
;;   [^Object _v])

JOKER FUNC testing.AllocsPerRun from testing/allocs.go:
;; (defn AllocsPerRun
;;   "AllocsPerRun returns the average number of allocations during calls to f.\nAlthough the return value has type float64, it will always be an integral value.\n\nTo compute the number of allocations, the function will first be run once as\na warm-up. The average number of allocations over the specified number of\nruns will then be measured and returned.\n\nAllocsPerRun sets GOMAXPROCS to 1 during its measurement and will restore\nit before returning.\n\nGo input arguments: (runs int, f func)\n\nGo return type: ...\n\nJoker input arguments: [^Int runs, ^fn f]\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__allocsPerRun(_runs, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Int _runs, ^fn _f])

JOKER FUNC testing.Benchmark from testing/benchmark.go:
;; (defn Benchmark
;;   "Benchmark benchmarks a single function. Useful for creating\ncustom benchmarks that do not use the \"go test\" command.\n\nIf f calls Run, the result will be an estimate of running all its\nsubbenchmarks that don't call Run in sequence in a single benchmark.\n\nGo input arguments: (f func)\n\nGo return type: BenchmarkResult\n\nJoker input arguments: [^fn f]\n\nJoker return type: go.std.testing/BenchmarkResult"
;;   {:added "1.0"
;;    :go "__benchmark(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^fn _f])

JOKER FUNC testing.CoverMode from testing/testing.go:
(defn ^"String" CoverMode
  "CoverMode reports what the test coverage mode is set to. The\nvalues are \"set\", \"count\", or \"atomic\". The return value will be\nempty if test coverage is not enabled.\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "testing.CoverMode()"}
  [])

JOKER FUNC testing.Coverage from testing/cover.go:
;; (defn Coverage
;;   "Coverage reports the current code coverage as a fraction in the range [0, 1].\nIf coverage is not enabled, Coverage returns 0.\n\nWhen running a large set of sequential test cases, checking Coverage after each one\ncan be useful for identifying which test cases exercise new code paths.\nIt is not a replacement for the reports generated by 'go test -cover' and\n'go tool cover'.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(post.go: unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "__coverage()"}
;;   [])

JOKER FUNC testing.Main from testing/testing.go:
;; (defn Main
;;   "Main is an internal function, part of the implementation of the \"go test\" command.\nIt was exported because it is cross-package and predates \"internal\" packages.\nIt is no longer used by \"go test\" but preserved, as much as possible, for other\nsystems that simulate \"go test\" using Main, but Main sometimes cannot be updated as\nnew functionality is added to the testing package.\nSystems simulating \"go test\" should be updated to use MainStart.\n\nGo input arguments: (matchString func, tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)\n\nJoker input arguments: [^fn matchString, ^(vector-of go.std.testing/InternalTest) tests, ^(vector-of go.std.testing/InternalBenchmark) benchmarks, ^(vector-of go.std.testing/InternalExample) examples]"
;;   {:added "1.0"
;;    :go "__main(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalTest(*_tests)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalBenchmark(*_benchmarks)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalExample(*_examples)))"}
;;   [^fn _matchString, ^Object _tests, ^Object _benchmarks, ^Object _examples])

JOKER FUNC testing.MainStart from testing/testing.go:
;; (defn MainStart
;;   "MainStart is meant for use by tests generated by 'go test'.\nIt is not meant to be called directly and is not subject to the Go 1 compatibility document.\nIt may change signature from release to release.\n\nGo input arguments: (deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)\n\nGo return type: *M\n\nJoker input arguments: [^testDeps deps, ^(vector-of go.std.testing/InternalTest) tests, ^(vector-of go.std.testing/InternalBenchmark) benchmarks, ^(vector-of go.std.testing/InternalExample) examples]\n\nJoker return type: (atom-of go.std.testing/M)"
;;   {:added "1.0"
;;    :go "__mainStart(_deps, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalTest(*_tests)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalBenchmark(*_benchmarks)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalExample(*_examples)))"}
;;   [^ABEND044(pre.go: unsupported built-in type testDeps) _deps, ^Object _tests, ^Object _benchmarks, ^Object _examples])

JOKER FUNC testing.RegisterCover from testing/cover.go:
;; (defn RegisterCover
;;   "RegisterCover records the coverage data accumulators for the tests.\nNOTE: This function is internal to the testing infrastructure and may change.\nIt is not covered (yet) by the Go 1 compatibility guidelines.\n\nGo input arguments: (c Cover)\n\nJoker input arguments: [^go.std.testing/Cover c]"
;;   {:added "1.0"
;;    :go "__registerCover(*_c)"}
;;   [^testing/Cover _c])

JOKER FUNC testing.RunBenchmarks from testing/benchmark.go:
;; (defn RunBenchmarks
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n\nGo input arguments: (matchString func, benchmarks []InternalBenchmark)\n\nJoker input arguments: [^fn matchString, ^(vector-of go.std.testing/InternalBenchmark) benchmarks]"
;;   {:added "1.0"
;;    :go "__runBenchmarks(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalBenchmark(*_benchmarks)))"}
;;   [^fn _matchString, ^Object _benchmarks])

JOKER FUNC testing.RunExamples from testing/example.go:
;; (defn ^"Boolean" RunExamples
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n\nGo input arguments: (matchString func, examples []InternalExample)\n\nGo return type: bool\n\nJoker input arguments: [^fn matchString, ^(vector-of go.std.testing/InternalExample) examples]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "testing.RunExamples(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalExample(*_examples)))"}
;;   [^fn _matchString, ^Object _examples])

JOKER FUNC testing.RunTests from testing/testing.go:
;; (defn ^"Boolean" RunTests
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n\nGo input arguments: (matchString func, tests []InternalTest)\n\nGo return type: bool\n\nJoker input arguments: [^fn matchString, ^(vector-of go.std.testing/InternalTest) tests]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "testing.RunTests(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalTest(*_tests)))"}
;;   [^fn _matchString, ^Object _tests])

JOKER FUNC testing.Short from testing/testing.go:
(defn ^"Boolean" Short
  "Short reports whether the -test.short flag is set.\n\nGo return type: bool\n\nJoker input arguments: []\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "testing.Short()"}
  [])

JOKER FUNC testing.Verbose from testing/testing.go:
(defn ^"Boolean" Verbose
  "Verbose reports whether the -test.v flag is set.\n\nGo return type: bool\n\nJoker input arguments: []\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "testing.Verbose()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["testing"]
    :doc "Provides a low-level interface to the testing package."
    :empty false}
  go.std.testing)
JOKER FUNC testing/iotest.DataErrReader from testing/iotest/reader.go:
;; (defn DataErrReader
;;   "DataErrReader changes the way errors are handled by a Reader. Normally, a\nReader returns an error (typically EOF) from the first Read call after the\nlast piece of data is read. DataErrReader wraps a Reader and changes its\nbehavior so the final error is returned along with the final data, instead\nof in the first call after the final data.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__dataErrReader(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC testing/iotest.HalfReader from testing/iotest/reader.go:
;; (defn HalfReader
;;   "HalfReader returns a Reader that implements Read\nby reading half as many requested bytes from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__halfReader(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC testing/iotest.NewReadLogger from testing/iotest/logger.go:
;; (defn NewReadLogger
;;   "NewReadLogger returns a reader that behaves like r except\nthat it logs (using log.Printf) each read to standard error,\nprinting the prefix and the hexadecimal data read.\n\nGo input arguments: (prefix string, r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^String prefix, ^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__newReadLogger(_prefix, *_r)"}
;;   [^String _prefix, ^io/Reader _r])

JOKER FUNC testing/iotest.NewWriteLogger from testing/iotest/logger.go:
;; (defn NewWriteLogger
;;   "NewWriteLogger returns a writer that behaves like w except\nthat it logs (using log.Printf) each write to standard error,\nprinting the prefix and the hexadecimal data written.\n\nGo input arguments: (prefix string, w io.Writer)\n\nGo return type: io.Writer\n\nJoker input arguments: [^String prefix, ^go.std.io/Writer w]\n\nJoker return type: go.std.io/Writer"
;;   {:added "1.0"
;;    :go "__newWriteLogger(_prefix, *_w)"}
;;   [^String _prefix, ^io/Writer _w])

JOKER FUNC testing/iotest.OneByteReader from testing/iotest/reader.go:
;; (defn OneByteReader
;;   "OneByteReader returns a Reader that implements\neach non-empty Read by reading one byte from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__oneByteReader(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC testing/iotest.TimeoutReader from testing/iotest/reader.go:
;; (defn TimeoutReader
;;   "TimeoutReader returns ErrTimeout on the second read\nwith no data. Subsequent calls to read succeed.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__timeoutReader(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC testing/iotest.TruncateWriter from testing/iotest/writer.go:
;; (defn TruncateWriter
;;   "TruncateWriter returns a Writer that writes to w\nbut stops silently after n bytes.\n\nGo input arguments: (w io.Writer, n int64)\n\nGo return type: io.Writer\n\nJoker input arguments: [^go.std.io/Writer w, ^Int64 n]\n\nJoker return type: go.std.io/Writer"
;;   {:added "1.0"
;;    :go "__truncateWriter(*_w, _n)"}
;;   [^io/Writer _w, ^Int64 _n])

JOKER FUNC testing/quick.Check from testing/quick/quick.go:
;; (defn ^"Error" Check
;;   "Check looks for an input to f, any function that returns bool,\nsuch that f returns false. It calls f repeatedly, with arbitrary\nvalues for each argument. If f returns false on a given input,\nCheck returns that input as a *CheckError.\nFor example:\n\n\tfunc TestOddMultipleOfThree(t *testing.T) {\n\t\tf := func(x int) bool {\n\t\t\ty := OddMultipleOfThree(x)\n\t\t\treturn y%2 == 1 && y%3 == 0\n\t\t}\n\t\tif err := quick.Check(f, nil); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n\nGo input arguments: (f interface {}, config *Config)\n\nGo return type: error\n\nJoker input arguments: [^<protocol-or-something> f, ^(atom-of go.std.testing.quick/Config) config]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "quick.Check(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), _config)"}
;;   [^<protocol-or-something> _f, ^quick/Config _config])

JOKER FUNC testing/quick.CheckEqual from testing/quick/quick.go:
;; (defn ^"Error" CheckEqual
;;   "CheckEqual looks for an input on which f and g return different results.\nIt calls f and g repeatedly with arbitrary values for each argument.\nIf f and g return different answers, CheckEqual returns a *CheckEqualError\ndescribing the input and the outputs.\n\nGo input arguments: (f interface {}, g interface {}, config *Config)\n\nGo return type: error\n\nJoker input arguments: [^<protocol-or-something> f, ^<protocol-or-something> g, ^(atom-of go.std.testing.quick/Config) config]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "quick.CheckEqual(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), _config)"}
;;   [^<protocol-or-something> _f, ^<protocol-or-something> _g, ^quick/Config _config])

JOKER FUNC testing/quick.Value from testing/quick/quick.go:
;; (defn Value
;;   "Value returns an arbitrary value of the given type.\nIf the type implements the Generator interface, that will be used.\nNote: To create arbitrary values for structs, all the fields must be exported.\n\nGo input arguments: (t reflect.Type, rand *rand.Rand)\n\nGo return type: (value reflect.Value, ok bool)\n\nJoker input arguments: [^go.std.reflect/Type t, ^(atom-of go.std.math.rand/Rand) rand]\n\nJoker return type: [go.std.reflect/Value Boolean]"
;;   {:added "1.0"
;;    :go "__value(*_t, _rand)"}
;;   [^reflect/Type _t, ^rand/Rand _rand])

JOKER FUNC text/scanner.TokenString from text/scanner/scanner.go:
;; (defn ^"String" TokenString
;;   "TokenString returns a printable string for a token or Unicode character.\n\nGo input arguments: (tok rune)\n\nGo return type: string\n\nJoker input arguments: [^rune tok]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "scanner.TokenString(_tok)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _tok])

JOKER FUNC text/tabwriter.NewWriter from text/tabwriter/tabwriter.go:
;; (defn NewWriter
;;   "NewWriter allocates and initializes a new tabwriter.Writer.\nThe parameters are the same as for the Init function.\n\nGo input arguments: (output io.Writer, minwidth int, tabwidth int, padding int, padchar byte, flags uint)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer output, ^Int minwidth, ^Int tabwidth, ^Int padding, ^Byte padchar, ^UInt flags]\n\nJoker return type: (atom-of go.std.text.tabwriter/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*_output, _minwidth, _tabwidth, _padding, _padchar, _flags)"}
;;   [^io/Writer _output, ^Int _minwidth, ^Int _tabwidth, ^Int _padding, ^Byte _padchar, ^UInt _flags])

JOKER TYPE text/template.ExecError from text/template/exec.go:
(defn ^"GoObject" ExecError.
  "Constructor for template.ExecError"
  {:added "1.0"
   :go "_ConstructExecError(_v)"}
  [^Object _v])

JOKER TYPE text/template.FuncMap from text/template/funcs.go:
;; (defn ^"GoObject" FuncMap.
;;   "Constructor for template.FuncMap"
;;   {:added "1.0"
;;    :go "_ConstructFuncMap(_v)"}
;;   [^Object _v])

JOKER TYPE text/template.Template from text/template/template.go:
(defn ^"GoObject" Template.
  "Constructor for template.Template"
  {:added "1.0"
   :go "_ConstructTemplate(_v)"}
  [^Object _v])

JOKER FUNC text/template.HTMLEscape from text/template/funcs.go:
;; (defn HTMLEscape
;;   "HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.\n\nGo input arguments: (w io.Writer, b []byte)\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Byte) b]"
;;   {:added "1.0"
;;    :go "__hTMLEscape(*_w, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^io/Writer _w, ^Object _b])

JOKER FUNC text/template.HTMLEscapeString from text/template/funcs.go:
(defn ^"String" HTMLEscapeString
  "HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "template.HTMLEscapeString(_s)"}
  [^String _s])

JOKER FUNC text/template.HTMLEscaper from text/template/funcs.go:
;; (defn ^"String" HTMLEscaper
;;   "HTMLEscaper returns the escaped HTML equivalent of the textual\nrepresentation of its arguments.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.HTMLEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _args])

JOKER FUNC text/template.IsTrue from text/template/exec.go:
;; (defn IsTrue
;;   "IsTrue reports whether the value is 'true', in the sense of not the zero of its type,\nand whether the value has a meaningful truth value. This is the definition of\ntruth used by if and other such actions.\n\nGo input arguments: (val interface {})\n\nGo return type: (truth bool, ok bool)\n\nJoker input arguments: [^<protocol-or-something> val]\n\nJoker return type: [Boolean Boolean]"
;;   {:added "1.0"
;;    :go "__isTrue(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _val])

JOKER FUNC text/template.JSEscape from text/template/funcs.go:
;; (defn JSEscape
;;   "JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.\n\nGo input arguments: (w io.Writer, b []byte)\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Byte) b]"
;;   {:added "1.0"
;;    :go "__jSEscape(*_w, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^io/Writer _w, ^Object _b])

JOKER FUNC text/template.JSEscapeString from text/template/funcs.go:
(defn ^"String" JSEscapeString
  "JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "template.JSEscapeString(_s)"}
  [^String _s])

JOKER FUNC text/template.JSEscaper from text/template/funcs.go:
;; (defn ^"String" JSEscaper
;;   "JSEscaper returns the escaped JavaScript equivalent of the textual\nrepresentation of its arguments.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.JSEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _args])

JOKER FUNC text/template.Must from text/template/helper.go:
;; (defn Must
;;   "Must is a helper that wraps a call to a function returning (*Template, error)\nand panics if the error is non-nil. It is intended for use in variable\ninitializations such as\n\tvar t = template.Must(template.New(\"name\").Parse(\"text\"))\n\nGo input arguments: (t *Template, err error)\n\nGo return type: *Template\n\nJoker input arguments: [^(atom-of go.std.text.template/Template) t, ^ABEND885(pre.go: unrecognized type error at: /usr/local/go-1.11.5/src/text/template/helper.go:21:28) err]\n\nJoker return type: (atom-of go.std.text.template/Template)"
;;   {:added "1.0"
;;    :go "__must(_t, _err)"}
;;   [^template/Template _t, ^ABEND885(pre.go: unrecognized type error at: /usr/local/go-1.11.5/src/text/template/helper.go:21:28) _err])

JOKER FUNC text/template.New from text/template/template.go:
(defn New
  "New allocates a new, undefined template with the given name.\n\nGo input arguments: (name string)\n\nGo return type: *Template\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.text.template/Template)"
  {:added "1.0"
   :go "__new(_name)"}
  [^String _name])

JOKER FUNC text/template.ParseFiles from text/template/helper.go:
;; (defn ParseFiles
;;   "ParseFiles creates a new Template and parses the template definitions from\nthe named files. The returned template's name will have the base name and\nparsed contents of the first file. There must be at least one file.\nIf an error occurs, parsing stops and the returned *Template is nil.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\nFor instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template\nnamed \"foo\", while \"a/foo\" is unavailable.\n\nGo input arguments: (filenames ...string)\n\nGo return type: (*Template, error)\n\nJoker input arguments: [^(ellipsis-somehow String) filenames]\n\nJoker return type: [(atom-of go.std.text.template/Template) Error]"
;;   {:added "1.0"
;;    :go "__parseFiles(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(_filenames)))"}
;;   [^String _filenames])

JOKER FUNC text/template.ParseGlob from text/template/helper.go:
(defn ParseGlob
  "ParseGlob creates a new Template and parses the template definitions from the\nfiles identified by the pattern, which must match at least one file. The\nreturned template will have the (base) name and (parsed) contents of the\nfirst file matched by the pattern. ParseGlob is equivalent to calling\nParseFiles with the list of files matched by the pattern.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\n\nGo input arguments: (pattern string)\n\nGo return type: (*Template, error)\n\nJoker input arguments: [^String pattern]\n\nJoker return type: [(atom-of go.std.text.template/Template) Error]"
  {:added "1.0"
   :go "__parseGlob(_pattern)"}
  [^String _pattern])

JOKER FUNC text/template.URLQueryEscaper from text/template/funcs.go:
;; (defn ^"String" URLQueryEscaper
;;   "URLQueryEscaper returns the escaped value of the textual representation of\nits arguments in a form suitable for embedding in a URL query.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.URLQueryEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _args])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["text/template"]
    :doc "Provides a low-level interface to the text/template package."
    :empty false}
  go.std.text.template)
JOKER TYPE text/template/parse.ActionNode from text/template/parse/node.go:
(defn ^"GoObject" ActionNode.
  "Constructor for parse.ActionNode"
  {:added "1.0"
   :go "_ConstructActionNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.BoolNode from text/template/parse/node.go:
(defn ^"GoObject" BoolNode.
  "Constructor for parse.BoolNode"
  {:added "1.0"
   :go "_ConstructBoolNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.BranchNode from text/template/parse/node.go:
(defn ^"GoObject" BranchNode.
  "Constructor for parse.BranchNode"
  {:added "1.0"
   :go "_ConstructBranchNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.ChainNode from text/template/parse/node.go:
(defn ^"GoObject" ChainNode.
  "Constructor for parse.ChainNode"
  {:added "1.0"
   :go "_ConstructChainNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.CommandNode from text/template/parse/node.go:
(defn ^"GoObject" CommandNode.
  "Constructor for parse.CommandNode"
  {:added "1.0"
   :go "_ConstructCommandNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.DotNode from text/template/parse/node.go:
(defn ^"GoObject" DotNode.
  "Constructor for parse.DotNode"
  {:added "1.0"
   :go "_ConstructDotNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.FieldNode from text/template/parse/node.go:
(defn ^"GoObject" FieldNode.
  "Constructor for parse.FieldNode"
  {:added "1.0"
   :go "_ConstructFieldNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.IdentifierNode from text/template/parse/node.go:
(defn ^"GoObject" IdentifierNode.
  "Constructor for parse.IdentifierNode"
  {:added "1.0"
   :go "_ConstructIdentifierNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.IfNode from text/template/parse/node.go:
(defn ^"GoObject" IfNode.
  "Constructor for parse.IfNode"
  {:added "1.0"
   :go "_ConstructIfNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.ListNode from text/template/parse/node.go:
(defn ^"GoObject" ListNode.
  "Constructor for parse.ListNode"
  {:added "1.0"
   :go "_ConstructListNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.NilNode from text/template/parse/node.go:
(defn ^"GoObject" NilNode.
  "Constructor for parse.NilNode"
  {:added "1.0"
   :go "_ConstructNilNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.Node from text/template/parse/node.go:
;; (defn ^"GoObject" Node.
;;   "Constructor for parse.Node"
;;   {:added "1.0"
;;    :go "_ConstructNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.NodeType from text/template/parse/node.go:
(defn ^"GoObject" NodeType.
  "Constructor for parse.NodeType"
  {:added "1.0"
   :go "_ConstructNodeType(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.NumberNode from text/template/parse/node.go:
(defn ^"GoObject" NumberNode.
  "Constructor for parse.NumberNode"
  {:added "1.0"
   :go "_ConstructNumberNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.PipeNode from text/template/parse/node.go:
(defn ^"GoObject" PipeNode.
  "Constructor for parse.PipeNode"
  {:added "1.0"
   :go "_ConstructPipeNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.Pos from text/template/parse/node.go:
(defn ^"GoObject" Pos.
  "Constructor for parse.Pos"
  {:added "1.0"
   :go "_ConstructPos(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.RangeNode from text/template/parse/node.go:
(defn ^"GoObject" RangeNode.
  "Constructor for parse.RangeNode"
  {:added "1.0"
   :go "_ConstructRangeNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.StringNode from text/template/parse/node.go:
(defn ^"GoObject" StringNode.
  "Constructor for parse.StringNode"
  {:added "1.0"
   :go "_ConstructStringNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.TemplateNode from text/template/parse/node.go:
(defn ^"GoObject" TemplateNode.
  "Constructor for parse.TemplateNode"
  {:added "1.0"
   :go "_ConstructTemplateNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.TextNode from text/template/parse/node.go:
(defn ^"GoObject" TextNode.
  "Constructor for parse.TextNode"
  {:added "1.0"
   :go "_ConstructTextNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.Tree from text/template/parse/parse.go:
(defn ^"GoObject" Tree.
  "Constructor for parse.Tree"
  {:added "1.0"
   :go "_ConstructTree(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.VariableNode from text/template/parse/node.go:
(defn ^"GoObject" VariableNode.
  "Constructor for parse.VariableNode"
  {:added "1.0"
   :go "_ConstructVariableNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.WithNode from text/template/parse/node.go:
(defn ^"GoObject" WithNode.
  "Constructor for parse.WithNode"
  {:added "1.0"
   :go "_ConstructWithNode(_v)"}
  [^Object _v])

JOKER FUNC text/template/parse.IsEmptyTree from text/template/parse/parse.go:
(defn ^"Boolean" IsEmptyTree
  "IsEmptyTree reports whether this tree (node) is empty of everything but space.\n\nGo input arguments: (n Node)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.text.template.parse/Node n]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "parse.IsEmptyTree(*_n)"}
  [^parse/Node _n])

JOKER FUNC text/template/parse.New from text/template/parse/parse.go:
;; (defn New
;;   "New allocates a new parse tree with the given name.\n\nGo input arguments: (name string, funcs ...map[])\n\nGo return type: *Tree\n\nJoker input arguments: [^String name, ^(ellipsis-somehow {}) funcs]\n\nJoker return type: (atom-of go.std.text.template.parse/Tree)"
;;   {:added "1.0"
;;    :go "__new(_name, ConvertToEllipsisHaHamap[](ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa())))"}
;;   [^String _name, ^{} _funcs])

JOKER FUNC text/template/parse.NewIdentifier from text/template/parse/node.go:
(defn NewIdentifier
  "NewIdentifier returns a new IdentifierNode with the given identifier name.\n\nGo input arguments: (ident string)\n\nGo return type: *IdentifierNode\n\nJoker input arguments: [^String ident]\n\nJoker return type: (atom-of go.std.text.template.parse/IdentifierNode)"
  {:added "1.0"
   :go "__newIdentifier(_ident)"}
  [^String _ident])

JOKER FUNC text/template/parse.Parse from text/template/parse/parse.go:
;; (defn Parse
;;   "Parse returns a map from template name to parse.Tree, created by parsing the\ntemplates described in the argument string. The top-level template will be\ngiven the specified name. If an error is encountered, parsing stops and an\nempty map is returned with the error.\n\nGo input arguments: (name string, text string, leftDelim string, rightDelim string, funcs ...map[])\n\nGo return type: (..., error)\n\nJoker input arguments: [^String name, ^String text, ^String leftDelim, ^String rightDelim, ^(ellipsis-somehow {}) funcs]\n\nJoker return type: [ABEND883(post.go: unrecognized Expr type *ast.MapType at: /usr/local/go-1.11.5/src/text/template/parse/parse.go:51:88) Error]"
;;   {:added "1.0"
;;    :go "__parse(_name, _text, _leftDelim, _rightDelim, ConvertToEllipsisHaHamap[](ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa())))"}
;;   [^String _name, ^String _text, ^String _leftDelim, ^String _rightDelim, ^{} _funcs])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["text/template/parse"]
    :doc "Provides a low-level interface to the text/template/parse package."
    :empty false}
  go.std.text.template.parse)
JOKER TYPE time.Duration from time/time.go:
(defn ^"GoObject" Duration.
  "Constructor for time.Duration"
  {:added "1.0"
   :go "_ConstructDuration(_v)"}
  [^Object _v])

JOKER TYPE time.Location from time/zoneinfo.go:
(defn ^"GoObject" Location.
  "Constructor for time.Location"
  {:added "1.0"
   :go "_ConstructLocation(_v)"}
  [^Object _v])

JOKER TYPE time.Month from time/time.go:
(defn ^"GoObject" Month.
  "Constructor for time.Month"
  {:added "1.0"
   :go "_ConstructMonth(_v)"}
  [^Object _v])

JOKER TYPE time.ParseError from time/format.go:
(defn ^"GoObject" ParseError.
  "Constructor for time.ParseError"
  {:added "1.0"
   :go "_ConstructParseError(_v)"}
  [^Object _v])

JOKER TYPE time.Ticker from time/tick.go:
(defn ^"GoObject" Ticker.
  "Constructor for time.Ticker"
  {:added "1.0"
   :go "_ConstructTicker(_v)"}
  [^Object _v])

JOKER TYPE time.Time from time/time.go:
(defn ^"GoObject" Time.
  "Constructor for time.Time"
  {:added "1.0"
   :go "_ConstructTime(_v)"}
  [^Object _v])

JOKER TYPE time.Timer from time/sleep.go:
(defn ^"GoObject" Timer.
  "Constructor for time.Timer"
  {:added "1.0"
   :go "_ConstructTimer(_v)"}
  [^Object _v])

JOKER TYPE time.Weekday from time/time.go:
(defn ^"GoObject" Weekday.
  "Constructor for time.Weekday"
  {:added "1.0"
   :go "_ConstructWeekday(_v)"}
  [^Object _v])

JOKER FUNC time.After from time/sleep.go:
;; (defn After
;;   "After waits for the duration to elapse and then sends the current time\non the returned channel.\nIt is equivalent to NewTimer(d).C.\nThe underlying Timer is not recovered by the garbage collector\nuntil the timer fires. If efficiency is a concern, use NewTimer\ninstead and call Timer.Stop if the timer is no longer needed.\n\nGo input arguments: (d Duration)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.time/Duration d]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.ChanType at: /usr/local/go-1.11.5/src/time/sleep.go:152:24)"
;;   {:added "1.0"
;;    :go "__after(*_d)"}
;;   [^time/Duration _d])

JOKER FUNC time.AfterFunc from time/sleep.go:
;; (defn AfterFunc
;;   "AfterFunc waits for the duration to elapse and then calls f\nin its own goroutine. It returns a Timer that can\nbe used to cancel the call using its Stop method.\n\nGo input arguments: (d Duration, f func)\n\nGo return type: *Timer\n\nJoker input arguments: [^go.std.time/Duration d, ^fn f]\n\nJoker return type: (atom-of go.std.time/Timer)"
;;   {:added "1.0"
;;    :go "__afterFunc(*_d, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^time/Duration _d, ^fn _f])

JOKER FUNC time.Date from time/time.go:
(defn Date
  "Date returns the Time corresponding to\n\tyyyy-mm-dd hh:mm:ss + nsec nanoseconds\nin the appropriate zone for that time in the given location.\n\nThe month, day, hour, min, sec, and nsec values may be outside\ntheir usual ranges and will be normalized during the conversion.\nFor example, October 32 converts to November 1.\n\nA daylight savings time transition skips or repeats times.\nFor example, in the United States, March 13, 2011 2:15am never occurred,\nwhile November 6, 2011 1:15am occurred twice. In such cases, the\nchoice of time zone, and therefore the time, is not well-defined.\nDate returns a time that is correct in one of the two zones involved\nin the transition, but it does not guarantee which.\n\nDate panics if loc is nil.\n\nGo input arguments: (year int, month Month, day int, hour int, min int, sec int, nsec int, loc *Location)\n\nGo return type: Time\n\nJoker input arguments: [^Int year, ^go.std.time/Month month, ^Int day, ^Int hour, ^Int min, ^Int sec, ^Int nsec, ^(atom-of go.std.time/Location) loc]\n\nJoker return type: go.std.time/Time"
  {:added "1.0"
   :go "__date(_year, *_month, _day, _hour, _min, _sec, _nsec, _loc)"}
  [^Int _year, ^time/Month _month, ^Int _day, ^Int _hour, ^Int _min, ^Int _sec, ^Int _nsec, ^time/Location _loc])

JOKER FUNC time.FixedZone from time/zoneinfo.go:
(defn FixedZone
  "FixedZone returns a Location that always uses\nthe given zone name and offset (seconds east of UTC).\n\nGo input arguments: (name string, offset int)\n\nGo return type: *Location\n\nJoker input arguments: [^String name, ^Int offset]\n\nJoker return type: (atom-of go.std.time/Location)"
  {:added "1.0"
   :go "__fixedZone(_name, _offset)"}
  [^String _name, ^Int _offset])

JOKER FUNC time.LoadLocation from time/zoneinfo.go:
(defn LoadLocation
  "LoadLocation returns the Location with the given name.\n\nIf the name is \"\" or \"UTC\", LoadLocation returns UTC.\nIf the name is \"Local\", LoadLocation returns Local.\n\nOtherwise, the name is taken to be a location name corresponding to a file\nin the IANA Time Zone database, such as \"America/New_York\".\n\nThe time zone database needed by LoadLocation may not be\npresent on all systems, especially non-Unix systems.\nLoadLocation looks in the directory or uncompressed zip file\nnamed by the ZONEINFO environment variable, if any, then looks in\nknown installation locations on Unix systems,\nand finally looks in $GOROOT/lib/time/zoneinfo.zip.\n\nGo input arguments: (name string)\n\nGo return type: (*Location, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.time/Location) Error]"
  {:added "1.0"
   :go "__loadLocation(_name)"}
  [^String _name])

JOKER FUNC time.LoadLocationFromTZData from time/zoneinfo_read.go:
;; (defn LoadLocationFromTZData
;;   "LoadLocationFromTZData returns a Location with the given name\ninitialized from the IANA Time Zone database-formatted data.\nThe data should be in the format of a standard IANA time zone file\n(for example, the content of /etc/localtime on Unix systems).\n\nGo input arguments: (name string, data []byte)\n\nGo return type: (*Location, error)\n\nJoker input arguments: [^String name, ^(vector-of Byte) data]\n\nJoker return type: [(atom-of go.std.time/Location) Error]"
;;   {:added "1.0"
;;    :go "__loadLocationFromTZData(_name, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^String _name, ^Object _data])

JOKER FUNC time.NewTicker from time/tick.go:
(defn NewTicker
  "NewTicker returns a new Ticker containing a channel that will send the\ntime with a period specified by the duration argument.\nIt adjusts the intervals or drops ticks to make up for slow receivers.\nThe duration d must be greater than zero; if not, NewTicker will panic.\nStop the ticker to release associated resources.\n\nGo input arguments: (d Duration)\n\nGo return type: *Ticker\n\nJoker input arguments: [^go.std.time/Duration d]\n\nJoker return type: (atom-of go.std.time/Ticker)"
  {:added "1.0"
   :go "__newTicker(*_d)"}
  [^time/Duration _d])

JOKER FUNC time.NewTimer from time/sleep.go:
(defn NewTimer
  "NewTimer creates a new Timer that will send\nthe current time on its channel after at least duration d.\n\nGo input arguments: (d Duration)\n\nGo return type: *Timer\n\nJoker input arguments: [^go.std.time/Duration d]\n\nJoker return type: (atom-of go.std.time/Timer)"
  {:added "1.0"
   :go "__newTimer(*_d)"}
  [^time/Duration _d])

JOKER FUNC time.Now from time/time.go:
(defn Now
  "Now returns the current local time.\n\nGo return type: Time\n\nJoker input arguments: []\n\nJoker return type: go.std.time/Time"
  {:added "1.0"
   :go "__now()"}
  [])

JOKER FUNC time.Parse from time/format.go:
(defn Parse
  "Parse parses a formatted string and returns the time value it represents.\nThe layout defines the format by showing how the reference time,\ndefined to be\n\tMon Jan 2 15:04:05 -0700 MST 2006\nwould be interpreted if it were the value; it serves as an example of\nthe input format. The same interpretation will then be made to the\ninput string.\n\nPredefined layouts ANSIC, UnixDate, RFC3339 and others describe standard\nand convenient representations of the reference time. For more information\nabout the formats and the definition of the reference time, see the\ndocumentation for ANSIC and the other constants defined by this package.\nAlso, the executable example for Time.Format demonstrates the working\nof the layout string in detail and is a good reference.\n\nElements omitted from the value are assumed to be zero or, when\nzero is impossible, one, so parsing \"3:04pm\" returns the time\ncorresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is\n0, this time is before the zero Time).\nYears must be in the range 0000..9999. The day of the week is checked\nfor syntax but it is otherwise ignored.\n\nIn the absence of a time zone indicator, Parse returns a time in UTC.\n\nWhen parsing a time with a zone offset like -0700, if the offset corresponds\nto a time zone used by the current location (Local), then Parse uses that\nlocation and zone in the returned time. Otherwise it records the time as\nbeing in a fabricated location with time fixed at the given zone offset.\n\nWhen parsing a time with a zone abbreviation like MST, if the zone abbreviation\nhas a defined offset in the current location, then that offset is used.\nThe zone abbreviation \"UTC\" is recognized as UTC regardless of location.\nIf the zone abbreviation is unknown, Parse records the time as being\nin a fabricated location with the given zone abbreviation and a zero offset.\nThis choice means that such a time can be parsed and reformatted with the\nsame layout losslessly, but the exact instant used in the representation will\ndiffer by the actual zone offset. To avoid such problems, prefer time layouts\nthat use a numeric zone offset, or use ParseInLocation.\n\nGo input arguments: (layout string, value string)\n\nGo return type: (Time, error)\n\nJoker input arguments: [^String layout, ^String value]\n\nJoker return type: [go.std.time/Time Error]"
  {:added "1.0"
   :go "__parse(_layout, _value)"}
  [^String _layout, ^String _value])

JOKER FUNC time.ParseDuration from time/format.go:
(defn ParseDuration
  "ParseDuration parses a duration string.\nA duration string is a possibly signed sequence of\ndecimal numbers, each with optional fraction and a unit suffix,\nsuch as \"300ms\", \"-1.5h\" or \"2h45m\".\nValid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\".\n\nGo input arguments: (s string)\n\nGo return type: (Duration, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [go.std.time/Duration Error]"
  {:added "1.0"
   :go "__parseDuration(_s)"}
  [^String _s])

JOKER FUNC time.ParseInLocation from time/format.go:
(defn ParseInLocation
  "ParseInLocation is like Parse but differs in two important ways.\nFirst, in the absence of time zone information, Parse interprets a time as UTC;\nParseInLocation interprets the time as in the given location.\nSecond, when given a zone offset or abbreviation, Parse tries to match it\nagainst the Local location; ParseInLocation uses the given location.\n\nGo input arguments: (layout string, value string, loc *Location)\n\nGo return type: (Time, error)\n\nJoker input arguments: [^String layout, ^String value, ^(atom-of go.std.time/Location) loc]\n\nJoker return type: [go.std.time/Time Error]"
  {:added "1.0"
   :go "__parseInLocation(_layout, _value, _loc)"}
  [^String _layout, ^String _value, ^time/Location _loc])

JOKER FUNC time.Since from time/time.go:
(defn Since
  "Since returns the time elapsed since t.\nIt is shorthand for time.Now().Sub(t).\n\nGo input arguments: (t Time)\n\nGo return type: Duration\n\nJoker input arguments: [^go.std.time/Time t]\n\nJoker return type: go.std.time/Duration"
  {:added "1.0"
   :go "__since(*_t)"}
  [^time/Time _t])

JOKER FUNC time.Sleep from time/sleep.go:
;; (defn Sleep
;;   "Sleep pauses the current goroutine for at least the duration d.\nA negative or zero duration causes Sleep to return immediately.\n\nGo input arguments: (d Duration)\n\nJoker input arguments: [^go.std.time/Duration d]"
;;   {:added "1.0"
;;    :go "__sleep(*_d)"}
;;   [^time/Duration _d])

JOKER FUNC time.Tick from time/tick.go:
;; (defn Tick
;;   "Tick is a convenience wrapper for NewTicker providing access to the ticking\nchannel only. While Tick is useful for clients that have no need to shut down\nthe Ticker, be aware that without a way to shut it down the underlying\nTicker cannot be recovered by the garbage collector; it \"leaks\".\nUnlike NewTicker, Tick will return nil if d <= 0.\n\nGo input arguments: (d Duration)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.time/Duration d]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.ChanType at: /usr/local/go-1.11.5/src/time/tick.go:54:23)"
;;   {:added "1.0"
;;    :go "__tick(*_d)"}
;;   [^time/Duration _d])

JOKER FUNC time.Unix from time/time.go:
(defn Unix
  "Unix returns the local Time corresponding to the given Unix time,\nsec seconds and nsec nanoseconds since January 1, 1970 UTC.\nIt is valid to pass nsec outside the range [0, 999999999].\nNot all sec values have a corresponding time value. One such\nvalue is 1<<63-1 (the largest int64 value).\n\nGo input arguments: (sec int64, nsec int64)\n\nGo return type: Time\n\nJoker input arguments: [^Int64 sec, ^Int64 nsec]\n\nJoker return type: go.std.time/Time"
  {:added "1.0"
   :go "__unix(_sec, _nsec)"}
  [^Int64 _sec, ^Int64 _nsec])

JOKER FUNC time.Until from time/time.go:
(defn Until
  "Until returns the duration until t.\nIt is shorthand for t.Sub(time.Now()).\n\nGo input arguments: (t Time)\n\nGo return type: Duration\n\nJoker input arguments: [^go.std.time/Time t]\n\nJoker return type: go.std.time/Duration"
  {:added "1.0"
   :go "__until(*_t)"}
  [^time/Time _t])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the time package."
    :empty false}
  go.std.time)
JOKER FUNC unicode.In from unicode/graphic.go:
;; (defn ^"Boolean" In
;;   "In reports whether the rune is a member of one of the ranges.\n\nGo input arguments: (r rune, ranges ...*RangeTable)\n\nGo return type: bool\n\nJoker input arguments: [^rune r, ^(ellipsis-somehow unicode/RangeTable) ranges]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "unicode.In(_r, ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHa*_unicode.RangeTable(_ranges)))"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r, ^unicode/RangeTable _ranges])

JOKER FUNC unicode.Is from unicode/letter.go:
;; (defn ^"Boolean" Is
;;   "Is reports whether the rune is in the specified table of ranges.\n\nGo input arguments: (rangeTab *RangeTable, r rune)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.unicode/RangeTable) rangeTab, ^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "unicode.Is(_rangeTab, _r)"}
;;   [^unicode/RangeTable _rangeTab, ^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode.IsControl from unicode/graphic.go:
;; (defn ^"Boolean" IsControl
;;   "IsControl reports whether the rune is a control character.\nThe C (Other) Unicode category includes more code points\nsuch as surrogates; use Is(C, r) to test for them.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "unicode.IsControl(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode.IsDigit from unicode/digit.go:
;; (defn ^"Boolean" IsDigit
;;   "IsDigit reports whether the rune is a decimal digit.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "unicode.IsDigit(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode.IsGraphic from unicode/graphic.go:
;; (defn ^"Boolean" IsGraphic
;;   "IsGraphic reports whether the rune is defined as a Graphic by Unicode.\nSuch characters include letters, marks, numbers, punctuation, symbols, and\nspaces, from categories L, M, N, P, S, Zs.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "unicode.IsGraphic(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode.IsLetter from unicode/graphic.go:
;; (defn ^"Boolean" IsLetter
;;   "IsLetter reports whether the rune is a letter (category L).\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "unicode.IsLetter(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode.IsLower from unicode/letter.go:
;; (defn ^"Boolean" IsLower
;;   "IsLower reports whether the rune is a lower case letter.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "unicode.IsLower(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode.IsMark from unicode/graphic.go:
;; (defn ^"Boolean" IsMark
;;   "IsMark reports whether the rune is a mark character (category M).\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "unicode.IsMark(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode.IsNumber from unicode/graphic.go:
;; (defn ^"Boolean" IsNumber
;;   "IsNumber reports whether the rune is a number (category N).\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "unicode.IsNumber(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode.IsOneOf from unicode/graphic.go:
;; (defn ^"Boolean" IsOneOf
;;   "IsOneOf reports whether the rune is a member of one of the ranges.\nThe function \"In\" provides a nicer signature and should be used in preference to IsOneOf.\n\nGo input arguments: (ranges []*RangeTable, r rune)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of (atom-of go.std.unicode/RangeTable)) ranges, ^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "unicode.IsOneOf(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_unicode.RangeTable(_ranges)), _r)"}
;;   [^Object _ranges, ^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode.IsPrint from unicode/graphic.go:
;; (defn ^"Boolean" IsPrint
;;   "IsPrint reports whether the rune is defined as printable by Go. Such\ncharacters include letters, marks, numbers, punctuation, symbols, and the\nASCII space character, from categories L, M, N, P, S and the ASCII space\ncharacter. This categorization is the same as IsGraphic except that the\nonly spacing character is ASCII space, U+0020.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "unicode.IsPrint(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode.IsPunct from unicode/graphic.go:
;; (defn ^"Boolean" IsPunct
;;   "IsPunct reports whether the rune is a Unicode punctuation character\n(category P).\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "unicode.IsPunct(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode.IsSpace from unicode/graphic.go:
;; (defn ^"Boolean" IsSpace
;;   "IsSpace reports whether the rune is a space character as defined\nby Unicode's White Space property; in the Latin-1 space\nthis is\n\t'\\t', '\\n', '\\v', '\\f', '\\r', ' ', U+0085 (NEL), U+00A0 (NBSP).\nOther definitions of spacing characters are set by category\nZ and property Pattern_White_Space.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "unicode.IsSpace(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode.IsSymbol from unicode/graphic.go:
;; (defn ^"Boolean" IsSymbol
;;   "IsSymbol reports whether the rune is a symbolic character.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "unicode.IsSymbol(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode.IsTitle from unicode/letter.go:
;; (defn ^"Boolean" IsTitle
;;   "IsTitle reports whether the rune is a title case letter.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "unicode.IsTitle(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode.IsUpper from unicode/letter.go:
;; (defn ^"Boolean" IsUpper
;;   "IsUpper reports whether the rune is an upper case letter.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "unicode.IsUpper(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode.SimpleFold from unicode/letter.go:
;; (defn SimpleFold
;;   "SimpleFold iterates over Unicode code points equivalent under\nthe Unicode-defined simple case folding. Among the code points\nequivalent to rune (including rune itself), SimpleFold returns the\nsmallest rune > r if one exists, or else the smallest rune >= 0.\nIf r is not a valid Unicode code point, SimpleFold(r) returns r.\n\nFor example:\n\tSimpleFold('A') = 'a'\n\tSimpleFold('a') = 'A'\n\n\tSimpleFold('K') = 'k'\n\tSimpleFold('k') = '\\u212A' (Kelvin symbol, K)\n\tSimpleFold('\\u212A') = 'K'\n\n\tSimpleFold('1') = '1'\n\n\tSimpleFold(-2) = -2\n\nGo input arguments: (r rune)\n\nGo return type: ...\n\nJoker input arguments: [^rune r]\n\nJoker return type: ABEND043(post.go: unsupported built-in type rune)"
;;   {:added "1.0"
;;    :go "__simpleFold(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode.To from unicode/letter.go:
;; (defn To
;;   "To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase.\n\nGo input arguments: (_case int, r rune)\n\nGo return type: ...\n\nJoker input arguments: [^Int _case, ^rune r]\n\nJoker return type: ABEND043(post.go: unsupported built-in type rune)"
;;   {:added "1.0"
;;    :go "__to(__case, _r)"}
;;   [^Int __case, ^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode.ToLower from unicode/letter.go:
;; (defn ToLower
;;   "ToLower maps the rune to lower case.\n\nGo input arguments: (r rune)\n\nGo return type: ...\n\nJoker input arguments: [^rune r]\n\nJoker return type: ABEND043(post.go: unsupported built-in type rune)"
;;   {:added "1.0"
;;    :go "__toLower(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode.ToTitle from unicode/letter.go:
;; (defn ToTitle
;;   "ToTitle maps the rune to title case.\n\nGo input arguments: (r rune)\n\nGo return type: ...\n\nJoker input arguments: [^rune r]\n\nJoker return type: ABEND043(post.go: unsupported built-in type rune)"
;;   {:added "1.0"
;;    :go "__toTitle(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode.ToUpper from unicode/letter.go:
;; (defn ToUpper
;;   "ToUpper maps the rune to upper case.\n\nGo input arguments: (r rune)\n\nGo return type: ...\n\nJoker input arguments: [^rune r]\n\nJoker return type: ABEND043(post.go: unsupported built-in type rune)"
;;   {:added "1.0"
;;    :go "__toUpper(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode/utf16.Decode from unicode/utf16/utf16.go:
;; (defn Decode
;;   "Decode returns the Unicode code point sequence represented\nby the UTF-16 encoding s.\n\nGo input arguments: (s []uint16)\n\nGo return type: []...\n\nJoker input arguments: [^(vector-of UInt16) s]\n\nJoker return type: (vector-of ABEND043(post.go: unsupported built-in type rune))"
;;   {:added "1.0"
;;    :go "__decode(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfuint16(_s)))"}
;;   [^Object _s])

JOKER FUNC unicode/utf16.DecodeRune from unicode/utf16/utf16.go:
;; (defn DecodeRune
;;   "DecodeRune returns the UTF-16 decoding of a surrogate pair.\nIf the pair is not a valid UTF-16 surrogate pair, DecodeRune returns\nthe Unicode replacement code point U+FFFD.\n\nGo input arguments: (r1 rune, r2 rune)\n\nGo return type: ...\n\nJoker input arguments: [^rune r1, ^rune r2]\n\nJoker return type: ABEND043(post.go: unsupported built-in type rune)"
;;   {:added "1.0"
;;    :go "__decodeRune(_r1, _r2)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r1, ^ABEND044(pre.go: unsupported built-in type rune) _r2])

JOKER FUNC unicode/utf16.Encode from unicode/utf16/utf16.go:
;; (defn Encode
;;   "Encode returns the UTF-16 encoding of the Unicode code point sequence s.\n\nGo input arguments: (s []rune)\n\nGo return type: []uint16\n\nJoker input arguments: [^(vector-of rune) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__encode(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfrune(_s)))"}
;;   [^Object _s])

JOKER FUNC unicode/utf16.EncodeRune from unicode/utf16/utf16.go:
;; (defn EncodeRune
;;   "EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune.\nIf the rune is not a valid Unicode code point or does not need encoding,\nEncodeRune returns U+FFFD, U+FFFD.\n\nGo input arguments: (r rune)\n\nGo return type: (r1 ..., r2 ...)\n\nJoker input arguments: [^rune r]\n\nJoker return type: [ABEND043(post.go: unsupported built-in type rune) ABEND043(post.go: unsupported built-in type rune)]"
;;   {:added "1.0"
;;    :go "__encodeRune(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode/utf16.IsSurrogate from unicode/utf16/utf16.go:
;; (defn ^"Boolean" IsSurrogate
;;   "IsSurrogate reports whether the specified Unicode code point\ncan appear in a surrogate pair.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "utf16.IsSurrogate(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode/utf8.DecodeLastRune from unicode/utf8/utf8.go:
;; (defn DecodeLastRune
;;   "DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and\nits width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if\nthe encoding is invalid, it returns (RuneError, 1). Both are impossible\nresults for correct, non-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo input arguments: (p []byte)\n\nGo return type: (r ..., size int)\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: [ABEND043(post.go: unsupported built-in type rune) Int]"
;;   {:added "1.0"
;;    :go "__decodeLastRune(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^Object _p])

JOKER FUNC unicode/utf8.DecodeLastRuneInString from unicode/utf8/utf8.go:
;; (defn DecodeLastRuneInString
;;   "DecodeLastRuneInString is like DecodeLastRune but its input is a string. If\ns is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid,\nit returns (RuneError, 1). Both are impossible results for correct,\nnon-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo input arguments: (s string)\n\nGo return type: (r ..., size int)\n\nJoker input arguments: [^String s]\n\nJoker return type: [ABEND043(post.go: unsupported built-in type rune) Int]"
;;   {:added "1.0"
;;    :go "__decodeLastRuneInString(_s)"}
;;   [^String _s])

JOKER FUNC unicode/utf8.DecodeRune from unicode/utf8/utf8.go:
;; (defn DecodeRune
;;   "DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and\nits width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if\nthe encoding is invalid, it returns (RuneError, 1). Both are impossible\nresults for correct, non-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo input arguments: (p []byte)\n\nGo return type: (r ..., size int)\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: [ABEND043(post.go: unsupported built-in type rune) Int]"
;;   {:added "1.0"
;;    :go "__decodeRune(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^Object _p])

JOKER FUNC unicode/utf8.DecodeRuneInString from unicode/utf8/utf8.go:
;; (defn DecodeRuneInString
;;   "DecodeRuneInString is like DecodeRune but its input is a string. If s is\nempty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it\nreturns (RuneError, 1). Both are impossible results for correct, non-empty\nUTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo input arguments: (s string)\n\nGo return type: (r ..., size int)\n\nJoker input arguments: [^String s]\n\nJoker return type: [ABEND043(post.go: unsupported built-in type rune) Int]"
;;   {:added "1.0"
;;    :go "__decodeRuneInString(_s)"}
;;   [^String _s])

JOKER FUNC unicode/utf8.EncodeRune from unicode/utf8/utf8.go:
;; (defn ^"Int" EncodeRune
;;   "EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.\nIt returns the number of bytes written.\n\nGo input arguments: (p []byte, r rune)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) p, ^rune r]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "utf8.EncodeRune(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)), _r)"}
;;   [^Object _p, ^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode/utf8.FullRune from unicode/utf8/utf8.go:
;; (defn ^"Boolean" FullRune
;;   "FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune.\nAn invalid encoding is considered a full Rune since it will convert as a width-1 error rune.\n\nGo input arguments: (p []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "utf8.FullRune(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^Object _p])

JOKER FUNC unicode/utf8.FullRuneInString from unicode/utf8/utf8.go:
(defn ^"Boolean" FullRuneInString
  "FullRuneInString is like FullRune but its input is a string.\n\nGo input arguments: (s string)\n\nGo return type: bool\n\nJoker input arguments: [^String s]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "utf8.FullRuneInString(_s)"}
  [^String _s])

JOKER FUNC unicode/utf8.RuneCount from unicode/utf8/utf8.go:
;; (defn ^"Int" RuneCount
;;   "RuneCount returns the number of runes in p. Erroneous and short\nencodings are treated as single runes of width 1 byte.\n\nGo input arguments: (p []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "utf8.RuneCount(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^Object _p])

JOKER FUNC unicode/utf8.RuneCountInString from unicode/utf8/utf8.go:
(defn ^"Int" RuneCountInString
  "RuneCountInString is like RuneCount but its input is a string.\n\nGo input arguments: (s string)\n\nGo return type: int\n\nJoker input arguments: [^String s]\n\nJoker return type: Int"
  {:added "1.0"
   :go "utf8.RuneCountInString(_s)"}
  [^String _s])

JOKER FUNC unicode/utf8.RuneLen from unicode/utf8/utf8.go:
;; (defn ^"Int" RuneLen
;;   "RuneLen returns the number of bytes required to encode the rune.\nIt returns -1 if the rune is not a valid value to encode in UTF-8.\n\nGo input arguments: (r rune)\n\nGo return type: int\n\nJoker input arguments: [^rune r]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "utf8.RuneLen(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode/utf8.RuneStart from unicode/utf8/utf8.go:
(defn ^"Boolean" RuneStart
  "RuneStart reports whether the byte could be the first byte of an encoded,\npossibly invalid rune. Second and subsequent bytes always have the top two\nbits set to 10.\n\nGo input arguments: (b byte)\n\nGo return type: bool\n\nJoker input arguments: [^Byte b]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "utf8.RuneStart(_b)"}
  [^Byte _b])

JOKER FUNC unicode/utf8.Valid from unicode/utf8/utf8.go:
;; (defn ^"Boolean" Valid
;;   "Valid reports whether p consists entirely of valid UTF-8-encoded runes.\n\nGo input arguments: (p []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "utf8.Valid(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^Object _p])

JOKER FUNC unicode/utf8.ValidRune from unicode/utf8/utf8.go:
;; (defn ^"Boolean" ValidRune
;;   "ValidRune reports whether r can be legally encoded as UTF-8.\nCode points that are out of range or a surrogate half are illegal.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "utf8.ValidRune(_r)"}
;;   [^ABEND044(pre.go: unsupported built-in type rune) _r])

JOKER FUNC unicode/utf8.ValidString from unicode/utf8/utf8.go:
(defn ^"Boolean" ValidString
  "ValidString reports whether s consists entirely of valid UTF-8-encoded runes.\n\nGo input arguments: (s string)\n\nGo return type: bool\n\nJoker input arguments: [^String s]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "utf8.ValidString(_s)"}
  [^String _s])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["unicode/utf8"]
    :doc "Provides a low-level interface to the unicode/utf8 package."
    :empty false}
  go.std.unicode.utf8)
GO FUNC archive/tar.FileInfoHeader from archive/tar/common.go:
// func __fileInfoHeader(fi ABEND987(genutils.go: imports not yet supported: os.FileInfo), link string) Object {
// 	_res1, _res2 := _tar.FileInfoHeader(fi, link)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC archive/tar.NewReader from archive/tar/reader.go:
// func __newReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _tar.NewReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC archive/tar.NewWriter from archive/tar/writer.go:
// func __newWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _tar.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO TYPE archive/zip.Compressor from archive/zip/register.go:
func ExtractGoObjectCompressor(args []Object, index int) *_zip.Compressor {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _zip.Compressor:
			return &r
		case *_zip.Compressor:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/zip.Compressor]"))
}

// func _ConstructCompressor(_v Object) _zip.Compressor {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _zip.Compressor:
// 			return _g
// 		case *_zip.Compressor:
// 			return *_g
// 		}
// 	default:
// 		return _zip.Compressor(_o.ABEND674(unknown underlying type *ast.FuncType for Compressor))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[zip.Compressor] or whatever"))
// }

GO TYPE archive/zip.Decompressor from archive/zip/register.go:
func ExtractGoObjectDecompressor(args []Object, index int) *_zip.Decompressor {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _zip.Decompressor:
			return &r
		case *_zip.Decompressor:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/zip.Decompressor]"))
}

// func _ConstructDecompressor(_v Object) _zip.Decompressor {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _zip.Decompressor:
// 			return _g
// 		case *_zip.Decompressor:
// 			return *_g
// 		}
// 	default:
// 		return _zip.Decompressor(_o.ABEND674(unknown underlying type *ast.FuncType for Decompressor))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[zip.Decompressor] or whatever"))
// }

GO TYPE archive/zip.File from archive/zip/reader.go:
func ExtractGoObjectFile(args []Object, index int) *_zip.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _zip.File:
			return &r
		case *_zip.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/zip.File]"))
}

func _mapToFile(o Map) *_zip.File {
	return &_zip.File{
	}
}

func _vectorToFile(o *Vector) *_zip.File {
	return &_zip.File{
	}
}

func _ConstructFile(_v Object) *_zip.File {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _zip.File:
			return &_g
		case *_zip.File:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFile(_o.(Map))
	case case *Vector:
		return _vectorToFile(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[zip.File] or Map"))
}

GO TYPE archive/zip.FileHeader from archive/zip/struct.go:
func ExtractGoObjectFileHeader(args []Object, index int) *_zip.FileHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _zip.FileHeader:
			return &r
		case *_zip.FileHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/zip.FileHeader]"))
}

func _mapToFileHeader(o Map) *_zip.FileHeader {
	return &_zip.FileHeader{
	}
}

func _vectorToFileHeader(o *Vector) *_zip.FileHeader {
	return &_zip.FileHeader{
	}
}

func _ConstructFileHeader(_v Object) *_zip.FileHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _zip.FileHeader:
			return &_g
		case *_zip.FileHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFileHeader(_o.(Map))
	case case *Vector:
		return _vectorToFileHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[zip.FileHeader] or Map"))
}

GO TYPE archive/zip.ReadCloser from archive/zip/reader.go:
func ExtractGoObjectReadCloser(args []Object, index int) *_zip.ReadCloser {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _zip.ReadCloser:
			return &r
		case *_zip.ReadCloser:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/zip.ReadCloser]"))
}

func _mapToReadCloser(o Map) *_zip.ReadCloser {
	return &_zip.ReadCloser{
	}
}

func _vectorToReadCloser(o *Vector) *_zip.ReadCloser {
	return &_zip.ReadCloser{
	}
}

func _ConstructReadCloser(_v Object) *_zip.ReadCloser {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _zip.ReadCloser:
			return &_g
		case *_zip.ReadCloser:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReadCloser(_o.(Map))
	case case *Vector:
		return _vectorToReadCloser(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[zip.ReadCloser] or Map"))
}

GO TYPE archive/zip.Reader from archive/zip/reader.go:
func ExtractGoObjectReader(args []Object, index int) *_zip.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _zip.Reader:
			return &r
		case *_zip.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/zip.Reader]"))
}

func _mapToReader(o Map) *_zip.Reader {
	return &_zip.Reader{
	}
}

func _vectorToReader(o *Vector) *_zip.Reader {
	return &_zip.Reader{
	}
}

func _ConstructReader(_v Object) *_zip.Reader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _zip.Reader:
			return &_g
		case *_zip.Reader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReader(_o.(Map))
	case case *Vector:
		return _vectorToReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[zip.Reader] or Map"))
}

GO TYPE archive/zip.Writer from archive/zip/writer.go:
func ExtractGoObjectWriter(args []Object, index int) *_zip.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _zip.Writer:
			return &r
		case *_zip.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/zip.Writer]"))
}

func _mapToWriter(o Map) *_zip.Writer {
	return &_zip.Writer{
	}
}

func _vectorToWriter(o *Vector) *_zip.Writer {
	return &_zip.Writer{
	}
}

func _ConstructWriter(_v Object) *_zip.Writer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _zip.Writer:
			return &_g
		case *_zip.Writer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWriter(_o.(Map))
	case case *Vector:
		return _vectorToWriter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[zip.Writer] or Map"))
}

GO FUNC archive/zip.FileInfoHeader from archive/zip/struct.go:
// func __fileInfoHeader(fi ABEND987(genutils.go: imports not yet supported: os.FileInfo)) Object {
// 	_res1, _res2 := _zip.FileInfoHeader(fi)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC archive/zip.NewReader from archive/zip/reader.go:
// func __newReader(r ABEND987(genutils.go: imports not yet supported: io.ReaderAt), size int64) Object {
// 	_res1, _res2 := _zip.NewReader(r, size)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC archive/zip.NewWriter from archive/zip/writer.go:
// func __newWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _zip.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC archive/zip.OpenReader from archive/zip/reader.go:
func __openReader(name string) Object {
	_res1, _res2 := _zip.OpenReader(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC archive/zip.RegisterCompressor from archive/zip/register.go:
// func __registerCompressor(method uint16, comp _zip.Compressor) Object {
// 	_zip.RegisterCompressor(method, comp)
// 	...ABEND675: TODO...
// }

GO FUNC archive/zip.RegisterDecompressor from archive/zip/register.go:
// func __registerDecompressor(method uint16, dcomp _zip.Decompressor) Object {
// 	_zip.RegisterDecompressor(method, dcomp)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package zip

import (
	_zip "archive/zip"
	. "github.com/candid82/joker/core"
)
GO TYPE bufio.ReadWriter from bufio/bufio.go:
func ExtractGoObjectReadWriter(args []Object, index int) *_bufio.ReadWriter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _bufio.ReadWriter:
			return &r
		case *_bufio.ReadWriter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[bufio.ReadWriter]"))
}

func _mapToReadWriter(o Map) *_bufio.ReadWriter {
	return &_bufio.ReadWriter{
	}
}

func _vectorToReadWriter(o *Vector) *_bufio.ReadWriter {
	return &_bufio.ReadWriter{
	}
}

func _ConstructReadWriter(_v Object) *_bufio.ReadWriter {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _bufio.ReadWriter:
			return &_g
		case *_bufio.ReadWriter:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReadWriter(_o.(Map))
	case case *Vector:
		return _vectorToReadWriter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[bufio.ReadWriter] or Map"))
}

GO TYPE bufio.Reader from bufio/bufio.go:
func ExtractGoObjectReader(args []Object, index int) *_bufio.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _bufio.Reader:
			return &r
		case *_bufio.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[bufio.Reader]"))
}

func _mapToReader(o Map) *_bufio.Reader {
	return &_bufio.Reader{
	}
}

func _vectorToReader(o *Vector) *_bufio.Reader {
	return &_bufio.Reader{
	}
}

func _ConstructReader(_v Object) *_bufio.Reader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _bufio.Reader:
			return &_g
		case *_bufio.Reader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReader(_o.(Map))
	case case *Vector:
		return _vectorToReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[bufio.Reader] or Map"))
}

GO TYPE bufio.Scanner from bufio/scan.go:
func ExtractGoObjectScanner(args []Object, index int) *_bufio.Scanner {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _bufio.Scanner:
			return &r
		case *_bufio.Scanner:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[bufio.Scanner]"))
}

func _mapToScanner(o Map) *_bufio.Scanner {
	return &_bufio.Scanner{
	}
}

func _vectorToScanner(o *Vector) *_bufio.Scanner {
	return &_bufio.Scanner{
	}
}

func _ConstructScanner(_v Object) *_bufio.Scanner {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _bufio.Scanner:
			return &_g
		case *_bufio.Scanner:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToScanner(_o.(Map))
	case case *Vector:
		return _vectorToScanner(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[bufio.Scanner] or Map"))
}

GO TYPE bufio.SplitFunc from bufio/scan.go:
func ExtractGoObjectSplitFunc(args []Object, index int) *_bufio.SplitFunc {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _bufio.SplitFunc:
			return &r
		case *_bufio.SplitFunc:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[bufio.SplitFunc]"))
}

// func _ConstructSplitFunc(_v Object) _bufio.SplitFunc {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _bufio.SplitFunc:
// 			return _g
// 		case *_bufio.SplitFunc:
// 			return *_g
// 		}
// 	default:
// 		return _bufio.SplitFunc(_o.ABEND674(unknown underlying type *ast.FuncType for SplitFunc))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[bufio.SplitFunc] or whatever"))
// }

GO TYPE bufio.Writer from bufio/bufio.go:
func ExtractGoObjectWriter(args []Object, index int) *_bufio.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _bufio.Writer:
			return &r
		case *_bufio.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[bufio.Writer]"))
}

func _mapToWriter(o Map) *_bufio.Writer {
	return &_bufio.Writer{
	}
}

func _vectorToWriter(o *Vector) *_bufio.Writer {
	return &_bufio.Writer{
	}
}

func _ConstructWriter(_v Object) *_bufio.Writer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _bufio.Writer:
			return &_g
		case *_bufio.Writer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWriter(_o.(Map))
	case case *Vector:
		return _vectorToWriter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[bufio.Writer] or Map"))
}

GO FUNC bufio.NewReadWriter from bufio/bufio.go:
func __newReadWriter(r *_bufio.Reader, w *_bufio.Writer) Object {
	_res := _bufio.NewReadWriter(r, w)
	return MakeGoObject(_res)
}

GO FUNC bufio.NewReader from bufio/bufio.go:
// func __newReader(rd ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _bufio.NewReader(rd)
// 	return MakeGoObject(_res)
// }

GO FUNC bufio.NewReaderSize from bufio/bufio.go:
// func __newReaderSize(rd ABEND987(genutils.go: imports not yet supported: io.Reader), size int) Object {
// 	_res := _bufio.NewReaderSize(rd, size)
// 	return MakeGoObject(_res)
// }

GO FUNC bufio.NewScanner from bufio/scan.go:
// func __newScanner(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _bufio.NewScanner(r)
// 	return MakeGoObject(_res)
// }

GO FUNC bufio.NewWriter from bufio/bufio.go:
// func __newWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _bufio.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC bufio.NewWriterSize from bufio/bufio.go:
// func __newWriterSize(w ABEND987(genutils.go: imports not yet supported: io.Writer), size int) Object {
// 	_res := _bufio.NewWriterSize(w, size)
// 	return MakeGoObject(_res)
// }

GO FUNC bufio.ScanBytes from bufio/scan.go:
// func __scanBytes(data []byte, atEOF bool) Object {
// 	advance, token, err := _bufio.ScanBytes(data, atEOF)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(advance))
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range token {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC bufio.ScanLines from bufio/scan.go:
// func __scanLines(data []byte, atEOF bool) Object {
// 	advance, token, err := _bufio.ScanLines(data, atEOF)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(advance))
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range token {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC bufio.ScanRunes from bufio/scan.go:
// func __scanRunes(data []byte, atEOF bool) Object {
// 	advance, token, err := _bufio.ScanRunes(data, atEOF)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(advance))
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range token {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC bufio.ScanWords from bufio/scan.go:
// func __scanWords(data []byte, atEOF bool) Object {
// 	advance, token, err := _bufio.ScanWords(data, atEOF)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(advance))
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range token {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package bufio

import (
	_bufio "bufio"
	. "github.com/candid82/joker/core"
)
GO TYPE bytes.Buffer from bytes/buffer.go:
func ExtractGoObjectBuffer(args []Object, index int) *_bytes.Buffer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _bytes.Buffer:
			return &r
		case *_bytes.Buffer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[bytes.Buffer]"))
}

func _mapToBuffer(o Map) *_bytes.Buffer {
	return &_bytes.Buffer{
	}
}

func _vectorToBuffer(o *Vector) *_bytes.Buffer {
	return &_bytes.Buffer{
	}
}

func _ConstructBuffer(_v Object) *_bytes.Buffer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _bytes.Buffer:
			return &_g
		case *_bytes.Buffer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBuffer(_o.(Map))
	case case *Vector:
		return _vectorToBuffer(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[bytes.Buffer] or Map"))
}

GO TYPE bytes.Reader from bytes/reader.go:
func ExtractGoObjectReader(args []Object, index int) *_bytes.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _bytes.Reader:
			return &r
		case *_bytes.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[bytes.Reader]"))
}

func _mapToReader(o Map) *_bytes.Reader {
	return &_bytes.Reader{
	}
}

func _vectorToReader(o *Vector) *_bytes.Reader {
	return &_bytes.Reader{
	}
}

func _ConstructReader(_v Object) *_bytes.Reader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _bytes.Reader:
			return &_g
		case *_bytes.Reader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReader(_o.(Map))
	case case *Vector:
		return _vectorToReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[bytes.Reader] or Map"))
}

GO FUNC bytes.Compare from bytes/bytes_decl.go:
// func __compare(a []byte, b []byte)  {
// 	_res := _bytes.Compare(a, b)
// 	return MakeInt(_res)
// }

GO FUNC bytes.Contains from bytes/bytes.go:
// func __contains(b []byte, subslice []byte)  {
// 	_res := _bytes.Contains(b, subslice)
// 	return MakeBoolean(_res)
// }

GO FUNC bytes.ContainsAny from bytes/bytes.go:
// func __containsAny(b []byte, chars string)  {
// 	_res := _bytes.ContainsAny(b, chars)
// 	return MakeBoolean(_res)
// }

GO FUNC bytes.ContainsRune from bytes/bytes.go:
// func __containsRune(b []byte, r rune)  {
// 	_res := _bytes.ContainsRune(b, r)
// 	return MakeBoolean(_res)
// }

GO FUNC bytes.Count from bytes/bytes.go:
// func __count(s []byte, sep []byte)  {
// 	_res := _bytes.Count(s, sep)
// 	return MakeInt(_res)
// }

GO FUNC bytes.Equal from bytes/bytes_decl.go:
// func __equal(a []byte, b []byte)  {
// 	_res := _bytes.Equal(a, b)
// 	return MakeBoolean(_res)
// }

GO FUNC bytes.EqualFold from bytes/bytes.go:
// func __equalFold(s []byte, t []byte)  {
// 	_res := _bytes.EqualFold(s, t)
// 	return MakeBoolean(_res)
// }

GO FUNC bytes.Fields from bytes/bytes.go:
// func __fields(s []byte) Object {
// 	_res := _bytes.Fields(s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range _elem1 {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_vec1 = _vec1.Conjoin(_vec2)
// 	}
// 	return _vec1
// }

GO FUNC bytes.FieldsFunc from bytes/bytes.go:
// func __fieldsFunc(s []byte, f func) Object {
// 	_res := _bytes.FieldsFunc(s, f)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range _elem1 {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_vec1 = _vec1.Conjoin(_vec2)
// 	}
// 	return _vec1
// }

GO FUNC bytes.HasPrefix from bytes/bytes.go:
// func __hasPrefix(s []byte, prefix []byte)  {
// 	_res := _bytes.HasPrefix(s, prefix)
// 	return MakeBoolean(_res)
// }

GO FUNC bytes.HasSuffix from bytes/bytes.go:
// func __hasSuffix(s []byte, suffix []byte)  {
// 	_res := _bytes.HasSuffix(s, suffix)
// 	return MakeBoolean(_res)
// }

GO FUNC bytes.Index from bytes/bytes.go:
// func __index(s []byte, sep []byte)  {
// 	_res := _bytes.Index(s, sep)
// 	return MakeInt(_res)
// }

GO FUNC bytes.IndexAny from bytes/bytes.go:
// func __indexAny(s []byte, chars string)  {
// 	_res := _bytes.IndexAny(s, chars)
// 	return MakeInt(_res)
// }

GO FUNC bytes.IndexByte from bytes/bytes_decl.go:
// func __indexByte(b []byte, c byte)  {
// 	_res := _bytes.IndexByte(b, c)
// 	return MakeInt(_res)
// }

GO FUNC bytes.IndexFunc from bytes/bytes.go:
// func __indexFunc(s []byte, f func)  {
// 	_res := _bytes.IndexFunc(s, f)
// 	return MakeInt(_res)
// }

GO FUNC bytes.IndexRune from bytes/bytes.go:
// func __indexRune(s []byte, r rune)  {
// 	_res := _bytes.IndexRune(s, r)
// 	return MakeInt(_res)
// }

GO FUNC bytes.Join from bytes/bytes.go:
// func __join(s [][]byte, sep []byte) Object {
// 	_res := _bytes.Join(s, sep)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.LastIndex from bytes/bytes.go:
// func __lastIndex(s []byte, sep []byte)  {
// 	_res := _bytes.LastIndex(s, sep)
// 	return MakeInt(_res)
// }

GO FUNC bytes.LastIndexAny from bytes/bytes.go:
// func __lastIndexAny(s []byte, chars string)  {
// 	_res := _bytes.LastIndexAny(s, chars)
// 	return MakeInt(_res)
// }

GO FUNC bytes.LastIndexByte from bytes/bytes.go:
// func __lastIndexByte(s []byte, c byte)  {
// 	_res := _bytes.LastIndexByte(s, c)
// 	return MakeInt(_res)
// }

GO FUNC bytes.LastIndexFunc from bytes/bytes.go:
// func __lastIndexFunc(s []byte, f func)  {
// 	_res := _bytes.LastIndexFunc(s, f)
// 	return MakeInt(_res)
// }

GO FUNC bytes.Map from bytes/bytes.go:
// func __map(mapping func, s []byte) Object {
// 	_res := _bytes.Map(mapping, s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.NewBuffer from bytes/buffer.go:
// func __newBuffer(buf []byte) Object {
// 	_res := _bytes.NewBuffer(buf)
// 	return MakeGoObject(_res)
// }

GO FUNC bytes.NewBufferString from bytes/buffer.go:
func __newBufferString(s string) Object {
	_res := _bytes.NewBufferString(s)
	return MakeGoObject(_res)
}

GO FUNC bytes.NewReader from bytes/reader.go:
// func __newReader(b []byte) Object {
// 	_res := _bytes.NewReader(b)
// 	return MakeGoObject(_res)
// }

GO FUNC bytes.Repeat from bytes/bytes.go:
// func __repeat(b []byte, count int) Object {
// 	_res := _bytes.Repeat(b, count)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.Replace from bytes/bytes.go:
// func __replace(s []byte, old []byte, new []byte, n int) Object {
// 	_res := _bytes.Replace(s, old, new, n)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.Runes from bytes/bytes.go:
// func __runes(s []byte) Object {
// 	_res := _bytes.Runes(s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(_elem1)
// 	}
// 	return _vec1
// }

GO FUNC bytes.Split from bytes/bytes.go:
// func __split(s []byte, sep []byte) Object {
// 	_res := _bytes.Split(s, sep)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range _elem1 {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_vec1 = _vec1.Conjoin(_vec2)
// 	}
// 	return _vec1
// }

GO FUNC bytes.SplitAfter from bytes/bytes.go:
// func __splitAfter(s []byte, sep []byte) Object {
// 	_res := _bytes.SplitAfter(s, sep)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range _elem1 {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_vec1 = _vec1.Conjoin(_vec2)
// 	}
// 	return _vec1
// }

GO FUNC bytes.SplitAfterN from bytes/bytes.go:
// func __splitAfterN(s []byte, sep []byte, n int) Object {
// 	_res := _bytes.SplitAfterN(s, sep, n)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range _elem1 {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_vec1 = _vec1.Conjoin(_vec2)
// 	}
// 	return _vec1
// }

GO FUNC bytes.SplitN from bytes/bytes.go:
// func __splitN(s []byte, sep []byte, n int) Object {
// 	_res := _bytes.SplitN(s, sep, n)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range _elem1 {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_vec1 = _vec1.Conjoin(_vec2)
// 	}
// 	return _vec1
// }

GO FUNC bytes.Title from bytes/bytes.go:
// func __title(s []byte) Object {
// 	_res := _bytes.Title(s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.ToLower from bytes/bytes.go:
// func __toLower(s []byte) Object {
// 	_res := _bytes.ToLower(s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.ToLowerSpecial from bytes/bytes.go:
// func __toLowerSpecial(c ABEND987(genutils.go: imports not yet supported: unicode.SpecialCase), s []byte) Object {
// 	_res := _bytes.ToLowerSpecial(c, s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.ToTitle from bytes/bytes.go:
// func __toTitle(s []byte) Object {
// 	_res := _bytes.ToTitle(s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.ToTitleSpecial from bytes/bytes.go:
// func __toTitleSpecial(c ABEND987(genutils.go: imports not yet supported: unicode.SpecialCase), s []byte) Object {
// 	_res := _bytes.ToTitleSpecial(c, s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.ToUpper from bytes/bytes.go:
// func __toUpper(s []byte) Object {
// 	_res := _bytes.ToUpper(s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.ToUpperSpecial from bytes/bytes.go:
// func __toUpperSpecial(c ABEND987(genutils.go: imports not yet supported: unicode.SpecialCase), s []byte) Object {
// 	_res := _bytes.ToUpperSpecial(c, s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.Trim from bytes/bytes.go:
// func __trim(s []byte, cutset string) Object {
// 	_res := _bytes.Trim(s, cutset)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimFunc from bytes/bytes.go:
// func __trimFunc(s []byte, f func) Object {
// 	_res := _bytes.TrimFunc(s, f)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimLeft from bytes/bytes.go:
// func __trimLeft(s []byte, cutset string) Object {
// 	_res := _bytes.TrimLeft(s, cutset)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimLeftFunc from bytes/bytes.go:
// func __trimLeftFunc(s []byte, f func) Object {
// 	_res := _bytes.TrimLeftFunc(s, f)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimPrefix from bytes/bytes.go:
// func __trimPrefix(s []byte, prefix []byte) Object {
// 	_res := _bytes.TrimPrefix(s, prefix)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimRight from bytes/bytes.go:
// func __trimRight(s []byte, cutset string) Object {
// 	_res := _bytes.TrimRight(s, cutset)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimRightFunc from bytes/bytes.go:
// func __trimRightFunc(s []byte, f func) Object {
// 	_res := _bytes.TrimRightFunc(s, f)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimSpace from bytes/bytes.go:
// func __trimSpace(s []byte) Object {
// 	_res := _bytes.TrimSpace(s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimSuffix from bytes/bytes.go:
// func __trimSuffix(s []byte, suffix []byte) Object {
// 	_res := _bytes.TrimSuffix(s, suffix)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package bytes

import (
	_bytes "bytes"
	. "github.com/candid82/joker/core"
)
GO FUNC compress/bzip2.NewReader from compress/bzip2/bzip2.go:
// func __newReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _bzip2.NewReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC compress/flate.NewReader from compress/flate/inflate.go:
// func __newReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _flate.NewReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC compress/flate.NewReaderDict from compress/flate/inflate.go:
// func __newReaderDict(r ABEND987(genutils.go: imports not yet supported: io.Reader), dict []byte) Object {
// 	_res := _flate.NewReaderDict(r, dict)
// 	return MakeGoObject(_res)
// }

GO FUNC compress/flate.NewWriter from compress/flate/deflate.go:
// func __newWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer), level int) Object {
// 	_res1, _res2 := _flate.NewWriter(w, level)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/flate.NewWriterDict from compress/flate/deflate.go:
// func __newWriterDict(w ABEND987(genutils.go: imports not yet supported: io.Writer), level int, dict []byte) Object {
// 	_res1, _res2 := _flate.NewWriterDict(w, level, dict)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/gzip.NewReader from compress/gzip/gunzip.go:
// func __newReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _gzip.NewReader(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/gzip.NewWriter from compress/gzip/gzip.go:
// func __newWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _gzip.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC compress/gzip.NewWriterLevel from compress/gzip/gzip.go:
// func __newWriterLevel(w ABEND987(genutils.go: imports not yet supported: io.Writer), level int) Object {
// 	_res1, _res2 := _gzip.NewWriterLevel(w, level)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/lzw.NewReader from compress/lzw/reader.go:
// func __newReader(r ABEND987(genutils.go: imports not yet supported: io.Reader), order _lzw.Order, litWidth int) Object {
// 	_res := _lzw.NewReader(r, order, litWidth)
// 	return MakeGoObject(_res)
// }

GO FUNC compress/lzw.NewWriter from compress/lzw/writer.go:
// func __newWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer), order _lzw.Order, litWidth int) Object {
// 	_res := _lzw.NewWriter(w, order, litWidth)
// 	return MakeGoObject(_res)
// }

GO FUNC compress/zlib.NewReader from compress/zlib/reader.go:
// func __newReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _zlib.NewReader(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/zlib.NewReaderDict from compress/zlib/reader.go:
// func __newReaderDict(r ABEND987(genutils.go: imports not yet supported: io.Reader), dict []byte) Object {
// 	_res1, _res2 := _zlib.NewReaderDict(r, dict)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/zlib.NewWriter from compress/zlib/writer.go:
// func __newWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _zlib.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC compress/zlib.NewWriterLevel from compress/zlib/writer.go:
// func __newWriterLevel(w ABEND987(genutils.go: imports not yet supported: io.Writer), level int) Object {
// 	_res1, _res2 := _zlib.NewWriterLevel(w, level)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/zlib.NewWriterLevelDict from compress/zlib/writer.go:
// func __newWriterLevelDict(w ABEND987(genutils.go: imports not yet supported: io.Writer), level int, dict []byte) Object {
// 	_res1, _res2 := _zlib.NewWriterLevelDict(w, level, dict)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC container/heap.Fix from container/heap/heap.go:
// func __fix(h _heap.Interface, i int) Object {
// 	_heap.Fix(h, i)
// 	...ABEND675: TODO...
// }

GO FUNC container/heap.Init from container/heap/heap.go:
// func __init(h _heap.Interface) Object {
// 	_heap.Init(h)
// 	...ABEND675: TODO...
// }

GO FUNC container/heap.Pop from container/heap/heap.go:
// func __pop(h _heap.Interface) Object {
// 	return _heap.Pop(h)
// }

GO FUNC container/heap.Push from container/heap/heap.go:
// func __push(h _heap.Interface, x interface {}) Object {
// 	_heap.Push(h, x)
// 	...ABEND675: TODO...
// }

GO FUNC container/heap.Remove from container/heap/heap.go:
// func __remove(h _heap.Interface, i int) Object {
// 	return _heap.Remove(h, i)
// }

GO TYPE container/list.Element from container/list/list.go:
func ExtractGoObjectElement(args []Object, index int) *_list.Element {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _list.Element:
			return &r
		case *_list.Element:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[container/list.Element]"))
}

func _mapToElement(o Map) *_list.Element {
	return &_list.Element{
	}
}

func _vectorToElement(o *Vector) *_list.Element {
	return &_list.Element{
	}
}

func _ConstructElement(_v Object) *_list.Element {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _list.Element:
			return &_g
		case *_list.Element:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToElement(_o.(Map))
	case case *Vector:
		return _vectorToElement(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[list.Element] or Map"))
}

GO TYPE container/list.List from container/list/list.go:
func ExtractGoObjectList(args []Object, index int) *_list.List {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _list.List:
			return &r
		case *_list.List:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[container/list.List]"))
}

func _mapToList(o Map) *_list.List {
	return &_list.List{
	}
}

func _vectorToList(o *Vector) *_list.List {
	return &_list.List{
	}
}

func _ConstructList(_v Object) *_list.List {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _list.List:
			return &_g
		case *_list.List:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToList(_o.(Map))
	case case *Vector:
		return _vectorToList(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[list.List] or Map"))
}

GO FUNC container/list.New from container/list/list.go:
func __new() Object {
	_res := _list.New()
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package list

import (
	_list "container/list"
	. "github.com/candid82/joker/core"
)
GO TYPE container/ring.Ring from container/ring/ring.go:
func ExtractGoObjectRing(args []Object, index int) *_ring.Ring {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ring.Ring:
			return &r
		case *_ring.Ring:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[container/ring.Ring]"))
}

func _mapToRing(o Map) *_ring.Ring {
	return &_ring.Ring{
	}
}

func _vectorToRing(o *Vector) *_ring.Ring {
	return &_ring.Ring{
	}
}

func _ConstructRing(_v Object) *_ring.Ring {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ring.Ring:
			return &_g
		case *_ring.Ring:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRing(_o.(Map))
	case case *Vector:
		return _vectorToRing(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ring.Ring] or Map"))
}

GO FUNC container/ring.New from container/ring/ring.go:
func __new(n int) Object {
	_res := _ring.New(n)
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package ring

import (
	_ring "container/ring"
	. "github.com/candid82/joker/core"
)
GO TYPE context.CancelFunc from context/context.go:
func ExtractGoObjectCancelFunc(args []Object, index int) *_context.CancelFunc {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _context.CancelFunc:
			return &r
		case *_context.CancelFunc:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[context.CancelFunc]"))
}

// func _ConstructCancelFunc(_v Object) _context.CancelFunc {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _context.CancelFunc:
// 			return _g
// 		case *_context.CancelFunc:
// 			return *_g
// 		}
// 	default:
// 		return _context.CancelFunc(_o.ABEND674(unknown underlying type *ast.FuncType for CancelFunc))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[context.CancelFunc] or whatever"))
// }

GO TYPE context.Context from context/context.go:
func ExtractGoObjectContext(args []Object, index int) *_context.Context {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _context.Context:
			return &r
		case *_context.Context:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[context.Context]"))
}

// func _ConstructContext(_v Object) _context.Context {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _context.Context:
// 			return _g
// 		case *_context.Context:
// 			return *_g
// 		}
// 	default:
// 		return _context.Context(_o.ABEND674(unknown underlying type *ast.InterfaceType for Context))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[context.Context] or whatever"))
// }

GO FUNC context.Background from context/context.go:
func __background() Object {
	_res := _context.Background()
	return MakeGoObject(_res)
}

GO FUNC context.TODO from context/context.go:
func __tODO() Object {
	_res := _context.TODO()
	return MakeGoObject(_res)
}

GO FUNC context.WithCancel from context/context.go:
func __withCancel(parent _context.Context) Object {
	ctx, cancel := _context.WithCancel(parent)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(ctx))
	_res = _res.Conjoin(MakeGoObject(cancel))
	return _res
}

GO FUNC context.WithDeadline from context/context.go:
// func __withDeadline(parent _context.Context, d ABEND987(genutils.go: imports not yet supported: time.Time)) Object {
// 	_res1, _res2 := _context.WithDeadline(parent, d)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(MakeGoObject(_res2))
// 	return _res
// }

GO FUNC context.WithTimeout from context/context.go:
// func __withTimeout(parent _context.Context, timeout ABEND987(genutils.go: imports not yet supported: time.Duration)) Object {
// 	_res1, _res2 := _context.WithTimeout(parent, timeout)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(MakeGoObject(_res2))
// 	return _res
// }

GO FUNC context.WithValue from context/context.go:
// func __withValue(parent _context.Context, key interface {}, val interface {}) Object {
// 	_res := _context.WithValue(parent, key, val)
// 	return MakeGoObject(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package context

import (
	_context "context"
	. "github.com/candid82/joker/core"
)
GO FUNC crypto.RegisterHash from crypto/crypto.go:
// func __registerHash(h _crypto.Hash, f func) Object {
// 	_crypto.RegisterHash(h, f)
// 	...ABEND675: TODO...
// }

GO FUNC crypto/aes.NewCipher from crypto/aes/cipher.go:
// func __newCipher(key []byte) Object {
// 	_res1, _res2 := _aes.NewCipher(key)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO TYPE crypto/cipher.AEAD from crypto/cipher/gcm.go:
func ExtractGoObjectAEAD(args []Object, index int) *_cipher.AEAD {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cipher.AEAD:
			return &r
		case *_cipher.AEAD:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/cipher.AEAD]"))
}

// func _ConstructAEAD(_v Object) _cipher.AEAD {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cipher.AEAD:
// 			return _g
// 		case *_cipher.AEAD:
// 			return *_g
// 		}
// 	default:
// 		return _cipher.AEAD(_o.ABEND674(unknown underlying type *ast.InterfaceType for AEAD))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cipher.AEAD] or whatever"))
// }

GO TYPE crypto/cipher.Block from crypto/cipher/cipher.go:
func ExtractGoObjectBlock(args []Object, index int) *_cipher.Block {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cipher.Block:
			return &r
		case *_cipher.Block:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/cipher.Block]"))
}

// func _ConstructBlock(_v Object) _cipher.Block {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cipher.Block:
// 			return _g
// 		case *_cipher.Block:
// 			return *_g
// 		}
// 	default:
// 		return _cipher.Block(_o.ABEND674(unknown underlying type *ast.InterfaceType for Block))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cipher.Block] or whatever"))
// }

GO TYPE crypto/cipher.BlockMode from crypto/cipher/cipher.go:
func ExtractGoObjectBlockMode(args []Object, index int) *_cipher.BlockMode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cipher.BlockMode:
			return &r
		case *_cipher.BlockMode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/cipher.BlockMode]"))
}

// func _ConstructBlockMode(_v Object) _cipher.BlockMode {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cipher.BlockMode:
// 			return _g
// 		case *_cipher.BlockMode:
// 			return *_g
// 		}
// 	default:
// 		return _cipher.BlockMode(_o.ABEND674(unknown underlying type *ast.InterfaceType for BlockMode))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cipher.BlockMode] or whatever"))
// }

GO TYPE crypto/cipher.Stream from crypto/cipher/cipher.go:
func ExtractGoObjectStream(args []Object, index int) *_cipher.Stream {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cipher.Stream:
			return &r
		case *_cipher.Stream:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/cipher.Stream]"))
}

// func _ConstructStream(_v Object) _cipher.Stream {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cipher.Stream:
// 			return _g
// 		case *_cipher.Stream:
// 			return *_g
// 		}
// 	default:
// 		return _cipher.Stream(_o.ABEND674(unknown underlying type *ast.InterfaceType for Stream))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cipher.Stream] or whatever"))
// }

GO TYPE crypto/cipher.StreamReader from crypto/cipher/io.go:
func ExtractGoObjectStreamReader(args []Object, index int) *_cipher.StreamReader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cipher.StreamReader:
			return &r
		case *_cipher.StreamReader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/cipher.StreamReader]"))
}

func _mapToStreamReader(o Map) *_cipher.StreamReader {
	return &_cipher.StreamReader{
	}
}

func _vectorToStreamReader(o *Vector) *_cipher.StreamReader {
	return &_cipher.StreamReader{
	}
}

func _ConstructStreamReader(_v Object) *_cipher.StreamReader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _cipher.StreamReader:
			return &_g
		case *_cipher.StreamReader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToStreamReader(_o.(Map))
	case case *Vector:
		return _vectorToStreamReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[cipher.StreamReader] or Map"))
}

GO TYPE crypto/cipher.StreamWriter from crypto/cipher/io.go:
func ExtractGoObjectStreamWriter(args []Object, index int) *_cipher.StreamWriter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cipher.StreamWriter:
			return &r
		case *_cipher.StreamWriter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/cipher.StreamWriter]"))
}

func _mapToStreamWriter(o Map) *_cipher.StreamWriter {
	return &_cipher.StreamWriter{
	}
}

func _vectorToStreamWriter(o *Vector) *_cipher.StreamWriter {
	return &_cipher.StreamWriter{
	}
}

func _ConstructStreamWriter(_v Object) *_cipher.StreamWriter {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _cipher.StreamWriter:
			return &_g
		case *_cipher.StreamWriter:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToStreamWriter(_o.(Map))
	case case *Vector:
		return _vectorToStreamWriter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[cipher.StreamWriter] or Map"))
}

GO FUNC crypto/cipher.NewCBCDecrypter from crypto/cipher/cbc.go:
// func __newCBCDecrypter(b _cipher.Block, iv []byte) Object {
// 	_res := _cipher.NewCBCDecrypter(b, iv)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/cipher.NewCBCEncrypter from crypto/cipher/cbc.go:
// func __newCBCEncrypter(b _cipher.Block, iv []byte) Object {
// 	_res := _cipher.NewCBCEncrypter(b, iv)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/cipher.NewCFBDecrypter from crypto/cipher/cfb.go:
// func __newCFBDecrypter(block _cipher.Block, iv []byte) Object {
// 	_res := _cipher.NewCFBDecrypter(block, iv)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/cipher.NewCFBEncrypter from crypto/cipher/cfb.go:
// func __newCFBEncrypter(block _cipher.Block, iv []byte) Object {
// 	_res := _cipher.NewCFBEncrypter(block, iv)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/cipher.NewCTR from crypto/cipher/ctr.go:
// func __newCTR(block _cipher.Block, iv []byte) Object {
// 	_res := _cipher.NewCTR(block, iv)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/cipher.NewGCM from crypto/cipher/gcm.go:
func __newGCM(cipher _cipher.Block) Object {
	_res1, _res2 := _cipher.NewGCM(cipher)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC crypto/cipher.NewGCMWithNonceSize from crypto/cipher/gcm.go:
func __newGCMWithNonceSize(cipher _cipher.Block, size int) Object {
	_res1, _res2 := _cipher.NewGCMWithNonceSize(cipher, size)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC crypto/cipher.NewGCMWithTagSize from crypto/cipher/gcm.go:
func __newGCMWithTagSize(cipher _cipher.Block, tagSize int) Object {
	_res1, _res2 := _cipher.NewGCMWithTagSize(cipher, tagSize)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC crypto/cipher.NewOFB from crypto/cipher/ofb.go:
// func __newOFB(b _cipher.Block, iv []byte) Object {
// 	_res := _cipher.NewOFB(b, iv)
// 	return MakeGoObject(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package cipher

import (
	_cipher "crypto/cipher"
	. "github.com/candid82/joker/core"
)
GO FUNC crypto/des.NewCipher from crypto/des/cipher.go:
// func __newCipher(key []byte) Object {
// 	_res1, _res2 := _des.NewCipher(key)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/des.NewTripleDESCipher from crypto/des/cipher.go:
// func __newTripleDESCipher(key []byte) Object {
// 	_res1, _res2 := _des.NewTripleDESCipher(key)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/dsa.GenerateKey from crypto/dsa/dsa.go:
// func __generateKey(priv *_dsa.PrivateKey, rand ABEND987(genutils.go: imports not yet supported: io.Reader))  {
// 	_res := _dsa.GenerateKey(priv, rand)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC crypto/dsa.GenerateParameters from crypto/dsa/dsa.go:
// func __generateParameters(params *_dsa.Parameters, rand ABEND987(genutils.go: imports not yet supported: io.Reader), sizes _dsa.ParameterSizes)  {
// 	_res := _dsa.GenerateParameters(params, rand, sizes)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC crypto/dsa.Sign from crypto/dsa/dsa.go:
// func __sign(rand ABEND987(genutils.go: imports not yet supported: io.Reader), priv *_dsa.PrivateKey, hash []byte) Object {
// 	r, s, err := _dsa.Sign(rand, priv, hash)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(r))
// 	_res = _res.Conjoin(MakeGoObject(s))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/dsa.Verify from crypto/dsa/dsa.go:
// func __verify(pub *_dsa.PublicKey, hash []byte, r *ABEND987(genutils.go: imports not yet supported: big.Int), s *ABEND987(genutils.go: imports not yet supported: big.Int))  {
// 	_res := _dsa.Verify(pub, hash, r, s)
// 	return MakeBoolean(_res)
// }

GO FUNC crypto/ecdsa.GenerateKey from crypto/ecdsa/ecdsa.go:
// func __generateKey(c ABEND987(genutils.go: imports not yet supported: elliptic.Curve), rand ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _ecdsa.GenerateKey(c, rand)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/ecdsa.Sign from crypto/ecdsa/ecdsa.go:
// func __sign(rand ABEND987(genutils.go: imports not yet supported: io.Reader), priv *_ecdsa.PrivateKey, hash []byte) Object {
// 	r, s, err := _ecdsa.Sign(rand, priv, hash)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(r))
// 	_res = _res.Conjoin(MakeGoObject(s))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/ecdsa.Verify from crypto/ecdsa/ecdsa.go:
// func __verify(pub *_ecdsa.PublicKey, hash []byte, r *ABEND987(genutils.go: imports not yet supported: big.Int), s *ABEND987(genutils.go: imports not yet supported: big.Int))  {
// 	_res := _ecdsa.Verify(pub, hash, r, s)
// 	return MakeBoolean(_res)
// }

GO TYPE crypto/elliptic.Curve from crypto/elliptic/elliptic.go:
func ExtractGoObjectCurve(args []Object, index int) *_elliptic.Curve {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elliptic.Curve:
			return &r
		case *_elliptic.Curve:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/elliptic.Curve]"))
}

// func _ConstructCurve(_v Object) _elliptic.Curve {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _elliptic.Curve:
// 			return _g
// 		case *_elliptic.Curve:
// 			return *_g
// 		}
// 	default:
// 		return _elliptic.Curve(_o.ABEND674(unknown underlying type *ast.InterfaceType for Curve))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[elliptic.Curve] or whatever"))
// }

GO TYPE crypto/elliptic.CurveParams from crypto/elliptic/elliptic.go:
func ExtractGoObjectCurveParams(args []Object, index int) *_elliptic.CurveParams {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elliptic.CurveParams:
			return &r
		case *_elliptic.CurveParams:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/elliptic.CurveParams]"))
}

func _mapToCurveParams(o Map) *_elliptic.CurveParams {
	return &_elliptic.CurveParams{
	}
}

func _vectorToCurveParams(o *Vector) *_elliptic.CurveParams {
	return &_elliptic.CurveParams{
	}
}

func _ConstructCurveParams(_v Object) *_elliptic.CurveParams {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elliptic.CurveParams:
			return &_g
		case *_elliptic.CurveParams:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCurveParams(_o.(Map))
	case case *Vector:
		return _vectorToCurveParams(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elliptic.CurveParams] or Map"))
}

GO FUNC crypto/elliptic.GenerateKey from crypto/elliptic/elliptic.go:
// func __generateKey(curve _elliptic.Curve, rand ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	priv, x, y, err := _elliptic.GenerateKey(curve, rand)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range priv {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(MakeGoObject(x))
// 	_res = _res.Conjoin(MakeGoObject(y))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/elliptic.Marshal from crypto/elliptic/elliptic.go:
// func __marshal(curve _elliptic.Curve, x *ABEND987(genutils.go: imports not yet supported: big.Int), y *ABEND987(genutils.go: imports not yet supported: big.Int)) Object {
// 	_res := _elliptic.Marshal(curve, x, y)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/elliptic.P224 from crypto/elliptic/p224.go:
func __p224() Object {
	_res := _elliptic.P224()
	return MakeGoObject(_res)
}

GO FUNC crypto/elliptic.P256 from crypto/elliptic/elliptic.go:
func __p256() Object {
	_res := _elliptic.P256()
	return MakeGoObject(_res)
}

GO FUNC crypto/elliptic.P384 from crypto/elliptic/elliptic.go:
func __p384() Object {
	_res := _elliptic.P384()
	return MakeGoObject(_res)
}

GO FUNC crypto/elliptic.P521 from crypto/elliptic/elliptic.go:
func __p521() Object {
	_res := _elliptic.P521()
	return MakeGoObject(_res)
}

GO FUNC crypto/elliptic.Unmarshal from crypto/elliptic/elliptic.go:
// func __unmarshal(curve _elliptic.Curve, data []byte) Object {
// 	x, y := _elliptic.Unmarshal(curve, data)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(x))
// 	_res = _res.Conjoin(MakeGoObject(y))
// 	return _res
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package elliptic

import (
	_elliptic "crypto/elliptic"
	. "github.com/candid82/joker/core"
)
GO FUNC crypto/hmac.Equal from crypto/hmac/hmac.go:
// func __equal(mac1 []byte, mac2 []byte)  {
// 	_res := _hmac.Equal(mac1, mac2)
// 	return MakeBoolean(_res)
// }

GO FUNC crypto/hmac.New from crypto/hmac/hmac.go:
// func __new(h func, key []byte) Object {
// 	_res := _hmac.New(h, key)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/md5.New from crypto/md5/md5.go:
func __new() Object {
	_res := _md5.New()
	return MakeGoObject(_res)
}

GO FUNC crypto/md5.Sum from crypto/md5/md5.go:
// func __sum(data []byte) Object {
// 	_res := _md5.Sum(data)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package md5

import (
	_md5 "crypto/md5"
	. "github.com/candid82/joker/core"
)
GO FUNC crypto/rand.Int from crypto/rand/util.go:
// func __int(rand ABEND987(genutils.go: imports not yet supported: io.Reader), max *ABEND987(genutils.go: imports not yet supported: big.Int)) Object {
// 	n, err := _rand.Int(rand, max)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/rand.Prime from crypto/rand/util.go:
// func __prime(rand ABEND987(genutils.go: imports not yet supported: io.Reader), bits int) Object {
// 	p, err := _rand.Prime(rand, bits)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(p))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/rand.Read from crypto/rand/rand.go:
// func __read(b []byte) Object {
// 	n, err := _rand.Read(b)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/rc4.NewCipher from crypto/rc4/rc4.go:
// func __newCipher(key []byte) Object {
// 	_res1, _res2 := _rc4.NewCipher(key)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.DecryptOAEP from crypto/rsa/rsa.go:
// func __decryptOAEP(hash ABEND987(genutils.go: imports not yet supported: hash.Hash), random ABEND987(genutils.go: imports not yet supported: io.Reader), priv *_rsa.PrivateKey, ciphertext []byte, label []byte) Object {
// 	_res1, _res2 := _rsa.DecryptOAEP(hash, random, priv, ciphertext, label)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.DecryptPKCS1v15 from crypto/rsa/pkcs1v15.go:
// func __decryptPKCS1v15(rand ABEND987(genutils.go: imports not yet supported: io.Reader), priv *_rsa.PrivateKey, ciphertext []byte) Object {
// 	_res1, _res2 := _rsa.DecryptPKCS1v15(rand, priv, ciphertext)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.DecryptPKCS1v15SessionKey from crypto/rsa/pkcs1v15.go:
// func __decryptPKCS1v15SessionKey(rand ABEND987(genutils.go: imports not yet supported: io.Reader), priv *_rsa.PrivateKey, ciphertext []byte, key []byte)  {
// 	_res := _rsa.DecryptPKCS1v15SessionKey(rand, priv, ciphertext, key)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC crypto/rsa.EncryptOAEP from crypto/rsa/rsa.go:
// func __encryptOAEP(hash ABEND987(genutils.go: imports not yet supported: hash.Hash), random ABEND987(genutils.go: imports not yet supported: io.Reader), pub *_rsa.PublicKey, msg []byte, label []byte) Object {
// 	_res1, _res2 := _rsa.EncryptOAEP(hash, random, pub, msg, label)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.EncryptPKCS1v15 from crypto/rsa/pkcs1v15.go:
// func __encryptPKCS1v15(rand ABEND987(genutils.go: imports not yet supported: io.Reader), pub *_rsa.PublicKey, msg []byte) Object {
// 	_res1, _res2 := _rsa.EncryptPKCS1v15(rand, pub, msg)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.GenerateKey from crypto/rsa/rsa.go:
// func __generateKey(random ABEND987(genutils.go: imports not yet supported: io.Reader), bits int) Object {
// 	_res1, _res2 := _rsa.GenerateKey(random, bits)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.GenerateMultiPrimeKey from crypto/rsa/rsa.go:
// func __generateMultiPrimeKey(random ABEND987(genutils.go: imports not yet supported: io.Reader), nprimes int, bits int) Object {
// 	_res1, _res2 := _rsa.GenerateMultiPrimeKey(random, nprimes, bits)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.SignPKCS1v15 from crypto/rsa/pkcs1v15.go:
// func __signPKCS1v15(rand ABEND987(genutils.go: imports not yet supported: io.Reader), priv *_rsa.PrivateKey, hash ABEND987(genutils.go: imports not yet supported: crypto.Hash), hashed []byte) Object {
// 	_res1, _res2 := _rsa.SignPKCS1v15(rand, priv, hash, hashed)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.SignPSS from crypto/rsa/pss.go:
// func __signPSS(rand ABEND987(genutils.go: imports not yet supported: io.Reader), priv *_rsa.PrivateKey, hash ABEND987(genutils.go: imports not yet supported: crypto.Hash), hashed []byte, opts *_rsa.PSSOptions) Object {
// 	_res1, _res2 := _rsa.SignPSS(rand, priv, hash, hashed, opts)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.VerifyPKCS1v15 from crypto/rsa/pkcs1v15.go:
// func __verifyPKCS1v15(pub *_rsa.PublicKey, hash ABEND987(genutils.go: imports not yet supported: crypto.Hash), hashed []byte, sig []byte)  {
// 	_res := _rsa.VerifyPKCS1v15(pub, hash, hashed, sig)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC crypto/rsa.VerifyPSS from crypto/rsa/pss.go:
// func __verifyPSS(pub *_rsa.PublicKey, hash ABEND987(genutils.go: imports not yet supported: crypto.Hash), hashed []byte, sig []byte, opts *_rsa.PSSOptions)  {
// 	_res := _rsa.VerifyPSS(pub, hash, hashed, sig, opts)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC crypto/sha1.New from crypto/sha1/sha1.go:
func __new() Object {
	_res := _sha1.New()
	return MakeGoObject(_res)
}

GO FUNC crypto/sha1.Sum from crypto/sha1/sha1.go:
// func __sum(data []byte) Object {
// 	_res := _sha1.Sum(data)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package sha1

import (
	_sha1 "crypto/sha1"
	. "github.com/candid82/joker/core"
)
GO FUNC crypto/sha256.New from crypto/sha256/sha256.go:
func __new() Object {
	_res := _sha256.New()
	return MakeGoObject(_res)
}

GO FUNC crypto/sha256.New224 from crypto/sha256/sha256.go:
func __new224() Object {
	_res := _sha256.New224()
	return MakeGoObject(_res)
}

GO FUNC crypto/sha256.Sum224 from crypto/sha256/sha256.go:
// func __sum224(data []byte) Object {
// 	_res := _sha256.Sum224(data)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/sha256.Sum256 from crypto/sha256/sha256.go:
// func __sum256(data []byte) Object {
// 	_res := _sha256.Sum256(data)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package sha256

import (
	_sha256 "crypto/sha256"
	. "github.com/candid82/joker/core"
)
GO FUNC crypto/sha512.New from crypto/sha512/sha512.go:
func __new() Object {
	_res := _sha512.New()
	return MakeGoObject(_res)
}

GO FUNC crypto/sha512.New384 from crypto/sha512/sha512.go:
func __new384() Object {
	_res := _sha512.New384()
	return MakeGoObject(_res)
}

GO FUNC crypto/sha512.New512_224 from crypto/sha512/sha512.go:
func __new512_224() Object {
	_res := _sha512.New512_224()
	return MakeGoObject(_res)
}

GO FUNC crypto/sha512.New512_256 from crypto/sha512/sha512.go:
func __new512_256() Object {
	_res := _sha512.New512_256()
	return MakeGoObject(_res)
}

GO FUNC crypto/sha512.Sum384 from crypto/sha512/sha512.go:
// func __sum384(data []byte) Object {
// 	_res := _sha512.Sum384(data)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/sha512.Sum512 from crypto/sha512/sha512.go:
// func __sum512(data []byte) Object {
// 	_res := _sha512.Sum512(data)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/sha512.Sum512_224 from crypto/sha512/sha512.go:
// func __sum512_224(data []byte) Object {
// 	_res := _sha512.Sum512_224(data)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/sha512.Sum512_256 from crypto/sha512/sha512.go:
// func __sum512_256(data []byte) Object {
// 	_res := _sha512.Sum512_256(data)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package sha512

import (
	_sha512 "crypto/sha512"
	. "github.com/candid82/joker/core"
)
GO FUNC crypto/subtle.ConstantTimeByteEq from crypto/subtle/constant_time.go:
// func __constantTimeByteEq(x uint8, y uint8)  {
// 	_res := _subtle.ConstantTimeByteEq(x, y)
// 	return MakeInt(_res)
// }

GO FUNC crypto/subtle.ConstantTimeCompare from crypto/subtle/constant_time.go:
// func __constantTimeCompare(x []byte, y []byte)  {
// 	_res := _subtle.ConstantTimeCompare(x, y)
// 	return MakeInt(_res)
// }

GO FUNC crypto/subtle.ConstantTimeCopy from crypto/subtle/constant_time.go:
// func __constantTimeCopy(v int, x []byte, y []byte) Object {
// 	_subtle.ConstantTimeCopy(v, x, y)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package subtle

import (
)
GO TYPE crypto/tls.Certificate from crypto/tls/common.go:
func ExtractGoObjectCertificate(args []Object, index int) *_tls.Certificate {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.Certificate:
			return &r
		case *_tls.Certificate:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.Certificate]"))
}

func _mapToCertificate(o Map) *_tls.Certificate {
	return &_tls.Certificate{
	}
}

func _vectorToCertificate(o *Vector) *_tls.Certificate {
	return &_tls.Certificate{
	}
}

func _ConstructCertificate(_v Object) *_tls.Certificate {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tls.Certificate:
			return &_g
		case *_tls.Certificate:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCertificate(_o.(Map))
	case case *Vector:
		return _vectorToCertificate(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.Certificate] or Map"))
}

GO TYPE crypto/tls.CertificateRequestInfo from crypto/tls/common.go:
func ExtractGoObjectCertificateRequestInfo(args []Object, index int) *_tls.CertificateRequestInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.CertificateRequestInfo:
			return &r
		case *_tls.CertificateRequestInfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.CertificateRequestInfo]"))
}

func _mapToCertificateRequestInfo(o Map) *_tls.CertificateRequestInfo {
	return &_tls.CertificateRequestInfo{
	}
}

func _vectorToCertificateRequestInfo(o *Vector) *_tls.CertificateRequestInfo {
	return &_tls.CertificateRequestInfo{
	}
}

func _ConstructCertificateRequestInfo(_v Object) *_tls.CertificateRequestInfo {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tls.CertificateRequestInfo:
			return &_g
		case *_tls.CertificateRequestInfo:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCertificateRequestInfo(_o.(Map))
	case case *Vector:
		return _vectorToCertificateRequestInfo(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.CertificateRequestInfo] or Map"))
}

GO TYPE crypto/tls.ClientAuthType from crypto/tls/common.go:
func ExtractGoObjectClientAuthType(args []Object, index int) *_tls.ClientAuthType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.ClientAuthType:
			return &r
		case *_tls.ClientAuthType:
			return r
		}
	case Int:
		v := _tls.ClientAuthType(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.ClientAuthType]"))
}

func _ConstructClientAuthType(_v Object) _tls.ClientAuthType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tls.ClientAuthType:
			return _g
		case *_tls.ClientAuthType:
			return *_g
		}
	case Number:
		return _tls.ClientAuthType(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.ClientAuthType] or Number"))
}

GO TYPE crypto/tls.ClientHelloInfo from crypto/tls/common.go:
func ExtractGoObjectClientHelloInfo(args []Object, index int) *_tls.ClientHelloInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.ClientHelloInfo:
			return &r
		case *_tls.ClientHelloInfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.ClientHelloInfo]"))
}

func _mapToClientHelloInfo(o Map) *_tls.ClientHelloInfo {
	return &_tls.ClientHelloInfo{
	}
}

func _vectorToClientHelloInfo(o *Vector) *_tls.ClientHelloInfo {
	return &_tls.ClientHelloInfo{
	}
}

func _ConstructClientHelloInfo(_v Object) *_tls.ClientHelloInfo {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tls.ClientHelloInfo:
			return &_g
		case *_tls.ClientHelloInfo:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToClientHelloInfo(_o.(Map))
	case case *Vector:
		return _vectorToClientHelloInfo(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.ClientHelloInfo] or Map"))
}

GO TYPE crypto/tls.ClientSessionCache from crypto/tls/common.go:
func ExtractGoObjectClientSessionCache(args []Object, index int) *_tls.ClientSessionCache {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.ClientSessionCache:
			return &r
		case *_tls.ClientSessionCache:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.ClientSessionCache]"))
}

// func _ConstructClientSessionCache(_v Object) _tls.ClientSessionCache {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _tls.ClientSessionCache:
// 			return _g
// 		case *_tls.ClientSessionCache:
// 			return *_g
// 		}
// 	default:
// 		return _tls.ClientSessionCache(_o.ABEND674(unknown underlying type *ast.InterfaceType for ClientSessionCache))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.ClientSessionCache] or whatever"))
// }

GO TYPE crypto/tls.ClientSessionState from crypto/tls/common.go:
func ExtractGoObjectClientSessionState(args []Object, index int) *_tls.ClientSessionState {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.ClientSessionState:
			return &r
		case *_tls.ClientSessionState:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.ClientSessionState]"))
}

func _mapToClientSessionState(o Map) *_tls.ClientSessionState {
	return &_tls.ClientSessionState{
	}
}

func _vectorToClientSessionState(o *Vector) *_tls.ClientSessionState {
	return &_tls.ClientSessionState{
	}
}

func _ConstructClientSessionState(_v Object) *_tls.ClientSessionState {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tls.ClientSessionState:
			return &_g
		case *_tls.ClientSessionState:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToClientSessionState(_o.(Map))
	case case *Vector:
		return _vectorToClientSessionState(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.ClientSessionState] or Map"))
}

GO TYPE crypto/tls.Config from crypto/tls/common.go:
func ExtractGoObjectConfig(args []Object, index int) *_tls.Config {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.Config:
			return &r
		case *_tls.Config:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.Config]"))
}

func _mapToConfig(o Map) *_tls.Config {
	return &_tls.Config{
	}
}

func _vectorToConfig(o *Vector) *_tls.Config {
	return &_tls.Config{
	}
}

func _ConstructConfig(_v Object) *_tls.Config {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tls.Config:
			return &_g
		case *_tls.Config:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToConfig(_o.(Map))
	case case *Vector:
		return _vectorToConfig(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.Config] or Map"))
}

GO TYPE crypto/tls.Conn from crypto/tls/conn.go:
func ExtractGoObjectConn(args []Object, index int) *_tls.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.Conn:
			return &r
		case *_tls.Conn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.Conn]"))
}

func _mapToConn(o Map) *_tls.Conn {
	return &_tls.Conn{
	}
}

func _vectorToConn(o *Vector) *_tls.Conn {
	return &_tls.Conn{
	}
}

func _ConstructConn(_v Object) *_tls.Conn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tls.Conn:
			return &_g
		case *_tls.Conn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToConn(_o.(Map))
	case case *Vector:
		return _vectorToConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.Conn] or Map"))
}

GO TYPE crypto/tls.ConnectionState from crypto/tls/common.go:
func ExtractGoObjectConnectionState(args []Object, index int) *_tls.ConnectionState {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.ConnectionState:
			return &r
		case *_tls.ConnectionState:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.ConnectionState]"))
}

func _mapToConnectionState(o Map) *_tls.ConnectionState {
	return &_tls.ConnectionState{
	}
}

func _vectorToConnectionState(o *Vector) *_tls.ConnectionState {
	return &_tls.ConnectionState{
	}
}

func _ConstructConnectionState(_v Object) *_tls.ConnectionState {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tls.ConnectionState:
			return &_g
		case *_tls.ConnectionState:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToConnectionState(_o.(Map))
	case case *Vector:
		return _vectorToConnectionState(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.ConnectionState] or Map"))
}

GO TYPE crypto/tls.CurveID from crypto/tls/common.go:
func ExtractGoObjectCurveID(args []Object, index int) *_tls.CurveID {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.CurveID:
			return &r
		case *_tls.CurveID:
			return r
		}
	case Int:
		v := _tls.CurveID(ExtractUInt16(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.CurveID]"))
}

// func _ConstructCurveID(_v Object) _tls.CurveID {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _tls.CurveID:
// 			return _g
// 		case *_tls.CurveID:
// 			return *_g
// 		}
// 	default:
// 		return _tls.CurveID(_o.ABEND674(unknown underlying type *ast.Ident for CurveID))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.CurveID] or whatever"))
// }

GO TYPE crypto/tls.RecordHeaderError from crypto/tls/conn.go:
func ExtractGoObjectRecordHeaderError(args []Object, index int) *_tls.RecordHeaderError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.RecordHeaderError:
			return &r
		case *_tls.RecordHeaderError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.RecordHeaderError]"))
}

func _mapToRecordHeaderError(o Map) *_tls.RecordHeaderError {
	return &_tls.RecordHeaderError{
	}
}

func _vectorToRecordHeaderError(o *Vector) *_tls.RecordHeaderError {
	return &_tls.RecordHeaderError{
	}
}

func _ConstructRecordHeaderError(_v Object) *_tls.RecordHeaderError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tls.RecordHeaderError:
			return &_g
		case *_tls.RecordHeaderError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRecordHeaderError(_o.(Map))
	case case *Vector:
		return _vectorToRecordHeaderError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.RecordHeaderError] or Map"))
}

GO TYPE crypto/tls.RenegotiationSupport from crypto/tls/common.go:
func ExtractGoObjectRenegotiationSupport(args []Object, index int) *_tls.RenegotiationSupport {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.RenegotiationSupport:
			return &r
		case *_tls.RenegotiationSupport:
			return r
		}
	case Int:
		v := _tls.RenegotiationSupport(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.RenegotiationSupport]"))
}

func _ConstructRenegotiationSupport(_v Object) _tls.RenegotiationSupport {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tls.RenegotiationSupport:
			return _g
		case *_tls.RenegotiationSupport:
			return *_g
		}
	case Number:
		return _tls.RenegotiationSupport(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.RenegotiationSupport] or Number"))
}

GO TYPE crypto/tls.SignatureScheme from crypto/tls/common.go:
func ExtractGoObjectSignatureScheme(args []Object, index int) *_tls.SignatureScheme {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.SignatureScheme:
			return &r
		case *_tls.SignatureScheme:
			return r
		}
	case Int:
		v := _tls.SignatureScheme(ExtractUInt16(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.SignatureScheme]"))
}

// func _ConstructSignatureScheme(_v Object) _tls.SignatureScheme {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _tls.SignatureScheme:
// 			return _g
// 		case *_tls.SignatureScheme:
// 			return *_g
// 		}
// 	default:
// 		return _tls.SignatureScheme(_o.ABEND674(unknown underlying type *ast.Ident for SignatureScheme))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.SignatureScheme] or whatever"))
// }

GO FUNC crypto/tls.Client from crypto/tls/tls.go:
// func __client(conn ABEND987(genutils.go: imports not yet supported: net.Conn), config *_tls.Config) Object {
// 	_res := _tls.Client(conn, config)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/tls.Dial from crypto/tls/tls.go:
func __dial(network string, addr string, config *_tls.Config) Object {
	_res1, _res2 := _tls.Dial(network, addr, config)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC crypto/tls.DialWithDialer from crypto/tls/tls.go:
// func __dialWithDialer(dialer *ABEND987(genutils.go: imports not yet supported: net.Dialer), network string, addr string, config *_tls.Config) Object {
// 	_res1, _res2 := _tls.DialWithDialer(dialer, network, addr, config)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/tls.Listen from crypto/tls/tls.go:
func __listen(network string, laddr string, config *_tls.Config) Object {
	_res1, _res2 := _tls.Listen(network, laddr, config)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC crypto/tls.LoadX509KeyPair from crypto/tls/tls.go:
func __loadX509KeyPair(certFile string, keyFile string) Object {
	_res1, _res2 := _tls.LoadX509KeyPair(certFile, keyFile)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC crypto/tls.NewLRUClientSessionCache from crypto/tls/common.go:
func __newLRUClientSessionCache(capacity int) Object {
	_res := _tls.NewLRUClientSessionCache(capacity)
	return MakeGoObject(_res)
}

GO FUNC crypto/tls.NewListener from crypto/tls/tls.go:
// func __newListener(inner ABEND987(genutils.go: imports not yet supported: net.Listener), config *_tls.Config) Object {
// 	_res := _tls.NewListener(inner, config)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/tls.Server from crypto/tls/tls.go:
// func __server(conn ABEND987(genutils.go: imports not yet supported: net.Conn), config *_tls.Config) Object {
// 	_res := _tls.Server(conn, config)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/tls.X509KeyPair from crypto/tls/tls.go:
// func __x509KeyPair(certPEMBlock []byte, keyPEMBlock []byte) Object {
// 	_res1, _res2 := _tls.X509KeyPair(certPEMBlock, keyPEMBlock)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package tls

import (
	_tls "crypto/tls"
	. "github.com/candid82/joker/core"
)
GO TYPE crypto/x509.CertPool from crypto/x509/cert_pool.go:
func ExtractGoObjectCertPool(args []Object, index int) *_x509.CertPool {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.CertPool:
			return &r
		case *_x509.CertPool:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.CertPool]"))
}

func _mapToCertPool(o Map) *_x509.CertPool {
	return &_x509.CertPool{
	}
}

func _vectorToCertPool(o *Vector) *_x509.CertPool {
	return &_x509.CertPool{
	}
}

func _ConstructCertPool(_v Object) *_x509.CertPool {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.CertPool:
			return &_g
		case *_x509.CertPool:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCertPool(_o.(Map))
	case case *Vector:
		return _vectorToCertPool(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.CertPool] or Map"))
}

GO TYPE crypto/x509.Certificate from crypto/x509/x509.go:
func ExtractGoObjectCertificate(args []Object, index int) *_x509.Certificate {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.Certificate:
			return &r
		case *_x509.Certificate:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.Certificate]"))
}

func _mapToCertificate(o Map) *_x509.Certificate {
	return &_x509.Certificate{
	}
}

func _vectorToCertificate(o *Vector) *_x509.Certificate {
	return &_x509.Certificate{
	}
}

func _ConstructCertificate(_v Object) *_x509.Certificate {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.Certificate:
			return &_g
		case *_x509.Certificate:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCertificate(_o.(Map))
	case case *Vector:
		return _vectorToCertificate(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.Certificate] or Map"))
}

GO TYPE crypto/x509.CertificateInvalidError from crypto/x509/verify.go:
func ExtractGoObjectCertificateInvalidError(args []Object, index int) *_x509.CertificateInvalidError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.CertificateInvalidError:
			return &r
		case *_x509.CertificateInvalidError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.CertificateInvalidError]"))
}

func _mapToCertificateInvalidError(o Map) *_x509.CertificateInvalidError {
	return &_x509.CertificateInvalidError{
	}
}

func _vectorToCertificateInvalidError(o *Vector) *_x509.CertificateInvalidError {
	return &_x509.CertificateInvalidError{
	}
}

func _ConstructCertificateInvalidError(_v Object) *_x509.CertificateInvalidError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.CertificateInvalidError:
			return &_g
		case *_x509.CertificateInvalidError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCertificateInvalidError(_o.(Map))
	case case *Vector:
		return _vectorToCertificateInvalidError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.CertificateInvalidError] or Map"))
}

GO TYPE crypto/x509.CertificateRequest from crypto/x509/x509.go:
func ExtractGoObjectCertificateRequest(args []Object, index int) *_x509.CertificateRequest {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.CertificateRequest:
			return &r
		case *_x509.CertificateRequest:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.CertificateRequest]"))
}

func _mapToCertificateRequest(o Map) *_x509.CertificateRequest {
	return &_x509.CertificateRequest{
	}
}

func _vectorToCertificateRequest(o *Vector) *_x509.CertificateRequest {
	return &_x509.CertificateRequest{
	}
}

func _ConstructCertificateRequest(_v Object) *_x509.CertificateRequest {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.CertificateRequest:
			return &_g
		case *_x509.CertificateRequest:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCertificateRequest(_o.(Map))
	case case *Vector:
		return _vectorToCertificateRequest(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.CertificateRequest] or Map"))
}

GO TYPE crypto/x509.ConstraintViolationError from crypto/x509/x509.go:
func ExtractGoObjectConstraintViolationError(args []Object, index int) *_x509.ConstraintViolationError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.ConstraintViolationError:
			return &r
		case *_x509.ConstraintViolationError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.ConstraintViolationError]"))
}

func _mapToConstraintViolationError(o Map) *_x509.ConstraintViolationError {
	return &_x509.ConstraintViolationError{
	}
}

func _vectorToConstraintViolationError(o *Vector) *_x509.ConstraintViolationError {
	return &_x509.ConstraintViolationError{
	}
}

func _ConstructConstraintViolationError(_v Object) *_x509.ConstraintViolationError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.ConstraintViolationError:
			return &_g
		case *_x509.ConstraintViolationError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToConstraintViolationError(_o.(Map))
	case case *Vector:
		return _vectorToConstraintViolationError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.ConstraintViolationError] or Map"))
}

GO TYPE crypto/x509.ExtKeyUsage from crypto/x509/x509.go:
func ExtractGoObjectExtKeyUsage(args []Object, index int) *_x509.ExtKeyUsage {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.ExtKeyUsage:
			return &r
		case *_x509.ExtKeyUsage:
			return r
		}
	case Int:
		v := _x509.ExtKeyUsage(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.ExtKeyUsage]"))
}

func _ConstructExtKeyUsage(_v Object) _x509.ExtKeyUsage {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.ExtKeyUsage:
			return _g
		case *_x509.ExtKeyUsage:
			return *_g
		}
	case Number:
		return _x509.ExtKeyUsage(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.ExtKeyUsage] or Number"))
}

GO TYPE crypto/x509.HostnameError from crypto/x509/verify.go:
func ExtractGoObjectHostnameError(args []Object, index int) *_x509.HostnameError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.HostnameError:
			return &r
		case *_x509.HostnameError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.HostnameError]"))
}

func _mapToHostnameError(o Map) *_x509.HostnameError {
	return &_x509.HostnameError{
	}
}

func _vectorToHostnameError(o *Vector) *_x509.HostnameError {
	return &_x509.HostnameError{
	}
}

func _ConstructHostnameError(_v Object) *_x509.HostnameError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.HostnameError:
			return &_g
		case *_x509.HostnameError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToHostnameError(_o.(Map))
	case case *Vector:
		return _vectorToHostnameError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.HostnameError] or Map"))
}

GO TYPE crypto/x509.InsecureAlgorithmError from crypto/x509/x509.go:
func ExtractGoObjectInsecureAlgorithmError(args []Object, index int) *_x509.InsecureAlgorithmError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.InsecureAlgorithmError:
			return &r
		case *_x509.InsecureAlgorithmError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.InsecureAlgorithmError]"))
}

// func _ConstructInsecureAlgorithmError(_v Object) _x509.InsecureAlgorithmError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _x509.InsecureAlgorithmError:
// 			return _g
// 		case *_x509.InsecureAlgorithmError:
// 			return *_g
// 		}
// 	default:
// 		return _x509.InsecureAlgorithmError(_o.ABEND674(unknown underlying type *ast.Ident for InsecureAlgorithmError))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.InsecureAlgorithmError] or whatever"))
// }

GO TYPE crypto/x509.InvalidReason from crypto/x509/verify.go:
func ExtractGoObjectInvalidReason(args []Object, index int) *_x509.InvalidReason {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.InvalidReason:
			return &r
		case *_x509.InvalidReason:
			return r
		}
	case Int:
		v := _x509.InvalidReason(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.InvalidReason]"))
}

func _ConstructInvalidReason(_v Object) _x509.InvalidReason {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.InvalidReason:
			return _g
		case *_x509.InvalidReason:
			return *_g
		}
	case Number:
		return _x509.InvalidReason(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.InvalidReason] or Number"))
}

GO TYPE crypto/x509.KeyUsage from crypto/x509/x509.go:
func ExtractGoObjectKeyUsage(args []Object, index int) *_x509.KeyUsage {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.KeyUsage:
			return &r
		case *_x509.KeyUsage:
			return r
		}
	case Int:
		v := _x509.KeyUsage(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.KeyUsage]"))
}

func _ConstructKeyUsage(_v Object) _x509.KeyUsage {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.KeyUsage:
			return _g
		case *_x509.KeyUsage:
			return *_g
		}
	case Number:
		return _x509.KeyUsage(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.KeyUsage] or Number"))
}

GO TYPE crypto/x509.PEMCipher from crypto/x509/pem_decrypt.go:
func ExtractGoObjectPEMCipher(args []Object, index int) *_x509.PEMCipher {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.PEMCipher:
			return &r
		case *_x509.PEMCipher:
			return r
		}
	case Int:
		v := _x509.PEMCipher(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.PEMCipher]"))
}

func _ConstructPEMCipher(_v Object) _x509.PEMCipher {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.PEMCipher:
			return _g
		case *_x509.PEMCipher:
			return *_g
		}
	case Number:
		return _x509.PEMCipher(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.PEMCipher] or Number"))
}

GO TYPE crypto/x509.PublicKeyAlgorithm from crypto/x509/x509.go:
func ExtractGoObjectPublicKeyAlgorithm(args []Object, index int) *_x509.PublicKeyAlgorithm {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.PublicKeyAlgorithm:
			return &r
		case *_x509.PublicKeyAlgorithm:
			return r
		}
	case Int:
		v := _x509.PublicKeyAlgorithm(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.PublicKeyAlgorithm]"))
}

func _ConstructPublicKeyAlgorithm(_v Object) _x509.PublicKeyAlgorithm {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.PublicKeyAlgorithm:
			return _g
		case *_x509.PublicKeyAlgorithm:
			return *_g
		}
	case Number:
		return _x509.PublicKeyAlgorithm(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.PublicKeyAlgorithm] or Number"))
}

GO TYPE crypto/x509.SignatureAlgorithm from crypto/x509/x509.go:
func ExtractGoObjectSignatureAlgorithm(args []Object, index int) *_x509.SignatureAlgorithm {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.SignatureAlgorithm:
			return &r
		case *_x509.SignatureAlgorithm:
			return r
		}
	case Int:
		v := _x509.SignatureAlgorithm(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.SignatureAlgorithm]"))
}

func _ConstructSignatureAlgorithm(_v Object) _x509.SignatureAlgorithm {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.SignatureAlgorithm:
			return _g
		case *_x509.SignatureAlgorithm:
			return *_g
		}
	case Number:
		return _x509.SignatureAlgorithm(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.SignatureAlgorithm] or Number"))
}

GO TYPE crypto/x509.SystemRootsError from crypto/x509/verify.go:
func ExtractGoObjectSystemRootsError(args []Object, index int) *_x509.SystemRootsError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.SystemRootsError:
			return &r
		case *_x509.SystemRootsError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.SystemRootsError]"))
}

func _mapToSystemRootsError(o Map) *_x509.SystemRootsError {
	return &_x509.SystemRootsError{
	}
}

func _vectorToSystemRootsError(o *Vector) *_x509.SystemRootsError {
	return &_x509.SystemRootsError{
	}
}

func _ConstructSystemRootsError(_v Object) *_x509.SystemRootsError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.SystemRootsError:
			return &_g
		case *_x509.SystemRootsError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSystemRootsError(_o.(Map))
	case case *Vector:
		return _vectorToSystemRootsError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.SystemRootsError] or Map"))
}

GO TYPE crypto/x509.UnhandledCriticalExtension from crypto/x509/x509.go:
func ExtractGoObjectUnhandledCriticalExtension(args []Object, index int) *_x509.UnhandledCriticalExtension {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.UnhandledCriticalExtension:
			return &r
		case *_x509.UnhandledCriticalExtension:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.UnhandledCriticalExtension]"))
}

func _mapToUnhandledCriticalExtension(o Map) *_x509.UnhandledCriticalExtension {
	return &_x509.UnhandledCriticalExtension{
	}
}

func _vectorToUnhandledCriticalExtension(o *Vector) *_x509.UnhandledCriticalExtension {
	return &_x509.UnhandledCriticalExtension{
	}
}

func _ConstructUnhandledCriticalExtension(_v Object) *_x509.UnhandledCriticalExtension {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.UnhandledCriticalExtension:
			return &_g
		case *_x509.UnhandledCriticalExtension:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnhandledCriticalExtension(_o.(Map))
	case case *Vector:
		return _vectorToUnhandledCriticalExtension(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.UnhandledCriticalExtension] or Map"))
}

GO TYPE crypto/x509.UnknownAuthorityError from crypto/x509/verify.go:
func ExtractGoObjectUnknownAuthorityError(args []Object, index int) *_x509.UnknownAuthorityError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.UnknownAuthorityError:
			return &r
		case *_x509.UnknownAuthorityError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.UnknownAuthorityError]"))
}

func _mapToUnknownAuthorityError(o Map) *_x509.UnknownAuthorityError {
	return &_x509.UnknownAuthorityError{
	}
}

func _vectorToUnknownAuthorityError(o *Vector) *_x509.UnknownAuthorityError {
	return &_x509.UnknownAuthorityError{
	}
}

func _ConstructUnknownAuthorityError(_v Object) *_x509.UnknownAuthorityError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.UnknownAuthorityError:
			return &_g
		case *_x509.UnknownAuthorityError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnknownAuthorityError(_o.(Map))
	case case *Vector:
		return _vectorToUnknownAuthorityError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.UnknownAuthorityError] or Map"))
}

GO TYPE crypto/x509.VerifyOptions from crypto/x509/verify.go:
func ExtractGoObjectVerifyOptions(args []Object, index int) *_x509.VerifyOptions {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.VerifyOptions:
			return &r
		case *_x509.VerifyOptions:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.VerifyOptions]"))
}

func _mapToVerifyOptions(o Map) *_x509.VerifyOptions {
	return &_x509.VerifyOptions{
	}
}

func _vectorToVerifyOptions(o *Vector) *_x509.VerifyOptions {
	return &_x509.VerifyOptions{
	}
}

func _ConstructVerifyOptions(_v Object) *_x509.VerifyOptions {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.VerifyOptions:
			return &_g
		case *_x509.VerifyOptions:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToVerifyOptions(_o.(Map))
	case case *Vector:
		return _vectorToVerifyOptions(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.VerifyOptions] or Map"))
}

GO FUNC crypto/x509.CreateCertificate from crypto/x509/x509.go:
// func __createCertificate(rand ABEND987(genutils.go: imports not yet supported: io.Reader), template *_x509.Certificate, parent *_x509.Certificate, pub interface {}, priv interface {}) Object {
// 	cert, err := _x509.CreateCertificate(rand, template, parent, pub, priv)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range cert {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/x509.CreateCertificateRequest from crypto/x509/x509.go:
// func __createCertificateRequest(rand ABEND987(genutils.go: imports not yet supported: io.Reader), template *_x509.CertificateRequest, priv interface {}) Object {
// 	csr, err := _x509.CreateCertificateRequest(rand, template, priv)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range csr {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/x509.DecryptPEMBlock from crypto/x509/pem_decrypt.go:
// func __decryptPEMBlock(b *ABEND987(genutils.go: imports not yet supported: pem.Block), password []byte) Object {
// 	_res1, _res2 := _x509.DecryptPEMBlock(b, password)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.EncryptPEMBlock from crypto/x509/pem_decrypt.go:
// func __encryptPEMBlock(rand ABEND987(genutils.go: imports not yet supported: io.Reader), blockType string, data []byte, password []byte, alg _x509.PEMCipher) Object {
// 	_res1, _res2 := _x509.EncryptPEMBlock(rand, blockType, data, password, alg)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.IsEncryptedPEMBlock from crypto/x509/pem_decrypt.go:
// func __isEncryptedPEMBlock(b *ABEND987(genutils.go: imports not yet supported: pem.Block))  {
// 	_res := _x509.IsEncryptedPEMBlock(b)
// 	return MakeBoolean(_res)
// }

GO FUNC crypto/x509.MarshalECPrivateKey from crypto/x509/sec1.go:
// func __marshalECPrivateKey(key *ABEND987(genutils.go: imports not yet supported: ecdsa.PrivateKey)) Object {
// 	_res1, _res2 := _x509.MarshalECPrivateKey(key)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.MarshalPKCS1PrivateKey from crypto/x509/pkcs1.go:
// func __marshalPKCS1PrivateKey(key *ABEND987(genutils.go: imports not yet supported: rsa.PrivateKey)) Object {
// 	_res := _x509.MarshalPKCS1PrivateKey(key)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/x509.MarshalPKCS1PublicKey from crypto/x509/pkcs1.go:
// func __marshalPKCS1PublicKey(key *ABEND987(genutils.go: imports not yet supported: rsa.PublicKey)) Object {
// 	_res := _x509.MarshalPKCS1PublicKey(key)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/x509.MarshalPKCS8PrivateKey from crypto/x509/pkcs8.go:
// func __marshalPKCS8PrivateKey(key interface {}) Object {
// 	_res1, _res2 := _x509.MarshalPKCS8PrivateKey(key)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.MarshalPKIXPublicKey from crypto/x509/x509.go:
// func __marshalPKIXPublicKey(pub interface {}) Object {
// 	_res1, _res2 := _x509.MarshalPKIXPublicKey(pub)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.NewCertPool from crypto/x509/cert_pool.go:
func __newCertPool() Object {
	_res := _x509.NewCertPool()
	return MakeGoObject(_res)
}

GO FUNC crypto/x509.ParseCRL from crypto/x509/x509.go:
// func __parseCRL(crlBytes []byte) Object {
// 	_res1, _res2 := _x509.ParseCRL(crlBytes)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParseCertificate from crypto/x509/x509.go:
// func __parseCertificate(asn1Data []byte) Object {
// 	_res1, _res2 := _x509.ParseCertificate(asn1Data)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParseCertificateRequest from crypto/x509/x509.go:
// func __parseCertificateRequest(asn1Data []byte) Object {
// 	_res1, _res2 := _x509.ParseCertificateRequest(asn1Data)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParseCertificates from crypto/x509/x509.go:
// func __parseCertificates(asn1Data []byte) Object {
// 	_res1, _res2 := _x509.ParseCertificates(asn1Data)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParseDERCRL from crypto/x509/x509.go:
// func __parseDERCRL(derBytes []byte) Object {
// 	_res1, _res2 := _x509.ParseDERCRL(derBytes)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParseECPrivateKey from crypto/x509/sec1.go:
// func __parseECPrivateKey(der []byte) Object {
// 	_res1, _res2 := _x509.ParseECPrivateKey(der)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParsePKCS1PrivateKey from crypto/x509/pkcs1.go:
// func __parsePKCS1PrivateKey(der []byte) Object {
// 	_res1, _res2 := _x509.ParsePKCS1PrivateKey(der)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParsePKCS1PublicKey from crypto/x509/pkcs1.go:
// func __parsePKCS1PublicKey(der []byte) Object {
// 	_res1, _res2 := _x509.ParsePKCS1PublicKey(der)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParsePKCS8PrivateKey from crypto/x509/pkcs8.go:
// func __parsePKCS8PrivateKey(der []byte) Object {
// 	key, err := _x509.ParsePKCS8PrivateKey(der)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(key)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParsePKIXPublicKey from crypto/x509/x509.go:
// func __parsePKIXPublicKey(derBytes []byte) Object {
// 	pub, err := _x509.ParsePKIXPublicKey(derBytes)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(pub)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/x509.SystemCertPool from crypto/x509/cert_pool.go:
func __systemCertPool() Object {
	_res1, _res2 := _x509.SystemCertPool()
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package x509

import (
	_x509 "crypto/x509"
	. "github.com/candid82/joker/core"
)
GO TYPE database/sql.ColumnType from database/sql/sql.go:
func ExtractGoObjectColumnType(args []Object, index int) *_sql.ColumnType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.ColumnType:
			return &r
		case *_sql.ColumnType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.ColumnType]"))
}

func _mapToColumnType(o Map) *_sql.ColumnType {
	return &_sql.ColumnType{
	}
}

func _vectorToColumnType(o *Vector) *_sql.ColumnType {
	return &_sql.ColumnType{
	}
}

func _ConstructColumnType(_v Object) *_sql.ColumnType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.ColumnType:
			return &_g
		case *_sql.ColumnType:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToColumnType(_o.(Map))
	case case *Vector:
		return _vectorToColumnType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.ColumnType] or Map"))
}

GO TYPE database/sql.Conn from database/sql/sql.go:
func ExtractGoObjectConn(args []Object, index int) *_sql.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.Conn:
			return &r
		case *_sql.Conn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.Conn]"))
}

func _mapToConn(o Map) *_sql.Conn {
	return &_sql.Conn{
	}
}

func _vectorToConn(o *Vector) *_sql.Conn {
	return &_sql.Conn{
	}
}

func _ConstructConn(_v Object) *_sql.Conn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.Conn:
			return &_g
		case *_sql.Conn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToConn(_o.(Map))
	case case *Vector:
		return _vectorToConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.Conn] or Map"))
}

GO TYPE database/sql.DB from database/sql/sql.go:
func ExtractGoObjectDB(args []Object, index int) *_sql.DB {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.DB:
			return &r
		case *_sql.DB:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.DB]"))
}

func _mapToDB(o Map) *_sql.DB {
	return &_sql.DB{
	}
}

func _vectorToDB(o *Vector) *_sql.DB {
	return &_sql.DB{
	}
}

func _ConstructDB(_v Object) *_sql.DB {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.DB:
			return &_g
		case *_sql.DB:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDB(_o.(Map))
	case case *Vector:
		return _vectorToDB(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.DB] or Map"))
}

GO TYPE database/sql.DBStats from database/sql/sql.go:
func ExtractGoObjectDBStats(args []Object, index int) *_sql.DBStats {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.DBStats:
			return &r
		case *_sql.DBStats:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.DBStats]"))
}

func _mapToDBStats(o Map) *_sql.DBStats {
	return &_sql.DBStats{
	}
}

func _vectorToDBStats(o *Vector) *_sql.DBStats {
	return &_sql.DBStats{
	}
}

func _ConstructDBStats(_v Object) *_sql.DBStats {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.DBStats:
			return &_g
		case *_sql.DBStats:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDBStats(_o.(Map))
	case case *Vector:
		return _vectorToDBStats(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.DBStats] or Map"))
}

GO TYPE database/sql.IsolationLevel from database/sql/sql.go:
func ExtractGoObjectIsolationLevel(args []Object, index int) *_sql.IsolationLevel {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.IsolationLevel:
			return &r
		case *_sql.IsolationLevel:
			return r
		}
	case Int:
		v := _sql.IsolationLevel(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.IsolationLevel]"))
}

func _ConstructIsolationLevel(_v Object) _sql.IsolationLevel {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.IsolationLevel:
			return _g
		case *_sql.IsolationLevel:
			return *_g
		}
	case Number:
		return _sql.IsolationLevel(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.IsolationLevel] or Number"))
}

GO TYPE database/sql.NamedArg from database/sql/sql.go:
func ExtractGoObjectNamedArg(args []Object, index int) *_sql.NamedArg {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.NamedArg:
			return &r
		case *_sql.NamedArg:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.NamedArg]"))
}

func _mapToNamedArg(o Map) *_sql.NamedArg {
	return &_sql.NamedArg{
	}
}

func _vectorToNamedArg(o *Vector) *_sql.NamedArg {
	return &_sql.NamedArg{
	}
}

func _ConstructNamedArg(_v Object) *_sql.NamedArg {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.NamedArg:
			return &_g
		case *_sql.NamedArg:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNamedArg(_o.(Map))
	case case *Vector:
		return _vectorToNamedArg(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.NamedArg] or Map"))
}

GO TYPE database/sql.NullBool from database/sql/sql.go:
func ExtractGoObjectNullBool(args []Object, index int) *_sql.NullBool {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.NullBool:
			return &r
		case *_sql.NullBool:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.NullBool]"))
}

func _mapToNullBool(o Map) *_sql.NullBool {
	return &_sql.NullBool{
	}
}

func _vectorToNullBool(o *Vector) *_sql.NullBool {
	return &_sql.NullBool{
	}
}

func _ConstructNullBool(_v Object) *_sql.NullBool {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.NullBool:
			return &_g
		case *_sql.NullBool:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNullBool(_o.(Map))
	case case *Vector:
		return _vectorToNullBool(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.NullBool] or Map"))
}

GO TYPE database/sql.NullFloat64 from database/sql/sql.go:
func ExtractGoObjectNullFloat64(args []Object, index int) *_sql.NullFloat64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.NullFloat64:
			return &r
		case *_sql.NullFloat64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.NullFloat64]"))
}

func _mapToNullFloat64(o Map) *_sql.NullFloat64 {
	return &_sql.NullFloat64{
	}
}

func _vectorToNullFloat64(o *Vector) *_sql.NullFloat64 {
	return &_sql.NullFloat64{
	}
}

func _ConstructNullFloat64(_v Object) *_sql.NullFloat64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.NullFloat64:
			return &_g
		case *_sql.NullFloat64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNullFloat64(_o.(Map))
	case case *Vector:
		return _vectorToNullFloat64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.NullFloat64] or Map"))
}

GO TYPE database/sql.NullInt64 from database/sql/sql.go:
func ExtractGoObjectNullInt64(args []Object, index int) *_sql.NullInt64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.NullInt64:
			return &r
		case *_sql.NullInt64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.NullInt64]"))
}

func _mapToNullInt64(o Map) *_sql.NullInt64 {
	return &_sql.NullInt64{
	}
}

func _vectorToNullInt64(o *Vector) *_sql.NullInt64 {
	return &_sql.NullInt64{
	}
}

func _ConstructNullInt64(_v Object) *_sql.NullInt64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.NullInt64:
			return &_g
		case *_sql.NullInt64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNullInt64(_o.(Map))
	case case *Vector:
		return _vectorToNullInt64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.NullInt64] or Map"))
}

GO TYPE database/sql.NullString from database/sql/sql.go:
func ExtractGoObjectNullString(args []Object, index int) *_sql.NullString {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.NullString:
			return &r
		case *_sql.NullString:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.NullString]"))
}

func _mapToNullString(o Map) *_sql.NullString {
	return &_sql.NullString{
	}
}

func _vectorToNullString(o *Vector) *_sql.NullString {
	return &_sql.NullString{
	}
}

func _ConstructNullString(_v Object) *_sql.NullString {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.NullString:
			return &_g
		case *_sql.NullString:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNullString(_o.(Map))
	case case *Vector:
		return _vectorToNullString(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.NullString] or Map"))
}

GO TYPE database/sql.Out from database/sql/sql.go:
func ExtractGoObjectOut(args []Object, index int) *_sql.Out {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.Out:
			return &r
		case *_sql.Out:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.Out]"))
}

func _mapToOut(o Map) *_sql.Out {
	return &_sql.Out{
	}
}

func _vectorToOut(o *Vector) *_sql.Out {
	return &_sql.Out{
	}
}

func _ConstructOut(_v Object) *_sql.Out {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.Out:
			return &_g
		case *_sql.Out:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToOut(_o.(Map))
	case case *Vector:
		return _vectorToOut(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.Out] or Map"))
}

GO TYPE database/sql.RawBytes from database/sql/sql.go:
func ExtractGoObjectRawBytes(args []Object, index int) *_sql.RawBytes {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.RawBytes:
			return &r
		case *_sql.RawBytes:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.RawBytes]"))
}

// func _ConstructRawBytes(_v Object) _sql.RawBytes {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _sql.RawBytes:
// 			return _g
// 		case *_sql.RawBytes:
// 			return *_g
// 		}
// 	default:
// 		return _sql.RawBytes(_o.ABEND674(unknown underlying type *ast.ArrayType for RawBytes))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.RawBytes] or whatever"))
// }

GO TYPE database/sql.Result from database/sql/sql.go:
func ExtractGoObjectResult(args []Object, index int) *_sql.Result {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.Result:
			return &r
		case *_sql.Result:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.Result]"))
}

// func _ConstructResult(_v Object) _sql.Result {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _sql.Result:
// 			return _g
// 		case *_sql.Result:
// 			return *_g
// 		}
// 	default:
// 		return _sql.Result(_o.ABEND674(unknown underlying type *ast.InterfaceType for Result))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.Result] or whatever"))
// }

GO TYPE database/sql.Row from database/sql/sql.go:
func ExtractGoObjectRow(args []Object, index int) *_sql.Row {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.Row:
			return &r
		case *_sql.Row:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.Row]"))
}

func _mapToRow(o Map) *_sql.Row {
	return &_sql.Row{
	}
}

func _vectorToRow(o *Vector) *_sql.Row {
	return &_sql.Row{
	}
}

func _ConstructRow(_v Object) *_sql.Row {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.Row:
			return &_g
		case *_sql.Row:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRow(_o.(Map))
	case case *Vector:
		return _vectorToRow(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.Row] or Map"))
}

GO TYPE database/sql.Rows from database/sql/sql.go:
func ExtractGoObjectRows(args []Object, index int) *_sql.Rows {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.Rows:
			return &r
		case *_sql.Rows:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.Rows]"))
}

func _mapToRows(o Map) *_sql.Rows {
	return &_sql.Rows{
	}
}

func _vectorToRows(o *Vector) *_sql.Rows {
	return &_sql.Rows{
	}
}

func _ConstructRows(_v Object) *_sql.Rows {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.Rows:
			return &_g
		case *_sql.Rows:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRows(_o.(Map))
	case case *Vector:
		return _vectorToRows(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.Rows] or Map"))
}

GO TYPE database/sql.Scanner from database/sql/sql.go:
func ExtractGoObjectScanner(args []Object, index int) *_sql.Scanner {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.Scanner:
			return &r
		case *_sql.Scanner:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.Scanner]"))
}

// func _ConstructScanner(_v Object) _sql.Scanner {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _sql.Scanner:
// 			return _g
// 		case *_sql.Scanner:
// 			return *_g
// 		}
// 	default:
// 		return _sql.Scanner(_o.ABEND674(unknown underlying type *ast.InterfaceType for Scanner))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.Scanner] or whatever"))
// }

GO TYPE database/sql.Stmt from database/sql/sql.go:
func ExtractGoObjectStmt(args []Object, index int) *_sql.Stmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.Stmt:
			return &r
		case *_sql.Stmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.Stmt]"))
}

func _mapToStmt(o Map) *_sql.Stmt {
	return &_sql.Stmt{
	}
}

func _vectorToStmt(o *Vector) *_sql.Stmt {
	return &_sql.Stmt{
	}
}

func _ConstructStmt(_v Object) *_sql.Stmt {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.Stmt:
			return &_g
		case *_sql.Stmt:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToStmt(_o.(Map))
	case case *Vector:
		return _vectorToStmt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.Stmt] or Map"))
}

GO TYPE database/sql.Tx from database/sql/sql.go:
func ExtractGoObjectTx(args []Object, index int) *_sql.Tx {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.Tx:
			return &r
		case *_sql.Tx:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.Tx]"))
}

func _mapToTx(o Map) *_sql.Tx {
	return &_sql.Tx{
	}
}

func _vectorToTx(o *Vector) *_sql.Tx {
	return &_sql.Tx{
	}
}

func _ConstructTx(_v Object) *_sql.Tx {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.Tx:
			return &_g
		case *_sql.Tx:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTx(_o.(Map))
	case case *Vector:
		return _vectorToTx(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.Tx] or Map"))
}

GO TYPE database/sql.TxOptions from database/sql/sql.go:
func ExtractGoObjectTxOptions(args []Object, index int) *_sql.TxOptions {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.TxOptions:
			return &r
		case *_sql.TxOptions:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.TxOptions]"))
}

func _mapToTxOptions(o Map) *_sql.TxOptions {
	return &_sql.TxOptions{
	}
}

func _vectorToTxOptions(o *Vector) *_sql.TxOptions {
	return &_sql.TxOptions{
	}
}

func _ConstructTxOptions(_v Object) *_sql.TxOptions {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.TxOptions:
			return &_g
		case *_sql.TxOptions:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTxOptions(_o.(Map))
	case case *Vector:
		return _vectorToTxOptions(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.TxOptions] or Map"))
}

GO FUNC database/sql.Drivers from database/sql/sql.go:
func __drivers() Object {
	_res := _sql.Drivers()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC database/sql.Named from database/sql/sql.go:
// func __named(name string, value interface {}) Object {
// 	_res := _sql.Named(name, value)
// 	return MakeGoObject(_res)
// }

GO FUNC database/sql.Open from database/sql/sql.go:
func __open(driverName string, dataSourceName string) Object {
	_res1, _res2 := _sql.Open(driverName, dataSourceName)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC database/sql.OpenDB from database/sql/sql.go:
// func __openDB(c ABEND987(genutils.go: imports not yet supported: driver.Connector)) Object {
// 	_res := _sql.OpenDB(c)
// 	return MakeGoObject(_res)
// }

GO FUNC database/sql.Register from database/sql/sql.go:
// func __register(name string, driver ABEND987(genutils.go: imports not yet supported: driver.Driver)) Object {
// 	_sql.Register(name, driver)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package sql

import (
	_sql "database/sql"
	. "github.com/candid82/joker/core"
)
GO FUNC database/sql/driver.IsScanValue from database/sql/driver/types.go:
// func __isScanValue(v interface {})  {
// 	_res := _driver.IsScanValue(v)
// 	return MakeBoolean(_res)
// }

GO FUNC database/sql/driver.IsValue from database/sql/driver/types.go:
// func __isValue(v interface {})  {
// 	_res := _driver.IsValue(v)
// 	return MakeBoolean(_res)
// }

GO FUNC debug/dwarf.New from debug/dwarf/open.go:
// func __new(abbrev []byte, aranges []byte, frame []byte, info []byte, line []byte, pubnames []byte, ranges []byte, str []byte) Object {
// 	_res1, _res2 := _dwarf.New(abbrev, aranges, frame, info, line, pubnames, ranges, str)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO TYPE debug/elf.Chdr32 from debug/elf/elf.go:
func ExtractGoObjectChdr32(args []Object, index int) *_elf.Chdr32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Chdr32:
			return &r
		case *_elf.Chdr32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Chdr32]"))
}

func _mapToChdr32(o Map) *_elf.Chdr32 {
	return &_elf.Chdr32{
	}
}

func _vectorToChdr32(o *Vector) *_elf.Chdr32 {
	return &_elf.Chdr32{
	}
}

func _ConstructChdr32(_v Object) *_elf.Chdr32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Chdr32:
			return &_g
		case *_elf.Chdr32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToChdr32(_o.(Map))
	case case *Vector:
		return _vectorToChdr32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Chdr32] or Map"))
}

GO TYPE debug/elf.Chdr64 from debug/elf/elf.go:
func ExtractGoObjectChdr64(args []Object, index int) *_elf.Chdr64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Chdr64:
			return &r
		case *_elf.Chdr64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Chdr64]"))
}

func _mapToChdr64(o Map) *_elf.Chdr64 {
	return &_elf.Chdr64{
	}
}

func _vectorToChdr64(o *Vector) *_elf.Chdr64 {
	return &_elf.Chdr64{
	}
}

func _ConstructChdr64(_v Object) *_elf.Chdr64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Chdr64:
			return &_g
		case *_elf.Chdr64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToChdr64(_o.(Map))
	case case *Vector:
		return _vectorToChdr64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Chdr64] or Map"))
}

GO TYPE debug/elf.Class from debug/elf/elf.go:
func ExtractGoObjectClass(args []Object, index int) *_elf.Class {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Class:
			return &r
		case *_elf.Class:
			return r
		}
	case Int:
		v := _elf.Class(ExtractByte(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Class]"))
}

func _ConstructClass(_v Object) _elf.Class {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Class:
			return _g
		case *_elf.Class:
			return *_g
		}
	case Number:
		return _elf.Class(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Class] or Number"))
}

GO TYPE debug/elf.CompressionType from debug/elf/elf.go:
func ExtractGoObjectCompressionType(args []Object, index int) *_elf.CompressionType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.CompressionType:
			return &r
		case *_elf.CompressionType:
			return r
		}
	case Int:
		v := _elf.CompressionType(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.CompressionType]"))
}

func _ConstructCompressionType(_v Object) _elf.CompressionType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.CompressionType:
			return _g
		case *_elf.CompressionType:
			return *_g
		}
	case Number:
		return _elf.CompressionType(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.CompressionType] or Number"))
}

GO TYPE debug/elf.Data from debug/elf/elf.go:
func ExtractGoObjectData(args []Object, index int) *_elf.Data {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Data:
			return &r
		case *_elf.Data:
			return r
		}
	case Int:
		v := _elf.Data(ExtractByte(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Data]"))
}

func _ConstructData(_v Object) _elf.Data {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Data:
			return _g
		case *_elf.Data:
			return *_g
		}
	case Number:
		return _elf.Data(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Data] or Number"))
}

GO TYPE debug/elf.Dyn32 from debug/elf/elf.go:
func ExtractGoObjectDyn32(args []Object, index int) *_elf.Dyn32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Dyn32:
			return &r
		case *_elf.Dyn32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Dyn32]"))
}

func _mapToDyn32(o Map) *_elf.Dyn32 {
	return &_elf.Dyn32{
	}
}

func _vectorToDyn32(o *Vector) *_elf.Dyn32 {
	return &_elf.Dyn32{
	}
}

func _ConstructDyn32(_v Object) *_elf.Dyn32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Dyn32:
			return &_g
		case *_elf.Dyn32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDyn32(_o.(Map))
	case case *Vector:
		return _vectorToDyn32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Dyn32] or Map"))
}

GO TYPE debug/elf.Dyn64 from debug/elf/elf.go:
func ExtractGoObjectDyn64(args []Object, index int) *_elf.Dyn64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Dyn64:
			return &r
		case *_elf.Dyn64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Dyn64]"))
}

func _mapToDyn64(o Map) *_elf.Dyn64 {
	return &_elf.Dyn64{
	}
}

func _vectorToDyn64(o *Vector) *_elf.Dyn64 {
	return &_elf.Dyn64{
	}
}

func _ConstructDyn64(_v Object) *_elf.Dyn64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Dyn64:
			return &_g
		case *_elf.Dyn64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDyn64(_o.(Map))
	case case *Vector:
		return _vectorToDyn64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Dyn64] or Map"))
}

GO TYPE debug/elf.DynFlag from debug/elf/elf.go:
func ExtractGoObjectDynFlag(args []Object, index int) *_elf.DynFlag {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.DynFlag:
			return &r
		case *_elf.DynFlag:
			return r
		}
	case Int:
		v := _elf.DynFlag(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.DynFlag]"))
}

func _ConstructDynFlag(_v Object) _elf.DynFlag {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.DynFlag:
			return _g
		case *_elf.DynFlag:
			return *_g
		}
	case Number:
		return _elf.DynFlag(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.DynFlag] or Number"))
}

GO TYPE debug/elf.DynTag from debug/elf/elf.go:
func ExtractGoObjectDynTag(args []Object, index int) *_elf.DynTag {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.DynTag:
			return &r
		case *_elf.DynTag:
			return r
		}
	case Int:
		v := _elf.DynTag(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.DynTag]"))
}

func _ConstructDynTag(_v Object) _elf.DynTag {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.DynTag:
			return _g
		case *_elf.DynTag:
			return *_g
		}
	case Number:
		return _elf.DynTag(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.DynTag] or Number"))
}

GO TYPE debug/elf.File from debug/elf/file.go:
func ExtractGoObjectFile(args []Object, index int) *_elf.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.File:
			return &r
		case *_elf.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.File]"))
}

func _mapToFile(o Map) *_elf.File {
	return &_elf.File{
	}
}

func _vectorToFile(o *Vector) *_elf.File {
	return &_elf.File{
	}
}

func _ConstructFile(_v Object) *_elf.File {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.File:
			return &_g
		case *_elf.File:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFile(_o.(Map))
	case case *Vector:
		return _vectorToFile(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.File] or Map"))
}

GO TYPE debug/elf.FileHeader from debug/elf/file.go:
func ExtractGoObjectFileHeader(args []Object, index int) *_elf.FileHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.FileHeader:
			return &r
		case *_elf.FileHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.FileHeader]"))
}

func _mapToFileHeader(o Map) *_elf.FileHeader {
	return &_elf.FileHeader{
	}
}

func _vectorToFileHeader(o *Vector) *_elf.FileHeader {
	return &_elf.FileHeader{
	}
}

func _ConstructFileHeader(_v Object) *_elf.FileHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.FileHeader:
			return &_g
		case *_elf.FileHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFileHeader(_o.(Map))
	case case *Vector:
		return _vectorToFileHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.FileHeader] or Map"))
}

GO TYPE debug/elf.FormatError from debug/elf/file.go:
func ExtractGoObjectFormatError(args []Object, index int) *_elf.FormatError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.FormatError:
			return &r
		case *_elf.FormatError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.FormatError]"))
}

func _mapToFormatError(o Map) *_elf.FormatError {
	return &_elf.FormatError{
	}
}

func _vectorToFormatError(o *Vector) *_elf.FormatError {
	return &_elf.FormatError{
	}
}

func _ConstructFormatError(_v Object) *_elf.FormatError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.FormatError:
			return &_g
		case *_elf.FormatError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFormatError(_o.(Map))
	case case *Vector:
		return _vectorToFormatError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.FormatError] or Map"))
}

GO TYPE debug/elf.Header32 from debug/elf/elf.go:
func ExtractGoObjectHeader32(args []Object, index int) *_elf.Header32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Header32:
			return &r
		case *_elf.Header32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Header32]"))
}

func _mapToHeader32(o Map) *_elf.Header32 {
	return &_elf.Header32{
	}
}

func _vectorToHeader32(o *Vector) *_elf.Header32 {
	return &_elf.Header32{
	}
}

func _ConstructHeader32(_v Object) *_elf.Header32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Header32:
			return &_g
		case *_elf.Header32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToHeader32(_o.(Map))
	case case *Vector:
		return _vectorToHeader32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Header32] or Map"))
}

GO TYPE debug/elf.Header64 from debug/elf/elf.go:
func ExtractGoObjectHeader64(args []Object, index int) *_elf.Header64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Header64:
			return &r
		case *_elf.Header64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Header64]"))
}

func _mapToHeader64(o Map) *_elf.Header64 {
	return &_elf.Header64{
	}
}

func _vectorToHeader64(o *Vector) *_elf.Header64 {
	return &_elf.Header64{
	}
}

func _ConstructHeader64(_v Object) *_elf.Header64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Header64:
			return &_g
		case *_elf.Header64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToHeader64(_o.(Map))
	case case *Vector:
		return _vectorToHeader64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Header64] or Map"))
}

GO TYPE debug/elf.ImportedSymbol from debug/elf/file.go:
func ExtractGoObjectImportedSymbol(args []Object, index int) *_elf.ImportedSymbol {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.ImportedSymbol:
			return &r
		case *_elf.ImportedSymbol:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.ImportedSymbol]"))
}

func _mapToImportedSymbol(o Map) *_elf.ImportedSymbol {
	return &_elf.ImportedSymbol{
	}
}

func _vectorToImportedSymbol(o *Vector) *_elf.ImportedSymbol {
	return &_elf.ImportedSymbol{
	}
}

func _ConstructImportedSymbol(_v Object) *_elf.ImportedSymbol {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.ImportedSymbol:
			return &_g
		case *_elf.ImportedSymbol:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToImportedSymbol(_o.(Map))
	case case *Vector:
		return _vectorToImportedSymbol(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.ImportedSymbol] or Map"))
}

GO TYPE debug/elf.Machine from debug/elf/elf.go:
func ExtractGoObjectMachine(args []Object, index int) *_elf.Machine {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Machine:
			return &r
		case *_elf.Machine:
			return r
		}
	case Int:
		v := _elf.Machine(ExtractUInt16(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Machine]"))
}

// func _ConstructMachine(_v Object) _elf.Machine {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _elf.Machine:
// 			return _g
// 		case *_elf.Machine:
// 			return *_g
// 		}
// 	default:
// 		return _elf.Machine(_o.ABEND674(unknown underlying type *ast.Ident for Machine))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Machine] or whatever"))
// }

GO TYPE debug/elf.NType from debug/elf/elf.go:
func ExtractGoObjectNType(args []Object, index int) *_elf.NType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.NType:
			return &r
		case *_elf.NType:
			return r
		}
	case Int:
		v := _elf.NType(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.NType]"))
}

func _ConstructNType(_v Object) _elf.NType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.NType:
			return _g
		case *_elf.NType:
			return *_g
		}
	case Number:
		return _elf.NType(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.NType] or Number"))
}

GO TYPE debug/elf.OSABI from debug/elf/elf.go:
func ExtractGoObjectOSABI(args []Object, index int) *_elf.OSABI {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.OSABI:
			return &r
		case *_elf.OSABI:
			return r
		}
	case Int:
		v := _elf.OSABI(ExtractByte(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.OSABI]"))
}

func _ConstructOSABI(_v Object) _elf.OSABI {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.OSABI:
			return _g
		case *_elf.OSABI:
			return *_g
		}
	case Number:
		return _elf.OSABI(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.OSABI] or Number"))
}

GO TYPE debug/elf.Prog from debug/elf/file.go:
func ExtractGoObjectProg(args []Object, index int) *_elf.Prog {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Prog:
			return &r
		case *_elf.Prog:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Prog]"))
}

func _mapToProg(o Map) *_elf.Prog {
	return &_elf.Prog{
	}
}

func _vectorToProg(o *Vector) *_elf.Prog {
	return &_elf.Prog{
	}
}

func _ConstructProg(_v Object) *_elf.Prog {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Prog:
			return &_g
		case *_elf.Prog:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProg(_o.(Map))
	case case *Vector:
		return _vectorToProg(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Prog] or Map"))
}

GO TYPE debug/elf.Prog32 from debug/elf/elf.go:
func ExtractGoObjectProg32(args []Object, index int) *_elf.Prog32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Prog32:
			return &r
		case *_elf.Prog32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Prog32]"))
}

func _mapToProg32(o Map) *_elf.Prog32 {
	return &_elf.Prog32{
	}
}

func _vectorToProg32(o *Vector) *_elf.Prog32 {
	return &_elf.Prog32{
	}
}

func _ConstructProg32(_v Object) *_elf.Prog32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Prog32:
			return &_g
		case *_elf.Prog32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProg32(_o.(Map))
	case case *Vector:
		return _vectorToProg32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Prog32] or Map"))
}

GO TYPE debug/elf.Prog64 from debug/elf/elf.go:
func ExtractGoObjectProg64(args []Object, index int) *_elf.Prog64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Prog64:
			return &r
		case *_elf.Prog64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Prog64]"))
}

func _mapToProg64(o Map) *_elf.Prog64 {
	return &_elf.Prog64{
	}
}

func _vectorToProg64(o *Vector) *_elf.Prog64 {
	return &_elf.Prog64{
	}
}

func _ConstructProg64(_v Object) *_elf.Prog64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Prog64:
			return &_g
		case *_elf.Prog64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProg64(_o.(Map))
	case case *Vector:
		return _vectorToProg64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Prog64] or Map"))
}

GO TYPE debug/elf.ProgFlag from debug/elf/elf.go:
func ExtractGoObjectProgFlag(args []Object, index int) *_elf.ProgFlag {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.ProgFlag:
			return &r
		case *_elf.ProgFlag:
			return r
		}
	case Number:
		v := _elf.ProgFlag(ExtractUInt32(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.ProgFlag]"))
}

func _ConstructProgFlag(_v Object) _elf.ProgFlag {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.ProgFlag:
			return _g
		case *_elf.ProgFlag:
			return *_g
		}
	case Number:
		return _elf.ProgFlag(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.ProgFlag] or Number"))
}

GO TYPE debug/elf.ProgHeader from debug/elf/file.go:
func ExtractGoObjectProgHeader(args []Object, index int) *_elf.ProgHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.ProgHeader:
			return &r
		case *_elf.ProgHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.ProgHeader]"))
}

func _mapToProgHeader(o Map) *_elf.ProgHeader {
	return &_elf.ProgHeader{
	}
}

func _vectorToProgHeader(o *Vector) *_elf.ProgHeader {
	return &_elf.ProgHeader{
	}
}

func _ConstructProgHeader(_v Object) *_elf.ProgHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.ProgHeader:
			return &_g
		case *_elf.ProgHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProgHeader(_o.(Map))
	case case *Vector:
		return _vectorToProgHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.ProgHeader] or Map"))
}

GO TYPE debug/elf.ProgType from debug/elf/elf.go:
func ExtractGoObjectProgType(args []Object, index int) *_elf.ProgType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.ProgType:
			return &r
		case *_elf.ProgType:
			return r
		}
	case Int:
		v := _elf.ProgType(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.ProgType]"))
}

func _ConstructProgType(_v Object) _elf.ProgType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.ProgType:
			return _g
		case *_elf.ProgType:
			return *_g
		}
	case Number:
		return _elf.ProgType(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.ProgType] or Number"))
}

GO TYPE debug/elf.R_386 from debug/elf/elf.go:
func ExtractGoObjectR_386(args []Object, index int) *_elf.R_386 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_386:
			return &r
		case *_elf.R_386:
			return r
		}
	case Int:
		v := _elf.R_386(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_386]"))
}

func _ConstructR_386(_v Object) _elf.R_386 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_386:
			return _g
		case *_elf.R_386:
			return *_g
		}
	case Number:
		return _elf.R_386(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_386] or Number"))
}

GO TYPE debug/elf.R_390 from debug/elf/elf.go:
func ExtractGoObjectR_390(args []Object, index int) *_elf.R_390 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_390:
			return &r
		case *_elf.R_390:
			return r
		}
	case Int:
		v := _elf.R_390(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_390]"))
}

func _ConstructR_390(_v Object) _elf.R_390 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_390:
			return _g
		case *_elf.R_390:
			return *_g
		}
	case Number:
		return _elf.R_390(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_390] or Number"))
}

GO TYPE debug/elf.R_AARCH64 from debug/elf/elf.go:
func ExtractGoObjectR_AARCH64(args []Object, index int) *_elf.R_AARCH64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_AARCH64:
			return &r
		case *_elf.R_AARCH64:
			return r
		}
	case Int:
		v := _elf.R_AARCH64(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_AARCH64]"))
}

func _ConstructR_AARCH64(_v Object) _elf.R_AARCH64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_AARCH64:
			return _g
		case *_elf.R_AARCH64:
			return *_g
		}
	case Number:
		return _elf.R_AARCH64(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_AARCH64] or Number"))
}

GO TYPE debug/elf.R_ALPHA from debug/elf/elf.go:
func ExtractGoObjectR_ALPHA(args []Object, index int) *_elf.R_ALPHA {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_ALPHA:
			return &r
		case *_elf.R_ALPHA:
			return r
		}
	case Int:
		v := _elf.R_ALPHA(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_ALPHA]"))
}

func _ConstructR_ALPHA(_v Object) _elf.R_ALPHA {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_ALPHA:
			return _g
		case *_elf.R_ALPHA:
			return *_g
		}
	case Number:
		return _elf.R_ALPHA(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_ALPHA] or Number"))
}

GO TYPE debug/elf.R_ARM from debug/elf/elf.go:
func ExtractGoObjectR_ARM(args []Object, index int) *_elf.R_ARM {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_ARM:
			return &r
		case *_elf.R_ARM:
			return r
		}
	case Int:
		v := _elf.R_ARM(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_ARM]"))
}

func _ConstructR_ARM(_v Object) _elf.R_ARM {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_ARM:
			return _g
		case *_elf.R_ARM:
			return *_g
		}
	case Number:
		return _elf.R_ARM(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_ARM] or Number"))
}

GO TYPE debug/elf.R_MIPS from debug/elf/elf.go:
func ExtractGoObjectR_MIPS(args []Object, index int) *_elf.R_MIPS {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_MIPS:
			return &r
		case *_elf.R_MIPS:
			return r
		}
	case Int:
		v := _elf.R_MIPS(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_MIPS]"))
}

func _ConstructR_MIPS(_v Object) _elf.R_MIPS {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_MIPS:
			return _g
		case *_elf.R_MIPS:
			return *_g
		}
	case Number:
		return _elf.R_MIPS(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_MIPS] or Number"))
}

GO TYPE debug/elf.R_PPC from debug/elf/elf.go:
func ExtractGoObjectR_PPC(args []Object, index int) *_elf.R_PPC {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_PPC:
			return &r
		case *_elf.R_PPC:
			return r
		}
	case Int:
		v := _elf.R_PPC(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_PPC]"))
}

func _ConstructR_PPC(_v Object) _elf.R_PPC {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_PPC:
			return _g
		case *_elf.R_PPC:
			return *_g
		}
	case Number:
		return _elf.R_PPC(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_PPC] or Number"))
}

GO TYPE debug/elf.R_PPC64 from debug/elf/elf.go:
func ExtractGoObjectR_PPC64(args []Object, index int) *_elf.R_PPC64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_PPC64:
			return &r
		case *_elf.R_PPC64:
			return r
		}
	case Int:
		v := _elf.R_PPC64(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_PPC64]"))
}

func _ConstructR_PPC64(_v Object) _elf.R_PPC64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_PPC64:
			return _g
		case *_elf.R_PPC64:
			return *_g
		}
	case Number:
		return _elf.R_PPC64(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_PPC64] or Number"))
}

GO TYPE debug/elf.R_RISCV from debug/elf/elf.go:
func ExtractGoObjectR_RISCV(args []Object, index int) *_elf.R_RISCV {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_RISCV:
			return &r
		case *_elf.R_RISCV:
			return r
		}
	case Int:
		v := _elf.R_RISCV(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_RISCV]"))
}

func _ConstructR_RISCV(_v Object) _elf.R_RISCV {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_RISCV:
			return _g
		case *_elf.R_RISCV:
			return *_g
		}
	case Number:
		return _elf.R_RISCV(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_RISCV] or Number"))
}

GO TYPE debug/elf.R_SPARC from debug/elf/elf.go:
func ExtractGoObjectR_SPARC(args []Object, index int) *_elf.R_SPARC {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_SPARC:
			return &r
		case *_elf.R_SPARC:
			return r
		}
	case Int:
		v := _elf.R_SPARC(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_SPARC]"))
}

func _ConstructR_SPARC(_v Object) _elf.R_SPARC {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_SPARC:
			return _g
		case *_elf.R_SPARC:
			return *_g
		}
	case Number:
		return _elf.R_SPARC(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_SPARC] or Number"))
}

GO TYPE debug/elf.R_X86_64 from debug/elf/elf.go:
func ExtractGoObjectR_X86_64(args []Object, index int) *_elf.R_X86_64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_X86_64:
			return &r
		case *_elf.R_X86_64:
			return r
		}
	case Int:
		v := _elf.R_X86_64(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_X86_64]"))
}

func _ConstructR_X86_64(_v Object) _elf.R_X86_64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_X86_64:
			return _g
		case *_elf.R_X86_64:
			return *_g
		}
	case Number:
		return _elf.R_X86_64(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_X86_64] or Number"))
}

GO TYPE debug/elf.Rel32 from debug/elf/elf.go:
func ExtractGoObjectRel32(args []Object, index int) *_elf.Rel32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Rel32:
			return &r
		case *_elf.Rel32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Rel32]"))
}

func _mapToRel32(o Map) *_elf.Rel32 {
	return &_elf.Rel32{
	}
}

func _vectorToRel32(o *Vector) *_elf.Rel32 {
	return &_elf.Rel32{
	}
}

func _ConstructRel32(_v Object) *_elf.Rel32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Rel32:
			return &_g
		case *_elf.Rel32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRel32(_o.(Map))
	case case *Vector:
		return _vectorToRel32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Rel32] or Map"))
}

GO TYPE debug/elf.Rel64 from debug/elf/elf.go:
func ExtractGoObjectRel64(args []Object, index int) *_elf.Rel64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Rel64:
			return &r
		case *_elf.Rel64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Rel64]"))
}

func _mapToRel64(o Map) *_elf.Rel64 {
	return &_elf.Rel64{
	}
}

func _vectorToRel64(o *Vector) *_elf.Rel64 {
	return &_elf.Rel64{
	}
}

func _ConstructRel64(_v Object) *_elf.Rel64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Rel64:
			return &_g
		case *_elf.Rel64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRel64(_o.(Map))
	case case *Vector:
		return _vectorToRel64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Rel64] or Map"))
}

GO TYPE debug/elf.Rela32 from debug/elf/elf.go:
func ExtractGoObjectRela32(args []Object, index int) *_elf.Rela32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Rela32:
			return &r
		case *_elf.Rela32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Rela32]"))
}

func _mapToRela32(o Map) *_elf.Rela32 {
	return &_elf.Rela32{
	}
}

func _vectorToRela32(o *Vector) *_elf.Rela32 {
	return &_elf.Rela32{
	}
}

func _ConstructRela32(_v Object) *_elf.Rela32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Rela32:
			return &_g
		case *_elf.Rela32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRela32(_o.(Map))
	case case *Vector:
		return _vectorToRela32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Rela32] or Map"))
}

GO TYPE debug/elf.Rela64 from debug/elf/elf.go:
func ExtractGoObjectRela64(args []Object, index int) *_elf.Rela64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Rela64:
			return &r
		case *_elf.Rela64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Rela64]"))
}

func _mapToRela64(o Map) *_elf.Rela64 {
	return &_elf.Rela64{
	}
}

func _vectorToRela64(o *Vector) *_elf.Rela64 {
	return &_elf.Rela64{
	}
}

func _ConstructRela64(_v Object) *_elf.Rela64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Rela64:
			return &_g
		case *_elf.Rela64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRela64(_o.(Map))
	case case *Vector:
		return _vectorToRela64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Rela64] or Map"))
}

GO TYPE debug/elf.Section from debug/elf/file.go:
func ExtractGoObjectSection(args []Object, index int) *_elf.Section {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Section:
			return &r
		case *_elf.Section:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Section]"))
}

func _mapToSection(o Map) *_elf.Section {
	return &_elf.Section{
	}
}

func _vectorToSection(o *Vector) *_elf.Section {
	return &_elf.Section{
	}
}

func _ConstructSection(_v Object) *_elf.Section {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Section:
			return &_g
		case *_elf.Section:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSection(_o.(Map))
	case case *Vector:
		return _vectorToSection(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Section] or Map"))
}

GO TYPE debug/elf.Section32 from debug/elf/elf.go:
func ExtractGoObjectSection32(args []Object, index int) *_elf.Section32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Section32:
			return &r
		case *_elf.Section32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Section32]"))
}

func _mapToSection32(o Map) *_elf.Section32 {
	return &_elf.Section32{
	}
}

func _vectorToSection32(o *Vector) *_elf.Section32 {
	return &_elf.Section32{
	}
}

func _ConstructSection32(_v Object) *_elf.Section32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Section32:
			return &_g
		case *_elf.Section32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSection32(_o.(Map))
	case case *Vector:
		return _vectorToSection32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Section32] or Map"))
}

GO TYPE debug/elf.Section64 from debug/elf/elf.go:
func ExtractGoObjectSection64(args []Object, index int) *_elf.Section64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Section64:
			return &r
		case *_elf.Section64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Section64]"))
}

func _mapToSection64(o Map) *_elf.Section64 {
	return &_elf.Section64{
	}
}

func _vectorToSection64(o *Vector) *_elf.Section64 {
	return &_elf.Section64{
	}
}

func _ConstructSection64(_v Object) *_elf.Section64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Section64:
			return &_g
		case *_elf.Section64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSection64(_o.(Map))
	case case *Vector:
		return _vectorToSection64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Section64] or Map"))
}

GO TYPE debug/elf.SectionFlag from debug/elf/elf.go:
func ExtractGoObjectSectionFlag(args []Object, index int) *_elf.SectionFlag {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.SectionFlag:
			return &r
		case *_elf.SectionFlag:
			return r
		}
	case Number:
		v := _elf.SectionFlag(ExtractUInt32(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.SectionFlag]"))
}

func _ConstructSectionFlag(_v Object) _elf.SectionFlag {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.SectionFlag:
			return _g
		case *_elf.SectionFlag:
			return *_g
		}
	case Number:
		return _elf.SectionFlag(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.SectionFlag] or Number"))
}

GO TYPE debug/elf.SectionHeader from debug/elf/file.go:
func ExtractGoObjectSectionHeader(args []Object, index int) *_elf.SectionHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.SectionHeader:
			return &r
		case *_elf.SectionHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.SectionHeader]"))
}

func _mapToSectionHeader(o Map) *_elf.SectionHeader {
	return &_elf.SectionHeader{
	}
}

func _vectorToSectionHeader(o *Vector) *_elf.SectionHeader {
	return &_elf.SectionHeader{
	}
}

func _ConstructSectionHeader(_v Object) *_elf.SectionHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.SectionHeader:
			return &_g
		case *_elf.SectionHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSectionHeader(_o.(Map))
	case case *Vector:
		return _vectorToSectionHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.SectionHeader] or Map"))
}

GO TYPE debug/elf.SectionIndex from debug/elf/elf.go:
func ExtractGoObjectSectionIndex(args []Object, index int) *_elf.SectionIndex {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.SectionIndex:
			return &r
		case *_elf.SectionIndex:
			return r
		}
	case Int:
		v := _elf.SectionIndex(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.SectionIndex]"))
}

func _ConstructSectionIndex(_v Object) _elf.SectionIndex {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.SectionIndex:
			return _g
		case *_elf.SectionIndex:
			return *_g
		}
	case Number:
		return _elf.SectionIndex(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.SectionIndex] or Number"))
}

GO TYPE debug/elf.SectionType from debug/elf/elf.go:
func ExtractGoObjectSectionType(args []Object, index int) *_elf.SectionType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.SectionType:
			return &r
		case *_elf.SectionType:
			return r
		}
	case Number:
		v := _elf.SectionType(ExtractUInt32(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.SectionType]"))
}

func _ConstructSectionType(_v Object) _elf.SectionType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.SectionType:
			return _g
		case *_elf.SectionType:
			return *_g
		}
	case Number:
		return _elf.SectionType(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.SectionType] or Number"))
}

GO TYPE debug/elf.Sym32 from debug/elf/elf.go:
func ExtractGoObjectSym32(args []Object, index int) *_elf.Sym32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Sym32:
			return &r
		case *_elf.Sym32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Sym32]"))
}

func _mapToSym32(o Map) *_elf.Sym32 {
	return &_elf.Sym32{
	}
}

func _vectorToSym32(o *Vector) *_elf.Sym32 {
	return &_elf.Sym32{
	}
}

func _ConstructSym32(_v Object) *_elf.Sym32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Sym32:
			return &_g
		case *_elf.Sym32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSym32(_o.(Map))
	case case *Vector:
		return _vectorToSym32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Sym32] or Map"))
}

GO TYPE debug/elf.Sym64 from debug/elf/elf.go:
func ExtractGoObjectSym64(args []Object, index int) *_elf.Sym64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Sym64:
			return &r
		case *_elf.Sym64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Sym64]"))
}

func _mapToSym64(o Map) *_elf.Sym64 {
	return &_elf.Sym64{
	}
}

func _vectorToSym64(o *Vector) *_elf.Sym64 {
	return &_elf.Sym64{
	}
}

func _ConstructSym64(_v Object) *_elf.Sym64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Sym64:
			return &_g
		case *_elf.Sym64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSym64(_o.(Map))
	case case *Vector:
		return _vectorToSym64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Sym64] or Map"))
}

GO TYPE debug/elf.SymBind from debug/elf/elf.go:
func ExtractGoObjectSymBind(args []Object, index int) *_elf.SymBind {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.SymBind:
			return &r
		case *_elf.SymBind:
			return r
		}
	case Int:
		v := _elf.SymBind(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.SymBind]"))
}

func _ConstructSymBind(_v Object) _elf.SymBind {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.SymBind:
			return _g
		case *_elf.SymBind:
			return *_g
		}
	case Number:
		return _elf.SymBind(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.SymBind] or Number"))
}

GO TYPE debug/elf.SymType from debug/elf/elf.go:
func ExtractGoObjectSymType(args []Object, index int) *_elf.SymType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.SymType:
			return &r
		case *_elf.SymType:
			return r
		}
	case Int:
		v := _elf.SymType(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.SymType]"))
}

func _ConstructSymType(_v Object) _elf.SymType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.SymType:
			return _g
		case *_elf.SymType:
			return *_g
		}
	case Number:
		return _elf.SymType(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.SymType] or Number"))
}

GO TYPE debug/elf.SymVis from debug/elf/elf.go:
func ExtractGoObjectSymVis(args []Object, index int) *_elf.SymVis {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.SymVis:
			return &r
		case *_elf.SymVis:
			return r
		}
	case Int:
		v := _elf.SymVis(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.SymVis]"))
}

func _ConstructSymVis(_v Object) _elf.SymVis {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.SymVis:
			return _g
		case *_elf.SymVis:
			return *_g
		}
	case Number:
		return _elf.SymVis(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.SymVis] or Number"))
}

GO TYPE debug/elf.Symbol from debug/elf/file.go:
func ExtractGoObjectSymbol(args []Object, index int) *_elf.Symbol {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Symbol:
			return &r
		case *_elf.Symbol:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Symbol]"))
}

func _mapToSymbol(o Map) *_elf.Symbol {
	return &_elf.Symbol{
	}
}

func _vectorToSymbol(o *Vector) *_elf.Symbol {
	return &_elf.Symbol{
	}
}

func _ConstructSymbol(_v Object) *_elf.Symbol {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Symbol:
			return &_g
		case *_elf.Symbol:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSymbol(_o.(Map))
	case case *Vector:
		return _vectorToSymbol(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Symbol] or Map"))
}

GO TYPE debug/elf.Type from debug/elf/elf.go:
func ExtractGoObjectType(args []Object, index int) *_elf.Type {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Type:
			return &r
		case *_elf.Type:
			return r
		}
	case Int:
		v := _elf.Type(ExtractUInt16(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Type]"))
}

// func _ConstructType(_v Object) _elf.Type {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _elf.Type:
// 			return _g
// 		case *_elf.Type:
// 			return *_g
// 		}
// 	default:
// 		return _elf.Type(_o.ABEND674(unknown underlying type *ast.Ident for Type))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Type] or whatever"))
// }

GO TYPE debug/elf.Version from debug/elf/elf.go:
func ExtractGoObjectVersion(args []Object, index int) *_elf.Version {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Version:
			return &r
		case *_elf.Version:
			return r
		}
	case Int:
		v := _elf.Version(ExtractByte(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Version]"))
}

func _ConstructVersion(_v Object) _elf.Version {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Version:
			return _g
		case *_elf.Version:
			return *_g
		}
	case Number:
		return _elf.Version(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Version] or Number"))
}

GO FUNC debug/elf.NewFile from debug/elf/file.go:
// func __newFile(r ABEND987(genutils.go: imports not yet supported: io.ReaderAt)) Object {
// 	_res1, _res2 := _elf.NewFile(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/elf.Open from debug/elf/file.go:
func __open(name string) Object {
	_res1, _res2 := _elf.Open(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/elf.R_INFO from debug/elf/elf.go:
func __r_INFO(sym uint32, typ uint32) Object {
	_res := _elf.R_INFO(sym, typ)
	return MakeBigInt(uint64(_res))
}

GO FUNC debug/elf.R_INFO32 from debug/elf/elf.go:
func __r_INFO32(sym uint32, typ uint32) Object {
	_res := _elf.R_INFO32(sym, typ)
	return MakeInt(int(_res))
}

GO FUNC debug/elf.R_SYM32 from debug/elf/elf.go:
func __r_SYM32(info uint32) Object {
	_res := _elf.R_SYM32(info)
	return MakeInt(int(_res))
}

GO FUNC debug/elf.R_SYM64 from debug/elf/elf.go:
// func __r_SYM64(info uint64) Object {
// 	_res := _elf.R_SYM64(info)
// 	return MakeInt(int(_res))
// }

GO FUNC debug/elf.R_TYPE32 from debug/elf/elf.go:
func __r_TYPE32(info uint32) Object {
	_res := _elf.R_TYPE32(info)
	return MakeInt(int(_res))
}

GO FUNC debug/elf.R_TYPE64 from debug/elf/elf.go:
// func __r_TYPE64(info uint64) Object {
// 	_res := _elf.R_TYPE64(info)
// 	return MakeInt(int(_res))
// }

GO FUNC debug/elf.ST_BIND from debug/elf/elf.go:
// func __sT_BIND(info uint8) Object {
// 	_res := _elf.ST_BIND(info)
// 	return MakeGoObject(_res)
// }

GO FUNC debug/elf.ST_INFO from debug/elf/elf.go:
// func __sT_INFO(bind _elf.SymBind, typ _elf.SymType) Object {
// 	return _elf.ST_INFO(bind, typ)
// }

GO FUNC debug/elf.ST_TYPE from debug/elf/elf.go:
// func __sT_TYPE(info uint8) Object {
// 	_res := _elf.ST_TYPE(info)
// 	return MakeGoObject(_res)
// }

GO FUNC debug/elf.ST_VISIBILITY from debug/elf/elf.go:
// func __sT_VISIBILITY(other uint8) Object {
// 	_res := _elf.ST_VISIBILITY(other)
// 	return MakeGoObject(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package elf

import (
	_elf "debug/elf"
	. "github.com/candid82/joker/core"
)
GO FUNC debug/gosym.NewLineTable from debug/gosym/pclntab.go:
// func __newLineTable(data []byte, text uint64) Object {
// 	_res := _gosym.NewLineTable(data, text)
// 	return MakeGoObject(_res)
// }

GO FUNC debug/gosym.NewTable from debug/gosym/symtab.go:
// func __newTable(symtab []byte, pcln *_gosym.LineTable) Object {
// 	_res1, _res2 := _gosym.NewTable(symtab, pcln)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO TYPE debug/macho.Cpu from debug/macho/macho.go:
func ExtractGoObjectCpu(args []Object, index int) *_macho.Cpu {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Cpu:
			return &r
		case *_macho.Cpu:
			return r
		}
	case Number:
		v := _macho.Cpu(ExtractUInt32(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Cpu]"))
}

func _ConstructCpu(_v Object) _macho.Cpu {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Cpu:
			return _g
		case *_macho.Cpu:
			return *_g
		}
	case Number:
		return _macho.Cpu(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Cpu] or Number"))
}

GO TYPE debug/macho.Dylib from debug/macho/file.go:
func ExtractGoObjectDylib(args []Object, index int) *_macho.Dylib {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Dylib:
			return &r
		case *_macho.Dylib:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Dylib]"))
}

func _mapToDylib(o Map) *_macho.Dylib {
	return &_macho.Dylib{
	}
}

func _vectorToDylib(o *Vector) *_macho.Dylib {
	return &_macho.Dylib{
	}
}

func _ConstructDylib(_v Object) *_macho.Dylib {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Dylib:
			return &_g
		case *_macho.Dylib:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDylib(_o.(Map))
	case case *Vector:
		return _vectorToDylib(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Dylib] or Map"))
}

GO TYPE debug/macho.DylibCmd from debug/macho/macho.go:
func ExtractGoObjectDylibCmd(args []Object, index int) *_macho.DylibCmd {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.DylibCmd:
			return &r
		case *_macho.DylibCmd:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.DylibCmd]"))
}

func _mapToDylibCmd(o Map) *_macho.DylibCmd {
	return &_macho.DylibCmd{
	}
}

func _vectorToDylibCmd(o *Vector) *_macho.DylibCmd {
	return &_macho.DylibCmd{
	}
}

func _ConstructDylibCmd(_v Object) *_macho.DylibCmd {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.DylibCmd:
			return &_g
		case *_macho.DylibCmd:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDylibCmd(_o.(Map))
	case case *Vector:
		return _vectorToDylibCmd(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.DylibCmd] or Map"))
}

GO TYPE debug/macho.Dysymtab from debug/macho/file.go:
func ExtractGoObjectDysymtab(args []Object, index int) *_macho.Dysymtab {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Dysymtab:
			return &r
		case *_macho.Dysymtab:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Dysymtab]"))
}

func _mapToDysymtab(o Map) *_macho.Dysymtab {
	return &_macho.Dysymtab{
	}
}

func _vectorToDysymtab(o *Vector) *_macho.Dysymtab {
	return &_macho.Dysymtab{
	}
}

func _ConstructDysymtab(_v Object) *_macho.Dysymtab {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Dysymtab:
			return &_g
		case *_macho.Dysymtab:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDysymtab(_o.(Map))
	case case *Vector:
		return _vectorToDysymtab(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Dysymtab] or Map"))
}

GO TYPE debug/macho.DysymtabCmd from debug/macho/macho.go:
func ExtractGoObjectDysymtabCmd(args []Object, index int) *_macho.DysymtabCmd {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.DysymtabCmd:
			return &r
		case *_macho.DysymtabCmd:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.DysymtabCmd]"))
}

func _mapToDysymtabCmd(o Map) *_macho.DysymtabCmd {
	return &_macho.DysymtabCmd{
	}
}

func _vectorToDysymtabCmd(o *Vector) *_macho.DysymtabCmd {
	return &_macho.DysymtabCmd{
	}
}

func _ConstructDysymtabCmd(_v Object) *_macho.DysymtabCmd {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.DysymtabCmd:
			return &_g
		case *_macho.DysymtabCmd:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDysymtabCmd(_o.(Map))
	case case *Vector:
		return _vectorToDysymtabCmd(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.DysymtabCmd] or Map"))
}

GO TYPE debug/macho.FatArch from debug/macho/fat.go:
func ExtractGoObjectFatArch(args []Object, index int) *_macho.FatArch {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.FatArch:
			return &r
		case *_macho.FatArch:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.FatArch]"))
}

func _mapToFatArch(o Map) *_macho.FatArch {
	return &_macho.FatArch{
	}
}

func _vectorToFatArch(o *Vector) *_macho.FatArch {
	return &_macho.FatArch{
	}
}

func _ConstructFatArch(_v Object) *_macho.FatArch {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.FatArch:
			return &_g
		case *_macho.FatArch:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFatArch(_o.(Map))
	case case *Vector:
		return _vectorToFatArch(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.FatArch] or Map"))
}

GO TYPE debug/macho.FatArchHeader from debug/macho/fat.go:
func ExtractGoObjectFatArchHeader(args []Object, index int) *_macho.FatArchHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.FatArchHeader:
			return &r
		case *_macho.FatArchHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.FatArchHeader]"))
}

func _mapToFatArchHeader(o Map) *_macho.FatArchHeader {
	return &_macho.FatArchHeader{
	}
}

func _vectorToFatArchHeader(o *Vector) *_macho.FatArchHeader {
	return &_macho.FatArchHeader{
	}
}

func _ConstructFatArchHeader(_v Object) *_macho.FatArchHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.FatArchHeader:
			return &_g
		case *_macho.FatArchHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFatArchHeader(_o.(Map))
	case case *Vector:
		return _vectorToFatArchHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.FatArchHeader] or Map"))
}

GO TYPE debug/macho.FatFile from debug/macho/fat.go:
func ExtractGoObjectFatFile(args []Object, index int) *_macho.FatFile {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.FatFile:
			return &r
		case *_macho.FatFile:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.FatFile]"))
}

func _mapToFatFile(o Map) *_macho.FatFile {
	return &_macho.FatFile{
	}
}

func _vectorToFatFile(o *Vector) *_macho.FatFile {
	return &_macho.FatFile{
	}
}

func _ConstructFatFile(_v Object) *_macho.FatFile {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.FatFile:
			return &_g
		case *_macho.FatFile:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFatFile(_o.(Map))
	case case *Vector:
		return _vectorToFatFile(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.FatFile] or Map"))
}

GO TYPE debug/macho.File from debug/macho/file.go:
func ExtractGoObjectFile(args []Object, index int) *_macho.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.File:
			return &r
		case *_macho.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.File]"))
}

func _mapToFile(o Map) *_macho.File {
	return &_macho.File{
	}
}

func _vectorToFile(o *Vector) *_macho.File {
	return &_macho.File{
	}
}

func _ConstructFile(_v Object) *_macho.File {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.File:
			return &_g
		case *_macho.File:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFile(_o.(Map))
	case case *Vector:
		return _vectorToFile(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.File] or Map"))
}

GO TYPE debug/macho.FileHeader from debug/macho/macho.go:
func ExtractGoObjectFileHeader(args []Object, index int) *_macho.FileHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.FileHeader:
			return &r
		case *_macho.FileHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.FileHeader]"))
}

func _mapToFileHeader(o Map) *_macho.FileHeader {
	return &_macho.FileHeader{
	}
}

func _vectorToFileHeader(o *Vector) *_macho.FileHeader {
	return &_macho.FileHeader{
	}
}

func _ConstructFileHeader(_v Object) *_macho.FileHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.FileHeader:
			return &_g
		case *_macho.FileHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFileHeader(_o.(Map))
	case case *Vector:
		return _vectorToFileHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.FileHeader] or Map"))
}

GO TYPE debug/macho.FormatError from debug/macho/file.go:
func ExtractGoObjectFormatError(args []Object, index int) *_macho.FormatError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.FormatError:
			return &r
		case *_macho.FormatError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.FormatError]"))
}

func _mapToFormatError(o Map) *_macho.FormatError {
	return &_macho.FormatError{
	}
}

func _vectorToFormatError(o *Vector) *_macho.FormatError {
	return &_macho.FormatError{
	}
}

func _ConstructFormatError(_v Object) *_macho.FormatError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.FormatError:
			return &_g
		case *_macho.FormatError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFormatError(_o.(Map))
	case case *Vector:
		return _vectorToFormatError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.FormatError] or Map"))
}

GO TYPE debug/macho.Load from debug/macho/file.go:
func ExtractGoObjectLoad(args []Object, index int) *_macho.Load {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Load:
			return &r
		case *_macho.Load:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Load]"))
}

// func _ConstructLoad(_v Object) _macho.Load {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _macho.Load:
// 			return _g
// 		case *_macho.Load:
// 			return *_g
// 		}
// 	default:
// 		return _macho.Load(_o.ABEND674(unknown underlying type *ast.InterfaceType for Load))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Load] or whatever"))
// }

GO TYPE debug/macho.LoadBytes from debug/macho/file.go:
func ExtractGoObjectLoadBytes(args []Object, index int) *_macho.LoadBytes {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.LoadBytes:
			return &r
		case *_macho.LoadBytes:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.LoadBytes]"))
}

// func _ConstructLoadBytes(_v Object) _macho.LoadBytes {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _macho.LoadBytes:
// 			return _g
// 		case *_macho.LoadBytes:
// 			return *_g
// 		}
// 	default:
// 		return _macho.LoadBytes(_o.ABEND674(unknown underlying type *ast.ArrayType for LoadBytes))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.LoadBytes] or whatever"))
// }

GO TYPE debug/macho.LoadCmd from debug/macho/macho.go:
func ExtractGoObjectLoadCmd(args []Object, index int) *_macho.LoadCmd {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.LoadCmd:
			return &r
		case *_macho.LoadCmd:
			return r
		}
	case Number:
		v := _macho.LoadCmd(ExtractUInt32(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.LoadCmd]"))
}

func _ConstructLoadCmd(_v Object) _macho.LoadCmd {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.LoadCmd:
			return _g
		case *_macho.LoadCmd:
			return *_g
		}
	case Number:
		return _macho.LoadCmd(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.LoadCmd] or Number"))
}

GO TYPE debug/macho.Nlist32 from debug/macho/macho.go:
func ExtractGoObjectNlist32(args []Object, index int) *_macho.Nlist32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Nlist32:
			return &r
		case *_macho.Nlist32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Nlist32]"))
}

func _mapToNlist32(o Map) *_macho.Nlist32 {
	return &_macho.Nlist32{
	}
}

func _vectorToNlist32(o *Vector) *_macho.Nlist32 {
	return &_macho.Nlist32{
	}
}

func _ConstructNlist32(_v Object) *_macho.Nlist32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Nlist32:
			return &_g
		case *_macho.Nlist32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNlist32(_o.(Map))
	case case *Vector:
		return _vectorToNlist32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Nlist32] or Map"))
}

GO TYPE debug/macho.Nlist64 from debug/macho/macho.go:
func ExtractGoObjectNlist64(args []Object, index int) *_macho.Nlist64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Nlist64:
			return &r
		case *_macho.Nlist64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Nlist64]"))
}

func _mapToNlist64(o Map) *_macho.Nlist64 {
	return &_macho.Nlist64{
	}
}

func _vectorToNlist64(o *Vector) *_macho.Nlist64 {
	return &_macho.Nlist64{
	}
}

func _ConstructNlist64(_v Object) *_macho.Nlist64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Nlist64:
			return &_g
		case *_macho.Nlist64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNlist64(_o.(Map))
	case case *Vector:
		return _vectorToNlist64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Nlist64] or Map"))
}

GO TYPE debug/macho.Regs386 from debug/macho/macho.go:
func ExtractGoObjectRegs386(args []Object, index int) *_macho.Regs386 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Regs386:
			return &r
		case *_macho.Regs386:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Regs386]"))
}

func _mapToRegs386(o Map) *_macho.Regs386 {
	return &_macho.Regs386{
	}
}

func _vectorToRegs386(o *Vector) *_macho.Regs386 {
	return &_macho.Regs386{
	}
}

func _ConstructRegs386(_v Object) *_macho.Regs386 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Regs386:
			return &_g
		case *_macho.Regs386:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRegs386(_o.(Map))
	case case *Vector:
		return _vectorToRegs386(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Regs386] or Map"))
}

GO TYPE debug/macho.RegsAMD64 from debug/macho/macho.go:
func ExtractGoObjectRegsAMD64(args []Object, index int) *_macho.RegsAMD64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.RegsAMD64:
			return &r
		case *_macho.RegsAMD64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.RegsAMD64]"))
}

func _mapToRegsAMD64(o Map) *_macho.RegsAMD64 {
	return &_macho.RegsAMD64{
	}
}

func _vectorToRegsAMD64(o *Vector) *_macho.RegsAMD64 {
	return &_macho.RegsAMD64{
	}
}

func _ConstructRegsAMD64(_v Object) *_macho.RegsAMD64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.RegsAMD64:
			return &_g
		case *_macho.RegsAMD64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRegsAMD64(_o.(Map))
	case case *Vector:
		return _vectorToRegsAMD64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.RegsAMD64] or Map"))
}

GO TYPE debug/macho.Reloc from debug/macho/file.go:
func ExtractGoObjectReloc(args []Object, index int) *_macho.Reloc {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Reloc:
			return &r
		case *_macho.Reloc:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Reloc]"))
}

func _mapToReloc(o Map) *_macho.Reloc {
	return &_macho.Reloc{
	}
}

func _vectorToReloc(o *Vector) *_macho.Reloc {
	return &_macho.Reloc{
	}
}

func _ConstructReloc(_v Object) *_macho.Reloc {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Reloc:
			return &_g
		case *_macho.Reloc:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReloc(_o.(Map))
	case case *Vector:
		return _vectorToReloc(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Reloc] or Map"))
}

GO TYPE debug/macho.RelocTypeARM from debug/macho/reloctype.go:
func ExtractGoObjectRelocTypeARM(args []Object, index int) *_macho.RelocTypeARM {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.RelocTypeARM:
			return &r
		case *_macho.RelocTypeARM:
			return r
		}
	case Int:
		v := _macho.RelocTypeARM(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.RelocTypeARM]"))
}

func _ConstructRelocTypeARM(_v Object) _macho.RelocTypeARM {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.RelocTypeARM:
			return _g
		case *_macho.RelocTypeARM:
			return *_g
		}
	case Number:
		return _macho.RelocTypeARM(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.RelocTypeARM] or Number"))
}

GO TYPE debug/macho.RelocTypeARM64 from debug/macho/reloctype.go:
func ExtractGoObjectRelocTypeARM64(args []Object, index int) *_macho.RelocTypeARM64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.RelocTypeARM64:
			return &r
		case *_macho.RelocTypeARM64:
			return r
		}
	case Int:
		v := _macho.RelocTypeARM64(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.RelocTypeARM64]"))
}

func _ConstructRelocTypeARM64(_v Object) _macho.RelocTypeARM64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.RelocTypeARM64:
			return _g
		case *_macho.RelocTypeARM64:
			return *_g
		}
	case Number:
		return _macho.RelocTypeARM64(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.RelocTypeARM64] or Number"))
}

GO TYPE debug/macho.RelocTypeGeneric from debug/macho/reloctype.go:
func ExtractGoObjectRelocTypeGeneric(args []Object, index int) *_macho.RelocTypeGeneric {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.RelocTypeGeneric:
			return &r
		case *_macho.RelocTypeGeneric:
			return r
		}
	case Int:
		v := _macho.RelocTypeGeneric(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.RelocTypeGeneric]"))
}

func _ConstructRelocTypeGeneric(_v Object) _macho.RelocTypeGeneric {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.RelocTypeGeneric:
			return _g
		case *_macho.RelocTypeGeneric:
			return *_g
		}
	case Number:
		return _macho.RelocTypeGeneric(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.RelocTypeGeneric] or Number"))
}

GO TYPE debug/macho.RelocTypeX86_64 from debug/macho/reloctype.go:
func ExtractGoObjectRelocTypeX86_64(args []Object, index int) *_macho.RelocTypeX86_64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.RelocTypeX86_64:
			return &r
		case *_macho.RelocTypeX86_64:
			return r
		}
	case Int:
		v := _macho.RelocTypeX86_64(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.RelocTypeX86_64]"))
}

func _ConstructRelocTypeX86_64(_v Object) _macho.RelocTypeX86_64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.RelocTypeX86_64:
			return _g
		case *_macho.RelocTypeX86_64:
			return *_g
		}
	case Number:
		return _macho.RelocTypeX86_64(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.RelocTypeX86_64] or Number"))
}

GO TYPE debug/macho.Rpath from debug/macho/file.go:
func ExtractGoObjectRpath(args []Object, index int) *_macho.Rpath {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Rpath:
			return &r
		case *_macho.Rpath:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Rpath]"))
}

func _mapToRpath(o Map) *_macho.Rpath {
	return &_macho.Rpath{
	}
}

func _vectorToRpath(o *Vector) *_macho.Rpath {
	return &_macho.Rpath{
	}
}

func _ConstructRpath(_v Object) *_macho.Rpath {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Rpath:
			return &_g
		case *_macho.Rpath:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRpath(_o.(Map))
	case case *Vector:
		return _vectorToRpath(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Rpath] or Map"))
}

GO TYPE debug/macho.RpathCmd from debug/macho/macho.go:
func ExtractGoObjectRpathCmd(args []Object, index int) *_macho.RpathCmd {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.RpathCmd:
			return &r
		case *_macho.RpathCmd:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.RpathCmd]"))
}

func _mapToRpathCmd(o Map) *_macho.RpathCmd {
	return &_macho.RpathCmd{
	}
}

func _vectorToRpathCmd(o *Vector) *_macho.RpathCmd {
	return &_macho.RpathCmd{
	}
}

func _ConstructRpathCmd(_v Object) *_macho.RpathCmd {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.RpathCmd:
			return &_g
		case *_macho.RpathCmd:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRpathCmd(_o.(Map))
	case case *Vector:
		return _vectorToRpathCmd(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.RpathCmd] or Map"))
}

GO TYPE debug/macho.Section from debug/macho/file.go:
func ExtractGoObjectSection(args []Object, index int) *_macho.Section {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Section:
			return &r
		case *_macho.Section:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Section]"))
}

func _mapToSection(o Map) *_macho.Section {
	return &_macho.Section{
	}
}

func _vectorToSection(o *Vector) *_macho.Section {
	return &_macho.Section{
	}
}

func _ConstructSection(_v Object) *_macho.Section {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Section:
			return &_g
		case *_macho.Section:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSection(_o.(Map))
	case case *Vector:
		return _vectorToSection(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Section] or Map"))
}

GO TYPE debug/macho.Section32 from debug/macho/macho.go:
func ExtractGoObjectSection32(args []Object, index int) *_macho.Section32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Section32:
			return &r
		case *_macho.Section32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Section32]"))
}

func _mapToSection32(o Map) *_macho.Section32 {
	return &_macho.Section32{
	}
}

func _vectorToSection32(o *Vector) *_macho.Section32 {
	return &_macho.Section32{
	}
}

func _ConstructSection32(_v Object) *_macho.Section32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Section32:
			return &_g
		case *_macho.Section32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSection32(_o.(Map))
	case case *Vector:
		return _vectorToSection32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Section32] or Map"))
}

GO TYPE debug/macho.Section64 from debug/macho/macho.go:
func ExtractGoObjectSection64(args []Object, index int) *_macho.Section64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Section64:
			return &r
		case *_macho.Section64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Section64]"))
}

func _mapToSection64(o Map) *_macho.Section64 {
	return &_macho.Section64{
	}
}

func _vectorToSection64(o *Vector) *_macho.Section64 {
	return &_macho.Section64{
	}
}

func _ConstructSection64(_v Object) *_macho.Section64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Section64:
			return &_g
		case *_macho.Section64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSection64(_o.(Map))
	case case *Vector:
		return _vectorToSection64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Section64] or Map"))
}

GO TYPE debug/macho.SectionHeader from debug/macho/file.go:
func ExtractGoObjectSectionHeader(args []Object, index int) *_macho.SectionHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.SectionHeader:
			return &r
		case *_macho.SectionHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.SectionHeader]"))
}

func _mapToSectionHeader(o Map) *_macho.SectionHeader {
	return &_macho.SectionHeader{
	}
}

func _vectorToSectionHeader(o *Vector) *_macho.SectionHeader {
	return &_macho.SectionHeader{
	}
}

func _ConstructSectionHeader(_v Object) *_macho.SectionHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.SectionHeader:
			return &_g
		case *_macho.SectionHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSectionHeader(_o.(Map))
	case case *Vector:
		return _vectorToSectionHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.SectionHeader] or Map"))
}

GO TYPE debug/macho.Segment from debug/macho/file.go:
func ExtractGoObjectSegment(args []Object, index int) *_macho.Segment {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Segment:
			return &r
		case *_macho.Segment:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Segment]"))
}

func _mapToSegment(o Map) *_macho.Segment {
	return &_macho.Segment{
	}
}

func _vectorToSegment(o *Vector) *_macho.Segment {
	return &_macho.Segment{
	}
}

func _ConstructSegment(_v Object) *_macho.Segment {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Segment:
			return &_g
		case *_macho.Segment:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSegment(_o.(Map))
	case case *Vector:
		return _vectorToSegment(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Segment] or Map"))
}

GO TYPE debug/macho.Segment32 from debug/macho/macho.go:
func ExtractGoObjectSegment32(args []Object, index int) *_macho.Segment32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Segment32:
			return &r
		case *_macho.Segment32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Segment32]"))
}

func _mapToSegment32(o Map) *_macho.Segment32 {
	return &_macho.Segment32{
	}
}

func _vectorToSegment32(o *Vector) *_macho.Segment32 {
	return &_macho.Segment32{
	}
}

func _ConstructSegment32(_v Object) *_macho.Segment32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Segment32:
			return &_g
		case *_macho.Segment32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSegment32(_o.(Map))
	case case *Vector:
		return _vectorToSegment32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Segment32] or Map"))
}

GO TYPE debug/macho.Segment64 from debug/macho/macho.go:
func ExtractGoObjectSegment64(args []Object, index int) *_macho.Segment64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Segment64:
			return &r
		case *_macho.Segment64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Segment64]"))
}

func _mapToSegment64(o Map) *_macho.Segment64 {
	return &_macho.Segment64{
	}
}

func _vectorToSegment64(o *Vector) *_macho.Segment64 {
	return &_macho.Segment64{
	}
}

func _ConstructSegment64(_v Object) *_macho.Segment64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Segment64:
			return &_g
		case *_macho.Segment64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSegment64(_o.(Map))
	case case *Vector:
		return _vectorToSegment64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Segment64] or Map"))
}

GO TYPE debug/macho.SegmentHeader from debug/macho/file.go:
func ExtractGoObjectSegmentHeader(args []Object, index int) *_macho.SegmentHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.SegmentHeader:
			return &r
		case *_macho.SegmentHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.SegmentHeader]"))
}

func _mapToSegmentHeader(o Map) *_macho.SegmentHeader {
	return &_macho.SegmentHeader{
	}
}

func _vectorToSegmentHeader(o *Vector) *_macho.SegmentHeader {
	return &_macho.SegmentHeader{
	}
}

func _ConstructSegmentHeader(_v Object) *_macho.SegmentHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.SegmentHeader:
			return &_g
		case *_macho.SegmentHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSegmentHeader(_o.(Map))
	case case *Vector:
		return _vectorToSegmentHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.SegmentHeader] or Map"))
}

GO TYPE debug/macho.Symbol from debug/macho/file.go:
func ExtractGoObjectSymbol(args []Object, index int) *_macho.Symbol {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Symbol:
			return &r
		case *_macho.Symbol:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Symbol]"))
}

func _mapToSymbol(o Map) *_macho.Symbol {
	return &_macho.Symbol{
	}
}

func _vectorToSymbol(o *Vector) *_macho.Symbol {
	return &_macho.Symbol{
	}
}

func _ConstructSymbol(_v Object) *_macho.Symbol {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Symbol:
			return &_g
		case *_macho.Symbol:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSymbol(_o.(Map))
	case case *Vector:
		return _vectorToSymbol(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Symbol] or Map"))
}

GO TYPE debug/macho.Symtab from debug/macho/file.go:
func ExtractGoObjectSymtab(args []Object, index int) *_macho.Symtab {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Symtab:
			return &r
		case *_macho.Symtab:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Symtab]"))
}

func _mapToSymtab(o Map) *_macho.Symtab {
	return &_macho.Symtab{
	}
}

func _vectorToSymtab(o *Vector) *_macho.Symtab {
	return &_macho.Symtab{
	}
}

func _ConstructSymtab(_v Object) *_macho.Symtab {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Symtab:
			return &_g
		case *_macho.Symtab:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSymtab(_o.(Map))
	case case *Vector:
		return _vectorToSymtab(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Symtab] or Map"))
}

GO TYPE debug/macho.SymtabCmd from debug/macho/macho.go:
func ExtractGoObjectSymtabCmd(args []Object, index int) *_macho.SymtabCmd {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.SymtabCmd:
			return &r
		case *_macho.SymtabCmd:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.SymtabCmd]"))
}

func _mapToSymtabCmd(o Map) *_macho.SymtabCmd {
	return &_macho.SymtabCmd{
	}
}

func _vectorToSymtabCmd(o *Vector) *_macho.SymtabCmd {
	return &_macho.SymtabCmd{
	}
}

func _ConstructSymtabCmd(_v Object) *_macho.SymtabCmd {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.SymtabCmd:
			return &_g
		case *_macho.SymtabCmd:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSymtabCmd(_o.(Map))
	case case *Vector:
		return _vectorToSymtabCmd(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.SymtabCmd] or Map"))
}

GO TYPE debug/macho.Thread from debug/macho/macho.go:
func ExtractGoObjectThread(args []Object, index int) *_macho.Thread {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Thread:
			return &r
		case *_macho.Thread:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Thread]"))
}

func _mapToThread(o Map) *_macho.Thread {
	return &_macho.Thread{
	}
}

func _vectorToThread(o *Vector) *_macho.Thread {
	return &_macho.Thread{
	}
}

func _ConstructThread(_v Object) *_macho.Thread {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Thread:
			return &_g
		case *_macho.Thread:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToThread(_o.(Map))
	case case *Vector:
		return _vectorToThread(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Thread] or Map"))
}

GO TYPE debug/macho.Type from debug/macho/macho.go:
func ExtractGoObjectType(args []Object, index int) *_macho.Type {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Type:
			return &r
		case *_macho.Type:
			return r
		}
	case Number:
		v := _macho.Type(ExtractUInt32(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Type]"))
}

func _ConstructType(_v Object) _macho.Type {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Type:
			return _g
		case *_macho.Type:
			return *_g
		}
	case Number:
		return _macho.Type(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Type] or Number"))
}

GO FUNC debug/macho.NewFatFile from debug/macho/fat.go:
// func __newFatFile(r ABEND987(genutils.go: imports not yet supported: io.ReaderAt)) Object {
// 	_res1, _res2 := _macho.NewFatFile(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/macho.NewFile from debug/macho/file.go:
// func __newFile(r ABEND987(genutils.go: imports not yet supported: io.ReaderAt)) Object {
// 	_res1, _res2 := _macho.NewFile(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/macho.Open from debug/macho/file.go:
func __open(name string) Object {
	_res1, _res2 := _macho.Open(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/macho.OpenFat from debug/macho/fat.go:
func __openFat(name string) Object {
	_res1, _res2 := _macho.OpenFat(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package macho

import (
	_macho "debug/macho"
	. "github.com/candid82/joker/core"
)
GO TYPE debug/pe.COFFSymbol from debug/pe/symbol.go:
func ExtractGoObjectCOFFSymbol(args []Object, index int) *_pe.COFFSymbol {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.COFFSymbol:
			return &r
		case *_pe.COFFSymbol:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.COFFSymbol]"))
}

func _mapToCOFFSymbol(o Map) *_pe.COFFSymbol {
	return &_pe.COFFSymbol{
	}
}

func _vectorToCOFFSymbol(o *Vector) *_pe.COFFSymbol {
	return &_pe.COFFSymbol{
	}
}

func _ConstructCOFFSymbol(_v Object) *_pe.COFFSymbol {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pe.COFFSymbol:
			return &_g
		case *_pe.COFFSymbol:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCOFFSymbol(_o.(Map))
	case case *Vector:
		return _vectorToCOFFSymbol(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.COFFSymbol] or Map"))
}

GO TYPE debug/pe.DataDirectory from debug/pe/pe.go:
func ExtractGoObjectDataDirectory(args []Object, index int) *_pe.DataDirectory {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.DataDirectory:
			return &r
		case *_pe.DataDirectory:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.DataDirectory]"))
}

func _mapToDataDirectory(o Map) *_pe.DataDirectory {
	return &_pe.DataDirectory{
	}
}

func _vectorToDataDirectory(o *Vector) *_pe.DataDirectory {
	return &_pe.DataDirectory{
	}
}

func _ConstructDataDirectory(_v Object) *_pe.DataDirectory {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pe.DataDirectory:
			return &_g
		case *_pe.DataDirectory:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDataDirectory(_o.(Map))
	case case *Vector:
		return _vectorToDataDirectory(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.DataDirectory] or Map"))
}

GO TYPE debug/pe.File from debug/pe/file.go:
func ExtractGoObjectFile(args []Object, index int) *_pe.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.File:
			return &r
		case *_pe.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.File]"))
}

func _mapToFile(o Map) *_pe.File {
	return &_pe.File{
	}
}

func _vectorToFile(o *Vector) *_pe.File {
	return &_pe.File{
	}
}

func _ConstructFile(_v Object) *_pe.File {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pe.File:
			return &_g
		case *_pe.File:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFile(_o.(Map))
	case case *Vector:
		return _vectorToFile(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.File] or Map"))
}

GO TYPE debug/pe.FileHeader from debug/pe/pe.go:
func ExtractGoObjectFileHeader(args []Object, index int) *_pe.FileHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.FileHeader:
			return &r
		case *_pe.FileHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.FileHeader]"))
}

func _mapToFileHeader(o Map) *_pe.FileHeader {
	return &_pe.FileHeader{
	}
}

func _vectorToFileHeader(o *Vector) *_pe.FileHeader {
	return &_pe.FileHeader{
	}
}

func _ConstructFileHeader(_v Object) *_pe.FileHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pe.FileHeader:
			return &_g
		case *_pe.FileHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFileHeader(_o.(Map))
	case case *Vector:
		return _vectorToFileHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.FileHeader] or Map"))
}

GO TYPE debug/pe.FormatError from debug/pe/file.go:
func ExtractGoObjectFormatError(args []Object, index int) *_pe.FormatError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.FormatError:
			return &r
		case *_pe.FormatError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.FormatError]"))
}

func _mapToFormatError(o Map) *_pe.FormatError {
	return &_pe.FormatError{
	}
}

func _vectorToFormatError(o *Vector) *_pe.FormatError {
	return &_pe.FormatError{
	}
}

func _ConstructFormatError(_v Object) *_pe.FormatError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pe.FormatError:
			return &_g
		case *_pe.FormatError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFormatError(_o.(Map))
	case case *Vector:
		return _vectorToFormatError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.FormatError] or Map"))
}

GO TYPE debug/pe.ImportDirectory from debug/pe/file.go:
func ExtractGoObjectImportDirectory(args []Object, index int) *_pe.ImportDirectory {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.ImportDirectory:
			return &r
		case *_pe.ImportDirectory:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.ImportDirectory]"))
}

func _mapToImportDirectory(o Map) *_pe.ImportDirectory {
	return &_pe.ImportDirectory{
	}
}

func _vectorToImportDirectory(o *Vector) *_pe.ImportDirectory {
	return &_pe.ImportDirectory{
	}
}

func _ConstructImportDirectory(_v Object) *_pe.ImportDirectory {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pe.ImportDirectory:
			return &_g
		case *_pe.ImportDirectory:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToImportDirectory(_o.(Map))
	case case *Vector:
		return _vectorToImportDirectory(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.ImportDirectory] or Map"))
}

GO TYPE debug/pe.OptionalHeader32 from debug/pe/pe.go:
func ExtractGoObjectOptionalHeader32(args []Object, index int) *_pe.OptionalHeader32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.OptionalHeader32:
			return &r
		case *_pe.OptionalHeader32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.OptionalHeader32]"))
}

func _mapToOptionalHeader32(o Map) *_pe.OptionalHeader32 {
	return &_pe.OptionalHeader32{
	}
}

func _vectorToOptionalHeader32(o *Vector) *_pe.OptionalHeader32 {
	return &_pe.OptionalHeader32{
	}
}

func _ConstructOptionalHeader32(_v Object) *_pe.OptionalHeader32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pe.OptionalHeader32:
			return &_g
		case *_pe.OptionalHeader32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToOptionalHeader32(_o.(Map))
	case case *Vector:
		return _vectorToOptionalHeader32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.OptionalHeader32] or Map"))
}

GO TYPE debug/pe.OptionalHeader64 from debug/pe/pe.go:
func ExtractGoObjectOptionalHeader64(args []Object, index int) *_pe.OptionalHeader64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.OptionalHeader64:
			return &r
		case *_pe.OptionalHeader64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.OptionalHeader64]"))
}

func _mapToOptionalHeader64(o Map) *_pe.OptionalHeader64 {
	return &_pe.OptionalHeader64{
	}
}

func _vectorToOptionalHeader64(o *Vector) *_pe.OptionalHeader64 {
	return &_pe.OptionalHeader64{
	}
}

func _ConstructOptionalHeader64(_v Object) *_pe.OptionalHeader64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pe.OptionalHeader64:
			return &_g
		case *_pe.OptionalHeader64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToOptionalHeader64(_o.(Map))
	case case *Vector:
		return _vectorToOptionalHeader64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.OptionalHeader64] or Map"))
}

GO TYPE debug/pe.Reloc from debug/pe/section.go:
func ExtractGoObjectReloc(args []Object, index int) *_pe.Reloc {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.Reloc:
			return &r
		case *_pe.Reloc:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.Reloc]"))
}

func _mapToReloc(o Map) *_pe.Reloc {
	return &_pe.Reloc{
	}
}

func _vectorToReloc(o *Vector) *_pe.Reloc {
	return &_pe.Reloc{
	}
}

func _ConstructReloc(_v Object) *_pe.Reloc {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pe.Reloc:
			return &_g
		case *_pe.Reloc:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReloc(_o.(Map))
	case case *Vector:
		return _vectorToReloc(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.Reloc] or Map"))
}

GO TYPE debug/pe.Section from debug/pe/section.go:
func ExtractGoObjectSection(args []Object, index int) *_pe.Section {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.Section:
			return &r
		case *_pe.Section:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.Section]"))
}

func _mapToSection(o Map) *_pe.Section {
	return &_pe.Section{
	}
}

func _vectorToSection(o *Vector) *_pe.Section {
	return &_pe.Section{
	}
}

func _ConstructSection(_v Object) *_pe.Section {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pe.Section:
			return &_g
		case *_pe.Section:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSection(_o.(Map))
	case case *Vector:
		return _vectorToSection(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.Section] or Map"))
}

GO TYPE debug/pe.SectionHeader from debug/pe/section.go:
func ExtractGoObjectSectionHeader(args []Object, index int) *_pe.SectionHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.SectionHeader:
			return &r
		case *_pe.SectionHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.SectionHeader]"))
}

func _mapToSectionHeader(o Map) *_pe.SectionHeader {
	return &_pe.SectionHeader{
	}
}

func _vectorToSectionHeader(o *Vector) *_pe.SectionHeader {
	return &_pe.SectionHeader{
	}
}

func _ConstructSectionHeader(_v Object) *_pe.SectionHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pe.SectionHeader:
			return &_g
		case *_pe.SectionHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSectionHeader(_o.(Map))
	case case *Vector:
		return _vectorToSectionHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.SectionHeader] or Map"))
}

GO TYPE debug/pe.SectionHeader32 from debug/pe/section.go:
func ExtractGoObjectSectionHeader32(args []Object, index int) *_pe.SectionHeader32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.SectionHeader32:
			return &r
		case *_pe.SectionHeader32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.SectionHeader32]"))
}

func _mapToSectionHeader32(o Map) *_pe.SectionHeader32 {
	return &_pe.SectionHeader32{
	}
}

func _vectorToSectionHeader32(o *Vector) *_pe.SectionHeader32 {
	return &_pe.SectionHeader32{
	}
}

func _ConstructSectionHeader32(_v Object) *_pe.SectionHeader32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pe.SectionHeader32:
			return &_g
		case *_pe.SectionHeader32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSectionHeader32(_o.(Map))
	case case *Vector:
		return _vectorToSectionHeader32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.SectionHeader32] or Map"))
}

GO TYPE debug/pe.StringTable from debug/pe/string.go:
func ExtractGoObjectStringTable(args []Object, index int) *_pe.StringTable {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.StringTable:
			return &r
		case *_pe.StringTable:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.StringTable]"))
}

// func _ConstructStringTable(_v Object) _pe.StringTable {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _pe.StringTable:
// 			return _g
// 		case *_pe.StringTable:
// 			return *_g
// 		}
// 	default:
// 		return _pe.StringTable(_o.ABEND674(unknown underlying type *ast.ArrayType for StringTable))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.StringTable] or whatever"))
// }

GO TYPE debug/pe.Symbol from debug/pe/symbol.go:
func ExtractGoObjectSymbol(args []Object, index int) *_pe.Symbol {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.Symbol:
			return &r
		case *_pe.Symbol:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.Symbol]"))
}

func _mapToSymbol(o Map) *_pe.Symbol {
	return &_pe.Symbol{
	}
}

func _vectorToSymbol(o *Vector) *_pe.Symbol {
	return &_pe.Symbol{
	}
}

func _ConstructSymbol(_v Object) *_pe.Symbol {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pe.Symbol:
			return &_g
		case *_pe.Symbol:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSymbol(_o.(Map))
	case case *Vector:
		return _vectorToSymbol(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.Symbol] or Map"))
}

GO FUNC debug/pe.NewFile from debug/pe/file.go:
// func __newFile(r ABEND987(genutils.go: imports not yet supported: io.ReaderAt)) Object {
// 	_res1, _res2 := _pe.NewFile(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/pe.Open from debug/pe/file.go:
func __open(name string) Object {
	_res1, _res2 := _pe.Open(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package pe

import (
	_pe "debug/pe"
	. "github.com/candid82/joker/core"
)
GO TYPE debug/plan9obj.File from debug/plan9obj/file.go:
func ExtractGoObjectFile(args []Object, index int) *_plan9obj.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _plan9obj.File:
			return &r
		case *_plan9obj.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/plan9obj.File]"))
}

func _mapToFile(o Map) *_plan9obj.File {
	return &_plan9obj.File{
	}
}

func _vectorToFile(o *Vector) *_plan9obj.File {
	return &_plan9obj.File{
	}
}

func _ConstructFile(_v Object) *_plan9obj.File {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _plan9obj.File:
			return &_g
		case *_plan9obj.File:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFile(_o.(Map))
	case case *Vector:
		return _vectorToFile(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[plan9obj.File] or Map"))
}

GO TYPE debug/plan9obj.FileHeader from debug/plan9obj/file.go:
func ExtractGoObjectFileHeader(args []Object, index int) *_plan9obj.FileHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _plan9obj.FileHeader:
			return &r
		case *_plan9obj.FileHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/plan9obj.FileHeader]"))
}

func _mapToFileHeader(o Map) *_plan9obj.FileHeader {
	return &_plan9obj.FileHeader{
	}
}

func _vectorToFileHeader(o *Vector) *_plan9obj.FileHeader {
	return &_plan9obj.FileHeader{
	}
}

func _ConstructFileHeader(_v Object) *_plan9obj.FileHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _plan9obj.FileHeader:
			return &_g
		case *_plan9obj.FileHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFileHeader(_o.(Map))
	case case *Vector:
		return _vectorToFileHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[plan9obj.FileHeader] or Map"))
}

GO TYPE debug/plan9obj.Section from debug/plan9obj/file.go:
func ExtractGoObjectSection(args []Object, index int) *_plan9obj.Section {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _plan9obj.Section:
			return &r
		case *_plan9obj.Section:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/plan9obj.Section]"))
}

func _mapToSection(o Map) *_plan9obj.Section {
	return &_plan9obj.Section{
	}
}

func _vectorToSection(o *Vector) *_plan9obj.Section {
	return &_plan9obj.Section{
	}
}

func _ConstructSection(_v Object) *_plan9obj.Section {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _plan9obj.Section:
			return &_g
		case *_plan9obj.Section:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSection(_o.(Map))
	case case *Vector:
		return _vectorToSection(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[plan9obj.Section] or Map"))
}

GO TYPE debug/plan9obj.SectionHeader from debug/plan9obj/file.go:
func ExtractGoObjectSectionHeader(args []Object, index int) *_plan9obj.SectionHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _plan9obj.SectionHeader:
			return &r
		case *_plan9obj.SectionHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/plan9obj.SectionHeader]"))
}

func _mapToSectionHeader(o Map) *_plan9obj.SectionHeader {
	return &_plan9obj.SectionHeader{
	}
}

func _vectorToSectionHeader(o *Vector) *_plan9obj.SectionHeader {
	return &_plan9obj.SectionHeader{
	}
}

func _ConstructSectionHeader(_v Object) *_plan9obj.SectionHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _plan9obj.SectionHeader:
			return &_g
		case *_plan9obj.SectionHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSectionHeader(_o.(Map))
	case case *Vector:
		return _vectorToSectionHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[plan9obj.SectionHeader] or Map"))
}

GO TYPE debug/plan9obj.Sym from debug/plan9obj/file.go:
func ExtractGoObjectSym(args []Object, index int) *_plan9obj.Sym {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _plan9obj.Sym:
			return &r
		case *_plan9obj.Sym:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/plan9obj.Sym]"))
}

func _mapToSym(o Map) *_plan9obj.Sym {
	return &_plan9obj.Sym{
	}
}

func _vectorToSym(o *Vector) *_plan9obj.Sym {
	return &_plan9obj.Sym{
	}
}

func _ConstructSym(_v Object) *_plan9obj.Sym {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _plan9obj.Sym:
			return &_g
		case *_plan9obj.Sym:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSym(_o.(Map))
	case case *Vector:
		return _vectorToSym(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[plan9obj.Sym] or Map"))
}

GO FUNC debug/plan9obj.NewFile from debug/plan9obj/file.go:
// func __newFile(r ABEND987(genutils.go: imports not yet supported: io.ReaderAt)) Object {
// 	_res1, _res2 := _plan9obj.NewFile(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/plan9obj.Open from debug/plan9obj/file.go:
func __open(name string) Object {
	_res1, _res2 := _plan9obj.Open(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package plan9obj

import (
	_plan9obj "debug/plan9obj"
	. "github.com/candid82/joker/core"
)
GO TYPE encoding/ascii85.CorruptInputError from encoding/ascii85/ascii85.go:
func ExtractGoObjectCorruptInputError(args []Object, index int) *_ascii85.CorruptInputError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ascii85.CorruptInputError:
			return &r
		case *_ascii85.CorruptInputError:
			return r
		}
	case Number:
		v := _ascii85.CorruptInputError(ExtractInt64(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/ascii85.CorruptInputError]"))
}

func _ConstructCorruptInputError(_v Object) _ascii85.CorruptInputError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ascii85.CorruptInputError:
			return _g
		case *_ascii85.CorruptInputError:
			return *_g
		}
	case Number:
		return _ascii85.CorruptInputError(_o.BigInt().Int64())
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ascii85.CorruptInputError] or Number"))
}

GO FUNC encoding/ascii85.Decode from encoding/ascii85/ascii85.go:
// func __decode(dst []byte, src []byte, flush bool) Object {
// 	ndst, nsrc, err := _ascii85.Decode(dst, src, flush)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(ndst))
// 	_res = _res.Conjoin(MakeInt(nsrc))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC encoding/ascii85.Encode from encoding/ascii85/ascii85.go:
// func __encode(dst []byte, src []byte)  {
// 	_res := _ascii85.Encode(dst, src)
// 	return MakeInt(_res)
// }

GO FUNC encoding/ascii85.NewDecoder from encoding/ascii85/ascii85.go:
// func __newDecoder(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _ascii85.NewDecoder(r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/ascii85.NewEncoder from encoding/ascii85/ascii85.go:
// func __newEncoder(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _ascii85.NewEncoder(w)
// 	return MakeGoObject(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package ascii85

import (
	_ascii85 "encoding/ascii85"
	. "github.com/candid82/joker/core"
)
GO FUNC encoding/asn1.Marshal from encoding/asn1/marshal.go:
// func __marshal(val interface {}) Object {
// 	_res1, _res2 := _asn1.Marshal(val)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/asn1.MarshalWithParams from encoding/asn1/marshal.go:
// func __marshalWithParams(val interface {}, params string) Object {
// 	_res1, _res2 := _asn1.MarshalWithParams(val, params)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/asn1.Unmarshal from encoding/asn1/asn1.go:
// func __unmarshal(b []byte, val interface {}) Object {
// 	rest, err := _asn1.Unmarshal(b, val)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range rest {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC encoding/asn1.UnmarshalWithParams from encoding/asn1/asn1.go:
// func __unmarshalWithParams(b []byte, val interface {}, params string) Object {
// 	rest, err := _asn1.UnmarshalWithParams(b, val, params)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range rest {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO TYPE encoding/base32.CorruptInputError from encoding/base32/base32.go:
func ExtractGoObjectCorruptInputError(args []Object, index int) *_base32.CorruptInputError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _base32.CorruptInputError:
			return &r
		case *_base32.CorruptInputError:
			return r
		}
	case Number:
		v := _base32.CorruptInputError(ExtractInt64(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/base32.CorruptInputError]"))
}

func _ConstructCorruptInputError(_v Object) _base32.CorruptInputError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _base32.CorruptInputError:
			return _g
		case *_base32.CorruptInputError:
			return *_g
		}
	case Number:
		return _base32.CorruptInputError(_o.BigInt().Int64())
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[base32.CorruptInputError] or Number"))
}

GO TYPE encoding/base32.Encoding from encoding/base32/base32.go:
func ExtractGoObjectEncoding(args []Object, index int) *_base32.Encoding {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _base32.Encoding:
			return &r
		case *_base32.Encoding:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/base32.Encoding]"))
}

func _mapToEncoding(o Map) *_base32.Encoding {
	return &_base32.Encoding{
	}
}

func _vectorToEncoding(o *Vector) *_base32.Encoding {
	return &_base32.Encoding{
	}
}

func _ConstructEncoding(_v Object) *_base32.Encoding {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _base32.Encoding:
			return &_g
		case *_base32.Encoding:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToEncoding(_o.(Map))
	case case *Vector:
		return _vectorToEncoding(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[base32.Encoding] or Map"))
}

GO FUNC encoding/base32.NewDecoder from encoding/base32/base32.go:
// func __newDecoder(enc *_base32.Encoding, r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _base32.NewDecoder(enc, r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/base32.NewEncoder from encoding/base32/base32.go:
// func __newEncoder(enc *_base32.Encoding, w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _base32.NewEncoder(enc, w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/base32.NewEncoding from encoding/base32/base32.go:
func __newEncoding(encoder string) Object {
	_res := _base32.NewEncoding(encoder)
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package base32

import (
	_base32 "encoding/base32"
	. "github.com/candid82/joker/core"
)
GO TYPE encoding/base64.CorruptInputError from encoding/base64/base64.go:
func ExtractGoObjectCorruptInputError(args []Object, index int) *_base64.CorruptInputError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _base64.CorruptInputError:
			return &r
		case *_base64.CorruptInputError:
			return r
		}
	case Number:
		v := _base64.CorruptInputError(ExtractInt64(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/base64.CorruptInputError]"))
}

func _ConstructCorruptInputError(_v Object) _base64.CorruptInputError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _base64.CorruptInputError:
			return _g
		case *_base64.CorruptInputError:
			return *_g
		}
	case Number:
		return _base64.CorruptInputError(_o.BigInt().Int64())
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[base64.CorruptInputError] or Number"))
}

GO TYPE encoding/base64.Encoding from encoding/base64/base64.go:
func ExtractGoObjectEncoding(args []Object, index int) *_base64.Encoding {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _base64.Encoding:
			return &r
		case *_base64.Encoding:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/base64.Encoding]"))
}

func _mapToEncoding(o Map) *_base64.Encoding {
	return &_base64.Encoding{
	}
}

func _vectorToEncoding(o *Vector) *_base64.Encoding {
	return &_base64.Encoding{
	}
}

func _ConstructEncoding(_v Object) *_base64.Encoding {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _base64.Encoding:
			return &_g
		case *_base64.Encoding:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToEncoding(_o.(Map))
	case case *Vector:
		return _vectorToEncoding(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[base64.Encoding] or Map"))
}

GO FUNC encoding/base64.NewDecoder from encoding/base64/base64.go:
// func __newDecoder(enc *_base64.Encoding, r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _base64.NewDecoder(enc, r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/base64.NewEncoder from encoding/base64/base64.go:
// func __newEncoder(enc *_base64.Encoding, w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _base64.NewEncoder(enc, w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/base64.NewEncoding from encoding/base64/base64.go:
func __newEncoding(encoder string) Object {
	_res := _base64.NewEncoding(encoder)
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package base64

import (
	_base64 "encoding/base64"
	. "github.com/candid82/joker/core"
)
GO FUNC encoding/binary.PutUvarint from encoding/binary/varint.go:
// func __putUvarint(buf []byte, x uint64)  {
// 	_res := _binary.PutUvarint(buf, x)
// 	return MakeInt(_res)
// }

GO FUNC encoding/binary.PutVarint from encoding/binary/varint.go:
// func __putVarint(buf []byte, x int64)  {
// 	_res := _binary.PutVarint(buf, x)
// 	return MakeInt(_res)
// }

GO FUNC encoding/binary.Read from encoding/binary/binary.go:
// func __read(r ABEND987(genutils.go: imports not yet supported: io.Reader), order _binary.ByteOrder, data interface {})  {
// 	_res := _binary.Read(r, order, data)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC encoding/binary.ReadUvarint from encoding/binary/varint.go:
// func __readUvarint(r ABEND987(genutils.go: imports not yet supported: io.ByteReader)) Object {
// 	_res1, _res2 := _binary.ReadUvarint(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeBigInt(uint64(_res1)))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/binary.ReadVarint from encoding/binary/varint.go:
// func __readVarint(r ABEND987(genutils.go: imports not yet supported: io.ByteReader)) Object {
// 	_res1, _res2 := _binary.ReadVarint(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(int(_res1)))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/binary.Size from encoding/binary/binary.go:
// func __size(v interface {})  {
// 	_res := _binary.Size(v)
// 	return MakeInt(_res)
// }

GO FUNC encoding/binary.Uvarint from encoding/binary/varint.go:
// func __uvarint(buf []byte) Object {
// 	_res1, _res2 := _binary.Uvarint(buf)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeBigInt(uint64(_res1)))
// 	_res = _res.Conjoin(MakeInt(_res2))
// 	return _res
// }

GO FUNC encoding/binary.Varint from encoding/binary/varint.go:
// func __varint(buf []byte) Object {
// 	_res1, _res2 := _binary.Varint(buf)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(int(_res1)))
// 	_res = _res.Conjoin(MakeInt(_res2))
// 	return _res
// }

GO FUNC encoding/binary.Write from encoding/binary/binary.go:
// func __write(w ABEND987(genutils.go: imports not yet supported: io.Writer), order _binary.ByteOrder, data interface {})  {
// 	_res := _binary.Write(w, order, data)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC encoding/csv.NewReader from encoding/csv/reader.go:
// func __newReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _csv.NewReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/csv.NewWriter from encoding/csv/writer.go:
// func __newWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _csv.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/gob.NewDecoder from encoding/gob/decoder.go:
// func __newDecoder(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _gob.NewDecoder(r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/gob.NewEncoder from encoding/gob/encoder.go:
// func __newEncoder(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _gob.NewEncoder(w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/gob.Register from encoding/gob/type.go:
// func __register(value interface {}) Object {
// 	_gob.Register(value)
// 	...ABEND675: TODO...
// }

GO FUNC encoding/gob.RegisterName from encoding/gob/type.go:
// func __registerName(name string, value interface {}) Object {
// 	_gob.RegisterName(name, value)
// 	...ABEND675: TODO...
// }

GO TYPE encoding/hex.InvalidByteError from encoding/hex/hex.go:
func ExtractGoObjectInvalidByteError(args []Object, index int) *_hex.InvalidByteError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _hex.InvalidByteError:
			return &r
		case *_hex.InvalidByteError:
			return r
		}
	case Int:
		v := _hex.InvalidByteError(ExtractByte(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/hex.InvalidByteError]"))
}

func _ConstructInvalidByteError(_v Object) _hex.InvalidByteError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _hex.InvalidByteError:
			return _g
		case *_hex.InvalidByteError:
			return *_g
		}
	case Number:
		return _hex.InvalidByteError(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[hex.InvalidByteError] or Number"))
}

GO FUNC encoding/hex.Decode from encoding/hex/hex.go:
// func __decode(dst []byte, src []byte) Object {
// 	_res1, _res2 := _hex.Decode(dst, src)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/hex.DecodeString from encoding/hex/hex.go:
func __decodeString(s string) Object {
	_res1, _res2 := _hex.DecodeString(s)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC encoding/hex.Dump from encoding/hex/hex.go:
// func __dump(data []byte)  {
// 	_res := _hex.Dump(data)
// 	return MakeString(_res)
// }

GO FUNC encoding/hex.Dumper from encoding/hex/hex.go:
// func __dumper(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _hex.Dumper(w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/hex.Encode from encoding/hex/hex.go:
// func __encode(dst []byte, src []byte)  {
// 	_res := _hex.Encode(dst, src)
// 	return MakeInt(_res)
// }

GO FUNC encoding/hex.EncodeToString from encoding/hex/hex.go:
// func __encodeToString(src []byte)  {
// 	_res := _hex.EncodeToString(src)
// 	return MakeString(_res)
// }

GO FUNC encoding/hex.NewDecoder from encoding/hex/hex.go:
// func __newDecoder(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _hex.NewDecoder(r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/hex.NewEncoder from encoding/hex/hex.go:
// func __newEncoder(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _hex.NewEncoder(w)
// 	return MakeGoObject(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package hex

import (
	_hex "encoding/hex"
	. "github.com/candid82/joker/core"
)
GO FUNC encoding/json.Compact from encoding/json/indent.go:
// func __compact(dst *ABEND987(genutils.go: imports not yet supported: bytes.Buffer), src []byte)  {
// 	_res := _json.Compact(dst, src)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC encoding/json.HTMLEscape from encoding/json/encode.go:
// func __hTMLEscape(dst *ABEND987(genutils.go: imports not yet supported: bytes.Buffer), src []byte) Object {
// 	_json.HTMLEscape(dst, src)
// 	...ABEND675: TODO...
// }

GO FUNC encoding/json.Indent from encoding/json/indent.go:
// func __indent(dst *ABEND987(genutils.go: imports not yet supported: bytes.Buffer), src []byte, prefix string, indent string)  {
// 	_res := _json.Indent(dst, src, prefix, indent)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC encoding/json.Marshal from encoding/json/encode.go:
// func __marshal(v interface {}) Object {
// 	_res1, _res2 := _json.Marshal(v)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/json.MarshalIndent from encoding/json/encode.go:
// func __marshalIndent(v interface {}, prefix string, indent string) Object {
// 	_res1, _res2 := _json.MarshalIndent(v, prefix, indent)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/json.NewDecoder from encoding/json/stream.go:
// func __newDecoder(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _json.NewDecoder(r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/json.NewEncoder from encoding/json/stream.go:
// func __newEncoder(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _json.NewEncoder(w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/json.Unmarshal from encoding/json/decode.go:
// func __unmarshal(data []byte, v interface {})  {
// 	_res := _json.Unmarshal(data, v)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC encoding/json.Valid from encoding/json/scanner.go:
// func __valid(data []byte)  {
// 	_res := _json.Valid(data)
// 	return MakeBoolean(_res)
// }

GO TYPE encoding/pem.Block from encoding/pem/pem.go:
func ExtractGoObjectBlock(args []Object, index int) *_pem.Block {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pem.Block:
			return &r
		case *_pem.Block:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/pem.Block]"))
}

func _mapToBlock(o Map) *_pem.Block {
	return &_pem.Block{
	}
}

func _vectorToBlock(o *Vector) *_pem.Block {
	return &_pem.Block{
	}
}

func _ConstructBlock(_v Object) *_pem.Block {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pem.Block:
			return &_g
		case *_pem.Block:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBlock(_o.(Map))
	case case *Vector:
		return _vectorToBlock(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pem.Block] or Map"))
}

GO FUNC encoding/pem.Decode from encoding/pem/pem.go:
// func __decode(data []byte) Object {
// 	p, rest := _pem.Decode(data)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(p))
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range rest {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	return _res
// }

GO FUNC encoding/pem.Encode from encoding/pem/pem.go:
// func __encode(out ABEND987(genutils.go: imports not yet supported: io.Writer), b *_pem.Block)  {
// 	_res := _pem.Encode(out, b)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC encoding/pem.EncodeToMemory from encoding/pem/pem.go:
func __encodeToMemory(b *_pem.Block) Object {
	_res := _pem.EncodeToMemory(b)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package pem

import (
	_pem "encoding/pem"
	. "github.com/candid82/joker/core"
)
GO TYPE encoding/xml.Attr from encoding/xml/xml.go:
func ExtractGoObjectAttr(args []Object, index int) *_xml.Attr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.Attr:
			return &r
		case *_xml.Attr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.Attr]"))
}

func _mapToAttr(o Map) *_xml.Attr {
	return &_xml.Attr{
	}
}

func _vectorToAttr(o *Vector) *_xml.Attr {
	return &_xml.Attr{
	}
}

func _ConstructAttr(_v Object) *_xml.Attr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _xml.Attr:
			return &_g
		case *_xml.Attr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToAttr(_o.(Map))
	case case *Vector:
		return _vectorToAttr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.Attr] or Map"))
}

GO TYPE encoding/xml.CharData from encoding/xml/xml.go:
func ExtractGoObjectCharData(args []Object, index int) *_xml.CharData {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.CharData:
			return &r
		case *_xml.CharData:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.CharData]"))
}

// func _ConstructCharData(_v Object) _xml.CharData {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.CharData:
// 			return _g
// 		case *_xml.CharData:
// 			return *_g
// 		}
// 	default:
// 		return _xml.CharData(_o.ABEND674(unknown underlying type *ast.ArrayType for CharData))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.CharData] or whatever"))
// }

GO TYPE encoding/xml.Comment from encoding/xml/xml.go:
func ExtractGoObjectComment(args []Object, index int) *_xml.Comment {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.Comment:
			return &r
		case *_xml.Comment:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.Comment]"))
}

// func _ConstructComment(_v Object) _xml.Comment {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.Comment:
// 			return _g
// 		case *_xml.Comment:
// 			return *_g
// 		}
// 	default:
// 		return _xml.Comment(_o.ABEND674(unknown underlying type *ast.ArrayType for Comment))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.Comment] or whatever"))
// }

GO TYPE encoding/xml.Decoder from encoding/xml/xml.go:
func ExtractGoObjectDecoder(args []Object, index int) *_xml.Decoder {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.Decoder:
			return &r
		case *_xml.Decoder:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.Decoder]"))
}

func _mapToDecoder(o Map) *_xml.Decoder {
	return &_xml.Decoder{
	}
}

func _vectorToDecoder(o *Vector) *_xml.Decoder {
	return &_xml.Decoder{
	}
}

func _ConstructDecoder(_v Object) *_xml.Decoder {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _xml.Decoder:
			return &_g
		case *_xml.Decoder:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDecoder(_o.(Map))
	case case *Vector:
		return _vectorToDecoder(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.Decoder] or Map"))
}

GO TYPE encoding/xml.Directive from encoding/xml/xml.go:
func ExtractGoObjectDirective(args []Object, index int) *_xml.Directive {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.Directive:
			return &r
		case *_xml.Directive:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.Directive]"))
}

// func _ConstructDirective(_v Object) _xml.Directive {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.Directive:
// 			return _g
// 		case *_xml.Directive:
// 			return *_g
// 		}
// 	default:
// 		return _xml.Directive(_o.ABEND674(unknown underlying type *ast.ArrayType for Directive))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.Directive] or whatever"))
// }

GO TYPE encoding/xml.Encoder from encoding/xml/marshal.go:
func ExtractGoObjectEncoder(args []Object, index int) *_xml.Encoder {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.Encoder:
			return &r
		case *_xml.Encoder:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.Encoder]"))
}

func _mapToEncoder(o Map) *_xml.Encoder {
	return &_xml.Encoder{
	}
}

func _vectorToEncoder(o *Vector) *_xml.Encoder {
	return &_xml.Encoder{
	}
}

func _ConstructEncoder(_v Object) *_xml.Encoder {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _xml.Encoder:
			return &_g
		case *_xml.Encoder:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToEncoder(_o.(Map))
	case case *Vector:
		return _vectorToEncoder(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.Encoder] or Map"))
}

GO TYPE encoding/xml.EndElement from encoding/xml/xml.go:
func ExtractGoObjectEndElement(args []Object, index int) *_xml.EndElement {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.EndElement:
			return &r
		case *_xml.EndElement:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.EndElement]"))
}

func _mapToEndElement(o Map) *_xml.EndElement {
	return &_xml.EndElement{
	}
}

func _vectorToEndElement(o *Vector) *_xml.EndElement {
	return &_xml.EndElement{
	}
}

func _ConstructEndElement(_v Object) *_xml.EndElement {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _xml.EndElement:
			return &_g
		case *_xml.EndElement:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToEndElement(_o.(Map))
	case case *Vector:
		return _vectorToEndElement(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.EndElement] or Map"))
}

GO TYPE encoding/xml.Marshaler from encoding/xml/marshal.go:
func ExtractGoObjectMarshaler(args []Object, index int) *_xml.Marshaler {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.Marshaler:
			return &r
		case *_xml.Marshaler:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.Marshaler]"))
}

// func _ConstructMarshaler(_v Object) _xml.Marshaler {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.Marshaler:
// 			return _g
// 		case *_xml.Marshaler:
// 			return *_g
// 		}
// 	default:
// 		return _xml.Marshaler(_o.ABEND674(unknown underlying type *ast.InterfaceType for Marshaler))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.Marshaler] or whatever"))
// }

GO TYPE encoding/xml.MarshalerAttr from encoding/xml/marshal.go:
func ExtractGoObjectMarshalerAttr(args []Object, index int) *_xml.MarshalerAttr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.MarshalerAttr:
			return &r
		case *_xml.MarshalerAttr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.MarshalerAttr]"))
}

// func _ConstructMarshalerAttr(_v Object) _xml.MarshalerAttr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.MarshalerAttr:
// 			return _g
// 		case *_xml.MarshalerAttr:
// 			return *_g
// 		}
// 	default:
// 		return _xml.MarshalerAttr(_o.ABEND674(unknown underlying type *ast.InterfaceType for MarshalerAttr))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.MarshalerAttr] or whatever"))
// }

GO TYPE encoding/xml.Name from encoding/xml/xml.go:
func ExtractGoObjectName(args []Object, index int) *_xml.Name {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.Name:
			return &r
		case *_xml.Name:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.Name]"))
}

func _mapToName(o Map) *_xml.Name {
	return &_xml.Name{
	}
}

func _vectorToName(o *Vector) *_xml.Name {
	return &_xml.Name{
	}
}

func _ConstructName(_v Object) *_xml.Name {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _xml.Name:
			return &_g
		case *_xml.Name:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToName(_o.(Map))
	case case *Vector:
		return _vectorToName(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.Name] or Map"))
}

GO TYPE encoding/xml.ProcInst from encoding/xml/xml.go:
func ExtractGoObjectProcInst(args []Object, index int) *_xml.ProcInst {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.ProcInst:
			return &r
		case *_xml.ProcInst:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.ProcInst]"))
}

func _mapToProcInst(o Map) *_xml.ProcInst {
	return &_xml.ProcInst{
	}
}

func _vectorToProcInst(o *Vector) *_xml.ProcInst {
	return &_xml.ProcInst{
	}
}

func _ConstructProcInst(_v Object) *_xml.ProcInst {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _xml.ProcInst:
			return &_g
		case *_xml.ProcInst:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProcInst(_o.(Map))
	case case *Vector:
		return _vectorToProcInst(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.ProcInst] or Map"))
}

GO TYPE encoding/xml.StartElement from encoding/xml/xml.go:
func ExtractGoObjectStartElement(args []Object, index int) *_xml.StartElement {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.StartElement:
			return &r
		case *_xml.StartElement:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.StartElement]"))
}

func _mapToStartElement(o Map) *_xml.StartElement {
	return &_xml.StartElement{
	}
}

func _vectorToStartElement(o *Vector) *_xml.StartElement {
	return &_xml.StartElement{
	}
}

func _ConstructStartElement(_v Object) *_xml.StartElement {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _xml.StartElement:
			return &_g
		case *_xml.StartElement:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToStartElement(_o.(Map))
	case case *Vector:
		return _vectorToStartElement(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.StartElement] or Map"))
}

GO TYPE encoding/xml.SyntaxError from encoding/xml/xml.go:
func ExtractGoObjectSyntaxError(args []Object, index int) *_xml.SyntaxError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.SyntaxError:
			return &r
		case *_xml.SyntaxError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.SyntaxError]"))
}

func _mapToSyntaxError(o Map) *_xml.SyntaxError {
	return &_xml.SyntaxError{
	}
}

func _vectorToSyntaxError(o *Vector) *_xml.SyntaxError {
	return &_xml.SyntaxError{
	}
}

func _ConstructSyntaxError(_v Object) *_xml.SyntaxError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _xml.SyntaxError:
			return &_g
		case *_xml.SyntaxError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSyntaxError(_o.(Map))
	case case *Vector:
		return _vectorToSyntaxError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.SyntaxError] or Map"))
}

GO TYPE encoding/xml.TagPathError from encoding/xml/typeinfo.go:
func ExtractGoObjectTagPathError(args []Object, index int) *_xml.TagPathError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.TagPathError:
			return &r
		case *_xml.TagPathError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.TagPathError]"))
}

func _mapToTagPathError(o Map) *_xml.TagPathError {
	return &_xml.TagPathError{
	}
}

func _vectorToTagPathError(o *Vector) *_xml.TagPathError {
	return &_xml.TagPathError{
	}
}

func _ConstructTagPathError(_v Object) *_xml.TagPathError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _xml.TagPathError:
			return &_g
		case *_xml.TagPathError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTagPathError(_o.(Map))
	case case *Vector:
		return _vectorToTagPathError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.TagPathError] or Map"))
}

GO TYPE encoding/xml.Token from encoding/xml/xml.go:
func ExtractGoObjectToken(args []Object, index int) *_xml.Token {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.Token:
			return &r
		case *_xml.Token:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.Token]"))
}

// func _ConstructToken(_v Object) _xml.Token {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.Token:
// 			return _g
// 		case *_xml.Token:
// 			return *_g
// 		}
// 	default:
// 		return _xml.Token(_o.ABEND674(unknown underlying type *ast.InterfaceType for Token))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.Token] or whatever"))
// }

GO TYPE encoding/xml.TokenReader from encoding/xml/xml.go:
func ExtractGoObjectTokenReader(args []Object, index int) *_xml.TokenReader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.TokenReader:
			return &r
		case *_xml.TokenReader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.TokenReader]"))
}

// func _ConstructTokenReader(_v Object) _xml.TokenReader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.TokenReader:
// 			return _g
// 		case *_xml.TokenReader:
// 			return *_g
// 		}
// 	default:
// 		return _xml.TokenReader(_o.ABEND674(unknown underlying type *ast.InterfaceType for TokenReader))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.TokenReader] or whatever"))
// }

GO TYPE encoding/xml.UnmarshalError from encoding/xml/read.go:
func ExtractGoObjectUnmarshalError(args []Object, index int) *_xml.UnmarshalError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.UnmarshalError:
			return &r
		case *_xml.UnmarshalError:
			return r
		}
	case String:
		v := _xml.UnmarshalError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.UnmarshalError]"))
}

func _ConstructUnmarshalError(_v Object) _xml.UnmarshalError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _xml.UnmarshalError:
			return _g
		case *_xml.UnmarshalError:
			return *_g
		}
	case String:
		return _xml.UnmarshalError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.UnmarshalError] or String"))
}

GO TYPE encoding/xml.Unmarshaler from encoding/xml/read.go:
func ExtractGoObjectUnmarshaler(args []Object, index int) *_xml.Unmarshaler {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.Unmarshaler:
			return &r
		case *_xml.Unmarshaler:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.Unmarshaler]"))
}

// func _ConstructUnmarshaler(_v Object) _xml.Unmarshaler {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.Unmarshaler:
// 			return _g
// 		case *_xml.Unmarshaler:
// 			return *_g
// 		}
// 	default:
// 		return _xml.Unmarshaler(_o.ABEND674(unknown underlying type *ast.InterfaceType for Unmarshaler))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.Unmarshaler] or whatever"))
// }

GO TYPE encoding/xml.UnmarshalerAttr from encoding/xml/read.go:
func ExtractGoObjectUnmarshalerAttr(args []Object, index int) *_xml.UnmarshalerAttr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.UnmarshalerAttr:
			return &r
		case *_xml.UnmarshalerAttr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.UnmarshalerAttr]"))
}

// func _ConstructUnmarshalerAttr(_v Object) _xml.UnmarshalerAttr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.UnmarshalerAttr:
// 			return _g
// 		case *_xml.UnmarshalerAttr:
// 			return *_g
// 		}
// 	default:
// 		return _xml.UnmarshalerAttr(_o.ABEND674(unknown underlying type *ast.InterfaceType for UnmarshalerAttr))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.UnmarshalerAttr] or whatever"))
// }

GO TYPE encoding/xml.UnsupportedTypeError from encoding/xml/marshal.go:
func ExtractGoObjectUnsupportedTypeError(args []Object, index int) *_xml.UnsupportedTypeError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.UnsupportedTypeError:
			return &r
		case *_xml.UnsupportedTypeError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.UnsupportedTypeError]"))
}

func _mapToUnsupportedTypeError(o Map) *_xml.UnsupportedTypeError {
	return &_xml.UnsupportedTypeError{
	}
}

func _vectorToUnsupportedTypeError(o *Vector) *_xml.UnsupportedTypeError {
	return &_xml.UnsupportedTypeError{
	}
}

func _ConstructUnsupportedTypeError(_v Object) *_xml.UnsupportedTypeError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _xml.UnsupportedTypeError:
			return &_g
		case *_xml.UnsupportedTypeError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnsupportedTypeError(_o.(Map))
	case case *Vector:
		return _vectorToUnsupportedTypeError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.UnsupportedTypeError] or Map"))
}

GO FUNC encoding/xml.CopyToken from encoding/xml/xml.go:
func __copyToken(t _xml.Token) Object {
	_res := _xml.CopyToken(t)
	return MakeGoObject(_res)
}

GO FUNC encoding/xml.Escape from encoding/xml/xml.go:
// func __escape(w ABEND987(genutils.go: imports not yet supported: io.Writer), s []byte) Object {
// 	_xml.Escape(w, s)
// 	...ABEND675: TODO...
// }

GO FUNC encoding/xml.EscapeText from encoding/xml/xml.go:
// func __escapeText(w ABEND987(genutils.go: imports not yet supported: io.Writer), s []byte)  {
// 	_res := _xml.EscapeText(w, s)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC encoding/xml.Marshal from encoding/xml/marshal.go:
// func __marshal(v interface {}) Object {
// 	_res1, _res2 := _xml.Marshal(v)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/xml.MarshalIndent from encoding/xml/marshal.go:
// func __marshalIndent(v interface {}, prefix string, indent string) Object {
// 	_res1, _res2 := _xml.MarshalIndent(v, prefix, indent)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/xml.NewDecoder from encoding/xml/xml.go:
// func __newDecoder(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _xml.NewDecoder(r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/xml.NewEncoder from encoding/xml/marshal.go:
// func __newEncoder(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _xml.NewEncoder(w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/xml.NewTokenDecoder from encoding/xml/xml.go:
func __newTokenDecoder(t _xml.TokenReader) Object {
	_res := _xml.NewTokenDecoder(t)
	return MakeGoObject(_res)
}

GO FUNC encoding/xml.Unmarshal from encoding/xml/read.go:
// func __unmarshal(data []byte, v interface {})  {
// 	_res := _xml.Unmarshal(data, v)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package xml

import (
	_xml "encoding/xml"
	. "github.com/candid82/joker/core"
)
// Auto-generated by gostd at (omitted for testing), do not edit!!

package errors

import (
)
GO TYPE expvar.Float from expvar/expvar.go:
func ExtractGoObjectFloat(args []Object, index int) *_expvar.Float {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _expvar.Float:
			return &r
		case *_expvar.Float:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[expvar.Float]"))
}

func _mapToFloat(o Map) *_expvar.Float {
	return &_expvar.Float{
	}
}

func _vectorToFloat(o *Vector) *_expvar.Float {
	return &_expvar.Float{
	}
}

func _ConstructFloat(_v Object) *_expvar.Float {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _expvar.Float:
			return &_g
		case *_expvar.Float:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFloat(_o.(Map))
	case case *Vector:
		return _vectorToFloat(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[expvar.Float] or Map"))
}

GO TYPE expvar.Func from expvar/expvar.go:
func ExtractGoObjectFunc(args []Object, index int) *_expvar.Func {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _expvar.Func:
			return &r
		case *_expvar.Func:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[expvar.Func]"))
}

// func _ConstructFunc(_v Object) _expvar.Func {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _expvar.Func:
// 			return _g
// 		case *_expvar.Func:
// 			return *_g
// 		}
// 	default:
// 		return _expvar.Func(_o.ABEND674(unknown underlying type *ast.FuncType for Func))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[expvar.Func] or whatever"))
// }

GO TYPE expvar.Int from expvar/expvar.go:
func ExtractGoObjectInt(args []Object, index int) *_expvar.Int {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _expvar.Int:
			return &r
		case *_expvar.Int:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[expvar.Int]"))
}

func _mapToInt(o Map) *_expvar.Int {
	return &_expvar.Int{
	}
}

func _vectorToInt(o *Vector) *_expvar.Int {
	return &_expvar.Int{
	}
}

func _ConstructInt(_v Object) *_expvar.Int {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _expvar.Int:
			return &_g
		case *_expvar.Int:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToInt(_o.(Map))
	case case *Vector:
		return _vectorToInt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[expvar.Int] or Map"))
}

GO TYPE expvar.KeyValue from expvar/expvar.go:
func ExtractGoObjectKeyValue(args []Object, index int) *_expvar.KeyValue {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _expvar.KeyValue:
			return &r
		case *_expvar.KeyValue:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[expvar.KeyValue]"))
}

func _mapToKeyValue(o Map) *_expvar.KeyValue {
	return &_expvar.KeyValue{
	}
}

func _vectorToKeyValue(o *Vector) *_expvar.KeyValue {
	return &_expvar.KeyValue{
	}
}

func _ConstructKeyValue(_v Object) *_expvar.KeyValue {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _expvar.KeyValue:
			return &_g
		case *_expvar.KeyValue:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToKeyValue(_o.(Map))
	case case *Vector:
		return _vectorToKeyValue(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[expvar.KeyValue] or Map"))
}

GO TYPE expvar.Map from expvar/expvar.go:
func ExtractGoObjectMap(args []Object, index int) *_expvar.Map {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _expvar.Map:
			return &r
		case *_expvar.Map:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[expvar.Map]"))
}

func _mapToMap(o Map) *_expvar.Map {
	return &_expvar.Map{
	}
}

func _vectorToMap(o *Vector) *_expvar.Map {
	return &_expvar.Map{
	}
}

func _ConstructMap(_v Object) *_expvar.Map {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _expvar.Map:
			return &_g
		case *_expvar.Map:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMap(_o.(Map))
	case case *Vector:
		return _vectorToMap(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[expvar.Map] or Map"))
}

GO TYPE expvar.String from expvar/expvar.go:
func ExtractGoObjectString(args []Object, index int) *_expvar.String {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _expvar.String:
			return &r
		case *_expvar.String:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[expvar.String]"))
}

func _mapToString(o Map) *_expvar.String {
	return &_expvar.String{
	}
}

func _vectorToString(o *Vector) *_expvar.String {
	return &_expvar.String{
	}
}

func _ConstructString(_v Object) *_expvar.String {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _expvar.String:
			return &_g
		case *_expvar.String:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToString(_o.(Map))
	case case *Vector:
		return _vectorToString(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[expvar.String] or Map"))
}

GO TYPE expvar.Var from expvar/expvar.go:
func ExtractGoObjectVar(args []Object, index int) *_expvar.Var {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _expvar.Var:
			return &r
		case *_expvar.Var:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[expvar.Var]"))
}

// func _ConstructVar(_v Object) _expvar.Var {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _expvar.Var:
// 			return _g
// 		case *_expvar.Var:
// 			return *_g
// 		}
// 	default:
// 		return _expvar.Var(_o.ABEND674(unknown underlying type *ast.InterfaceType for Var))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[expvar.Var] or whatever"))
// }

GO FUNC expvar.Do from expvar/expvar.go:
// func __do(f func) Object {
// 	_expvar.Do(f)
// 	...ABEND675: TODO...
// }

GO FUNC expvar.Get from expvar/expvar.go:
func __get(name string) Object {
	_res := _expvar.Get(name)
	return MakeGoObject(_res)
}

GO FUNC expvar.Handler from expvar/expvar.go:
func __handler() Object {
	_res := _expvar.Handler()
	return MakeGoObject(_res)
}

GO FUNC expvar.NewFloat from expvar/expvar.go:
func __newFloat(name string) Object {
	_res := _expvar.NewFloat(name)
	return MakeGoObject(_res)
}

GO FUNC expvar.NewInt from expvar/expvar.go:
func __newInt(name string) Object {
	_res := _expvar.NewInt(name)
	return MakeGoObject(_res)
}

GO FUNC expvar.NewMap from expvar/expvar.go:
func __newMap(name string) Object {
	_res := _expvar.NewMap(name)
	return MakeGoObject(_res)
}

GO FUNC expvar.NewString from expvar/expvar.go:
func __newString(name string) Object {
	_res := _expvar.NewString(name)
	return MakeGoObject(_res)
}

GO FUNC expvar.Publish from expvar/expvar.go:
// func __publish(name string, v _expvar.Var) Object {
// 	_expvar.Publish(name, v)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package expvar

import (
	_expvar "expvar"
	. "github.com/candid82/joker/core"
)
GO TYPE flag.ErrorHandling from flag/flag.go:
func ExtractGoObjectErrorHandling(args []Object, index int) *_flag.ErrorHandling {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _flag.ErrorHandling:
			return &r
		case *_flag.ErrorHandling:
			return r
		}
	case Int:
		v := _flag.ErrorHandling(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[flag.ErrorHandling]"))
}

func _ConstructErrorHandling(_v Object) _flag.ErrorHandling {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _flag.ErrorHandling:
			return _g
		case *_flag.ErrorHandling:
			return *_g
		}
	case Number:
		return _flag.ErrorHandling(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[flag.ErrorHandling] or Number"))
}

GO TYPE flag.Flag from flag/flag.go:
func ExtractGoObjectFlag(args []Object, index int) *_flag.Flag {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _flag.Flag:
			return &r
		case *_flag.Flag:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[flag.Flag]"))
}

func _mapToFlag(o Map) *_flag.Flag {
	return &_flag.Flag{
	}
}

func _vectorToFlag(o *Vector) *_flag.Flag {
	return &_flag.Flag{
	}
}

func _ConstructFlag(_v Object) *_flag.Flag {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _flag.Flag:
			return &_g
		case *_flag.Flag:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFlag(_o.(Map))
	case case *Vector:
		return _vectorToFlag(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[flag.Flag] or Map"))
}

GO TYPE flag.FlagSet from flag/flag.go:
func ExtractGoObjectFlagSet(args []Object, index int) *_flag.FlagSet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _flag.FlagSet:
			return &r
		case *_flag.FlagSet:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[flag.FlagSet]"))
}

func _mapToFlagSet(o Map) *_flag.FlagSet {
	return &_flag.FlagSet{
	}
}

func _vectorToFlagSet(o *Vector) *_flag.FlagSet {
	return &_flag.FlagSet{
	}
}

func _ConstructFlagSet(_v Object) *_flag.FlagSet {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _flag.FlagSet:
			return &_g
		case *_flag.FlagSet:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFlagSet(_o.(Map))
	case case *Vector:
		return _vectorToFlagSet(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[flag.FlagSet] or Map"))
}

GO TYPE flag.Getter from flag/flag.go:
func ExtractGoObjectGetter(args []Object, index int) *_flag.Getter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _flag.Getter:
			return &r
		case *_flag.Getter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[flag.Getter]"))
}

// func _ConstructGetter(_v Object) _flag.Getter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _flag.Getter:
// 			return _g
// 		case *_flag.Getter:
// 			return *_g
// 		}
// 	default:
// 		return _flag.Getter(_o.ABEND674(unknown underlying type *ast.InterfaceType for Getter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[flag.Getter] or whatever"))
// }

GO TYPE flag.Value from flag/flag.go:
func ExtractGoObjectValue(args []Object, index int) *_flag.Value {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _flag.Value:
			return &r
		case *_flag.Value:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[flag.Value]"))
}

// func _ConstructValue(_v Object) _flag.Value {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _flag.Value:
// 			return _g
// 		case *_flag.Value:
// 			return *_g
// 		}
// 	default:
// 		return _flag.Value(_o.ABEND674(unknown underlying type *ast.InterfaceType for Value))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[flag.Value] or whatever"))
// }

GO FUNC flag.Args from flag/flag.go:
func __args() Object {
	_res := _flag.Args()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC flag.Bool from flag/flag.go:
func __bool(name string, value bool, usage string) Object {
	_res := _flag.Bool(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.BoolVar from flag/flag.go:
// func __boolVar(p *bool, name string, value bool, usage string) Object {
// 	_flag.BoolVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Duration from flag/flag.go:
// func __duration(name string, value ABEND987(genutils.go: imports not yet supported: time.Duration), usage string) Object {
// 	_res := _flag.Duration(name, value, usage)
// 	return MakeGoObject(_res)
// }

GO FUNC flag.DurationVar from flag/flag.go:
// func __durationVar(p *ABEND987(genutils.go: imports not yet supported: time.Duration), name string, value ABEND987(genutils.go: imports not yet supported: time.Duration), usage string) Object {
// 	_flag.DurationVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Float64 from flag/flag.go:
// func __float64(name string, value float64, usage string) Object {
// 	_res := _flag.Float64(name, value, usage)
// 	return MakeGoObject(_res)
// }

GO FUNC flag.Float64Var from flag/flag.go:
// func __float64Var(p *float64, name string, value float64, usage string) Object {
// 	_flag.Float64Var(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Int from flag/flag.go:
func __int(name string, value int, usage string) Object {
	_res := _flag.Int(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.Int64 from flag/flag.go:
func __int64(name string, value int64, usage string) Object {
	_res := _flag.Int64(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.Int64Var from flag/flag.go:
// func __int64Var(p *int64, name string, value int64, usage string) Object {
// 	_flag.Int64Var(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.IntVar from flag/flag.go:
// func __intVar(p *int, name string, value int, usage string) Object {
// 	_flag.IntVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Lookup from flag/flag.go:
func __lookup(name string) Object {
	_res := _flag.Lookup(name)
	return MakeGoObject(_res)
}

GO FUNC flag.NewFlagSet from flag/flag.go:
func __newFlagSet(name string, errorHandling _flag.ErrorHandling) Object {
	_res := _flag.NewFlagSet(name, errorHandling)
	return MakeGoObject(_res)
}

GO FUNC flag.Parse from flag/flag.go:
// func __parse() Object {
// 	_flag.Parse()
// 	...ABEND675: TODO...
// }

GO FUNC flag.PrintDefaults from flag/flag.go:
// func __printDefaults() Object {
// 	_flag.PrintDefaults()
// 	...ABEND675: TODO...
// }

GO FUNC flag.String from flag/flag.go:
func __string(name string, value string, usage string) Object {
	_res := _flag.String(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.StringVar from flag/flag.go:
// func __stringVar(p *string, name string, value string, usage string) Object {
// 	_flag.StringVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Uint from flag/flag.go:
func __uint(name string, value uint, usage string) Object {
	_res := _flag.Uint(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.Uint64 from flag/flag.go:
// func __uint64(name string, value uint64, usage string) Object {
// 	_res := _flag.Uint64(name, value, usage)
// 	return MakeGoObject(_res)
// }

GO FUNC flag.Uint64Var from flag/flag.go:
// func __uint64Var(p *uint64, name string, value uint64, usage string) Object {
// 	_flag.Uint64Var(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.UintVar from flag/flag.go:
// func __uintVar(p *uint, name string, value uint, usage string) Object {
// 	_flag.UintVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.UnquoteUsage from flag/flag.go:
func __unquoteUsage(flag *_flag.Flag) Object {
	name, usage := _flag.UnquoteUsage(flag)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(name))
	_res = _res.Conjoin(MakeString(usage))
	return _res
}

GO FUNC flag.Var from flag/flag.go:
// func __var(value _flag.Value, name string, usage string) Object {
// 	_flag.Var(value, name, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Visit from flag/flag.go:
// func __visit(fn func) Object {
// 	_flag.Visit(fn)
// 	...ABEND675: TODO...
// }

GO FUNC flag.VisitAll from flag/flag.go:
// func __visitAll(fn func) Object {
// 	_flag.VisitAll(fn)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package flag

import (
	_flag "flag"
	. "github.com/candid82/joker/core"
)
GO FUNC fmt.Errorf from fmt/print.go:
// func __errorf(format string, a ...interface {})  {
// 	_res := _fmt.Errorf(format, a)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC fmt.Fprint from fmt/print.go:
// func __fprint(w ABEND987(genutils.go: imports not yet supported: io.Writer), a ...interface {}) Object {
// 	n, err := _fmt.Fprint(w, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Fprintf from fmt/print.go:
// func __fprintf(w ABEND987(genutils.go: imports not yet supported: io.Writer), format string, a ...interface {}) Object {
// 	n, err := _fmt.Fprintf(w, format, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Fprintln from fmt/print.go:
// func __fprintln(w ABEND987(genutils.go: imports not yet supported: io.Writer), a ...interface {}) Object {
// 	n, err := _fmt.Fprintln(w, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Fscan from fmt/scan.go:
// func __fscan(r ABEND987(genutils.go: imports not yet supported: io.Reader), a ...interface {}) Object {
// 	n, err := _fmt.Fscan(r, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Fscanf from fmt/scan.go:
// func __fscanf(r ABEND987(genutils.go: imports not yet supported: io.Reader), format string, a ...interface {}) Object {
// 	n, err := _fmt.Fscanf(r, format, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Fscanln from fmt/scan.go:
// func __fscanln(r ABEND987(genutils.go: imports not yet supported: io.Reader), a ...interface {}) Object {
// 	n, err := _fmt.Fscanln(r, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Print from fmt/print.go:
// func __print(a ...interface {}) Object {
// 	n, err := _fmt.Print(a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Printf from fmt/print.go:
// func __printf(format string, a ...interface {}) Object {
// 	n, err := _fmt.Printf(format, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Println from fmt/print.go:
// func __println(a ...interface {}) Object {
// 	n, err := _fmt.Println(a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Scan from fmt/scan.go:
// func __scan(a ...interface {}) Object {
// 	n, err := _fmt.Scan(a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Scanf from fmt/scan.go:
// func __scanf(format string, a ...interface {}) Object {
// 	n, err := _fmt.Scanf(format, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Scanln from fmt/scan.go:
// func __scanln(a ...interface {}) Object {
// 	n, err := _fmt.Scanln(a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Sprint from fmt/print.go:
// func __sprint(a ...interface {})  {
// 	_res := _fmt.Sprint(a)
// 	return MakeString(_res)
// }

GO FUNC fmt.Sprintf from fmt/print.go:
// func __sprintf(format string, a ...interface {})  {
// 	_res := _fmt.Sprintf(format, a)
// 	return MakeString(_res)
// }

GO FUNC fmt.Sprintln from fmt/print.go:
// func __sprintln(a ...interface {})  {
// 	_res := _fmt.Sprintln(a)
// 	return MakeString(_res)
// }

GO FUNC fmt.Sscan from fmt/scan.go:
// func __sscan(str string, a ...interface {}) Object {
// 	n, err := _fmt.Sscan(str, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Sscanf from fmt/scan.go:
// func __sscanf(str string, format string, a ...interface {}) Object {
// 	n, err := _fmt.Sscanf(str, format, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Sscanln from fmt/scan.go:
// func __sscanln(str string, a ...interface {}) Object {
// 	n, err := _fmt.Sscanln(str, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO TYPE go/ast.ArrayType from go/ast/ast.go:
func ExtractGoObjectArrayType(args []Object, index int) *_ast.ArrayType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.ArrayType:
			return &r
		case *_ast.ArrayType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.ArrayType]"))
}

func _mapToArrayType(o Map) *_ast.ArrayType {
	return &_ast.ArrayType{
	}
}

func _vectorToArrayType(o *Vector) *_ast.ArrayType {
	return &_ast.ArrayType{
	}
}

func _ConstructArrayType(_v Object) *_ast.ArrayType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.ArrayType:
			return &_g
		case *_ast.ArrayType:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToArrayType(_o.(Map))
	case case *Vector:
		return _vectorToArrayType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.ArrayType] or Map"))
}

GO TYPE go/ast.AssignStmt from go/ast/ast.go:
func ExtractGoObjectAssignStmt(args []Object, index int) *_ast.AssignStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.AssignStmt:
			return &r
		case *_ast.AssignStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.AssignStmt]"))
}

func _mapToAssignStmt(o Map) *_ast.AssignStmt {
	return &_ast.AssignStmt{
	}
}

func _vectorToAssignStmt(o *Vector) *_ast.AssignStmt {
	return &_ast.AssignStmt{
	}
}

func _ConstructAssignStmt(_v Object) *_ast.AssignStmt {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.AssignStmt:
			return &_g
		case *_ast.AssignStmt:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToAssignStmt(_o.(Map))
	case case *Vector:
		return _vectorToAssignStmt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.AssignStmt] or Map"))
}

GO TYPE go/ast.BadDecl from go/ast/ast.go:
func ExtractGoObjectBadDecl(args []Object, index int) *_ast.BadDecl {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.BadDecl:
			return &r
		case *_ast.BadDecl:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.BadDecl]"))
}

func _mapToBadDecl(o Map) *_ast.BadDecl {
	return &_ast.BadDecl{
	}
}

func _vectorToBadDecl(o *Vector) *_ast.BadDecl {
	return &_ast.BadDecl{
	}
}

func _ConstructBadDecl(_v Object) *_ast.BadDecl {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.BadDecl:
			return &_g
		case *_ast.BadDecl:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBadDecl(_o.(Map))
	case case *Vector:
		return _vectorToBadDecl(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.BadDecl] or Map"))
}

GO TYPE go/ast.BadExpr from go/ast/ast.go:
func ExtractGoObjectBadExpr(args []Object, index int) *_ast.BadExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.BadExpr:
			return &r
		case *_ast.BadExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.BadExpr]"))
}

func _mapToBadExpr(o Map) *_ast.BadExpr {
	return &_ast.BadExpr{
	}
}

func _vectorToBadExpr(o *Vector) *_ast.BadExpr {
	return &_ast.BadExpr{
	}
}

func _ConstructBadExpr(_v Object) *_ast.BadExpr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.BadExpr:
			return &_g
		case *_ast.BadExpr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBadExpr(_o.(Map))
	case case *Vector:
		return _vectorToBadExpr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.BadExpr] or Map"))
}

GO TYPE go/ast.BadStmt from go/ast/ast.go:
func ExtractGoObjectBadStmt(args []Object, index int) *_ast.BadStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.BadStmt:
			return &r
		case *_ast.BadStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.BadStmt]"))
}

func _mapToBadStmt(o Map) *_ast.BadStmt {
	return &_ast.BadStmt{
	}
}

func _vectorToBadStmt(o *Vector) *_ast.BadStmt {
	return &_ast.BadStmt{
	}
}

func _ConstructBadStmt(_v Object) *_ast.BadStmt {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.BadStmt:
			return &_g
		case *_ast.BadStmt:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBadStmt(_o.(Map))
	case case *Vector:
		return _vectorToBadStmt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.BadStmt] or Map"))
}

GO TYPE go/ast.BasicLit from go/ast/ast.go:
func ExtractGoObjectBasicLit(args []Object, index int) *_ast.BasicLit {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.BasicLit:
			return &r
		case *_ast.BasicLit:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.BasicLit]"))
}

func _mapToBasicLit(o Map) *_ast.BasicLit {
	return &_ast.BasicLit{
	}
}

func _vectorToBasicLit(o *Vector) *_ast.BasicLit {
	return &_ast.BasicLit{
	}
}

func _ConstructBasicLit(_v Object) *_ast.BasicLit {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.BasicLit:
			return &_g
		case *_ast.BasicLit:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBasicLit(_o.(Map))
	case case *Vector:
		return _vectorToBasicLit(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.BasicLit] or Map"))
}

GO TYPE go/ast.BinaryExpr from go/ast/ast.go:
func ExtractGoObjectBinaryExpr(args []Object, index int) *_ast.BinaryExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.BinaryExpr:
			return &r
		case *_ast.BinaryExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.BinaryExpr]"))
}

func _mapToBinaryExpr(o Map) *_ast.BinaryExpr {
	return &_ast.BinaryExpr{
	}
}

func _vectorToBinaryExpr(o *Vector) *_ast.BinaryExpr {
	return &_ast.BinaryExpr{
	}
}

func _ConstructBinaryExpr(_v Object) *_ast.BinaryExpr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.BinaryExpr:
			return &_g
		case *_ast.BinaryExpr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBinaryExpr(_o.(Map))
	case case *Vector:
		return _vectorToBinaryExpr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.BinaryExpr] or Map"))
}

GO TYPE go/ast.BlockStmt from go/ast/ast.go:
func ExtractGoObjectBlockStmt(args []Object, index int) *_ast.BlockStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.BlockStmt:
			return &r
		case *_ast.BlockStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.BlockStmt]"))
}

func _mapToBlockStmt(o Map) *_ast.BlockStmt {
	return &_ast.BlockStmt{
	}
}

func _vectorToBlockStmt(o *Vector) *_ast.BlockStmt {
	return &_ast.BlockStmt{
	}
}

func _ConstructBlockStmt(_v Object) *_ast.BlockStmt {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.BlockStmt:
			return &_g
		case *_ast.BlockStmt:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBlockStmt(_o.(Map))
	case case *Vector:
		return _vectorToBlockStmt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.BlockStmt] or Map"))
}

GO TYPE go/ast.BranchStmt from go/ast/ast.go:
func ExtractGoObjectBranchStmt(args []Object, index int) *_ast.BranchStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.BranchStmt:
			return &r
		case *_ast.BranchStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.BranchStmt]"))
}

func _mapToBranchStmt(o Map) *_ast.BranchStmt {
	return &_ast.BranchStmt{
	}
}

func _vectorToBranchStmt(o *Vector) *_ast.BranchStmt {
	return &_ast.BranchStmt{
	}
}

func _ConstructBranchStmt(_v Object) *_ast.BranchStmt {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.BranchStmt:
			return &_g
		case *_ast.BranchStmt:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBranchStmt(_o.(Map))
	case case *Vector:
		return _vectorToBranchStmt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.BranchStmt] or Map"))
}

GO TYPE go/ast.CallExpr from go/ast/ast.go:
func ExtractGoObjectCallExpr(args []Object, index int) *_ast.CallExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.CallExpr:
			return &r
		case *_ast.CallExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.CallExpr]"))
}

func _mapToCallExpr(o Map) *_ast.CallExpr {
	return &_ast.CallExpr{
	}
}

func _vectorToCallExpr(o *Vector) *_ast.CallExpr {
	return &_ast.CallExpr{
	}
}

func _ConstructCallExpr(_v Object) *_ast.CallExpr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.CallExpr:
			return &_g
		case *_ast.CallExpr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCallExpr(_o.(Map))
	case case *Vector:
		return _vectorToCallExpr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.CallExpr] or Map"))
}

GO TYPE go/ast.CaseClause from go/ast/ast.go:
func ExtractGoObjectCaseClause(args []Object, index int) *_ast.CaseClause {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.CaseClause:
			return &r
		case *_ast.CaseClause:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.CaseClause]"))
}

func _mapToCaseClause(o Map) *_ast.CaseClause {
	return &_ast.CaseClause{
	}
}

func _vectorToCaseClause(o *Vector) *_ast.CaseClause {
	return &_ast.CaseClause{
	}
}

func _ConstructCaseClause(_v Object) *_ast.CaseClause {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.CaseClause:
			return &_g
		case *_ast.CaseClause:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCaseClause(_o.(Map))
	case case *Vector:
		return _vectorToCaseClause(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.CaseClause] or Map"))
}

GO TYPE go/ast.ChanDir from go/ast/ast.go:
func ExtractGoObjectChanDir(args []Object, index int) *_ast.ChanDir {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.ChanDir:
			return &r
		case *_ast.ChanDir:
			return r
		}
	case Int:
		v := _ast.ChanDir(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.ChanDir]"))
}

func _ConstructChanDir(_v Object) _ast.ChanDir {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.ChanDir:
			return _g
		case *_ast.ChanDir:
			return *_g
		}
	case Number:
		return _ast.ChanDir(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.ChanDir] or Number"))
}

GO TYPE go/ast.ChanType from go/ast/ast.go:
func ExtractGoObjectChanType(args []Object, index int) *_ast.ChanType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.ChanType:
			return &r
		case *_ast.ChanType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.ChanType]"))
}

func _mapToChanType(o Map) *_ast.ChanType {
	return &_ast.ChanType{
	}
}

func _vectorToChanType(o *Vector) *_ast.ChanType {
	return &_ast.ChanType{
	}
}

func _ConstructChanType(_v Object) *_ast.ChanType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.ChanType:
			return &_g
		case *_ast.ChanType:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToChanType(_o.(Map))
	case case *Vector:
		return _vectorToChanType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.ChanType] or Map"))
}

GO TYPE go/ast.CommClause from go/ast/ast.go:
func ExtractGoObjectCommClause(args []Object, index int) *_ast.CommClause {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.CommClause:
			return &r
		case *_ast.CommClause:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.CommClause]"))
}

func _mapToCommClause(o Map) *_ast.CommClause {
	return &_ast.CommClause{
	}
}

func _vectorToCommClause(o *Vector) *_ast.CommClause {
	return &_ast.CommClause{
	}
}

func _ConstructCommClause(_v Object) *_ast.CommClause {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.CommClause:
			return &_g
		case *_ast.CommClause:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCommClause(_o.(Map))
	case case *Vector:
		return _vectorToCommClause(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.CommClause] or Map"))
}

GO TYPE go/ast.Comment from go/ast/ast.go:
func ExtractGoObjectComment(args []Object, index int) *_ast.Comment {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Comment:
			return &r
		case *_ast.Comment:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Comment]"))
}

func _mapToComment(o Map) *_ast.Comment {
	return &_ast.Comment{
	}
}

func _vectorToComment(o *Vector) *_ast.Comment {
	return &_ast.Comment{
	}
}

func _ConstructComment(_v Object) *_ast.Comment {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.Comment:
			return &_g
		case *_ast.Comment:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToComment(_o.(Map))
	case case *Vector:
		return _vectorToComment(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Comment] or Map"))
}

GO TYPE go/ast.CommentGroup from go/ast/ast.go:
func ExtractGoObjectCommentGroup(args []Object, index int) *_ast.CommentGroup {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.CommentGroup:
			return &r
		case *_ast.CommentGroup:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.CommentGroup]"))
}

func _mapToCommentGroup(o Map) *_ast.CommentGroup {
	return &_ast.CommentGroup{
	}
}

func _vectorToCommentGroup(o *Vector) *_ast.CommentGroup {
	return &_ast.CommentGroup{
	}
}

func _ConstructCommentGroup(_v Object) *_ast.CommentGroup {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.CommentGroup:
			return &_g
		case *_ast.CommentGroup:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCommentGroup(_o.(Map))
	case case *Vector:
		return _vectorToCommentGroup(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.CommentGroup] or Map"))
}

GO TYPE go/ast.CommentMap from go/ast/commentmap.go:
func ExtractGoObjectCommentMap(args []Object, index int) *_ast.CommentMap {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.CommentMap:
			return &r
		case *_ast.CommentMap:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.CommentMap]"))
}

// func _ConstructCommentMap(_v Object) _ast.CommentMap {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.CommentMap:
// 			return _g
// 		case *_ast.CommentMap:
// 			return *_g
// 		}
// 	default:
// 		return _ast.CommentMap(_o.ABEND674(unknown underlying type *ast.MapType for CommentMap))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.CommentMap] or whatever"))
// }

GO TYPE go/ast.CompositeLit from go/ast/ast.go:
func ExtractGoObjectCompositeLit(args []Object, index int) *_ast.CompositeLit {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.CompositeLit:
			return &r
		case *_ast.CompositeLit:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.CompositeLit]"))
}

func _mapToCompositeLit(o Map) *_ast.CompositeLit {
	return &_ast.CompositeLit{
	}
}

func _vectorToCompositeLit(o *Vector) *_ast.CompositeLit {
	return &_ast.CompositeLit{
	}
}

func _ConstructCompositeLit(_v Object) *_ast.CompositeLit {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.CompositeLit:
			return &_g
		case *_ast.CompositeLit:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCompositeLit(_o.(Map))
	case case *Vector:
		return _vectorToCompositeLit(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.CompositeLit] or Map"))
}

GO TYPE go/ast.Decl from go/ast/ast.go:
func ExtractGoObjectDecl(args []Object, index int) *_ast.Decl {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Decl:
			return &r
		case *_ast.Decl:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Decl]"))
}

// func _ConstructDecl(_v Object) _ast.Decl {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Decl:
// 			return _g
// 		case *_ast.Decl:
// 			return *_g
// 		}
// 	default:
// 		return _ast.Decl(_o.ABEND674(unknown underlying type *ast.InterfaceType for Decl))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Decl] or whatever"))
// }

GO TYPE go/ast.DeclStmt from go/ast/ast.go:
func ExtractGoObjectDeclStmt(args []Object, index int) *_ast.DeclStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.DeclStmt:
			return &r
		case *_ast.DeclStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.DeclStmt]"))
}

func _mapToDeclStmt(o Map) *_ast.DeclStmt {
	return &_ast.DeclStmt{
	}
}

func _vectorToDeclStmt(o *Vector) *_ast.DeclStmt {
	return &_ast.DeclStmt{
	}
}

func _ConstructDeclStmt(_v Object) *_ast.DeclStmt {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.DeclStmt:
			return &_g
		case *_ast.DeclStmt:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDeclStmt(_o.(Map))
	case case *Vector:
		return _vectorToDeclStmt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.DeclStmt] or Map"))
}

GO TYPE go/ast.DeferStmt from go/ast/ast.go:
func ExtractGoObjectDeferStmt(args []Object, index int) *_ast.DeferStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.DeferStmt:
			return &r
		case *_ast.DeferStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.DeferStmt]"))
}

func _mapToDeferStmt(o Map) *_ast.DeferStmt {
	return &_ast.DeferStmt{
	}
}

func _vectorToDeferStmt(o *Vector) *_ast.DeferStmt {
	return &_ast.DeferStmt{
	}
}

func _ConstructDeferStmt(_v Object) *_ast.DeferStmt {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.DeferStmt:
			return &_g
		case *_ast.DeferStmt:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDeferStmt(_o.(Map))
	case case *Vector:
		return _vectorToDeferStmt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.DeferStmt] or Map"))
}

GO TYPE go/ast.Ellipsis from go/ast/ast.go:
func ExtractGoObjectEllipsis(args []Object, index int) *_ast.Ellipsis {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Ellipsis:
			return &r
		case *_ast.Ellipsis:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Ellipsis]"))
}

func _mapToEllipsis(o Map) *_ast.Ellipsis {
	return &_ast.Ellipsis{
	}
}

func _vectorToEllipsis(o *Vector) *_ast.Ellipsis {
	return &_ast.Ellipsis{
	}
}

func _ConstructEllipsis(_v Object) *_ast.Ellipsis {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.Ellipsis:
			return &_g
		case *_ast.Ellipsis:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToEllipsis(_o.(Map))
	case case *Vector:
		return _vectorToEllipsis(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Ellipsis] or Map"))
}

GO TYPE go/ast.EmptyStmt from go/ast/ast.go:
func ExtractGoObjectEmptyStmt(args []Object, index int) *_ast.EmptyStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.EmptyStmt:
			return &r
		case *_ast.EmptyStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.EmptyStmt]"))
}

func _mapToEmptyStmt(o Map) *_ast.EmptyStmt {
	return &_ast.EmptyStmt{
	}
}

func _vectorToEmptyStmt(o *Vector) *_ast.EmptyStmt {
	return &_ast.EmptyStmt{
	}
}

func _ConstructEmptyStmt(_v Object) *_ast.EmptyStmt {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.EmptyStmt:
			return &_g
		case *_ast.EmptyStmt:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToEmptyStmt(_o.(Map))
	case case *Vector:
		return _vectorToEmptyStmt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.EmptyStmt] or Map"))
}

GO TYPE go/ast.Expr from go/ast/ast.go:
func ExtractGoObjectExpr(args []Object, index int) *_ast.Expr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Expr:
			return &r
		case *_ast.Expr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Expr]"))
}

// func _ConstructExpr(_v Object) _ast.Expr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Expr:
// 			return _g
// 		case *_ast.Expr:
// 			return *_g
// 		}
// 	default:
// 		return _ast.Expr(_o.ABEND674(unknown underlying type *ast.InterfaceType for Expr))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Expr] or whatever"))
// }

GO TYPE go/ast.ExprStmt from go/ast/ast.go:
func ExtractGoObjectExprStmt(args []Object, index int) *_ast.ExprStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.ExprStmt:
			return &r
		case *_ast.ExprStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.ExprStmt]"))
}

func _mapToExprStmt(o Map) *_ast.ExprStmt {
	return &_ast.ExprStmt{
	}
}

func _vectorToExprStmt(o *Vector) *_ast.ExprStmt {
	return &_ast.ExprStmt{
	}
}

func _ConstructExprStmt(_v Object) *_ast.ExprStmt {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.ExprStmt:
			return &_g
		case *_ast.ExprStmt:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToExprStmt(_o.(Map))
	case case *Vector:
		return _vectorToExprStmt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.ExprStmt] or Map"))
}

GO TYPE go/ast.Field from go/ast/ast.go:
func ExtractGoObjectField(args []Object, index int) *_ast.Field {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Field:
			return &r
		case *_ast.Field:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Field]"))
}

func _mapToField(o Map) *_ast.Field {
	return &_ast.Field{
	}
}

func _vectorToField(o *Vector) *_ast.Field {
	return &_ast.Field{
	}
}

func _ConstructField(_v Object) *_ast.Field {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.Field:
			return &_g
		case *_ast.Field:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToField(_o.(Map))
	case case *Vector:
		return _vectorToField(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Field] or Map"))
}

GO TYPE go/ast.FieldFilter from go/ast/print.go:
func ExtractGoObjectFieldFilter(args []Object, index int) *_ast.FieldFilter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.FieldFilter:
			return &r
		case *_ast.FieldFilter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.FieldFilter]"))
}

// func _ConstructFieldFilter(_v Object) _ast.FieldFilter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.FieldFilter:
// 			return _g
// 		case *_ast.FieldFilter:
// 			return *_g
// 		}
// 	default:
// 		return _ast.FieldFilter(_o.ABEND674(unknown underlying type *ast.FuncType for FieldFilter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.FieldFilter] or whatever"))
// }

GO TYPE go/ast.FieldList from go/ast/ast.go:
func ExtractGoObjectFieldList(args []Object, index int) *_ast.FieldList {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.FieldList:
			return &r
		case *_ast.FieldList:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.FieldList]"))
}

func _mapToFieldList(o Map) *_ast.FieldList {
	return &_ast.FieldList{
	}
}

func _vectorToFieldList(o *Vector) *_ast.FieldList {
	return &_ast.FieldList{
	}
}

func _ConstructFieldList(_v Object) *_ast.FieldList {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.FieldList:
			return &_g
		case *_ast.FieldList:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFieldList(_o.(Map))
	case case *Vector:
		return _vectorToFieldList(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.FieldList] or Map"))
}

GO TYPE go/ast.File from go/ast/ast.go:
func ExtractGoObjectFile(args []Object, index int) *_ast.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.File:
			return &r
		case *_ast.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.File]"))
}

func _mapToFile(o Map) *_ast.File {
	return &_ast.File{
	}
}

func _vectorToFile(o *Vector) *_ast.File {
	return &_ast.File{
	}
}

func _ConstructFile(_v Object) *_ast.File {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.File:
			return &_g
		case *_ast.File:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFile(_o.(Map))
	case case *Vector:
		return _vectorToFile(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.File] or Map"))
}

GO TYPE go/ast.Filter from go/ast/filter.go:
func ExtractGoObjectFilter(args []Object, index int) *_ast.Filter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Filter:
			return &r
		case *_ast.Filter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Filter]"))
}

// func _ConstructFilter(_v Object) _ast.Filter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Filter:
// 			return _g
// 		case *_ast.Filter:
// 			return *_g
// 		}
// 	default:
// 		return _ast.Filter(_o.ABEND674(unknown underlying type *ast.FuncType for Filter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Filter] or whatever"))
// }

GO TYPE go/ast.ForStmt from go/ast/ast.go:
func ExtractGoObjectForStmt(args []Object, index int) *_ast.ForStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.ForStmt:
			return &r
		case *_ast.ForStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.ForStmt]"))
}

func _mapToForStmt(o Map) *_ast.ForStmt {
	return &_ast.ForStmt{
	}
}

func _vectorToForStmt(o *Vector) *_ast.ForStmt {
	return &_ast.ForStmt{
	}
}

func _ConstructForStmt(_v Object) *_ast.ForStmt {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.ForStmt:
			return &_g
		case *_ast.ForStmt:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToForStmt(_o.(Map))
	case case *Vector:
		return _vectorToForStmt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.ForStmt] or Map"))
}

GO TYPE go/ast.FuncDecl from go/ast/ast.go:
func ExtractGoObjectFuncDecl(args []Object, index int) *_ast.FuncDecl {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.FuncDecl:
			return &r
		case *_ast.FuncDecl:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.FuncDecl]"))
}

func _mapToFuncDecl(o Map) *_ast.FuncDecl {
	return &_ast.FuncDecl{
	}
}

func _vectorToFuncDecl(o *Vector) *_ast.FuncDecl {
	return &_ast.FuncDecl{
	}
}

func _ConstructFuncDecl(_v Object) *_ast.FuncDecl {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.FuncDecl:
			return &_g
		case *_ast.FuncDecl:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFuncDecl(_o.(Map))
	case case *Vector:
		return _vectorToFuncDecl(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.FuncDecl] or Map"))
}

GO TYPE go/ast.FuncLit from go/ast/ast.go:
func ExtractGoObjectFuncLit(args []Object, index int) *_ast.FuncLit {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.FuncLit:
			return &r
		case *_ast.FuncLit:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.FuncLit]"))
}

func _mapToFuncLit(o Map) *_ast.FuncLit {
	return &_ast.FuncLit{
	}
}

func _vectorToFuncLit(o *Vector) *_ast.FuncLit {
	return &_ast.FuncLit{
	}
}

func _ConstructFuncLit(_v Object) *_ast.FuncLit {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.FuncLit:
			return &_g
		case *_ast.FuncLit:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFuncLit(_o.(Map))
	case case *Vector:
		return _vectorToFuncLit(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.FuncLit] or Map"))
}

GO TYPE go/ast.FuncType from go/ast/ast.go:
func ExtractGoObjectFuncType(args []Object, index int) *_ast.FuncType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.FuncType:
			return &r
		case *_ast.FuncType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.FuncType]"))
}

func _mapToFuncType(o Map) *_ast.FuncType {
	return &_ast.FuncType{
	}
}

func _vectorToFuncType(o *Vector) *_ast.FuncType {
	return &_ast.FuncType{
	}
}

func _ConstructFuncType(_v Object) *_ast.FuncType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.FuncType:
			return &_g
		case *_ast.FuncType:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFuncType(_o.(Map))
	case case *Vector:
		return _vectorToFuncType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.FuncType] or Map"))
}

GO TYPE go/ast.GenDecl from go/ast/ast.go:
func ExtractGoObjectGenDecl(args []Object, index int) *_ast.GenDecl {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.GenDecl:
			return &r
		case *_ast.GenDecl:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.GenDecl]"))
}

func _mapToGenDecl(o Map) *_ast.GenDecl {
	return &_ast.GenDecl{
	}
}

func _vectorToGenDecl(o *Vector) *_ast.GenDecl {
	return &_ast.GenDecl{
	}
}

func _ConstructGenDecl(_v Object) *_ast.GenDecl {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.GenDecl:
			return &_g
		case *_ast.GenDecl:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToGenDecl(_o.(Map))
	case case *Vector:
		return _vectorToGenDecl(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.GenDecl] or Map"))
}

GO TYPE go/ast.GoStmt from go/ast/ast.go:
func ExtractGoObjectGoStmt(args []Object, index int) *_ast.GoStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.GoStmt:
			return &r
		case *_ast.GoStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.GoStmt]"))
}

func _mapToGoStmt(o Map) *_ast.GoStmt {
	return &_ast.GoStmt{
	}
}

func _vectorToGoStmt(o *Vector) *_ast.GoStmt {
	return &_ast.GoStmt{
	}
}

func _ConstructGoStmt(_v Object) *_ast.GoStmt {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.GoStmt:
			return &_g
		case *_ast.GoStmt:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToGoStmt(_o.(Map))
	case case *Vector:
		return _vectorToGoStmt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.GoStmt] or Map"))
}

GO TYPE go/ast.Ident from go/ast/ast.go:
func ExtractGoObjectIdent(args []Object, index int) *_ast.Ident {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Ident:
			return &r
		case *_ast.Ident:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Ident]"))
}

func _mapToIdent(o Map) *_ast.Ident {
	return &_ast.Ident{
	}
}

func _vectorToIdent(o *Vector) *_ast.Ident {
	return &_ast.Ident{
	}
}

func _ConstructIdent(_v Object) *_ast.Ident {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.Ident:
			return &_g
		case *_ast.Ident:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIdent(_o.(Map))
	case case *Vector:
		return _vectorToIdent(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Ident] or Map"))
}

GO TYPE go/ast.IfStmt from go/ast/ast.go:
func ExtractGoObjectIfStmt(args []Object, index int) *_ast.IfStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.IfStmt:
			return &r
		case *_ast.IfStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.IfStmt]"))
}

func _mapToIfStmt(o Map) *_ast.IfStmt {
	return &_ast.IfStmt{
	}
}

func _vectorToIfStmt(o *Vector) *_ast.IfStmt {
	return &_ast.IfStmt{
	}
}

func _ConstructIfStmt(_v Object) *_ast.IfStmt {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.IfStmt:
			return &_g
		case *_ast.IfStmt:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIfStmt(_o.(Map))
	case case *Vector:
		return _vectorToIfStmt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.IfStmt] or Map"))
}

GO TYPE go/ast.ImportSpec from go/ast/ast.go:
func ExtractGoObjectImportSpec(args []Object, index int) *_ast.ImportSpec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.ImportSpec:
			return &r
		case *_ast.ImportSpec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.ImportSpec]"))
}

func _mapToImportSpec(o Map) *_ast.ImportSpec {
	return &_ast.ImportSpec{
	}
}

func _vectorToImportSpec(o *Vector) *_ast.ImportSpec {
	return &_ast.ImportSpec{
	}
}

func _ConstructImportSpec(_v Object) *_ast.ImportSpec {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.ImportSpec:
			return &_g
		case *_ast.ImportSpec:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToImportSpec(_o.(Map))
	case case *Vector:
		return _vectorToImportSpec(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.ImportSpec] or Map"))
}

GO TYPE go/ast.Importer from go/ast/resolve.go:
func ExtractGoObjectImporter(args []Object, index int) *_ast.Importer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Importer:
			return &r
		case *_ast.Importer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Importer]"))
}

// func _ConstructImporter(_v Object) _ast.Importer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Importer:
// 			return _g
// 		case *_ast.Importer:
// 			return *_g
// 		}
// 	default:
// 		return _ast.Importer(_o.ABEND674(unknown underlying type *ast.FuncType for Importer))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Importer] or whatever"))
// }

GO TYPE go/ast.IncDecStmt from go/ast/ast.go:
func ExtractGoObjectIncDecStmt(args []Object, index int) *_ast.IncDecStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.IncDecStmt:
			return &r
		case *_ast.IncDecStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.IncDecStmt]"))
}

func _mapToIncDecStmt(o Map) *_ast.IncDecStmt {
	return &_ast.IncDecStmt{
	}
}

func _vectorToIncDecStmt(o *Vector) *_ast.IncDecStmt {
	return &_ast.IncDecStmt{
	}
}

func _ConstructIncDecStmt(_v Object) *_ast.IncDecStmt {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.IncDecStmt:
			return &_g
		case *_ast.IncDecStmt:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIncDecStmt(_o.(Map))
	case case *Vector:
		return _vectorToIncDecStmt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.IncDecStmt] or Map"))
}

GO TYPE go/ast.IndexExpr from go/ast/ast.go:
func ExtractGoObjectIndexExpr(args []Object, index int) *_ast.IndexExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.IndexExpr:
			return &r
		case *_ast.IndexExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.IndexExpr]"))
}

func _mapToIndexExpr(o Map) *_ast.IndexExpr {
	return &_ast.IndexExpr{
	}
}

func _vectorToIndexExpr(o *Vector) *_ast.IndexExpr {
	return &_ast.IndexExpr{
	}
}

func _ConstructIndexExpr(_v Object) *_ast.IndexExpr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.IndexExpr:
			return &_g
		case *_ast.IndexExpr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIndexExpr(_o.(Map))
	case case *Vector:
		return _vectorToIndexExpr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.IndexExpr] or Map"))
}

GO TYPE go/ast.InterfaceType from go/ast/ast.go:
func ExtractGoObjectInterfaceType(args []Object, index int) *_ast.InterfaceType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.InterfaceType:
			return &r
		case *_ast.InterfaceType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.InterfaceType]"))
}

func _mapToInterfaceType(o Map) *_ast.InterfaceType {
	return &_ast.InterfaceType{
	}
}

func _vectorToInterfaceType(o *Vector) *_ast.InterfaceType {
	return &_ast.InterfaceType{
	}
}

func _ConstructInterfaceType(_v Object) *_ast.InterfaceType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.InterfaceType:
			return &_g
		case *_ast.InterfaceType:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToInterfaceType(_o.(Map))
	case case *Vector:
		return _vectorToInterfaceType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.InterfaceType] or Map"))
}

GO TYPE go/ast.KeyValueExpr from go/ast/ast.go:
func ExtractGoObjectKeyValueExpr(args []Object, index int) *_ast.KeyValueExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.KeyValueExpr:
			return &r
		case *_ast.KeyValueExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.KeyValueExpr]"))
}

func _mapToKeyValueExpr(o Map) *_ast.KeyValueExpr {
	return &_ast.KeyValueExpr{
	}
}

func _vectorToKeyValueExpr(o *Vector) *_ast.KeyValueExpr {
	return &_ast.KeyValueExpr{
	}
}

func _ConstructKeyValueExpr(_v Object) *_ast.KeyValueExpr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.KeyValueExpr:
			return &_g
		case *_ast.KeyValueExpr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToKeyValueExpr(_o.(Map))
	case case *Vector:
		return _vectorToKeyValueExpr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.KeyValueExpr] or Map"))
}

GO TYPE go/ast.LabeledStmt from go/ast/ast.go:
func ExtractGoObjectLabeledStmt(args []Object, index int) *_ast.LabeledStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.LabeledStmt:
			return &r
		case *_ast.LabeledStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.LabeledStmt]"))
}

func _mapToLabeledStmt(o Map) *_ast.LabeledStmt {
	return &_ast.LabeledStmt{
	}
}

func _vectorToLabeledStmt(o *Vector) *_ast.LabeledStmt {
	return &_ast.LabeledStmt{
	}
}

func _ConstructLabeledStmt(_v Object) *_ast.LabeledStmt {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.LabeledStmt:
			return &_g
		case *_ast.LabeledStmt:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToLabeledStmt(_o.(Map))
	case case *Vector:
		return _vectorToLabeledStmt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.LabeledStmt] or Map"))
}

GO TYPE go/ast.MapType from go/ast/ast.go:
func ExtractGoObjectMapType(args []Object, index int) *_ast.MapType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.MapType:
			return &r
		case *_ast.MapType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.MapType]"))
}

func _mapToMapType(o Map) *_ast.MapType {
	return &_ast.MapType{
	}
}

func _vectorToMapType(o *Vector) *_ast.MapType {
	return &_ast.MapType{
	}
}

func _ConstructMapType(_v Object) *_ast.MapType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.MapType:
			return &_g
		case *_ast.MapType:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMapType(_o.(Map))
	case case *Vector:
		return _vectorToMapType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.MapType] or Map"))
}

GO TYPE go/ast.MergeMode from go/ast/filter.go:
func ExtractGoObjectMergeMode(args []Object, index int) *_ast.MergeMode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.MergeMode:
			return &r
		case *_ast.MergeMode:
			return r
		}
	case Number:
		v := _ast.MergeMode(ExtractUInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.MergeMode]"))
}

func _ConstructMergeMode(_v Object) _ast.MergeMode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.MergeMode:
			return _g
		case *_ast.MergeMode:
			return *_g
		}
	case Number:
		return _ast.MergeMode(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.MergeMode] or Number"))
}

GO TYPE go/ast.Node from go/ast/ast.go:
func ExtractGoObjectNode(args []Object, index int) *_ast.Node {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Node:
			return &r
		case *_ast.Node:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Node]"))
}

// func _ConstructNode(_v Object) _ast.Node {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Node:
// 			return _g
// 		case *_ast.Node:
// 			return *_g
// 		}
// 	default:
// 		return _ast.Node(_o.ABEND674(unknown underlying type *ast.InterfaceType for Node))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Node] or whatever"))
// }

GO TYPE go/ast.ObjKind from go/ast/scope.go:
func ExtractGoObjectObjKind(args []Object, index int) *_ast.ObjKind {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.ObjKind:
			return &r
		case *_ast.ObjKind:
			return r
		}
	case Int:
		v := _ast.ObjKind(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.ObjKind]"))
}

func _ConstructObjKind(_v Object) _ast.ObjKind {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.ObjKind:
			return _g
		case *_ast.ObjKind:
			return *_g
		}
	case Number:
		return _ast.ObjKind(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.ObjKind] or Number"))
}

GO TYPE go/ast.Object from go/ast/scope.go:
func ExtractGoObjectObject(args []Object, index int) *_ast.Object {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Object:
			return &r
		case *_ast.Object:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Object]"))
}

func _mapToObject(o Map) *_ast.Object {
	return &_ast.Object{
	}
}

func _vectorToObject(o *Vector) *_ast.Object {
	return &_ast.Object{
	}
}

func _ConstructObject(_v Object) *_ast.Object {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.Object:
			return &_g
		case *_ast.Object:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToObject(_o.(Map))
	case case *Vector:
		return _vectorToObject(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Object] or Map"))
}

GO TYPE go/ast.Package from go/ast/ast.go:
func ExtractGoObjectPackage(args []Object, index int) *_ast.Package {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Package:
			return &r
		case *_ast.Package:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Package]"))
}

func _mapToPackage(o Map) *_ast.Package {
	return &_ast.Package{
	}
}

func _vectorToPackage(o *Vector) *_ast.Package {
	return &_ast.Package{
	}
}

func _ConstructPackage(_v Object) *_ast.Package {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.Package:
			return &_g
		case *_ast.Package:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPackage(_o.(Map))
	case case *Vector:
		return _vectorToPackage(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Package] or Map"))
}

GO TYPE go/ast.ParenExpr from go/ast/ast.go:
func ExtractGoObjectParenExpr(args []Object, index int) *_ast.ParenExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.ParenExpr:
			return &r
		case *_ast.ParenExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.ParenExpr]"))
}

func _mapToParenExpr(o Map) *_ast.ParenExpr {
	return &_ast.ParenExpr{
	}
}

func _vectorToParenExpr(o *Vector) *_ast.ParenExpr {
	return &_ast.ParenExpr{
	}
}

func _ConstructParenExpr(_v Object) *_ast.ParenExpr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.ParenExpr:
			return &_g
		case *_ast.ParenExpr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToParenExpr(_o.(Map))
	case case *Vector:
		return _vectorToParenExpr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.ParenExpr] or Map"))
}

GO TYPE go/ast.RangeStmt from go/ast/ast.go:
func ExtractGoObjectRangeStmt(args []Object, index int) *_ast.RangeStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.RangeStmt:
			return &r
		case *_ast.RangeStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.RangeStmt]"))
}

func _mapToRangeStmt(o Map) *_ast.RangeStmt {
	return &_ast.RangeStmt{
	}
}

func _vectorToRangeStmt(o *Vector) *_ast.RangeStmt {
	return &_ast.RangeStmt{
	}
}

func _ConstructRangeStmt(_v Object) *_ast.RangeStmt {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.RangeStmt:
			return &_g
		case *_ast.RangeStmt:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRangeStmt(_o.(Map))
	case case *Vector:
		return _vectorToRangeStmt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.RangeStmt] or Map"))
}

GO TYPE go/ast.ReturnStmt from go/ast/ast.go:
func ExtractGoObjectReturnStmt(args []Object, index int) *_ast.ReturnStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.ReturnStmt:
			return &r
		case *_ast.ReturnStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.ReturnStmt]"))
}

func _mapToReturnStmt(o Map) *_ast.ReturnStmt {
	return &_ast.ReturnStmt{
	}
}

func _vectorToReturnStmt(o *Vector) *_ast.ReturnStmt {
	return &_ast.ReturnStmt{
	}
}

func _ConstructReturnStmt(_v Object) *_ast.ReturnStmt {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.ReturnStmt:
			return &_g
		case *_ast.ReturnStmt:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReturnStmt(_o.(Map))
	case case *Vector:
		return _vectorToReturnStmt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.ReturnStmt] or Map"))
}

GO TYPE go/ast.Scope from go/ast/scope.go:
func ExtractGoObjectScope(args []Object, index int) *_ast.Scope {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Scope:
			return &r
		case *_ast.Scope:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Scope]"))
}

func _mapToScope(o Map) *_ast.Scope {
	return &_ast.Scope{
	}
}

func _vectorToScope(o *Vector) *_ast.Scope {
	return &_ast.Scope{
	}
}

func _ConstructScope(_v Object) *_ast.Scope {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.Scope:
			return &_g
		case *_ast.Scope:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToScope(_o.(Map))
	case case *Vector:
		return _vectorToScope(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Scope] or Map"))
}

GO TYPE go/ast.SelectStmt from go/ast/ast.go:
func ExtractGoObjectSelectStmt(args []Object, index int) *_ast.SelectStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.SelectStmt:
			return &r
		case *_ast.SelectStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.SelectStmt]"))
}

func _mapToSelectStmt(o Map) *_ast.SelectStmt {
	return &_ast.SelectStmt{
	}
}

func _vectorToSelectStmt(o *Vector) *_ast.SelectStmt {
	return &_ast.SelectStmt{
	}
}

func _ConstructSelectStmt(_v Object) *_ast.SelectStmt {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.SelectStmt:
			return &_g
		case *_ast.SelectStmt:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSelectStmt(_o.(Map))
	case case *Vector:
		return _vectorToSelectStmt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.SelectStmt] or Map"))
}

GO TYPE go/ast.SelectorExpr from go/ast/ast.go:
func ExtractGoObjectSelectorExpr(args []Object, index int) *_ast.SelectorExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.SelectorExpr:
			return &r
		case *_ast.SelectorExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.SelectorExpr]"))
}

func _mapToSelectorExpr(o Map) *_ast.SelectorExpr {
	return &_ast.SelectorExpr{
	}
}

func _vectorToSelectorExpr(o *Vector) *_ast.SelectorExpr {
	return &_ast.SelectorExpr{
	}
}

func _ConstructSelectorExpr(_v Object) *_ast.SelectorExpr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.SelectorExpr:
			return &_g
		case *_ast.SelectorExpr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSelectorExpr(_o.(Map))
	case case *Vector:
		return _vectorToSelectorExpr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.SelectorExpr] or Map"))
}

GO TYPE go/ast.SendStmt from go/ast/ast.go:
func ExtractGoObjectSendStmt(args []Object, index int) *_ast.SendStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.SendStmt:
			return &r
		case *_ast.SendStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.SendStmt]"))
}

func _mapToSendStmt(o Map) *_ast.SendStmt {
	return &_ast.SendStmt{
	}
}

func _vectorToSendStmt(o *Vector) *_ast.SendStmt {
	return &_ast.SendStmt{
	}
}

func _ConstructSendStmt(_v Object) *_ast.SendStmt {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.SendStmt:
			return &_g
		case *_ast.SendStmt:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSendStmt(_o.(Map))
	case case *Vector:
		return _vectorToSendStmt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.SendStmt] or Map"))
}

GO TYPE go/ast.SliceExpr from go/ast/ast.go:
func ExtractGoObjectSliceExpr(args []Object, index int) *_ast.SliceExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.SliceExpr:
			return &r
		case *_ast.SliceExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.SliceExpr]"))
}

func _mapToSliceExpr(o Map) *_ast.SliceExpr {
	return &_ast.SliceExpr{
	}
}

func _vectorToSliceExpr(o *Vector) *_ast.SliceExpr {
	return &_ast.SliceExpr{
	}
}

func _ConstructSliceExpr(_v Object) *_ast.SliceExpr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.SliceExpr:
			return &_g
		case *_ast.SliceExpr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSliceExpr(_o.(Map))
	case case *Vector:
		return _vectorToSliceExpr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.SliceExpr] or Map"))
}

GO TYPE go/ast.Spec from go/ast/ast.go:
func ExtractGoObjectSpec(args []Object, index int) *_ast.Spec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Spec:
			return &r
		case *_ast.Spec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Spec]"))
}

// func _ConstructSpec(_v Object) _ast.Spec {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Spec:
// 			return _g
// 		case *_ast.Spec:
// 			return *_g
// 		}
// 	default:
// 		return _ast.Spec(_o.ABEND674(unknown underlying type *ast.InterfaceType for Spec))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Spec] or whatever"))
// }

GO TYPE go/ast.StarExpr from go/ast/ast.go:
func ExtractGoObjectStarExpr(args []Object, index int) *_ast.StarExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.StarExpr:
			return &r
		case *_ast.StarExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.StarExpr]"))
}

func _mapToStarExpr(o Map) *_ast.StarExpr {
	return &_ast.StarExpr{
	}
}

func _vectorToStarExpr(o *Vector) *_ast.StarExpr {
	return &_ast.StarExpr{
	}
}

func _ConstructStarExpr(_v Object) *_ast.StarExpr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.StarExpr:
			return &_g
		case *_ast.StarExpr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToStarExpr(_o.(Map))
	case case *Vector:
		return _vectorToStarExpr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.StarExpr] or Map"))
}

GO TYPE go/ast.Stmt from go/ast/ast.go:
func ExtractGoObjectStmt(args []Object, index int) *_ast.Stmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Stmt:
			return &r
		case *_ast.Stmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Stmt]"))
}

// func _ConstructStmt(_v Object) _ast.Stmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Stmt:
// 			return _g
// 		case *_ast.Stmt:
// 			return *_g
// 		}
// 	default:
// 		return _ast.Stmt(_o.ABEND674(unknown underlying type *ast.InterfaceType for Stmt))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Stmt] or whatever"))
// }

GO TYPE go/ast.StructType from go/ast/ast.go:
func ExtractGoObjectStructType(args []Object, index int) *_ast.StructType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.StructType:
			return &r
		case *_ast.StructType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.StructType]"))
}

func _mapToStructType(o Map) *_ast.StructType {
	return &_ast.StructType{
	}
}

func _vectorToStructType(o *Vector) *_ast.StructType {
	return &_ast.StructType{
	}
}

func _ConstructStructType(_v Object) *_ast.StructType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.StructType:
			return &_g
		case *_ast.StructType:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToStructType(_o.(Map))
	case case *Vector:
		return _vectorToStructType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.StructType] or Map"))
}

GO TYPE go/ast.SwitchStmt from go/ast/ast.go:
func ExtractGoObjectSwitchStmt(args []Object, index int) *_ast.SwitchStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.SwitchStmt:
			return &r
		case *_ast.SwitchStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.SwitchStmt]"))
}

func _mapToSwitchStmt(o Map) *_ast.SwitchStmt {
	return &_ast.SwitchStmt{
	}
}

func _vectorToSwitchStmt(o *Vector) *_ast.SwitchStmt {
	return &_ast.SwitchStmt{
	}
}

func _ConstructSwitchStmt(_v Object) *_ast.SwitchStmt {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.SwitchStmt:
			return &_g
		case *_ast.SwitchStmt:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSwitchStmt(_o.(Map))
	case case *Vector:
		return _vectorToSwitchStmt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.SwitchStmt] or Map"))
}

GO TYPE go/ast.TypeAssertExpr from go/ast/ast.go:
func ExtractGoObjectTypeAssertExpr(args []Object, index int) *_ast.TypeAssertExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.TypeAssertExpr:
			return &r
		case *_ast.TypeAssertExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.TypeAssertExpr]"))
}

func _mapToTypeAssertExpr(o Map) *_ast.TypeAssertExpr {
	return &_ast.TypeAssertExpr{
	}
}

func _vectorToTypeAssertExpr(o *Vector) *_ast.TypeAssertExpr {
	return &_ast.TypeAssertExpr{
	}
}

func _ConstructTypeAssertExpr(_v Object) *_ast.TypeAssertExpr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.TypeAssertExpr:
			return &_g
		case *_ast.TypeAssertExpr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTypeAssertExpr(_o.(Map))
	case case *Vector:
		return _vectorToTypeAssertExpr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.TypeAssertExpr] or Map"))
}

GO TYPE go/ast.TypeSpec from go/ast/ast.go:
func ExtractGoObjectTypeSpec(args []Object, index int) *_ast.TypeSpec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.TypeSpec:
			return &r
		case *_ast.TypeSpec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.TypeSpec]"))
}

func _mapToTypeSpec(o Map) *_ast.TypeSpec {
	return &_ast.TypeSpec{
	}
}

func _vectorToTypeSpec(o *Vector) *_ast.TypeSpec {
	return &_ast.TypeSpec{
	}
}

func _ConstructTypeSpec(_v Object) *_ast.TypeSpec {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.TypeSpec:
			return &_g
		case *_ast.TypeSpec:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTypeSpec(_o.(Map))
	case case *Vector:
		return _vectorToTypeSpec(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.TypeSpec] or Map"))
}

GO TYPE go/ast.TypeSwitchStmt from go/ast/ast.go:
func ExtractGoObjectTypeSwitchStmt(args []Object, index int) *_ast.TypeSwitchStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.TypeSwitchStmt:
			return &r
		case *_ast.TypeSwitchStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.TypeSwitchStmt]"))
}

func _mapToTypeSwitchStmt(o Map) *_ast.TypeSwitchStmt {
	return &_ast.TypeSwitchStmt{
	}
}

func _vectorToTypeSwitchStmt(o *Vector) *_ast.TypeSwitchStmt {
	return &_ast.TypeSwitchStmt{
	}
}

func _ConstructTypeSwitchStmt(_v Object) *_ast.TypeSwitchStmt {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.TypeSwitchStmt:
			return &_g
		case *_ast.TypeSwitchStmt:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTypeSwitchStmt(_o.(Map))
	case case *Vector:
		return _vectorToTypeSwitchStmt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.TypeSwitchStmt] or Map"))
}

GO TYPE go/ast.UnaryExpr from go/ast/ast.go:
func ExtractGoObjectUnaryExpr(args []Object, index int) *_ast.UnaryExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.UnaryExpr:
			return &r
		case *_ast.UnaryExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.UnaryExpr]"))
}

func _mapToUnaryExpr(o Map) *_ast.UnaryExpr {
	return &_ast.UnaryExpr{
	}
}

func _vectorToUnaryExpr(o *Vector) *_ast.UnaryExpr {
	return &_ast.UnaryExpr{
	}
}

func _ConstructUnaryExpr(_v Object) *_ast.UnaryExpr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.UnaryExpr:
			return &_g
		case *_ast.UnaryExpr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnaryExpr(_o.(Map))
	case case *Vector:
		return _vectorToUnaryExpr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.UnaryExpr] or Map"))
}

GO TYPE go/ast.ValueSpec from go/ast/ast.go:
func ExtractGoObjectValueSpec(args []Object, index int) *_ast.ValueSpec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.ValueSpec:
			return &r
		case *_ast.ValueSpec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.ValueSpec]"))
}

func _mapToValueSpec(o Map) *_ast.ValueSpec {
	return &_ast.ValueSpec{
	}
}

func _vectorToValueSpec(o *Vector) *_ast.ValueSpec {
	return &_ast.ValueSpec{
	}
}

func _ConstructValueSpec(_v Object) *_ast.ValueSpec {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.ValueSpec:
			return &_g
		case *_ast.ValueSpec:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToValueSpec(_o.(Map))
	case case *Vector:
		return _vectorToValueSpec(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.ValueSpec] or Map"))
}

GO TYPE go/ast.Visitor from go/ast/walk.go:
func ExtractGoObjectVisitor(args []Object, index int) *_ast.Visitor {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Visitor:
			return &r
		case *_ast.Visitor:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Visitor]"))
}

// func _ConstructVisitor(_v Object) _ast.Visitor {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Visitor:
// 			return _g
// 		case *_ast.Visitor:
// 			return *_g
// 		}
// 	default:
// 		return _ast.Visitor(_o.ABEND674(unknown underlying type *ast.InterfaceType for Visitor))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Visitor] or whatever"))
// }

GO FUNC go/ast.Fprint from go/ast/print.go:
// func __fprint(w ABEND987(genutils.go: imports not yet supported: io.Writer), fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), x interface {}, f _ast.FieldFilter)  {
// 	_res := _ast.Fprint(w, fset, x, f)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC go/ast.Inspect from go/ast/walk.go:
// func __inspect(node _ast.Node, f func) Object {
// 	_ast.Inspect(node, f)
// 	...ABEND675: TODO...
// }

GO FUNC go/ast.MergePackageFiles from go/ast/filter.go:
func __mergePackageFiles(pkg *_ast.Package, mode _ast.MergeMode) Object {
	_res := _ast.MergePackageFiles(pkg, mode)
	return MakeGoObject(_res)
}

GO FUNC go/ast.NewCommentMap from go/ast/commentmap.go:
// func __newCommentMap(fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), node _ast.Node, comments []*_ast.CommentGroup) Object {
// 	_res := _ast.NewCommentMap(fset, node, comments)
// 	return MakeGoObject(_res)
// }

GO FUNC go/ast.NewIdent from go/ast/ast.go:
func __newIdent(name string) Object {
	_res := _ast.NewIdent(name)
	return MakeGoObject(_res)
}

GO FUNC go/ast.NewObj from go/ast/scope.go:
func __newObj(kind _ast.ObjKind, name string) Object {
	_res := _ast.NewObj(kind, name)
	return MakeGoObject(_res)
}

GO FUNC go/ast.NewPackage from go/ast/resolve.go:
// func __newPackage(fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), files map[], importer _ast.Importer, universe *_ast.Scope) Object {
// 	_res1, _res2 := _ast.NewPackage(fset, files, importer, universe)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC go/ast.NewScope from go/ast/scope.go:
func __newScope(outer *_ast.Scope) Object {
	_res := _ast.NewScope(outer)
	return MakeGoObject(_res)
}

GO FUNC go/ast.NotNilFilter from go/ast/print.go:
// func __notNilFilter(_ string, v ABEND987(genutils.go: imports not yet supported: reflect.Value))  {
// 	_res := _ast.NotNilFilter(_, v)
// 	return MakeBoolean(_res)
// }

GO FUNC go/ast.Print from go/ast/print.go:
// func __print(fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), x interface {})  {
// 	_res := _ast.Print(fset, x)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC go/ast.SortImports from go/ast/import.go:
// func __sortImports(fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), f *_ast.File) Object {
// 	_ast.SortImports(fset, f)
// 	...ABEND675: TODO...
// }

GO FUNC go/ast.Walk from go/ast/walk.go:
// func __walk(v _ast.Visitor, node _ast.Node) Object {
// 	_ast.Walk(v, node)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package ast

import (
	_ast "go/ast"
	. "github.com/candid82/joker/core"
)
GO TYPE go/build.Context from go/build/build.go:
func ExtractGoObjectContext(args []Object, index int) *_build.Context {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _build.Context:
			return &r
		case *_build.Context:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/build.Context]"))
}

func _mapToContext(o Map) *_build.Context {
	return &_build.Context{
	}
}

func _vectorToContext(o *Vector) *_build.Context {
	return &_build.Context{
	}
}

func _ConstructContext(_v Object) *_build.Context {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _build.Context:
			return &_g
		case *_build.Context:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToContext(_o.(Map))
	case case *Vector:
		return _vectorToContext(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[build.Context] or Map"))
}

GO TYPE go/build.ImportMode from go/build/build.go:
func ExtractGoObjectImportMode(args []Object, index int) *_build.ImportMode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _build.ImportMode:
			return &r
		case *_build.ImportMode:
			return r
		}
	case Number:
		v := _build.ImportMode(ExtractUInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/build.ImportMode]"))
}

func _ConstructImportMode(_v Object) _build.ImportMode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _build.ImportMode:
			return _g
		case *_build.ImportMode:
			return *_g
		}
	case Number:
		return _build.ImportMode(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[build.ImportMode] or Number"))
}

GO TYPE go/build.MultiplePackageError from go/build/build.go:
func ExtractGoObjectMultiplePackageError(args []Object, index int) *_build.MultiplePackageError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _build.MultiplePackageError:
			return &r
		case *_build.MultiplePackageError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/build.MultiplePackageError]"))
}

func _mapToMultiplePackageError(o Map) *_build.MultiplePackageError {
	return &_build.MultiplePackageError{
	}
}

func _vectorToMultiplePackageError(o *Vector) *_build.MultiplePackageError {
	return &_build.MultiplePackageError{
	}
}

func _ConstructMultiplePackageError(_v Object) *_build.MultiplePackageError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _build.MultiplePackageError:
			return &_g
		case *_build.MultiplePackageError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMultiplePackageError(_o.(Map))
	case case *Vector:
		return _vectorToMultiplePackageError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[build.MultiplePackageError] or Map"))
}

GO TYPE go/build.NoGoError from go/build/build.go:
func ExtractGoObjectNoGoError(args []Object, index int) *_build.NoGoError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _build.NoGoError:
			return &r
		case *_build.NoGoError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/build.NoGoError]"))
}

func _mapToNoGoError(o Map) *_build.NoGoError {
	return &_build.NoGoError{
	}
}

func _vectorToNoGoError(o *Vector) *_build.NoGoError {
	return &_build.NoGoError{
	}
}

func _ConstructNoGoError(_v Object) *_build.NoGoError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _build.NoGoError:
			return &_g
		case *_build.NoGoError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNoGoError(_o.(Map))
	case case *Vector:
		return _vectorToNoGoError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[build.NoGoError] or Map"))
}

GO TYPE go/build.Package from go/build/build.go:
func ExtractGoObjectPackage(args []Object, index int) *_build.Package {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _build.Package:
			return &r
		case *_build.Package:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/build.Package]"))
}

func _mapToPackage(o Map) *_build.Package {
	return &_build.Package{
	}
}

func _vectorToPackage(o *Vector) *_build.Package {
	return &_build.Package{
	}
}

func _ConstructPackage(_v Object) *_build.Package {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _build.Package:
			return &_g
		case *_build.Package:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPackage(_o.(Map))
	case case *Vector:
		return _vectorToPackage(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[build.Package] or Map"))
}

GO FUNC go/build.ArchChar from go/build/build.go:
func __archChar(goarch string) Object {
	_res1, _res2 := _build.ArchChar(goarch)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC go/build.Import from go/build/build.go:
func __import(path string, srcDir string, mode _build.ImportMode) Object {
	_res1, _res2 := _build.Import(path, srcDir, mode)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC go/build.ImportDir from go/build/build.go:
func __importDir(dir string, mode _build.ImportMode) Object {
	_res1, _res2 := _build.ImportDir(dir, mode)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package build

import (
	_build "go/build"
	. "github.com/candid82/joker/core"
)
GO TYPE go/constant.Kind from go/constant/value.go:
func ExtractGoObjectKind(args []Object, index int) *_constant.Kind {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _constant.Kind:
			return &r
		case *_constant.Kind:
			return r
		}
	case Int:
		v := _constant.Kind(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/constant.Kind]"))
}

func _ConstructKind(_v Object) _constant.Kind {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _constant.Kind:
			return _g
		case *_constant.Kind:
			return *_g
		}
	case Number:
		return _constant.Kind(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[constant.Kind] or Number"))
}

GO TYPE go/constant.Value from go/constant/value.go:
func ExtractGoObjectValue(args []Object, index int) *_constant.Value {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _constant.Value:
			return &r
		case *_constant.Value:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/constant.Value]"))
}

// func _ConstructValue(_v Object) _constant.Value {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _constant.Value:
// 			return _g
// 		case *_constant.Value:
// 			return *_g
// 		}
// 	default:
// 		return _constant.Value(_o.ABEND674(unknown underlying type *ast.InterfaceType for Value))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[constant.Value] or whatever"))
// }

GO FUNC go/constant.BinaryOp from go/constant/value.go:
// func __binaryOp(x_ _constant.Value, op ABEND987(genutils.go: imports not yet supported: token.Token), y_ _constant.Value) Object {
// 	_res := _constant.BinaryOp(x_, op, y_)
// 	return MakeGoObject(_res)
// }

GO FUNC go/constant.Bytes from go/constant/value.go:
func __bytes(x _constant.Value) Object {
	_res := _constant.Bytes(x)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC go/constant.Compare from go/constant/value.go:
// func __compare(x_ _constant.Value, op ABEND987(genutils.go: imports not yet supported: token.Token), y_ _constant.Value)  {
// 	_res := _constant.Compare(x_, op, y_)
// 	return MakeBoolean(_res)
// }

GO FUNC go/constant.Denom from go/constant/value.go:
func __denom(x _constant.Value) Object {
	_res := _constant.Denom(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.Float32Val from go/constant/value.go:
// func __float32Val(x _constant.Value) Object {
// 	_res1, _res2 := _constant.Float32Val(x)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(MakeBoolean(_res2))
// 	return _res
// }

GO FUNC go/constant.Float64Val from go/constant/value.go:
// func __float64Val(x _constant.Value) Object {
// 	_res1, _res2 := _constant.Float64Val(x)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(MakeBoolean(_res2))
// 	return _res
// }

GO FUNC go/constant.Imag from go/constant/value.go:
func __imag(x _constant.Value) Object {
	_res := _constant.Imag(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.Int64Val from go/constant/value.go:
func __int64Val(x _constant.Value) Object {
	_res1, _res2 := _constant.Int64Val(x)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(int(_res1)))
	_res = _res.Conjoin(MakeBoolean(_res2))
	return _res
}

GO FUNC go/constant.MakeBool from go/constant/value.go:
func __makeBool(b bool) Object {
	_res := _constant.MakeBool(b)
	return MakeGoObject(_res)
}

GO FUNC go/constant.MakeFloat64 from go/constant/value.go:
// func __makeFloat64(x float64) Object {
// 	_res := _constant.MakeFloat64(x)
// 	return MakeGoObject(_res)
// }

GO FUNC go/constant.MakeFromBytes from go/constant/value.go:
// func __makeFromBytes(bytes []byte) Object {
// 	_res := _constant.MakeFromBytes(bytes)
// 	return MakeGoObject(_res)
// }

GO FUNC go/constant.MakeFromLiteral from go/constant/value.go:
// func __makeFromLiteral(lit string, tok ABEND987(genutils.go: imports not yet supported: token.Token), zero uint) Object {
// 	_res := _constant.MakeFromLiteral(lit, tok, zero)
// 	return MakeGoObject(_res)
// }

GO FUNC go/constant.MakeImag from go/constant/value.go:
func __makeImag(x _constant.Value) Object {
	_res := _constant.MakeImag(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.MakeInt64 from go/constant/value.go:
func __makeInt64(x int64) Object {
	_res := _constant.MakeInt64(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.MakeString from go/constant/value.go:
func __makeString(s string) Object {
	_res := _constant.MakeString(s)
	return MakeGoObject(_res)
}

GO FUNC go/constant.MakeUint64 from go/constant/value.go:
// func __makeUint64(x uint64) Object {
// 	_res := _constant.MakeUint64(x)
// 	return MakeGoObject(_res)
// }

GO FUNC go/constant.MakeUnknown from go/constant/value.go:
func __makeUnknown() Object {
	_res := _constant.MakeUnknown()
	return MakeGoObject(_res)
}

GO FUNC go/constant.Num from go/constant/value.go:
func __num(x _constant.Value) Object {
	_res := _constant.Num(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.Real from go/constant/value.go:
func __real(x _constant.Value) Object {
	_res := _constant.Real(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.Shift from go/constant/value.go:
// func __shift(x _constant.Value, op ABEND987(genutils.go: imports not yet supported: token.Token), s uint) Object {
// 	_res := _constant.Shift(x, op, s)
// 	return MakeGoObject(_res)
// }

GO FUNC go/constant.ToComplex from go/constant/value.go:
func __toComplex(x _constant.Value) Object {
	_res := _constant.ToComplex(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.ToFloat from go/constant/value.go:
func __toFloat(x _constant.Value) Object {
	_res := _constant.ToFloat(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.ToInt from go/constant/value.go:
func __toInt(x _constant.Value) Object {
	_res := _constant.ToInt(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.Uint64Val from go/constant/value.go:
func __uint64Val(x _constant.Value) Object {
	_res1, _res2 := _constant.Uint64Val(x)
	_res := EmptyVector
	_res = _res.Conjoin(MakeBigInt(uint64(_res1)))
	_res = _res.Conjoin(MakeBoolean(_res2))
	return _res
}

GO FUNC go/constant.UnaryOp from go/constant/value.go:
// func __unaryOp(op ABEND987(genutils.go: imports not yet supported: token.Token), y _constant.Value, prec uint) Object {
// 	_res := _constant.UnaryOp(op, y, prec)
// 	return MakeGoObject(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package constant

import (
	_constant "go/constant"
	. "github.com/candid82/joker/core"
)
GO TYPE go/doc.Example from go/doc/example.go:
func ExtractGoObjectExample(args []Object, index int) *_doc.Example {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _doc.Example:
			return &r
		case *_doc.Example:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/doc.Example]"))
}

func _mapToExample(o Map) *_doc.Example {
	return &_doc.Example{
	}
}

func _vectorToExample(o *Vector) *_doc.Example {
	return &_doc.Example{
	}
}

func _ConstructExample(_v Object) *_doc.Example {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _doc.Example:
			return &_g
		case *_doc.Example:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToExample(_o.(Map))
	case case *Vector:
		return _vectorToExample(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[doc.Example] or Map"))
}

GO TYPE go/doc.Filter from go/doc/filter.go:
func ExtractGoObjectFilter(args []Object, index int) *_doc.Filter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _doc.Filter:
			return &r
		case *_doc.Filter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/doc.Filter]"))
}

// func _ConstructFilter(_v Object) _doc.Filter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _doc.Filter:
// 			return _g
// 		case *_doc.Filter:
// 			return *_g
// 		}
// 	default:
// 		return _doc.Filter(_o.ABEND674(unknown underlying type *ast.FuncType for Filter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[doc.Filter] or whatever"))
// }

GO TYPE go/doc.Func from go/doc/doc.go:
func ExtractGoObjectFunc(args []Object, index int) *_doc.Func {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _doc.Func:
			return &r
		case *_doc.Func:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/doc.Func]"))
}

func _mapToFunc(o Map) *_doc.Func {
	return &_doc.Func{
	}
}

func _vectorToFunc(o *Vector) *_doc.Func {
	return &_doc.Func{
	}
}

func _ConstructFunc(_v Object) *_doc.Func {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _doc.Func:
			return &_g
		case *_doc.Func:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFunc(_o.(Map))
	case case *Vector:
		return _vectorToFunc(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[doc.Func] or Map"))
}

GO TYPE go/doc.Mode from go/doc/doc.go:
func ExtractGoObjectMode(args []Object, index int) *_doc.Mode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _doc.Mode:
			return &r
		case *_doc.Mode:
			return r
		}
	case Int:
		v := _doc.Mode(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/doc.Mode]"))
}

func _ConstructMode(_v Object) _doc.Mode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _doc.Mode:
			return _g
		case *_doc.Mode:
			return *_g
		}
	case Number:
		return _doc.Mode(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[doc.Mode] or Number"))
}

GO TYPE go/doc.Note from go/doc/doc.go:
func ExtractGoObjectNote(args []Object, index int) *_doc.Note {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _doc.Note:
			return &r
		case *_doc.Note:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/doc.Note]"))
}

func _mapToNote(o Map) *_doc.Note {
	return &_doc.Note{
	}
}

func _vectorToNote(o *Vector) *_doc.Note {
	return &_doc.Note{
	}
}

func _ConstructNote(_v Object) *_doc.Note {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _doc.Note:
			return &_g
		case *_doc.Note:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNote(_o.(Map))
	case case *Vector:
		return _vectorToNote(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[doc.Note] or Map"))
}

GO TYPE go/doc.Package from go/doc/doc.go:
func ExtractGoObjectPackage(args []Object, index int) *_doc.Package {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _doc.Package:
			return &r
		case *_doc.Package:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/doc.Package]"))
}

func _mapToPackage(o Map) *_doc.Package {
	return &_doc.Package{
	}
}

func _vectorToPackage(o *Vector) *_doc.Package {
	return &_doc.Package{
	}
}

func _ConstructPackage(_v Object) *_doc.Package {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _doc.Package:
			return &_g
		case *_doc.Package:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPackage(_o.(Map))
	case case *Vector:
		return _vectorToPackage(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[doc.Package] or Map"))
}

GO TYPE go/doc.Type from go/doc/doc.go:
func ExtractGoObjectType(args []Object, index int) *_doc.Type {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _doc.Type:
			return &r
		case *_doc.Type:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/doc.Type]"))
}

func _mapToType(o Map) *_doc.Type {
	return &_doc.Type{
	}
}

func _vectorToType(o *Vector) *_doc.Type {
	return &_doc.Type{
	}
}

func _ConstructType(_v Object) *_doc.Type {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _doc.Type:
			return &_g
		case *_doc.Type:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToType(_o.(Map))
	case case *Vector:
		return _vectorToType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[doc.Type] or Map"))
}

GO TYPE go/doc.Value from go/doc/doc.go:
func ExtractGoObjectValue(args []Object, index int) *_doc.Value {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _doc.Value:
			return &r
		case *_doc.Value:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/doc.Value]"))
}

func _mapToValue(o Map) *_doc.Value {
	return &_doc.Value{
	}
}

func _vectorToValue(o *Vector) *_doc.Value {
	return &_doc.Value{
	}
}

func _ConstructValue(_v Object) *_doc.Value {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _doc.Value:
			return &_g
		case *_doc.Value:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToValue(_o.(Map))
	case case *Vector:
		return _vectorToValue(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[doc.Value] or Map"))
}

GO FUNC go/doc.Examples from go/doc/example.go:
// func __examples(files ...*ABEND987(genutils.go: imports not yet supported: ast.File)) Object {
// 	_res := _doc.Examples(files)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
// 	}
// 	return _vec1
// }

GO FUNC go/doc.New from go/doc/doc.go:
// func __new(pkg *ABEND987(genutils.go: imports not yet supported: ast.Package), importPath string, mode _doc.Mode) Object {
// 	_res := _doc.New(pkg, importPath, mode)
// 	return MakeGoObject(_res)
// }

GO FUNC go/doc.ToHTML from go/doc/comment.go:
// func __toHTML(w ABEND987(genutils.go: imports not yet supported: io.Writer), text string, words map[]) Object {
// 	_doc.ToHTML(w, text, words)
// 	...ABEND675: TODO...
// }

GO FUNC go/doc.ToText from go/doc/comment.go:
// func __toText(w ABEND987(genutils.go: imports not yet supported: io.Writer), text string, indent string, preIndent string, width int) Object {
// 	_doc.ToText(w, text, indent, preIndent, width)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package doc

import (
	_doc "go/doc"
	. "github.com/candid82/joker/core"
)
GO FUNC go/format.Node from go/format/format.go:
// func __node(dst ABEND987(genutils.go: imports not yet supported: io.Writer), fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), node interface {})  {
// 	_res := _format.Node(dst, fset, node)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC go/format.Source from go/format/format.go:
// func __source(src []byte) Object {
// 	_res1, _res2 := _format.Source(src)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO TYPE go/importer.Lookup from go/importer/importer.go:
func ExtractGoObjectLookup(args []Object, index int) *_importer.Lookup {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _importer.Lookup:
			return &r
		case *_importer.Lookup:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/importer.Lookup]"))
}

// func _ConstructLookup(_v Object) _importer.Lookup {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _importer.Lookup:
// 			return _g
// 		case *_importer.Lookup:
// 			return *_g
// 		}
// 	default:
// 		return _importer.Lookup(_o.ABEND674(unknown underlying type *ast.FuncType for Lookup))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[importer.Lookup] or whatever"))
// }

GO FUNC go/importer.Default from go/importer/importer.go:
func __default() Object {
	_res := _importer.Default()
	return MakeGoObject(_res)
}

GO FUNC go/importer.For from go/importer/importer.go:
func __for(compiler string, lookup _importer.Lookup) Object {
	_res := _importer.For(compiler, lookup)
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package importer

import (
	_importer "go/importer"
	. "github.com/candid82/joker/core"
)
GO TYPE go/parser.Mode from go/parser/interface.go:
func ExtractGoObjectMode(args []Object, index int) *_parser.Mode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parser.Mode:
			return &r
		case *_parser.Mode:
			return r
		}
	case Number:
		v := _parser.Mode(ExtractUInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/parser.Mode]"))
}

func _ConstructMode(_v Object) _parser.Mode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parser.Mode:
			return _g
		case *_parser.Mode:
			return *_g
		}
	case Number:
		return _parser.Mode(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parser.Mode] or Number"))
}

GO FUNC go/parser.ParseDir from go/parser/interface.go:
// func __parseDir(fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), path string, filter func, mode _parser.Mode) Object {
// 	pkgs, first := _parser.ParseDir(fset, path, filter, mode)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(pkgs)
// 	_res = _res.Conjoin(func () Object { if (first) == nil { return NIL } else { return MakeError(first) } }())
// 	return _res
// }

GO FUNC go/parser.ParseExpr from go/parser/interface.go:
func __parseExpr(x string) Object {
	_res1, _res2 := _parser.ParseExpr(x)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC go/parser.ParseExprFrom from go/parser/interface.go:
// func __parseExprFrom(fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), filename string, src interface {}, mode _parser.Mode) Object {
// 	_res1, _res2 := _parser.ParseExprFrom(fset, filename, src, mode)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC go/parser.ParseFile from go/parser/interface.go:
// func __parseFile(fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), filename string, src interface {}, mode _parser.Mode) Object {
// 	f, err := _parser.ParseFile(fset, filename, src, mode)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(f))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package parser

import (
	_parser "go/parser"
	. "github.com/candid82/joker/core"
)
GO FUNC go/printer.Fprint from go/printer/printer.go:
// func __fprint(output ABEND987(genutils.go: imports not yet supported: io.Writer), fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), node interface {})  {
// 	_res := _printer.Fprint(output, fset, node)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC go/scanner.PrintError from go/scanner/errors.go:
// func __printError(w ABEND987(genutils.go: imports not yet supported: io.Writer), err error) Object {
// 	_scanner.PrintError(w, err)
// 	...ABEND675: TODO...
// }

GO TYPE go/token.File from go/token/position.go:
func ExtractGoObjectFile(args []Object, index int) *_token.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _token.File:
			return &r
		case *_token.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/token.File]"))
}

func _mapToFile(o Map) *_token.File {
	return &_token.File{
	}
}

func _vectorToFile(o *Vector) *_token.File {
	return &_token.File{
	}
}

func _ConstructFile(_v Object) *_token.File {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _token.File:
			return &_g
		case *_token.File:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFile(_o.(Map))
	case case *Vector:
		return _vectorToFile(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[token.File] or Map"))
}

GO TYPE go/token.FileSet from go/token/position.go:
func ExtractGoObjectFileSet(args []Object, index int) *_token.FileSet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _token.FileSet:
			return &r
		case *_token.FileSet:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/token.FileSet]"))
}

func _mapToFileSet(o Map) *_token.FileSet {
	return &_token.FileSet{
	}
}

func _vectorToFileSet(o *Vector) *_token.FileSet {
	return &_token.FileSet{
	}
}

func _ConstructFileSet(_v Object) *_token.FileSet {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _token.FileSet:
			return &_g
		case *_token.FileSet:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFileSet(_o.(Map))
	case case *Vector:
		return _vectorToFileSet(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[token.FileSet] or Map"))
}

GO TYPE go/token.Pos from go/token/position.go:
func ExtractGoObjectPos(args []Object, index int) *_token.Pos {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _token.Pos:
			return &r
		case *_token.Pos:
			return r
		}
	case Int:
		v := _token.Pos(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/token.Pos]"))
}

func _ConstructPos(_v Object) _token.Pos {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _token.Pos:
			return _g
		case *_token.Pos:
			return *_g
		}
	case Number:
		return _token.Pos(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[token.Pos] or Number"))
}

GO TYPE go/token.Position from go/token/position.go:
func ExtractGoObjectPosition(args []Object, index int) *_token.Position {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _token.Position:
			return &r
		case *_token.Position:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/token.Position]"))
}

func _mapToPosition(o Map) *_token.Position {
	return &_token.Position{
	}
}

func _vectorToPosition(o *Vector) *_token.Position {
	return &_token.Position{
	}
}

func _ConstructPosition(_v Object) *_token.Position {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _token.Position:
			return &_g
		case *_token.Position:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPosition(_o.(Map))
	case case *Vector:
		return _vectorToPosition(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[token.Position] or Map"))
}

GO TYPE go/token.Token from go/token/token.go:
func ExtractGoObjectToken(args []Object, index int) *_token.Token {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _token.Token:
			return &r
		case *_token.Token:
			return r
		}
	case Int:
		v := _token.Token(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/token.Token]"))
}

func _ConstructToken(_v Object) _token.Token {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _token.Token:
			return _g
		case *_token.Token:
			return *_g
		}
	case Number:
		return _token.Token(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[token.Token] or Number"))
}

GO FUNC go/token.Lookup from go/token/token.go:
func __lookup(ident string) Object {
	_res := _token.Lookup(ident)
	return MakeGoObject(_res)
}

GO FUNC go/token.NewFileSet from go/token/position.go:
func __newFileSet() Object {
	_res := _token.NewFileSet()
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package token

import (
	_token "go/token"
	. "github.com/candid82/joker/core"
)
GO TYPE go/types.Array from go/types/type.go:
func ExtractGoObjectArray(args []Object, index int) *_types.Array {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Array:
			return &r
		case *_types.Array:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Array]"))
}

func _mapToArray(o Map) *_types.Array {
	return &_types.Array{
	}
}

func _vectorToArray(o *Vector) *_types.Array {
	return &_types.Array{
	}
}

func _ConstructArray(_v Object) *_types.Array {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Array:
			return &_g
		case *_types.Array:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToArray(_o.(Map))
	case case *Vector:
		return _vectorToArray(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Array] or Map"))
}

GO TYPE go/types.Basic from go/types/type.go:
func ExtractGoObjectBasic(args []Object, index int) *_types.Basic {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Basic:
			return &r
		case *_types.Basic:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Basic]"))
}

func _mapToBasic(o Map) *_types.Basic {
	return &_types.Basic{
	}
}

func _vectorToBasic(o *Vector) *_types.Basic {
	return &_types.Basic{
	}
}

func _ConstructBasic(_v Object) *_types.Basic {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Basic:
			return &_g
		case *_types.Basic:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBasic(_o.(Map))
	case case *Vector:
		return _vectorToBasic(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Basic] or Map"))
}

GO TYPE go/types.BasicInfo from go/types/type.go:
func ExtractGoObjectBasicInfo(args []Object, index int) *_types.BasicInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.BasicInfo:
			return &r
		case *_types.BasicInfo:
			return r
		}
	case Int:
		v := _types.BasicInfo(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.BasicInfo]"))
}

func _ConstructBasicInfo(_v Object) _types.BasicInfo {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.BasicInfo:
			return _g
		case *_types.BasicInfo:
			return *_g
		}
	case Number:
		return _types.BasicInfo(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.BasicInfo] or Number"))
}

GO TYPE go/types.BasicKind from go/types/type.go:
func ExtractGoObjectBasicKind(args []Object, index int) *_types.BasicKind {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.BasicKind:
			return &r
		case *_types.BasicKind:
			return r
		}
	case Int:
		v := _types.BasicKind(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.BasicKind]"))
}

func _ConstructBasicKind(_v Object) _types.BasicKind {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.BasicKind:
			return _g
		case *_types.BasicKind:
			return *_g
		}
	case Number:
		return _types.BasicKind(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.BasicKind] or Number"))
}

GO TYPE go/types.Builtin from go/types/object.go:
func ExtractGoObjectBuiltin(args []Object, index int) *_types.Builtin {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Builtin:
			return &r
		case *_types.Builtin:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Builtin]"))
}

func _mapToBuiltin(o Map) *_types.Builtin {
	return &_types.Builtin{
	}
}

func _vectorToBuiltin(o *Vector) *_types.Builtin {
	return &_types.Builtin{
	}
}

func _ConstructBuiltin(_v Object) *_types.Builtin {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Builtin:
			return &_g
		case *_types.Builtin:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBuiltin(_o.(Map))
	case case *Vector:
		return _vectorToBuiltin(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Builtin] or Map"))
}

GO TYPE go/types.Chan from go/types/type.go:
func ExtractGoObjectChan(args []Object, index int) *_types.Chan {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Chan:
			return &r
		case *_types.Chan:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Chan]"))
}

func _mapToChan(o Map) *_types.Chan {
	return &_types.Chan{
	}
}

func _vectorToChan(o *Vector) *_types.Chan {
	return &_types.Chan{
	}
}

func _ConstructChan(_v Object) *_types.Chan {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Chan:
			return &_g
		case *_types.Chan:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToChan(_o.(Map))
	case case *Vector:
		return _vectorToChan(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Chan] or Map"))
}

GO TYPE go/types.ChanDir from go/types/type.go:
func ExtractGoObjectChanDir(args []Object, index int) *_types.ChanDir {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.ChanDir:
			return &r
		case *_types.ChanDir:
			return r
		}
	case Int:
		v := _types.ChanDir(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.ChanDir]"))
}

func _ConstructChanDir(_v Object) _types.ChanDir {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.ChanDir:
			return _g
		case *_types.ChanDir:
			return *_g
		}
	case Number:
		return _types.ChanDir(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.ChanDir] or Number"))
}

GO TYPE go/types.Checker from go/types/check.go:
func ExtractGoObjectChecker(args []Object, index int) *_types.Checker {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Checker:
			return &r
		case *_types.Checker:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Checker]"))
}

func _mapToChecker(o Map) *_types.Checker {
	return &_types.Checker{
	}
}

func _vectorToChecker(o *Vector) *_types.Checker {
	return &_types.Checker{
	}
}

func _ConstructChecker(_v Object) *_types.Checker {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Checker:
			return &_g
		case *_types.Checker:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToChecker(_o.(Map))
	case case *Vector:
		return _vectorToChecker(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Checker] or Map"))
}

GO TYPE go/types.Config from go/types/api.go:
func ExtractGoObjectConfig(args []Object, index int) *_types.Config {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Config:
			return &r
		case *_types.Config:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Config]"))
}

func _mapToConfig(o Map) *_types.Config {
	return &_types.Config{
	}
}

func _vectorToConfig(o *Vector) *_types.Config {
	return &_types.Config{
	}
}

func _ConstructConfig(_v Object) *_types.Config {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Config:
			return &_g
		case *_types.Config:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToConfig(_o.(Map))
	case case *Vector:
		return _vectorToConfig(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Config] or Map"))
}

GO TYPE go/types.Const from go/types/object.go:
func ExtractGoObjectConst(args []Object, index int) *_types.Const {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Const:
			return &r
		case *_types.Const:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Const]"))
}

func _mapToConst(o Map) *_types.Const {
	return &_types.Const{
	}
}

func _vectorToConst(o *Vector) *_types.Const {
	return &_types.Const{
	}
}

func _ConstructConst(_v Object) *_types.Const {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Const:
			return &_g
		case *_types.Const:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToConst(_o.(Map))
	case case *Vector:
		return _vectorToConst(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Const] or Map"))
}

GO TYPE go/types.Error from go/types/api.go:
func ExtractGoObjectError(args []Object, index int) *_types.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Error:
			return &r
		case *_types.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Error]"))
}

func _mapToError(o Map) *_types.Error {
	return &_types.Error{
	}
}

func _vectorToError(o *Vector) *_types.Error {
	return &_types.Error{
	}
}

func _ConstructError(_v Object) *_types.Error {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Error:
			return &_g
		case *_types.Error:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToError(_o.(Map))
	case case *Vector:
		return _vectorToError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Error] or Map"))
}

GO TYPE go/types.Func from go/types/object.go:
func ExtractGoObjectFunc(args []Object, index int) *_types.Func {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Func:
			return &r
		case *_types.Func:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Func]"))
}

func _mapToFunc(o Map) *_types.Func {
	return &_types.Func{
	}
}

func _vectorToFunc(o *Vector) *_types.Func {
	return &_types.Func{
	}
}

func _ConstructFunc(_v Object) *_types.Func {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Func:
			return &_g
		case *_types.Func:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFunc(_o.(Map))
	case case *Vector:
		return _vectorToFunc(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Func] or Map"))
}

GO TYPE go/types.ImportMode from go/types/api.go:
func ExtractGoObjectImportMode(args []Object, index int) *_types.ImportMode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.ImportMode:
			return &r
		case *_types.ImportMode:
			return r
		}
	case Int:
		v := _types.ImportMode(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.ImportMode]"))
}

func _ConstructImportMode(_v Object) _types.ImportMode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.ImportMode:
			return _g
		case *_types.ImportMode:
			return *_g
		}
	case Number:
		return _types.ImportMode(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.ImportMode] or Number"))
}

GO TYPE go/types.Importer from go/types/api.go:
func ExtractGoObjectImporter(args []Object, index int) *_types.Importer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Importer:
			return &r
		case *_types.Importer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Importer]"))
}

// func _ConstructImporter(_v Object) _types.Importer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _types.Importer:
// 			return _g
// 		case *_types.Importer:
// 			return *_g
// 		}
// 	default:
// 		return _types.Importer(_o.ABEND674(unknown underlying type *ast.InterfaceType for Importer))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Importer] or whatever"))
// }

GO TYPE go/types.ImporterFrom from go/types/api.go:
func ExtractGoObjectImporterFrom(args []Object, index int) *_types.ImporterFrom {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.ImporterFrom:
			return &r
		case *_types.ImporterFrom:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.ImporterFrom]"))
}

// func _ConstructImporterFrom(_v Object) _types.ImporterFrom {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _types.ImporterFrom:
// 			return _g
// 		case *_types.ImporterFrom:
// 			return *_g
// 		}
// 	default:
// 		return _types.ImporterFrom(_o.ABEND674(unknown underlying type *ast.InterfaceType for ImporterFrom))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[types.ImporterFrom] or whatever"))
// }

GO TYPE go/types.Info from go/types/api.go:
func ExtractGoObjectInfo(args []Object, index int) *_types.Info {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Info:
			return &r
		case *_types.Info:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Info]"))
}

func _mapToInfo(o Map) *_types.Info {
	return &_types.Info{
	}
}

func _vectorToInfo(o *Vector) *_types.Info {
	return &_types.Info{
	}
}

func _ConstructInfo(_v Object) *_types.Info {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Info:
			return &_g
		case *_types.Info:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToInfo(_o.(Map))
	case case *Vector:
		return _vectorToInfo(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Info] or Map"))
}

GO TYPE go/types.Initializer from go/types/api.go:
func ExtractGoObjectInitializer(args []Object, index int) *_types.Initializer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Initializer:
			return &r
		case *_types.Initializer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Initializer]"))
}

func _mapToInitializer(o Map) *_types.Initializer {
	return &_types.Initializer{
	}
}

func _vectorToInitializer(o *Vector) *_types.Initializer {
	return &_types.Initializer{
	}
}

func _ConstructInitializer(_v Object) *_types.Initializer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Initializer:
			return &_g
		case *_types.Initializer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToInitializer(_o.(Map))
	case case *Vector:
		return _vectorToInitializer(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Initializer] or Map"))
}

GO TYPE go/types.Interface from go/types/type.go:
func ExtractGoObjectInterface(args []Object, index int) *_types.Interface {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Interface:
			return &r
		case *_types.Interface:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Interface]"))
}

func _mapToInterface(o Map) *_types.Interface {
	return &_types.Interface{
	}
}

func _vectorToInterface(o *Vector) *_types.Interface {
	return &_types.Interface{
	}
}

func _ConstructInterface(_v Object) *_types.Interface {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Interface:
			return &_g
		case *_types.Interface:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToInterface(_o.(Map))
	case case *Vector:
		return _vectorToInterface(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Interface] or Map"))
}

GO TYPE go/types.Label from go/types/object.go:
func ExtractGoObjectLabel(args []Object, index int) *_types.Label {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Label:
			return &r
		case *_types.Label:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Label]"))
}

func _mapToLabel(o Map) *_types.Label {
	return &_types.Label{
	}
}

func _vectorToLabel(o *Vector) *_types.Label {
	return &_types.Label{
	}
}

func _ConstructLabel(_v Object) *_types.Label {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Label:
			return &_g
		case *_types.Label:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToLabel(_o.(Map))
	case case *Vector:
		return _vectorToLabel(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Label] or Map"))
}

GO TYPE go/types.Map from go/types/type.go:
func ExtractGoObjectMap(args []Object, index int) *_types.Map {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Map:
			return &r
		case *_types.Map:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Map]"))
}

func _mapToMap(o Map) *_types.Map {
	return &_types.Map{
	}
}

func _vectorToMap(o *Vector) *_types.Map {
	return &_types.Map{
	}
}

func _ConstructMap(_v Object) *_types.Map {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Map:
			return &_g
		case *_types.Map:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMap(_o.(Map))
	case case *Vector:
		return _vectorToMap(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Map] or Map"))
}

GO TYPE go/types.MethodSet from go/types/methodset.go:
func ExtractGoObjectMethodSet(args []Object, index int) *_types.MethodSet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.MethodSet:
			return &r
		case *_types.MethodSet:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.MethodSet]"))
}

func _mapToMethodSet(o Map) *_types.MethodSet {
	return &_types.MethodSet{
	}
}

func _vectorToMethodSet(o *Vector) *_types.MethodSet {
	return &_types.MethodSet{
	}
}

func _ConstructMethodSet(_v Object) *_types.MethodSet {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.MethodSet:
			return &_g
		case *_types.MethodSet:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMethodSet(_o.(Map))
	case case *Vector:
		return _vectorToMethodSet(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.MethodSet] or Map"))
}

GO TYPE go/types.Named from go/types/type.go:
func ExtractGoObjectNamed(args []Object, index int) *_types.Named {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Named:
			return &r
		case *_types.Named:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Named]"))
}

func _mapToNamed(o Map) *_types.Named {
	return &_types.Named{
	}
}

func _vectorToNamed(o *Vector) *_types.Named {
	return &_types.Named{
	}
}

func _ConstructNamed(_v Object) *_types.Named {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Named:
			return &_g
		case *_types.Named:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNamed(_o.(Map))
	case case *Vector:
		return _vectorToNamed(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Named] or Map"))
}

GO TYPE go/types.Nil from go/types/object.go:
func ExtractGoObjectNil(args []Object, index int) *_types.Nil {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Nil:
			return &r
		case *_types.Nil:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Nil]"))
}

func _mapToNil(o Map) *_types.Nil {
	return &_types.Nil{
	}
}

func _vectorToNil(o *Vector) *_types.Nil {
	return &_types.Nil{
	}
}

func _ConstructNil(_v Object) *_types.Nil {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Nil:
			return &_g
		case *_types.Nil:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNil(_o.(Map))
	case case *Vector:
		return _vectorToNil(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Nil] or Map"))
}

GO TYPE go/types.Object from go/types/object.go:
func ExtractGoObjectObject(args []Object, index int) *_types.Object {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Object:
			return &r
		case *_types.Object:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Object]"))
}

// func _ConstructObject(_v Object) _types.Object {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _types.Object:
// 			return _g
// 		case *_types.Object:
// 			return *_g
// 		}
// 	default:
// 		return _types.Object(_o.ABEND674(unknown underlying type *ast.InterfaceType for Object))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Object] or whatever"))
// }

GO TYPE go/types.Package from go/types/package.go:
func ExtractGoObjectPackage(args []Object, index int) *_types.Package {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Package:
			return &r
		case *_types.Package:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Package]"))
}

func _mapToPackage(o Map) *_types.Package {
	return &_types.Package{
	}
}

func _vectorToPackage(o *Vector) *_types.Package {
	return &_types.Package{
	}
}

func _ConstructPackage(_v Object) *_types.Package {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Package:
			return &_g
		case *_types.Package:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPackage(_o.(Map))
	case case *Vector:
		return _vectorToPackage(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Package] or Map"))
}

GO TYPE go/types.PkgName from go/types/object.go:
func ExtractGoObjectPkgName(args []Object, index int) *_types.PkgName {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.PkgName:
			return &r
		case *_types.PkgName:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.PkgName]"))
}

func _mapToPkgName(o Map) *_types.PkgName {
	return &_types.PkgName{
	}
}

func _vectorToPkgName(o *Vector) *_types.PkgName {
	return &_types.PkgName{
	}
}

func _ConstructPkgName(_v Object) *_types.PkgName {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.PkgName:
			return &_g
		case *_types.PkgName:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPkgName(_o.(Map))
	case case *Vector:
		return _vectorToPkgName(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.PkgName] or Map"))
}

GO TYPE go/types.Pointer from go/types/type.go:
func ExtractGoObjectPointer(args []Object, index int) *_types.Pointer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Pointer:
			return &r
		case *_types.Pointer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Pointer]"))
}

func _mapToPointer(o Map) *_types.Pointer {
	return &_types.Pointer{
	}
}

func _vectorToPointer(o *Vector) *_types.Pointer {
	return &_types.Pointer{
	}
}

func _ConstructPointer(_v Object) *_types.Pointer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Pointer:
			return &_g
		case *_types.Pointer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPointer(_o.(Map))
	case case *Vector:
		return _vectorToPointer(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Pointer] or Map"))
}

GO TYPE go/types.Qualifier from go/types/typestring.go:
func ExtractGoObjectQualifier(args []Object, index int) *_types.Qualifier {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Qualifier:
			return &r
		case *_types.Qualifier:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Qualifier]"))
}

// func _ConstructQualifier(_v Object) _types.Qualifier {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _types.Qualifier:
// 			return _g
// 		case *_types.Qualifier:
// 			return *_g
// 		}
// 	default:
// 		return _types.Qualifier(_o.ABEND674(unknown underlying type *ast.FuncType for Qualifier))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Qualifier] or whatever"))
// }

GO TYPE go/types.Scope from go/types/scope.go:
func ExtractGoObjectScope(args []Object, index int) *_types.Scope {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Scope:
			return &r
		case *_types.Scope:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Scope]"))
}

func _mapToScope(o Map) *_types.Scope {
	return &_types.Scope{
	}
}

func _vectorToScope(o *Vector) *_types.Scope {
	return &_types.Scope{
	}
}

func _ConstructScope(_v Object) *_types.Scope {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Scope:
			return &_g
		case *_types.Scope:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToScope(_o.(Map))
	case case *Vector:
		return _vectorToScope(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Scope] or Map"))
}

GO TYPE go/types.Selection from go/types/selection.go:
func ExtractGoObjectSelection(args []Object, index int) *_types.Selection {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Selection:
			return &r
		case *_types.Selection:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Selection]"))
}

func _mapToSelection(o Map) *_types.Selection {
	return &_types.Selection{
	}
}

func _vectorToSelection(o *Vector) *_types.Selection {
	return &_types.Selection{
	}
}

func _ConstructSelection(_v Object) *_types.Selection {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Selection:
			return &_g
		case *_types.Selection:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSelection(_o.(Map))
	case case *Vector:
		return _vectorToSelection(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Selection] or Map"))
}

GO TYPE go/types.SelectionKind from go/types/selection.go:
func ExtractGoObjectSelectionKind(args []Object, index int) *_types.SelectionKind {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.SelectionKind:
			return &r
		case *_types.SelectionKind:
			return r
		}
	case Int:
		v := _types.SelectionKind(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.SelectionKind]"))
}

func _ConstructSelectionKind(_v Object) _types.SelectionKind {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.SelectionKind:
			return _g
		case *_types.SelectionKind:
			return *_g
		}
	case Number:
		return _types.SelectionKind(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.SelectionKind] or Number"))
}

GO TYPE go/types.Signature from go/types/type.go:
func ExtractGoObjectSignature(args []Object, index int) *_types.Signature {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Signature:
			return &r
		case *_types.Signature:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Signature]"))
}

func _mapToSignature(o Map) *_types.Signature {
	return &_types.Signature{
	}
}

func _vectorToSignature(o *Vector) *_types.Signature {
	return &_types.Signature{
	}
}

func _ConstructSignature(_v Object) *_types.Signature {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Signature:
			return &_g
		case *_types.Signature:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSignature(_o.(Map))
	case case *Vector:
		return _vectorToSignature(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Signature] or Map"))
}

GO TYPE go/types.Sizes from go/types/sizes.go:
func ExtractGoObjectSizes(args []Object, index int) *_types.Sizes {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Sizes:
			return &r
		case *_types.Sizes:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Sizes]"))
}

// func _ConstructSizes(_v Object) _types.Sizes {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _types.Sizes:
// 			return _g
// 		case *_types.Sizes:
// 			return *_g
// 		}
// 	default:
// 		return _types.Sizes(_o.ABEND674(unknown underlying type *ast.InterfaceType for Sizes))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Sizes] or whatever"))
// }

GO TYPE go/types.Slice from go/types/type.go:
func ExtractGoObjectSlice(args []Object, index int) *_types.Slice {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Slice:
			return &r
		case *_types.Slice:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Slice]"))
}

func _mapToSlice(o Map) *_types.Slice {
	return &_types.Slice{
	}
}

func _vectorToSlice(o *Vector) *_types.Slice {
	return &_types.Slice{
	}
}

func _ConstructSlice(_v Object) *_types.Slice {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Slice:
			return &_g
		case *_types.Slice:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSlice(_o.(Map))
	case case *Vector:
		return _vectorToSlice(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Slice] or Map"))
}

GO TYPE go/types.StdSizes from go/types/sizes.go:
func ExtractGoObjectStdSizes(args []Object, index int) *_types.StdSizes {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.StdSizes:
			return &r
		case *_types.StdSizes:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.StdSizes]"))
}

func _mapToStdSizes(o Map) *_types.StdSizes {
	return &_types.StdSizes{
	}
}

func _vectorToStdSizes(o *Vector) *_types.StdSizes {
	return &_types.StdSizes{
	}
}

func _ConstructStdSizes(_v Object) *_types.StdSizes {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.StdSizes:
			return &_g
		case *_types.StdSizes:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToStdSizes(_o.(Map))
	case case *Vector:
		return _vectorToStdSizes(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.StdSizes] or Map"))
}

GO TYPE go/types.Struct from go/types/type.go:
func ExtractGoObjectStruct(args []Object, index int) *_types.Struct {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Struct:
			return &r
		case *_types.Struct:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Struct]"))
}

func _mapToStruct(o Map) *_types.Struct {
	return &_types.Struct{
	}
}

func _vectorToStruct(o *Vector) *_types.Struct {
	return &_types.Struct{
	}
}

func _ConstructStruct(_v Object) *_types.Struct {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Struct:
			return &_g
		case *_types.Struct:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToStruct(_o.(Map))
	case case *Vector:
		return _vectorToStruct(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Struct] or Map"))
}

GO TYPE go/types.Tuple from go/types/type.go:
func ExtractGoObjectTuple(args []Object, index int) *_types.Tuple {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Tuple:
			return &r
		case *_types.Tuple:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Tuple]"))
}

func _mapToTuple(o Map) *_types.Tuple {
	return &_types.Tuple{
	}
}

func _vectorToTuple(o *Vector) *_types.Tuple {
	return &_types.Tuple{
	}
}

func _ConstructTuple(_v Object) *_types.Tuple {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Tuple:
			return &_g
		case *_types.Tuple:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTuple(_o.(Map))
	case case *Vector:
		return _vectorToTuple(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Tuple] or Map"))
}

GO TYPE go/types.Type from go/types/type.go:
func ExtractGoObjectType(args []Object, index int) *_types.Type {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Type:
			return &r
		case *_types.Type:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Type]"))
}

// func _ConstructType(_v Object) _types.Type {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _types.Type:
// 			return _g
// 		case *_types.Type:
// 			return *_g
// 		}
// 	default:
// 		return _types.Type(_o.ABEND674(unknown underlying type *ast.InterfaceType for Type))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Type] or whatever"))
// }

GO TYPE go/types.TypeAndValue from go/types/api.go:
func ExtractGoObjectTypeAndValue(args []Object, index int) *_types.TypeAndValue {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.TypeAndValue:
			return &r
		case *_types.TypeAndValue:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.TypeAndValue]"))
}

func _mapToTypeAndValue(o Map) *_types.TypeAndValue {
	return &_types.TypeAndValue{
	}
}

func _vectorToTypeAndValue(o *Vector) *_types.TypeAndValue {
	return &_types.TypeAndValue{
	}
}

func _ConstructTypeAndValue(_v Object) *_types.TypeAndValue {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.TypeAndValue:
			return &_g
		case *_types.TypeAndValue:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTypeAndValue(_o.(Map))
	case case *Vector:
		return _vectorToTypeAndValue(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.TypeAndValue] or Map"))
}

GO TYPE go/types.TypeName from go/types/object.go:
func ExtractGoObjectTypeName(args []Object, index int) *_types.TypeName {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.TypeName:
			return &r
		case *_types.TypeName:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.TypeName]"))
}

func _mapToTypeName(o Map) *_types.TypeName {
	return &_types.TypeName{
	}
}

func _vectorToTypeName(o *Vector) *_types.TypeName {
	return &_types.TypeName{
	}
}

func _ConstructTypeName(_v Object) *_types.TypeName {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.TypeName:
			return &_g
		case *_types.TypeName:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTypeName(_o.(Map))
	case case *Vector:
		return _vectorToTypeName(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.TypeName] or Map"))
}

GO TYPE go/types.Var from go/types/object.go:
func ExtractGoObjectVar(args []Object, index int) *_types.Var {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Var:
			return &r
		case *_types.Var:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Var]"))
}

func _mapToVar(o Map) *_types.Var {
	return &_types.Var{
	}
}

func _vectorToVar(o *Vector) *_types.Var {
	return &_types.Var{
	}
}

func _ConstructVar(_v Object) *_types.Var {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Var:
			return &_g
		case *_types.Var:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToVar(_o.(Map))
	case case *Vector:
		return _vectorToVar(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Var] or Map"))
}

GO FUNC go/types.DefPredeclaredTestFuncs from go/types/universe.go:
// func __defPredeclaredTestFuncs() Object {
// 	_types.DefPredeclaredTestFuncs()
// 	...ABEND675: TODO...
// }

GO FUNC go/types.Default from go/types/predicates.go:
func __default(typ _types.Type) Object {
	_res := _types.Default(typ)
	return MakeGoObject(_res)
}

GO FUNC go/types.Eval from go/types/eval.go:
// func __eval(fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), pkg *_types.Package, pos ABEND987(genutils.go: imports not yet supported: token.Pos), expr string) Object {
// 	_, err := _types.Eval(fset, pkg, pos, expr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC go/types.ExprString from go/types/exprstring.go:
// func __exprString(x ABEND987(genutils.go: imports not yet supported: ast.Expr))  {
// 	_res := _types.ExprString(x)
// 	return MakeString(_res)
// }

GO FUNC go/types.LookupFieldOrMethod from go/types/lookup.go:
func __lookupFieldOrMethod(T _types.Type, addressable bool, pkg *_types.Package, name string) Object {
	obj, index, indirect := _types.LookupFieldOrMethod(T, addressable, pkg, name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(obj))
	_vec1 := EmptyVector
	for _, _elem1 := range index {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(MakeBoolean(indirect))
	return _res
}

GO FUNC go/types.MissingMethod from go/types/lookup.go:
func __missingMethod(V _types.Type, T *_types.Interface, static bool) Object {
	method, wrongType := _types.MissingMethod(V, T, static)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(method))
	_res = _res.Conjoin(MakeBoolean(wrongType))
	return _res
}

GO FUNC go/types.NewArray from go/types/type.go:
func __newArray(elem _types.Type, len int64) Object {
	_res := _types.NewArray(elem, len)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewChan from go/types/type.go:
func __newChan(dir _types.ChanDir, elem _types.Type) Object {
	_res := _types.NewChan(dir, elem)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewChecker from go/types/check.go:
// func __newChecker(conf *_types.Config, fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), pkg *_types.Package, info *_types.Info) Object {
// 	_res := _types.NewChecker(conf, fset, pkg, info)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewConst from go/types/object.go:
// func __newConst(pos ABEND987(genutils.go: imports not yet supported: token.Pos), pkg *_types.Package, name string, typ _types.Type, val ABEND987(genutils.go: imports not yet supported: constant.Value)) Object {
// 	_res := _types.NewConst(pos, pkg, name, typ, val)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewField from go/types/object.go:
// func __newField(pos ABEND987(genutils.go: imports not yet supported: token.Pos), pkg *_types.Package, name string, typ _types.Type, embedded bool) Object {
// 	_res := _types.NewField(pos, pkg, name, typ, embedded)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewFunc from go/types/object.go:
// func __newFunc(pos ABEND987(genutils.go: imports not yet supported: token.Pos), pkg *_types.Package, name string, sig *_types.Signature) Object {
// 	_res := _types.NewFunc(pos, pkg, name, sig)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewInterface from go/types/type.go:
// func __newInterface(methods []*_types.Func, embeddeds []*_types.Named) Object {
// 	_res := _types.NewInterface(methods, embeddeds)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewInterfaceType from go/types/type.go:
// func __newInterfaceType(methods []*_types.Func, embeddeds []_types.Type) Object {
// 	_res := _types.NewInterfaceType(methods, embeddeds)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewLabel from go/types/object.go:
// func __newLabel(pos ABEND987(genutils.go: imports not yet supported: token.Pos), pkg *_types.Package, name string) Object {
// 	_res := _types.NewLabel(pos, pkg, name)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewMap from go/types/type.go:
func __newMap(key _types.Type, elem _types.Type) Object {
	_res := _types.NewMap(key, elem)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewMethodSet from go/types/methodset.go:
func __newMethodSet(T _types.Type) Object {
	_res := _types.NewMethodSet(T)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewNamed from go/types/type.go:
// func __newNamed(obj *_types.TypeName, underlying _types.Type, methods []*_types.Func) Object {
// 	_res := _types.NewNamed(obj, underlying, methods)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewPackage from go/types/package.go:
func __newPackage(path string, name string) Object {
	_res := _types.NewPackage(path, name)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewParam from go/types/object.go:
// func __newParam(pos ABEND987(genutils.go: imports not yet supported: token.Pos), pkg *_types.Package, name string, typ _types.Type) Object {
// 	_res := _types.NewParam(pos, pkg, name, typ)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewPkgName from go/types/object.go:
// func __newPkgName(pos ABEND987(genutils.go: imports not yet supported: token.Pos), pkg *_types.Package, name string, imported *_types.Package) Object {
// 	_res := _types.NewPkgName(pos, pkg, name, imported)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewPointer from go/types/type.go:
func __newPointer(elem _types.Type) Object {
	_res := _types.NewPointer(elem)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewScope from go/types/scope.go:
// func __newScope(parent *_types.Scope, pos ABEND987(genutils.go: imports not yet supported: token.Pos), end ABEND987(genutils.go: imports not yet supported: token.Pos), comment string) Object {
// 	_res := _types.NewScope(parent, pos, end, comment)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewSignature from go/types/type.go:
func __newSignature(recv *_types.Var, params *_types.Tuple, results *_types.Tuple, variadic bool) Object {
	_res := _types.NewSignature(recv, params, results, variadic)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewSlice from go/types/type.go:
func __newSlice(elem _types.Type) Object {
	_res := _types.NewSlice(elem)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewStruct from go/types/type.go:
// func __newStruct(fields []*_types.Var, tags []string) Object {
// 	_res := _types.NewStruct(fields, tags)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewTuple from go/types/type.go:
// func __newTuple(x ...*_types.Var) Object {
// 	_res := _types.NewTuple(x)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewTypeName from go/types/object.go:
// func __newTypeName(pos ABEND987(genutils.go: imports not yet supported: token.Pos), pkg *_types.Package, name string, typ _types.Type) Object {
// 	_res := _types.NewTypeName(pos, pkg, name, typ)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewVar from go/types/object.go:
// func __newVar(pos ABEND987(genutils.go: imports not yet supported: token.Pos), pkg *_types.Package, name string, typ _types.Type) Object {
// 	_res := _types.NewVar(pos, pkg, name, typ)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.RelativeTo from go/types/typestring.go:
func __relativeTo(pkg *_types.Package) Object {
	_res := _types.RelativeTo(pkg)
	return MakeGoObject(_res)
}

GO FUNC go/types.SizesFor from go/types/sizes.go:
func __sizesFor(compiler string, arch string) Object {
	_res := _types.SizesFor(compiler, arch)
	return MakeGoObject(_res)
}

GO FUNC go/types.WriteExpr from go/types/exprstring.go:
// func __writeExpr(buf *ABEND987(genutils.go: imports not yet supported: bytes.Buffer), x ABEND987(genutils.go: imports not yet supported: ast.Expr)) Object {
// 	_types.WriteExpr(buf, x)
// 	...ABEND675: TODO...
// }

GO FUNC go/types.WriteSignature from go/types/typestring.go:
// func __writeSignature(buf *ABEND987(genutils.go: imports not yet supported: bytes.Buffer), sig *_types.Signature, qf _types.Qualifier) Object {
// 	_types.WriteSignature(buf, sig, qf)
// 	...ABEND675: TODO...
// }

GO FUNC go/types.WriteType from go/types/typestring.go:
// func __writeType(buf *ABEND987(genutils.go: imports not yet supported: bytes.Buffer), typ _types.Type, qf _types.Qualifier) Object {
// 	_types.WriteType(buf, typ, qf)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package types

import (
	_types "go/types"
	. "github.com/candid82/joker/core"
)
GO FUNC hash/adler32.Checksum from hash/adler32/adler32.go:
// func __checksum(data []byte) Object {
// 	_res := _adler32.Checksum(data)
// 	return MakeInt(int(_res))
// }

GO FUNC hash/adler32.New from hash/adler32/adler32.go:
func __new() Object {
	_res := _adler32.New()
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package adler32

import (
	_adler32 "hash/adler32"
	. "github.com/candid82/joker/core"
)
GO TYPE hash/crc32.Table from hash/crc32/crc32.go:
func ExtractGoObjectTable(args []Object, index int) *_crc32.Table {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _crc32.Table:
			return &r
		case *_crc32.Table:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[hash/crc32.Table]"))
}

// func _ConstructTable(_v Object) _crc32.Table {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _crc32.Table:
// 			return _g
// 		case *_crc32.Table:
// 			return *_g
// 		}
// 	default:
// 		return _crc32.Table(_o.ABEND674(unknown underlying type *ast.ArrayType for Table))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[crc32.Table] or whatever"))
// }

GO FUNC hash/crc32.Checksum from hash/crc32/crc32.go:
// func __checksum(data []byte, tab *_crc32.Table) Object {
// 	_res := _crc32.Checksum(data, tab)
// 	return MakeInt(int(_res))
// }

GO FUNC hash/crc32.ChecksumIEEE from hash/crc32/crc32.go:
// func __checksumIEEE(data []byte) Object {
// 	_res := _crc32.ChecksumIEEE(data)
// 	return MakeInt(int(_res))
// }

GO FUNC hash/crc32.MakeTable from hash/crc32/crc32.go:
func __makeTable(poly uint32) Object {
	_res := _crc32.MakeTable(poly)
	return MakeGoObject(_res)
}

GO FUNC hash/crc32.New from hash/crc32/crc32.go:
func __new(tab *_crc32.Table) Object {
	_res := _crc32.New(tab)
	return MakeGoObject(_res)
}

GO FUNC hash/crc32.NewIEEE from hash/crc32/crc32.go:
func __newIEEE() Object {
	_res := _crc32.NewIEEE()
	return MakeGoObject(_res)
}

GO FUNC hash/crc32.Update from hash/crc32/crc32.go:
// func __update(crc uint32, tab *_crc32.Table, p []byte) Object {
// 	_res := _crc32.Update(crc, tab, p)
// 	return MakeInt(int(_res))
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package crc32

import (
	_crc32 "hash/crc32"
	. "github.com/candid82/joker/core"
)
GO TYPE hash/crc64.Table from hash/crc64/crc64.go:
func ExtractGoObjectTable(args []Object, index int) *_crc64.Table {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _crc64.Table:
			return &r
		case *_crc64.Table:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[hash/crc64.Table]"))
}

// func _ConstructTable(_v Object) _crc64.Table {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _crc64.Table:
// 			return _g
// 		case *_crc64.Table:
// 			return *_g
// 		}
// 	default:
// 		return _crc64.Table(_o.ABEND674(unknown underlying type *ast.ArrayType for Table))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[crc64.Table] or whatever"))
// }

GO FUNC hash/crc64.Checksum from hash/crc64/crc64.go:
// func __checksum(data []byte, tab *_crc64.Table) Object {
// 	_res := _crc64.Checksum(data, tab)
// 	return MakeBigInt(uint64(_res))
// }

GO FUNC hash/crc64.MakeTable from hash/crc64/crc64.go:
// func __makeTable(poly uint64) Object {
// 	_res := _crc64.MakeTable(poly)
// 	return MakeGoObject(_res)
// }

GO FUNC hash/crc64.New from hash/crc64/crc64.go:
func __new(tab *_crc64.Table) Object {
	_res := _crc64.New(tab)
	return MakeGoObject(_res)
}

GO FUNC hash/crc64.Update from hash/crc64/crc64.go:
// func __update(crc uint64, tab *_crc64.Table, p []byte) Object {
// 	_res := _crc64.Update(crc, tab, p)
// 	return MakeBigInt(uint64(_res))
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package crc64

import (
	_crc64 "hash/crc64"
	. "github.com/candid82/joker/core"
)
GO FUNC hash/fnv.New128 from hash/fnv/fnv.go:
func __new128() Object {
	_res := _fnv.New128()
	return MakeGoObject(_res)
}

GO FUNC hash/fnv.New128a from hash/fnv/fnv.go:
func __new128a() Object {
	_res := _fnv.New128a()
	return MakeGoObject(_res)
}

GO FUNC hash/fnv.New32 from hash/fnv/fnv.go:
func __new32() Object {
	_res := _fnv.New32()
	return MakeGoObject(_res)
}

GO FUNC hash/fnv.New32a from hash/fnv/fnv.go:
func __new32a() Object {
	_res := _fnv.New32a()
	return MakeGoObject(_res)
}

GO FUNC hash/fnv.New64 from hash/fnv/fnv.go:
func __new64() Object {
	_res := _fnv.New64()
	return MakeGoObject(_res)
}

GO FUNC hash/fnv.New64a from hash/fnv/fnv.go:
func __new64a() Object {
	_res := _fnv.New64a()
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package fnv

import (
	_fnv "hash/fnv"
	. "github.com/candid82/joker/core"
)
// Auto-generated by gostd at (omitted for testing), do not edit!!

package html

import (
)
GO TYPE html/template.CSS from html/template/content.go:
func ExtractGoObjectCSS(args []Object, index int) *_template.CSS {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.CSS:
			return &r
		case *_template.CSS:
			return r
		}
	case String:
		v := _template.CSS(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.CSS]"))
}

func _ConstructCSS(_v Object) _template.CSS {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.CSS:
			return _g
		case *_template.CSS:
			return *_g
		}
	case String:
		return _template.CSS(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.CSS] or String"))
}

GO TYPE html/template.Error from html/template/error.go:
func ExtractGoObjectError(args []Object, index int) *_template.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.Error:
			return &r
		case *_template.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.Error]"))
}

func _mapToError(o Map) *_template.Error {
	return &_template.Error{
	}
}

func _vectorToError(o *Vector) *_template.Error {
	return &_template.Error{
	}
}

func _ConstructError(_v Object) *_template.Error {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.Error:
			return &_g
		case *_template.Error:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToError(_o.(Map))
	case case *Vector:
		return _vectorToError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.Error] or Map"))
}

GO TYPE html/template.ErrorCode from html/template/error.go:
func ExtractGoObjectErrorCode(args []Object, index int) *_template.ErrorCode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.ErrorCode:
			return &r
		case *_template.ErrorCode:
			return r
		}
	case Int:
		v := _template.ErrorCode(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.ErrorCode]"))
}

func _ConstructErrorCode(_v Object) _template.ErrorCode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.ErrorCode:
			return _g
		case *_template.ErrorCode:
			return *_g
		}
	case Number:
		return _template.ErrorCode(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.ErrorCode] or Number"))
}

GO TYPE html/template.FuncMap from html/template/template.go:
func ExtractGoObjectFuncMap(args []Object, index int) *_template.FuncMap {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.FuncMap:
			return &r
		case *_template.FuncMap:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.FuncMap]"))
}

// func _ConstructFuncMap(_v Object) _template.FuncMap {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _template.FuncMap:
// 			return _g
// 		case *_template.FuncMap:
// 			return *_g
// 		}
// 	default:
// 		return _template.FuncMap(_o.ABEND674(unknown underlying type *ast.MapType for FuncMap))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[template.FuncMap] or whatever"))
// }

GO TYPE html/template.HTML from html/template/content.go:
func ExtractGoObjectHTML(args []Object, index int) *_template.HTML {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.HTML:
			return &r
		case *_template.HTML:
			return r
		}
	case String:
		v := _template.HTML(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.HTML]"))
}

func _ConstructHTML(_v Object) _template.HTML {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.HTML:
			return _g
		case *_template.HTML:
			return *_g
		}
	case String:
		return _template.HTML(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.HTML] or String"))
}

GO TYPE html/template.HTMLAttr from html/template/content.go:
func ExtractGoObjectHTMLAttr(args []Object, index int) *_template.HTMLAttr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.HTMLAttr:
			return &r
		case *_template.HTMLAttr:
			return r
		}
	case String:
		v := _template.HTMLAttr(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.HTMLAttr]"))
}

func _ConstructHTMLAttr(_v Object) _template.HTMLAttr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.HTMLAttr:
			return _g
		case *_template.HTMLAttr:
			return *_g
		}
	case String:
		return _template.HTMLAttr(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.HTMLAttr] or String"))
}

GO TYPE html/template.JS from html/template/content.go:
func ExtractGoObjectJS(args []Object, index int) *_template.JS {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.JS:
			return &r
		case *_template.JS:
			return r
		}
	case String:
		v := _template.JS(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.JS]"))
}

func _ConstructJS(_v Object) _template.JS {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.JS:
			return _g
		case *_template.JS:
			return *_g
		}
	case String:
		return _template.JS(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.JS] or String"))
}

GO TYPE html/template.JSStr from html/template/content.go:
func ExtractGoObjectJSStr(args []Object, index int) *_template.JSStr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.JSStr:
			return &r
		case *_template.JSStr:
			return r
		}
	case String:
		v := _template.JSStr(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.JSStr]"))
}

func _ConstructJSStr(_v Object) _template.JSStr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.JSStr:
			return _g
		case *_template.JSStr:
			return *_g
		}
	case String:
		return _template.JSStr(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.JSStr] or String"))
}

GO TYPE html/template.Srcset from html/template/content.go:
func ExtractGoObjectSrcset(args []Object, index int) *_template.Srcset {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.Srcset:
			return &r
		case *_template.Srcset:
			return r
		}
	case String:
		v := _template.Srcset(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.Srcset]"))
}

func _ConstructSrcset(_v Object) _template.Srcset {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.Srcset:
			return _g
		case *_template.Srcset:
			return *_g
		}
	case String:
		return _template.Srcset(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.Srcset] or String"))
}

GO TYPE html/template.Template from html/template/template.go:
func ExtractGoObjectTemplate(args []Object, index int) *_template.Template {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.Template:
			return &r
		case *_template.Template:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.Template]"))
}

func _mapToTemplate(o Map) *_template.Template {
	return &_template.Template{
	}
}

func _vectorToTemplate(o *Vector) *_template.Template {
	return &_template.Template{
	}
}

func _ConstructTemplate(_v Object) *_template.Template {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.Template:
			return &_g
		case *_template.Template:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTemplate(_o.(Map))
	case case *Vector:
		return _vectorToTemplate(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.Template] or Map"))
}

GO TYPE html/template.URL from html/template/content.go:
func ExtractGoObjectURL(args []Object, index int) *_template.URL {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.URL:
			return &r
		case *_template.URL:
			return r
		}
	case String:
		v := _template.URL(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.URL]"))
}

func _ConstructURL(_v Object) _template.URL {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.URL:
			return _g
		case *_template.URL:
			return *_g
		}
	case String:
		return _template.URL(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.URL] or String"))
}

GO FUNC html/template.HTMLEscape from html/template/escape.go:
// func __hTMLEscape(w ABEND987(genutils.go: imports not yet supported: io.Writer), b []byte) Object {
// 	_template.HTMLEscape(w, b)
// 	...ABEND675: TODO...
// }

GO FUNC html/template.HTMLEscaper from html/template/escape.go:
// func __hTMLEscaper(args ...interface {})  {
// 	_res := _template.HTMLEscaper(args)
// 	return MakeString(_res)
// }

GO FUNC html/template.IsTrue from html/template/template.go:
// func __isTrue(val interface {}) Object {
// 	truth, ok := _template.IsTrue(val)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeBoolean(truth))
// 	_res = _res.Conjoin(MakeBoolean(ok))
// 	return _res
// }

GO FUNC html/template.JSEscape from html/template/escape.go:
// func __jSEscape(w ABEND987(genutils.go: imports not yet supported: io.Writer), b []byte) Object {
// 	_template.JSEscape(w, b)
// 	...ABEND675: TODO...
// }

GO FUNC html/template.JSEscaper from html/template/escape.go:
// func __jSEscaper(args ...interface {})  {
// 	_res := _template.JSEscaper(args)
// 	return MakeString(_res)
// }

GO FUNC html/template.Must from html/template/template.go:
// func __must(t *_template.Template, err error) Object {
// 	_res := _template.Must(t, err)
// 	return MakeGoObject(_res)
// }

GO FUNC html/template.New from html/template/template.go:
func __new(name string) Object {
	_res := _template.New(name)
	return MakeGoObject(_res)
}

GO FUNC html/template.ParseFiles from html/template/template.go:
// func __parseFiles(filenames ...string) Object {
// 	_res1, _res2 := _template.ParseFiles(filenames)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC html/template.ParseGlob from html/template/template.go:
func __parseGlob(pattern string) Object {
	_res1, _res2 := _template.ParseGlob(pattern)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC html/template.URLQueryEscaper from html/template/escape.go:
// func __uRLQueryEscaper(args ...interface {})  {
// 	_res := _template.URLQueryEscaper(args)
// 	return MakeString(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package template

import (
	_template "html/template"
	. "github.com/candid82/joker/core"
)
GO TYPE image.Alpha from image/image.go:
func ExtractGoObjectAlpha(args []Object, index int) *_image.Alpha {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.Alpha:
			return &r
		case *_image.Alpha:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.Alpha]"))
}

func _mapToAlpha(o Map) *_image.Alpha {
	return &_image.Alpha{
	}
}

func _vectorToAlpha(o *Vector) *_image.Alpha {
	return &_image.Alpha{
	}
}

func _ConstructAlpha(_v Object) *_image.Alpha {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _image.Alpha:
			return &_g
		case *_image.Alpha:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToAlpha(_o.(Map))
	case case *Vector:
		return _vectorToAlpha(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[image.Alpha] or Map"))
}

GO TYPE image.Alpha16 from image/image.go:
func ExtractGoObjectAlpha16(args []Object, index int) *_image.Alpha16 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.Alpha16:
			return &r
		case *_image.Alpha16:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.Alpha16]"))
}

func _mapToAlpha16(o Map) *_image.Alpha16 {
	return &_image.Alpha16{
	}
}

func _vectorToAlpha16(o *Vector) *_image.Alpha16 {
	return &_image.Alpha16{
	}
}

func _ConstructAlpha16(_v Object) *_image.Alpha16 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _image.Alpha16:
			return &_g
		case *_image.Alpha16:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToAlpha16(_o.(Map))
	case case *Vector:
		return _vectorToAlpha16(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[image.Alpha16] or Map"))
}

GO TYPE image.CMYK from image/image.go:
func ExtractGoObjectCMYK(args []Object, index int) *_image.CMYK {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.CMYK:
			return &r
		case *_image.CMYK:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.CMYK]"))
}

func _mapToCMYK(o Map) *_image.CMYK {
	return &_image.CMYK{
	}
}

func _vectorToCMYK(o *Vector) *_image.CMYK {
	return &_image.CMYK{
	}
}

func _ConstructCMYK(_v Object) *_image.CMYK {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _image.CMYK:
			return &_g
		case *_image.CMYK:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCMYK(_o.(Map))
	case case *Vector:
		return _vectorToCMYK(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[image.CMYK] or Map"))
}

GO TYPE image.Config from image/image.go:
func ExtractGoObjectConfig(args []Object, index int) *_image.Config {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.Config:
			return &r
		case *_image.Config:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.Config]"))
}

func _mapToConfig(o Map) *_image.Config {
	return &_image.Config{
	}
}

func _vectorToConfig(o *Vector) *_image.Config {
	return &_image.Config{
	}
}

func _ConstructConfig(_v Object) *_image.Config {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _image.Config:
			return &_g
		case *_image.Config:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToConfig(_o.(Map))
	case case *Vector:
		return _vectorToConfig(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[image.Config] or Map"))
}

GO TYPE image.Gray from image/image.go:
func ExtractGoObjectGray(args []Object, index int) *_image.Gray {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.Gray:
			return &r
		case *_image.Gray:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.Gray]"))
}

func _mapToGray(o Map) *_image.Gray {
	return &_image.Gray{
	}
}

func _vectorToGray(o *Vector) *_image.Gray {
	return &_image.Gray{
	}
}

func _ConstructGray(_v Object) *_image.Gray {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _image.Gray:
			return &_g
		case *_image.Gray:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToGray(_o.(Map))
	case case *Vector:
		return _vectorToGray(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[image.Gray] or Map"))
}

GO TYPE image.Gray16 from image/image.go:
func ExtractGoObjectGray16(args []Object, index int) *_image.Gray16 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.Gray16:
			return &r
		case *_image.Gray16:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.Gray16]"))
}

func _mapToGray16(o Map) *_image.Gray16 {
	return &_image.Gray16{
	}
}

func _vectorToGray16(o *Vector) *_image.Gray16 {
	return &_image.Gray16{
	}
}

func _ConstructGray16(_v Object) *_image.Gray16 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _image.Gray16:
			return &_g
		case *_image.Gray16:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToGray16(_o.(Map))
	case case *Vector:
		return _vectorToGray16(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[image.Gray16] or Map"))
}

GO TYPE image.Image from image/image.go:
func ExtractGoObjectImage(args []Object, index int) *_image.Image {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.Image:
			return &r
		case *_image.Image:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.Image]"))
}

// func _ConstructImage(_v Object) _image.Image {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _image.Image:
// 			return _g
// 		case *_image.Image:
// 			return *_g
// 		}
// 	default:
// 		return _image.Image(_o.ABEND674(unknown underlying type *ast.InterfaceType for Image))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[image.Image] or whatever"))
// }

GO TYPE image.NRGBA from image/image.go:
func ExtractGoObjectNRGBA(args []Object, index int) *_image.NRGBA {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.NRGBA:
			return &r
		case *_image.NRGBA:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.NRGBA]"))
}

func _mapToNRGBA(o Map) *_image.NRGBA {
	return &_image.NRGBA{
	}
}

func _vectorToNRGBA(o *Vector) *_image.NRGBA {
	return &_image.NRGBA{
	}
}

func _ConstructNRGBA(_v Object) *_image.NRGBA {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _image.NRGBA:
			return &_g
		case *_image.NRGBA:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNRGBA(_o.(Map))
	case case *Vector:
		return _vectorToNRGBA(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[image.NRGBA] or Map"))
}

GO TYPE image.NRGBA64 from image/image.go:
func ExtractGoObjectNRGBA64(args []Object, index int) *_image.NRGBA64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.NRGBA64:
			return &r
		case *_image.NRGBA64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.NRGBA64]"))
}

func _mapToNRGBA64(o Map) *_image.NRGBA64 {
	return &_image.NRGBA64{
	}
}

func _vectorToNRGBA64(o *Vector) *_image.NRGBA64 {
	return &_image.NRGBA64{
	}
}

func _ConstructNRGBA64(_v Object) *_image.NRGBA64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _image.NRGBA64:
			return &_g
		case *_image.NRGBA64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNRGBA64(_o.(Map))
	case case *Vector:
		return _vectorToNRGBA64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[image.NRGBA64] or Map"))
}

GO TYPE image.NYCbCrA from image/ycbcr.go:
func ExtractGoObjectNYCbCrA(args []Object, index int) *_image.NYCbCrA {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.NYCbCrA:
			return &r
		case *_image.NYCbCrA:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.NYCbCrA]"))
}

func _mapToNYCbCrA(o Map) *_image.NYCbCrA {
	return &_image.NYCbCrA{
	}
}

func _vectorToNYCbCrA(o *Vector) *_image.NYCbCrA {
	return &_image.NYCbCrA{
	}
}

func _ConstructNYCbCrA(_v Object) *_image.NYCbCrA {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _image.NYCbCrA:
			return &_g
		case *_image.NYCbCrA:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNYCbCrA(_o.(Map))
	case case *Vector:
		return _vectorToNYCbCrA(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[image.NYCbCrA] or Map"))
}

GO TYPE image.Paletted from image/image.go:
func ExtractGoObjectPaletted(args []Object, index int) *_image.Paletted {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.Paletted:
			return &r
		case *_image.Paletted:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.Paletted]"))
}

func _mapToPaletted(o Map) *_image.Paletted {
	return &_image.Paletted{
	}
}

func _vectorToPaletted(o *Vector) *_image.Paletted {
	return &_image.Paletted{
	}
}

func _ConstructPaletted(_v Object) *_image.Paletted {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _image.Paletted:
			return &_g
		case *_image.Paletted:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPaletted(_o.(Map))
	case case *Vector:
		return _vectorToPaletted(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[image.Paletted] or Map"))
}

GO TYPE image.PalettedImage from image/image.go:
func ExtractGoObjectPalettedImage(args []Object, index int) *_image.PalettedImage {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.PalettedImage:
			return &r
		case *_image.PalettedImage:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.PalettedImage]"))
}

// func _ConstructPalettedImage(_v Object) _image.PalettedImage {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _image.PalettedImage:
// 			return _g
// 		case *_image.PalettedImage:
// 			return *_g
// 		}
// 	default:
// 		return _image.PalettedImage(_o.ABEND674(unknown underlying type *ast.InterfaceType for PalettedImage))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[image.PalettedImage] or whatever"))
// }

GO TYPE image.Point from image/geom.go:
func ExtractGoObjectPoint(args []Object, index int) *_image.Point {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.Point:
			return &r
		case *_image.Point:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.Point]"))
}

func _mapToPoint(o Map) *_image.Point {
	return &_image.Point{
	}
}

func _vectorToPoint(o *Vector) *_image.Point {
	return &_image.Point{
	}
}

func _ConstructPoint(_v Object) *_image.Point {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _image.Point:
			return &_g
		case *_image.Point:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPoint(_o.(Map))
	case case *Vector:
		return _vectorToPoint(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[image.Point] or Map"))
}

GO TYPE image.RGBA from image/image.go:
func ExtractGoObjectRGBA(args []Object, index int) *_image.RGBA {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.RGBA:
			return &r
		case *_image.RGBA:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.RGBA]"))
}

func _mapToRGBA(o Map) *_image.RGBA {
	return &_image.RGBA{
	}
}

func _vectorToRGBA(o *Vector) *_image.RGBA {
	return &_image.RGBA{
	}
}

func _ConstructRGBA(_v Object) *_image.RGBA {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _image.RGBA:
			return &_g
		case *_image.RGBA:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRGBA(_o.(Map))
	case case *Vector:
		return _vectorToRGBA(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[image.RGBA] or Map"))
}

GO TYPE image.RGBA64 from image/image.go:
func ExtractGoObjectRGBA64(args []Object, index int) *_image.RGBA64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.RGBA64:
			return &r
		case *_image.RGBA64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.RGBA64]"))
}

func _mapToRGBA64(o Map) *_image.RGBA64 {
	return &_image.RGBA64{
	}
}

func _vectorToRGBA64(o *Vector) *_image.RGBA64 {
	return &_image.RGBA64{
	}
}

func _ConstructRGBA64(_v Object) *_image.RGBA64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _image.RGBA64:
			return &_g
		case *_image.RGBA64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRGBA64(_o.(Map))
	case case *Vector:
		return _vectorToRGBA64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[image.RGBA64] or Map"))
}

GO TYPE image.Rectangle from image/geom.go:
func ExtractGoObjectRectangle(args []Object, index int) *_image.Rectangle {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.Rectangle:
			return &r
		case *_image.Rectangle:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.Rectangle]"))
}

func _mapToRectangle(o Map) *_image.Rectangle {
	return &_image.Rectangle{
	}
}

func _vectorToRectangle(o *Vector) *_image.Rectangle {
	return &_image.Rectangle{
	}
}

func _ConstructRectangle(_v Object) *_image.Rectangle {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _image.Rectangle:
			return &_g
		case *_image.Rectangle:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRectangle(_o.(Map))
	case case *Vector:
		return _vectorToRectangle(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[image.Rectangle] or Map"))
}

GO TYPE image.Uniform from image/names.go:
func ExtractGoObjectUniform(args []Object, index int) *_image.Uniform {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.Uniform:
			return &r
		case *_image.Uniform:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.Uniform]"))
}

func _mapToUniform(o Map) *_image.Uniform {
	return &_image.Uniform{
	}
}

func _vectorToUniform(o *Vector) *_image.Uniform {
	return &_image.Uniform{
	}
}

func _ConstructUniform(_v Object) *_image.Uniform {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _image.Uniform:
			return &_g
		case *_image.Uniform:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUniform(_o.(Map))
	case case *Vector:
		return _vectorToUniform(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[image.Uniform] or Map"))
}

GO TYPE image.YCbCr from image/ycbcr.go:
func ExtractGoObjectYCbCr(args []Object, index int) *_image.YCbCr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.YCbCr:
			return &r
		case *_image.YCbCr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.YCbCr]"))
}

func _mapToYCbCr(o Map) *_image.YCbCr {
	return &_image.YCbCr{
	}
}

func _vectorToYCbCr(o *Vector) *_image.YCbCr {
	return &_image.YCbCr{
	}
}

func _ConstructYCbCr(_v Object) *_image.YCbCr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _image.YCbCr:
			return &_g
		case *_image.YCbCr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToYCbCr(_o.(Map))
	case case *Vector:
		return _vectorToYCbCr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[image.YCbCr] or Map"))
}

GO TYPE image.YCbCrSubsampleRatio from image/ycbcr.go:
func ExtractGoObjectYCbCrSubsampleRatio(args []Object, index int) *_image.YCbCrSubsampleRatio {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.YCbCrSubsampleRatio:
			return &r
		case *_image.YCbCrSubsampleRatio:
			return r
		}
	case Int:
		v := _image.YCbCrSubsampleRatio(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.YCbCrSubsampleRatio]"))
}

func _ConstructYCbCrSubsampleRatio(_v Object) _image.YCbCrSubsampleRatio {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _image.YCbCrSubsampleRatio:
			return _g
		case *_image.YCbCrSubsampleRatio:
			return *_g
		}
	case Number:
		return _image.YCbCrSubsampleRatio(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[image.YCbCrSubsampleRatio] or Number"))
}

GO FUNC image.Decode from image/format.go:
// func __decode(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2, _res3 := _image.Decode(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(MakeString(_res2))
// 	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
// 	return _res
// }

GO FUNC image.DecodeConfig from image/format.go:
// func __decodeConfig(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2, _res3 := _image.DecodeConfig(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(MakeString(_res2))
// 	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
// 	return _res
// }

GO FUNC image.NewAlpha from image/image.go:
func __newAlpha(r _image.Rectangle) Object {
	_res := _image.NewAlpha(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewAlpha16 from image/image.go:
func __newAlpha16(r _image.Rectangle) Object {
	_res := _image.NewAlpha16(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewCMYK from image/image.go:
func __newCMYK(r _image.Rectangle) Object {
	_res := _image.NewCMYK(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewGray from image/image.go:
func __newGray(r _image.Rectangle) Object {
	_res := _image.NewGray(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewGray16 from image/image.go:
func __newGray16(r _image.Rectangle) Object {
	_res := _image.NewGray16(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewNRGBA from image/image.go:
func __newNRGBA(r _image.Rectangle) Object {
	_res := _image.NewNRGBA(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewNRGBA64 from image/image.go:
func __newNRGBA64(r _image.Rectangle) Object {
	_res := _image.NewNRGBA64(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewNYCbCrA from image/ycbcr.go:
func __newNYCbCrA(r _image.Rectangle, subsampleRatio _image.YCbCrSubsampleRatio) Object {
	_res := _image.NewNYCbCrA(r, subsampleRatio)
	return MakeGoObject(_res)
}

GO FUNC image.NewPaletted from image/image.go:
// func __newPaletted(r _image.Rectangle, p ABEND987(genutils.go: imports not yet supported: color.Palette)) Object {
// 	_res := _image.NewPaletted(r, p)
// 	return MakeGoObject(_res)
// }

GO FUNC image.NewRGBA from image/image.go:
func __newRGBA(r _image.Rectangle) Object {
	_res := _image.NewRGBA(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewRGBA64 from image/image.go:
func __newRGBA64(r _image.Rectangle) Object {
	_res := _image.NewRGBA64(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewUniform from image/names.go:
// func __newUniform(c ABEND987(genutils.go: imports not yet supported: color.Color)) Object {
// 	_res := _image.NewUniform(c)
// 	return MakeGoObject(_res)
// }

GO FUNC image.NewYCbCr from image/ycbcr.go:
func __newYCbCr(r _image.Rectangle, subsampleRatio _image.YCbCrSubsampleRatio) Object {
	_res := _image.NewYCbCr(r, subsampleRatio)
	return MakeGoObject(_res)
}

GO FUNC image.Pt from image/geom.go:
func __pt(X int, Y int) Object {
	_res := _image.Pt(X, Y)
	return MakeGoObject(_res)
}

GO FUNC image.Rect from image/geom.go:
func __rect(x0 int, y0 int, x1 int, y1 int) Object {
	_res := _image.Rect(x0, y0, x1, y1)
	return MakeGoObject(_res)
}

GO FUNC image.RegisterFormat from image/format.go:
// func __registerFormat(name string, magic string, decode func, decodeConfig func) Object {
// 	_image.RegisterFormat(name, magic, decode, decodeConfig)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package image

import (
	_image "image"
	. "github.com/candid82/joker/core"
)
GO FUNC image/color.CMYKToRGB from image/color/ycbcr.go:
// func __cMYKToRGB(c uint8, m uint8, y uint8, k uint8) Object {
// 	_res1, _res2, _res3 := _color.CMYKToRGB(c, m, y, k)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(_res2)
// 	_res = _res.Conjoin(_res3)
// 	return _res
// }

GO FUNC image/color.ModelFunc from image/color/color.go:
// func __modelFunc(f func) Object {
// 	_res := _color.ModelFunc(f)
// 	return MakeGoObject(_res)
// }

GO FUNC image/color.RGBToCMYK from image/color/ycbcr.go:
// func __rGBToCMYK(r uint8, g uint8, b uint8) Object {
// 	_res1, _res2, _res3, _res4 := _color.RGBToCMYK(r, g, b)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(_res2)
// 	_res = _res.Conjoin(_res3)
// 	_res = _res.Conjoin(_res4)
// 	return _res
// }

GO FUNC image/color.RGBToYCbCr from image/color/ycbcr.go:
// func __rGBToYCbCr(r uint8, g uint8, b uint8) Object {
// 	_res1, _res2, _res3 := _color.RGBToYCbCr(r, g, b)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(_res2)
// 	_res = _res.Conjoin(_res3)
// 	return _res
// }

GO FUNC image/color.YCbCrToRGB from image/color/ycbcr.go:
// func __yCbCrToRGB(y uint8, cb uint8, cr uint8) Object {
// 	_res1, _res2, _res3 := _color.YCbCrToRGB(y, cb, cr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(_res2)
// 	_res = _res.Conjoin(_res3)
// 	return _res
// }

GO FUNC image/draw.Draw from image/draw/draw.go:
// func __draw(dst _draw.Image, r ABEND987(genutils.go: imports not yet supported: image.Rectangle), src ABEND987(genutils.go: imports not yet supported: image.Image), sp ABEND987(genutils.go: imports not yet supported: image.Point), op _draw.Op) Object {
// 	_draw.Draw(dst, r, src, sp, op)
// 	...ABEND675: TODO...
// }

GO FUNC image/draw.DrawMask from image/draw/draw.go:
// func __drawMask(dst _draw.Image, r ABEND987(genutils.go: imports not yet supported: image.Rectangle), src ABEND987(genutils.go: imports not yet supported: image.Image), sp ABEND987(genutils.go: imports not yet supported: image.Point), mask ABEND987(genutils.go: imports not yet supported: image.Image), mp ABEND987(genutils.go: imports not yet supported: image.Point), op _draw.Op) Object {
// 	_draw.DrawMask(dst, r, src, sp, mask, mp, op)
// 	...ABEND675: TODO...
// }

GO FUNC image/gif.Decode from image/gif/reader.go:
// func __decode(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _gif.Decode(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/gif.DecodeAll from image/gif/reader.go:
// func __decodeAll(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _gif.DecodeAll(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/gif.DecodeConfig from image/gif/reader.go:
// func __decodeConfig(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _gif.DecodeConfig(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/gif.Encode from image/gif/writer.go:
// func __encode(w ABEND987(genutils.go: imports not yet supported: io.Writer), m ABEND987(genutils.go: imports not yet supported: image.Image), o *_gif.Options)  {
// 	_res := _gif.Encode(w, m, o)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC image/gif.EncodeAll from image/gif/writer.go:
// func __encodeAll(w ABEND987(genutils.go: imports not yet supported: io.Writer), g *_gif.GIF)  {
// 	_res := _gif.EncodeAll(w, g)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC image/jpeg.Decode from image/jpeg/reader.go:
// func __decode(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _jpeg.Decode(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/jpeg.DecodeConfig from image/jpeg/reader.go:
// func __decodeConfig(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _jpeg.DecodeConfig(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/jpeg.Encode from image/jpeg/writer.go:
// func __encode(w ABEND987(genutils.go: imports not yet supported: io.Writer), m ABEND987(genutils.go: imports not yet supported: image.Image), o *_jpeg.Options)  {
// 	_res := _jpeg.Encode(w, m, o)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC image/png.Decode from image/png/reader.go:
// func __decode(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _png.Decode(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/png.DecodeConfig from image/png/reader.go:
// func __decodeConfig(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _png.DecodeConfig(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/png.Encode from image/png/writer.go:
// func __encode(w ABEND987(genutils.go: imports not yet supported: io.Writer), m ABEND987(genutils.go: imports not yet supported: image.Image))  {
// 	_res := _png.Encode(w, m)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC index/suffixarray.New from index/suffixarray/suffixarray.go:
// func __new(data []byte) Object {
// 	_res := _suffixarray.New(data)
// 	return MakeGoObject(_res)
// }

GO TYPE io.ByteReader from io/io.go:
func ExtractGoObjectByteReader(args []Object, index int) *_io.ByteReader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.ByteReader:
			return &r
		case *_io.ByteReader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.ByteReader]"))
}

// func _ConstructByteReader(_v Object) _io.ByteReader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.ByteReader:
// 			return _g
// 		case *_io.ByteReader:
// 			return *_g
// 		}
// 	default:
// 		return _io.ByteReader(_o.ABEND674(unknown underlying type *ast.InterfaceType for ByteReader))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.ByteReader] or whatever"))
// }

GO TYPE io.ByteScanner from io/io.go:
func ExtractGoObjectByteScanner(args []Object, index int) *_io.ByteScanner {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.ByteScanner:
			return &r
		case *_io.ByteScanner:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.ByteScanner]"))
}

// func _ConstructByteScanner(_v Object) _io.ByteScanner {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.ByteScanner:
// 			return _g
// 		case *_io.ByteScanner:
// 			return *_g
// 		}
// 	default:
// 		return _io.ByteScanner(_o.ABEND674(unknown underlying type *ast.InterfaceType for ByteScanner))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.ByteScanner] or whatever"))
// }

GO TYPE io.ByteWriter from io/io.go:
func ExtractGoObjectByteWriter(args []Object, index int) *_io.ByteWriter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.ByteWriter:
			return &r
		case *_io.ByteWriter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.ByteWriter]"))
}

// func _ConstructByteWriter(_v Object) _io.ByteWriter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.ByteWriter:
// 			return _g
// 		case *_io.ByteWriter:
// 			return *_g
// 		}
// 	default:
// 		return _io.ByteWriter(_o.ABEND674(unknown underlying type *ast.InterfaceType for ByteWriter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.ByteWriter] or whatever"))
// }

GO TYPE io.Closer from io/io.go:
func ExtractGoObjectCloser(args []Object, index int) *_io.Closer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.Closer:
			return &r
		case *_io.Closer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.Closer]"))
}

// func _ConstructCloser(_v Object) _io.Closer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.Closer:
// 			return _g
// 		case *_io.Closer:
// 			return *_g
// 		}
// 	default:
// 		return _io.Closer(_o.ABEND674(unknown underlying type *ast.InterfaceType for Closer))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.Closer] or whatever"))
// }

GO TYPE io.LimitedReader from io/io.go:
func ExtractGoObjectLimitedReader(args []Object, index int) *_io.LimitedReader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.LimitedReader:
			return &r
		case *_io.LimitedReader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.LimitedReader]"))
}

func _mapToLimitedReader(o Map) *_io.LimitedReader {
	return &_io.LimitedReader{
	}
}

func _vectorToLimitedReader(o *Vector) *_io.LimitedReader {
	return &_io.LimitedReader{
	}
}

func _ConstructLimitedReader(_v Object) *_io.LimitedReader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _io.LimitedReader:
			return &_g
		case *_io.LimitedReader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToLimitedReader(_o.(Map))
	case case *Vector:
		return _vectorToLimitedReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[io.LimitedReader] or Map"))
}

GO TYPE io.PipeReader from io/pipe.go:
func ExtractGoObjectPipeReader(args []Object, index int) *_io.PipeReader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.PipeReader:
			return &r
		case *_io.PipeReader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.PipeReader]"))
}

func _mapToPipeReader(o Map) *_io.PipeReader {
	return &_io.PipeReader{
	}
}

func _vectorToPipeReader(o *Vector) *_io.PipeReader {
	return &_io.PipeReader{
	}
}

func _ConstructPipeReader(_v Object) *_io.PipeReader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _io.PipeReader:
			return &_g
		case *_io.PipeReader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPipeReader(_o.(Map))
	case case *Vector:
		return _vectorToPipeReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[io.PipeReader] or Map"))
}

GO TYPE io.PipeWriter from io/pipe.go:
func ExtractGoObjectPipeWriter(args []Object, index int) *_io.PipeWriter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.PipeWriter:
			return &r
		case *_io.PipeWriter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.PipeWriter]"))
}

func _mapToPipeWriter(o Map) *_io.PipeWriter {
	return &_io.PipeWriter{
	}
}

func _vectorToPipeWriter(o *Vector) *_io.PipeWriter {
	return &_io.PipeWriter{
	}
}

func _ConstructPipeWriter(_v Object) *_io.PipeWriter {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _io.PipeWriter:
			return &_g
		case *_io.PipeWriter:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPipeWriter(_o.(Map))
	case case *Vector:
		return _vectorToPipeWriter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[io.PipeWriter] or Map"))
}

GO TYPE io.ReadCloser from io/io.go:
func ExtractGoObjectReadCloser(args []Object, index int) *_io.ReadCloser {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.ReadCloser:
			return &r
		case *_io.ReadCloser:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.ReadCloser]"))
}

// func _ConstructReadCloser(_v Object) _io.ReadCloser {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.ReadCloser:
// 			return _g
// 		case *_io.ReadCloser:
// 			return *_g
// 		}
// 	default:
// 		return _io.ReadCloser(_o.ABEND674(unknown underlying type *ast.InterfaceType for ReadCloser))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.ReadCloser] or whatever"))
// }

GO TYPE io.ReadSeeker from io/io.go:
func ExtractGoObjectReadSeeker(args []Object, index int) *_io.ReadSeeker {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.ReadSeeker:
			return &r
		case *_io.ReadSeeker:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.ReadSeeker]"))
}

// func _ConstructReadSeeker(_v Object) _io.ReadSeeker {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.ReadSeeker:
// 			return _g
// 		case *_io.ReadSeeker:
// 			return *_g
// 		}
// 	default:
// 		return _io.ReadSeeker(_o.ABEND674(unknown underlying type *ast.InterfaceType for ReadSeeker))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.ReadSeeker] or whatever"))
// }

GO TYPE io.ReadWriteCloser from io/io.go:
func ExtractGoObjectReadWriteCloser(args []Object, index int) *_io.ReadWriteCloser {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.ReadWriteCloser:
			return &r
		case *_io.ReadWriteCloser:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.ReadWriteCloser]"))
}

// func _ConstructReadWriteCloser(_v Object) _io.ReadWriteCloser {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.ReadWriteCloser:
// 			return _g
// 		case *_io.ReadWriteCloser:
// 			return *_g
// 		}
// 	default:
// 		return _io.ReadWriteCloser(_o.ABEND674(unknown underlying type *ast.InterfaceType for ReadWriteCloser))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.ReadWriteCloser] or whatever"))
// }

GO TYPE io.ReadWriteSeeker from io/io.go:
func ExtractGoObjectReadWriteSeeker(args []Object, index int) *_io.ReadWriteSeeker {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.ReadWriteSeeker:
			return &r
		case *_io.ReadWriteSeeker:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.ReadWriteSeeker]"))
}

// func _ConstructReadWriteSeeker(_v Object) _io.ReadWriteSeeker {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.ReadWriteSeeker:
// 			return _g
// 		case *_io.ReadWriteSeeker:
// 			return *_g
// 		}
// 	default:
// 		return _io.ReadWriteSeeker(_o.ABEND674(unknown underlying type *ast.InterfaceType for ReadWriteSeeker))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.ReadWriteSeeker] or whatever"))
// }

GO TYPE io.ReadWriter from io/io.go:
func ExtractGoObjectReadWriter(args []Object, index int) *_io.ReadWriter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.ReadWriter:
			return &r
		case *_io.ReadWriter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.ReadWriter]"))
}

// func _ConstructReadWriter(_v Object) _io.ReadWriter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.ReadWriter:
// 			return _g
// 		case *_io.ReadWriter:
// 			return *_g
// 		}
// 	default:
// 		return _io.ReadWriter(_o.ABEND674(unknown underlying type *ast.InterfaceType for ReadWriter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.ReadWriter] or whatever"))
// }

GO TYPE io.Reader from io/io.go:
func ExtractGoObjectReader(args []Object, index int) *_io.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.Reader:
			return &r
		case *_io.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.Reader]"))
}

// func _ConstructReader(_v Object) _io.Reader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.Reader:
// 			return _g
// 		case *_io.Reader:
// 			return *_g
// 		}
// 	default:
// 		return _io.Reader(_o.ABEND674(unknown underlying type *ast.InterfaceType for Reader))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.Reader] or whatever"))
// }

GO TYPE io.ReaderAt from io/io.go:
func ExtractGoObjectReaderAt(args []Object, index int) *_io.ReaderAt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.ReaderAt:
			return &r
		case *_io.ReaderAt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.ReaderAt]"))
}

// func _ConstructReaderAt(_v Object) _io.ReaderAt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.ReaderAt:
// 			return _g
// 		case *_io.ReaderAt:
// 			return *_g
// 		}
// 	default:
// 		return _io.ReaderAt(_o.ABEND674(unknown underlying type *ast.InterfaceType for ReaderAt))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.ReaderAt] or whatever"))
// }

GO TYPE io.ReaderFrom from io/io.go:
func ExtractGoObjectReaderFrom(args []Object, index int) *_io.ReaderFrom {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.ReaderFrom:
			return &r
		case *_io.ReaderFrom:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.ReaderFrom]"))
}

// func _ConstructReaderFrom(_v Object) _io.ReaderFrom {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.ReaderFrom:
// 			return _g
// 		case *_io.ReaderFrom:
// 			return *_g
// 		}
// 	default:
// 		return _io.ReaderFrom(_o.ABEND674(unknown underlying type *ast.InterfaceType for ReaderFrom))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.ReaderFrom] or whatever"))
// }

GO TYPE io.RuneReader from io/io.go:
func ExtractGoObjectRuneReader(args []Object, index int) *_io.RuneReader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.RuneReader:
			return &r
		case *_io.RuneReader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.RuneReader]"))
}

// func _ConstructRuneReader(_v Object) _io.RuneReader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.RuneReader:
// 			return _g
// 		case *_io.RuneReader:
// 			return *_g
// 		}
// 	default:
// 		return _io.RuneReader(_o.ABEND674(unknown underlying type *ast.InterfaceType for RuneReader))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.RuneReader] or whatever"))
// }

GO TYPE io.RuneScanner from io/io.go:
func ExtractGoObjectRuneScanner(args []Object, index int) *_io.RuneScanner {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.RuneScanner:
			return &r
		case *_io.RuneScanner:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.RuneScanner]"))
}

// func _ConstructRuneScanner(_v Object) _io.RuneScanner {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.RuneScanner:
// 			return _g
// 		case *_io.RuneScanner:
// 			return *_g
// 		}
// 	default:
// 		return _io.RuneScanner(_o.ABEND674(unknown underlying type *ast.InterfaceType for RuneScanner))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.RuneScanner] or whatever"))
// }

GO TYPE io.SectionReader from io/io.go:
func ExtractGoObjectSectionReader(args []Object, index int) *_io.SectionReader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.SectionReader:
			return &r
		case *_io.SectionReader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.SectionReader]"))
}

func _mapToSectionReader(o Map) *_io.SectionReader {
	return &_io.SectionReader{
	}
}

func _vectorToSectionReader(o *Vector) *_io.SectionReader {
	return &_io.SectionReader{
	}
}

func _ConstructSectionReader(_v Object) *_io.SectionReader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _io.SectionReader:
			return &_g
		case *_io.SectionReader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSectionReader(_o.(Map))
	case case *Vector:
		return _vectorToSectionReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[io.SectionReader] or Map"))
}

GO TYPE io.Seeker from io/io.go:
func ExtractGoObjectSeeker(args []Object, index int) *_io.Seeker {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.Seeker:
			return &r
		case *_io.Seeker:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.Seeker]"))
}

// func _ConstructSeeker(_v Object) _io.Seeker {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.Seeker:
// 			return _g
// 		case *_io.Seeker:
// 			return *_g
// 		}
// 	default:
// 		return _io.Seeker(_o.ABEND674(unknown underlying type *ast.InterfaceType for Seeker))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.Seeker] or whatever"))
// }

GO TYPE io.WriteCloser from io/io.go:
func ExtractGoObjectWriteCloser(args []Object, index int) *_io.WriteCloser {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.WriteCloser:
			return &r
		case *_io.WriteCloser:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.WriteCloser]"))
}

// func _ConstructWriteCloser(_v Object) _io.WriteCloser {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.WriteCloser:
// 			return _g
// 		case *_io.WriteCloser:
// 			return *_g
// 		}
// 	default:
// 		return _io.WriteCloser(_o.ABEND674(unknown underlying type *ast.InterfaceType for WriteCloser))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.WriteCloser] or whatever"))
// }

GO TYPE io.WriteSeeker from io/io.go:
func ExtractGoObjectWriteSeeker(args []Object, index int) *_io.WriteSeeker {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.WriteSeeker:
			return &r
		case *_io.WriteSeeker:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.WriteSeeker]"))
}

// func _ConstructWriteSeeker(_v Object) _io.WriteSeeker {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.WriteSeeker:
// 			return _g
// 		case *_io.WriteSeeker:
// 			return *_g
// 		}
// 	default:
// 		return _io.WriteSeeker(_o.ABEND674(unknown underlying type *ast.InterfaceType for WriteSeeker))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.WriteSeeker] or whatever"))
// }

GO TYPE io.Writer from io/io.go:
func ExtractGoObjectWriter(args []Object, index int) *_io.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.Writer:
			return &r
		case *_io.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.Writer]"))
}

// func _ConstructWriter(_v Object) _io.Writer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.Writer:
// 			return _g
// 		case *_io.Writer:
// 			return *_g
// 		}
// 	default:
// 		return _io.Writer(_o.ABEND674(unknown underlying type *ast.InterfaceType for Writer))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.Writer] or whatever"))
// }

GO TYPE io.WriterAt from io/io.go:
func ExtractGoObjectWriterAt(args []Object, index int) *_io.WriterAt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.WriterAt:
			return &r
		case *_io.WriterAt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.WriterAt]"))
}

// func _ConstructWriterAt(_v Object) _io.WriterAt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.WriterAt:
// 			return _g
// 		case *_io.WriterAt:
// 			return *_g
// 		}
// 	default:
// 		return _io.WriterAt(_o.ABEND674(unknown underlying type *ast.InterfaceType for WriterAt))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.WriterAt] or whatever"))
// }

GO TYPE io.WriterTo from io/io.go:
func ExtractGoObjectWriterTo(args []Object, index int) *_io.WriterTo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.WriterTo:
			return &r
		case *_io.WriterTo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.WriterTo]"))
}

// func _ConstructWriterTo(_v Object) _io.WriterTo {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.WriterTo:
// 			return _g
// 		case *_io.WriterTo:
// 			return *_g
// 		}
// 	default:
// 		return _io.WriterTo(_o.ABEND674(unknown underlying type *ast.InterfaceType for WriterTo))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.WriterTo] or whatever"))
// }

GO FUNC io.Copy from io/io.go:
func __copy(dst _io.Writer, src _io.Reader) Object {
	written, err := _io.Copy(dst, src)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(int(written)))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC io.CopyBuffer from io/io.go:
// func __copyBuffer(dst _io.Writer, src _io.Reader, buf []byte) Object {
// 	written, err := _io.CopyBuffer(dst, src, buf)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(int(written)))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC io.CopyN from io/io.go:
func __copyN(dst _io.Writer, src _io.Reader, n int64) Object {
	written, err := _io.CopyN(dst, src, n)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(int(written)))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC io.LimitReader from io/io.go:
func __limitReader(r _io.Reader, n int64) Object {
	_res := _io.LimitReader(r, n)
	return MakeGoObject(_res)
}

GO FUNC io.MultiReader from io/multi.go:
// func __multiReader(readers ..._io.Reader) Object {
// 	_res := _io.MultiReader(readers)
// 	return MakeGoObject(_res)
// }

GO FUNC io.MultiWriter from io/multi.go:
// func __multiWriter(writers ..._io.Writer) Object {
// 	_res := _io.MultiWriter(writers)
// 	return MakeGoObject(_res)
// }

GO FUNC io.NewSectionReader from io/io.go:
func __newSectionReader(r _io.ReaderAt, off int64, n int64) Object {
	_res := _io.NewSectionReader(r, off, n)
	return MakeGoObject(_res)
}

GO FUNC io.Pipe from io/pipe.go:
func __pipe() Object {
	_res1, _res2 := _io.Pipe()
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	return _res
}

GO FUNC io.ReadAtLeast from io/io.go:
// func __readAtLeast(r _io.Reader, buf []byte, min int) Object {
// 	n, err := _io.ReadAtLeast(r, buf, min)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC io.ReadFull from io/io.go:
// func __readFull(r _io.Reader, buf []byte) Object {
// 	n, err := _io.ReadFull(r, buf)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC io.TeeReader from io/io.go:
func __teeReader(r _io.Reader, w _io.Writer) Object {
	_res := _io.TeeReader(r, w)
	return MakeGoObject(_res)
}

GO FUNC io.WriteString from io/io.go:
func __writeString(w _io.Writer, s string) Object {
	n, err := _io.WriteString(w, s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package io

import (
	_io "io"
	. "github.com/candid82/joker/core"
)
GO FUNC io/ioutil.NopCloser from io/ioutil/ioutil.go:
// func __nopCloser(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _ioutil.NopCloser(r)
// 	return MakeGoObject(_res)
// }

GO FUNC io/ioutil.ReadAll from io/ioutil/ioutil.go:
// func __readAll(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _ioutil.ReadAll(r)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC io/ioutil.ReadDir from io/ioutil/ioutil.go:
func __readDir(dirname string) Object {
	_res1, _res2 := _ioutil.ReadDir(dirname)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC io/ioutil.ReadFile from io/ioutil/ioutil.go:
func __readFile(filename string) Object {
	_res1, _res2 := _ioutil.ReadFile(filename)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC io/ioutil.TempDir from io/ioutil/tempfile.go:
func __tempDir(dir string, prefix string) Object {
	name, err := _ioutil.TempDir(dir, prefix)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(name))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC io/ioutil.TempFile from io/ioutil/tempfile.go:
func __tempFile(dir string, pattern string) Object {
	f, err := _ioutil.TempFile(dir, pattern)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(f))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC io/ioutil.WriteFile from io/ioutil/ioutil.go:
// func __writeFile(filename string, data []byte, perm ABEND987(genutils.go: imports not yet supported: os.FileMode))  {
// 	_res := _ioutil.WriteFile(filename, data, perm)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package ioutil

import (
	_ioutil "io/ioutil"
	. "github.com/candid82/joker/core"
)
GO TYPE log.Logger from log/log.go:
func ExtractGoObjectLogger(args []Object, index int) *_log.Logger {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _log.Logger:
			return &r
		case *_log.Logger:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[log.Logger]"))
}

func _mapToLogger(o Map) *_log.Logger {
	return &_log.Logger{
	}
}

func _vectorToLogger(o *Vector) *_log.Logger {
	return &_log.Logger{
	}
}

func _ConstructLogger(_v Object) *_log.Logger {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _log.Logger:
			return &_g
		case *_log.Logger:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToLogger(_o.(Map))
	case case *Vector:
		return _vectorToLogger(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[log.Logger] or Map"))
}

GO FUNC log.Fatal from log/log.go:
// func __fatal(v ...interface {}) Object {
// 	_log.Fatal(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Fatalf from log/log.go:
// func __fatalf(format string, v ...interface {}) Object {
// 	_log.Fatalf(format, v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Fatalln from log/log.go:
// func __fatalln(v ...interface {}) Object {
// 	_log.Fatalln(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.New from log/log.go:
// func __new(out ABEND987(genutils.go: imports not yet supported: io.Writer), prefix string, flag int) Object {
// 	_res := _log.New(out, prefix, flag)
// 	return MakeGoObject(_res)
// }

GO FUNC log.Panic from log/log.go:
// func __panic(v ...interface {}) Object {
// 	_log.Panic(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Panicf from log/log.go:
// func __panicf(format string, v ...interface {}) Object {
// 	_log.Panicf(format, v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Panicln from log/log.go:
// func __panicln(v ...interface {}) Object {
// 	_log.Panicln(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Print from log/log.go:
// func __print(v ...interface {}) Object {
// 	_log.Print(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Printf from log/log.go:
// func __printf(format string, v ...interface {}) Object {
// 	_log.Printf(format, v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Println from log/log.go:
// func __println(v ...interface {}) Object {
// 	_log.Println(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.SetFlags from log/log.go:
// func __setFlags(flag int) Object {
// 	_log.SetFlags(flag)
// 	...ABEND675: TODO...
// }

GO FUNC log.SetOutput from log/log.go:
// func __setOutput(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_log.SetOutput(w)
// 	...ABEND675: TODO...
// }

GO FUNC log.SetPrefix from log/log.go:
// func __setPrefix(prefix string) Object {
// 	_log.SetPrefix(prefix)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package log

import (
	_log "log"
	. "github.com/candid82/joker/core"
)
GO TYPE log/syslog.Priority from log/syslog/syslog.go:
func ExtractGoObjectPriority(args []Object, index int) *_syslog.Priority {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syslog.Priority:
			return &r
		case *_syslog.Priority:
			return r
		}
	case Int:
		v := _syslog.Priority(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[log/syslog.Priority]"))
}

func _ConstructPriority(_v Object) _syslog.Priority {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syslog.Priority:
			return _g
		case *_syslog.Priority:
			return *_g
		}
	case Number:
		return _syslog.Priority(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syslog.Priority] or Number"))
}

GO TYPE log/syslog.Writer from log/syslog/syslog.go:
func ExtractGoObjectWriter(args []Object, index int) *_syslog.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syslog.Writer:
			return &r
		case *_syslog.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[log/syslog.Writer]"))
}

func _mapToWriter(o Map) *_syslog.Writer {
	return &_syslog.Writer{
	}
}

func _vectorToWriter(o *Vector) *_syslog.Writer {
	return &_syslog.Writer{
	}
}

func _ConstructWriter(_v Object) *_syslog.Writer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syslog.Writer:
			return &_g
		case *_syslog.Writer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWriter(_o.(Map))
	case case *Vector:
		return _vectorToWriter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syslog.Writer] or Map"))
}

GO FUNC log/syslog.Dial from log/syslog/syslog.go:
func __dial(network string, raddr string, priority _syslog.Priority, tag string) Object {
	_res1, _res2 := _syslog.Dial(network, raddr, priority, tag)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC log/syslog.New from log/syslog/syslog.go:
func __new(priority _syslog.Priority, tag string) Object {
	_res1, _res2 := _syslog.New(priority, tag)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC log/syslog.NewLogger from log/syslog/syslog.go:
func __newLogger(p _syslog.Priority, logFlag int) Object {
	_res1, _res2 := _syslog.NewLogger(p, logFlag)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package syslog

import (
	_syslog "log/syslog"
	. "github.com/candid82/joker/core"
)
GO FUNC math.Abs from math/abs.go:
// func __abs(x float64) Object {
// 	return _math.Abs(x)
// }

GO FUNC math.Acos from math/asin.go:
// func __acos(x float64) Object {
// 	return _math.Acos(x)
// }

GO FUNC math.Acosh from math/acosh.go:
// func __acosh(x float64) Object {
// 	return _math.Acosh(x)
// }

GO FUNC math.Asin from math/asin.go:
// func __asin(x float64) Object {
// 	return _math.Asin(x)
// }

GO FUNC math.Asinh from math/asinh.go:
// func __asinh(x float64) Object {
// 	return _math.Asinh(x)
// }

GO FUNC math.Atan from math/atan.go:
// func __atan(x float64) Object {
// 	return _math.Atan(x)
// }

GO FUNC math.Atan2 from math/atan2.go:
// func __atan2(y float64, x float64) Object {
// 	return _math.Atan2(y, x)
// }

GO FUNC math.Atanh from math/atanh.go:
// func __atanh(x float64) Object {
// 	return _math.Atanh(x)
// }

GO FUNC math.Cbrt from math/cbrt.go:
// func __cbrt(x float64) Object {
// 	return _math.Cbrt(x)
// }

GO FUNC math.Ceil from math/floor.go:
// func __ceil(x float64) Object {
// 	return _math.Ceil(x)
// }

GO FUNC math.Copysign from math/copysign.go:
// func __copysign(x float64, y float64) Object {
// 	return _math.Copysign(x, y)
// }

GO FUNC math.Cos from math/sin.go:
// func __cos(x float64) Object {
// 	return _math.Cos(x)
// }

GO FUNC math.Cosh from math/sinh.go:
// func __cosh(x float64) Object {
// 	return _math.Cosh(x)
// }

GO FUNC math.Dim from math/dim.go:
// func __dim(x float64, y float64) Object {
// 	return _math.Dim(x, y)
// }

GO FUNC math.Erf from math/erf.go:
// func __erf(x float64) Object {
// 	return _math.Erf(x)
// }

GO FUNC math.Erfc from math/erf.go:
// func __erfc(x float64) Object {
// 	return _math.Erfc(x)
// }

GO FUNC math.Erfcinv from math/erfinv.go:
// func __erfcinv(x float64) Object {
// 	return _math.Erfcinv(x)
// }

GO FUNC math.Erfinv from math/erfinv.go:
// func __erfinv(x float64) Object {
// 	return _math.Erfinv(x)
// }

GO FUNC math.Exp from math/exp.go:
// func __exp(x float64) Object {
// 	return _math.Exp(x)
// }

GO FUNC math.Exp2 from math/exp.go:
// func __exp2(x float64) Object {
// 	return _math.Exp2(x)
// }

GO FUNC math.Expm1 from math/expm1.go:
// func __expm1(x float64) Object {
// 	return _math.Expm1(x)
// }

GO FUNC math.Float32bits from math/unsafe.go:
// func __float32bits(f float32) Object {
// 	_res := _math.Float32bits(f)
// 	return MakeInt(int(_res))
// }

GO FUNC math.Float32frombits from math/unsafe.go:
// func __float32frombits(b uint32) Object {
// 	return _math.Float32frombits(b)
// }

GO FUNC math.Float64bits from math/unsafe.go:
// func __float64bits(f float64) Object {
// 	_res := _math.Float64bits(f)
// 	return MakeBigInt(uint64(_res))
// }

GO FUNC math.Float64frombits from math/unsafe.go:
// func __float64frombits(b uint64) Object {
// 	return _math.Float64frombits(b)
// }

GO FUNC math.Floor from math/floor.go:
// func __floor(x float64) Object {
// 	return _math.Floor(x)
// }

GO FUNC math.Frexp from math/frexp.go:
// func __frexp(f float64) Object {
// 	frac, exp := _math.Frexp(f)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(frac)
// 	_res = _res.Conjoin(MakeInt(exp))
// 	return _res
// }

GO FUNC math.Gamma from math/gamma.go:
// func __gamma(x float64) Object {
// 	return _math.Gamma(x)
// }

GO FUNC math.Hypot from math/hypot.go:
// func __hypot(p float64, q float64) Object {
// 	return _math.Hypot(p, q)
// }

GO FUNC math.Ilogb from math/logb.go:
// func __ilogb(x float64)  {
// 	_res := _math.Ilogb(x)
// 	return MakeInt(_res)
// }

GO FUNC math.Inf from math/bits.go:
// func __inf(sign int) Object {
// 	return _math.Inf(sign)
// }

GO FUNC math.IsInf from math/bits.go:
// func __isInf(f float64, sign int)  {
// 	_res := _math.IsInf(f, sign)
// 	return MakeBoolean(_res)
// }

GO FUNC math.IsNaN from math/bits.go:
// func __isNaN(f float64)  {
// 	_res := _math.IsNaN(f)
// 	return MakeBoolean(_res)
// }

GO FUNC math.J0 from math/j0.go:
// func __j0(x float64) Object {
// 	return _math.J0(x)
// }

GO FUNC math.J1 from math/j1.go:
// func __j1(x float64) Object {
// 	return _math.J1(x)
// }

GO FUNC math.Jn from math/jn.go:
// func __jn(n int, x float64) Object {
// 	return _math.Jn(n, x)
// }

GO FUNC math.Ldexp from math/ldexp.go:
// func __ldexp(frac float64, exp int) Object {
// 	return _math.Ldexp(frac, exp)
// }

GO FUNC math.Lgamma from math/lgamma.go:
// func __lgamma(x float64) Object {
// 	lgamma, sign := _math.Lgamma(x)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(lgamma)
// 	_res = _res.Conjoin(MakeInt(sign))
// 	return _res
// }

GO FUNC math.Log from math/log.go:
// func __log(x float64) Object {
// 	return _math.Log(x)
// }

GO FUNC math.Log10 from math/log10.go:
// func __log10(x float64) Object {
// 	return _math.Log10(x)
// }

GO FUNC math.Log1p from math/log1p.go:
// func __log1p(x float64) Object {
// 	return _math.Log1p(x)
// }

GO FUNC math.Log2 from math/log10.go:
// func __log2(x float64) Object {
// 	return _math.Log2(x)
// }

GO FUNC math.Logb from math/logb.go:
// func __logb(x float64) Object {
// 	return _math.Logb(x)
// }

GO FUNC math.Max from math/dim.go:
// func __max(x float64, y float64) Object {
// 	return _math.Max(x, y)
// }

GO FUNC math.Min from math/dim.go:
// func __min(x float64, y float64) Object {
// 	return _math.Min(x, y)
// }

GO FUNC math.Mod from math/mod.go:
// func __mod(x float64, y float64) Object {
// 	return _math.Mod(x, y)
// }

GO FUNC math.Modf from math/modf.go:
// func __modf(f float64) Object {
// 	int, frac := _math.Modf(f)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(int)
// 	_res = _res.Conjoin(frac)
// 	return _res
// }

GO FUNC math.NaN from math/bits.go:
// func __naN() Object {
// 	return _math.NaN()
// }

GO FUNC math.Nextafter from math/nextafter.go:
// func __nextafter(x float64, y float64) Object {
// 	return _math.Nextafter(x, y)
// }

GO FUNC math.Nextafter32 from math/nextafter.go:
// func __nextafter32(x float32, y float32) Object {
// 	return _math.Nextafter32(x, y)
// }

GO FUNC math.Pow from math/pow.go:
// func __pow(x float64, y float64) Object {
// 	return _math.Pow(x, y)
// }

GO FUNC math.Pow10 from math/pow10.go:
// func __pow10(n int) Object {
// 	return _math.Pow10(n)
// }

GO FUNC math.Remainder from math/remainder.go:
// func __remainder(x float64, y float64) Object {
// 	return _math.Remainder(x, y)
// }

GO FUNC math.Round from math/floor.go:
// func __round(x float64) Object {
// 	return _math.Round(x)
// }

GO FUNC math.RoundToEven from math/floor.go:
// func __roundToEven(x float64) Object {
// 	return _math.RoundToEven(x)
// }

GO FUNC math.Signbit from math/signbit.go:
// func __signbit(x float64)  {
// 	_res := _math.Signbit(x)
// 	return MakeBoolean(_res)
// }

GO FUNC math.Sin from math/sin.go:
// func __sin(x float64) Object {
// 	return _math.Sin(x)
// }

GO FUNC math.Sincos from math/sincos.go:
// func __sincos(x float64) Object {
// 	sin, cos := _math.Sincos(x)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(sin)
// 	_res = _res.Conjoin(cos)
// 	return _res
// }

GO FUNC math.Sinh from math/sinh.go:
// func __sinh(x float64) Object {
// 	return _math.Sinh(x)
// }

GO FUNC math.Sqrt from math/sqrt.go:
// func __sqrt(x float64) Object {
// 	return _math.Sqrt(x)
// }

GO FUNC math.Tan from math/tan.go:
// func __tan(x float64) Object {
// 	return _math.Tan(x)
// }

GO FUNC math.Tanh from math/tanh.go:
// func __tanh(x float64) Object {
// 	return _math.Tanh(x)
// }

GO FUNC math.Trunc from math/floor.go:
// func __trunc(x float64) Object {
// 	return _math.Trunc(x)
// }

GO FUNC math.Y0 from math/j0.go:
// func __y0(x float64) Object {
// 	return _math.Y0(x)
// }

GO FUNC math.Y1 from math/j1.go:
// func __y1(x float64) Object {
// 	return _math.Y1(x)
// }

GO FUNC math.Yn from math/jn.go:
// func __yn(n int, x float64) Object {
// 	return _math.Yn(n, x)
// }

GO TYPE math/big.Accuracy from math/big/float.go:
func ExtractGoObjectAccuracy(args []Object, index int) *_big.Accuracy {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _big.Accuracy:
			return &r
		case *_big.Accuracy:
			return r
		}
	case Int:
		v := _big.Accuracy(ExtractByte(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/big.Accuracy]"))
}

func _ConstructAccuracy(_v Object) _big.Accuracy {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _big.Accuracy:
			return _g
		case *_big.Accuracy:
			return *_g
		}
	case Number:
		return _big.Accuracy(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[big.Accuracy] or Number"))
}

GO TYPE math/big.ErrNaN from math/big/float.go:
func ExtractGoObjectErrNaN(args []Object, index int) *_big.ErrNaN {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _big.ErrNaN:
			return &r
		case *_big.ErrNaN:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/big.ErrNaN]"))
}

func _mapToErrNaN(o Map) *_big.ErrNaN {
	return &_big.ErrNaN{
	}
}

func _vectorToErrNaN(o *Vector) *_big.ErrNaN {
	return &_big.ErrNaN{
	}
}

func _ConstructErrNaN(_v Object) *_big.ErrNaN {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _big.ErrNaN:
			return &_g
		case *_big.ErrNaN:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToErrNaN(_o.(Map))
	case case *Vector:
		return _vectorToErrNaN(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[big.ErrNaN] or Map"))
}

GO TYPE math/big.Float from math/big/float.go:
func ExtractGoObjectFloat(args []Object, index int) *_big.Float {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _big.Float:
			return &r
		case *_big.Float:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/big.Float]"))
}

func _mapToFloat(o Map) *_big.Float {
	return &_big.Float{
	}
}

func _vectorToFloat(o *Vector) *_big.Float {
	return &_big.Float{
	}
}

func _ConstructFloat(_v Object) *_big.Float {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _big.Float:
			return &_g
		case *_big.Float:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFloat(_o.(Map))
	case case *Vector:
		return _vectorToFloat(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[big.Float] or Map"))
}

GO TYPE math/big.Int from math/big/int.go:
func ExtractGoObjectInt(args []Object, index int) *_big.Int {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _big.Int:
			return &r
		case *_big.Int:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/big.Int]"))
}

func _mapToInt(o Map) *_big.Int {
	return &_big.Int{
	}
}

func _vectorToInt(o *Vector) *_big.Int {
	return &_big.Int{
	}
}

func _ConstructInt(_v Object) *_big.Int {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _big.Int:
			return &_g
		case *_big.Int:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToInt(_o.(Map))
	case case *Vector:
		return _vectorToInt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[big.Int] or Map"))
}

GO TYPE math/big.Rat from math/big/rat.go:
func ExtractGoObjectRat(args []Object, index int) *_big.Rat {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _big.Rat:
			return &r
		case *_big.Rat:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/big.Rat]"))
}

func _mapToRat(o Map) *_big.Rat {
	return &_big.Rat{
	}
}

func _vectorToRat(o *Vector) *_big.Rat {
	return &_big.Rat{
	}
}

func _ConstructRat(_v Object) *_big.Rat {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _big.Rat:
			return &_g
		case *_big.Rat:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRat(_o.(Map))
	case case *Vector:
		return _vectorToRat(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[big.Rat] or Map"))
}

GO TYPE math/big.RoundingMode from math/big/float.go:
func ExtractGoObjectRoundingMode(args []Object, index int) *_big.RoundingMode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _big.RoundingMode:
			return &r
		case *_big.RoundingMode:
			return r
		}
	case Int:
		v := _big.RoundingMode(ExtractByte(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/big.RoundingMode]"))
}

func _ConstructRoundingMode(_v Object) _big.RoundingMode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _big.RoundingMode:
			return _g
		case *_big.RoundingMode:
			return *_g
		}
	case Number:
		return _big.RoundingMode(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[big.RoundingMode] or Number"))
}

GO TYPE math/big.Word from math/big/arith.go:
func ExtractGoObjectWord(args []Object, index int) *_big.Word {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _big.Word:
			return &r
		case *_big.Word:
			return r
		}
	case Number:
		v := _big.Word(ExtractUInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/big.Word]"))
}

func _ConstructWord(_v Object) _big.Word {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _big.Word:
			return _g
		case *_big.Word:
			return *_g
		}
	case Number:
		return _big.Word(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[big.Word] or Number"))
}

GO FUNC math/big.NewFloat from math/big/float.go:
// func __newFloat(x float64) Object {
// 	_res := _big.NewFloat(x)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.NewInt from math/big/int.go:
func __newInt(x int64) Object {
	_res := _big.NewInt(x)
	return MakeGoObject(_res)
}

GO FUNC math/big.NewRat from math/big/rat.go:
func __newRat(a int64, b int64) Object {
	_res := _big.NewRat(a, b)
	return MakeGoObject(_res)
}

GO FUNC math/big.ParseFloat from math/big/floatconv.go:
func __parseFloat(s string, base int, prec uint, mode _big.RoundingMode) Object {
	f, b, err := _big.ParseFloat(s, base, prec, mode)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(f))
	_res = _res.Conjoin(MakeInt(b))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package big

import (
	_big "math/big"
	. "github.com/candid82/joker/core"
)
GO FUNC math/bits.LeadingZeros64 from math/bits/bits.go:
// func __leadingZeros64(x uint64)  {
// 	_res := _bits.LeadingZeros64(x)
// 	return MakeInt(_res)
// }

GO FUNC math/bits.LeadingZeros8 from math/bits/bits.go:
// func __leadingZeros8(x uint8)  {
// 	_res := _bits.LeadingZeros8(x)
// 	return MakeInt(_res)
// }

GO FUNC math/bits.Len64 from math/bits/bits.go:
// func __len64(x uint64)  {
// 	_res := _bits.Len64(x)
// 	return MakeInt(_res)
// }

GO FUNC math/bits.Len8 from math/bits/bits.go:
// func __len8(x uint8)  {
// 	_res := _bits.Len8(x)
// 	return MakeInt(_res)
// }

GO FUNC math/bits.OnesCount64 from math/bits/bits.go:
// func __onesCount64(x uint64)  {
// 	_res := _bits.OnesCount64(x)
// 	return MakeInt(_res)
// }

GO FUNC math/bits.OnesCount8 from math/bits/bits.go:
// func __onesCount8(x uint8)  {
// 	_res := _bits.OnesCount8(x)
// 	return MakeInt(_res)
// }

GO FUNC math/bits.Reverse from math/bits/bits.go:
func __reverse(x uint) Object {
	_res := _bits.Reverse(x)
	return MakeInt(int(_res))
}

GO FUNC math/bits.Reverse16 from math/bits/bits.go:
func __reverse16(x uint16) Object {
	_res := _bits.Reverse16(x)
	return MakeInt(int(_res))
}

GO FUNC math/bits.Reverse32 from math/bits/bits.go:
func __reverse32(x uint32) Object {
	_res := _bits.Reverse32(x)
	return MakeInt(int(_res))
}

GO FUNC math/bits.Reverse64 from math/bits/bits.go:
// func __reverse64(x uint64) Object {
// 	_res := _bits.Reverse64(x)
// 	return MakeBigInt(uint64(_res))
// }

GO FUNC math/bits.Reverse8 from math/bits/bits.go:
// func __reverse8(x uint8) Object {
// 	return _bits.Reverse8(x)
// }

GO FUNC math/bits.ReverseBytes from math/bits/bits.go:
func __reverseBytes(x uint) Object {
	_res := _bits.ReverseBytes(x)
	return MakeInt(int(_res))
}

GO FUNC math/bits.ReverseBytes16 from math/bits/bits.go:
func __reverseBytes16(x uint16) Object {
	_res := _bits.ReverseBytes16(x)
	return MakeInt(int(_res))
}

GO FUNC math/bits.ReverseBytes32 from math/bits/bits.go:
func __reverseBytes32(x uint32) Object {
	_res := _bits.ReverseBytes32(x)
	return MakeInt(int(_res))
}

GO FUNC math/bits.ReverseBytes64 from math/bits/bits.go:
// func __reverseBytes64(x uint64) Object {
// 	_res := _bits.ReverseBytes64(x)
// 	return MakeBigInt(uint64(_res))
// }

GO FUNC math/bits.RotateLeft from math/bits/bits.go:
func __rotateLeft(x uint, k int) Object {
	_res := _bits.RotateLeft(x, k)
	return MakeInt(int(_res))
}

GO FUNC math/bits.RotateLeft16 from math/bits/bits.go:
func __rotateLeft16(x uint16, k int) Object {
	_res := _bits.RotateLeft16(x, k)
	return MakeInt(int(_res))
}

GO FUNC math/bits.RotateLeft32 from math/bits/bits.go:
func __rotateLeft32(x uint32, k int) Object {
	_res := _bits.RotateLeft32(x, k)
	return MakeInt(int(_res))
}

GO FUNC math/bits.RotateLeft64 from math/bits/bits.go:
// func __rotateLeft64(x uint64, k int) Object {
// 	_res := _bits.RotateLeft64(x, k)
// 	return MakeBigInt(uint64(_res))
// }

GO FUNC math/bits.RotateLeft8 from math/bits/bits.go:
// func __rotateLeft8(x uint8, k int) Object {
// 	return _bits.RotateLeft8(x, k)
// }

GO FUNC math/bits.TrailingZeros64 from math/bits/bits.go:
// func __trailingZeros64(x uint64)  {
// 	_res := _bits.TrailingZeros64(x)
// 	return MakeInt(_res)
// }

GO FUNC math/bits.TrailingZeros8 from math/bits/bits.go:
// func __trailingZeros8(x uint8)  {
// 	_res := _bits.TrailingZeros8(x)
// 	return MakeInt(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package bits

import (
	_bits "math/bits"
	. "github.com/candid82/joker/core"
)
GO FUNC math/cmplx.Abs from math/cmplx/abs.go:
// func __abs(x complex128) Object {
// 	return _cmplx.Abs(x)
// }

GO FUNC math/cmplx.Acos from math/cmplx/asin.go:
// func __acos(x complex128) Object {
// 	return _cmplx.Acos(x)
// }

GO FUNC math/cmplx.Acosh from math/cmplx/asin.go:
// func __acosh(x complex128) Object {
// 	return _cmplx.Acosh(x)
// }

GO FUNC math/cmplx.Asin from math/cmplx/asin.go:
// func __asin(x complex128) Object {
// 	return _cmplx.Asin(x)
// }

GO FUNC math/cmplx.Asinh from math/cmplx/asin.go:
// func __asinh(x complex128) Object {
// 	return _cmplx.Asinh(x)
// }

GO FUNC math/cmplx.Atan from math/cmplx/asin.go:
// func __atan(x complex128) Object {
// 	return _cmplx.Atan(x)
// }

GO FUNC math/cmplx.Atanh from math/cmplx/asin.go:
// func __atanh(x complex128) Object {
// 	return _cmplx.Atanh(x)
// }

GO FUNC math/cmplx.Conj from math/cmplx/conj.go:
// func __conj(x complex128) Object {
// 	return _cmplx.Conj(x)
// }

GO FUNC math/cmplx.Cos from math/cmplx/sin.go:
// func __cos(x complex128) Object {
// 	return _cmplx.Cos(x)
// }

GO FUNC math/cmplx.Cosh from math/cmplx/sin.go:
// func __cosh(x complex128) Object {
// 	return _cmplx.Cosh(x)
// }

GO FUNC math/cmplx.Cot from math/cmplx/tan.go:
// func __cot(x complex128) Object {
// 	return _cmplx.Cot(x)
// }

GO FUNC math/cmplx.Exp from math/cmplx/exp.go:
// func __exp(x complex128) Object {
// 	return _cmplx.Exp(x)
// }

GO FUNC math/cmplx.Inf from math/cmplx/isinf.go:
// func __inf() Object {
// 	return _cmplx.Inf()
// }

GO FUNC math/cmplx.IsInf from math/cmplx/isinf.go:
// func __isInf(x complex128)  {
// 	_res := _cmplx.IsInf(x)
// 	return MakeBoolean(_res)
// }

GO FUNC math/cmplx.IsNaN from math/cmplx/isnan.go:
// func __isNaN(x complex128)  {
// 	_res := _cmplx.IsNaN(x)
// 	return MakeBoolean(_res)
// }

GO FUNC math/cmplx.Log from math/cmplx/log.go:
// func __log(x complex128) Object {
// 	return _cmplx.Log(x)
// }

GO FUNC math/cmplx.Log10 from math/cmplx/log.go:
// func __log10(x complex128) Object {
// 	return _cmplx.Log10(x)
// }

GO FUNC math/cmplx.NaN from math/cmplx/isnan.go:
// func __naN() Object {
// 	return _cmplx.NaN()
// }

GO FUNC math/cmplx.Phase from math/cmplx/phase.go:
// func __phase(x complex128) Object {
// 	return _cmplx.Phase(x)
// }

GO FUNC math/cmplx.Polar from math/cmplx/polar.go:
// func __polar(x complex128) Object {
// 	r, θ := _cmplx.Polar(x)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r)
// 	_res = _res.Conjoin(θ)
// 	return _res
// }

GO FUNC math/cmplx.Pow from math/cmplx/pow.go:
// func __pow(x complex128, y complex128) Object {
// 	return _cmplx.Pow(x, y)
// }

GO FUNC math/cmplx.Rect from math/cmplx/rect.go:
// func __rect(r float64, θ float64) Object {
// 	return _cmplx.Rect(r, θ)
// }

GO FUNC math/cmplx.Sin from math/cmplx/sin.go:
// func __sin(x complex128) Object {
// 	return _cmplx.Sin(x)
// }

GO FUNC math/cmplx.Sinh from math/cmplx/sin.go:
// func __sinh(x complex128) Object {
// 	return _cmplx.Sinh(x)
// }

GO FUNC math/cmplx.Sqrt from math/cmplx/sqrt.go:
// func __sqrt(x complex128) Object {
// 	return _cmplx.Sqrt(x)
// }

GO FUNC math/cmplx.Tan from math/cmplx/tan.go:
// func __tan(x complex128) Object {
// 	return _cmplx.Tan(x)
// }

GO FUNC math/cmplx.Tanh from math/cmplx/tan.go:
// func __tanh(x complex128) Object {
// 	return _cmplx.Tanh(x)
// }

GO TYPE math/rand.Rand from math/rand/rand.go:
func ExtractGoObjectRand(args []Object, index int) *_rand.Rand {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rand.Rand:
			return &r
		case *_rand.Rand:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/rand.Rand]"))
}

func _mapToRand(o Map) *_rand.Rand {
	return &_rand.Rand{
	}
}

func _vectorToRand(o *Vector) *_rand.Rand {
	return &_rand.Rand{
	}
}

func _ConstructRand(_v Object) *_rand.Rand {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rand.Rand:
			return &_g
		case *_rand.Rand:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRand(_o.(Map))
	case case *Vector:
		return _vectorToRand(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rand.Rand] or Map"))
}

GO TYPE math/rand.Source from math/rand/rand.go:
func ExtractGoObjectSource(args []Object, index int) *_rand.Source {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rand.Source:
			return &r
		case *_rand.Source:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/rand.Source]"))
}

// func _ConstructSource(_v Object) _rand.Source {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rand.Source:
// 			return _g
// 		case *_rand.Source:
// 			return *_g
// 		}
// 	default:
// 		return _rand.Source(_o.ABEND674(unknown underlying type *ast.InterfaceType for Source))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rand.Source] or whatever"))
// }

GO TYPE math/rand.Source64 from math/rand/rand.go:
func ExtractGoObjectSource64(args []Object, index int) *_rand.Source64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rand.Source64:
			return &r
		case *_rand.Source64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/rand.Source64]"))
}

// func _ConstructSource64(_v Object) _rand.Source64 {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rand.Source64:
// 			return _g
// 		case *_rand.Source64:
// 			return *_g
// 		}
// 	default:
// 		return _rand.Source64(_o.ABEND674(unknown underlying type *ast.InterfaceType for Source64))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rand.Source64] or whatever"))
// }

GO TYPE math/rand.Zipf from math/rand/zipf.go:
func ExtractGoObjectZipf(args []Object, index int) *_rand.Zipf {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rand.Zipf:
			return &r
		case *_rand.Zipf:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/rand.Zipf]"))
}

func _mapToZipf(o Map) *_rand.Zipf {
	return &_rand.Zipf{
	}
}

func _vectorToZipf(o *Vector) *_rand.Zipf {
	return &_rand.Zipf{
	}
}

func _ConstructZipf(_v Object) *_rand.Zipf {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rand.Zipf:
			return &_g
		case *_rand.Zipf:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToZipf(_o.(Map))
	case case *Vector:
		return _vectorToZipf(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rand.Zipf] or Map"))
}

GO FUNC math/rand.ExpFloat64 from math/rand/rand.go:
// func __expFloat64() Object {
// 	return _rand.ExpFloat64()
// }

GO FUNC math/rand.Float32 from math/rand/rand.go:
// func __float32() Object {
// 	return _rand.Float32()
// }

GO FUNC math/rand.Float64 from math/rand/rand.go:
// func __float64() Object {
// 	return _rand.Float64()
// }

GO FUNC math/rand.Int31 from math/rand/rand.go:
func __int31() Object {
	_res := _rand.Int31()
	return MakeInt(int(_res))
}

GO FUNC math/rand.Int31n from math/rand/rand.go:
func __int31n(n int32) Object {
	_res := _rand.Int31n(n)
	return MakeInt(int(_res))
}

GO FUNC math/rand.Int63 from math/rand/rand.go:
func __int63() Object {
	_res := _rand.Int63()
	return MakeInt(int(_res))
}

GO FUNC math/rand.Int63n from math/rand/rand.go:
func __int63n(n int64) Object {
	_res := _rand.Int63n(n)
	return MakeInt(int(_res))
}

GO FUNC math/rand.New from math/rand/rand.go:
func __new(src _rand.Source) Object {
	_res := _rand.New(src)
	return MakeGoObject(_res)
}

GO FUNC math/rand.NewSource from math/rand/rand.go:
func __newSource(seed int64) Object {
	_res := _rand.NewSource(seed)
	return MakeGoObject(_res)
}

GO FUNC math/rand.NewZipf from math/rand/zipf.go:
// func __newZipf(r *_rand.Rand, s float64, v float64, imax uint64) Object {
// 	_res := _rand.NewZipf(r, s, v, imax)
// 	return MakeGoObject(_res)
// }

GO FUNC math/rand.NormFloat64 from math/rand/rand.go:
// func __normFloat64() Object {
// 	return _rand.NormFloat64()
// }

GO FUNC math/rand.Perm from math/rand/rand.go:
func __perm(n int) Object {
	_res := _rand.Perm(n)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	return _vec1
}

GO FUNC math/rand.Read from math/rand/rand.go:
// func __read(p []byte) Object {
// 	n, err := _rand.Read(p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC math/rand.Seed from math/rand/rand.go:
// func __seed(seed int64) Object {
// 	_rand.Seed(seed)
// 	...ABEND675: TODO...
// }

GO FUNC math/rand.Shuffle from math/rand/rand.go:
// func __shuffle(n int, swap func) Object {
// 	_rand.Shuffle(n, swap)
// 	...ABEND675: TODO...
// }

GO FUNC math/rand.Uint32 from math/rand/rand.go:
func __uint32() Object {
	_res := _rand.Uint32()
	return MakeInt(int(_res))
}

GO FUNC math/rand.Uint64 from math/rand/rand.go:
func __uint64() Object {
	_res := _rand.Uint64()
	return MakeBigInt(uint64(_res))
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package rand

import (
	_rand "math/rand"
	. "github.com/candid82/joker/core"
)
GO TYPE mime.WordDecoder from mime/encodedword.go:
func ExtractGoObjectWordDecoder(args []Object, index int) *_mime.WordDecoder {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mime.WordDecoder:
			return &r
		case *_mime.WordDecoder:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[mime.WordDecoder]"))
}

func _mapToWordDecoder(o Map) *_mime.WordDecoder {
	return &_mime.WordDecoder{
	}
}

func _vectorToWordDecoder(o *Vector) *_mime.WordDecoder {
	return &_mime.WordDecoder{
	}
}

func _ConstructWordDecoder(_v Object) *_mime.WordDecoder {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _mime.WordDecoder:
			return &_g
		case *_mime.WordDecoder:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWordDecoder(_o.(Map))
	case case *Vector:
		return _vectorToWordDecoder(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[mime.WordDecoder] or Map"))
}

GO TYPE mime.WordEncoder from mime/encodedword.go:
func ExtractGoObjectWordEncoder(args []Object, index int) *_mime.WordEncoder {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mime.WordEncoder:
			return &r
		case *_mime.WordEncoder:
			return r
		}
	case Int:
		v := _mime.WordEncoder(ExtractByte(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[mime.WordEncoder]"))
}

func _ConstructWordEncoder(_v Object) _mime.WordEncoder {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _mime.WordEncoder:
			return _g
		case *_mime.WordEncoder:
			return *_g
		}
	case Number:
		return _mime.WordEncoder(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[mime.WordEncoder] or Number"))
}

GO FUNC mime.ExtensionsByType from mime/type.go:
func __extensionsByType(typ string) Object {
	_res1, _res2 := _mime.ExtensionsByType(typ)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC mime.FormatMediaType from mime/mediatype.go:
// func __formatMediaType(t string, param map[])  {
// 	_res := _mime.FormatMediaType(t, param)
// 	return MakeString(_res)
// }

GO FUNC mime.ParseMediaType from mime/mediatype.go:
// func __parseMediaType(v string) Object {
// 	mediatype, params, err := _mime.ParseMediaType(v)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeString(mediatype))
// 	_res = _res.Conjoin(params)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package mime

import (
	_mime "mime"
	. "github.com/candid82/joker/core"
)
GO FUNC mime/multipart.NewReader from mime/multipart/multipart.go:
// func __newReader(r ABEND987(genutils.go: imports not yet supported: io.Reader), boundary string) Object {
// 	_res := _multipart.NewReader(r, boundary)
// 	return MakeGoObject(_res)
// }

GO FUNC mime/multipart.NewWriter from mime/multipart/writer.go:
// func __newWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _multipart.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC mime/quotedprintable.NewReader from mime/quotedprintable/reader.go:
// func __newReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _quotedprintable.NewReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC mime/quotedprintable.NewWriter from mime/quotedprintable/writer.go:
// func __newWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _quotedprintable.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO TYPE net.Addr from net/net.go:
func ExtractGoObjectAddr(args []Object, index int) *_net.Addr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Addr:
			return &r
		case *_net.Addr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Addr]"))
}

// func _ConstructAddr(_v Object) _net.Addr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Addr:
// 			return _g
// 		case *_net.Addr:
// 			return *_g
// 		}
// 	default:
// 		return _net.Addr(_o.ABEND674(unknown underlying type *ast.InterfaceType for Addr))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Addr] or whatever"))
// }

GO TYPE net.AddrError from net/net.go:
func ExtractGoObjectAddrError(args []Object, index int) *_net.AddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.AddrError:
			return &r
		case *_net.AddrError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.AddrError]"))
}

func _mapToAddrError(o Map) *_net.AddrError {
	return &_net.AddrError{
	}
}

func _vectorToAddrError(o *Vector) *_net.AddrError {
	return &_net.AddrError{
	}
}

func _ConstructAddrError(_v Object) *_net.AddrError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.AddrError:
			return &_g
		case *_net.AddrError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToAddrError(_o.(Map))
	case case *Vector:
		return _vectorToAddrError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.AddrError] or Map"))
}

GO TYPE net.Buffers from net/net.go:
func ExtractGoObjectBuffers(args []Object, index int) *_net.Buffers {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Buffers:
			return &r
		case *_net.Buffers:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Buffers]"))
}

// func _ConstructBuffers(_v Object) _net.Buffers {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Buffers:
// 			return _g
// 		case *_net.Buffers:
// 			return *_g
// 		}
// 	default:
// 		return _net.Buffers(_o.ABEND674(unknown underlying type *ast.ArrayType for Buffers))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Buffers] or whatever"))
// }

GO TYPE net.Conn from net/net.go:
func ExtractGoObjectConn(args []Object, index int) *_net.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Conn:
			return &r
		case *_net.Conn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Conn]"))
}

// func _ConstructConn(_v Object) _net.Conn {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Conn:
// 			return _g
// 		case *_net.Conn:
// 			return *_g
// 		}
// 	default:
// 		return _net.Conn(_o.ABEND674(unknown underlying type *ast.InterfaceType for Conn))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Conn] or whatever"))
// }

GO TYPE net.DNSConfigError from net/net.go:
func ExtractGoObjectDNSConfigError(args []Object, index int) *_net.DNSConfigError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.DNSConfigError:
			return &r
		case *_net.DNSConfigError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.DNSConfigError]"))
}

func _mapToDNSConfigError(o Map) *_net.DNSConfigError {
	return &_net.DNSConfigError{
	}
}

func _vectorToDNSConfigError(o *Vector) *_net.DNSConfigError {
	return &_net.DNSConfigError{
	}
}

func _ConstructDNSConfigError(_v Object) *_net.DNSConfigError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.DNSConfigError:
			return &_g
		case *_net.DNSConfigError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDNSConfigError(_o.(Map))
	case case *Vector:
		return _vectorToDNSConfigError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.DNSConfigError] or Map"))
}

GO TYPE net.DNSError from net/net.go:
func ExtractGoObjectDNSError(args []Object, index int) *_net.DNSError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.DNSError:
			return &r
		case *_net.DNSError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.DNSError]"))
}

func _mapToDNSError(o Map) *_net.DNSError {
	return &_net.DNSError{
	}
}

func _vectorToDNSError(o *Vector) *_net.DNSError {
	return &_net.DNSError{
	}
}

func _ConstructDNSError(_v Object) *_net.DNSError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.DNSError:
			return &_g
		case *_net.DNSError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDNSError(_o.(Map))
	case case *Vector:
		return _vectorToDNSError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.DNSError] or Map"))
}

GO TYPE net.Dialer from net/dial.go:
func ExtractGoObjectDialer(args []Object, index int) *_net.Dialer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Dialer:
			return &r
		case *_net.Dialer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Dialer]"))
}

func _mapToDialer(o Map) *_net.Dialer {
	return &_net.Dialer{
	}
}

func _vectorToDialer(o *Vector) *_net.Dialer {
	return &_net.Dialer{
	}
}

func _ConstructDialer(_v Object) *_net.Dialer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.Dialer:
			return &_g
		case *_net.Dialer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDialer(_o.(Map))
	case case *Vector:
		return _vectorToDialer(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Dialer] or Map"))
}

GO TYPE net.Error from net/net.go:
func ExtractGoObjectError(args []Object, index int) *_net.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Error:
			return &r
		case *_net.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Error]"))
}

// func _ConstructError(_v Object) _net.Error {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Error:
// 			return _g
// 		case *_net.Error:
// 			return *_g
// 		}
// 	default:
// 		return _net.Error(_o.ABEND674(unknown underlying type *ast.InterfaceType for Error))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Error] or whatever"))
// }

GO TYPE net.Flags from net/interface.go:
func ExtractGoObjectFlags(args []Object, index int) *_net.Flags {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Flags:
			return &r
		case *_net.Flags:
			return r
		}
	case Number:
		v := _net.Flags(ExtractUInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Flags]"))
}

func _ConstructFlags(_v Object) _net.Flags {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.Flags:
			return _g
		case *_net.Flags:
			return *_g
		}
	case Number:
		return _net.Flags(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Flags] or Number"))
}

GO TYPE net.HardwareAddr from net/mac.go:
func ExtractGoObjectHardwareAddr(args []Object, index int) *_net.HardwareAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.HardwareAddr:
			return &r
		case *_net.HardwareAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.HardwareAddr]"))
}

// func _ConstructHardwareAddr(_v Object) _net.HardwareAddr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.HardwareAddr:
// 			return _g
// 		case *_net.HardwareAddr:
// 			return *_g
// 		}
// 	default:
// 		return _net.HardwareAddr(_o.ABEND674(unknown underlying type *ast.ArrayType for HardwareAddr))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.HardwareAddr] or whatever"))
// }

GO TYPE net.IP from net/ip.go:
func ExtractGoObjectIP(args []Object, index int) *_net.IP {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IP:
			return &r
		case *_net.IP:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IP]"))
}

// func _ConstructIP(_v Object) _net.IP {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.IP:
// 			return _g
// 		case *_net.IP:
// 			return *_g
// 		}
// 	default:
// 		return _net.IP(_o.ABEND674(unknown underlying type *ast.ArrayType for IP))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IP] or whatever"))
// }

GO TYPE net.IPAddr from net/iprawsock.go:
func ExtractGoObjectIPAddr(args []Object, index int) *_net.IPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPAddr:
			return &r
		case *_net.IPAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPAddr]"))
}

func _mapToIPAddr(o Map) *_net.IPAddr {
	return &_net.IPAddr{
	}
}

func _vectorToIPAddr(o *Vector) *_net.IPAddr {
	return &_net.IPAddr{
	}
}

func _ConstructIPAddr(_v Object) *_net.IPAddr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.IPAddr:
			return &_g
		case *_net.IPAddr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIPAddr(_o.(Map))
	case case *Vector:
		return _vectorToIPAddr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPAddr] or Map"))
}

GO TYPE net.IPConn from net/iprawsock.go:
func ExtractGoObjectIPConn(args []Object, index int) *_net.IPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPConn:
			return &r
		case *_net.IPConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPConn]"))
}

func _mapToIPConn(o Map) *_net.IPConn {
	return &_net.IPConn{
	}
}

func _vectorToIPConn(o *Vector) *_net.IPConn {
	return &_net.IPConn{
	}
}

func _ConstructIPConn(_v Object) *_net.IPConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.IPConn:
			return &_g
		case *_net.IPConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIPConn(_o.(Map))
	case case *Vector:
		return _vectorToIPConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPConn] or Map"))
}

GO TYPE net.IPMask from net/ip.go:
func ExtractGoObjectIPMask(args []Object, index int) *_net.IPMask {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPMask:
			return &r
		case *_net.IPMask:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPMask]"))
}

// func _ConstructIPMask(_v Object) _net.IPMask {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.IPMask:
// 			return _g
// 		case *_net.IPMask:
// 			return *_g
// 		}
// 	default:
// 		return _net.IPMask(_o.ABEND674(unknown underlying type *ast.ArrayType for IPMask))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPMask] or whatever"))
// }

GO TYPE net.IPNet from net/ip.go:
func ExtractGoObjectIPNet(args []Object, index int) *_net.IPNet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPNet:
			return &r
		case *_net.IPNet:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPNet]"))
}

func _mapToIPNet(o Map) *_net.IPNet {
	return &_net.IPNet{
	}
}

func _vectorToIPNet(o *Vector) *_net.IPNet {
	return &_net.IPNet{
	}
}

func _ConstructIPNet(_v Object) *_net.IPNet {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.IPNet:
			return &_g
		case *_net.IPNet:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIPNet(_o.(Map))
	case case *Vector:
		return _vectorToIPNet(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPNet] or Map"))
}

GO TYPE net.Interface from net/interface.go:
func ExtractGoObjectInterface(args []Object, index int) *_net.Interface {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Interface:
			return &r
		case *_net.Interface:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Interface]"))
}

func _mapToInterface(o Map) *_net.Interface {
	return &_net.Interface{
	}
}

func _vectorToInterface(o *Vector) *_net.Interface {
	return &_net.Interface{
	}
}

func _ConstructInterface(_v Object) *_net.Interface {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.Interface:
			return &_g
		case *_net.Interface:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToInterface(_o.(Map))
	case case *Vector:
		return _vectorToInterface(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Interface] or Map"))
}

GO TYPE net.InvalidAddrError from net/net.go:
func ExtractGoObjectInvalidAddrError(args []Object, index int) *_net.InvalidAddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.InvalidAddrError:
			return &r
		case *_net.InvalidAddrError:
			return r
		}
	case String:
		v := _net.InvalidAddrError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.InvalidAddrError]"))
}

func _ConstructInvalidAddrError(_v Object) _net.InvalidAddrError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.InvalidAddrError:
			return _g
		case *_net.InvalidAddrError:
			return *_g
		}
	case String:
		return _net.InvalidAddrError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.InvalidAddrError] or String"))
}

GO TYPE net.ListenConfig from net/dial.go:
func ExtractGoObjectListenConfig(args []Object, index int) *_net.ListenConfig {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.ListenConfig:
			return &r
		case *_net.ListenConfig:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.ListenConfig]"))
}

func _mapToListenConfig(o Map) *_net.ListenConfig {
	return &_net.ListenConfig{
	}
}

func _vectorToListenConfig(o *Vector) *_net.ListenConfig {
	return &_net.ListenConfig{
	}
}

func _ConstructListenConfig(_v Object) *_net.ListenConfig {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.ListenConfig:
			return &_g
		case *_net.ListenConfig:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToListenConfig(_o.(Map))
	case case *Vector:
		return _vectorToListenConfig(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.ListenConfig] or Map"))
}

GO TYPE net.Listener from net/net.go:
func ExtractGoObjectListener(args []Object, index int) *_net.Listener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Listener:
			return &r
		case *_net.Listener:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Listener]"))
}

// func _ConstructListener(_v Object) _net.Listener {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Listener:
// 			return _g
// 		case *_net.Listener:
// 			return *_g
// 		}
// 	default:
// 		return _net.Listener(_o.ABEND674(unknown underlying type *ast.InterfaceType for Listener))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Listener] or whatever"))
// }

GO TYPE net.MX from net/dnsclient.go:
func ExtractGoObjectMX(args []Object, index int) *_net.MX {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.MX:
			return &r
		case *_net.MX:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.MX]"))
}

func _mapToMX(o Map) *_net.MX {
	return &_net.MX{
	}
}

func _vectorToMX(o *Vector) *_net.MX {
	return &_net.MX{
	}
}

func _ConstructMX(_v Object) *_net.MX {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.MX:
			return &_g
		case *_net.MX:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMX(_o.(Map))
	case case *Vector:
		return _vectorToMX(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.MX] or Map"))
}

GO TYPE net.NS from net/dnsclient.go:
func ExtractGoObjectNS(args []Object, index int) *_net.NS {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.NS:
			return &r
		case *_net.NS:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.NS]"))
}

func _mapToNS(o Map) *_net.NS {
	return &_net.NS{
	}
}

func _vectorToNS(o *Vector) *_net.NS {
	return &_net.NS{
	}
}

func _ConstructNS(_v Object) *_net.NS {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.NS:
			return &_g
		case *_net.NS:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNS(_o.(Map))
	case case *Vector:
		return _vectorToNS(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.NS] or Map"))
}

GO TYPE net.OpError from net/net.go:
func ExtractGoObjectOpError(args []Object, index int) *_net.OpError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.OpError:
			return &r
		case *_net.OpError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.OpError]"))
}

func _mapToOpError(o Map) *_net.OpError {
	return &_net.OpError{
	}
}

func _vectorToOpError(o *Vector) *_net.OpError {
	return &_net.OpError{
	}
}

func _ConstructOpError(_v Object) *_net.OpError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.OpError:
			return &_g
		case *_net.OpError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToOpError(_o.(Map))
	case case *Vector:
		return _vectorToOpError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.OpError] or Map"))
}

GO TYPE net.PacketConn from net/net.go:
func ExtractGoObjectPacketConn(args []Object, index int) *_net.PacketConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.PacketConn:
			return &r
		case *_net.PacketConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.PacketConn]"))
}

// func _ConstructPacketConn(_v Object) _net.PacketConn {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.PacketConn:
// 			return _g
// 		case *_net.PacketConn:
// 			return *_g
// 		}
// 	default:
// 		return _net.PacketConn(_o.ABEND674(unknown underlying type *ast.InterfaceType for PacketConn))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.PacketConn] or whatever"))
// }

GO TYPE net.ParseError from net/net.go:
func ExtractGoObjectParseError(args []Object, index int) *_net.ParseError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.ParseError:
			return &r
		case *_net.ParseError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.ParseError]"))
}

func _mapToParseError(o Map) *_net.ParseError {
	return &_net.ParseError{
	}
}

func _vectorToParseError(o *Vector) *_net.ParseError {
	return &_net.ParseError{
	}
}

func _ConstructParseError(_v Object) *_net.ParseError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.ParseError:
			return &_g
		case *_net.ParseError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToParseError(_o.(Map))
	case case *Vector:
		return _vectorToParseError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.ParseError] or Map"))
}

GO TYPE net.Resolver from net/lookup.go:
func ExtractGoObjectResolver(args []Object, index int) *_net.Resolver {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Resolver:
			return &r
		case *_net.Resolver:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Resolver]"))
}

func _mapToResolver(o Map) *_net.Resolver {
	return &_net.Resolver{
	}
}

func _vectorToResolver(o *Vector) *_net.Resolver {
	return &_net.Resolver{
	}
}

func _ConstructResolver(_v Object) *_net.Resolver {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.Resolver:
			return &_g
		case *_net.Resolver:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToResolver(_o.(Map))
	case case *Vector:
		return _vectorToResolver(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Resolver] or Map"))
}

GO TYPE net.SRV from net/dnsclient.go:
func ExtractGoObjectSRV(args []Object, index int) *_net.SRV {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.SRV:
			return &r
		case *_net.SRV:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.SRV]"))
}

func _mapToSRV(o Map) *_net.SRV {
	return &_net.SRV{
	}
}

func _vectorToSRV(o *Vector) *_net.SRV {
	return &_net.SRV{
	}
}

func _ConstructSRV(_v Object) *_net.SRV {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.SRV:
			return &_g
		case *_net.SRV:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSRV(_o.(Map))
	case case *Vector:
		return _vectorToSRV(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.SRV] or Map"))
}

GO TYPE net.TCPAddr from net/tcpsock.go:
func ExtractGoObjectTCPAddr(args []Object, index int) *_net.TCPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.TCPAddr:
			return &r
		case *_net.TCPAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.TCPAddr]"))
}

func _mapToTCPAddr(o Map) *_net.TCPAddr {
	return &_net.TCPAddr{
	}
}

func _vectorToTCPAddr(o *Vector) *_net.TCPAddr {
	return &_net.TCPAddr{
	}
}

func _ConstructTCPAddr(_v Object) *_net.TCPAddr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.TCPAddr:
			return &_g
		case *_net.TCPAddr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTCPAddr(_o.(Map))
	case case *Vector:
		return _vectorToTCPAddr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.TCPAddr] or Map"))
}

GO TYPE net.TCPConn from net/tcpsock.go:
func ExtractGoObjectTCPConn(args []Object, index int) *_net.TCPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.TCPConn:
			return &r
		case *_net.TCPConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.TCPConn]"))
}

func _mapToTCPConn(o Map) *_net.TCPConn {
	return &_net.TCPConn{
	}
}

func _vectorToTCPConn(o *Vector) *_net.TCPConn {
	return &_net.TCPConn{
	}
}

func _ConstructTCPConn(_v Object) *_net.TCPConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.TCPConn:
			return &_g
		case *_net.TCPConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTCPConn(_o.(Map))
	case case *Vector:
		return _vectorToTCPConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.TCPConn] or Map"))
}

GO TYPE net.TCPListener from net/tcpsock.go:
func ExtractGoObjectTCPListener(args []Object, index int) *_net.TCPListener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.TCPListener:
			return &r
		case *_net.TCPListener:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.TCPListener]"))
}

func _mapToTCPListener(o Map) *_net.TCPListener {
	return &_net.TCPListener{
	}
}

func _vectorToTCPListener(o *Vector) *_net.TCPListener {
	return &_net.TCPListener{
	}
}

func _ConstructTCPListener(_v Object) *_net.TCPListener {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.TCPListener:
			return &_g
		case *_net.TCPListener:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTCPListener(_o.(Map))
	case case *Vector:
		return _vectorToTCPListener(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.TCPListener] or Map"))
}

GO TYPE net.UDPAddr from net/udpsock.go:
func ExtractGoObjectUDPAddr(args []Object, index int) *_net.UDPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UDPAddr:
			return &r
		case *_net.UDPAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UDPAddr]"))
}

func _mapToUDPAddr(o Map) *_net.UDPAddr {
	return &_net.UDPAddr{
	}
}

func _vectorToUDPAddr(o *Vector) *_net.UDPAddr {
	return &_net.UDPAddr{
	}
}

func _ConstructUDPAddr(_v Object) *_net.UDPAddr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UDPAddr:
			return &_g
		case *_net.UDPAddr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUDPAddr(_o.(Map))
	case case *Vector:
		return _vectorToUDPAddr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UDPAddr] or Map"))
}

GO TYPE net.UDPConn from net/udpsock.go:
func ExtractGoObjectUDPConn(args []Object, index int) *_net.UDPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UDPConn:
			return &r
		case *_net.UDPConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UDPConn]"))
}

func _mapToUDPConn(o Map) *_net.UDPConn {
	return &_net.UDPConn{
	}
}

func _vectorToUDPConn(o *Vector) *_net.UDPConn {
	return &_net.UDPConn{
	}
}

func _ConstructUDPConn(_v Object) *_net.UDPConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UDPConn:
			return &_g
		case *_net.UDPConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUDPConn(_o.(Map))
	case case *Vector:
		return _vectorToUDPConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UDPConn] or Map"))
}

GO TYPE net.UnixAddr from net/unixsock.go:
func ExtractGoObjectUnixAddr(args []Object, index int) *_net.UnixAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UnixAddr:
			return &r
		case *_net.UnixAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnixAddr]"))
}

func _mapToUnixAddr(o Map) *_net.UnixAddr {
	return &_net.UnixAddr{
	}
}

func _vectorToUnixAddr(o *Vector) *_net.UnixAddr {
	return &_net.UnixAddr{
	}
}

func _ConstructUnixAddr(_v Object) *_net.UnixAddr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UnixAddr:
			return &_g
		case *_net.UnixAddr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnixAddr(_o.(Map))
	case case *Vector:
		return _vectorToUnixAddr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnixAddr] or Map"))
}

GO TYPE net.UnixConn from net/unixsock.go:
func ExtractGoObjectUnixConn(args []Object, index int) *_net.UnixConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UnixConn:
			return &r
		case *_net.UnixConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnixConn]"))
}

func _mapToUnixConn(o Map) *_net.UnixConn {
	return &_net.UnixConn{
	}
}

func _vectorToUnixConn(o *Vector) *_net.UnixConn {
	return &_net.UnixConn{
	}
}

func _ConstructUnixConn(_v Object) *_net.UnixConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UnixConn:
			return &_g
		case *_net.UnixConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnixConn(_o.(Map))
	case case *Vector:
		return _vectorToUnixConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnixConn] or Map"))
}

GO TYPE net.UnixListener from net/unixsock.go:
func ExtractGoObjectUnixListener(args []Object, index int) *_net.UnixListener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UnixListener:
			return &r
		case *_net.UnixListener:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnixListener]"))
}

func _mapToUnixListener(o Map) *_net.UnixListener {
	return &_net.UnixListener{
	}
}

func _vectorToUnixListener(o *Vector) *_net.UnixListener {
	return &_net.UnixListener{
	}
}

func _ConstructUnixListener(_v Object) *_net.UnixListener {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UnixListener:
			return &_g
		case *_net.UnixListener:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnixListener(_o.(Map))
	case case *Vector:
		return _vectorToUnixListener(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnixListener] or Map"))
}

GO TYPE net.UnknownNetworkError from net/net.go:
func ExtractGoObjectUnknownNetworkError(args []Object, index int) *_net.UnknownNetworkError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UnknownNetworkError:
			return &r
		case *_net.UnknownNetworkError:
			return r
		}
	case String:
		v := _net.UnknownNetworkError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnknownNetworkError]"))
}

func _ConstructUnknownNetworkError(_v Object) _net.UnknownNetworkError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UnknownNetworkError:
			return _g
		case *_net.UnknownNetworkError:
			return *_g
		}
	case String:
		return _net.UnknownNetworkError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnknownNetworkError] or String"))
}

GO FUNC net.CIDRMask from net/ip.go:
func __cIDRMask(ones int, bits int) Object {
	_res := _net.CIDRMask(ones, bits)
	return MakeGoObject(_res)
}

GO FUNC net.Dial from net/dial.go:
func __dial(network string, address string) Object {
	_res1, _res2 := _net.Dial(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.DialIP from net/iprawsock.go:
func __dialIP(network string, laddr *_net.IPAddr, raddr *_net.IPAddr) Object {
	_res1, _res2 := _net.DialIP(network, laddr, raddr)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.DialTCP from net/tcpsock.go:
func __dialTCP(network string, laddr *_net.TCPAddr, raddr *_net.TCPAddr) Object {
	_res1, _res2 := _net.DialTCP(network, laddr, raddr)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.DialTimeout from net/dial.go:
// func __dialTimeout(network string, address string, timeout ABEND987(genutils.go: imports not yet supported: time.Duration)) Object {
// 	_res1, _res2 := _net.DialTimeout(network, address, timeout)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialUDP from net/udpsock.go:
func __dialUDP(network string, laddr *_net.UDPAddr, raddr *_net.UDPAddr) Object {
	_res1, _res2 := _net.DialUDP(network, laddr, raddr)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.DialUnix from net/unixsock.go:
func __dialUnix(network string, laddr *_net.UnixAddr, raddr *_net.UnixAddr) Object {
	_res1, _res2 := _net.DialUnix(network, laddr, raddr)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.FileConn from net/file.go:
// func __fileConn(f *ABEND987(genutils.go: imports not yet supported: os.File)) Object {
// 	c, err := _net.FileConn(f)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(c))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.FileListener from net/file.go:
// func __fileListener(f *ABEND987(genutils.go: imports not yet supported: os.File)) Object {
// 	ln, err := _net.FileListener(f)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(ln))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.FilePacketConn from net/file.go:
// func __filePacketConn(f *ABEND987(genutils.go: imports not yet supported: os.File)) Object {
// 	c, err := _net.FilePacketConn(f)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(c))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.IPv4 from net/ip.go:
func __iPv4(a byte, b byte, c byte, d byte) Object {
	_res := _net.IPv4(a, b, c, d)
	return MakeGoObject(_res)
}

GO FUNC net.IPv4Mask from net/ip.go:
func __iPv4Mask(a byte, b byte, c byte, d byte) Object {
	_res := _net.IPv4Mask(a, b, c, d)
	return MakeGoObject(_res)
}

GO FUNC net.InterfaceAddrs from net/interface.go:
func __interfaceAddrs() Object {
	_res1, _res2 := _net.InterfaceAddrs()
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.InterfaceByIndex from net/interface.go:
func __interfaceByIndex(index int) Object {
	_res1, _res2 := _net.InterfaceByIndex(index)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.InterfaceByName from net/interface.go:
func __interfaceByName(name string) Object {
	_res1, _res2 := _net.InterfaceByName(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.Interfaces from net/interface.go:
func __interfaces() Object {
	_res1, _res2 := _net.Interfaces()
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.Listen from net/dial.go:
func __listen(network string, address string) Object {
	_res1, _res2 := _net.Listen(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenIP from net/iprawsock.go:
func __listenIP(network string, laddr *_net.IPAddr) Object {
	_res1, _res2 := _net.ListenIP(network, laddr)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenMulticastUDP from net/udpsock.go:
func __listenMulticastUDP(network string, ifi *_net.Interface, gaddr *_net.UDPAddr) Object {
	_res1, _res2 := _net.ListenMulticastUDP(network, ifi, gaddr)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenPacket from net/dial.go:
func __listenPacket(network string, address string) Object {
	_res1, _res2 := _net.ListenPacket(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenTCP from net/tcpsock.go:
func __listenTCP(network string, laddr *_net.TCPAddr) Object {
	_res1, _res2 := _net.ListenTCP(network, laddr)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenUDP from net/udpsock.go:
func __listenUDP(network string, laddr *_net.UDPAddr) Object {
	_res1, _res2 := _net.ListenUDP(network, laddr)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenUnix from net/unixsock.go:
func __listenUnix(network string, laddr *_net.UnixAddr) Object {
	_res1, _res2 := _net.ListenUnix(network, laddr)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenUnixgram from net/unixsock.go:
func __listenUnixgram(network string, laddr *_net.UnixAddr) Object {
	_res1, _res2 := _net.ListenUnixgram(network, laddr)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupAddr from net/lookup.go:
func __lookupAddr(addr string) Object {
	names, err := _net.LookupAddr(addr)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range names {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupCNAME from net/lookup.go:
func __lookupCNAME(host string) Object {
	cname, err := _net.LookupCNAME(host)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(cname))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupHost from net/lookup.go:
func __lookupHost(host string) Object {
	addrs, err := _net.LookupHost(host)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range addrs {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupIP from net/lookup.go:
func __lookupIP(host string) Object {
	_res1, _res2 := _net.LookupIP(host)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupMX from net/lookup.go:
func __lookupMX(name string) Object {
	_res1, _res2 := _net.LookupMX(name)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupNS from net/lookup.go:
func __lookupNS(name string) Object {
	_res1, _res2 := _net.LookupNS(name)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupPort from net/lookup.go:
func __lookupPort(network string, service string) Object {
	port, err := _net.LookupPort(network, service)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(port))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupSRV from net/lookup.go:
func __lookupSRV(service string, proto string, name string) Object {
	cname, addrs, err := _net.LookupSRV(service, proto, name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(cname))
	_vec1 := EmptyVector
	for _, _elem1 := range addrs {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupTXT from net/lookup.go:
func __lookupTXT(name string) Object {
	_res1, _res2 := _net.LookupTXT(name)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ParseCIDR from net/ip.go:
func __parseCIDR(s string) Object {
	_res1, _res2, _res3 := _net.ParseCIDR(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
	return _res
}

GO FUNC net.ParseIP from net/ip.go:
func __parseIP(s string) Object {
	_res := _net.ParseIP(s)
	return MakeGoObject(_res)
}

GO FUNC net.ParseMAC from net/mac.go:
func __parseMAC(s string) Object {
	hw, err := _net.ParseMAC(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(hw))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.Pipe from net/pipe.go:
func __pipe() Object {
	_res1, _res2 := _net.Pipe()
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	return _res
}

GO FUNC net.ResolveIPAddr from net/iprawsock.go:
func __resolveIPAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveIPAddr(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveTCPAddr from net/tcpsock.go:
func __resolveTCPAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveTCPAddr(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveUDPAddr from net/udpsock.go:
func __resolveUDPAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveUDPAddr(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveUnixAddr from net/unixsock.go:
func __resolveUnixAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveUnixAddr(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.SplitHostPort from net/ipsock.go:
func __splitHostPort(hostport string) Object {
	host, port, err := _net.SplitHostPort(hostport)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(host))
	_res = _res.Conjoin(MakeString(port))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package net

import (
	_net "net"
	. "github.com/candid82/joker/core"
)
GO TYPE net/http.Client from net/http/client.go:
func ExtractGoObjectClient(args []Object, index int) *_http.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Client:
			return &r
		case *_http.Client:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Client]"))
}

func _mapToClient(o Map) *_http.Client {
	return &_http.Client{
	}
}

func _vectorToClient(o *Vector) *_http.Client {
	return &_http.Client{
	}
}

func _ConstructClient(_v Object) *_http.Client {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.Client:
			return &_g
		case *_http.Client:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToClient(_o.(Map))
	case case *Vector:
		return _vectorToClient(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Client] or Map"))
}

GO TYPE net/http.CloseNotifier from net/http/server.go:
func ExtractGoObjectCloseNotifier(args []Object, index int) *_http.CloseNotifier {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.CloseNotifier:
			return &r
		case *_http.CloseNotifier:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.CloseNotifier]"))
}

// func _ConstructCloseNotifier(_v Object) _http.CloseNotifier {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.CloseNotifier:
// 			return _g
// 		case *_http.CloseNotifier:
// 			return *_g
// 		}
// 	default:
// 		return _http.CloseNotifier(_o.ABEND674(unknown underlying type *ast.InterfaceType for CloseNotifier))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.CloseNotifier] or whatever"))
// }

GO TYPE net/http.ConnState from net/http/server.go:
func ExtractGoObjectConnState(args []Object, index int) *_http.ConnState {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.ConnState:
			return &r
		case *_http.ConnState:
			return r
		}
	case Int:
		v := _http.ConnState(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ConnState]"))
}

func _ConstructConnState(_v Object) _http.ConnState {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.ConnState:
			return _g
		case *_http.ConnState:
			return *_g
		}
	case Number:
		return _http.ConnState(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ConnState] or Number"))
}

GO TYPE net/http.Cookie from net/http/cookie.go:
func ExtractGoObjectCookie(args []Object, index int) *_http.Cookie {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Cookie:
			return &r
		case *_http.Cookie:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Cookie]"))
}

func _mapToCookie(o Map) *_http.Cookie {
	return &_http.Cookie{
	}
}

func _vectorToCookie(o *Vector) *_http.Cookie {
	return &_http.Cookie{
	}
}

func _ConstructCookie(_v Object) *_http.Cookie {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.Cookie:
			return &_g
		case *_http.Cookie:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCookie(_o.(Map))
	case case *Vector:
		return _vectorToCookie(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Cookie] or Map"))
}

GO TYPE net/http.CookieJar from net/http/jar.go:
func ExtractGoObjectCookieJar(args []Object, index int) *_http.CookieJar {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.CookieJar:
			return &r
		case *_http.CookieJar:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.CookieJar]"))
}

// func _ConstructCookieJar(_v Object) _http.CookieJar {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.CookieJar:
// 			return _g
// 		case *_http.CookieJar:
// 			return *_g
// 		}
// 	default:
// 		return _http.CookieJar(_o.ABEND674(unknown underlying type *ast.InterfaceType for CookieJar))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.CookieJar] or whatever"))
// }

GO TYPE net/http.Dir from net/http/fs.go:
func ExtractGoObjectDir(args []Object, index int) *_http.Dir {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Dir:
			return &r
		case *_http.Dir:
			return r
		}
	case String:
		v := _http.Dir(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Dir]"))
}

func _ConstructDir(_v Object) _http.Dir {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.Dir:
			return _g
		case *_http.Dir:
			return *_g
		}
	case String:
		return _http.Dir(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Dir] or String"))
}

GO TYPE net/http.File from net/http/fs.go:
func ExtractGoObjectFile(args []Object, index int) *_http.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.File:
			return &r
		case *_http.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.File]"))
}

// func _ConstructFile(_v Object) _http.File {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.File:
// 			return _g
// 		case *_http.File:
// 			return *_g
// 		}
// 	default:
// 		return _http.File(_o.ABEND674(unknown underlying type *ast.InterfaceType for File))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.File] or whatever"))
// }

GO TYPE net/http.FileSystem from net/http/fs.go:
func ExtractGoObjectFileSystem(args []Object, index int) *_http.FileSystem {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.FileSystem:
			return &r
		case *_http.FileSystem:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.FileSystem]"))
}

// func _ConstructFileSystem(_v Object) _http.FileSystem {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.FileSystem:
// 			return _g
// 		case *_http.FileSystem:
// 			return *_g
// 		}
// 	default:
// 		return _http.FileSystem(_o.ABEND674(unknown underlying type *ast.InterfaceType for FileSystem))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.FileSystem] or whatever"))
// }

GO TYPE net/http.Flusher from net/http/server.go:
func ExtractGoObjectFlusher(args []Object, index int) *_http.Flusher {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Flusher:
			return &r
		case *_http.Flusher:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Flusher]"))
}

// func _ConstructFlusher(_v Object) _http.Flusher {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Flusher:
// 			return _g
// 		case *_http.Flusher:
// 			return *_g
// 		}
// 	default:
// 		return _http.Flusher(_o.ABEND674(unknown underlying type *ast.InterfaceType for Flusher))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Flusher] or whatever"))
// }

GO TYPE net/http.Handler from net/http/server.go:
func ExtractGoObjectHandler(args []Object, index int) *_http.Handler {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Handler:
			return &r
		case *_http.Handler:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Handler]"))
}

// func _ConstructHandler(_v Object) _http.Handler {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Handler:
// 			return _g
// 		case *_http.Handler:
// 			return *_g
// 		}
// 	default:
// 		return _http.Handler(_o.ABEND674(unknown underlying type *ast.InterfaceType for Handler))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Handler] or whatever"))
// }

GO TYPE net/http.HandlerFunc from net/http/server.go:
func ExtractGoObjectHandlerFunc(args []Object, index int) *_http.HandlerFunc {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.HandlerFunc:
			return &r
		case *_http.HandlerFunc:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.HandlerFunc]"))
}

// func _ConstructHandlerFunc(_v Object) _http.HandlerFunc {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.HandlerFunc:
// 			return _g
// 		case *_http.HandlerFunc:
// 			return *_g
// 		}
// 	default:
// 		return _http.HandlerFunc(_o.ABEND674(unknown underlying type *ast.FuncType for HandlerFunc))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.HandlerFunc] or whatever"))
// }

GO TYPE net/http.Header from net/http/header.go:
func ExtractGoObjectHeader(args []Object, index int) *_http.Header {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Header:
			return &r
		case *_http.Header:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Header]"))
}

// func _ConstructHeader(_v Object) _http.Header {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Header:
// 			return _g
// 		case *_http.Header:
// 			return *_g
// 		}
// 	default:
// 		return _http.Header(_o.ABEND674(unknown underlying type *ast.MapType for Header))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Header] or whatever"))
// }

GO TYPE net/http.Hijacker from net/http/server.go:
func ExtractGoObjectHijacker(args []Object, index int) *_http.Hijacker {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Hijacker:
			return &r
		case *_http.Hijacker:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Hijacker]"))
}

// func _ConstructHijacker(_v Object) _http.Hijacker {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Hijacker:
// 			return _g
// 		case *_http.Hijacker:
// 			return *_g
// 		}
// 	default:
// 		return _http.Hijacker(_o.ABEND674(unknown underlying type *ast.InterfaceType for Hijacker))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Hijacker] or whatever"))
// }

GO TYPE net/http.ProtocolError from net/http/request.go:
func ExtractGoObjectProtocolError(args []Object, index int) *_http.ProtocolError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.ProtocolError:
			return &r
		case *_http.ProtocolError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ProtocolError]"))
}

func _mapToProtocolError(o Map) *_http.ProtocolError {
	return &_http.ProtocolError{
	}
}

func _vectorToProtocolError(o *Vector) *_http.ProtocolError {
	return &_http.ProtocolError{
	}
}

func _ConstructProtocolError(_v Object) *_http.ProtocolError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.ProtocolError:
			return &_g
		case *_http.ProtocolError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProtocolError(_o.(Map))
	case case *Vector:
		return _vectorToProtocolError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ProtocolError] or Map"))
}

GO TYPE net/http.PushOptions from net/http/http.go:
func ExtractGoObjectPushOptions(args []Object, index int) *_http.PushOptions {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.PushOptions:
			return &r
		case *_http.PushOptions:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.PushOptions]"))
}

func _mapToPushOptions(o Map) *_http.PushOptions {
	return &_http.PushOptions{
	}
}

func _vectorToPushOptions(o *Vector) *_http.PushOptions {
	return &_http.PushOptions{
	}
}

func _ConstructPushOptions(_v Object) *_http.PushOptions {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.PushOptions:
			return &_g
		case *_http.PushOptions:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPushOptions(_o.(Map))
	case case *Vector:
		return _vectorToPushOptions(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.PushOptions] or Map"))
}

GO TYPE net/http.Pusher from net/http/http.go:
func ExtractGoObjectPusher(args []Object, index int) *_http.Pusher {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Pusher:
			return &r
		case *_http.Pusher:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Pusher]"))
}

// func _ConstructPusher(_v Object) _http.Pusher {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Pusher:
// 			return _g
// 		case *_http.Pusher:
// 			return *_g
// 		}
// 	default:
// 		return _http.Pusher(_o.ABEND674(unknown underlying type *ast.InterfaceType for Pusher))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Pusher] or whatever"))
// }

GO TYPE net/http.Request from net/http/request.go:
func ExtractGoObjectRequest(args []Object, index int) *_http.Request {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Request:
			return &r
		case *_http.Request:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Request]"))
}

func _mapToRequest(o Map) *_http.Request {
	return &_http.Request{
	}
}

func _vectorToRequest(o *Vector) *_http.Request {
	return &_http.Request{
	}
}

func _ConstructRequest(_v Object) *_http.Request {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.Request:
			return &_g
		case *_http.Request:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRequest(_o.(Map))
	case case *Vector:
		return _vectorToRequest(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Request] or Map"))
}

GO TYPE net/http.Response from net/http/response.go:
func ExtractGoObjectResponse(args []Object, index int) *_http.Response {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Response:
			return &r
		case *_http.Response:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Response]"))
}

func _mapToResponse(o Map) *_http.Response {
	return &_http.Response{
	}
}

func _vectorToResponse(o *Vector) *_http.Response {
	return &_http.Response{
	}
}

func _ConstructResponse(_v Object) *_http.Response {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.Response:
			return &_g
		case *_http.Response:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToResponse(_o.(Map))
	case case *Vector:
		return _vectorToResponse(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Response] or Map"))
}

GO TYPE net/http.ResponseWriter from net/http/server.go:
func ExtractGoObjectResponseWriter(args []Object, index int) *_http.ResponseWriter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.ResponseWriter:
			return &r
		case *_http.ResponseWriter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ResponseWriter]"))
}

// func _ConstructResponseWriter(_v Object) _http.ResponseWriter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.ResponseWriter:
// 			return _g
// 		case *_http.ResponseWriter:
// 			return *_g
// 		}
// 	default:
// 		return _http.ResponseWriter(_o.ABEND674(unknown underlying type *ast.InterfaceType for ResponseWriter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ResponseWriter] or whatever"))
// }

GO TYPE net/http.RoundTripper from net/http/client.go:
func ExtractGoObjectRoundTripper(args []Object, index int) *_http.RoundTripper {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.RoundTripper:
			return &r
		case *_http.RoundTripper:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.RoundTripper]"))
}

// func _ConstructRoundTripper(_v Object) _http.RoundTripper {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.RoundTripper:
// 			return _g
// 		case *_http.RoundTripper:
// 			return *_g
// 		}
// 	default:
// 		return _http.RoundTripper(_o.ABEND674(unknown underlying type *ast.InterfaceType for RoundTripper))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.RoundTripper] or whatever"))
// }

GO TYPE net/http.SameSite from net/http/cookie.go:
func ExtractGoObjectSameSite(args []Object, index int) *_http.SameSite {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.SameSite:
			return &r
		case *_http.SameSite:
			return r
		}
	case Int:
		v := _http.SameSite(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.SameSite]"))
}

func _ConstructSameSite(_v Object) _http.SameSite {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.SameSite:
			return _g
		case *_http.SameSite:
			return *_g
		}
	case Number:
		return _http.SameSite(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.SameSite] or Number"))
}

GO TYPE net/http.ServeMux from net/http/server.go:
func ExtractGoObjectServeMux(args []Object, index int) *_http.ServeMux {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.ServeMux:
			return &r
		case *_http.ServeMux:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ServeMux]"))
}

func _mapToServeMux(o Map) *_http.ServeMux {
	return &_http.ServeMux{
	}
}

func _vectorToServeMux(o *Vector) *_http.ServeMux {
	return &_http.ServeMux{
	}
}

func _ConstructServeMux(_v Object) *_http.ServeMux {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.ServeMux:
			return &_g
		case *_http.ServeMux:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToServeMux(_o.(Map))
	case case *Vector:
		return _vectorToServeMux(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ServeMux] or Map"))
}

GO TYPE net/http.Server from net/http/server.go:
func ExtractGoObjectServer(args []Object, index int) *_http.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Server:
			return &r
		case *_http.Server:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Server]"))
}

func _mapToServer(o Map) *_http.Server {
	return &_http.Server{
	}
}

func _vectorToServer(o *Vector) *_http.Server {
	return &_http.Server{
	}
}

func _ConstructServer(_v Object) *_http.Server {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.Server:
			return &_g
		case *_http.Server:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToServer(_o.(Map))
	case case *Vector:
		return _vectorToServer(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Server] or Map"))
}

GO TYPE net/http.Transport from net/http/transport.go:
func ExtractGoObjectTransport(args []Object, index int) *_http.Transport {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Transport:
			return &r
		case *_http.Transport:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Transport]"))
}

func _mapToTransport(o Map) *_http.Transport {
	return &_http.Transport{
	}
}

func _vectorToTransport(o *Vector) *_http.Transport {
	return &_http.Transport{
	}
}

func _ConstructTransport(_v Object) *_http.Transport {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.Transport:
			return &_g
		case *_http.Transport:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTransport(_o.(Map))
	case case *Vector:
		return _vectorToTransport(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Transport] or Map"))
}

GO FUNC net/http.DetectContentType from net/http/sniff.go:
// func __detectContentType(data []byte)  {
// 	_res := _http.DetectContentType(data)
// 	return MakeString(_res)
// }

GO FUNC net/http.Error from net/http/server.go:
// func __error(w _http.ResponseWriter, error string, code int) Object {
// 	_http.Error(w, error, code)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.FileServer from net/http/fs.go:
func __fileServer(root _http.FileSystem) Object {
	_res := _http.FileServer(root)
	return MakeGoObject(_res)
}

GO FUNC net/http.Get from net/http/client.go:
func __get(url string) Object {
	resp, err := _http.Get(url)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.Handle from net/http/server.go:
// func __handle(pattern string, handler _http.Handler) Object {
// 	_http.Handle(pattern, handler)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.HandleFunc from net/http/server.go:
// func __handleFunc(pattern string, handler func) Object {
// 	_http.HandleFunc(pattern, handler)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.Head from net/http/client.go:
func __head(url string) Object {
	resp, err := _http.Head(url)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.MaxBytesReader from net/http/request.go:
// func __maxBytesReader(w _http.ResponseWriter, r ABEND987(genutils.go: imports not yet supported: io.ReadCloser), n int64) Object {
// 	_res := _http.MaxBytesReader(w, r, n)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http.NewFileTransport from net/http/filetransport.go:
func __newFileTransport(fs _http.FileSystem) Object {
	_res := _http.NewFileTransport(fs)
	return MakeGoObject(_res)
}

GO FUNC net/http.NewRequest from net/http/request.go:
// func __newRequest(method string, url string, body ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _http.NewRequest(method, url, body)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.NewServeMux from net/http/server.go:
func __newServeMux() Object {
	_res := _http.NewServeMux()
	return MakeGoObject(_res)
}

GO FUNC net/http.NotFound from net/http/server.go:
// func __notFound(w _http.ResponseWriter, r *_http.Request) Object {
// 	_http.NotFound(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.NotFoundHandler from net/http/server.go:
func __notFoundHandler() Object {
	_res := _http.NotFoundHandler()
	return MakeGoObject(_res)
}

GO FUNC net/http.ParseHTTPVersion from net/http/request.go:
func __parseHTTPVersion(vers string) Object {
	major, minor, ok := _http.ParseHTTPVersion(vers)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(major))
	_res = _res.Conjoin(MakeInt(minor))
	_res = _res.Conjoin(MakeBoolean(ok))
	return _res
}

GO FUNC net/http.ParseTime from net/http/header.go:
func __parseTime(text string) Object {
	t, err := _http.ParseTime(text)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(t))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.Post from net/http/client.go:
// func __post(url string, contentType string, body ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	resp, err := _http.Post(url, contentType, body)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(resp))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.PostForm from net/http/client.go:
// func __postForm(url string, data ABEND987(genutils.go: imports not yet supported: url.Values)) Object {
// 	resp, err := _http.PostForm(url, data)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(resp))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.ProxyFromEnvironment from net/http/transport.go:
func __proxyFromEnvironment(req *_http.Request) Object {
	_res1, _res2 := _http.ProxyFromEnvironment(req)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http.ProxyURL from net/http/transport.go:
// func __proxyURL(fixedURL *ABEND987(genutils.go: imports not yet supported: url.URL)) Object {
// 	return _http.ProxyURL(fixedURL)
// }

GO FUNC net/http.ReadRequest from net/http/request.go:
// func __readRequest(b *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res1, _res2 := _http.ReadRequest(b)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.ReadResponse from net/http/response.go:
// func __readResponse(r *ABEND987(genutils.go: imports not yet supported: bufio.Reader), req *_http.Request) Object {
// 	_res1, _res2 := _http.ReadResponse(r, req)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.Redirect from net/http/server.go:
// func __redirect(w _http.ResponseWriter, r *_http.Request, url string, code int) Object {
// 	_http.Redirect(w, r, url, code)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.RedirectHandler from net/http/server.go:
func __redirectHandler(url string, code int) Object {
	_res := _http.RedirectHandler(url, code)
	return MakeGoObject(_res)
}

GO FUNC net/http.Serve from net/http/server.go:
// func __serve(l ABEND987(genutils.go: imports not yet supported: net.Listener), handler _http.Handler)  {
// 	_res := _http.Serve(l, handler)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/http.ServeContent from net/http/fs.go:
// func __serveContent(w _http.ResponseWriter, req *_http.Request, name string, modtime ABEND987(genutils.go: imports not yet supported: time.Time), content ABEND987(genutils.go: imports not yet supported: io.ReadSeeker)) Object {
// 	_http.ServeContent(w, req, name, modtime, content)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.ServeFile from net/http/fs.go:
// func __serveFile(w _http.ResponseWriter, r *_http.Request, name string) Object {
// 	_http.ServeFile(w, r, name)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.ServeTLS from net/http/server.go:
// func __serveTLS(l ABEND987(genutils.go: imports not yet supported: net.Listener), handler _http.Handler, certFile string, keyFile string)  {
// 	_res := _http.ServeTLS(l, handler, certFile, keyFile)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/http.SetCookie from net/http/cookie.go:
// func __setCookie(w _http.ResponseWriter, cookie *_http.Cookie) Object {
// 	_http.SetCookie(w, cookie)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.StripPrefix from net/http/server.go:
func __stripPrefix(prefix string, h _http.Handler) Object {
	_res := _http.StripPrefix(prefix, h)
	return MakeGoObject(_res)
}

GO FUNC net/http.TimeoutHandler from net/http/server.go:
// func __timeoutHandler(h _http.Handler, dt ABEND987(genutils.go: imports not yet supported: time.Duration), msg string) Object {
// 	_res := _http.TimeoutHandler(h, dt, msg)
// 	return MakeGoObject(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package http

import (
	_http "net/http"
	. "github.com/candid82/joker/core"
)
GO TYPE net/http/cgi.Handler from net/http/cgi/host.go:
func ExtractGoObjectHandler(args []Object, index int) *_cgi.Handler {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cgi.Handler:
			return &r
		case *_cgi.Handler:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cgi.Handler]"))
}

func _mapToHandler(o Map) *_cgi.Handler {
	return &_cgi.Handler{
	}
}

func _vectorToHandler(o *Vector) *_cgi.Handler {
	return &_cgi.Handler{
	}
}

func _ConstructHandler(_v Object) *_cgi.Handler {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _cgi.Handler:
			return &_g
		case *_cgi.Handler:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToHandler(_o.(Map))
	case case *Vector:
		return _vectorToHandler(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[cgi.Handler] or Map"))
}

GO FUNC net/http/cgi.Request from net/http/cgi/child.go:
func __request() Object {
	_res1, _res2 := _cgi.Request()
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http/cgi.RequestFromMap from net/http/cgi/child.go:
// func __requestFromMap(params map[]) Object {
// 	_res1, _res2 := _cgi.RequestFromMap(params)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/cgi.Serve from net/http/cgi/child.go:
// func __serve(handler ABEND987(genutils.go: imports not yet supported: http.Handler))  {
// 	_res := _cgi.Serve(handler)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package cgi

import (
	_cgi "net/http/cgi"
	. "github.com/candid82/joker/core"
)
GO TYPE net/http/cookiejar.Jar from net/http/cookiejar/jar.go:
func ExtractGoObjectJar(args []Object, index int) *_cookiejar.Jar {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cookiejar.Jar:
			return &r
		case *_cookiejar.Jar:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cookiejar.Jar]"))
}

func _mapToJar(o Map) *_cookiejar.Jar {
	return &_cookiejar.Jar{
	}
}

func _vectorToJar(o *Vector) *_cookiejar.Jar {
	return &_cookiejar.Jar{
	}
}

func _ConstructJar(_v Object) *_cookiejar.Jar {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _cookiejar.Jar:
			return &_g
		case *_cookiejar.Jar:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToJar(_o.(Map))
	case case *Vector:
		return _vectorToJar(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[cookiejar.Jar] or Map"))
}

GO TYPE net/http/cookiejar.Options from net/http/cookiejar/jar.go:
func ExtractGoObjectOptions(args []Object, index int) *_cookiejar.Options {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cookiejar.Options:
			return &r
		case *_cookiejar.Options:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cookiejar.Options]"))
}

func _mapToOptions(o Map) *_cookiejar.Options {
	return &_cookiejar.Options{
	}
}

func _vectorToOptions(o *Vector) *_cookiejar.Options {
	return &_cookiejar.Options{
	}
}

func _ConstructOptions(_v Object) *_cookiejar.Options {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _cookiejar.Options:
			return &_g
		case *_cookiejar.Options:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToOptions(_o.(Map))
	case case *Vector:
		return _vectorToOptions(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[cookiejar.Options] or Map"))
}

GO TYPE net/http/cookiejar.PublicSuffixList from net/http/cookiejar/jar.go:
func ExtractGoObjectPublicSuffixList(args []Object, index int) *_cookiejar.PublicSuffixList {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cookiejar.PublicSuffixList:
			return &r
		case *_cookiejar.PublicSuffixList:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cookiejar.PublicSuffixList]"))
}

// func _ConstructPublicSuffixList(_v Object) _cookiejar.PublicSuffixList {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cookiejar.PublicSuffixList:
// 			return _g
// 		case *_cookiejar.PublicSuffixList:
// 			return *_g
// 		}
// 	default:
// 		return _cookiejar.PublicSuffixList(_o.ABEND674(unknown underlying type *ast.InterfaceType for PublicSuffixList))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cookiejar.PublicSuffixList] or whatever"))
// }

GO FUNC net/http/cookiejar.New from net/http/cookiejar/jar.go:
func __new(o *_cookiejar.Options) Object {
	_res1, _res2 := _cookiejar.New(o)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package cookiejar

import (
	_cookiejar "net/http/cookiejar"
	. "github.com/candid82/joker/core"
)
GO FUNC net/http/fcgi.ProcessEnv from net/http/fcgi/child.go:
// func __processEnv(r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	return _fcgi.ProcessEnv(r)
// }

GO FUNC net/http/fcgi.Serve from net/http/fcgi/child.go:
// func __serve(l ABEND987(genutils.go: imports not yet supported: net.Listener), handler ABEND987(genutils.go: imports not yet supported: http.Handler))  {
// 	_res := _fcgi.Serve(l, handler)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO TYPE net/http/httptest.ResponseRecorder from net/http/httptest/recorder.go:
func ExtractGoObjectResponseRecorder(args []Object, index int) *_httptest.ResponseRecorder {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httptest.ResponseRecorder:
			return &r
		case *_httptest.ResponseRecorder:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httptest.ResponseRecorder]"))
}

func _mapToResponseRecorder(o Map) *_httptest.ResponseRecorder {
	return &_httptest.ResponseRecorder{
	}
}

func _vectorToResponseRecorder(o *Vector) *_httptest.ResponseRecorder {
	return &_httptest.ResponseRecorder{
	}
}

func _ConstructResponseRecorder(_v Object) *_httptest.ResponseRecorder {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _httptest.ResponseRecorder:
			return &_g
		case *_httptest.ResponseRecorder:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToResponseRecorder(_o.(Map))
	case case *Vector:
		return _vectorToResponseRecorder(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[httptest.ResponseRecorder] or Map"))
}

GO TYPE net/http/httptest.Server from net/http/httptest/server.go:
func ExtractGoObjectServer(args []Object, index int) *_httptest.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httptest.Server:
			return &r
		case *_httptest.Server:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httptest.Server]"))
}

func _mapToServer(o Map) *_httptest.Server {
	return &_httptest.Server{
	}
}

func _vectorToServer(o *Vector) *_httptest.Server {
	return &_httptest.Server{
	}
}

func _ConstructServer(_v Object) *_httptest.Server {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _httptest.Server:
			return &_g
		case *_httptest.Server:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToServer(_o.(Map))
	case case *Vector:
		return _vectorToServer(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[httptest.Server] or Map"))
}

GO FUNC net/http/httptest.NewRecorder from net/http/httptest/recorder.go:
func __newRecorder() Object {
	_res := _httptest.NewRecorder()
	return MakeGoObject(_res)
}

GO FUNC net/http/httptest.NewRequest from net/http/httptest/httptest.go:
// func __newRequest(method string, target string, body ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _httptest.NewRequest(method, target, body)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptest.NewServer from net/http/httptest/server.go:
// func __newServer(handler ABEND987(genutils.go: imports not yet supported: http.Handler)) Object {
// 	_res := _httptest.NewServer(handler)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptest.NewTLSServer from net/http/httptest/server.go:
// func __newTLSServer(handler ABEND987(genutils.go: imports not yet supported: http.Handler)) Object {
// 	_res := _httptest.NewTLSServer(handler)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptest.NewUnstartedServer from net/http/httptest/server.go:
// func __newUnstartedServer(handler ABEND987(genutils.go: imports not yet supported: http.Handler)) Object {
// 	_res := _httptest.NewUnstartedServer(handler)
// 	return MakeGoObject(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package httptest

import (
	_httptest "net/http/httptest"
	. "github.com/candid82/joker/core"
)
GO FUNC net/http/httptrace.ContextClientTrace from net/http/httptrace/trace.go:
// func __contextClientTrace(ctx ABEND987(genutils.go: imports not yet supported: context.Context)) Object {
// 	_res := _httptrace.ContextClientTrace(ctx)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptrace.WithClientTrace from net/http/httptrace/trace.go:
// func __withClientTrace(ctx ABEND987(genutils.go: imports not yet supported: context.Context), trace *_httptrace.ClientTrace) Object {
// 	_res := _httptrace.WithClientTrace(ctx, trace)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.DumpRequest from net/http/httputil/dump.go:
// func __dumpRequest(req *ABEND987(genutils.go: imports not yet supported: http.Request), body bool) Object {
// 	_res1, _res2 := _httputil.DumpRequest(req, body)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.DumpRequestOut from net/http/httputil/dump.go:
// func __dumpRequestOut(req *ABEND987(genutils.go: imports not yet supported: http.Request), body bool) Object {
// 	_res1, _res2 := _httputil.DumpRequestOut(req, body)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.DumpResponse from net/http/httputil/dump.go:
// func __dumpResponse(resp *ABEND987(genutils.go: imports not yet supported: http.Response), body bool) Object {
// 	_res1, _res2 := _httputil.DumpResponse(resp, body)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.NewChunkedReader from net/http/httputil/httputil.go:
// func __newChunkedReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _httputil.NewChunkedReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewChunkedWriter from net/http/httputil/httputil.go:
// func __newChunkedWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _httputil.NewChunkedWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewClientConn from net/http/httputil/persist.go:
// func __newClientConn(c ABEND987(genutils.go: imports not yet supported: net.Conn), r *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res := _httputil.NewClientConn(c, r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewProxyClientConn from net/http/httputil/persist.go:
// func __newProxyClientConn(c ABEND987(genutils.go: imports not yet supported: net.Conn), r *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res := _httputil.NewProxyClientConn(c, r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewServerConn from net/http/httputil/persist.go:
// func __newServerConn(c ABEND987(genutils.go: imports not yet supported: net.Conn), r *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res := _httputil.NewServerConn(c, r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewSingleHostReverseProxy from net/http/httputil/reverseproxy.go:
// func __newSingleHostReverseProxy(target *ABEND987(genutils.go: imports not yet supported: url.URL)) Object {
// 	_res := _httputil.NewSingleHostReverseProxy(target)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/pprof.Cmdline from net/http/pprof/pprof.go:
// func __cmdline(w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	_pprof.Cmdline(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Handler from net/http/pprof/pprof.go:
func __handler(name string) Object {
	_res := _pprof.Handler(name)
	return MakeGoObject(_res)
}

GO FUNC net/http/pprof.Index from net/http/pprof/pprof.go:
// func __index(w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	_pprof.Index(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Profile from net/http/pprof/pprof.go:
// func __profile(w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	_pprof.Profile(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Symbol from net/http/pprof/pprof.go:
// func __symbol(w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	_pprof.Symbol(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Trace from net/http/pprof/pprof.go:
// func __trace(w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	_pprof.Trace(w, r)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package pprof

import (
	_pprof "net/http/pprof"
	. "github.com/candid82/joker/core"
)
GO TYPE net/mail.Address from net/mail/message.go:
func ExtractGoObjectAddress(args []Object, index int) *_mail.Address {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mail.Address:
			return &r
		case *_mail.Address:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.Address]"))
}

func _mapToAddress(o Map) *_mail.Address {
	return &_mail.Address{
	}
}

func _vectorToAddress(o *Vector) *_mail.Address {
	return &_mail.Address{
	}
}

func _ConstructAddress(_v Object) *_mail.Address {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _mail.Address:
			return &_g
		case *_mail.Address:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToAddress(_o.(Map))
	case case *Vector:
		return _vectorToAddress(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.Address] or Map"))
}

GO TYPE net/mail.AddressParser from net/mail/message.go:
func ExtractGoObjectAddressParser(args []Object, index int) *_mail.AddressParser {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mail.AddressParser:
			return &r
		case *_mail.AddressParser:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.AddressParser]"))
}

func _mapToAddressParser(o Map) *_mail.AddressParser {
	return &_mail.AddressParser{
	}
}

func _vectorToAddressParser(o *Vector) *_mail.AddressParser {
	return &_mail.AddressParser{
	}
}

func _ConstructAddressParser(_v Object) *_mail.AddressParser {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _mail.AddressParser:
			return &_g
		case *_mail.AddressParser:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToAddressParser(_o.(Map))
	case case *Vector:
		return _vectorToAddressParser(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.AddressParser] or Map"))
}

GO TYPE net/mail.Header from net/mail/message.go:
func ExtractGoObjectHeader(args []Object, index int) *_mail.Header {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mail.Header:
			return &r
		case *_mail.Header:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.Header]"))
}

// func _ConstructHeader(_v Object) _mail.Header {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _mail.Header:
// 			return _g
// 		case *_mail.Header:
// 			return *_g
// 		}
// 	default:
// 		return _mail.Header(_o.ABEND674(unknown underlying type *ast.MapType for Header))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.Header] or whatever"))
// }

GO TYPE net/mail.Message from net/mail/message.go:
func ExtractGoObjectMessage(args []Object, index int) *_mail.Message {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mail.Message:
			return &r
		case *_mail.Message:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.Message]"))
}

func _mapToMessage(o Map) *_mail.Message {
	return &_mail.Message{
	}
}

func _vectorToMessage(o *Vector) *_mail.Message {
	return &_mail.Message{
	}
}

func _ConstructMessage(_v Object) *_mail.Message {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _mail.Message:
			return &_g
		case *_mail.Message:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMessage(_o.(Map))
	case case *Vector:
		return _vectorToMessage(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.Message] or Map"))
}

GO FUNC net/mail.ParseAddress from net/mail/message.go:
func __parseAddress(address string) Object {
	_res1, _res2 := _mail.ParseAddress(address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.ParseAddressList from net/mail/message.go:
func __parseAddressList(list string) Object {
	_res1, _res2 := _mail.ParseAddressList(list)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.ParseDate from net/mail/message.go:
func __parseDate(date string) Object {
	_res1, _res2 := _mail.ParseDate(date)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.ReadMessage from net/mail/message.go:
// func __readMessage(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	msg, err := _mail.ReadMessage(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(msg))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package mail

import (
	_mail "net/mail"
	. "github.com/candid82/joker/core"
)
GO TYPE net/rpc.Call from net/rpc/client.go:
func ExtractGoObjectCall(args []Object, index int) *_rpc.Call {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Call:
			return &r
		case *_rpc.Call:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Call]"))
}

func _mapToCall(o Map) *_rpc.Call {
	return &_rpc.Call{
	}
}

func _vectorToCall(o *Vector) *_rpc.Call {
	return &_rpc.Call{
	}
}

func _ConstructCall(_v Object) *_rpc.Call {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.Call:
			return &_g
		case *_rpc.Call:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCall(_o.(Map))
	case case *Vector:
		return _vectorToCall(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Call] or Map"))
}

GO TYPE net/rpc.Client from net/rpc/client.go:
func ExtractGoObjectClient(args []Object, index int) *_rpc.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Client:
			return &r
		case *_rpc.Client:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Client]"))
}

func _mapToClient(o Map) *_rpc.Client {
	return &_rpc.Client{
	}
}

func _vectorToClient(o *Vector) *_rpc.Client {
	return &_rpc.Client{
	}
}

func _ConstructClient(_v Object) *_rpc.Client {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.Client:
			return &_g
		case *_rpc.Client:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToClient(_o.(Map))
	case case *Vector:
		return _vectorToClient(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Client] or Map"))
}

GO TYPE net/rpc.ClientCodec from net/rpc/client.go:
func ExtractGoObjectClientCodec(args []Object, index int) *_rpc.ClientCodec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.ClientCodec:
			return &r
		case *_rpc.ClientCodec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.ClientCodec]"))
}

// func _ConstructClientCodec(_v Object) _rpc.ClientCodec {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rpc.ClientCodec:
// 			return _g
// 		case *_rpc.ClientCodec:
// 			return *_g
// 		}
// 	default:
// 		return _rpc.ClientCodec(_o.ABEND674(unknown underlying type *ast.InterfaceType for ClientCodec))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.ClientCodec] or whatever"))
// }

GO TYPE net/rpc.Request from net/rpc/server.go:
func ExtractGoObjectRequest(args []Object, index int) *_rpc.Request {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Request:
			return &r
		case *_rpc.Request:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Request]"))
}

func _mapToRequest(o Map) *_rpc.Request {
	return &_rpc.Request{
	}
}

func _vectorToRequest(o *Vector) *_rpc.Request {
	return &_rpc.Request{
	}
}

func _ConstructRequest(_v Object) *_rpc.Request {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.Request:
			return &_g
		case *_rpc.Request:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRequest(_o.(Map))
	case case *Vector:
		return _vectorToRequest(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Request] or Map"))
}

GO TYPE net/rpc.Response from net/rpc/server.go:
func ExtractGoObjectResponse(args []Object, index int) *_rpc.Response {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Response:
			return &r
		case *_rpc.Response:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Response]"))
}

func _mapToResponse(o Map) *_rpc.Response {
	return &_rpc.Response{
	}
}

func _vectorToResponse(o *Vector) *_rpc.Response {
	return &_rpc.Response{
	}
}

func _ConstructResponse(_v Object) *_rpc.Response {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.Response:
			return &_g
		case *_rpc.Response:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToResponse(_o.(Map))
	case case *Vector:
		return _vectorToResponse(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Response] or Map"))
}

GO TYPE net/rpc.Server from net/rpc/server.go:
func ExtractGoObjectServer(args []Object, index int) *_rpc.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Server:
			return &r
		case *_rpc.Server:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Server]"))
}

func _mapToServer(o Map) *_rpc.Server {
	return &_rpc.Server{
	}
}

func _vectorToServer(o *Vector) *_rpc.Server {
	return &_rpc.Server{
	}
}

func _ConstructServer(_v Object) *_rpc.Server {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.Server:
			return &_g
		case *_rpc.Server:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToServer(_o.(Map))
	case case *Vector:
		return _vectorToServer(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Server] or Map"))
}

GO TYPE net/rpc.ServerCodec from net/rpc/server.go:
func ExtractGoObjectServerCodec(args []Object, index int) *_rpc.ServerCodec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.ServerCodec:
			return &r
		case *_rpc.ServerCodec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.ServerCodec]"))
}

// func _ConstructServerCodec(_v Object) _rpc.ServerCodec {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rpc.ServerCodec:
// 			return _g
// 		case *_rpc.ServerCodec:
// 			return *_g
// 		}
// 	default:
// 		return _rpc.ServerCodec(_o.ABEND674(unknown underlying type *ast.InterfaceType for ServerCodec))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.ServerCodec] or whatever"))
// }

GO TYPE net/rpc.ServerError from net/rpc/client.go:
func ExtractGoObjectServerError(args []Object, index int) *_rpc.ServerError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.ServerError:
			return &r
		case *_rpc.ServerError:
			return r
		}
	case String:
		v := _rpc.ServerError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.ServerError]"))
}

func _ConstructServerError(_v Object) _rpc.ServerError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.ServerError:
			return _g
		case *_rpc.ServerError:
			return *_g
		}
	case String:
		return _rpc.ServerError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.ServerError] or String"))
}

GO FUNC net/rpc.Accept from net/rpc/server.go:
// func __accept(lis ABEND987(genutils.go: imports not yet supported: net.Listener)) Object {
// 	_rpc.Accept(lis)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.Dial from net/rpc/client.go:
func __dial(network string, address string) Object {
	_res1, _res2 := _rpc.Dial(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.DialHTTP from net/rpc/client.go:
func __dialHTTP(network string, address string) Object {
	_res1, _res2 := _rpc.DialHTTP(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.DialHTTPPath from net/rpc/client.go:
func __dialHTTPPath(network string, address string, path string) Object {
	_res1, _res2 := _rpc.DialHTTPPath(network, address, path)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.HandleHTTP from net/rpc/server.go:
// func __handleHTTP() Object {
// 	_rpc.HandleHTTP()
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.NewClient from net/rpc/client.go:
// func __newClient(conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _rpc.NewClient(conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc.NewClientWithCodec from net/rpc/client.go:
func __newClientWithCodec(codec _rpc.ClientCodec) Object {
	_res := _rpc.NewClientWithCodec(codec)
	return MakeGoObject(_res)
}

GO FUNC net/rpc.NewServer from net/rpc/server.go:
func __newServer() Object {
	_res := _rpc.NewServer()
	return MakeGoObject(_res)
}

GO FUNC net/rpc.Register from net/rpc/server.go:
// func __register(rcvr interface {})  {
// 	_res := _rpc.Register(rcvr)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/rpc.RegisterName from net/rpc/server.go:
// func __registerName(name string, rcvr interface {})  {
// 	_res := _rpc.RegisterName(name, rcvr)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/rpc.ServeCodec from net/rpc/server.go:
// func __serveCodec(codec _rpc.ServerCodec) Object {
// 	_rpc.ServeCodec(codec)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.ServeConn from net/rpc/server.go:
// func __serveConn(conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_rpc.ServeConn(conn)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package rpc

import (
	_rpc "net/rpc"
	. "github.com/candid82/joker/core"
)
GO FUNC net/rpc/jsonrpc.Dial from net/rpc/jsonrpc/client.go:
func __dial(network string, address string) Object {
	_res1, _res2 := _jsonrpc.Dial(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc/jsonrpc.NewClient from net/rpc/jsonrpc/client.go:
// func __newClient(conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _jsonrpc.NewClient(conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc/jsonrpc.NewClientCodec from net/rpc/jsonrpc/client.go:
// func __newClientCodec(conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _jsonrpc.NewClientCodec(conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc/jsonrpc.NewServerCodec from net/rpc/jsonrpc/server.go:
// func __newServerCodec(conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _jsonrpc.NewServerCodec(conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc/jsonrpc.ServeConn from net/rpc/jsonrpc/server.go:
// func __serveConn(conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_jsonrpc.ServeConn(conn)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package jsonrpc

import (
	_jsonrpc "net/rpc/jsonrpc"
	. "github.com/candid82/joker/core"
)
GO TYPE net/smtp.Auth from net/smtp/auth.go:
func ExtractGoObjectAuth(args []Object, index int) *_smtp.Auth {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _smtp.Auth:
			return &r
		case *_smtp.Auth:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/smtp.Auth]"))
}

// func _ConstructAuth(_v Object) _smtp.Auth {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _smtp.Auth:
// 			return _g
// 		case *_smtp.Auth:
// 			return *_g
// 		}
// 	default:
// 		return _smtp.Auth(_o.ABEND674(unknown underlying type *ast.InterfaceType for Auth))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[smtp.Auth] or whatever"))
// }

GO TYPE net/smtp.Client from net/smtp/smtp.go:
func ExtractGoObjectClient(args []Object, index int) *_smtp.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _smtp.Client:
			return &r
		case *_smtp.Client:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/smtp.Client]"))
}

func _mapToClient(o Map) *_smtp.Client {
	return &_smtp.Client{
	}
}

func _vectorToClient(o *Vector) *_smtp.Client {
	return &_smtp.Client{
	}
}

func _ConstructClient(_v Object) *_smtp.Client {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _smtp.Client:
			return &_g
		case *_smtp.Client:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToClient(_o.(Map))
	case case *Vector:
		return _vectorToClient(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[smtp.Client] or Map"))
}

GO TYPE net/smtp.ServerInfo from net/smtp/auth.go:
func ExtractGoObjectServerInfo(args []Object, index int) *_smtp.ServerInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _smtp.ServerInfo:
			return &r
		case *_smtp.ServerInfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/smtp.ServerInfo]"))
}

func _mapToServerInfo(o Map) *_smtp.ServerInfo {
	return &_smtp.ServerInfo{
	}
}

func _vectorToServerInfo(o *Vector) *_smtp.ServerInfo {
	return &_smtp.ServerInfo{
	}
}

func _ConstructServerInfo(_v Object) *_smtp.ServerInfo {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _smtp.ServerInfo:
			return &_g
		case *_smtp.ServerInfo:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToServerInfo(_o.(Map))
	case case *Vector:
		return _vectorToServerInfo(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[smtp.ServerInfo] or Map"))
}

GO FUNC net/smtp.CRAMMD5Auth from net/smtp/auth.go:
func __cRAMMD5Auth(username string, secret string) Object {
	_res := _smtp.CRAMMD5Auth(username, secret)
	return MakeGoObject(_res)
}

GO FUNC net/smtp.Dial from net/smtp/smtp.go:
func __dial(addr string) Object {
	_res1, _res2 := _smtp.Dial(addr)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/smtp.NewClient from net/smtp/smtp.go:
// func __newClient(conn ABEND987(genutils.go: imports not yet supported: net.Conn), host string) Object {
// 	_res1, _res2 := _smtp.NewClient(conn, host)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/smtp.PlainAuth from net/smtp/auth.go:
func __plainAuth(identity string, username string, password string, host string) Object {
	_res := _smtp.PlainAuth(identity, username, password, host)
	return MakeGoObject(_res)
}

GO FUNC net/smtp.SendMail from net/smtp/smtp.go:
// func __sendMail(addr string, a _smtp.Auth, from string, to []string, msg []byte)  {
// 	_res := _smtp.SendMail(addr, a, from, to, msg)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package smtp

import (
	_smtp "net/smtp"
	. "github.com/candid82/joker/core"
)
GO TYPE net/textproto.Conn from net/textproto/textproto.go:
func ExtractGoObjectConn(args []Object, index int) *_textproto.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Conn:
			return &r
		case *_textproto.Conn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Conn]"))
}

func _mapToConn(o Map) *_textproto.Conn {
	return &_textproto.Conn{
	}
}

func _vectorToConn(o *Vector) *_textproto.Conn {
	return &_textproto.Conn{
	}
}

func _ConstructConn(_v Object) *_textproto.Conn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.Conn:
			return &_g
		case *_textproto.Conn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToConn(_o.(Map))
	case case *Vector:
		return _vectorToConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Conn] or Map"))
}

GO TYPE net/textproto.Error from net/textproto/textproto.go:
func ExtractGoObjectError(args []Object, index int) *_textproto.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Error:
			return &r
		case *_textproto.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Error]"))
}

func _mapToError(o Map) *_textproto.Error {
	return &_textproto.Error{
	}
}

func _vectorToError(o *Vector) *_textproto.Error {
	return &_textproto.Error{
	}
}

func _ConstructError(_v Object) *_textproto.Error {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.Error:
			return &_g
		case *_textproto.Error:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToError(_o.(Map))
	case case *Vector:
		return _vectorToError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Error] or Map"))
}

GO TYPE net/textproto.MIMEHeader from net/textproto/header.go:
func ExtractGoObjectMIMEHeader(args []Object, index int) *_textproto.MIMEHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.MIMEHeader:
			return &r
		case *_textproto.MIMEHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.MIMEHeader]"))
}

// func _ConstructMIMEHeader(_v Object) _textproto.MIMEHeader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _textproto.MIMEHeader:
// 			return _g
// 		case *_textproto.MIMEHeader:
// 			return *_g
// 		}
// 	default:
// 		return _textproto.MIMEHeader(_o.ABEND674(unknown underlying type *ast.MapType for MIMEHeader))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.MIMEHeader] or whatever"))
// }

GO TYPE net/textproto.Pipeline from net/textproto/pipeline.go:
func ExtractGoObjectPipeline(args []Object, index int) *_textproto.Pipeline {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Pipeline:
			return &r
		case *_textproto.Pipeline:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Pipeline]"))
}

func _mapToPipeline(o Map) *_textproto.Pipeline {
	return &_textproto.Pipeline{
	}
}

func _vectorToPipeline(o *Vector) *_textproto.Pipeline {
	return &_textproto.Pipeline{
	}
}

func _ConstructPipeline(_v Object) *_textproto.Pipeline {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.Pipeline:
			return &_g
		case *_textproto.Pipeline:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPipeline(_o.(Map))
	case case *Vector:
		return _vectorToPipeline(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Pipeline] or Map"))
}

GO TYPE net/textproto.ProtocolError from net/textproto/textproto.go:
func ExtractGoObjectProtocolError(args []Object, index int) *_textproto.ProtocolError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.ProtocolError:
			return &r
		case *_textproto.ProtocolError:
			return r
		}
	case String:
		v := _textproto.ProtocolError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.ProtocolError]"))
}

func _ConstructProtocolError(_v Object) _textproto.ProtocolError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.ProtocolError:
			return _g
		case *_textproto.ProtocolError:
			return *_g
		}
	case String:
		return _textproto.ProtocolError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.ProtocolError] or String"))
}

GO TYPE net/textproto.Reader from net/textproto/reader.go:
func ExtractGoObjectReader(args []Object, index int) *_textproto.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Reader:
			return &r
		case *_textproto.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Reader]"))
}

func _mapToReader(o Map) *_textproto.Reader {
	return &_textproto.Reader{
	}
}

func _vectorToReader(o *Vector) *_textproto.Reader {
	return &_textproto.Reader{
	}
}

func _ConstructReader(_v Object) *_textproto.Reader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.Reader:
			return &_g
		case *_textproto.Reader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReader(_o.(Map))
	case case *Vector:
		return _vectorToReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Reader] or Map"))
}

GO TYPE net/textproto.Writer from net/textproto/writer.go:
func ExtractGoObjectWriter(args []Object, index int) *_textproto.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Writer:
			return &r
		case *_textproto.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Writer]"))
}

func _mapToWriter(o Map) *_textproto.Writer {
	return &_textproto.Writer{
	}
}

func _vectorToWriter(o *Vector) *_textproto.Writer {
	return &_textproto.Writer{
	}
}

func _ConstructWriter(_v Object) *_textproto.Writer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.Writer:
			return &_g
		case *_textproto.Writer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWriter(_o.(Map))
	case case *Vector:
		return _vectorToWriter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Writer] or Map"))
}

GO FUNC net/textproto.Dial from net/textproto/textproto.go:
func __dial(network string, addr string) Object {
	_res1, _res2 := _textproto.Dial(network, addr)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.NewConn from net/textproto/textproto.go:
// func __newConn(conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _textproto.NewConn(conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/textproto.NewReader from net/textproto/reader.go:
// func __newReader(r *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res := _textproto.NewReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/textproto.NewWriter from net/textproto/writer.go:
// func __newWriter(w *ABEND987(genutils.go: imports not yet supported: bufio.Writer)) Object {
// 	_res := _textproto.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC net/textproto.TrimBytes from net/textproto/textproto.go:
// func __trimBytes(b []byte) Object {
// 	_res := _textproto.TrimBytes(b)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package textproto

import (
	_textproto "net/textproto"
	. "github.com/candid82/joker/core"
)
GO TYPE net/url.Error from net/url/url.go:
func ExtractGoObjectError(args []Object, index int) *_url.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.Error:
			return &r
		case *_url.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Error]"))
}

func _mapToError(o Map) *_url.Error {
	return &_url.Error{
	}
}

func _vectorToError(o *Vector) *_url.Error {
	return &_url.Error{
	}
}

func _ConstructError(_v Object) *_url.Error {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _url.Error:
			return &_g
		case *_url.Error:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToError(_o.(Map))
	case case *Vector:
		return _vectorToError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Error] or Map"))
}

GO TYPE net/url.EscapeError from net/url/url.go:
func ExtractGoObjectEscapeError(args []Object, index int) *_url.EscapeError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.EscapeError:
			return &r
		case *_url.EscapeError:
			return r
		}
	case String:
		v := _url.EscapeError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.EscapeError]"))
}

func _ConstructEscapeError(_v Object) _url.EscapeError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _url.EscapeError:
			return _g
		case *_url.EscapeError:
			return *_g
		}
	case String:
		return _url.EscapeError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.EscapeError] or String"))
}

GO TYPE net/url.InvalidHostError from net/url/url.go:
func ExtractGoObjectInvalidHostError(args []Object, index int) *_url.InvalidHostError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.InvalidHostError:
			return &r
		case *_url.InvalidHostError:
			return r
		}
	case String:
		v := _url.InvalidHostError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.InvalidHostError]"))
}

func _ConstructInvalidHostError(_v Object) _url.InvalidHostError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _url.InvalidHostError:
			return _g
		case *_url.InvalidHostError:
			return *_g
		}
	case String:
		return _url.InvalidHostError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.InvalidHostError] or String"))
}

GO TYPE net/url.URL from net/url/url.go:
func ExtractGoObjectURL(args []Object, index int) *_url.URL {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.URL:
			return &r
		case *_url.URL:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.URL]"))
}

func _mapToURL(o Map) *_url.URL {
	return &_url.URL{
	}
}

func _vectorToURL(o *Vector) *_url.URL {
	return &_url.URL{
	}
}

func _ConstructURL(_v Object) *_url.URL {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _url.URL:
			return &_g
		case *_url.URL:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToURL(_o.(Map))
	case case *Vector:
		return _vectorToURL(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.URL] or Map"))
}

GO TYPE net/url.Userinfo from net/url/url.go:
func ExtractGoObjectUserinfo(args []Object, index int) *_url.Userinfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.Userinfo:
			return &r
		case *_url.Userinfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Userinfo]"))
}

func _mapToUserinfo(o Map) *_url.Userinfo {
	return &_url.Userinfo{
	}
}

func _vectorToUserinfo(o *Vector) *_url.Userinfo {
	return &_url.Userinfo{
	}
}

func _ConstructUserinfo(_v Object) *_url.Userinfo {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _url.Userinfo:
			return &_g
		case *_url.Userinfo:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUserinfo(_o.(Map))
	case case *Vector:
		return _vectorToUserinfo(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Userinfo] or Map"))
}

GO TYPE net/url.Values from net/url/url.go:
func ExtractGoObjectValues(args []Object, index int) *_url.Values {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.Values:
			return &r
		case *_url.Values:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Values]"))
}

// func _ConstructValues(_v Object) _url.Values {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _url.Values:
// 			return _g
// 		case *_url.Values:
// 			return *_g
// 		}
// 	default:
// 		return _url.Values(_o.ABEND674(unknown underlying type *ast.MapType for Values))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Values] or whatever"))
// }

GO FUNC net/url.Parse from net/url/url.go:
func __parse(rawurl string) Object {
	_res1, _res2 := _url.Parse(rawurl)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.ParseQuery from net/url/url.go:
func __parseQuery(query string) Object {
	_res1, _res2 := _url.ParseQuery(query)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.ParseRequestURI from net/url/url.go:
func __parseRequestURI(rawurl string) Object {
	_res1, _res2 := _url.ParseRequestURI(rawurl)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.PathUnescape from net/url/url.go:
func __pathUnescape(s string) Object {
	_res1, _res2 := _url.PathUnescape(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.QueryUnescape from net/url/url.go:
func __queryUnescape(s string) Object {
	_res1, _res2 := _url.QueryUnescape(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.User from net/url/url.go:
func __user(username string) Object {
	_res := _url.User(username)
	return MakeGoObject(_res)
}

GO FUNC net/url.UserPassword from net/url/url.go:
func __userPassword(username string, password string) Object {
	_res := _url.UserPassword(username, password)
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package url

import (
	_url "net/url"
	. "github.com/candid82/joker/core"
)
GO TYPE os.File from os/types.go:
func ExtractGoObjectFile(args []Object, index int) *_os.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _os.File:
			return &r
		case *_os.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os.File]"))
}

func _mapToFile(o Map) *_os.File {
	return &_os.File{
	}
}

func _vectorToFile(o *Vector) *_os.File {
	return &_os.File{
	}
}

func _ConstructFile(_v Object) *_os.File {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _os.File:
			return &_g
		case *_os.File:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFile(_o.(Map))
	case case *Vector:
		return _vectorToFile(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[os.File] or Map"))
}

GO TYPE os.FileInfo from os/types.go:
func ExtractGoObjectFileInfo(args []Object, index int) *_os.FileInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _os.FileInfo:
			return &r
		case *_os.FileInfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os.FileInfo]"))
}

// func _ConstructFileInfo(_v Object) _os.FileInfo {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _os.FileInfo:
// 			return _g
// 		case *_os.FileInfo:
// 			return *_g
// 		}
// 	default:
// 		return _os.FileInfo(_o.ABEND674(unknown underlying type *ast.InterfaceType for FileInfo))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[os.FileInfo] or whatever"))
// }

GO TYPE os.FileMode from os/types.go:
func ExtractGoObjectFileMode(args []Object, index int) *_os.FileMode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _os.FileMode:
			return &r
		case *_os.FileMode:
			return r
		}
	case Number:
		v := _os.FileMode(ExtractUInt32(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os.FileMode]"))
}

func _ConstructFileMode(_v Object) _os.FileMode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _os.FileMode:
			return _g
		case *_os.FileMode:
			return *_g
		}
	case Number:
		return _os.FileMode(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[os.FileMode] or Number"))
}

GO TYPE os.LinkError from os/file.go:
func ExtractGoObjectLinkError(args []Object, index int) *_os.LinkError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _os.LinkError:
			return &r
		case *_os.LinkError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os.LinkError]"))
}

func _mapToLinkError(o Map) *_os.LinkError {
	return &_os.LinkError{
	}
}

func _vectorToLinkError(o *Vector) *_os.LinkError {
	return &_os.LinkError{
	}
}

func _ConstructLinkError(_v Object) *_os.LinkError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _os.LinkError:
			return &_g
		case *_os.LinkError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToLinkError(_o.(Map))
	case case *Vector:
		return _vectorToLinkError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[os.LinkError] or Map"))
}

GO TYPE os.PathError from os/error.go:
func ExtractGoObjectPathError(args []Object, index int) *_os.PathError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _os.PathError:
			return &r
		case *_os.PathError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os.PathError]"))
}

func _mapToPathError(o Map) *_os.PathError {
	return &_os.PathError{
	}
}

func _vectorToPathError(o *Vector) *_os.PathError {
	return &_os.PathError{
	}
}

func _ConstructPathError(_v Object) *_os.PathError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _os.PathError:
			return &_g
		case *_os.PathError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPathError(_o.(Map))
	case case *Vector:
		return _vectorToPathError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[os.PathError] or Map"))
}

GO TYPE os.ProcAttr from os/exec.go:
func ExtractGoObjectProcAttr(args []Object, index int) *_os.ProcAttr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _os.ProcAttr:
			return &r
		case *_os.ProcAttr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os.ProcAttr]"))
}

func _mapToProcAttr(o Map) *_os.ProcAttr {
	return &_os.ProcAttr{
	}
}

func _vectorToProcAttr(o *Vector) *_os.ProcAttr {
	return &_os.ProcAttr{
	}
}

func _ConstructProcAttr(_v Object) *_os.ProcAttr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _os.ProcAttr:
			return &_g
		case *_os.ProcAttr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProcAttr(_o.(Map))
	case case *Vector:
		return _vectorToProcAttr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[os.ProcAttr] or Map"))
}

GO TYPE os.Process from os/exec.go:
func ExtractGoObjectProcess(args []Object, index int) *_os.Process {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _os.Process:
			return &r
		case *_os.Process:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os.Process]"))
}

func _mapToProcess(o Map) *_os.Process {
	return &_os.Process{
	}
}

func _vectorToProcess(o *Vector) *_os.Process {
	return &_os.Process{
	}
}

func _ConstructProcess(_v Object) *_os.Process {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _os.Process:
			return &_g
		case *_os.Process:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProcess(_o.(Map))
	case case *Vector:
		return _vectorToProcess(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[os.Process] or Map"))
}

GO TYPE os.ProcessState from os/exec_posix.go:
func ExtractGoObjectProcessState(args []Object, index int) *_os.ProcessState {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _os.ProcessState:
			return &r
		case *_os.ProcessState:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os.ProcessState]"))
}

func _mapToProcessState(o Map) *_os.ProcessState {
	return &_os.ProcessState{
	}
}

func _vectorToProcessState(o *Vector) *_os.ProcessState {
	return &_os.ProcessState{
	}
}

func _ConstructProcessState(_v Object) *_os.ProcessState {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _os.ProcessState:
			return &_g
		case *_os.ProcessState:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProcessState(_o.(Map))
	case case *Vector:
		return _vectorToProcessState(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[os.ProcessState] or Map"))
}

GO TYPE os.Signal from os/exec.go:
func ExtractGoObjectSignal(args []Object, index int) *_os.Signal {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _os.Signal:
			return &r
		case *_os.Signal:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os.Signal]"))
}

// func _ConstructSignal(_v Object) _os.Signal {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _os.Signal:
// 			return _g
// 		case *_os.Signal:
// 			return *_g
// 		}
// 	default:
// 		return _os.Signal(_o.ABEND674(unknown underlying type *ast.InterfaceType for Signal))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[os.Signal] or whatever"))
// }

GO TYPE os.SyscallError from os/error.go:
func ExtractGoObjectSyscallError(args []Object, index int) *_os.SyscallError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _os.SyscallError:
			return &r
		case *_os.SyscallError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os.SyscallError]"))
}

func _mapToSyscallError(o Map) *_os.SyscallError {
	return &_os.SyscallError{
	}
}

func _vectorToSyscallError(o *Vector) *_os.SyscallError {
	return &_os.SyscallError{
	}
}

func _ConstructSyscallError(_v Object) *_os.SyscallError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _os.SyscallError:
			return &_g
		case *_os.SyscallError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSyscallError(_o.(Map))
	case case *Vector:
		return _vectorToSyscallError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[os.SyscallError] or Map"))
}

GO FUNC os.Chtimes from os/file_posix.go:
// func __chtimes(name string, atime ABEND987(genutils.go: imports not yet supported: time.Time), mtime ABEND987(genutils.go: imports not yet supported: time.Time))  {
// 	_res := _os.Chtimes(name, atime, mtime)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC os.Clearenv from os/env.go:
// func __clearenv() Object {
// 	_os.Clearenv()
// 	...ABEND675: TODO...
// }

GO FUNC os.Create from os/file.go:
func __create(name string) Object {
	_res1, _res2 := _os.Create(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.Environ from os/env.go:
func __environ() Object {
	_res := _os.Environ()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC os.Executable from os/executable.go:
func __executable() Object {
	_res1, _res2 := _os.Executable()
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.Exit from os/proc.go:
// func __exit(code int) Object {
// 	_os.Exit(code)
// 	...ABEND675: TODO...
// }

GO FUNC os.Expand from os/env.go:
// func __expand(s string, mapping func)  {
// 	_res := _os.Expand(s, mapping)
// 	return MakeString(_res)
// }

GO FUNC os.FindProcess from os/exec.go:
func __findProcess(pid int) Object {
	_res1, _res2 := _os.FindProcess(pid)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.Getgroups from os/proc.go:
func __getgroups() Object {
	_res1, _res2 := _os.Getgroups()
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.Getwd from os/getwd.go:
func __getwd() Object {
	dir, err := _os.Getwd()
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(dir))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC os.Hostname from os/sys.go:
func __hostname() Object {
	name, err := _os.Hostname()
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(name))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC os.IsExist from os/error.go:
// func __isExist(err error)  {
// 	_res := _os.IsExist(err)
// 	return MakeBoolean(_res)
// }

GO FUNC os.IsNotExist from os/error.go:
// func __isNotExist(err error)  {
// 	_res := _os.IsNotExist(err)
// 	return MakeBoolean(_res)
// }

GO FUNC os.IsPathSeparator from os/path_unix.go:
// func __isPathSeparator(c uint8)  {
// 	_res := _os.IsPathSeparator(c)
// 	return MakeBoolean(_res)
// }

GO FUNC os.IsPermission from os/error.go:
// func __isPermission(err error)  {
// 	_res := _os.IsPermission(err)
// 	return MakeBoolean(_res)
// }

GO FUNC os.IsTimeout from os/error.go:
// func __isTimeout(err error)  {
// 	_res := _os.IsTimeout(err)
// 	return MakeBoolean(_res)
// }

GO FUNC os.LookupEnv from os/env.go:
func __lookupEnv(key string) Object {
	_res1, _res2 := _os.LookupEnv(key)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(MakeBoolean(_res2))
	return _res
}

GO FUNC os.Lstat from os/stat.go:
func __lstat(name string) Object {
	_res1, _res2 := _os.Lstat(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.NewFile from os/file_unix.go:
func __newFile(fd uintptr, name string) Object {
	_res := _os.NewFile(fd, name)
	return MakeGoObject(_res)
}

GO FUNC os.NewSyscallError from os/error.go:
// func __newSyscallError(syscall string, err error)  {
// 	_res := _os.NewSyscallError(syscall, err)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC os.Open from os/file.go:
func __open(name string) Object {
	_res1, _res2 := _os.Open(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.OpenFile from os/file.go:
func __openFile(name string, flag int, perm _os.FileMode) Object {
	_res1, _res2 := _os.OpenFile(name, flag, perm)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.Pipe from os/pipe_linux.go:
func __pipe() Object {
	r, w, err := _os.Pipe()
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(r))
	_res = _res.Conjoin(MakeGoObject(w))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC os.Readlink from os/file_posix.go:
func __readlink(name string) Object {
	_res1, _res2 := _os.Readlink(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.StartProcess from os/exec.go:
// func __startProcess(name string, argv []string, attr *_os.ProcAttr) Object {
// 	_res1, _res2 := _os.StartProcess(name, argv, attr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC os.Stat from os/stat.go:
func __stat(name string) Object {
	_res1, _res2 := _os.Stat(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.UserCacheDir from os/file.go:
func __userCacheDir() Object {
	_res1, _res2 := _os.UserCacheDir()
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package os

import (
	_os "os"
	. "github.com/candid82/joker/core"
)
GO TYPE os/exec.Cmd from os/exec/exec.go:
func ExtractGoObjectCmd(args []Object, index int) *_exec.Cmd {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _exec.Cmd:
			return &r
		case *_exec.Cmd:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os/exec.Cmd]"))
}

func _mapToCmd(o Map) *_exec.Cmd {
	return &_exec.Cmd{
	}
}

func _vectorToCmd(o *Vector) *_exec.Cmd {
	return &_exec.Cmd{
	}
}

func _ConstructCmd(_v Object) *_exec.Cmd {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _exec.Cmd:
			return &_g
		case *_exec.Cmd:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCmd(_o.(Map))
	case case *Vector:
		return _vectorToCmd(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[exec.Cmd] or Map"))
}

GO TYPE os/exec.Error from os/exec/exec.go:
func ExtractGoObjectError(args []Object, index int) *_exec.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _exec.Error:
			return &r
		case *_exec.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os/exec.Error]"))
}

func _mapToError(o Map) *_exec.Error {
	return &_exec.Error{
	}
}

func _vectorToError(o *Vector) *_exec.Error {
	return &_exec.Error{
	}
}

func _ConstructError(_v Object) *_exec.Error {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _exec.Error:
			return &_g
		case *_exec.Error:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToError(_o.(Map))
	case case *Vector:
		return _vectorToError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[exec.Error] or Map"))
}

GO TYPE os/exec.ExitError from os/exec/exec.go:
func ExtractGoObjectExitError(args []Object, index int) *_exec.ExitError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _exec.ExitError:
			return &r
		case *_exec.ExitError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os/exec.ExitError]"))
}

func _mapToExitError(o Map) *_exec.ExitError {
	return &_exec.ExitError{
	}
}

func _vectorToExitError(o *Vector) *_exec.ExitError {
	return &_exec.ExitError{
	}
}

func _ConstructExitError(_v Object) *_exec.ExitError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _exec.ExitError:
			return &_g
		case *_exec.ExitError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToExitError(_o.(Map))
	case case *Vector:
		return _vectorToExitError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[exec.ExitError] or Map"))
}

GO FUNC os/exec.Command from os/exec/exec.go:
// func __command(name string, arg ...string) Object {
// 	_res := _exec.Command(name, arg)
// 	return MakeGoObject(_res)
// }

GO FUNC os/exec.CommandContext from os/exec/exec.go:
// func __commandContext(ctx ABEND987(genutils.go: imports not yet supported: context.Context), name string, arg ...string) Object {
// 	_res := _exec.CommandContext(ctx, name, arg)
// 	return MakeGoObject(_res)
// }

GO FUNC os/exec.LookPath from os/exec/lp_unix.go:
func __lookPath(file string) Object {
	_res1, _res2 := _exec.LookPath(file)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package exec

import (
	_exec "os/exec"
	. "github.com/candid82/joker/core"
)
GO FUNC os/signal.Ignore from os/signal/signal.go:
// func __ignore(sig ...ABEND987(genutils.go: imports not yet supported: os.Signal)) Object {
// 	_signal.Ignore(sig)
// 	...ABEND675: TODO...
// }

GO FUNC os/signal.Ignored from os/signal/signal.go:
// func __ignored(sig ABEND987(genutils.go: imports not yet supported: os.Signal))  {
// 	_res := _signal.Ignored(sig)
// 	return MakeBoolean(_res)
// }

GO FUNC os/signal.Notify from os/signal/signal.go:
// func __notify(c <-chan, sig ...ABEND987(genutils.go: imports not yet supported: os.Signal)) Object {
// 	_signal.Notify(c, sig)
// 	...ABEND675: TODO...
// }

GO FUNC os/signal.Reset from os/signal/signal.go:
// func __reset(sig ...ABEND987(genutils.go: imports not yet supported: os.Signal)) Object {
// 	_signal.Reset(sig)
// 	...ABEND675: TODO...
// }

GO FUNC os/signal.Stop from os/signal/signal.go:
// func __stop(c <-chan) Object {
// 	_signal.Stop(c)
// 	...ABEND675: TODO...
// }

GO TYPE os/user.Group from os/user/user.go:
func ExtractGoObjectGroup(args []Object, index int) *_user.Group {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _user.Group:
			return &r
		case *_user.Group:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os/user.Group]"))
}

func _mapToGroup(o Map) *_user.Group {
	return &_user.Group{
	}
}

func _vectorToGroup(o *Vector) *_user.Group {
	return &_user.Group{
	}
}

func _ConstructGroup(_v Object) *_user.Group {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _user.Group:
			return &_g
		case *_user.Group:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToGroup(_o.(Map))
	case case *Vector:
		return _vectorToGroup(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[user.Group] or Map"))
}

GO TYPE os/user.UnknownGroupError from os/user/user.go:
func ExtractGoObjectUnknownGroupError(args []Object, index int) *_user.UnknownGroupError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _user.UnknownGroupError:
			return &r
		case *_user.UnknownGroupError:
			return r
		}
	case String:
		v := _user.UnknownGroupError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os/user.UnknownGroupError]"))
}

func _ConstructUnknownGroupError(_v Object) _user.UnknownGroupError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _user.UnknownGroupError:
			return _g
		case *_user.UnknownGroupError:
			return *_g
		}
	case String:
		return _user.UnknownGroupError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[user.UnknownGroupError] or String"))
}

GO TYPE os/user.UnknownGroupIdError from os/user/user.go:
func ExtractGoObjectUnknownGroupIdError(args []Object, index int) *_user.UnknownGroupIdError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _user.UnknownGroupIdError:
			return &r
		case *_user.UnknownGroupIdError:
			return r
		}
	case String:
		v := _user.UnknownGroupIdError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os/user.UnknownGroupIdError]"))
}

func _ConstructUnknownGroupIdError(_v Object) _user.UnknownGroupIdError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _user.UnknownGroupIdError:
			return _g
		case *_user.UnknownGroupIdError:
			return *_g
		}
	case String:
		return _user.UnknownGroupIdError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[user.UnknownGroupIdError] or String"))
}

GO TYPE os/user.UnknownUserError from os/user/user.go:
func ExtractGoObjectUnknownUserError(args []Object, index int) *_user.UnknownUserError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _user.UnknownUserError:
			return &r
		case *_user.UnknownUserError:
			return r
		}
	case String:
		v := _user.UnknownUserError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os/user.UnknownUserError]"))
}

func _ConstructUnknownUserError(_v Object) _user.UnknownUserError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _user.UnknownUserError:
			return _g
		case *_user.UnknownUserError:
			return *_g
		}
	case String:
		return _user.UnknownUserError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[user.UnknownUserError] or String"))
}

GO TYPE os/user.UnknownUserIdError from os/user/user.go:
func ExtractGoObjectUnknownUserIdError(args []Object, index int) *_user.UnknownUserIdError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _user.UnknownUserIdError:
			return &r
		case *_user.UnknownUserIdError:
			return r
		}
	case Int:
		v := _user.UnknownUserIdError(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os/user.UnknownUserIdError]"))
}

func _ConstructUnknownUserIdError(_v Object) _user.UnknownUserIdError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _user.UnknownUserIdError:
			return _g
		case *_user.UnknownUserIdError:
			return *_g
		}
	case Number:
		return _user.UnknownUserIdError(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[user.UnknownUserIdError] or Number"))
}

GO TYPE os/user.User from os/user/user.go:
func ExtractGoObjectUser(args []Object, index int) *_user.User {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _user.User:
			return &r
		case *_user.User:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os/user.User]"))
}

func _mapToUser(o Map) *_user.User {
	return &_user.User{
	}
}

func _vectorToUser(o *Vector) *_user.User {
	return &_user.User{
	}
}

func _ConstructUser(_v Object) *_user.User {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _user.User:
			return &_g
		case *_user.User:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUser(_o.(Map))
	case case *Vector:
		return _vectorToUser(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[user.User] or Map"))
}

GO FUNC os/user.Current from os/user/lookup.go:
func __current() Object {
	_res1, _res2 := _user.Current()
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/user.Lookup from os/user/lookup.go:
func __lookup(username string) Object {
	_res1, _res2 := _user.Lookup(username)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/user.LookupGroup from os/user/lookup.go:
func __lookupGroup(name string) Object {
	_res1, _res2 := _user.LookupGroup(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/user.LookupGroupId from os/user/lookup.go:
func __lookupGroupId(gid string) Object {
	_res1, _res2 := _user.LookupGroupId(gid)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/user.LookupId from os/user/lookup.go:
func __lookupId(uid string) Object {
	_res1, _res2 := _user.LookupId(uid)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package user

import (
	_user "os/user"
	. "github.com/candid82/joker/core"
)
GO FUNC path.Join from path/path.go:
// func __join(elem ...string)  {
// 	_res := _path.Join(elem)
// 	return MakeString(_res)
// }

GO FUNC path.Match from path/match.go:
func __match(pattern string, name string) Object {
	matched, err := _path.Match(pattern, name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeBoolean(matched))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC path.Split from path/path.go:
func __split(path string) Object {
	dir, file := _path.Split(path)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(dir))
	_res = _res.Conjoin(MakeString(file))
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package path

import (
	_path "path"
	. "github.com/candid82/joker/core"
)
GO TYPE path/filepath.WalkFunc from path/filepath/path.go:
func ExtractGoObjectWalkFunc(args []Object, index int) *_filepath.WalkFunc {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _filepath.WalkFunc:
			return &r
		case *_filepath.WalkFunc:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[path/filepath.WalkFunc]"))
}

// func _ConstructWalkFunc(_v Object) _filepath.WalkFunc {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _filepath.WalkFunc:
// 			return _g
// 		case *_filepath.WalkFunc:
// 			return *_g
// 		}
// 	default:
// 		return _filepath.WalkFunc(_o.ABEND674(unknown underlying type *ast.FuncType for WalkFunc))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[filepath.WalkFunc] or whatever"))
// }

GO FUNC path/filepath.Abs from path/filepath/path.go:
func __abs(path string) Object {
	_res1, _res2 := _filepath.Abs(path)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC path/filepath.EvalSymlinks from path/filepath/path.go:
func __evalSymlinks(path string) Object {
	_res1, _res2 := _filepath.EvalSymlinks(path)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC path/filepath.Glob from path/filepath/match.go:
func __glob(pattern string) Object {
	matches, err := _filepath.Glob(pattern)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range matches {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC path/filepath.Join from path/filepath/path.go:
// func __join(elem ...string)  {
// 	_res := _filepath.Join(elem)
// 	return MakeString(_res)
// }

GO FUNC path/filepath.Match from path/filepath/match.go:
func __match(pattern string, name string) Object {
	matched, err := _filepath.Match(pattern, name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeBoolean(matched))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC path/filepath.Rel from path/filepath/path.go:
func __rel(basepath string, targpath string) Object {
	_res1, _res2 := _filepath.Rel(basepath, targpath)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC path/filepath.Split from path/filepath/path.go:
func __split(path string) Object {
	dir, file := _filepath.Split(path)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(dir))
	_res = _res.Conjoin(MakeString(file))
	return _res
}

GO FUNC path/filepath.SplitList from path/filepath/path.go:
func __splitList(path string) Object {
	_res := _filepath.SplitList(path)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package filepath

import (
	_filepath "path/filepath"
	. "github.com/candid82/joker/core"
)
GO TYPE plugin.Plugin from plugin/plugin.go:
func ExtractGoObjectPlugin(args []Object, index int) *_plugin.Plugin {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _plugin.Plugin:
			return &r
		case *_plugin.Plugin:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[plugin.Plugin]"))
}

func _mapToPlugin(o Map) *_plugin.Plugin {
	return &_plugin.Plugin{
	}
}

func _vectorToPlugin(o *Vector) *_plugin.Plugin {
	return &_plugin.Plugin{
	}
}

func _ConstructPlugin(_v Object) *_plugin.Plugin {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _plugin.Plugin:
			return &_g
		case *_plugin.Plugin:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPlugin(_o.(Map))
	case case *Vector:
		return _vectorToPlugin(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[plugin.Plugin] or Map"))
}

GO TYPE plugin.Symbol from plugin/plugin.go:
func ExtractGoObjectSymbol(args []Object, index int) *_plugin.Symbol {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _plugin.Symbol:
			return &r
		case *_plugin.Symbol:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[plugin.Symbol]"))
}

// func _ConstructSymbol(_v Object) _plugin.Symbol {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _plugin.Symbol:
// 			return _g
// 		case *_plugin.Symbol:
// 			return *_g
// 		}
// 	default:
// 		return _plugin.Symbol(_o.ABEND674(unknown underlying type *ast.InterfaceType for Symbol))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[plugin.Symbol] or whatever"))
// }

GO FUNC plugin.Open from plugin/plugin.go:
func __open(path string) Object {
	_res1, _res2 := _plugin.Open(path)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package plugin

import (
	_plugin "plugin"
	. "github.com/candid82/joker/core"
)
GO TYPE reflect.ChanDir from reflect/type.go:
func ExtractGoObjectChanDir(args []Object, index int) *_reflect.ChanDir {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.ChanDir:
			return &r
		case *_reflect.ChanDir:
			return r
		}
	case Int:
		v := _reflect.ChanDir(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.ChanDir]"))
}

func _ConstructChanDir(_v Object) _reflect.ChanDir {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _reflect.ChanDir:
			return _g
		case *_reflect.ChanDir:
			return *_g
		}
	case Number:
		return _reflect.ChanDir(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.ChanDir] or Number"))
}

GO TYPE reflect.Kind from reflect/type.go:
func ExtractGoObjectKind(args []Object, index int) *_reflect.Kind {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.Kind:
			return &r
		case *_reflect.Kind:
			return r
		}
	case Number:
		v := _reflect.Kind(ExtractUInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.Kind]"))
}

func _ConstructKind(_v Object) _reflect.Kind {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _reflect.Kind:
			return _g
		case *_reflect.Kind:
			return *_g
		}
	case Number:
		return _reflect.Kind(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.Kind] or Number"))
}

GO TYPE reflect.Method from reflect/type.go:
func ExtractGoObjectMethod(args []Object, index int) *_reflect.Method {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.Method:
			return &r
		case *_reflect.Method:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.Method]"))
}

func _mapToMethod(o Map) *_reflect.Method {
	return &_reflect.Method{
	}
}

func _vectorToMethod(o *Vector) *_reflect.Method {
	return &_reflect.Method{
	}
}

func _ConstructMethod(_v Object) *_reflect.Method {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _reflect.Method:
			return &_g
		case *_reflect.Method:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMethod(_o.(Map))
	case case *Vector:
		return _vectorToMethod(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.Method] or Map"))
}

GO TYPE reflect.SelectCase from reflect/value.go:
func ExtractGoObjectSelectCase(args []Object, index int) *_reflect.SelectCase {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.SelectCase:
			return &r
		case *_reflect.SelectCase:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.SelectCase]"))
}

func _mapToSelectCase(o Map) *_reflect.SelectCase {
	return &_reflect.SelectCase{
	}
}

func _vectorToSelectCase(o *Vector) *_reflect.SelectCase {
	return &_reflect.SelectCase{
	}
}

func _ConstructSelectCase(_v Object) *_reflect.SelectCase {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _reflect.SelectCase:
			return &_g
		case *_reflect.SelectCase:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSelectCase(_o.(Map))
	case case *Vector:
		return _vectorToSelectCase(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.SelectCase] or Map"))
}

GO TYPE reflect.SelectDir from reflect/value.go:
func ExtractGoObjectSelectDir(args []Object, index int) *_reflect.SelectDir {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.SelectDir:
			return &r
		case *_reflect.SelectDir:
			return r
		}
	case Int:
		v := _reflect.SelectDir(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.SelectDir]"))
}

func _ConstructSelectDir(_v Object) _reflect.SelectDir {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _reflect.SelectDir:
			return _g
		case *_reflect.SelectDir:
			return *_g
		}
	case Number:
		return _reflect.SelectDir(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.SelectDir] or Number"))
}

GO TYPE reflect.SliceHeader from reflect/value.go:
func ExtractGoObjectSliceHeader(args []Object, index int) *_reflect.SliceHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.SliceHeader:
			return &r
		case *_reflect.SliceHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.SliceHeader]"))
}

func _mapToSliceHeader(o Map) *_reflect.SliceHeader {
	return &_reflect.SliceHeader{
	}
}

func _vectorToSliceHeader(o *Vector) *_reflect.SliceHeader {
	return &_reflect.SliceHeader{
	}
}

func _ConstructSliceHeader(_v Object) *_reflect.SliceHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _reflect.SliceHeader:
			return &_g
		case *_reflect.SliceHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSliceHeader(_o.(Map))
	case case *Vector:
		return _vectorToSliceHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.SliceHeader] or Map"))
}

GO TYPE reflect.StringHeader from reflect/value.go:
func ExtractGoObjectStringHeader(args []Object, index int) *_reflect.StringHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.StringHeader:
			return &r
		case *_reflect.StringHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.StringHeader]"))
}

func _mapToStringHeader(o Map) *_reflect.StringHeader {
	return &_reflect.StringHeader{
	}
}

func _vectorToStringHeader(o *Vector) *_reflect.StringHeader {
	return &_reflect.StringHeader{
	}
}

func _ConstructStringHeader(_v Object) *_reflect.StringHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _reflect.StringHeader:
			return &_g
		case *_reflect.StringHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToStringHeader(_o.(Map))
	case case *Vector:
		return _vectorToStringHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.StringHeader] or Map"))
}

GO TYPE reflect.StructField from reflect/type.go:
func ExtractGoObjectStructField(args []Object, index int) *_reflect.StructField {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.StructField:
			return &r
		case *_reflect.StructField:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.StructField]"))
}

func _mapToStructField(o Map) *_reflect.StructField {
	return &_reflect.StructField{
	}
}

func _vectorToStructField(o *Vector) *_reflect.StructField {
	return &_reflect.StructField{
	}
}

func _ConstructStructField(_v Object) *_reflect.StructField {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _reflect.StructField:
			return &_g
		case *_reflect.StructField:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToStructField(_o.(Map))
	case case *Vector:
		return _vectorToStructField(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.StructField] or Map"))
}

GO TYPE reflect.StructTag from reflect/type.go:
func ExtractGoObjectStructTag(args []Object, index int) *_reflect.StructTag {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.StructTag:
			return &r
		case *_reflect.StructTag:
			return r
		}
	case String:
		v := _reflect.StructTag(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.StructTag]"))
}

func _ConstructStructTag(_v Object) _reflect.StructTag {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _reflect.StructTag:
			return _g
		case *_reflect.StructTag:
			return *_g
		}
	case String:
		return _reflect.StructTag(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.StructTag] or String"))
}

GO TYPE reflect.Type from reflect/type.go:
func ExtractGoObjectType(args []Object, index int) *_reflect.Type {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.Type:
			return &r
		case *_reflect.Type:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.Type]"))
}

// func _ConstructType(_v Object) _reflect.Type {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _reflect.Type:
// 			return _g
// 		case *_reflect.Type:
// 			return *_g
// 		}
// 	default:
// 		return _reflect.Type(_o.ABEND674(unknown underlying type *ast.InterfaceType for Type))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.Type] or whatever"))
// }

GO TYPE reflect.Value from reflect/value.go:
func ExtractGoObjectValue(args []Object, index int) *_reflect.Value {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.Value:
			return &r
		case *_reflect.Value:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.Value]"))
}

func _mapToValue(o Map) *_reflect.Value {
	return &_reflect.Value{
	}
}

func _vectorToValue(o *Vector) *_reflect.Value {
	return &_reflect.Value{
	}
}

func _ConstructValue(_v Object) *_reflect.Value {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _reflect.Value:
			return &_g
		case *_reflect.Value:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToValue(_o.(Map))
	case case *Vector:
		return _vectorToValue(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.Value] or Map"))
}

GO TYPE reflect.ValueError from reflect/value.go:
func ExtractGoObjectValueError(args []Object, index int) *_reflect.ValueError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.ValueError:
			return &r
		case *_reflect.ValueError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.ValueError]"))
}

func _mapToValueError(o Map) *_reflect.ValueError {
	return &_reflect.ValueError{
	}
}

func _vectorToValueError(o *Vector) *_reflect.ValueError {
	return &_reflect.ValueError{
	}
}

func _ConstructValueError(_v Object) *_reflect.ValueError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _reflect.ValueError:
			return &_g
		case *_reflect.ValueError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToValueError(_o.(Map))
	case case *Vector:
		return _vectorToValueError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.ValueError] or Map"))
}

GO FUNC reflect.Append from reflect/value.go:
// func __append(s _reflect.Value, x ..._reflect.Value) Object {
// 	_res := _reflect.Append(s, x)
// 	return MakeGoObject(_res)
// }

GO FUNC reflect.AppendSlice from reflect/value.go:
func __appendSlice(s _reflect.Value, t _reflect.Value) Object {
	_res := _reflect.AppendSlice(s, t)
	return MakeGoObject(_res)
}

GO FUNC reflect.ArrayOf from reflect/type.go:
func __arrayOf(count int, elem _reflect.Type) Object {
	_res := _reflect.ArrayOf(count, elem)
	return MakeGoObject(_res)
}

GO FUNC reflect.ChanOf from reflect/type.go:
func __chanOf(dir _reflect.ChanDir, t _reflect.Type) Object {
	_res := _reflect.ChanOf(dir, t)
	return MakeGoObject(_res)
}

GO FUNC reflect.DeepEqual from reflect/deepequal.go:
// func __deepEqual(x interface {}, y interface {})  {
// 	_res := _reflect.DeepEqual(x, y)
// 	return MakeBoolean(_res)
// }

GO FUNC reflect.FuncOf from reflect/type.go:
// func __funcOf(in []_reflect.Type, out []_reflect.Type, variadic bool) Object {
// 	_res := _reflect.FuncOf(in, out, variadic)
// 	return MakeGoObject(_res)
// }

GO FUNC reflect.Indirect from reflect/value.go:
func __indirect(v _reflect.Value) Object {
	_res := _reflect.Indirect(v)
	return MakeGoObject(_res)
}

GO FUNC reflect.MakeChan from reflect/value.go:
func __makeChan(typ _reflect.Type, buffer int) Object {
	_res := _reflect.MakeChan(typ, buffer)
	return MakeGoObject(_res)
}

GO FUNC reflect.MakeFunc from reflect/makefunc.go:
// func __makeFunc(typ _reflect.Type, fn func) Object {
// 	_res := _reflect.MakeFunc(typ, fn)
// 	return MakeGoObject(_res)
// }

GO FUNC reflect.MakeMap from reflect/value.go:
func __makeMap(typ _reflect.Type) Object {
	_res := _reflect.MakeMap(typ)
	return MakeGoObject(_res)
}

GO FUNC reflect.MakeMapWithSize from reflect/value.go:
func __makeMapWithSize(typ _reflect.Type, n int) Object {
	_res := _reflect.MakeMapWithSize(typ, n)
	return MakeGoObject(_res)
}

GO FUNC reflect.MakeSlice from reflect/value.go:
func __makeSlice(typ _reflect.Type, len int, cap int) Object {
	_res := _reflect.MakeSlice(typ, len, cap)
	return MakeGoObject(_res)
}

GO FUNC reflect.MapOf from reflect/type.go:
func __mapOf(key _reflect.Type, elem _reflect.Type) Object {
	_res := _reflect.MapOf(key, elem)
	return MakeGoObject(_res)
}

GO FUNC reflect.New from reflect/value.go:
func __new(typ _reflect.Type) Object {
	_res := _reflect.New(typ)
	return MakeGoObject(_res)
}

GO FUNC reflect.NewAt from reflect/value.go:
// func __newAt(typ _reflect.Type, p ABEND987(genutils.go: imports not yet supported: unsafe.Pointer)) Object {
// 	_res := _reflect.NewAt(typ, p)
// 	return MakeGoObject(_res)
// }

GO FUNC reflect.PtrTo from reflect/type.go:
func __ptrTo(t _reflect.Type) Object {
	_res := _reflect.PtrTo(t)
	return MakeGoObject(_res)
}

GO FUNC reflect.Select from reflect/value.go:
// func __select(cases []_reflect.SelectCase) Object {
// 	chosen, recv, recvOK := _reflect.Select(cases)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(chosen))
// 	_res = _res.Conjoin(MakeGoObject(recv))
// 	_res = _res.Conjoin(MakeBoolean(recvOK))
// 	return _res
// }

GO FUNC reflect.SliceOf from reflect/type.go:
func __sliceOf(t _reflect.Type) Object {
	_res := _reflect.SliceOf(t)
	return MakeGoObject(_res)
}

GO FUNC reflect.StructOf from reflect/type.go:
// func __structOf(fields []_reflect.StructField) Object {
// 	_res := _reflect.StructOf(fields)
// 	return MakeGoObject(_res)
// }

GO FUNC reflect.Swapper from reflect/swapper.go:
// func __swapper(slice interface {}) Object {
// 	return _reflect.Swapper(slice)
// }

GO FUNC reflect.TypeOf from reflect/type.go:
// func __typeOf(i interface {}) Object {
// 	_res := _reflect.TypeOf(i)
// 	return MakeGoObject(_res)
// }

GO FUNC reflect.ValueOf from reflect/value.go:
// func __valueOf(i interface {}) Object {
// 	_res := _reflect.ValueOf(i)
// 	return MakeGoObject(_res)
// }

GO FUNC reflect.Zero from reflect/value.go:
func __zero(typ _reflect.Type) Object {
	_res := _reflect.Zero(typ)
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package reflect

import (
	_reflect "reflect"
	. "github.com/candid82/joker/core"
)
GO TYPE regexp.Regexp from regexp/regexp.go:
func ExtractGoObjectRegexp(args []Object, index int) *_regexp.Regexp {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _regexp.Regexp:
			return &r
		case *_regexp.Regexp:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[regexp.Regexp]"))
}

func _mapToRegexp(o Map) *_regexp.Regexp {
	return &_regexp.Regexp{
	}
}

func _vectorToRegexp(o *Vector) *_regexp.Regexp {
	return &_regexp.Regexp{
	}
}

func _ConstructRegexp(_v Object) *_regexp.Regexp {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _regexp.Regexp:
			return &_g
		case *_regexp.Regexp:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRegexp(_o.(Map))
	case case *Vector:
		return _vectorToRegexp(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[regexp.Regexp] or Map"))
}

GO FUNC regexp.Compile from regexp/regexp.go:
func __compile(expr string) Object {
	_res1, _res2 := _regexp.Compile(expr)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC regexp.CompilePOSIX from regexp/regexp.go:
func __compilePOSIX(expr string) Object {
	_res1, _res2 := _regexp.CompilePOSIX(expr)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC regexp.Match from regexp/regexp.go:
// func __match(pattern string, b []byte) Object {
// 	matched, err := _regexp.Match(pattern, b)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeBoolean(matched))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC regexp.MatchReader from regexp/regexp.go:
// func __matchReader(pattern string, r ABEND987(genutils.go: imports not yet supported: io.RuneReader)) Object {
// 	matched, err := _regexp.MatchReader(pattern, r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeBoolean(matched))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC regexp.MatchString from regexp/regexp.go:
func __matchString(pattern string, s string) Object {
	matched, err := _regexp.MatchString(pattern, s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeBoolean(matched))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC regexp.MustCompile from regexp/regexp.go:
func __mustCompile(str string) Object {
	_res := _regexp.MustCompile(str)
	return MakeGoObject(_res)
}

GO FUNC regexp.MustCompilePOSIX from regexp/regexp.go:
func __mustCompilePOSIX(str string) Object {
	_res := _regexp.MustCompilePOSIX(str)
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package regexp

import (
	_regexp "regexp"
	. "github.com/candid82/joker/core"
)
GO TYPE regexp/syntax.EmptyOp from regexp/syntax/prog.go:
func ExtractGoObjectEmptyOp(args []Object, index int) *_syntax.EmptyOp {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syntax.EmptyOp:
			return &r
		case *_syntax.EmptyOp:
			return r
		}
	case Int:
		v := _syntax.EmptyOp(ExtractUInt8(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[regexp/syntax.EmptyOp]"))
}

func _ConstructEmptyOp(_v Object) _syntax.EmptyOp {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syntax.EmptyOp:
			return _g
		case *_syntax.EmptyOp:
			return *_g
		}
	case Number:
		return _syntax.EmptyOp(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syntax.EmptyOp] or Number"))
}

GO TYPE regexp/syntax.Error from regexp/syntax/parse.go:
func ExtractGoObjectError(args []Object, index int) *_syntax.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syntax.Error:
			return &r
		case *_syntax.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[regexp/syntax.Error]"))
}

func _mapToError(o Map) *_syntax.Error {
	return &_syntax.Error{
	}
}

func _vectorToError(o *Vector) *_syntax.Error {
	return &_syntax.Error{
	}
}

func _ConstructError(_v Object) *_syntax.Error {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syntax.Error:
			return &_g
		case *_syntax.Error:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToError(_o.(Map))
	case case *Vector:
		return _vectorToError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syntax.Error] or Map"))
}

GO TYPE regexp/syntax.ErrorCode from regexp/syntax/parse.go:
func ExtractGoObjectErrorCode(args []Object, index int) *_syntax.ErrorCode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syntax.ErrorCode:
			return &r
		case *_syntax.ErrorCode:
			return r
		}
	case String:
		v := _syntax.ErrorCode(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[regexp/syntax.ErrorCode]"))
}

func _ConstructErrorCode(_v Object) _syntax.ErrorCode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syntax.ErrorCode:
			return _g
		case *_syntax.ErrorCode:
			return *_g
		}
	case String:
		return _syntax.ErrorCode(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syntax.ErrorCode] or String"))
}

GO TYPE regexp/syntax.Flags from regexp/syntax/parse.go:
func ExtractGoObjectFlags(args []Object, index int) *_syntax.Flags {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syntax.Flags:
			return &r
		case *_syntax.Flags:
			return r
		}
	case Int:
		v := _syntax.Flags(ExtractUInt16(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[regexp/syntax.Flags]"))
}

// func _ConstructFlags(_v Object) _syntax.Flags {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syntax.Flags:
// 			return _g
// 		case *_syntax.Flags:
// 			return *_g
// 		}
// 	default:
// 		return _syntax.Flags(_o.ABEND674(unknown underlying type *ast.Ident for Flags))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syntax.Flags] or whatever"))
// }

GO TYPE regexp/syntax.Inst from regexp/syntax/prog.go:
func ExtractGoObjectInst(args []Object, index int) *_syntax.Inst {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syntax.Inst:
			return &r
		case *_syntax.Inst:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[regexp/syntax.Inst]"))
}

func _mapToInst(o Map) *_syntax.Inst {
	return &_syntax.Inst{
	}
}

func _vectorToInst(o *Vector) *_syntax.Inst {
	return &_syntax.Inst{
	}
}

func _ConstructInst(_v Object) *_syntax.Inst {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syntax.Inst:
			return &_g
		case *_syntax.Inst:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToInst(_o.(Map))
	case case *Vector:
		return _vectorToInst(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syntax.Inst] or Map"))
}

GO TYPE regexp/syntax.InstOp from regexp/syntax/prog.go:
func ExtractGoObjectInstOp(args []Object, index int) *_syntax.InstOp {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syntax.InstOp:
			return &r
		case *_syntax.InstOp:
			return r
		}
	case Int:
		v := _syntax.InstOp(ExtractUInt8(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[regexp/syntax.InstOp]"))
}

func _ConstructInstOp(_v Object) _syntax.InstOp {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syntax.InstOp:
			return _g
		case *_syntax.InstOp:
			return *_g
		}
	case Number:
		return _syntax.InstOp(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syntax.InstOp] or Number"))
}

GO TYPE regexp/syntax.Op from regexp/syntax/regexp.go:
func ExtractGoObjectOp(args []Object, index int) *_syntax.Op {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syntax.Op:
			return &r
		case *_syntax.Op:
			return r
		}
	case Int:
		v := _syntax.Op(ExtractUInt8(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[regexp/syntax.Op]"))
}

func _ConstructOp(_v Object) _syntax.Op {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syntax.Op:
			return _g
		case *_syntax.Op:
			return *_g
		}
	case Number:
		return _syntax.Op(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syntax.Op] or Number"))
}

GO TYPE regexp/syntax.Prog from regexp/syntax/prog.go:
func ExtractGoObjectProg(args []Object, index int) *_syntax.Prog {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syntax.Prog:
			return &r
		case *_syntax.Prog:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[regexp/syntax.Prog]"))
}

func _mapToProg(o Map) *_syntax.Prog {
	return &_syntax.Prog{
	}
}

func _vectorToProg(o *Vector) *_syntax.Prog {
	return &_syntax.Prog{
	}
}

func _ConstructProg(_v Object) *_syntax.Prog {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syntax.Prog:
			return &_g
		case *_syntax.Prog:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProg(_o.(Map))
	case case *Vector:
		return _vectorToProg(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syntax.Prog] or Map"))
}

GO TYPE regexp/syntax.Regexp from regexp/syntax/regexp.go:
func ExtractGoObjectRegexp(args []Object, index int) *_syntax.Regexp {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syntax.Regexp:
			return &r
		case *_syntax.Regexp:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[regexp/syntax.Regexp]"))
}

func _mapToRegexp(o Map) *_syntax.Regexp {
	return &_syntax.Regexp{
	}
}

func _vectorToRegexp(o *Vector) *_syntax.Regexp {
	return &_syntax.Regexp{
	}
}

func _ConstructRegexp(_v Object) *_syntax.Regexp {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syntax.Regexp:
			return &_g
		case *_syntax.Regexp:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRegexp(_o.(Map))
	case case *Vector:
		return _vectorToRegexp(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syntax.Regexp] or Map"))
}

GO FUNC regexp/syntax.Compile from regexp/syntax/compile.go:
func __compile(re *_syntax.Regexp) Object {
	_res1, _res2 := _syntax.Compile(re)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC regexp/syntax.EmptyOpContext from regexp/syntax/prog.go:
// func __emptyOpContext(r1 rune, r2 rune) Object {
// 	_res := _syntax.EmptyOpContext(r1, r2)
// 	return MakeGoObject(_res)
// }

GO FUNC regexp/syntax.IsWordChar from regexp/syntax/prog.go:
// func __isWordChar(r rune)  {
// 	_res := _syntax.IsWordChar(r)
// 	return MakeBoolean(_res)
// }

GO FUNC regexp/syntax.Parse from regexp/syntax/parse.go:
func __parse(s string, flags _syntax.Flags) Object {
	_res1, _res2 := _syntax.Parse(s, flags)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package syntax

import (
	_syntax "regexp/syntax"
	. "github.com/candid82/joker/core"
)
GO TYPE runtime.BlockProfileRecord from runtime/mprof.go:
func ExtractGoObjectBlockProfileRecord(args []Object, index int) *_runtime.BlockProfileRecord {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _runtime.BlockProfileRecord:
			return &r
		case *_runtime.BlockProfileRecord:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime.BlockProfileRecord]"))
}

func _mapToBlockProfileRecord(o Map) *_runtime.BlockProfileRecord {
	return &_runtime.BlockProfileRecord{
	}
}

func _vectorToBlockProfileRecord(o *Vector) *_runtime.BlockProfileRecord {
	return &_runtime.BlockProfileRecord{
	}
}

func _ConstructBlockProfileRecord(_v Object) *_runtime.BlockProfileRecord {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _runtime.BlockProfileRecord:
			return &_g
		case *_runtime.BlockProfileRecord:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBlockProfileRecord(_o.(Map))
	case case *Vector:
		return _vectorToBlockProfileRecord(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[runtime.BlockProfileRecord] or Map"))
}

GO TYPE runtime.Error from runtime/error.go:
func ExtractGoObjectError(args []Object, index int) *_runtime.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _runtime.Error:
			return &r
		case *_runtime.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime.Error]"))
}

// func _ConstructError(_v Object) _runtime.Error {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _runtime.Error:
// 			return _g
// 		case *_runtime.Error:
// 			return *_g
// 		}
// 	default:
// 		return _runtime.Error(_o.ABEND674(unknown underlying type *ast.InterfaceType for Error))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[runtime.Error] or whatever"))
// }

GO TYPE runtime.Frame from runtime/symtab.go:
func ExtractGoObjectFrame(args []Object, index int) *_runtime.Frame {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _runtime.Frame:
			return &r
		case *_runtime.Frame:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime.Frame]"))
}

func _mapToFrame(o Map) *_runtime.Frame {
	return &_runtime.Frame{
	}
}

func _vectorToFrame(o *Vector) *_runtime.Frame {
	return &_runtime.Frame{
	}
}

func _ConstructFrame(_v Object) *_runtime.Frame {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _runtime.Frame:
			return &_g
		case *_runtime.Frame:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFrame(_o.(Map))
	case case *Vector:
		return _vectorToFrame(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[runtime.Frame] or Map"))
}

GO TYPE runtime.Frames from runtime/symtab.go:
func ExtractGoObjectFrames(args []Object, index int) *_runtime.Frames {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _runtime.Frames:
			return &r
		case *_runtime.Frames:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime.Frames]"))
}

func _mapToFrames(o Map) *_runtime.Frames {
	return &_runtime.Frames{
	}
}

func _vectorToFrames(o *Vector) *_runtime.Frames {
	return &_runtime.Frames{
	}
}

func _ConstructFrames(_v Object) *_runtime.Frames {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _runtime.Frames:
			return &_g
		case *_runtime.Frames:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFrames(_o.(Map))
	case case *Vector:
		return _vectorToFrames(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[runtime.Frames] or Map"))
}

GO TYPE runtime.Func from runtime/symtab.go:
func ExtractGoObjectFunc(args []Object, index int) *_runtime.Func {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _runtime.Func:
			return &r
		case *_runtime.Func:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime.Func]"))
}

func _mapToFunc(o Map) *_runtime.Func {
	return &_runtime.Func{
	}
}

func _vectorToFunc(o *Vector) *_runtime.Func {
	return &_runtime.Func{
	}
}

func _ConstructFunc(_v Object) *_runtime.Func {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _runtime.Func:
			return &_g
		case *_runtime.Func:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFunc(_o.(Map))
	case case *Vector:
		return _vectorToFunc(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[runtime.Func] or Map"))
}

GO TYPE runtime.MemProfileRecord from runtime/mprof.go:
func ExtractGoObjectMemProfileRecord(args []Object, index int) *_runtime.MemProfileRecord {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _runtime.MemProfileRecord:
			return &r
		case *_runtime.MemProfileRecord:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime.MemProfileRecord]"))
}

func _mapToMemProfileRecord(o Map) *_runtime.MemProfileRecord {
	return &_runtime.MemProfileRecord{
	}
}

func _vectorToMemProfileRecord(o *Vector) *_runtime.MemProfileRecord {
	return &_runtime.MemProfileRecord{
	}
}

func _ConstructMemProfileRecord(_v Object) *_runtime.MemProfileRecord {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _runtime.MemProfileRecord:
			return &_g
		case *_runtime.MemProfileRecord:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMemProfileRecord(_o.(Map))
	case case *Vector:
		return _vectorToMemProfileRecord(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[runtime.MemProfileRecord] or Map"))
}

GO TYPE runtime.MemStats from runtime/mstats.go:
func ExtractGoObjectMemStats(args []Object, index int) *_runtime.MemStats {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _runtime.MemStats:
			return &r
		case *_runtime.MemStats:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime.MemStats]"))
}

func _mapToMemStats(o Map) *_runtime.MemStats {
	return &_runtime.MemStats{
	}
}

func _vectorToMemStats(o *Vector) *_runtime.MemStats {
	return &_runtime.MemStats{
	}
}

func _ConstructMemStats(_v Object) *_runtime.MemStats {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _runtime.MemStats:
			return &_g
		case *_runtime.MemStats:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMemStats(_o.(Map))
	case case *Vector:
		return _vectorToMemStats(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[runtime.MemStats] or Map"))
}

GO TYPE runtime.StackRecord from runtime/mprof.go:
func ExtractGoObjectStackRecord(args []Object, index int) *_runtime.StackRecord {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _runtime.StackRecord:
			return &r
		case *_runtime.StackRecord:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime.StackRecord]"))
}

func _mapToStackRecord(o Map) *_runtime.StackRecord {
	return &_runtime.StackRecord{
	}
}

func _vectorToStackRecord(o *Vector) *_runtime.StackRecord {
	return &_runtime.StackRecord{
	}
}

func _ConstructStackRecord(_v Object) *_runtime.StackRecord {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _runtime.StackRecord:
			return &_g
		case *_runtime.StackRecord:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToStackRecord(_o.(Map))
	case case *Vector:
		return _vectorToStackRecord(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[runtime.StackRecord] or Map"))
}

GO TYPE runtime.TypeAssertionError from runtime/error.go:
func ExtractGoObjectTypeAssertionError(args []Object, index int) *_runtime.TypeAssertionError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _runtime.TypeAssertionError:
			return &r
		case *_runtime.TypeAssertionError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime.TypeAssertionError]"))
}

func _mapToTypeAssertionError(o Map) *_runtime.TypeAssertionError {
	return &_runtime.TypeAssertionError{
	}
}

func _vectorToTypeAssertionError(o *Vector) *_runtime.TypeAssertionError {
	return &_runtime.TypeAssertionError{
	}
}

func _ConstructTypeAssertionError(_v Object) *_runtime.TypeAssertionError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _runtime.TypeAssertionError:
			return &_g
		case *_runtime.TypeAssertionError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTypeAssertionError(_o.(Map))
	case case *Vector:
		return _vectorToTypeAssertionError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[runtime.TypeAssertionError] or Map"))
}

GO FUNC runtime.BlockProfile from runtime/mprof.go:
// func __blockProfile(p []_runtime.BlockProfileRecord) Object {
// 	n, ok := _runtime.BlockProfile(p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeBoolean(ok))
// 	return _res
// }

GO FUNC runtime.Breakpoint from runtime/proc.go:
// func __breakpoint() Object {
// 	_runtime.Breakpoint()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.CPUProfile from runtime/cpuprof.go:
func __cPUProfile() Object {
	_res := _runtime.CPUProfile()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC runtime.Caller from runtime/extern.go:
func __caller(skip int) Object {
	pc, file, line, ok := _runtime.Caller(skip)
	_res := EmptyVector
	_res = _res.Conjoin(MakeBigInt(uint64(pc)))
	_res = _res.Conjoin(MakeString(file))
	_res = _res.Conjoin(MakeInt(line))
	_res = _res.Conjoin(MakeBoolean(ok))
	return _res
}

GO FUNC runtime.Callers from runtime/extern.go:
// func __callers(skip int, pc []uintptr)  {
// 	_res := _runtime.Callers(skip, pc)
// 	return MakeInt(_res)
// }

GO FUNC runtime.CallersFrames from runtime/symtab.go:
// func __callersFrames(callers []uintptr) Object {
// 	_res := _runtime.CallersFrames(callers)
// 	return MakeGoObject(_res)
// }

GO FUNC runtime.FuncForPC from runtime/symtab.go:
func __funcForPC(pc uintptr) Object {
	_res := _runtime.FuncForPC(pc)
	return MakeGoObject(_res)
}

GO FUNC runtime.GC from runtime/mgc.go:
// func __gC() Object {
// 	_runtime.GC()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.Goexit from runtime/panic.go:
// func __goexit() Object {
// 	_runtime.Goexit()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.GoroutineProfile from runtime/mprof.go:
// func __goroutineProfile(p []_runtime.StackRecord) Object {
// 	n, ok := _runtime.GoroutineProfile(p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeBoolean(ok))
// 	return _res
// }

GO FUNC runtime.Gosched from runtime/proc.go:
// func __gosched() Object {
// 	_runtime.Gosched()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.KeepAlive from runtime/mfinal.go:
// func __keepAlive(x interface {}) Object {
// 	_runtime.KeepAlive(x)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.LockOSThread from runtime/proc.go:
// func __lockOSThread() Object {
// 	_runtime.LockOSThread()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.MemProfile from runtime/mprof.go:
// func __memProfile(p []_runtime.MemProfileRecord, inuseZero bool) Object {
// 	n, ok := _runtime.MemProfile(p, inuseZero)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeBoolean(ok))
// 	return _res
// }

GO FUNC runtime.MutexProfile from runtime/mprof.go:
// func __mutexProfile(p []_runtime.BlockProfileRecord) Object {
// 	n, ok := _runtime.MutexProfile(p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeBoolean(ok))
// 	return _res
// }

GO FUNC runtime.NumCgoCall from runtime/debug.go:
func __numCgoCall() Object {
	_res := _runtime.NumCgoCall()
	return MakeInt(int(_res))
}

GO FUNC runtime.ReadMemStats from runtime/mstats.go:
// func __readMemStats(m *_runtime.MemStats) Object {
// 	_runtime.ReadMemStats(m)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.ReadTrace from runtime/trace.go:
func __readTrace() Object {
	_res := _runtime.ReadTrace()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC runtime.SetBlockProfileRate from runtime/mprof.go:
// func __setBlockProfileRate(rate int) Object {
// 	_runtime.SetBlockProfileRate(rate)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.SetCPUProfileRate from runtime/cpuprof.go:
// func __setCPUProfileRate(hz int) Object {
// 	_runtime.SetCPUProfileRate(hz)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.SetCgoTraceback from runtime/traceback.go:
// func __setCgoTraceback(version int, traceback ABEND987(genutils.go: imports not yet supported: unsafe.Pointer), context ABEND987(genutils.go: imports not yet supported: unsafe.Pointer), symbolizer ABEND987(genutils.go: imports not yet supported: unsafe.Pointer)) Object {
// 	_runtime.SetCgoTraceback(version, traceback, context, symbolizer)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.SetFinalizer from runtime/mfinal.go:
// func __setFinalizer(obj interface {}, finalizer interface {}) Object {
// 	_runtime.SetFinalizer(obj, finalizer)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.Stack from runtime/mprof.go:
// func __stack(buf []byte, all bool)  {
// 	_res := _runtime.Stack(buf, all)
// 	return MakeInt(_res)
// }

GO FUNC runtime.StopTrace from runtime/trace.go:
// func __stopTrace() Object {
// 	_runtime.StopTrace()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.ThreadCreateProfile from runtime/mprof.go:
// func __threadCreateProfile(p []_runtime.StackRecord) Object {
// 	n, ok := _runtime.ThreadCreateProfile(p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeBoolean(ok))
// 	return _res
// }

GO FUNC runtime.UnlockOSThread from runtime/proc.go:
// func __unlockOSThread() Object {
// 	_runtime.UnlockOSThread()
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package runtime

import (
	_runtime "runtime"
	. "github.com/candid82/joker/core"
)
GO TYPE runtime/debug.GCStats from runtime/debug/garbage.go:
func ExtractGoObjectGCStats(args []Object, index int) *_debug.GCStats {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _debug.GCStats:
			return &r
		case *_debug.GCStats:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime/debug.GCStats]"))
}

func _mapToGCStats(o Map) *_debug.GCStats {
	return &_debug.GCStats{
	}
}

func _vectorToGCStats(o *Vector) *_debug.GCStats {
	return &_debug.GCStats{
	}
}

func _ConstructGCStats(_v Object) *_debug.GCStats {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _debug.GCStats:
			return &_g
		case *_debug.GCStats:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToGCStats(_o.(Map))
	case case *Vector:
		return _vectorToGCStats(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[debug.GCStats] or Map"))
}

GO FUNC runtime/debug.FreeOSMemory from runtime/debug/garbage.go:
// func __freeOSMemory() Object {
// 	_debug.FreeOSMemory()
// 	...ABEND675: TODO...
// }

GO FUNC runtime/debug.PrintStack from runtime/debug/stack.go:
// func __printStack() Object {
// 	_debug.PrintStack()
// 	...ABEND675: TODO...
// }

GO FUNC runtime/debug.ReadGCStats from runtime/debug/garbage.go:
// func __readGCStats(stats *_debug.GCStats) Object {
// 	_debug.ReadGCStats(stats)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/debug.SetTraceback from runtime/debug/garbage.go:
// func __setTraceback(level string) Object {
// 	_debug.SetTraceback(level)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/debug.Stack from runtime/debug/stack.go:
func __stack() Object {
	_res := _debug.Stack()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC runtime/debug.WriteHeapDump from runtime/debug/garbage.go:
// func __writeHeapDump(fd uintptr) Object {
// 	_debug.WriteHeapDump(fd)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package debug

import (
	_debug "runtime/debug"
	. "github.com/candid82/joker/core"
)
GO TYPE runtime/pprof.LabelSet from runtime/pprof/label.go:
func ExtractGoObjectLabelSet(args []Object, index int) *_pprof.LabelSet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pprof.LabelSet:
			return &r
		case *_pprof.LabelSet:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime/pprof.LabelSet]"))
}

func _mapToLabelSet(o Map) *_pprof.LabelSet {
	return &_pprof.LabelSet{
	}
}

func _vectorToLabelSet(o *Vector) *_pprof.LabelSet {
	return &_pprof.LabelSet{
	}
}

func _ConstructLabelSet(_v Object) *_pprof.LabelSet {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pprof.LabelSet:
			return &_g
		case *_pprof.LabelSet:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToLabelSet(_o.(Map))
	case case *Vector:
		return _vectorToLabelSet(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pprof.LabelSet] or Map"))
}

GO TYPE runtime/pprof.Profile from runtime/pprof/pprof.go:
func ExtractGoObjectProfile(args []Object, index int) *_pprof.Profile {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pprof.Profile:
			return &r
		case *_pprof.Profile:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime/pprof.Profile]"))
}

func _mapToProfile(o Map) *_pprof.Profile {
	return &_pprof.Profile{
	}
}

func _vectorToProfile(o *Vector) *_pprof.Profile {
	return &_pprof.Profile{
	}
}

func _ConstructProfile(_v Object) *_pprof.Profile {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pprof.Profile:
			return &_g
		case *_pprof.Profile:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProfile(_o.(Map))
	case case *Vector:
		return _vectorToProfile(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pprof.Profile] or Map"))
}

GO FUNC runtime/pprof.Do from runtime/pprof/runtime.go:
// func __do(ctx ABEND987(genutils.go: imports not yet supported: context.Context), labels _pprof.LabelSet, f func) Object {
// 	_pprof.Do(ctx, labels, f)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/pprof.ForLabels from runtime/pprof/label.go:
// func __forLabels(ctx ABEND987(genutils.go: imports not yet supported: context.Context), f func) Object {
// 	_pprof.ForLabels(ctx, f)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/pprof.Label from runtime/pprof/label.go:
// func __label(ctx ABEND987(genutils.go: imports not yet supported: context.Context), key string) Object {
// 	_res1, _res2 := _pprof.Label(ctx, key)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeString(_res1))
// 	_res = _res.Conjoin(MakeBoolean(_res2))
// 	return _res
// }

GO FUNC runtime/pprof.Labels from runtime/pprof/label.go:
// func __labels(args ...string) Object {
// 	_res := _pprof.Labels(args)
// 	return MakeGoObject(_res)
// }

GO FUNC runtime/pprof.Lookup from runtime/pprof/pprof.go:
func __lookup(name string) Object {
	_res := _pprof.Lookup(name)
	return MakeGoObject(_res)
}

GO FUNC runtime/pprof.NewProfile from runtime/pprof/pprof.go:
func __newProfile(name string) Object {
	_res := _pprof.NewProfile(name)
	return MakeGoObject(_res)
}

GO FUNC runtime/pprof.Profiles from runtime/pprof/pprof.go:
func __profiles() Object {
	_res := _pprof.Profiles()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	return _vec1
}

GO FUNC runtime/pprof.SetGoroutineLabels from runtime/pprof/runtime.go:
// func __setGoroutineLabels(ctx ABEND987(genutils.go: imports not yet supported: context.Context)) Object {
// 	_pprof.SetGoroutineLabels(ctx)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/pprof.StartCPUProfile from runtime/pprof/pprof.go:
// func __startCPUProfile(w ABEND987(genutils.go: imports not yet supported: io.Writer))  {
// 	_res := _pprof.StartCPUProfile(w)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC runtime/pprof.StopCPUProfile from runtime/pprof/pprof.go:
// func __stopCPUProfile() Object {
// 	_pprof.StopCPUProfile()
// 	...ABEND675: TODO...
// }

GO FUNC runtime/pprof.WithLabels from runtime/pprof/label.go:
// func __withLabels(ctx ABEND987(genutils.go: imports not yet supported: context.Context), labels _pprof.LabelSet) Object {
// 	_res := _pprof.WithLabels(ctx, labels)
// 	return MakeGoObject(_res)
// }

GO FUNC runtime/pprof.WriteHeapProfile from runtime/pprof/pprof.go:
// func __writeHeapProfile(w ABEND987(genutils.go: imports not yet supported: io.Writer))  {
// 	_res := _pprof.WriteHeapProfile(w)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package pprof

import (
	_pprof "runtime/pprof"
	. "github.com/candid82/joker/core"
)
GO TYPE runtime/trace.Region from runtime/trace/annotation.go:
func ExtractGoObjectRegion(args []Object, index int) *_trace.Region {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _trace.Region:
			return &r
		case *_trace.Region:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime/trace.Region]"))
}

func _mapToRegion(o Map) *_trace.Region {
	return &_trace.Region{
	}
}

func _vectorToRegion(o *Vector) *_trace.Region {
	return &_trace.Region{
	}
}

func _ConstructRegion(_v Object) *_trace.Region {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _trace.Region:
			return &_g
		case *_trace.Region:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRegion(_o.(Map))
	case case *Vector:
		return _vectorToRegion(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[trace.Region] or Map"))
}

GO TYPE runtime/trace.Task from runtime/trace/annotation.go:
func ExtractGoObjectTask(args []Object, index int) *_trace.Task {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _trace.Task:
			return &r
		case *_trace.Task:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime/trace.Task]"))
}

func _mapToTask(o Map) *_trace.Task {
	return &_trace.Task{
	}
}

func _vectorToTask(o *Vector) *_trace.Task {
	return &_trace.Task{
	}
}

func _ConstructTask(_v Object) *_trace.Task {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _trace.Task:
			return &_g
		case *_trace.Task:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTask(_o.(Map))
	case case *Vector:
		return _vectorToTask(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[trace.Task] or Map"))
}

GO FUNC runtime/trace.Log from runtime/trace/annotation.go:
// func __log(ctx ABEND987(genutils.go: imports not yet supported: context.Context), category string, message string) Object {
// 	_trace.Log(ctx, category, message)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/trace.Logf from runtime/trace/annotation.go:
// func __logf(ctx ABEND987(genutils.go: imports not yet supported: context.Context), category string, format string, args ...interface {}) Object {
// 	_trace.Logf(ctx, category, format, args)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/trace.NewTask from runtime/trace/annotation.go:
// func __newTask(pctx ABEND987(genutils.go: imports not yet supported: context.Context), taskType string) Object {
// 	ctx, task := _trace.NewTask(pctx, taskType)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(ctx))
// 	_res = _res.Conjoin(MakeGoObject(task))
// 	return _res
// }

GO FUNC runtime/trace.Start from runtime/trace/trace.go:
// func __start(w ABEND987(genutils.go: imports not yet supported: io.Writer))  {
// 	_res := _trace.Start(w)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC runtime/trace.StartRegion from runtime/trace/annotation.go:
// func __startRegion(ctx ABEND987(genutils.go: imports not yet supported: context.Context), regionType string) Object {
// 	_res := _trace.StartRegion(ctx, regionType)
// 	return MakeGoObject(_res)
// }

GO FUNC runtime/trace.Stop from runtime/trace/trace.go:
// func __stop() Object {
// 	_trace.Stop()
// 	...ABEND675: TODO...
// }

GO FUNC runtime/trace.WithRegion from runtime/trace/annotation.go:
// func __withRegion(ctx ABEND987(genutils.go: imports not yet supported: context.Context), regionType string, fn func) Object {
// 	_trace.WithRegion(ctx, regionType, fn)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package trace

import (
	_trace "runtime/trace"
	. "github.com/candid82/joker/core"
)
GO TYPE sort.Float64Slice from sort/sort.go:
func ExtractGoObjectFloat64Slice(args []Object, index int) *_sort.Float64Slice {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sort.Float64Slice:
			return &r
		case *_sort.Float64Slice:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sort.Float64Slice]"))
}

// func _ConstructFloat64Slice(_v Object) _sort.Float64Slice {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _sort.Float64Slice:
// 			return _g
// 		case *_sort.Float64Slice:
// 			return *_g
// 		}
// 	default:
// 		return _sort.Float64Slice(_o.ABEND674(unknown underlying type *ast.ArrayType for Float64Slice))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[sort.Float64Slice] or whatever"))
// }

GO TYPE sort.IntSlice from sort/sort.go:
func ExtractGoObjectIntSlice(args []Object, index int) *_sort.IntSlice {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sort.IntSlice:
			return &r
		case *_sort.IntSlice:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sort.IntSlice]"))
}

// func _ConstructIntSlice(_v Object) _sort.IntSlice {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _sort.IntSlice:
// 			return _g
// 		case *_sort.IntSlice:
// 			return *_g
// 		}
// 	default:
// 		return _sort.IntSlice(_o.ABEND674(unknown underlying type *ast.ArrayType for IntSlice))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[sort.IntSlice] or whatever"))
// }

GO TYPE sort.Interface from sort/sort.go:
func ExtractGoObjectInterface(args []Object, index int) *_sort.Interface {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sort.Interface:
			return &r
		case *_sort.Interface:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sort.Interface]"))
}

// func _ConstructInterface(_v Object) _sort.Interface {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _sort.Interface:
// 			return _g
// 		case *_sort.Interface:
// 			return *_g
// 		}
// 	default:
// 		return _sort.Interface(_o.ABEND674(unknown underlying type *ast.InterfaceType for Interface))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[sort.Interface] or whatever"))
// }

GO TYPE sort.StringSlice from sort/sort.go:
func ExtractGoObjectStringSlice(args []Object, index int) *_sort.StringSlice {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sort.StringSlice:
			return &r
		case *_sort.StringSlice:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sort.StringSlice]"))
}

// func _ConstructStringSlice(_v Object) _sort.StringSlice {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _sort.StringSlice:
// 			return _g
// 		case *_sort.StringSlice:
// 			return *_g
// 		}
// 	default:
// 		return _sort.StringSlice(_o.ABEND674(unknown underlying type *ast.ArrayType for StringSlice))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[sort.StringSlice] or whatever"))
// }

GO FUNC sort.Float64s from sort/sort.go:
// func __float64s(a []float64) Object {
// 	_sort.Float64s(a)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Float64sAreSorted from sort/sort.go:
// func __float64sAreSorted(a []float64)  {
// 	_res := _sort.Float64sAreSorted(a)
// 	return MakeBoolean(_res)
// }

GO FUNC sort.Ints from sort/sort.go:
// func __ints(a []int) Object {
// 	_sort.Ints(a)
// 	...ABEND675: TODO...
// }

GO FUNC sort.IntsAreSorted from sort/sort.go:
// func __intsAreSorted(a []int)  {
// 	_res := _sort.IntsAreSorted(a)
// 	return MakeBoolean(_res)
// }

GO FUNC sort.Reverse from sort/sort.go:
func __reverse(data _sort.Interface) Object {
	_res := _sort.Reverse(data)
	return MakeGoObject(_res)
}

GO FUNC sort.Search from sort/search.go:
// func __search(n int, f func)  {
// 	_res := _sort.Search(n, f)
// 	return MakeInt(_res)
// }

GO FUNC sort.SearchFloat64s from sort/search.go:
// func __searchFloat64s(a []float64, x float64)  {
// 	_res := _sort.SearchFloat64s(a, x)
// 	return MakeInt(_res)
// }

GO FUNC sort.SearchInts from sort/search.go:
// func __searchInts(a []int, x int)  {
// 	_res := _sort.SearchInts(a, x)
// 	return MakeInt(_res)
// }

GO FUNC sort.SearchStrings from sort/search.go:
// func __searchStrings(a []string, x string)  {
// 	_res := _sort.SearchStrings(a, x)
// 	return MakeInt(_res)
// }

GO FUNC sort.Slice from sort/slice.go:
// func __slice(slice interface {}, less func) Object {
// 	_sort.Slice(slice, less)
// 	...ABEND675: TODO...
// }

GO FUNC sort.SliceIsSorted from sort/slice.go:
// func __sliceIsSorted(slice interface {}, less func)  {
// 	_res := _sort.SliceIsSorted(slice, less)
// 	return MakeBoolean(_res)
// }

GO FUNC sort.SliceStable from sort/slice.go:
// func __sliceStable(slice interface {}, less func) Object {
// 	_sort.SliceStable(slice, less)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Sort from sort/sort.go:
// func __sort(data _sort.Interface) Object {
// 	_sort.Sort(data)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Stable from sort/sort.go:
// func __stable(data _sort.Interface) Object {
// 	_sort.Stable(data)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Strings from sort/sort.go:
// func __strings(a []string) Object {
// 	_sort.Strings(a)
// 	...ABEND675: TODO...
// }

GO FUNC sort.StringsAreSorted from sort/sort.go:
// func __stringsAreSorted(a []string)  {
// 	_res := _sort.StringsAreSorted(a)
// 	return MakeBoolean(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package sort

import (
	_sort "sort"
	. "github.com/candid82/joker/core"
)
GO TYPE strconv.NumError from strconv/atoi.go:
func ExtractGoObjectNumError(args []Object, index int) *_strconv.NumError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _strconv.NumError:
			return &r
		case *_strconv.NumError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[strconv.NumError]"))
}

func _mapToNumError(o Map) *_strconv.NumError {
	return &_strconv.NumError{
	}
}

func _vectorToNumError(o *Vector) *_strconv.NumError {
	return &_strconv.NumError{
	}
}

func _ConstructNumError(_v Object) *_strconv.NumError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _strconv.NumError:
			return &_g
		case *_strconv.NumError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNumError(_o.(Map))
	case case *Vector:
		return _vectorToNumError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[strconv.NumError] or Map"))
}

GO FUNC strconv.AppendBool from strconv/atob.go:
// func __appendBool(dst []byte, b bool) Object {
// 	_res := _strconv.AppendBool(dst, b)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendFloat from strconv/ftoa.go:
// func __appendFloat(dst []byte, f float64, fmt byte, prec int, bitSize int) Object {
// 	_res := _strconv.AppendFloat(dst, f, fmt, prec, bitSize)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendInt from strconv/itoa.go:
// func __appendInt(dst []byte, i int64, base int) Object {
// 	_res := _strconv.AppendInt(dst, i, base)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendQuote from strconv/quote.go:
// func __appendQuote(dst []byte, s string) Object {
// 	_res := _strconv.AppendQuote(dst, s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendQuoteRune from strconv/quote.go:
// func __appendQuoteRune(dst []byte, r rune) Object {
// 	_res := _strconv.AppendQuoteRune(dst, r)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendQuoteRuneToASCII from strconv/quote.go:
// func __appendQuoteRuneToASCII(dst []byte, r rune) Object {
// 	_res := _strconv.AppendQuoteRuneToASCII(dst, r)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendQuoteRuneToGraphic from strconv/quote.go:
// func __appendQuoteRuneToGraphic(dst []byte, r rune) Object {
// 	_res := _strconv.AppendQuoteRuneToGraphic(dst, r)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendQuoteToASCII from strconv/quote.go:
// func __appendQuoteToASCII(dst []byte, s string) Object {
// 	_res := _strconv.AppendQuoteToASCII(dst, s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendQuoteToGraphic from strconv/quote.go:
// func __appendQuoteToGraphic(dst []byte, s string) Object {
// 	_res := _strconv.AppendQuoteToGraphic(dst, s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendUint from strconv/itoa.go:
// func __appendUint(dst []byte, i uint64, base int) Object {
// 	_res := _strconv.AppendUint(dst, i, base)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.Atoi from strconv/atoi.go:
func __atoi(s string) Object {
	_res1, _res2 := _strconv.Atoi(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC strconv.FormatFloat from strconv/ftoa.go:
// func __formatFloat(f float64, fmt byte, prec int, bitSize int)  {
// 	_res := _strconv.FormatFloat(f, fmt, prec, bitSize)
// 	return MakeString(_res)
// }

GO FUNC strconv.FormatUint from strconv/itoa.go:
// func __formatUint(i uint64, base int)  {
// 	_res := _strconv.FormatUint(i, base)
// 	return MakeString(_res)
// }

GO FUNC strconv.IsGraphic from strconv/quote.go:
// func __isGraphic(r rune)  {
// 	_res := _strconv.IsGraphic(r)
// 	return MakeBoolean(_res)
// }

GO FUNC strconv.IsPrint from strconv/quote.go:
// func __isPrint(r rune)  {
// 	_res := _strconv.IsPrint(r)
// 	return MakeBoolean(_res)
// }

GO FUNC strconv.ParseBool from strconv/atob.go:
func __parseBool(str string) Object {
	_res1, _res2 := _strconv.ParseBool(str)
	_res := EmptyVector
	_res = _res.Conjoin(MakeBoolean(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC strconv.ParseFloat from strconv/atof.go:
// func __parseFloat(s string, bitSize int) Object {
// 	_res1, _res2 := _strconv.ParseFloat(s, bitSize)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC strconv.ParseInt from strconv/atoi.go:
func __parseInt(s string, base int, bitSize int) Object {
	i, err := _strconv.ParseInt(s, base, bitSize)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(int(i)))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC strconv.ParseUint from strconv/atoi.go:
func __parseUint(s string, base int, bitSize int) Object {
	_res1, _res2 := _strconv.ParseUint(s, base, bitSize)
	_res := EmptyVector
	_res = _res.Conjoin(MakeBigInt(uint64(_res1)))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC strconv.QuoteRune from strconv/quote.go:
// func __quoteRune(r rune)  {
// 	_res := _strconv.QuoteRune(r)
// 	return MakeString(_res)
// }

GO FUNC strconv.QuoteRuneToASCII from strconv/quote.go:
// func __quoteRuneToASCII(r rune)  {
// 	_res := _strconv.QuoteRuneToASCII(r)
// 	return MakeString(_res)
// }

GO FUNC strconv.QuoteRuneToGraphic from strconv/quote.go:
// func __quoteRuneToGraphic(r rune)  {
// 	_res := _strconv.QuoteRuneToGraphic(r)
// 	return MakeString(_res)
// }

GO FUNC strconv.Unquote from strconv/quote.go:
func __unquote(s string) Object {
	_res1, _res2 := _strconv.Unquote(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC strconv.UnquoteChar from strconv/quote.go:
// func __unquoteChar(s string, quote byte) Object {
// 	value, multibyte, tail, err := _strconv.UnquoteChar(s, quote)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(value)
// 	_res = _res.Conjoin(MakeBoolean(multibyte))
// 	_res = _res.Conjoin(MakeString(tail))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package strconv

import (
	_strconv "strconv"
	. "github.com/candid82/joker/core"
)
GO TYPE strings.Builder from strings/builder.go:
func ExtractGoObjectBuilder(args []Object, index int) *_strings.Builder {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _strings.Builder:
			return &r
		case *_strings.Builder:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[strings.Builder]"))
}

func _mapToBuilder(o Map) *_strings.Builder {
	return &_strings.Builder{
	}
}

func _vectorToBuilder(o *Vector) *_strings.Builder {
	return &_strings.Builder{
	}
}

func _ConstructBuilder(_v Object) *_strings.Builder {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _strings.Builder:
			return &_g
		case *_strings.Builder:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBuilder(_o.(Map))
	case case *Vector:
		return _vectorToBuilder(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[strings.Builder] or Map"))
}

GO TYPE strings.Reader from strings/reader.go:
func ExtractGoObjectReader(args []Object, index int) *_strings.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _strings.Reader:
			return &r
		case *_strings.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[strings.Reader]"))
}

func _mapToReader(o Map) *_strings.Reader {
	return &_strings.Reader{
	}
}

func _vectorToReader(o *Vector) *_strings.Reader {
	return &_strings.Reader{
	}
}

func _ConstructReader(_v Object) *_strings.Reader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _strings.Reader:
			return &_g
		case *_strings.Reader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReader(_o.(Map))
	case case *Vector:
		return _vectorToReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[strings.Reader] or Map"))
}

GO TYPE strings.Replacer from strings/replace.go:
func ExtractGoObjectReplacer(args []Object, index int) *_strings.Replacer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _strings.Replacer:
			return &r
		case *_strings.Replacer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[strings.Replacer]"))
}

func _mapToReplacer(o Map) *_strings.Replacer {
	return &_strings.Replacer{
	}
}

func _vectorToReplacer(o *Vector) *_strings.Replacer {
	return &_strings.Replacer{
	}
}

func _ConstructReplacer(_v Object) *_strings.Replacer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _strings.Replacer:
			return &_g
		case *_strings.Replacer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReplacer(_o.(Map))
	case case *Vector:
		return _vectorToReplacer(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[strings.Replacer] or Map"))
}

GO FUNC strings.ContainsRune from strings/strings.go:
// func __containsRune(s string, r rune)  {
// 	_res := _strings.ContainsRune(s, r)
// 	return MakeBoolean(_res)
// }

GO FUNC strings.Fields from strings/strings.go:
func __fields(s string) Object {
	_res := _strings.Fields(s)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC strings.FieldsFunc from strings/strings.go:
// func __fieldsFunc(s string, f func) Object {
// 	_res := _strings.FieldsFunc(s, f)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeString(_elem1))
// 	}
// 	return _vec1
// }

GO FUNC strings.IndexFunc from strings/strings.go:
// func __indexFunc(s string, f func)  {
// 	_res := _strings.IndexFunc(s, f)
// 	return MakeInt(_res)
// }

GO FUNC strings.IndexRune from strings/strings.go:
// func __indexRune(s string, r rune)  {
// 	_res := _strings.IndexRune(s, r)
// 	return MakeInt(_res)
// }

GO FUNC strings.Join from strings/strings.go:
// func __join(a []string, sep string)  {
// 	_res := _strings.Join(a, sep)
// 	return MakeString(_res)
// }

GO FUNC strings.LastIndexFunc from strings/strings.go:
// func __lastIndexFunc(s string, f func)  {
// 	_res := _strings.LastIndexFunc(s, f)
// 	return MakeInt(_res)
// }

GO FUNC strings.Map from strings/strings.go:
// func __map(mapping func, s string)  {
// 	_res := _strings.Map(mapping, s)
// 	return MakeString(_res)
// }

GO FUNC strings.NewReader from strings/reader.go:
func __newReader(s string) Object {
	_res := _strings.NewReader(s)
	return MakeGoObject(_res)
}

GO FUNC strings.NewReplacer from strings/replace.go:
// func __newReplacer(oldnew ...string) Object {
// 	_res := _strings.NewReplacer(oldnew)
// 	return MakeGoObject(_res)
// }

GO FUNC strings.Split from strings/strings.go:
func __split(s string, sep string) Object {
	_res := _strings.Split(s, sep)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC strings.SplitAfter from strings/strings.go:
func __splitAfter(s string, sep string) Object {
	_res := _strings.SplitAfter(s, sep)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC strings.SplitAfterN from strings/strings.go:
func __splitAfterN(s string, sep string, n int) Object {
	_res := _strings.SplitAfterN(s, sep, n)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC strings.SplitN from strings/strings.go:
func __splitN(s string, sep string, n int) Object {
	_res := _strings.SplitN(s, sep, n)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC strings.ToLowerSpecial from strings/strings.go:
// func __toLowerSpecial(c ABEND987(genutils.go: imports not yet supported: unicode.SpecialCase), s string)  {
// 	_res := _strings.ToLowerSpecial(c, s)
// 	return MakeString(_res)
// }

GO FUNC strings.ToTitleSpecial from strings/strings.go:
// func __toTitleSpecial(c ABEND987(genutils.go: imports not yet supported: unicode.SpecialCase), s string)  {
// 	_res := _strings.ToTitleSpecial(c, s)
// 	return MakeString(_res)
// }

GO FUNC strings.ToUpperSpecial from strings/strings.go:
// func __toUpperSpecial(c ABEND987(genutils.go: imports not yet supported: unicode.SpecialCase), s string)  {
// 	_res := _strings.ToUpperSpecial(c, s)
// 	return MakeString(_res)
// }

GO FUNC strings.TrimFunc from strings/strings.go:
// func __trimFunc(s string, f func)  {
// 	_res := _strings.TrimFunc(s, f)
// 	return MakeString(_res)
// }

GO FUNC strings.TrimLeftFunc from strings/strings.go:
// func __trimLeftFunc(s string, f func)  {
// 	_res := _strings.TrimLeftFunc(s, f)
// 	return MakeString(_res)
// }

GO FUNC strings.TrimRightFunc from strings/strings.go:
// func __trimRightFunc(s string, f func)  {
// 	_res := _strings.TrimRightFunc(s, f)
// 	return MakeString(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package strings

import (
	_strings "strings"
	. "github.com/candid82/joker/core"
)
GO TYPE sync.Cond from sync/cond.go:
func ExtractGoObjectCond(args []Object, index int) *_sync.Cond {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sync.Cond:
			return &r
		case *_sync.Cond:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sync.Cond]"))
}

func _mapToCond(o Map) *_sync.Cond {
	return &_sync.Cond{
	}
}

func _vectorToCond(o *Vector) *_sync.Cond {
	return &_sync.Cond{
	}
}

func _ConstructCond(_v Object) *_sync.Cond {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sync.Cond:
			return &_g
		case *_sync.Cond:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCond(_o.(Map))
	case case *Vector:
		return _vectorToCond(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sync.Cond] or Map"))
}

GO TYPE sync.Locker from sync/mutex.go:
func ExtractGoObjectLocker(args []Object, index int) *_sync.Locker {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sync.Locker:
			return &r
		case *_sync.Locker:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sync.Locker]"))
}

// func _ConstructLocker(_v Object) _sync.Locker {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _sync.Locker:
// 			return _g
// 		case *_sync.Locker:
// 			return *_g
// 		}
// 	default:
// 		return _sync.Locker(_o.ABEND674(unknown underlying type *ast.InterfaceType for Locker))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[sync.Locker] or whatever"))
// }

GO TYPE sync.Map from sync/map.go:
func ExtractGoObjectMap(args []Object, index int) *_sync.Map {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sync.Map:
			return &r
		case *_sync.Map:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sync.Map]"))
}

func _mapToMap(o Map) *_sync.Map {
	return &_sync.Map{
	}
}

func _vectorToMap(o *Vector) *_sync.Map {
	return &_sync.Map{
	}
}

func _ConstructMap(_v Object) *_sync.Map {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sync.Map:
			return &_g
		case *_sync.Map:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMap(_o.(Map))
	case case *Vector:
		return _vectorToMap(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sync.Map] or Map"))
}

GO TYPE sync.Mutex from sync/mutex.go:
func ExtractGoObjectMutex(args []Object, index int) *_sync.Mutex {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sync.Mutex:
			return &r
		case *_sync.Mutex:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sync.Mutex]"))
}

func _mapToMutex(o Map) *_sync.Mutex {
	return &_sync.Mutex{
	}
}

func _vectorToMutex(o *Vector) *_sync.Mutex {
	return &_sync.Mutex{
	}
}

func _ConstructMutex(_v Object) *_sync.Mutex {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sync.Mutex:
			return &_g
		case *_sync.Mutex:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMutex(_o.(Map))
	case case *Vector:
		return _vectorToMutex(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sync.Mutex] or Map"))
}

GO TYPE sync.Once from sync/once.go:
func ExtractGoObjectOnce(args []Object, index int) *_sync.Once {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sync.Once:
			return &r
		case *_sync.Once:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sync.Once]"))
}

func _mapToOnce(o Map) *_sync.Once {
	return &_sync.Once{
	}
}

func _vectorToOnce(o *Vector) *_sync.Once {
	return &_sync.Once{
	}
}

func _ConstructOnce(_v Object) *_sync.Once {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sync.Once:
			return &_g
		case *_sync.Once:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToOnce(_o.(Map))
	case case *Vector:
		return _vectorToOnce(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sync.Once] or Map"))
}

GO TYPE sync.Pool from sync/pool.go:
func ExtractGoObjectPool(args []Object, index int) *_sync.Pool {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sync.Pool:
			return &r
		case *_sync.Pool:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sync.Pool]"))
}

func _mapToPool(o Map) *_sync.Pool {
	return &_sync.Pool{
	}
}

func _vectorToPool(o *Vector) *_sync.Pool {
	return &_sync.Pool{
	}
}

func _ConstructPool(_v Object) *_sync.Pool {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sync.Pool:
			return &_g
		case *_sync.Pool:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPool(_o.(Map))
	case case *Vector:
		return _vectorToPool(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sync.Pool] or Map"))
}

GO TYPE sync.RWMutex from sync/rwmutex.go:
func ExtractGoObjectRWMutex(args []Object, index int) *_sync.RWMutex {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sync.RWMutex:
			return &r
		case *_sync.RWMutex:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sync.RWMutex]"))
}

func _mapToRWMutex(o Map) *_sync.RWMutex {
	return &_sync.RWMutex{
	}
}

func _vectorToRWMutex(o *Vector) *_sync.RWMutex {
	return &_sync.RWMutex{
	}
}

func _ConstructRWMutex(_v Object) *_sync.RWMutex {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sync.RWMutex:
			return &_g
		case *_sync.RWMutex:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRWMutex(_o.(Map))
	case case *Vector:
		return _vectorToRWMutex(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sync.RWMutex] or Map"))
}

GO TYPE sync.WaitGroup from sync/waitgroup.go:
func ExtractGoObjectWaitGroup(args []Object, index int) *_sync.WaitGroup {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sync.WaitGroup:
			return &r
		case *_sync.WaitGroup:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sync.WaitGroup]"))
}

func _mapToWaitGroup(o Map) *_sync.WaitGroup {
	return &_sync.WaitGroup{
	}
}

func _vectorToWaitGroup(o *Vector) *_sync.WaitGroup {
	return &_sync.WaitGroup{
	}
}

func _ConstructWaitGroup(_v Object) *_sync.WaitGroup {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sync.WaitGroup:
			return &_g
		case *_sync.WaitGroup:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWaitGroup(_o.(Map))
	case case *Vector:
		return _vectorToWaitGroup(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sync.WaitGroup] or Map"))
}

GO FUNC sync.NewCond from sync/cond.go:
func __newCond(l _sync.Locker) Object {
	_res := _sync.NewCond(l)
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package sync

import (
	_sync "sync"
	. "github.com/candid82/joker/core"
)
GO FUNC sync/atomic.AddInt32 from sync/atomic/doc.go:
// func __addInt32(addr *int32, delta int32) Object {
// 	_res := _atomic.AddInt32(addr, delta)
// 	return MakeInt(int(_res))
// }

GO FUNC sync/atomic.AddInt64 from sync/atomic/doc.go:
// func __addInt64(addr *int64, delta int64) Object {
// 	_res := _atomic.AddInt64(addr, delta)
// 	return MakeInt(int(_res))
// }

GO FUNC sync/atomic.AddUint32 from sync/atomic/doc.go:
// func __addUint32(addr *uint32, delta uint32) Object {
// 	_res := _atomic.AddUint32(addr, delta)
// 	return MakeInt(int(_res))
// }

GO FUNC sync/atomic.AddUint64 from sync/atomic/doc.go:
// func __addUint64(addr *uint64, delta uint64) Object {
// 	_res := _atomic.AddUint64(addr, delta)
// 	return MakeBigInt(uint64(_res))
// }

GO FUNC sync/atomic.AddUintptr from sync/atomic/doc.go:
// func __addUintptr(addr *uintptr, delta uintptr) Object {
// 	_res := _atomic.AddUintptr(addr, delta)
// 	return MakeBigInt(uint64(_res))
// }

GO FUNC sync/atomic.CompareAndSwapInt32 from sync/atomic/doc.go:
// func __compareAndSwapInt32(addr *int32, old int32, new int32)  {
// 	_res := _atomic.CompareAndSwapInt32(addr, old, new)
// 	return MakeBoolean(_res)
// }

GO FUNC sync/atomic.CompareAndSwapInt64 from sync/atomic/doc.go:
// func __compareAndSwapInt64(addr *int64, old int64, new int64)  {
// 	_res := _atomic.CompareAndSwapInt64(addr, old, new)
// 	return MakeBoolean(_res)
// }

GO FUNC sync/atomic.CompareAndSwapPointer from sync/atomic/doc.go:
// func __compareAndSwapPointer(addr *ABEND987(genutils.go: imports not yet supported: unsafe.Pointer), old ABEND987(genutils.go: imports not yet supported: unsafe.Pointer), new ABEND987(genutils.go: imports not yet supported: unsafe.Pointer))  {
// 	_res := _atomic.CompareAndSwapPointer(addr, old, new)
// 	return MakeBoolean(_res)
// }

GO FUNC sync/atomic.CompareAndSwapUint32 from sync/atomic/doc.go:
// func __compareAndSwapUint32(addr *uint32, old uint32, new uint32)  {
// 	_res := _atomic.CompareAndSwapUint32(addr, old, new)
// 	return MakeBoolean(_res)
// }

GO FUNC sync/atomic.CompareAndSwapUint64 from sync/atomic/doc.go:
// func __compareAndSwapUint64(addr *uint64, old uint64, new uint64)  {
// 	_res := _atomic.CompareAndSwapUint64(addr, old, new)
// 	return MakeBoolean(_res)
// }

GO FUNC sync/atomic.CompareAndSwapUintptr from sync/atomic/doc.go:
// func __compareAndSwapUintptr(addr *uintptr, old uintptr, new uintptr)  {
// 	_res := _atomic.CompareAndSwapUintptr(addr, old, new)
// 	return MakeBoolean(_res)
// }

GO FUNC sync/atomic.LoadInt32 from sync/atomic/doc.go:
// func __loadInt32(addr *int32) Object {
// 	_res := _atomic.LoadInt32(addr)
// 	return MakeInt(int(_res))
// }

GO FUNC sync/atomic.LoadInt64 from sync/atomic/doc.go:
// func __loadInt64(addr *int64) Object {
// 	_res := _atomic.LoadInt64(addr)
// 	return MakeInt(int(_res))
// }

GO FUNC sync/atomic.LoadPointer from sync/atomic/doc.go:
// func __loadPointer(addr *ABEND987(genutils.go: imports not yet supported: unsafe.Pointer)) Object {
// 	return _atomic.LoadPointer(addr)
// }

GO FUNC sync/atomic.LoadUint32 from sync/atomic/doc.go:
// func __loadUint32(addr *uint32) Object {
// 	_res := _atomic.LoadUint32(addr)
// 	return MakeInt(int(_res))
// }

GO FUNC sync/atomic.LoadUint64 from sync/atomic/doc.go:
// func __loadUint64(addr *uint64) Object {
// 	_res := _atomic.LoadUint64(addr)
// 	return MakeBigInt(uint64(_res))
// }

GO FUNC sync/atomic.LoadUintptr from sync/atomic/doc.go:
// func __loadUintptr(addr *uintptr) Object {
// 	_res := _atomic.LoadUintptr(addr)
// 	return MakeBigInt(uint64(_res))
// }

GO FUNC sync/atomic.StoreInt32 from sync/atomic/doc.go:
// func __storeInt32(addr *int32, val int32) Object {
// 	_atomic.StoreInt32(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.StoreInt64 from sync/atomic/doc.go:
// func __storeInt64(addr *int64, val int64) Object {
// 	_atomic.StoreInt64(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.StorePointer from sync/atomic/doc.go:
// func __storePointer(addr *ABEND987(genutils.go: imports not yet supported: unsafe.Pointer), val ABEND987(genutils.go: imports not yet supported: unsafe.Pointer)) Object {
// 	_atomic.StorePointer(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.StoreUint32 from sync/atomic/doc.go:
// func __storeUint32(addr *uint32, val uint32) Object {
// 	_atomic.StoreUint32(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.StoreUint64 from sync/atomic/doc.go:
// func __storeUint64(addr *uint64, val uint64) Object {
// 	_atomic.StoreUint64(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.StoreUintptr from sync/atomic/doc.go:
// func __storeUintptr(addr *uintptr, val uintptr) Object {
// 	_atomic.StoreUintptr(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.SwapInt32 from sync/atomic/doc.go:
// func __swapInt32(addr *int32, new int32) Object {
// 	_res := _atomic.SwapInt32(addr, new)
// 	return MakeInt(int(_res))
// }

GO FUNC sync/atomic.SwapInt64 from sync/atomic/doc.go:
// func __swapInt64(addr *int64, new int64) Object {
// 	_res := _atomic.SwapInt64(addr, new)
// 	return MakeInt(int(_res))
// }

GO FUNC sync/atomic.SwapPointer from sync/atomic/doc.go:
// func __swapPointer(addr *ABEND987(genutils.go: imports not yet supported: unsafe.Pointer), new ABEND987(genutils.go: imports not yet supported: unsafe.Pointer)) Object {
// 	return _atomic.SwapPointer(addr, new)
// }

GO FUNC sync/atomic.SwapUint32 from sync/atomic/doc.go:
// func __swapUint32(addr *uint32, new uint32) Object {
// 	_res := _atomic.SwapUint32(addr, new)
// 	return MakeInt(int(_res))
// }

GO FUNC sync/atomic.SwapUint64 from sync/atomic/doc.go:
// func __swapUint64(addr *uint64, new uint64) Object {
// 	_res := _atomic.SwapUint64(addr, new)
// 	return MakeBigInt(uint64(_res))
// }

GO FUNC sync/atomic.SwapUintptr from sync/atomic/doc.go:
// func __swapUintptr(addr *uintptr, new uintptr) Object {
// 	_res := _atomic.SwapUintptr(addr, new)
// 	return MakeBigInt(uint64(_res))
// }

GO TYPE syscall.Cmsghdr from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectCmsghdr(args []Object, index int) *_syscall.Cmsghdr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Cmsghdr:
			return &r
		case *_syscall.Cmsghdr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Cmsghdr]"))
}

func _mapToCmsghdr(o Map) *_syscall.Cmsghdr {
	return &_syscall.Cmsghdr{
	}
}

func _vectorToCmsghdr(o *Vector) *_syscall.Cmsghdr {
	return &_syscall.Cmsghdr{
	}
}

func _ConstructCmsghdr(_v Object) *_syscall.Cmsghdr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Cmsghdr:
			return &_g
		case *_syscall.Cmsghdr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCmsghdr(_o.(Map))
	case case *Vector:
		return _vectorToCmsghdr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Cmsghdr] or Map"))
}

GO TYPE syscall.Conn from syscall/net.go:
func ExtractGoObjectConn(args []Object, index int) *_syscall.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Conn:
			return &r
		case *_syscall.Conn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Conn]"))
}

// func _ConstructConn(_v Object) _syscall.Conn {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.Conn:
// 			return _g
// 		case *_syscall.Conn:
// 			return *_g
// 		}
// 	default:
// 		return _syscall.Conn(_o.ABEND674(unknown underlying type *ast.InterfaceType for Conn))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Conn] or whatever"))
// }

GO TYPE syscall.Credential from syscall/exec_unix.go:
func ExtractGoObjectCredential(args []Object, index int) *_syscall.Credential {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Credential:
			return &r
		case *_syscall.Credential:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Credential]"))
}

func _mapToCredential(o Map) *_syscall.Credential {
	return &_syscall.Credential{
	}
}

func _vectorToCredential(o *Vector) *_syscall.Credential {
	return &_syscall.Credential{
	}
}

func _ConstructCredential(_v Object) *_syscall.Credential {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Credential:
			return &_g
		case *_syscall.Credential:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCredential(_o.(Map))
	case case *Vector:
		return _vectorToCredential(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Credential] or Map"))
}

GO TYPE syscall.Dirent from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectDirent(args []Object, index int) *_syscall.Dirent {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Dirent:
			return &r
		case *_syscall.Dirent:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Dirent]"))
}

func _mapToDirent(o Map) *_syscall.Dirent {
	return &_syscall.Dirent{
	}
}

func _vectorToDirent(o *Vector) *_syscall.Dirent {
	return &_syscall.Dirent{
	}
}

func _ConstructDirent(_v Object) *_syscall.Dirent {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Dirent:
			return &_g
		case *_syscall.Dirent:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDirent(_o.(Map))
	case case *Vector:
		return _vectorToDirent(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Dirent] or Map"))
}

GO TYPE syscall.EpollEvent from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectEpollEvent(args []Object, index int) *_syscall.EpollEvent {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.EpollEvent:
			return &r
		case *_syscall.EpollEvent:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.EpollEvent]"))
}

func _mapToEpollEvent(o Map) *_syscall.EpollEvent {
	return &_syscall.EpollEvent{
	}
}

func _vectorToEpollEvent(o *Vector) *_syscall.EpollEvent {
	return &_syscall.EpollEvent{
	}
}

func _ConstructEpollEvent(_v Object) *_syscall.EpollEvent {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.EpollEvent:
			return &_g
		case *_syscall.EpollEvent:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToEpollEvent(_o.(Map))
	case case *Vector:
		return _vectorToEpollEvent(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.EpollEvent] or Map"))
}

GO TYPE syscall.Errno from syscall/syscall_unix.go:
func ExtractGoObjectErrno(args []Object, index int) *_syscall.Errno {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Errno:
			return &r
		case *_syscall.Errno:
			return r
		}
	case Number:
		v := _syscall.Errno(ExtractUIntPtr(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Errno]"))
}

func _ConstructErrno(_v Object) _syscall.Errno {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Errno:
			return _g
		case *_syscall.Errno:
			return *_g
		}
	case Number:
		return _syscall.Errno(_o.BigInt().Uint64())
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Errno] or Number"))
}

GO TYPE syscall.FdSet from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectFdSet(args []Object, index int) *_syscall.FdSet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.FdSet:
			return &r
		case *_syscall.FdSet:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.FdSet]"))
}

func _mapToFdSet(o Map) *_syscall.FdSet {
	return &_syscall.FdSet{
	}
}

func _vectorToFdSet(o *Vector) *_syscall.FdSet {
	return &_syscall.FdSet{
	}
}

func _ConstructFdSet(_v Object) *_syscall.FdSet {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.FdSet:
			return &_g
		case *_syscall.FdSet:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFdSet(_o.(Map))
	case case *Vector:
		return _vectorToFdSet(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.FdSet] or Map"))
}

GO TYPE syscall.Flock_t from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectFlock_t(args []Object, index int) *_syscall.Flock_t {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Flock_t:
			return &r
		case *_syscall.Flock_t:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Flock_t]"))
}

func _mapToFlock_t(o Map) *_syscall.Flock_t {
	return &_syscall.Flock_t{
	}
}

func _vectorToFlock_t(o *Vector) *_syscall.Flock_t {
	return &_syscall.Flock_t{
	}
}

func _ConstructFlock_t(_v Object) *_syscall.Flock_t {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Flock_t:
			return &_g
		case *_syscall.Flock_t:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFlock_t(_o.(Map))
	case case *Vector:
		return _vectorToFlock_t(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Flock_t] or Map"))
}

GO TYPE syscall.Fsid from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectFsid(args []Object, index int) *_syscall.Fsid {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Fsid:
			return &r
		case *_syscall.Fsid:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Fsid]"))
}

func _mapToFsid(o Map) *_syscall.Fsid {
	return &_syscall.Fsid{
	}
}

func _vectorToFsid(o *Vector) *_syscall.Fsid {
	return &_syscall.Fsid{
	}
}

func _ConstructFsid(_v Object) *_syscall.Fsid {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Fsid:
			return &_g
		case *_syscall.Fsid:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFsid(_o.(Map))
	case case *Vector:
		return _vectorToFsid(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Fsid] or Map"))
}

GO TYPE syscall.ICMPv6Filter from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectICMPv6Filter(args []Object, index int) *_syscall.ICMPv6Filter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.ICMPv6Filter:
			return &r
		case *_syscall.ICMPv6Filter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.ICMPv6Filter]"))
}

func _mapToICMPv6Filter(o Map) *_syscall.ICMPv6Filter {
	return &_syscall.ICMPv6Filter{
	}
}

func _vectorToICMPv6Filter(o *Vector) *_syscall.ICMPv6Filter {
	return &_syscall.ICMPv6Filter{
	}
}

func _ConstructICMPv6Filter(_v Object) *_syscall.ICMPv6Filter {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.ICMPv6Filter:
			return &_g
		case *_syscall.ICMPv6Filter:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToICMPv6Filter(_o.(Map))
	case case *Vector:
		return _vectorToICMPv6Filter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.ICMPv6Filter] or Map"))
}

GO TYPE syscall.IPMreq from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectIPMreq(args []Object, index int) *_syscall.IPMreq {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.IPMreq:
			return &r
		case *_syscall.IPMreq:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.IPMreq]"))
}

func _mapToIPMreq(o Map) *_syscall.IPMreq {
	return &_syscall.IPMreq{
	}
}

func _vectorToIPMreq(o *Vector) *_syscall.IPMreq {
	return &_syscall.IPMreq{
	}
}

func _ConstructIPMreq(_v Object) *_syscall.IPMreq {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.IPMreq:
			return &_g
		case *_syscall.IPMreq:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIPMreq(_o.(Map))
	case case *Vector:
		return _vectorToIPMreq(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.IPMreq] or Map"))
}

GO TYPE syscall.IPMreqn from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectIPMreqn(args []Object, index int) *_syscall.IPMreqn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.IPMreqn:
			return &r
		case *_syscall.IPMreqn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.IPMreqn]"))
}

func _mapToIPMreqn(o Map) *_syscall.IPMreqn {
	return &_syscall.IPMreqn{
	}
}

func _vectorToIPMreqn(o *Vector) *_syscall.IPMreqn {
	return &_syscall.IPMreqn{
	}
}

func _ConstructIPMreqn(_v Object) *_syscall.IPMreqn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.IPMreqn:
			return &_g
		case *_syscall.IPMreqn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIPMreqn(_o.(Map))
	case case *Vector:
		return _vectorToIPMreqn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.IPMreqn] or Map"))
}

GO TYPE syscall.IPv6MTUInfo from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectIPv6MTUInfo(args []Object, index int) *_syscall.IPv6MTUInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.IPv6MTUInfo:
			return &r
		case *_syscall.IPv6MTUInfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.IPv6MTUInfo]"))
}

func _mapToIPv6MTUInfo(o Map) *_syscall.IPv6MTUInfo {
	return &_syscall.IPv6MTUInfo{
	}
}

func _vectorToIPv6MTUInfo(o *Vector) *_syscall.IPv6MTUInfo {
	return &_syscall.IPv6MTUInfo{
	}
}

func _ConstructIPv6MTUInfo(_v Object) *_syscall.IPv6MTUInfo {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.IPv6MTUInfo:
			return &_g
		case *_syscall.IPv6MTUInfo:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIPv6MTUInfo(_o.(Map))
	case case *Vector:
		return _vectorToIPv6MTUInfo(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.IPv6MTUInfo] or Map"))
}

GO TYPE syscall.IPv6Mreq from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectIPv6Mreq(args []Object, index int) *_syscall.IPv6Mreq {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.IPv6Mreq:
			return &r
		case *_syscall.IPv6Mreq:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.IPv6Mreq]"))
}

func _mapToIPv6Mreq(o Map) *_syscall.IPv6Mreq {
	return &_syscall.IPv6Mreq{
	}
}

func _vectorToIPv6Mreq(o *Vector) *_syscall.IPv6Mreq {
	return &_syscall.IPv6Mreq{
	}
}

func _ConstructIPv6Mreq(_v Object) *_syscall.IPv6Mreq {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.IPv6Mreq:
			return &_g
		case *_syscall.IPv6Mreq:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIPv6Mreq(_o.(Map))
	case case *Vector:
		return _vectorToIPv6Mreq(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.IPv6Mreq] or Map"))
}

GO TYPE syscall.IfAddrmsg from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectIfAddrmsg(args []Object, index int) *_syscall.IfAddrmsg {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.IfAddrmsg:
			return &r
		case *_syscall.IfAddrmsg:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.IfAddrmsg]"))
}

func _mapToIfAddrmsg(o Map) *_syscall.IfAddrmsg {
	return &_syscall.IfAddrmsg{
	}
}

func _vectorToIfAddrmsg(o *Vector) *_syscall.IfAddrmsg {
	return &_syscall.IfAddrmsg{
	}
}

func _ConstructIfAddrmsg(_v Object) *_syscall.IfAddrmsg {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.IfAddrmsg:
			return &_g
		case *_syscall.IfAddrmsg:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIfAddrmsg(_o.(Map))
	case case *Vector:
		return _vectorToIfAddrmsg(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.IfAddrmsg] or Map"))
}

GO TYPE syscall.IfInfomsg from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectIfInfomsg(args []Object, index int) *_syscall.IfInfomsg {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.IfInfomsg:
			return &r
		case *_syscall.IfInfomsg:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.IfInfomsg]"))
}

func _mapToIfInfomsg(o Map) *_syscall.IfInfomsg {
	return &_syscall.IfInfomsg{
	}
}

func _vectorToIfInfomsg(o *Vector) *_syscall.IfInfomsg {
	return &_syscall.IfInfomsg{
	}
}

func _ConstructIfInfomsg(_v Object) *_syscall.IfInfomsg {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.IfInfomsg:
			return &_g
		case *_syscall.IfInfomsg:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIfInfomsg(_o.(Map))
	case case *Vector:
		return _vectorToIfInfomsg(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.IfInfomsg] or Map"))
}

GO TYPE syscall.Inet4Pktinfo from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectInet4Pktinfo(args []Object, index int) *_syscall.Inet4Pktinfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Inet4Pktinfo:
			return &r
		case *_syscall.Inet4Pktinfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Inet4Pktinfo]"))
}

func _mapToInet4Pktinfo(o Map) *_syscall.Inet4Pktinfo {
	return &_syscall.Inet4Pktinfo{
	}
}

func _vectorToInet4Pktinfo(o *Vector) *_syscall.Inet4Pktinfo {
	return &_syscall.Inet4Pktinfo{
	}
}

func _ConstructInet4Pktinfo(_v Object) *_syscall.Inet4Pktinfo {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Inet4Pktinfo:
			return &_g
		case *_syscall.Inet4Pktinfo:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToInet4Pktinfo(_o.(Map))
	case case *Vector:
		return _vectorToInet4Pktinfo(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Inet4Pktinfo] or Map"))
}

GO TYPE syscall.Inet6Pktinfo from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectInet6Pktinfo(args []Object, index int) *_syscall.Inet6Pktinfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Inet6Pktinfo:
			return &r
		case *_syscall.Inet6Pktinfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Inet6Pktinfo]"))
}

func _mapToInet6Pktinfo(o Map) *_syscall.Inet6Pktinfo {
	return &_syscall.Inet6Pktinfo{
	}
}

func _vectorToInet6Pktinfo(o *Vector) *_syscall.Inet6Pktinfo {
	return &_syscall.Inet6Pktinfo{
	}
}

func _ConstructInet6Pktinfo(_v Object) *_syscall.Inet6Pktinfo {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Inet6Pktinfo:
			return &_g
		case *_syscall.Inet6Pktinfo:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToInet6Pktinfo(_o.(Map))
	case case *Vector:
		return _vectorToInet6Pktinfo(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Inet6Pktinfo] or Map"))
}

GO TYPE syscall.InotifyEvent from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectInotifyEvent(args []Object, index int) *_syscall.InotifyEvent {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.InotifyEvent:
			return &r
		case *_syscall.InotifyEvent:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.InotifyEvent]"))
}

func _mapToInotifyEvent(o Map) *_syscall.InotifyEvent {
	return &_syscall.InotifyEvent{
	}
}

func _vectorToInotifyEvent(o *Vector) *_syscall.InotifyEvent {
	return &_syscall.InotifyEvent{
	}
}

func _ConstructInotifyEvent(_v Object) *_syscall.InotifyEvent {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.InotifyEvent:
			return &_g
		case *_syscall.InotifyEvent:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToInotifyEvent(_o.(Map))
	case case *Vector:
		return _vectorToInotifyEvent(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.InotifyEvent] or Map"))
}

GO TYPE syscall.Iovec from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectIovec(args []Object, index int) *_syscall.Iovec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Iovec:
			return &r
		case *_syscall.Iovec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Iovec]"))
}

func _mapToIovec(o Map) *_syscall.Iovec {
	return &_syscall.Iovec{
	}
}

func _vectorToIovec(o *Vector) *_syscall.Iovec {
	return &_syscall.Iovec{
	}
}

func _ConstructIovec(_v Object) *_syscall.Iovec {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Iovec:
			return &_g
		case *_syscall.Iovec:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIovec(_o.(Map))
	case case *Vector:
		return _vectorToIovec(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Iovec] or Map"))
}

GO TYPE syscall.Linger from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectLinger(args []Object, index int) *_syscall.Linger {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Linger:
			return &r
		case *_syscall.Linger:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Linger]"))
}

func _mapToLinger(o Map) *_syscall.Linger {
	return &_syscall.Linger{
	}
}

func _vectorToLinger(o *Vector) *_syscall.Linger {
	return &_syscall.Linger{
	}
}

func _ConstructLinger(_v Object) *_syscall.Linger {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Linger:
			return &_g
		case *_syscall.Linger:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToLinger(_o.(Map))
	case case *Vector:
		return _vectorToLinger(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Linger] or Map"))
}

GO TYPE syscall.Msghdr from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectMsghdr(args []Object, index int) *_syscall.Msghdr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Msghdr:
			return &r
		case *_syscall.Msghdr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Msghdr]"))
}

func _mapToMsghdr(o Map) *_syscall.Msghdr {
	return &_syscall.Msghdr{
	}
}

func _vectorToMsghdr(o *Vector) *_syscall.Msghdr {
	return &_syscall.Msghdr{
	}
}

func _ConstructMsghdr(_v Object) *_syscall.Msghdr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Msghdr:
			return &_g
		case *_syscall.Msghdr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMsghdr(_o.(Map))
	case case *Vector:
		return _vectorToMsghdr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Msghdr] or Map"))
}

GO TYPE syscall.NetlinkMessage from syscall/netlink_linux.go:
func ExtractGoObjectNetlinkMessage(args []Object, index int) *_syscall.NetlinkMessage {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.NetlinkMessage:
			return &r
		case *_syscall.NetlinkMessage:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.NetlinkMessage]"))
}

func _mapToNetlinkMessage(o Map) *_syscall.NetlinkMessage {
	return &_syscall.NetlinkMessage{
	}
}

func _vectorToNetlinkMessage(o *Vector) *_syscall.NetlinkMessage {
	return &_syscall.NetlinkMessage{
	}
}

func _ConstructNetlinkMessage(_v Object) *_syscall.NetlinkMessage {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.NetlinkMessage:
			return &_g
		case *_syscall.NetlinkMessage:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNetlinkMessage(_o.(Map))
	case case *Vector:
		return _vectorToNetlinkMessage(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.NetlinkMessage] or Map"))
}

GO TYPE syscall.NetlinkRouteAttr from syscall/netlink_linux.go:
func ExtractGoObjectNetlinkRouteAttr(args []Object, index int) *_syscall.NetlinkRouteAttr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.NetlinkRouteAttr:
			return &r
		case *_syscall.NetlinkRouteAttr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.NetlinkRouteAttr]"))
}

func _mapToNetlinkRouteAttr(o Map) *_syscall.NetlinkRouteAttr {
	return &_syscall.NetlinkRouteAttr{
	}
}

func _vectorToNetlinkRouteAttr(o *Vector) *_syscall.NetlinkRouteAttr {
	return &_syscall.NetlinkRouteAttr{
	}
}

func _ConstructNetlinkRouteAttr(_v Object) *_syscall.NetlinkRouteAttr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.NetlinkRouteAttr:
			return &_g
		case *_syscall.NetlinkRouteAttr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNetlinkRouteAttr(_o.(Map))
	case case *Vector:
		return _vectorToNetlinkRouteAttr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.NetlinkRouteAttr] or Map"))
}

GO TYPE syscall.NetlinkRouteRequest from syscall/netlink_linux.go:
func ExtractGoObjectNetlinkRouteRequest(args []Object, index int) *_syscall.NetlinkRouteRequest {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.NetlinkRouteRequest:
			return &r
		case *_syscall.NetlinkRouteRequest:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.NetlinkRouteRequest]"))
}

func _mapToNetlinkRouteRequest(o Map) *_syscall.NetlinkRouteRequest {
	return &_syscall.NetlinkRouteRequest{
	}
}

func _vectorToNetlinkRouteRequest(o *Vector) *_syscall.NetlinkRouteRequest {
	return &_syscall.NetlinkRouteRequest{
	}
}

func _ConstructNetlinkRouteRequest(_v Object) *_syscall.NetlinkRouteRequest {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.NetlinkRouteRequest:
			return &_g
		case *_syscall.NetlinkRouteRequest:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNetlinkRouteRequest(_o.(Map))
	case case *Vector:
		return _vectorToNetlinkRouteRequest(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.NetlinkRouteRequest] or Map"))
}

GO TYPE syscall.NlAttr from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectNlAttr(args []Object, index int) *_syscall.NlAttr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.NlAttr:
			return &r
		case *_syscall.NlAttr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.NlAttr]"))
}

func _mapToNlAttr(o Map) *_syscall.NlAttr {
	return &_syscall.NlAttr{
	}
}

func _vectorToNlAttr(o *Vector) *_syscall.NlAttr {
	return &_syscall.NlAttr{
	}
}

func _ConstructNlAttr(_v Object) *_syscall.NlAttr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.NlAttr:
			return &_g
		case *_syscall.NlAttr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNlAttr(_o.(Map))
	case case *Vector:
		return _vectorToNlAttr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.NlAttr] or Map"))
}

GO TYPE syscall.NlMsgerr from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectNlMsgerr(args []Object, index int) *_syscall.NlMsgerr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.NlMsgerr:
			return &r
		case *_syscall.NlMsgerr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.NlMsgerr]"))
}

func _mapToNlMsgerr(o Map) *_syscall.NlMsgerr {
	return &_syscall.NlMsgerr{
	}
}

func _vectorToNlMsgerr(o *Vector) *_syscall.NlMsgerr {
	return &_syscall.NlMsgerr{
	}
}

func _ConstructNlMsgerr(_v Object) *_syscall.NlMsgerr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.NlMsgerr:
			return &_g
		case *_syscall.NlMsgerr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNlMsgerr(_o.(Map))
	case case *Vector:
		return _vectorToNlMsgerr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.NlMsgerr] or Map"))
}

GO TYPE syscall.NlMsghdr from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectNlMsghdr(args []Object, index int) *_syscall.NlMsghdr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.NlMsghdr:
			return &r
		case *_syscall.NlMsghdr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.NlMsghdr]"))
}

func _mapToNlMsghdr(o Map) *_syscall.NlMsghdr {
	return &_syscall.NlMsghdr{
	}
}

func _vectorToNlMsghdr(o *Vector) *_syscall.NlMsghdr {
	return &_syscall.NlMsghdr{
	}
}

func _ConstructNlMsghdr(_v Object) *_syscall.NlMsghdr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.NlMsghdr:
			return &_g
		case *_syscall.NlMsghdr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNlMsghdr(_o.(Map))
	case case *Vector:
		return _vectorToNlMsghdr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.NlMsghdr] or Map"))
}

GO TYPE syscall.ProcAttr from syscall/exec_unix.go:
func ExtractGoObjectProcAttr(args []Object, index int) *_syscall.ProcAttr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.ProcAttr:
			return &r
		case *_syscall.ProcAttr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.ProcAttr]"))
}

func _mapToProcAttr(o Map) *_syscall.ProcAttr {
	return &_syscall.ProcAttr{
	}
}

func _vectorToProcAttr(o *Vector) *_syscall.ProcAttr {
	return &_syscall.ProcAttr{
	}
}

func _ConstructProcAttr(_v Object) *_syscall.ProcAttr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.ProcAttr:
			return &_g
		case *_syscall.ProcAttr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProcAttr(_o.(Map))
	case case *Vector:
		return _vectorToProcAttr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.ProcAttr] or Map"))
}

GO TYPE syscall.PtraceRegs from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectPtraceRegs(args []Object, index int) *_syscall.PtraceRegs {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.PtraceRegs:
			return &r
		case *_syscall.PtraceRegs:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.PtraceRegs]"))
}

func _mapToPtraceRegs(o Map) *_syscall.PtraceRegs {
	return &_syscall.PtraceRegs{
	}
}

func _vectorToPtraceRegs(o *Vector) *_syscall.PtraceRegs {
	return &_syscall.PtraceRegs{
	}
}

func _ConstructPtraceRegs(_v Object) *_syscall.PtraceRegs {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.PtraceRegs:
			return &_g
		case *_syscall.PtraceRegs:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPtraceRegs(_o.(Map))
	case case *Vector:
		return _vectorToPtraceRegs(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.PtraceRegs] or Map"))
}

GO TYPE syscall.RawConn from syscall/net.go:
func ExtractGoObjectRawConn(args []Object, index int) *_syscall.RawConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RawConn:
			return &r
		case *_syscall.RawConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RawConn]"))
}

// func _ConstructRawConn(_v Object) _syscall.RawConn {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.RawConn:
// 			return _g
// 		case *_syscall.RawConn:
// 			return *_g
// 		}
// 	default:
// 		return _syscall.RawConn(_o.ABEND674(unknown underlying type *ast.InterfaceType for RawConn))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RawConn] or whatever"))
// }

GO TYPE syscall.RawSockaddr from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectRawSockaddr(args []Object, index int) *_syscall.RawSockaddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RawSockaddr:
			return &r
		case *_syscall.RawSockaddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RawSockaddr]"))
}

func _mapToRawSockaddr(o Map) *_syscall.RawSockaddr {
	return &_syscall.RawSockaddr{
	}
}

func _vectorToRawSockaddr(o *Vector) *_syscall.RawSockaddr {
	return &_syscall.RawSockaddr{
	}
}

func _ConstructRawSockaddr(_v Object) *_syscall.RawSockaddr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.RawSockaddr:
			return &_g
		case *_syscall.RawSockaddr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRawSockaddr(_o.(Map))
	case case *Vector:
		return _vectorToRawSockaddr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RawSockaddr] or Map"))
}

GO TYPE syscall.RawSockaddrAny from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectRawSockaddrAny(args []Object, index int) *_syscall.RawSockaddrAny {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RawSockaddrAny:
			return &r
		case *_syscall.RawSockaddrAny:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RawSockaddrAny]"))
}

func _mapToRawSockaddrAny(o Map) *_syscall.RawSockaddrAny {
	return &_syscall.RawSockaddrAny{
	}
}

func _vectorToRawSockaddrAny(o *Vector) *_syscall.RawSockaddrAny {
	return &_syscall.RawSockaddrAny{
	}
}

func _ConstructRawSockaddrAny(_v Object) *_syscall.RawSockaddrAny {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.RawSockaddrAny:
			return &_g
		case *_syscall.RawSockaddrAny:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRawSockaddrAny(_o.(Map))
	case case *Vector:
		return _vectorToRawSockaddrAny(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RawSockaddrAny] or Map"))
}

GO TYPE syscall.RawSockaddrInet4 from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectRawSockaddrInet4(args []Object, index int) *_syscall.RawSockaddrInet4 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RawSockaddrInet4:
			return &r
		case *_syscall.RawSockaddrInet4:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RawSockaddrInet4]"))
}

func _mapToRawSockaddrInet4(o Map) *_syscall.RawSockaddrInet4 {
	return &_syscall.RawSockaddrInet4{
	}
}

func _vectorToRawSockaddrInet4(o *Vector) *_syscall.RawSockaddrInet4 {
	return &_syscall.RawSockaddrInet4{
	}
}

func _ConstructRawSockaddrInet4(_v Object) *_syscall.RawSockaddrInet4 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.RawSockaddrInet4:
			return &_g
		case *_syscall.RawSockaddrInet4:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRawSockaddrInet4(_o.(Map))
	case case *Vector:
		return _vectorToRawSockaddrInet4(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RawSockaddrInet4] or Map"))
}

GO TYPE syscall.RawSockaddrInet6 from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectRawSockaddrInet6(args []Object, index int) *_syscall.RawSockaddrInet6 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RawSockaddrInet6:
			return &r
		case *_syscall.RawSockaddrInet6:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RawSockaddrInet6]"))
}

func _mapToRawSockaddrInet6(o Map) *_syscall.RawSockaddrInet6 {
	return &_syscall.RawSockaddrInet6{
	}
}

func _vectorToRawSockaddrInet6(o *Vector) *_syscall.RawSockaddrInet6 {
	return &_syscall.RawSockaddrInet6{
	}
}

func _ConstructRawSockaddrInet6(_v Object) *_syscall.RawSockaddrInet6 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.RawSockaddrInet6:
			return &_g
		case *_syscall.RawSockaddrInet6:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRawSockaddrInet6(_o.(Map))
	case case *Vector:
		return _vectorToRawSockaddrInet6(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RawSockaddrInet6] or Map"))
}

GO TYPE syscall.RawSockaddrLinklayer from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectRawSockaddrLinklayer(args []Object, index int) *_syscall.RawSockaddrLinklayer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RawSockaddrLinklayer:
			return &r
		case *_syscall.RawSockaddrLinklayer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RawSockaddrLinklayer]"))
}

func _mapToRawSockaddrLinklayer(o Map) *_syscall.RawSockaddrLinklayer {
	return &_syscall.RawSockaddrLinklayer{
	}
}

func _vectorToRawSockaddrLinklayer(o *Vector) *_syscall.RawSockaddrLinklayer {
	return &_syscall.RawSockaddrLinklayer{
	}
}

func _ConstructRawSockaddrLinklayer(_v Object) *_syscall.RawSockaddrLinklayer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.RawSockaddrLinklayer:
			return &_g
		case *_syscall.RawSockaddrLinklayer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRawSockaddrLinklayer(_o.(Map))
	case case *Vector:
		return _vectorToRawSockaddrLinklayer(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RawSockaddrLinklayer] or Map"))
}

GO TYPE syscall.RawSockaddrNetlink from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectRawSockaddrNetlink(args []Object, index int) *_syscall.RawSockaddrNetlink {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RawSockaddrNetlink:
			return &r
		case *_syscall.RawSockaddrNetlink:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RawSockaddrNetlink]"))
}

func _mapToRawSockaddrNetlink(o Map) *_syscall.RawSockaddrNetlink {
	return &_syscall.RawSockaddrNetlink{
	}
}

func _vectorToRawSockaddrNetlink(o *Vector) *_syscall.RawSockaddrNetlink {
	return &_syscall.RawSockaddrNetlink{
	}
}

func _ConstructRawSockaddrNetlink(_v Object) *_syscall.RawSockaddrNetlink {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.RawSockaddrNetlink:
			return &_g
		case *_syscall.RawSockaddrNetlink:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRawSockaddrNetlink(_o.(Map))
	case case *Vector:
		return _vectorToRawSockaddrNetlink(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RawSockaddrNetlink] or Map"))
}

GO TYPE syscall.RawSockaddrUnix from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectRawSockaddrUnix(args []Object, index int) *_syscall.RawSockaddrUnix {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RawSockaddrUnix:
			return &r
		case *_syscall.RawSockaddrUnix:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RawSockaddrUnix]"))
}

func _mapToRawSockaddrUnix(o Map) *_syscall.RawSockaddrUnix {
	return &_syscall.RawSockaddrUnix{
	}
}

func _vectorToRawSockaddrUnix(o *Vector) *_syscall.RawSockaddrUnix {
	return &_syscall.RawSockaddrUnix{
	}
}

func _ConstructRawSockaddrUnix(_v Object) *_syscall.RawSockaddrUnix {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.RawSockaddrUnix:
			return &_g
		case *_syscall.RawSockaddrUnix:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRawSockaddrUnix(_o.(Map))
	case case *Vector:
		return _vectorToRawSockaddrUnix(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RawSockaddrUnix] or Map"))
}

GO TYPE syscall.Rlimit from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectRlimit(args []Object, index int) *_syscall.Rlimit {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Rlimit:
			return &r
		case *_syscall.Rlimit:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Rlimit]"))
}

func _mapToRlimit(o Map) *_syscall.Rlimit {
	return &_syscall.Rlimit{
	}
}

func _vectorToRlimit(o *Vector) *_syscall.Rlimit {
	return &_syscall.Rlimit{
	}
}

func _ConstructRlimit(_v Object) *_syscall.Rlimit {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Rlimit:
			return &_g
		case *_syscall.Rlimit:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRlimit(_o.(Map))
	case case *Vector:
		return _vectorToRlimit(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Rlimit] or Map"))
}

GO TYPE syscall.RtAttr from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectRtAttr(args []Object, index int) *_syscall.RtAttr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RtAttr:
			return &r
		case *_syscall.RtAttr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RtAttr]"))
}

func _mapToRtAttr(o Map) *_syscall.RtAttr {
	return &_syscall.RtAttr{
	}
}

func _vectorToRtAttr(o *Vector) *_syscall.RtAttr {
	return &_syscall.RtAttr{
	}
}

func _ConstructRtAttr(_v Object) *_syscall.RtAttr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.RtAttr:
			return &_g
		case *_syscall.RtAttr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRtAttr(_o.(Map))
	case case *Vector:
		return _vectorToRtAttr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RtAttr] or Map"))
}

GO TYPE syscall.RtGenmsg from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectRtGenmsg(args []Object, index int) *_syscall.RtGenmsg {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RtGenmsg:
			return &r
		case *_syscall.RtGenmsg:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RtGenmsg]"))
}

func _mapToRtGenmsg(o Map) *_syscall.RtGenmsg {
	return &_syscall.RtGenmsg{
	}
}

func _vectorToRtGenmsg(o *Vector) *_syscall.RtGenmsg {
	return &_syscall.RtGenmsg{
	}
}

func _ConstructRtGenmsg(_v Object) *_syscall.RtGenmsg {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.RtGenmsg:
			return &_g
		case *_syscall.RtGenmsg:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRtGenmsg(_o.(Map))
	case case *Vector:
		return _vectorToRtGenmsg(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RtGenmsg] or Map"))
}

GO TYPE syscall.RtMsg from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectRtMsg(args []Object, index int) *_syscall.RtMsg {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RtMsg:
			return &r
		case *_syscall.RtMsg:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RtMsg]"))
}

func _mapToRtMsg(o Map) *_syscall.RtMsg {
	return &_syscall.RtMsg{
	}
}

func _vectorToRtMsg(o *Vector) *_syscall.RtMsg {
	return &_syscall.RtMsg{
	}
}

func _ConstructRtMsg(_v Object) *_syscall.RtMsg {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.RtMsg:
			return &_g
		case *_syscall.RtMsg:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRtMsg(_o.(Map))
	case case *Vector:
		return _vectorToRtMsg(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RtMsg] or Map"))
}

GO TYPE syscall.RtNexthop from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectRtNexthop(args []Object, index int) *_syscall.RtNexthop {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RtNexthop:
			return &r
		case *_syscall.RtNexthop:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RtNexthop]"))
}

func _mapToRtNexthop(o Map) *_syscall.RtNexthop {
	return &_syscall.RtNexthop{
	}
}

func _vectorToRtNexthop(o *Vector) *_syscall.RtNexthop {
	return &_syscall.RtNexthop{
	}
}

func _ConstructRtNexthop(_v Object) *_syscall.RtNexthop {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.RtNexthop:
			return &_g
		case *_syscall.RtNexthop:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRtNexthop(_o.(Map))
	case case *Vector:
		return _vectorToRtNexthop(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RtNexthop] or Map"))
}

GO TYPE syscall.Rusage from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectRusage(args []Object, index int) *_syscall.Rusage {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Rusage:
			return &r
		case *_syscall.Rusage:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Rusage]"))
}

func _mapToRusage(o Map) *_syscall.Rusage {
	return &_syscall.Rusage{
	}
}

func _vectorToRusage(o *Vector) *_syscall.Rusage {
	return &_syscall.Rusage{
	}
}

func _ConstructRusage(_v Object) *_syscall.Rusage {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Rusage:
			return &_g
		case *_syscall.Rusage:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRusage(_o.(Map))
	case case *Vector:
		return _vectorToRusage(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Rusage] or Map"))
}

GO TYPE syscall.Signal from syscall/syscall_unix.go:
func ExtractGoObjectSignal(args []Object, index int) *_syscall.Signal {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Signal:
			return &r
		case *_syscall.Signal:
			return r
		}
	case Int:
		v := _syscall.Signal(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Signal]"))
}

func _ConstructSignal(_v Object) _syscall.Signal {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Signal:
			return _g
		case *_syscall.Signal:
			return *_g
		}
	case Number:
		return _syscall.Signal(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Signal] or Number"))
}

GO TYPE syscall.SockFilter from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectSockFilter(args []Object, index int) *_syscall.SockFilter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.SockFilter:
			return &r
		case *_syscall.SockFilter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.SockFilter]"))
}

func _mapToSockFilter(o Map) *_syscall.SockFilter {
	return &_syscall.SockFilter{
	}
}

func _vectorToSockFilter(o *Vector) *_syscall.SockFilter {
	return &_syscall.SockFilter{
	}
}

func _ConstructSockFilter(_v Object) *_syscall.SockFilter {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.SockFilter:
			return &_g
		case *_syscall.SockFilter:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSockFilter(_o.(Map))
	case case *Vector:
		return _vectorToSockFilter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.SockFilter] or Map"))
}

GO TYPE syscall.SockFprog from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectSockFprog(args []Object, index int) *_syscall.SockFprog {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.SockFprog:
			return &r
		case *_syscall.SockFprog:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.SockFprog]"))
}

func _mapToSockFprog(o Map) *_syscall.SockFprog {
	return &_syscall.SockFprog{
	}
}

func _vectorToSockFprog(o *Vector) *_syscall.SockFprog {
	return &_syscall.SockFprog{
	}
}

func _ConstructSockFprog(_v Object) *_syscall.SockFprog {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.SockFprog:
			return &_g
		case *_syscall.SockFprog:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSockFprog(_o.(Map))
	case case *Vector:
		return _vectorToSockFprog(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.SockFprog] or Map"))
}

GO TYPE syscall.Sockaddr from syscall/syscall_unix.go:
func ExtractGoObjectSockaddr(args []Object, index int) *_syscall.Sockaddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Sockaddr:
			return &r
		case *_syscall.Sockaddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Sockaddr]"))
}

// func _ConstructSockaddr(_v Object) _syscall.Sockaddr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.Sockaddr:
// 			return _g
// 		case *_syscall.Sockaddr:
// 			return *_g
// 		}
// 	default:
// 		return _syscall.Sockaddr(_o.ABEND674(unknown underlying type *ast.InterfaceType for Sockaddr))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Sockaddr] or whatever"))
// }

GO TYPE syscall.SockaddrInet4 from syscall/syscall_unix.go:
func ExtractGoObjectSockaddrInet4(args []Object, index int) *_syscall.SockaddrInet4 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.SockaddrInet4:
			return &r
		case *_syscall.SockaddrInet4:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.SockaddrInet4]"))
}

func _mapToSockaddrInet4(o Map) *_syscall.SockaddrInet4 {
	return &_syscall.SockaddrInet4{
	}
}

func _vectorToSockaddrInet4(o *Vector) *_syscall.SockaddrInet4 {
	return &_syscall.SockaddrInet4{
	}
}

func _ConstructSockaddrInet4(_v Object) *_syscall.SockaddrInet4 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.SockaddrInet4:
			return &_g
		case *_syscall.SockaddrInet4:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSockaddrInet4(_o.(Map))
	case case *Vector:
		return _vectorToSockaddrInet4(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.SockaddrInet4] or Map"))
}

GO TYPE syscall.SockaddrInet6 from syscall/syscall_unix.go:
func ExtractGoObjectSockaddrInet6(args []Object, index int) *_syscall.SockaddrInet6 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.SockaddrInet6:
			return &r
		case *_syscall.SockaddrInet6:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.SockaddrInet6]"))
}

func _mapToSockaddrInet6(o Map) *_syscall.SockaddrInet6 {
	return &_syscall.SockaddrInet6{
	}
}

func _vectorToSockaddrInet6(o *Vector) *_syscall.SockaddrInet6 {
	return &_syscall.SockaddrInet6{
	}
}

func _ConstructSockaddrInet6(_v Object) *_syscall.SockaddrInet6 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.SockaddrInet6:
			return &_g
		case *_syscall.SockaddrInet6:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSockaddrInet6(_o.(Map))
	case case *Vector:
		return _vectorToSockaddrInet6(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.SockaddrInet6] or Map"))
}

GO TYPE syscall.SockaddrLinklayer from syscall/syscall_linux.go:
func ExtractGoObjectSockaddrLinklayer(args []Object, index int) *_syscall.SockaddrLinklayer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.SockaddrLinklayer:
			return &r
		case *_syscall.SockaddrLinklayer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.SockaddrLinklayer]"))
}

func _mapToSockaddrLinklayer(o Map) *_syscall.SockaddrLinklayer {
	return &_syscall.SockaddrLinklayer{
	}
}

func _vectorToSockaddrLinklayer(o *Vector) *_syscall.SockaddrLinklayer {
	return &_syscall.SockaddrLinklayer{
	}
}

func _ConstructSockaddrLinklayer(_v Object) *_syscall.SockaddrLinklayer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.SockaddrLinklayer:
			return &_g
		case *_syscall.SockaddrLinklayer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSockaddrLinklayer(_o.(Map))
	case case *Vector:
		return _vectorToSockaddrLinklayer(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.SockaddrLinklayer] or Map"))
}

GO TYPE syscall.SockaddrNetlink from syscall/syscall_linux.go:
func ExtractGoObjectSockaddrNetlink(args []Object, index int) *_syscall.SockaddrNetlink {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.SockaddrNetlink:
			return &r
		case *_syscall.SockaddrNetlink:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.SockaddrNetlink]"))
}

func _mapToSockaddrNetlink(o Map) *_syscall.SockaddrNetlink {
	return &_syscall.SockaddrNetlink{
	}
}

func _vectorToSockaddrNetlink(o *Vector) *_syscall.SockaddrNetlink {
	return &_syscall.SockaddrNetlink{
	}
}

func _ConstructSockaddrNetlink(_v Object) *_syscall.SockaddrNetlink {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.SockaddrNetlink:
			return &_g
		case *_syscall.SockaddrNetlink:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSockaddrNetlink(_o.(Map))
	case case *Vector:
		return _vectorToSockaddrNetlink(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.SockaddrNetlink] or Map"))
}

GO TYPE syscall.SockaddrUnix from syscall/syscall_unix.go:
func ExtractGoObjectSockaddrUnix(args []Object, index int) *_syscall.SockaddrUnix {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.SockaddrUnix:
			return &r
		case *_syscall.SockaddrUnix:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.SockaddrUnix]"))
}

func _mapToSockaddrUnix(o Map) *_syscall.SockaddrUnix {
	return &_syscall.SockaddrUnix{
	}
}

func _vectorToSockaddrUnix(o *Vector) *_syscall.SockaddrUnix {
	return &_syscall.SockaddrUnix{
	}
}

func _ConstructSockaddrUnix(_v Object) *_syscall.SockaddrUnix {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.SockaddrUnix:
			return &_g
		case *_syscall.SockaddrUnix:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSockaddrUnix(_o.(Map))
	case case *Vector:
		return _vectorToSockaddrUnix(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.SockaddrUnix] or Map"))
}

GO TYPE syscall.SocketControlMessage from syscall/sockcmsg_unix.go:
func ExtractGoObjectSocketControlMessage(args []Object, index int) *_syscall.SocketControlMessage {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.SocketControlMessage:
			return &r
		case *_syscall.SocketControlMessage:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.SocketControlMessage]"))
}

func _mapToSocketControlMessage(o Map) *_syscall.SocketControlMessage {
	return &_syscall.SocketControlMessage{
	}
}

func _vectorToSocketControlMessage(o *Vector) *_syscall.SocketControlMessage {
	return &_syscall.SocketControlMessage{
	}
}

func _ConstructSocketControlMessage(_v Object) *_syscall.SocketControlMessage {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.SocketControlMessage:
			return &_g
		case *_syscall.SocketControlMessage:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSocketControlMessage(_o.(Map))
	case case *Vector:
		return _vectorToSocketControlMessage(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.SocketControlMessage] or Map"))
}

GO TYPE syscall.Stat_t from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectStat_t(args []Object, index int) *_syscall.Stat_t {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Stat_t:
			return &r
		case *_syscall.Stat_t:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Stat_t]"))
}

func _mapToStat_t(o Map) *_syscall.Stat_t {
	return &_syscall.Stat_t{
	}
}

func _vectorToStat_t(o *Vector) *_syscall.Stat_t {
	return &_syscall.Stat_t{
	}
}

func _ConstructStat_t(_v Object) *_syscall.Stat_t {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Stat_t:
			return &_g
		case *_syscall.Stat_t:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToStat_t(_o.(Map))
	case case *Vector:
		return _vectorToStat_t(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Stat_t] or Map"))
}

GO TYPE syscall.Statfs_t from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectStatfs_t(args []Object, index int) *_syscall.Statfs_t {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Statfs_t:
			return &r
		case *_syscall.Statfs_t:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Statfs_t]"))
}

func _mapToStatfs_t(o Map) *_syscall.Statfs_t {
	return &_syscall.Statfs_t{
	}
}

func _vectorToStatfs_t(o *Vector) *_syscall.Statfs_t {
	return &_syscall.Statfs_t{
	}
}

func _ConstructStatfs_t(_v Object) *_syscall.Statfs_t {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Statfs_t:
			return &_g
		case *_syscall.Statfs_t:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToStatfs_t(_o.(Map))
	case case *Vector:
		return _vectorToStatfs_t(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Statfs_t] or Map"))
}

GO TYPE syscall.SysProcAttr from syscall/exec_linux.go:
func ExtractGoObjectSysProcAttr(args []Object, index int) *_syscall.SysProcAttr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.SysProcAttr:
			return &r
		case *_syscall.SysProcAttr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.SysProcAttr]"))
}

func _mapToSysProcAttr(o Map) *_syscall.SysProcAttr {
	return &_syscall.SysProcAttr{
	}
}

func _vectorToSysProcAttr(o *Vector) *_syscall.SysProcAttr {
	return &_syscall.SysProcAttr{
	}
}

func _ConstructSysProcAttr(_v Object) *_syscall.SysProcAttr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.SysProcAttr:
			return &_g
		case *_syscall.SysProcAttr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSysProcAttr(_o.(Map))
	case case *Vector:
		return _vectorToSysProcAttr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.SysProcAttr] or Map"))
}

GO TYPE syscall.SysProcIDMap from syscall/exec_linux.go:
func ExtractGoObjectSysProcIDMap(args []Object, index int) *_syscall.SysProcIDMap {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.SysProcIDMap:
			return &r
		case *_syscall.SysProcIDMap:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.SysProcIDMap]"))
}

func _mapToSysProcIDMap(o Map) *_syscall.SysProcIDMap {
	return &_syscall.SysProcIDMap{
	}
}

func _vectorToSysProcIDMap(o *Vector) *_syscall.SysProcIDMap {
	return &_syscall.SysProcIDMap{
	}
}

func _ConstructSysProcIDMap(_v Object) *_syscall.SysProcIDMap {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.SysProcIDMap:
			return &_g
		case *_syscall.SysProcIDMap:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSysProcIDMap(_o.(Map))
	case case *Vector:
		return _vectorToSysProcIDMap(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.SysProcIDMap] or Map"))
}

GO TYPE syscall.Sysinfo_t from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectSysinfo_t(args []Object, index int) *_syscall.Sysinfo_t {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Sysinfo_t:
			return &r
		case *_syscall.Sysinfo_t:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Sysinfo_t]"))
}

func _mapToSysinfo_t(o Map) *_syscall.Sysinfo_t {
	return &_syscall.Sysinfo_t{
	}
}

func _vectorToSysinfo_t(o *Vector) *_syscall.Sysinfo_t {
	return &_syscall.Sysinfo_t{
	}
}

func _ConstructSysinfo_t(_v Object) *_syscall.Sysinfo_t {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Sysinfo_t:
			return &_g
		case *_syscall.Sysinfo_t:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSysinfo_t(_o.(Map))
	case case *Vector:
		return _vectorToSysinfo_t(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Sysinfo_t] or Map"))
}

GO TYPE syscall.TCPInfo from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectTCPInfo(args []Object, index int) *_syscall.TCPInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.TCPInfo:
			return &r
		case *_syscall.TCPInfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.TCPInfo]"))
}

func _mapToTCPInfo(o Map) *_syscall.TCPInfo {
	return &_syscall.TCPInfo{
	}
}

func _vectorToTCPInfo(o *Vector) *_syscall.TCPInfo {
	return &_syscall.TCPInfo{
	}
}

func _ConstructTCPInfo(_v Object) *_syscall.TCPInfo {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.TCPInfo:
			return &_g
		case *_syscall.TCPInfo:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTCPInfo(_o.(Map))
	case case *Vector:
		return _vectorToTCPInfo(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.TCPInfo] or Map"))
}

GO TYPE syscall.Termios from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectTermios(args []Object, index int) *_syscall.Termios {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Termios:
			return &r
		case *_syscall.Termios:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Termios]"))
}

func _mapToTermios(o Map) *_syscall.Termios {
	return &_syscall.Termios{
	}
}

func _vectorToTermios(o *Vector) *_syscall.Termios {
	return &_syscall.Termios{
	}
}

func _ConstructTermios(_v Object) *_syscall.Termios {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Termios:
			return &_g
		case *_syscall.Termios:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTermios(_o.(Map))
	case case *Vector:
		return _vectorToTermios(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Termios] or Map"))
}

GO TYPE syscall.Time_t from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectTime_t(args []Object, index int) *_syscall.Time_t {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Time_t:
			return &r
		case *_syscall.Time_t:
			return r
		}
	case Number:
		v := _syscall.Time_t(ExtractInt64(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Time_t]"))
}

func _ConstructTime_t(_v Object) _syscall.Time_t {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Time_t:
			return _g
		case *_syscall.Time_t:
			return *_g
		}
	case Number:
		return _syscall.Time_t(_o.BigInt().Int64())
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Time_t] or Number"))
}

GO TYPE syscall.Timespec from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectTimespec(args []Object, index int) *_syscall.Timespec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Timespec:
			return &r
		case *_syscall.Timespec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Timespec]"))
}

func _mapToTimespec(o Map) *_syscall.Timespec {
	return &_syscall.Timespec{
	}
}

func _vectorToTimespec(o *Vector) *_syscall.Timespec {
	return &_syscall.Timespec{
	}
}

func _ConstructTimespec(_v Object) *_syscall.Timespec {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Timespec:
			return &_g
		case *_syscall.Timespec:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTimespec(_o.(Map))
	case case *Vector:
		return _vectorToTimespec(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Timespec] or Map"))
}

GO TYPE syscall.Timeval from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectTimeval(args []Object, index int) *_syscall.Timeval {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Timeval:
			return &r
		case *_syscall.Timeval:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Timeval]"))
}

func _mapToTimeval(o Map) *_syscall.Timeval {
	return &_syscall.Timeval{
	}
}

func _vectorToTimeval(o *Vector) *_syscall.Timeval {
	return &_syscall.Timeval{
	}
}

func _ConstructTimeval(_v Object) *_syscall.Timeval {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Timeval:
			return &_g
		case *_syscall.Timeval:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTimeval(_o.(Map))
	case case *Vector:
		return _vectorToTimeval(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Timeval] or Map"))
}

GO TYPE syscall.Timex from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectTimex(args []Object, index int) *_syscall.Timex {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Timex:
			return &r
		case *_syscall.Timex:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Timex]"))
}

func _mapToTimex(o Map) *_syscall.Timex {
	return &_syscall.Timex{
	}
}

func _vectorToTimex(o *Vector) *_syscall.Timex {
	return &_syscall.Timex{
	}
}

func _ConstructTimex(_v Object) *_syscall.Timex {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Timex:
			return &_g
		case *_syscall.Timex:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTimex(_o.(Map))
	case case *Vector:
		return _vectorToTimex(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Timex] or Map"))
}

GO TYPE syscall.Tms from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectTms(args []Object, index int) *_syscall.Tms {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Tms:
			return &r
		case *_syscall.Tms:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Tms]"))
}

func _mapToTms(o Map) *_syscall.Tms {
	return &_syscall.Tms{
	}
}

func _vectorToTms(o *Vector) *_syscall.Tms {
	return &_syscall.Tms{
	}
}

func _ConstructTms(_v Object) *_syscall.Tms {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Tms:
			return &_g
		case *_syscall.Tms:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTms(_o.(Map))
	case case *Vector:
		return _vectorToTms(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Tms] or Map"))
}

GO TYPE syscall.Ucred from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectUcred(args []Object, index int) *_syscall.Ucred {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Ucred:
			return &r
		case *_syscall.Ucred:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Ucred]"))
}

func _mapToUcred(o Map) *_syscall.Ucred {
	return &_syscall.Ucred{
	}
}

func _vectorToUcred(o *Vector) *_syscall.Ucred {
	return &_syscall.Ucred{
	}
}

func _ConstructUcred(_v Object) *_syscall.Ucred {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Ucred:
			return &_g
		case *_syscall.Ucred:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUcred(_o.(Map))
	case case *Vector:
		return _vectorToUcred(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Ucred] or Map"))
}

GO TYPE syscall.Ustat_t from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectUstat_t(args []Object, index int) *_syscall.Ustat_t {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Ustat_t:
			return &r
		case *_syscall.Ustat_t:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Ustat_t]"))
}

func _mapToUstat_t(o Map) *_syscall.Ustat_t {
	return &_syscall.Ustat_t{
	}
}

func _vectorToUstat_t(o *Vector) *_syscall.Ustat_t {
	return &_syscall.Ustat_t{
	}
}

func _ConstructUstat_t(_v Object) *_syscall.Ustat_t {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Ustat_t:
			return &_g
		case *_syscall.Ustat_t:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUstat_t(_o.(Map))
	case case *Vector:
		return _vectorToUstat_t(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Ustat_t] or Map"))
}

GO TYPE syscall.Utimbuf from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectUtimbuf(args []Object, index int) *_syscall.Utimbuf {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Utimbuf:
			return &r
		case *_syscall.Utimbuf:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Utimbuf]"))
}

func _mapToUtimbuf(o Map) *_syscall.Utimbuf {
	return &_syscall.Utimbuf{
	}
}

func _vectorToUtimbuf(o *Vector) *_syscall.Utimbuf {
	return &_syscall.Utimbuf{
	}
}

func _ConstructUtimbuf(_v Object) *_syscall.Utimbuf {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Utimbuf:
			return &_g
		case *_syscall.Utimbuf:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUtimbuf(_o.(Map))
	case case *Vector:
		return _vectorToUtimbuf(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Utimbuf] or Map"))
}

GO TYPE syscall.Utsname from syscall/ztypes_linux_amd64.go:
func ExtractGoObjectUtsname(args []Object, index int) *_syscall.Utsname {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Utsname:
			return &r
		case *_syscall.Utsname:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Utsname]"))
}

func _mapToUtsname(o Map) *_syscall.Utsname {
	return &_syscall.Utsname{
	}
}

func _vectorToUtsname(o *Vector) *_syscall.Utsname {
	return &_syscall.Utsname{
	}
}

func _ConstructUtsname(_v Object) *_syscall.Utsname {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Utsname:
			return &_g
		case *_syscall.Utsname:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUtsname(_o.(Map))
	case case *Vector:
		return _vectorToUtsname(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Utsname] or Map"))
}

GO TYPE syscall.WaitStatus from syscall/syscall_linux.go:
func ExtractGoObjectWaitStatus(args []Object, index int) *_syscall.WaitStatus {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.WaitStatus:
			return &r
		case *_syscall.WaitStatus:
			return r
		}
	case Number:
		v := _syscall.WaitStatus(ExtractUInt32(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.WaitStatus]"))
}

func _ConstructWaitStatus(_v Object) _syscall.WaitStatus {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.WaitStatus:
			return _g
		case *_syscall.WaitStatus:
			return *_g
		}
	case Number:
		return _syscall.WaitStatus(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.WaitStatus] or Number"))
}

GO FUNC syscall.Accept from syscall/syscall_linux.go:
func __accept(fd int) Object {
	nfd, sa, err := _syscall.Accept(fd)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(nfd))
	_res = _res.Conjoin(MakeGoObject(sa))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Accept4 from syscall/syscall_linux.go:
func __accept4(fd int, flags int) Object {
	nfd, sa, err := _syscall.Accept4(fd, flags)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(nfd))
	_res = _res.Conjoin(MakeGoObject(sa))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Adjtimex from syscall/zsyscall_linux_amd64.go:
func __adjtimex(buf *_syscall.Timex) Object {
	state, err := _syscall.Adjtimex(buf)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(state))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.AttachLsf from syscall/lsf_linux.go:
// func __attachLsf(fd int, i []_syscall.SockFilter)  {
// 	_res := _syscall.AttachLsf(fd, i)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.BytePtrFromString from syscall/syscall.go:
func __bytePtrFromString(s string) Object {
	_res1, _res2 := _syscall.BytePtrFromString(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.ByteSliceFromString from syscall/syscall.go:
func __byteSliceFromString(s string) Object {
	_res1, _res2 := _syscall.ByteSliceFromString(s)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.Clearenv from syscall/env_unix.go:
// func __clearenv() Object {
// 	_syscall.Clearenv()
// 	...ABEND675: TODO...
// }

GO FUNC syscall.CloseOnExec from syscall/exec_unix.go:
// func __closeOnExec(fd int) Object {
// 	_syscall.CloseOnExec(fd)
// 	...ABEND675: TODO...
// }

GO FUNC syscall.Creat from syscall/syscall_linux.go:
func __creat(path string, mode uint32) Object {
	fd, err := _syscall.Creat(path, mode)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Dup from syscall/zsyscall_linux_amd64.go:
func __dup(oldfd int) Object {
	fd, err := _syscall.Dup(oldfd)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Environ from syscall/env_unix.go:
func __environ() Object {
	_res := _syscall.Environ()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC syscall.EpollCreate from syscall/zsyscall_linux_amd64.go:
func __epollCreate(size int) Object {
	fd, err := _syscall.EpollCreate(size)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.EpollCreate1 from syscall/zsyscall_linux_amd64.go:
func __epollCreate1(flag int) Object {
	fd, err := _syscall.EpollCreate1(flag)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.EpollWait from syscall/zsyscall_linux_amd64.go:
// func __epollWait(epfd int, events []_syscall.EpollEvent, msec int) Object {
// 	n, err := _syscall.EpollWait(epfd, events, msec)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Exec from syscall/exec_unix.go:
// func __exec(argv0 string, argv []string, envv []string)  {
// 	_res := _syscall.Exec(argv0, argv, envv)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Exit from syscall/syscall.go:
// func __exit(code int) Object {
// 	_syscall.Exit(code)
// 	...ABEND675: TODO...
// }

GO FUNC syscall.ForkExec from syscall/exec_unix.go:
// func __forkExec(argv0 string, argv []string, attr *_syscall.ProcAttr) Object {
// 	pid, err := _syscall.ForkExec(argv0, argv, attr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(pid))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Futimes from syscall/syscall_linux.go:
// func __futimes(fd int, tv []_syscall.Timeval)  {
// 	_res := _syscall.Futimes(fd, tv)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Futimesat from syscall/syscall_linux.go:
// func __futimesat(dirfd int, path string, tv []_syscall.Timeval)  {
// 	_res := _syscall.Futimesat(dirfd, path, tv)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Getcwd from syscall/zsyscall_linux_amd64.go:
// func __getcwd(buf []byte) Object {
// 	n, err := _syscall.Getcwd(buf)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Getdents from syscall/zsyscall_linux_amd64.go:
// func __getdents(fd int, buf []byte) Object {
// 	n, err := _syscall.Getdents(fd, buf)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Getenv from syscall/env_unix.go:
func __getenv(key string) Object {
	value, found := _syscall.Getenv(key)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(value))
	_res = _res.Conjoin(MakeBoolean(found))
	return _res
}

GO FUNC syscall.Getgroups from syscall/syscall_linux.go:
func __getgroups() Object {
	gids, err := _syscall.Getgroups()
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range gids {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getpeername from syscall/syscall_unix.go:
func __getpeername(fd int) Object {
	sa, err := _syscall.Getpeername(fd)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(sa))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getpgid from syscall/zsyscall_linux_amd64.go:
func __getpgid(pid int) Object {
	pgid, err := _syscall.Getpgid(pid)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(pgid))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getpriority from syscall/zsyscall_linux_amd64.go:
func __getpriority(which int, who int) Object {
	prio, err := _syscall.Getpriority(which, who)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(prio))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getsockname from syscall/syscall_linux.go:
func __getsockname(fd int) Object {
	sa, err := _syscall.Getsockname(fd)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(sa))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.GetsockoptICMPv6Filter from syscall/syscall_linux.go:
func __getsockoptICMPv6Filter(fd int, level int, opt int) Object {
	_res1, _res2 := _syscall.GetsockoptICMPv6Filter(fd, level, opt)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.GetsockoptIPMreq from syscall/syscall_linux.go:
func __getsockoptIPMreq(fd int, level int, opt int) Object {
	_res1, _res2 := _syscall.GetsockoptIPMreq(fd, level, opt)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.GetsockoptIPMreqn from syscall/syscall_linux.go:
func __getsockoptIPMreqn(fd int, level int, opt int) Object {
	_res1, _res2 := _syscall.GetsockoptIPMreqn(fd, level, opt)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.GetsockoptIPv6MTUInfo from syscall/syscall_linux.go:
func __getsockoptIPv6MTUInfo(fd int, level int, opt int) Object {
	_res1, _res2 := _syscall.GetsockoptIPv6MTUInfo(fd, level, opt)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.GetsockoptIPv6Mreq from syscall/syscall_linux.go:
func __getsockoptIPv6Mreq(fd int, level int, opt int) Object {
	_res1, _res2 := _syscall.GetsockoptIPv6Mreq(fd, level, opt)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.GetsockoptInet4Addr from syscall/syscall_linux.go:
func __getsockoptInet4Addr(fd int, level int, opt int) Object {
	value, err := _syscall.GetsockoptInet4Addr(fd, level, opt)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range value {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.GetsockoptInt from syscall/syscall_unix.go:
func __getsockoptInt(fd int, level int, opt int) Object {
	value, err := _syscall.GetsockoptInt(fd, level, opt)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(value))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.GetsockoptUcred from syscall/syscall_linux.go:
func __getsockoptUcred(fd int, level int, opt int) Object {
	_res1, _res2 := _syscall.GetsockoptUcred(fd, level, opt)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.Getwd from syscall/syscall_linux.go:
func __getwd() Object {
	wd, err := _syscall.Getwd()
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(wd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getxattr from syscall/zsyscall_linux_amd64.go:
// func __getxattr(path string, attr string, dest []byte) Object {
// 	sz, err := _syscall.Getxattr(path, attr, dest)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(sz))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.InotifyAddWatch from syscall/zsyscall_linux_amd64.go:
func __inotifyAddWatch(fd int, pathname string, mask uint32) Object {
	watchdesc, err := _syscall.InotifyAddWatch(fd, pathname, mask)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(watchdesc))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.InotifyInit from syscall/zsyscall_linux_amd64.go:
func __inotifyInit() Object {
	fd, err := _syscall.InotifyInit()
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.InotifyInit1 from syscall/zsyscall_linux_amd64.go:
func __inotifyInit1(flags int) Object {
	fd, err := _syscall.InotifyInit1(flags)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.InotifyRmWatch from syscall/zsyscall_linux_amd64.go:
func __inotifyRmWatch(fd int, watchdesc uint32) Object {
	success, err := _syscall.InotifyRmWatch(fd, watchdesc)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(success))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Klogctl from syscall/zsyscall_linux_amd64.go:
// func __klogctl(typ int, buf []byte) Object {
// 	n, err := _syscall.Klogctl(typ, buf)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Listxattr from syscall/zsyscall_linux_amd64.go:
// func __listxattr(path string, dest []byte) Object {
// 	sz, err := _syscall.Listxattr(path, dest)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(sz))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.LsfJump from syscall/lsf_linux.go:
func __lsfJump(code int, k int, jt int, jf int) Object {
	_res := _syscall.LsfJump(code, k, jt, jf)
	return MakeGoObject(_res)
}

GO FUNC syscall.LsfSocket from syscall/lsf_linux.go:
func __lsfSocket(ifindex int, proto int) Object {
	_res1, _res2 := _syscall.LsfSocket(ifindex, proto)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.LsfStmt from syscall/lsf_linux.go:
func __lsfStmt(code int, k int) Object {
	_res := _syscall.LsfStmt(code, k)
	return MakeGoObject(_res)
}

GO FUNC syscall.Madvise from syscall/zsyscall_linux_amd64.go:
// func __madvise(b []byte, advice int)  {
// 	_res := _syscall.Madvise(b, advice)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Mlock from syscall/zsyscall_linux_amd64.go:
// func __mlock(b []byte)  {
// 	_res := _syscall.Mlock(b)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Mmap from syscall/syscall_linux.go:
func __mmap(fd int, offset int64, length int, prot int, flags int) Object {
	data, err := _syscall.Mmap(fd, offset, length, prot, flags)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range data {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Mprotect from syscall/zsyscall_linux_amd64.go:
// func __mprotect(b []byte, prot int)  {
// 	_res := _syscall.Mprotect(b, prot)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Munlock from syscall/zsyscall_linux_amd64.go:
// func __munlock(b []byte)  {
// 	_res := _syscall.Munlock(b)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Munmap from syscall/syscall_linux.go:
// func __munmap(b []byte)  {
// 	_res := _syscall.Munmap(b)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.NetlinkRIB from syscall/netlink_linux.go:
func __netlinkRIB(proto int, family int) Object {
	_res1, _res2 := _syscall.NetlinkRIB(proto, family)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.NsecToTimespec from syscall/timestruct.go:
func __nsecToTimespec(nsec int64) Object {
	_res := _syscall.NsecToTimespec(nsec)
	return MakeGoObject(_res)
}

GO FUNC syscall.NsecToTimeval from syscall/timestruct.go:
func __nsecToTimeval(nsec int64) Object {
	_res := _syscall.NsecToTimeval(nsec)
	return MakeGoObject(_res)
}

GO FUNC syscall.Open from syscall/syscall_linux.go:
func __open(path string, mode int, perm uint32) Object {
	fd, err := _syscall.Open(path, mode, perm)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Openat from syscall/syscall_linux.go:
func __openat(dirfd int, path string, flags int, mode uint32) Object {
	fd, err := _syscall.Openat(dirfd, path, flags, mode)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.ParseDirent from syscall/dirent.go:
// func __parseDirent(buf []byte, max int, names []string) Object {
// 	consumed, count, newnames := _syscall.ParseDirent(buf, max, names)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(consumed))
// 	_res = _res.Conjoin(MakeInt(count))
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range newnames {
// 		_vec1 = _vec1.Conjoin(MakeString(_elem1))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	return _res
// }

GO FUNC syscall.ParseNetlinkMessage from syscall/netlink_linux.go:
// func __parseNetlinkMessage(b []byte) Object {
// 	_res1, _res2 := _syscall.ParseNetlinkMessage(b)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC syscall.ParseNetlinkRouteAttr from syscall/netlink_linux.go:
func __parseNetlinkRouteAttr(m *_syscall.NetlinkMessage) Object {
	_res1, _res2 := _syscall.ParseNetlinkRouteAttr(m)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.ParseSocketControlMessage from syscall/sockcmsg_unix.go:
// func __parseSocketControlMessage(b []byte) Object {
// 	_res1, _res2 := _syscall.ParseSocketControlMessage(b)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC syscall.ParseUnixCredentials from syscall/sockcmsg_linux.go:
func __parseUnixCredentials(m *_syscall.SocketControlMessage) Object {
	_res1, _res2 := _syscall.ParseUnixCredentials(m)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.ParseUnixRights from syscall/sockcmsg_unix.go:
func __parseUnixRights(m *_syscall.SocketControlMessage) Object {
	_res1, _res2 := _syscall.ParseUnixRights(m)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.Pipe from syscall/syscall_linux_amd64.go:
// func __pipe(p []int)  {
// 	_res := _syscall.Pipe(p)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Pipe2 from syscall/syscall_linux_amd64.go:
// func __pipe2(p []int, flags int)  {
// 	_res := _syscall.Pipe2(p, flags)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Pread from syscall/zsyscall_linux_amd64.go:
// func __pread(fd int, p []byte, offset int64) Object {
// 	n, err := _syscall.Pread(fd, p, offset)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.PtraceGetEventMsg from syscall/syscall_linux.go:
func __ptraceGetEventMsg(pid int) Object {
	msg, err := _syscall.PtraceGetEventMsg(pid)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(int(msg)))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.PtracePeekData from syscall/syscall_linux.go:
// func __ptracePeekData(pid int, addr uintptr, out []byte) Object {
// 	count, err := _syscall.PtracePeekData(pid, addr, out)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(count))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.PtracePeekText from syscall/syscall_linux.go:
// func __ptracePeekText(pid int, addr uintptr, out []byte) Object {
// 	count, err := _syscall.PtracePeekText(pid, addr, out)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(count))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.PtracePokeData from syscall/syscall_linux.go:
// func __ptracePokeData(pid int, addr uintptr, data []byte) Object {
// 	count, err := _syscall.PtracePokeData(pid, addr, data)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(count))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.PtracePokeText from syscall/syscall_linux.go:
// func __ptracePokeText(pid int, addr uintptr, data []byte) Object {
// 	count, err := _syscall.PtracePokeText(pid, addr, data)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(count))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Pwrite from syscall/zsyscall_linux_amd64.go:
// func __pwrite(fd int, p []byte, offset int64) Object {
// 	n, err := _syscall.Pwrite(fd, p, offset)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.RawSyscall from syscall/syscall_unix.go:
func __rawSyscall(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr) Object {
	r1, r2, err := _syscall.RawSyscall(trap, a1, a2, a3)
	_res := EmptyVector
	_res = _res.Conjoin(MakeBigInt(uint64(r1)))
	_res = _res.Conjoin(MakeBigInt(uint64(r2)))
	_res = _res.Conjoin(MakeGoObject(err))
	return _res
}

GO FUNC syscall.RawSyscall6 from syscall/syscall_unix.go:
func __rawSyscall6(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr) Object {
	r1, r2, err := _syscall.RawSyscall6(trap, a1, a2, a3, a4, a5, a6)
	_res := EmptyVector
	_res = _res.Conjoin(MakeBigInt(uint64(r1)))
	_res = _res.Conjoin(MakeBigInt(uint64(r2)))
	_res = _res.Conjoin(MakeGoObject(err))
	return _res
}

GO FUNC syscall.Read from syscall/syscall_unix.go:
// func __read(fd int, p []byte) Object {
// 	n, err := _syscall.Read(fd, p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.ReadDirent from syscall/syscall_linux.go:
// func __readDirent(fd int, buf []byte) Object {
// 	n, err := _syscall.ReadDirent(fd, buf)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Readlink from syscall/syscall_linux.go:
// func __readlink(path string, buf []byte) Object {
// 	n, err := _syscall.Readlink(path, buf)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Recvfrom from syscall/syscall_unix.go:
// func __recvfrom(fd int, p []byte, flags int) Object {
// 	n, from, err := _syscall.Recvfrom(fd, p, flags)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeGoObject(from))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Recvmsg from syscall/syscall_linux.go:
// func __recvmsg(fd int, p []byte, oob []byte, flags int) Object {
// 	n, oobn, recvflags, from, err := _syscall.Recvmsg(fd, p, oob, flags)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeInt(oobn))
// 	_res = _res.Conjoin(MakeInt(recvflags))
// 	_res = _res.Conjoin(MakeGoObject(from))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Seek from syscall/zsyscall_linux_amd64.go:
func __seek(fd int, offset int64, whence int) Object {
	off, err := _syscall.Seek(fd, offset, whence)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(int(off)))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Select from syscall/zsyscall_linux_amd64.go:
func __select(nfd int, r *_syscall.FdSet, w *_syscall.FdSet, e *_syscall.FdSet, timeout *_syscall.Timeval) Object {
	n, err := _syscall.Select(nfd, r, w, e, timeout)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Sendfile from syscall/syscall_unix.go:
// func __sendfile(outfd int, infd int, offset *int64, count int) Object {
// 	written, err := _syscall.Sendfile(outfd, infd, offset, count)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(written))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Sendmsg from syscall/syscall_linux.go:
// func __sendmsg(fd int, p []byte, oob []byte, to _syscall.Sockaddr, flags int)  {
// 	_res := _syscall.Sendmsg(fd, p, oob, to, flags)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.SendmsgN from syscall/syscall_linux.go:
// func __sendmsgN(fd int, p []byte, oob []byte, to _syscall.Sockaddr, flags int) Object {
// 	n, err := _syscall.SendmsgN(fd, p, oob, to, flags)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Sendto from syscall/syscall_unix.go:
// func __sendto(fd int, p []byte, flags int, to _syscall.Sockaddr)  {
// 	_res := _syscall.Sendto(fd, p, flags, to)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Setdomainname from syscall/zsyscall_linux_amd64.go:
// func __setdomainname(p []byte)  {
// 	_res := _syscall.Setdomainname(p)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Setgroups from syscall/syscall_linux.go:
// func __setgroups(gids []int)  {
// 	_res := _syscall.Setgroups(gids)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Sethostname from syscall/zsyscall_linux_amd64.go:
// func __sethostname(p []byte)  {
// 	_res := _syscall.Sethostname(p)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Setsid from syscall/zsyscall_linux_amd64.go:
func __setsid() Object {
	pid, err := _syscall.Setsid()
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(pid))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.SetsockoptInet4Addr from syscall/syscall_unix.go:
// func __setsockoptInet4Addr(fd int, level int, opt int, value []byte)  {
// 	_res := _syscall.SetsockoptInet4Addr(fd, level, opt, value)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Setxattr from syscall/zsyscall_linux_amd64.go:
// func __setxattr(path string, attr string, data []byte, flags int)  {
// 	_res := _syscall.Setxattr(path, attr, data, flags)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.SlicePtrFromStrings from syscall/exec_unix.go:
// func __slicePtrFromStrings(ss []string) Object {
// 	_res1, _res2 := _syscall.SlicePtrFromStrings(ss)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC syscall.Socket from syscall/syscall_unix.go:
func __socket(domain int, typ int, proto int) Object {
	fd, err := _syscall.Socket(domain, typ, proto)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Socketpair from syscall/syscall_unix.go:
func __socketpair(domain int, typ int, proto int) Object {
	fd, err := _syscall.Socketpair(domain, typ, proto)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range fd {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Splice from syscall/zsyscall_linux_amd64.go:
// func __splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) Object {
// 	n, err := _syscall.Splice(rfd, roff, wfd, woff, len, flags)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(int(n)))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.StartProcess from syscall/exec_unix.go:
// func __startProcess(argv0 string, argv []string, attr *_syscall.ProcAttr) Object {
// 	pid, handle, err := _syscall.StartProcess(argv0, argv, attr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(pid))
// 	_res = _res.Conjoin(MakeBigInt(uint64(handle)))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.StringBytePtr from syscall/syscall.go:
func __stringBytePtr(s string) Object {
	_res := _syscall.StringBytePtr(s)
	return MakeGoObject(_res)
}

GO FUNC syscall.StringByteSlice from syscall/syscall.go:
func __stringByteSlice(s string) Object {
	_res := _syscall.StringByteSlice(s)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC syscall.StringSlicePtr from syscall/exec_unix.go:
// func __stringSlicePtr(ss []string) Object {
// 	_res := _syscall.StringSlicePtr(ss)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
// 	}
// 	return _vec1
// }

GO FUNC syscall.Sync from syscall/zsyscall_linux_amd64.go:
// func __sync() Object {
// 	_syscall.Sync()
// 	...ABEND675: TODO...
// }

GO FUNC syscall.Syscall from syscall/syscall_unix.go:
func __syscall(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr) Object {
	r1, r2, err := _syscall.Syscall(trap, a1, a2, a3)
	_res := EmptyVector
	_res = _res.Conjoin(MakeBigInt(uint64(r1)))
	_res = _res.Conjoin(MakeBigInt(uint64(r2)))
	_res = _res.Conjoin(MakeGoObject(err))
	return _res
}

GO FUNC syscall.Syscall6 from syscall/syscall_unix.go:
func __syscall6(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr) Object {
	r1, r2, err := _syscall.Syscall6(trap, a1, a2, a3, a4, a5, a6)
	_res := EmptyVector
	_res = _res.Conjoin(MakeBigInt(uint64(r1)))
	_res = _res.Conjoin(MakeBigInt(uint64(r2)))
	_res = _res.Conjoin(MakeGoObject(err))
	return _res
}

GO FUNC syscall.Tee from syscall/zsyscall_linux_amd64.go:
func __tee(rfd int, wfd int, len int, flags int) Object {
	n, err := _syscall.Tee(rfd, wfd, len, flags)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(int(n)))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Time from syscall/syscall_linux_amd64.go:
func __time(t *_syscall.Time_t) Object {
	tt, err := _syscall.Time(t)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(tt))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Times from syscall/zsyscall_linux_amd64.go:
func __times(tms *_syscall.Tms) Object {
	ticks, err := _syscall.Times(tms)
	_res := EmptyVector
	_res = _res.Conjoin(MakeBigInt(uint64(ticks)))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.TimespecToNsec from syscall/timestruct.go:
func __timespecToNsec(ts _syscall.Timespec) Object {
	_res := _syscall.TimespecToNsec(ts)
	return MakeInt(int(_res))
}

GO FUNC syscall.TimevalToNsec from syscall/timestruct.go:
func __timevalToNsec(tv _syscall.Timeval) Object {
	_res := _syscall.TimevalToNsec(tv)
	return MakeInt(int(_res))
}

GO FUNC syscall.UnixCredentials from syscall/sockcmsg_linux.go:
func __unixCredentials(ucred *_syscall.Ucred) Object {
	_res := _syscall.UnixCredentials(ucred)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC syscall.UnixRights from syscall/sockcmsg_unix.go:
// func __unixRights(fds ...int) Object {
// 	_res := _syscall.UnixRights(fds)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC syscall.Utimes from syscall/syscall_linux.go:
// func __utimes(path string, tv []_syscall.Timeval)  {
// 	_res := _syscall.Utimes(path, tv)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.UtimesNano from syscall/syscall_linux.go:
// func __utimesNano(path string, ts []_syscall.Timespec)  {
// 	_res := _syscall.UtimesNano(path, ts)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Wait4 from syscall/syscall_linux.go:
func __wait4(pid int, wstatus *_syscall.WaitStatus, options int, rusage *_syscall.Rusage) Object {
	wpid, err := _syscall.Wait4(pid, wstatus, options, rusage)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(wpid))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Write from syscall/syscall_unix.go:
// func __write(fd int, p []byte) Object {
// 	n, err := _syscall.Write(fd, p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package syscall

import (
	_syscall "syscall"
	. "github.com/candid82/joker/core"
)
GO TYPE testing.B from testing/benchmark.go:
func ExtractGoObjectB(args []Object, index int) *_testing.B {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.B:
			return &r
		case *_testing.B:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.B]"))
}

func _mapToB(o Map) *_testing.B {
	return &_testing.B{
	}
}

func _vectorToB(o *Vector) *_testing.B {
	return &_testing.B{
	}
}

func _ConstructB(_v Object) *_testing.B {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _testing.B:
			return &_g
		case *_testing.B:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToB(_o.(Map))
	case case *Vector:
		return _vectorToB(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.B] or Map"))
}

GO TYPE testing.BenchmarkResult from testing/benchmark.go:
func ExtractGoObjectBenchmarkResult(args []Object, index int) *_testing.BenchmarkResult {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.BenchmarkResult:
			return &r
		case *_testing.BenchmarkResult:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.BenchmarkResult]"))
}

func _mapToBenchmarkResult(o Map) *_testing.BenchmarkResult {
	return &_testing.BenchmarkResult{
	}
}

func _vectorToBenchmarkResult(o *Vector) *_testing.BenchmarkResult {
	return &_testing.BenchmarkResult{
	}
}

func _ConstructBenchmarkResult(_v Object) *_testing.BenchmarkResult {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _testing.BenchmarkResult:
			return &_g
		case *_testing.BenchmarkResult:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBenchmarkResult(_o.(Map))
	case case *Vector:
		return _vectorToBenchmarkResult(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.BenchmarkResult] or Map"))
}

GO TYPE testing.Cover from testing/cover.go:
func ExtractGoObjectCover(args []Object, index int) *_testing.Cover {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.Cover:
			return &r
		case *_testing.Cover:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.Cover]"))
}

func _mapToCover(o Map) *_testing.Cover {
	return &_testing.Cover{
	}
}

func _vectorToCover(o *Vector) *_testing.Cover {
	return &_testing.Cover{
	}
}

func _ConstructCover(_v Object) *_testing.Cover {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _testing.Cover:
			return &_g
		case *_testing.Cover:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCover(_o.(Map))
	case case *Vector:
		return _vectorToCover(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.Cover] or Map"))
}

GO TYPE testing.CoverBlock from testing/cover.go:
func ExtractGoObjectCoverBlock(args []Object, index int) *_testing.CoverBlock {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.CoverBlock:
			return &r
		case *_testing.CoverBlock:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.CoverBlock]"))
}

func _mapToCoverBlock(o Map) *_testing.CoverBlock {
	return &_testing.CoverBlock{
	}
}

func _vectorToCoverBlock(o *Vector) *_testing.CoverBlock {
	return &_testing.CoverBlock{
	}
}

func _ConstructCoverBlock(_v Object) *_testing.CoverBlock {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _testing.CoverBlock:
			return &_g
		case *_testing.CoverBlock:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCoverBlock(_o.(Map))
	case case *Vector:
		return _vectorToCoverBlock(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.CoverBlock] or Map"))
}

GO TYPE testing.InternalBenchmark from testing/benchmark.go:
func ExtractGoObjectInternalBenchmark(args []Object, index int) *_testing.InternalBenchmark {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.InternalBenchmark:
			return &r
		case *_testing.InternalBenchmark:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.InternalBenchmark]"))
}

func _mapToInternalBenchmark(o Map) *_testing.InternalBenchmark {
	return &_testing.InternalBenchmark{
	}
}

func _vectorToInternalBenchmark(o *Vector) *_testing.InternalBenchmark {
	return &_testing.InternalBenchmark{
	}
}

func _ConstructInternalBenchmark(_v Object) *_testing.InternalBenchmark {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _testing.InternalBenchmark:
			return &_g
		case *_testing.InternalBenchmark:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToInternalBenchmark(_o.(Map))
	case case *Vector:
		return _vectorToInternalBenchmark(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.InternalBenchmark] or Map"))
}

GO TYPE testing.InternalExample from testing/example.go:
func ExtractGoObjectInternalExample(args []Object, index int) *_testing.InternalExample {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.InternalExample:
			return &r
		case *_testing.InternalExample:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.InternalExample]"))
}

func _mapToInternalExample(o Map) *_testing.InternalExample {
	return &_testing.InternalExample{
	}
}

func _vectorToInternalExample(o *Vector) *_testing.InternalExample {
	return &_testing.InternalExample{
	}
}

func _ConstructInternalExample(_v Object) *_testing.InternalExample {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _testing.InternalExample:
			return &_g
		case *_testing.InternalExample:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToInternalExample(_o.(Map))
	case case *Vector:
		return _vectorToInternalExample(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.InternalExample] or Map"))
}

GO TYPE testing.InternalTest from testing/testing.go:
func ExtractGoObjectInternalTest(args []Object, index int) *_testing.InternalTest {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.InternalTest:
			return &r
		case *_testing.InternalTest:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.InternalTest]"))
}

func _mapToInternalTest(o Map) *_testing.InternalTest {
	return &_testing.InternalTest{
	}
}

func _vectorToInternalTest(o *Vector) *_testing.InternalTest {
	return &_testing.InternalTest{
	}
}

func _ConstructInternalTest(_v Object) *_testing.InternalTest {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _testing.InternalTest:
			return &_g
		case *_testing.InternalTest:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToInternalTest(_o.(Map))
	case case *Vector:
		return _vectorToInternalTest(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.InternalTest] or Map"))
}

GO TYPE testing.M from testing/testing.go:
func ExtractGoObjectM(args []Object, index int) *_testing.M {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.M:
			return &r
		case *_testing.M:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.M]"))
}

func _mapToM(o Map) *_testing.M {
	return &_testing.M{
	}
}

func _vectorToM(o *Vector) *_testing.M {
	return &_testing.M{
	}
}

func _ConstructM(_v Object) *_testing.M {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _testing.M:
			return &_g
		case *_testing.M:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToM(_o.(Map))
	case case *Vector:
		return _vectorToM(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.M] or Map"))
}

GO TYPE testing.PB from testing/benchmark.go:
func ExtractGoObjectPB(args []Object, index int) *_testing.PB {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.PB:
			return &r
		case *_testing.PB:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.PB]"))
}

func _mapToPB(o Map) *_testing.PB {
	return &_testing.PB{
	}
}

func _vectorToPB(o *Vector) *_testing.PB {
	return &_testing.PB{
	}
}

func _ConstructPB(_v Object) *_testing.PB {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _testing.PB:
			return &_g
		case *_testing.PB:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPB(_o.(Map))
	case case *Vector:
		return _vectorToPB(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.PB] or Map"))
}

GO TYPE testing.T from testing/testing.go:
func ExtractGoObjectT(args []Object, index int) *_testing.T {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.T:
			return &r
		case *_testing.T:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.T]"))
}

func _mapToT(o Map) *_testing.T {
	return &_testing.T{
	}
}

func _vectorToT(o *Vector) *_testing.T {
	return &_testing.T{
	}
}

func _ConstructT(_v Object) *_testing.T {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _testing.T:
			return &_g
		case *_testing.T:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToT(_o.(Map))
	case case *Vector:
		return _vectorToT(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.T] or Map"))
}

GO TYPE testing.TB from testing/testing.go:
func ExtractGoObjectTB(args []Object, index int) *_testing.TB {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.TB:
			return &r
		case *_testing.TB:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.TB]"))
}

// func _ConstructTB(_v Object) _testing.TB {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _testing.TB:
// 			return _g
// 		case *_testing.TB:
// 			return *_g
// 		}
// 	default:
// 		return _testing.TB(_o.ABEND674(unknown underlying type *ast.InterfaceType for TB))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.TB] or whatever"))
// }

GO FUNC testing.AllocsPerRun from testing/allocs.go:
// func __allocsPerRun(runs int, f func) Object {
// 	return _testing.AllocsPerRun(runs, f)
// }

GO FUNC testing.Benchmark from testing/benchmark.go:
// func __benchmark(f func) Object {
// 	_res := _testing.Benchmark(f)
// 	return MakeGoObject(_res)
// }

GO FUNC testing.Coverage from testing/cover.go:
// func __coverage() Object {
// 	return _testing.Coverage()
// }

GO FUNC testing.Main from testing/testing.go:
// func __main(matchString func, tests []_testing.InternalTest, benchmarks []_testing.InternalBenchmark, examples []_testing.InternalExample) Object {
// 	_testing.Main(matchString, tests, benchmarks, examples)
// 	...ABEND675: TODO...
// }

GO FUNC testing.MainStart from testing/testing.go:
// func __mainStart(deps testDeps, tests []_testing.InternalTest, benchmarks []_testing.InternalBenchmark, examples []_testing.InternalExample) Object {
// 	_res := _testing.MainStart(deps, tests, benchmarks, examples)
// 	return MakeGoObject(_res)
// }

GO FUNC testing.RegisterCover from testing/cover.go:
// func __registerCover(c _testing.Cover) Object {
// 	_testing.RegisterCover(c)
// 	...ABEND675: TODO...
// }

GO FUNC testing.RunBenchmarks from testing/benchmark.go:
// func __runBenchmarks(matchString func, benchmarks []_testing.InternalBenchmark) Object {
// 	_testing.RunBenchmarks(matchString, benchmarks)
// 	...ABEND675: TODO...
// }

GO FUNC testing.RunExamples from testing/example.go:
// func __runExamples(matchString func, examples []_testing.InternalExample)  {
// 	_res := _testing.RunExamples(matchString, examples)
// 	return MakeBoolean(_res)
// }

GO FUNC testing.RunTests from testing/testing.go:
// func __runTests(matchString func, tests []_testing.InternalTest)  {
// 	_res := _testing.RunTests(matchString, tests)
// 	return MakeBoolean(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package testing

import (
	_testing "testing"
	. "github.com/candid82/joker/core"
)
GO FUNC testing/iotest.DataErrReader from testing/iotest/reader.go:
// func __dataErrReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _iotest.DataErrReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC testing/iotest.HalfReader from testing/iotest/reader.go:
// func __halfReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _iotest.HalfReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC testing/iotest.NewReadLogger from testing/iotest/logger.go:
// func __newReadLogger(prefix string, r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _iotest.NewReadLogger(prefix, r)
// 	return MakeGoObject(_res)
// }

GO FUNC testing/iotest.NewWriteLogger from testing/iotest/logger.go:
// func __newWriteLogger(prefix string, w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _iotest.NewWriteLogger(prefix, w)
// 	return MakeGoObject(_res)
// }

GO FUNC testing/iotest.OneByteReader from testing/iotest/reader.go:
// func __oneByteReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _iotest.OneByteReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC testing/iotest.TimeoutReader from testing/iotest/reader.go:
// func __timeoutReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _iotest.TimeoutReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC testing/iotest.TruncateWriter from testing/iotest/writer.go:
// func __truncateWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer), n int64) Object {
// 	_res := _iotest.TruncateWriter(w, n)
// 	return MakeGoObject(_res)
// }

GO FUNC testing/quick.Check from testing/quick/quick.go:
// func __check(f interface {}, config *_quick.Config)  {
// 	_res := _quick.Check(f, config)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC testing/quick.CheckEqual from testing/quick/quick.go:
// func __checkEqual(f interface {}, g interface {}, config *_quick.Config)  {
// 	_res := _quick.CheckEqual(f, g, config)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC testing/quick.Value from testing/quick/quick.go:
// func __value(t ABEND987(genutils.go: imports not yet supported: reflect.Type), rand *ABEND987(genutils.go: imports not yet supported: rand.Rand)) Object {
// 	value, ok := _quick.Value(t, rand)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(value))
// 	_res = _res.Conjoin(MakeBoolean(ok))
// 	return _res
// }

GO FUNC text/scanner.TokenString from text/scanner/scanner.go:
// func __tokenString(tok rune)  {
// 	_res := _scanner.TokenString(tok)
// 	return MakeString(_res)
// }

GO FUNC text/tabwriter.NewWriter from text/tabwriter/tabwriter.go:
// func __newWriter(output ABEND987(genutils.go: imports not yet supported: io.Writer), minwidth int, tabwidth int, padding int, padchar byte, flags uint) Object {
// 	_res := _tabwriter.NewWriter(output, minwidth, tabwidth, padding, padchar, flags)
// 	return MakeGoObject(_res)
// }

GO TYPE text/template.ExecError from text/template/exec.go:
func ExtractGoObjectExecError(args []Object, index int) *_template.ExecError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.ExecError:
			return &r
		case *_template.ExecError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template.ExecError]"))
}

func _mapToExecError(o Map) *_template.ExecError {
	return &_template.ExecError{
	}
}

func _vectorToExecError(o *Vector) *_template.ExecError {
	return &_template.ExecError{
	}
}

func _ConstructExecError(_v Object) *_template.ExecError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.ExecError:
			return &_g
		case *_template.ExecError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToExecError(_o.(Map))
	case case *Vector:
		return _vectorToExecError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.ExecError] or Map"))
}

GO TYPE text/template.FuncMap from text/template/funcs.go:
func ExtractGoObjectFuncMap(args []Object, index int) *_template.FuncMap {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.FuncMap:
			return &r
		case *_template.FuncMap:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template.FuncMap]"))
}

// func _ConstructFuncMap(_v Object) _template.FuncMap {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _template.FuncMap:
// 			return _g
// 		case *_template.FuncMap:
// 			return *_g
// 		}
// 	default:
// 		return _template.FuncMap(_o.ABEND674(unknown underlying type *ast.MapType for FuncMap))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[template.FuncMap] or whatever"))
// }

GO TYPE text/template.Template from text/template/template.go:
func ExtractGoObjectTemplate(args []Object, index int) *_template.Template {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.Template:
			return &r
		case *_template.Template:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template.Template]"))
}

func _mapToTemplate(o Map) *_template.Template {
	return &_template.Template{
	}
}

func _vectorToTemplate(o *Vector) *_template.Template {
	return &_template.Template{
	}
}

func _ConstructTemplate(_v Object) *_template.Template {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.Template:
			return &_g
		case *_template.Template:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTemplate(_o.(Map))
	case case *Vector:
		return _vectorToTemplate(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.Template] or Map"))
}

GO FUNC text/template.HTMLEscape from text/template/funcs.go:
// func __hTMLEscape(w ABEND987(genutils.go: imports not yet supported: io.Writer), b []byte) Object {
// 	_template.HTMLEscape(w, b)
// 	...ABEND675: TODO...
// }

GO FUNC text/template.HTMLEscaper from text/template/funcs.go:
// func __hTMLEscaper(args ...interface {})  {
// 	_res := _template.HTMLEscaper(args)
// 	return MakeString(_res)
// }

GO FUNC text/template.IsTrue from text/template/exec.go:
// func __isTrue(val interface {}) Object {
// 	truth, ok := _template.IsTrue(val)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeBoolean(truth))
// 	_res = _res.Conjoin(MakeBoolean(ok))
// 	return _res
// }

GO FUNC text/template.JSEscape from text/template/funcs.go:
// func __jSEscape(w ABEND987(genutils.go: imports not yet supported: io.Writer), b []byte) Object {
// 	_template.JSEscape(w, b)
// 	...ABEND675: TODO...
// }

GO FUNC text/template.JSEscaper from text/template/funcs.go:
// func __jSEscaper(args ...interface {})  {
// 	_res := _template.JSEscaper(args)
// 	return MakeString(_res)
// }

GO FUNC text/template.Must from text/template/helper.go:
// func __must(t *_template.Template, err error) Object {
// 	_res := _template.Must(t, err)
// 	return MakeGoObject(_res)
// }

GO FUNC text/template.New from text/template/template.go:
func __new(name string) Object {
	_res := _template.New(name)
	return MakeGoObject(_res)
}

GO FUNC text/template.ParseFiles from text/template/helper.go:
// func __parseFiles(filenames ...string) Object {
// 	_res1, _res2 := _template.ParseFiles(filenames)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC text/template.ParseGlob from text/template/helper.go:
func __parseGlob(pattern string) Object {
	_res1, _res2 := _template.ParseGlob(pattern)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC text/template.URLQueryEscaper from text/template/funcs.go:
// func __uRLQueryEscaper(args ...interface {})  {
// 	_res := _template.URLQueryEscaper(args)
// 	return MakeString(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package template

import (
	_template "text/template"
	. "github.com/candid82/joker/core"
)
GO TYPE text/template/parse.ActionNode from text/template/parse/node.go:
func ExtractGoObjectActionNode(args []Object, index int) *_parse.ActionNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.ActionNode:
			return &r
		case *_parse.ActionNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.ActionNode]"))
}

func _mapToActionNode(o Map) *_parse.ActionNode {
	return &_parse.ActionNode{
	}
}

func _vectorToActionNode(o *Vector) *_parse.ActionNode {
	return &_parse.ActionNode{
	}
}

func _ConstructActionNode(_v Object) *_parse.ActionNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.ActionNode:
			return &_g
		case *_parse.ActionNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToActionNode(_o.(Map))
	case case *Vector:
		return _vectorToActionNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.ActionNode] or Map"))
}

GO TYPE text/template/parse.BoolNode from text/template/parse/node.go:
func ExtractGoObjectBoolNode(args []Object, index int) *_parse.BoolNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.BoolNode:
			return &r
		case *_parse.BoolNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.BoolNode]"))
}

func _mapToBoolNode(o Map) *_parse.BoolNode {
	return &_parse.BoolNode{
	}
}

func _vectorToBoolNode(o *Vector) *_parse.BoolNode {
	return &_parse.BoolNode{
	}
}

func _ConstructBoolNode(_v Object) *_parse.BoolNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.BoolNode:
			return &_g
		case *_parse.BoolNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBoolNode(_o.(Map))
	case case *Vector:
		return _vectorToBoolNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.BoolNode] or Map"))
}

GO TYPE text/template/parse.BranchNode from text/template/parse/node.go:
func ExtractGoObjectBranchNode(args []Object, index int) *_parse.BranchNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.BranchNode:
			return &r
		case *_parse.BranchNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.BranchNode]"))
}

func _mapToBranchNode(o Map) *_parse.BranchNode {
	return &_parse.BranchNode{
	}
}

func _vectorToBranchNode(o *Vector) *_parse.BranchNode {
	return &_parse.BranchNode{
	}
}

func _ConstructBranchNode(_v Object) *_parse.BranchNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.BranchNode:
			return &_g
		case *_parse.BranchNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBranchNode(_o.(Map))
	case case *Vector:
		return _vectorToBranchNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.BranchNode] or Map"))
}

GO TYPE text/template/parse.ChainNode from text/template/parse/node.go:
func ExtractGoObjectChainNode(args []Object, index int) *_parse.ChainNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.ChainNode:
			return &r
		case *_parse.ChainNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.ChainNode]"))
}

func _mapToChainNode(o Map) *_parse.ChainNode {
	return &_parse.ChainNode{
	}
}

func _vectorToChainNode(o *Vector) *_parse.ChainNode {
	return &_parse.ChainNode{
	}
}

func _ConstructChainNode(_v Object) *_parse.ChainNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.ChainNode:
			return &_g
		case *_parse.ChainNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToChainNode(_o.(Map))
	case case *Vector:
		return _vectorToChainNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.ChainNode] or Map"))
}

GO TYPE text/template/parse.CommandNode from text/template/parse/node.go:
func ExtractGoObjectCommandNode(args []Object, index int) *_parse.CommandNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.CommandNode:
			return &r
		case *_parse.CommandNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.CommandNode]"))
}

func _mapToCommandNode(o Map) *_parse.CommandNode {
	return &_parse.CommandNode{
	}
}

func _vectorToCommandNode(o *Vector) *_parse.CommandNode {
	return &_parse.CommandNode{
	}
}

func _ConstructCommandNode(_v Object) *_parse.CommandNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.CommandNode:
			return &_g
		case *_parse.CommandNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCommandNode(_o.(Map))
	case case *Vector:
		return _vectorToCommandNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.CommandNode] or Map"))
}

GO TYPE text/template/parse.DotNode from text/template/parse/node.go:
func ExtractGoObjectDotNode(args []Object, index int) *_parse.DotNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.DotNode:
			return &r
		case *_parse.DotNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.DotNode]"))
}

func _mapToDotNode(o Map) *_parse.DotNode {
	return &_parse.DotNode{
	}
}

func _vectorToDotNode(o *Vector) *_parse.DotNode {
	return &_parse.DotNode{
	}
}

func _ConstructDotNode(_v Object) *_parse.DotNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.DotNode:
			return &_g
		case *_parse.DotNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDotNode(_o.(Map))
	case case *Vector:
		return _vectorToDotNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.DotNode] or Map"))
}

GO TYPE text/template/parse.FieldNode from text/template/parse/node.go:
func ExtractGoObjectFieldNode(args []Object, index int) *_parse.FieldNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.FieldNode:
			return &r
		case *_parse.FieldNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.FieldNode]"))
}

func _mapToFieldNode(o Map) *_parse.FieldNode {
	return &_parse.FieldNode{
	}
}

func _vectorToFieldNode(o *Vector) *_parse.FieldNode {
	return &_parse.FieldNode{
	}
}

func _ConstructFieldNode(_v Object) *_parse.FieldNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.FieldNode:
			return &_g
		case *_parse.FieldNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFieldNode(_o.(Map))
	case case *Vector:
		return _vectorToFieldNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.FieldNode] or Map"))
}

GO TYPE text/template/parse.IdentifierNode from text/template/parse/node.go:
func ExtractGoObjectIdentifierNode(args []Object, index int) *_parse.IdentifierNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.IdentifierNode:
			return &r
		case *_parse.IdentifierNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.IdentifierNode]"))
}

func _mapToIdentifierNode(o Map) *_parse.IdentifierNode {
	return &_parse.IdentifierNode{
	}
}

func _vectorToIdentifierNode(o *Vector) *_parse.IdentifierNode {
	return &_parse.IdentifierNode{
	}
}

func _ConstructIdentifierNode(_v Object) *_parse.IdentifierNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.IdentifierNode:
			return &_g
		case *_parse.IdentifierNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIdentifierNode(_o.(Map))
	case case *Vector:
		return _vectorToIdentifierNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.IdentifierNode] or Map"))
}

GO TYPE text/template/parse.IfNode from text/template/parse/node.go:
func ExtractGoObjectIfNode(args []Object, index int) *_parse.IfNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.IfNode:
			return &r
		case *_parse.IfNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.IfNode]"))
}

func _mapToIfNode(o Map) *_parse.IfNode {
	return &_parse.IfNode{
	}
}

func _vectorToIfNode(o *Vector) *_parse.IfNode {
	return &_parse.IfNode{
	}
}

func _ConstructIfNode(_v Object) *_parse.IfNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.IfNode:
			return &_g
		case *_parse.IfNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIfNode(_o.(Map))
	case case *Vector:
		return _vectorToIfNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.IfNode] or Map"))
}

GO TYPE text/template/parse.ListNode from text/template/parse/node.go:
func ExtractGoObjectListNode(args []Object, index int) *_parse.ListNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.ListNode:
			return &r
		case *_parse.ListNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.ListNode]"))
}

func _mapToListNode(o Map) *_parse.ListNode {
	return &_parse.ListNode{
	}
}

func _vectorToListNode(o *Vector) *_parse.ListNode {
	return &_parse.ListNode{
	}
}

func _ConstructListNode(_v Object) *_parse.ListNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.ListNode:
			return &_g
		case *_parse.ListNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToListNode(_o.(Map))
	case case *Vector:
		return _vectorToListNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.ListNode] or Map"))
}

GO TYPE text/template/parse.NilNode from text/template/parse/node.go:
func ExtractGoObjectNilNode(args []Object, index int) *_parse.NilNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.NilNode:
			return &r
		case *_parse.NilNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.NilNode]"))
}

func _mapToNilNode(o Map) *_parse.NilNode {
	return &_parse.NilNode{
	}
}

func _vectorToNilNode(o *Vector) *_parse.NilNode {
	return &_parse.NilNode{
	}
}

func _ConstructNilNode(_v Object) *_parse.NilNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.NilNode:
			return &_g
		case *_parse.NilNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNilNode(_o.(Map))
	case case *Vector:
		return _vectorToNilNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.NilNode] or Map"))
}

GO TYPE text/template/parse.Node from text/template/parse/node.go:
func ExtractGoObjectNode(args []Object, index int) *_parse.Node {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.Node:
			return &r
		case *_parse.Node:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.Node]"))
}

// func _ConstructNode(_v Object) _parse.Node {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _parse.Node:
// 			return _g
// 		case *_parse.Node:
// 			return *_g
// 		}
// 	default:
// 		return _parse.Node(_o.ABEND674(unknown underlying type *ast.InterfaceType for Node))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.Node] or whatever"))
// }

GO TYPE text/template/parse.NodeType from text/template/parse/node.go:
func ExtractGoObjectNodeType(args []Object, index int) *_parse.NodeType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.NodeType:
			return &r
		case *_parse.NodeType:
			return r
		}
	case Int:
		v := _parse.NodeType(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.NodeType]"))
}

func _ConstructNodeType(_v Object) _parse.NodeType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.NodeType:
			return _g
		case *_parse.NodeType:
			return *_g
		}
	case Number:
		return _parse.NodeType(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.NodeType] or Number"))
}

GO TYPE text/template/parse.NumberNode from text/template/parse/node.go:
func ExtractGoObjectNumberNode(args []Object, index int) *_parse.NumberNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.NumberNode:
			return &r
		case *_parse.NumberNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.NumberNode]"))
}

func _mapToNumberNode(o Map) *_parse.NumberNode {
	return &_parse.NumberNode{
	}
}

func _vectorToNumberNode(o *Vector) *_parse.NumberNode {
	return &_parse.NumberNode{
	}
}

func _ConstructNumberNode(_v Object) *_parse.NumberNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.NumberNode:
			return &_g
		case *_parse.NumberNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNumberNode(_o.(Map))
	case case *Vector:
		return _vectorToNumberNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.NumberNode] or Map"))
}

GO TYPE text/template/parse.PipeNode from text/template/parse/node.go:
func ExtractGoObjectPipeNode(args []Object, index int) *_parse.PipeNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.PipeNode:
			return &r
		case *_parse.PipeNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.PipeNode]"))
}

func _mapToPipeNode(o Map) *_parse.PipeNode {
	return &_parse.PipeNode{
	}
}

func _vectorToPipeNode(o *Vector) *_parse.PipeNode {
	return &_parse.PipeNode{
	}
}

func _ConstructPipeNode(_v Object) *_parse.PipeNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.PipeNode:
			return &_g
		case *_parse.PipeNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPipeNode(_o.(Map))
	case case *Vector:
		return _vectorToPipeNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.PipeNode] or Map"))
}

GO TYPE text/template/parse.Pos from text/template/parse/node.go:
func ExtractGoObjectPos(args []Object, index int) *_parse.Pos {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.Pos:
			return &r
		case *_parse.Pos:
			return r
		}
	case Int:
		v := _parse.Pos(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.Pos]"))
}

func _ConstructPos(_v Object) _parse.Pos {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.Pos:
			return _g
		case *_parse.Pos:
			return *_g
		}
	case Number:
		return _parse.Pos(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.Pos] or Number"))
}

GO TYPE text/template/parse.RangeNode from text/template/parse/node.go:
func ExtractGoObjectRangeNode(args []Object, index int) *_parse.RangeNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.RangeNode:
			return &r
		case *_parse.RangeNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.RangeNode]"))
}

func _mapToRangeNode(o Map) *_parse.RangeNode {
	return &_parse.RangeNode{
	}
}

func _vectorToRangeNode(o *Vector) *_parse.RangeNode {
	return &_parse.RangeNode{
	}
}

func _ConstructRangeNode(_v Object) *_parse.RangeNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.RangeNode:
			return &_g
		case *_parse.RangeNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRangeNode(_o.(Map))
	case case *Vector:
		return _vectorToRangeNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.RangeNode] or Map"))
}

GO TYPE text/template/parse.StringNode from text/template/parse/node.go:
func ExtractGoObjectStringNode(args []Object, index int) *_parse.StringNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.StringNode:
			return &r
		case *_parse.StringNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.StringNode]"))
}

func _mapToStringNode(o Map) *_parse.StringNode {
	return &_parse.StringNode{
	}
}

func _vectorToStringNode(o *Vector) *_parse.StringNode {
	return &_parse.StringNode{
	}
}

func _ConstructStringNode(_v Object) *_parse.StringNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.StringNode:
			return &_g
		case *_parse.StringNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToStringNode(_o.(Map))
	case case *Vector:
		return _vectorToStringNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.StringNode] or Map"))
}

GO TYPE text/template/parse.TemplateNode from text/template/parse/node.go:
func ExtractGoObjectTemplateNode(args []Object, index int) *_parse.TemplateNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.TemplateNode:
			return &r
		case *_parse.TemplateNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.TemplateNode]"))
}

func _mapToTemplateNode(o Map) *_parse.TemplateNode {
	return &_parse.TemplateNode{
	}
}

func _vectorToTemplateNode(o *Vector) *_parse.TemplateNode {
	return &_parse.TemplateNode{
	}
}

func _ConstructTemplateNode(_v Object) *_parse.TemplateNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.TemplateNode:
			return &_g
		case *_parse.TemplateNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTemplateNode(_o.(Map))
	case case *Vector:
		return _vectorToTemplateNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.TemplateNode] or Map"))
}

GO TYPE text/template/parse.TextNode from text/template/parse/node.go:
func ExtractGoObjectTextNode(args []Object, index int) *_parse.TextNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.TextNode:
			return &r
		case *_parse.TextNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.TextNode]"))
}

func _mapToTextNode(o Map) *_parse.TextNode {
	return &_parse.TextNode{
	}
}

func _vectorToTextNode(o *Vector) *_parse.TextNode {
	return &_parse.TextNode{
	}
}

func _ConstructTextNode(_v Object) *_parse.TextNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.TextNode:
			return &_g
		case *_parse.TextNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTextNode(_o.(Map))
	case case *Vector:
		return _vectorToTextNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.TextNode] or Map"))
}

GO TYPE text/template/parse.Tree from text/template/parse/parse.go:
func ExtractGoObjectTree(args []Object, index int) *_parse.Tree {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.Tree:
			return &r
		case *_parse.Tree:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.Tree]"))
}

func _mapToTree(o Map) *_parse.Tree {
	return &_parse.Tree{
	}
}

func _vectorToTree(o *Vector) *_parse.Tree {
	return &_parse.Tree{
	}
}

func _ConstructTree(_v Object) *_parse.Tree {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.Tree:
			return &_g
		case *_parse.Tree:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTree(_o.(Map))
	case case *Vector:
		return _vectorToTree(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.Tree] or Map"))
}

GO TYPE text/template/parse.VariableNode from text/template/parse/node.go:
func ExtractGoObjectVariableNode(args []Object, index int) *_parse.VariableNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.VariableNode:
			return &r
		case *_parse.VariableNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.VariableNode]"))
}

func _mapToVariableNode(o Map) *_parse.VariableNode {
	return &_parse.VariableNode{
	}
}

func _vectorToVariableNode(o *Vector) *_parse.VariableNode {
	return &_parse.VariableNode{
	}
}

func _ConstructVariableNode(_v Object) *_parse.VariableNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.VariableNode:
			return &_g
		case *_parse.VariableNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToVariableNode(_o.(Map))
	case case *Vector:
		return _vectorToVariableNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.VariableNode] or Map"))
}

GO TYPE text/template/parse.WithNode from text/template/parse/node.go:
func ExtractGoObjectWithNode(args []Object, index int) *_parse.WithNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.WithNode:
			return &r
		case *_parse.WithNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.WithNode]"))
}

func _mapToWithNode(o Map) *_parse.WithNode {
	return &_parse.WithNode{
	}
}

func _vectorToWithNode(o *Vector) *_parse.WithNode {
	return &_parse.WithNode{
	}
}

func _ConstructWithNode(_v Object) *_parse.WithNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.WithNode:
			return &_g
		case *_parse.WithNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWithNode(_o.(Map))
	case case *Vector:
		return _vectorToWithNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.WithNode] or Map"))
}

GO FUNC text/template/parse.New from text/template/parse/parse.go:
// func __new(name string, funcs ...map[]) Object {
// 	_res := _parse.New(name, funcs)
// 	return MakeGoObject(_res)
// }

GO FUNC text/template/parse.NewIdentifier from text/template/parse/node.go:
func __newIdentifier(ident string) Object {
	_res := _parse.NewIdentifier(ident)
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.Parse from text/template/parse/parse.go:
// func __parse(name string, text string, leftDelim string, rightDelim string, funcs ...map[]) Object {
// 	_res1, _res2 := _parse.Parse(name, text, leftDelim, rightDelim, funcs)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package parse

import (
	_parse "text/template/parse"
	. "github.com/candid82/joker/core"
)
GO TYPE time.Duration from time/time.go:
func ExtractGoObjectDuration(args []Object, index int) *_time.Duration {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _time.Duration:
			return &r
		case *_time.Duration:
			return r
		}
	case Number:
		v := _time.Duration(ExtractInt64(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[time.Duration]"))
}

func _ConstructDuration(_v Object) _time.Duration {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _time.Duration:
			return _g
		case *_time.Duration:
			return *_g
		}
	case Number:
		return _time.Duration(_o.BigInt().Int64())
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[time.Duration] or Number"))
}

GO TYPE time.Location from time/zoneinfo.go:
func ExtractGoObjectLocation(args []Object, index int) *_time.Location {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _time.Location:
			return &r
		case *_time.Location:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[time.Location]"))
}

func _mapToLocation(o Map) *_time.Location {
	return &_time.Location{
	}
}

func _vectorToLocation(o *Vector) *_time.Location {
	return &_time.Location{
	}
}

func _ConstructLocation(_v Object) *_time.Location {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _time.Location:
			return &_g
		case *_time.Location:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToLocation(_o.(Map))
	case case *Vector:
		return _vectorToLocation(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[time.Location] or Map"))
}

GO TYPE time.Month from time/time.go:
func ExtractGoObjectMonth(args []Object, index int) *_time.Month {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _time.Month:
			return &r
		case *_time.Month:
			return r
		}
	case Int:
		v := _time.Month(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[time.Month]"))
}

func _ConstructMonth(_v Object) _time.Month {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _time.Month:
			return _g
		case *_time.Month:
			return *_g
		}
	case Number:
		return _time.Month(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[time.Month] or Number"))
}

GO TYPE time.ParseError from time/format.go:
func ExtractGoObjectParseError(args []Object, index int) *_time.ParseError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _time.ParseError:
			return &r
		case *_time.ParseError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[time.ParseError]"))
}

func _mapToParseError(o Map) *_time.ParseError {
	return &_time.ParseError{
	}
}

func _vectorToParseError(o *Vector) *_time.ParseError {
	return &_time.ParseError{
	}
}

func _ConstructParseError(_v Object) *_time.ParseError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _time.ParseError:
			return &_g
		case *_time.ParseError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToParseError(_o.(Map))
	case case *Vector:
		return _vectorToParseError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[time.ParseError] or Map"))
}

GO TYPE time.Ticker from time/tick.go:
func ExtractGoObjectTicker(args []Object, index int) *_time.Ticker {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _time.Ticker:
			return &r
		case *_time.Ticker:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[time.Ticker]"))
}

func _mapToTicker(o Map) *_time.Ticker {
	return &_time.Ticker{
	}
}

func _vectorToTicker(o *Vector) *_time.Ticker {
	return &_time.Ticker{
	}
}

func _ConstructTicker(_v Object) *_time.Ticker {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _time.Ticker:
			return &_g
		case *_time.Ticker:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTicker(_o.(Map))
	case case *Vector:
		return _vectorToTicker(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[time.Ticker] or Map"))
}

GO TYPE time.Time from time/time.go:
func ExtractGoObjectTime(args []Object, index int) *_time.Time {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _time.Time:
			return &r
		case *_time.Time:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[time.Time]"))
}

func _mapToTime(o Map) *_time.Time {
	return &_time.Time{
	}
}

func _vectorToTime(o *Vector) *_time.Time {
	return &_time.Time{
	}
}

func _ConstructTime(_v Object) *_time.Time {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _time.Time:
			return &_g
		case *_time.Time:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTime(_o.(Map))
	case case *Vector:
		return _vectorToTime(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[time.Time] or Map"))
}

GO TYPE time.Timer from time/sleep.go:
func ExtractGoObjectTimer(args []Object, index int) *_time.Timer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _time.Timer:
			return &r
		case *_time.Timer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[time.Timer]"))
}

func _mapToTimer(o Map) *_time.Timer {
	return &_time.Timer{
	}
}

func _vectorToTimer(o *Vector) *_time.Timer {
	return &_time.Timer{
	}
}

func _ConstructTimer(_v Object) *_time.Timer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _time.Timer:
			return &_g
		case *_time.Timer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTimer(_o.(Map))
	case case *Vector:
		return _vectorToTimer(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[time.Timer] or Map"))
}

GO TYPE time.Weekday from time/time.go:
func ExtractGoObjectWeekday(args []Object, index int) *_time.Weekday {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _time.Weekday:
			return &r
		case *_time.Weekday:
			return r
		}
	case Int:
		v := _time.Weekday(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[time.Weekday]"))
}

func _ConstructWeekday(_v Object) _time.Weekday {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _time.Weekday:
			return _g
		case *_time.Weekday:
			return *_g
		}
	case Number:
		return _time.Weekday(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[time.Weekday] or Number"))
}

GO FUNC time.After from time/sleep.go:
// func __after(d _time.Duration) Object {
// 	return _time.After(d)
// }

GO FUNC time.AfterFunc from time/sleep.go:
// func __afterFunc(d _time.Duration, f func) Object {
// 	_res := _time.AfterFunc(d, f)
// 	return MakeGoObject(_res)
// }

GO FUNC time.Date from time/time.go:
func __date(year int, month _time.Month, day int, hour int, min int, sec int, nsec int, loc *_time.Location) Object {
	_res := _time.Date(year, month, day, hour, min, sec, nsec, loc)
	return MakeGoObject(_res)
}

GO FUNC time.FixedZone from time/zoneinfo.go:
func __fixedZone(name string, offset int) Object {
	_res := _time.FixedZone(name, offset)
	return MakeGoObject(_res)
}

GO FUNC time.LoadLocation from time/zoneinfo.go:
func __loadLocation(name string) Object {
	_res1, _res2 := _time.LoadLocation(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC time.LoadLocationFromTZData from time/zoneinfo_read.go:
// func __loadLocationFromTZData(name string, data []byte) Object {
// 	_res1, _res2 := _time.LoadLocationFromTZData(name, data)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC time.NewTicker from time/tick.go:
func __newTicker(d _time.Duration) Object {
	_res := _time.NewTicker(d)
	return MakeGoObject(_res)
}

GO FUNC time.NewTimer from time/sleep.go:
func __newTimer(d _time.Duration) Object {
	_res := _time.NewTimer(d)
	return MakeGoObject(_res)
}

GO FUNC time.Now from time/time.go:
func __now() Object {
	_res := _time.Now()
	return MakeGoObject(_res)
}

GO FUNC time.Parse from time/format.go:
func __parse(layout string, value string) Object {
	_res1, _res2 := _time.Parse(layout, value)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC time.ParseDuration from time/format.go:
func __parseDuration(s string) Object {
	_res1, _res2 := _time.ParseDuration(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC time.ParseInLocation from time/format.go:
func __parseInLocation(layout string, value string, loc *_time.Location) Object {
	_res1, _res2 := _time.ParseInLocation(layout, value, loc)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC time.Since from time/time.go:
func __since(t _time.Time) Object {
	_res := _time.Since(t)
	return MakeGoObject(_res)
}

GO FUNC time.Sleep from time/sleep.go:
// func __sleep(d _time.Duration) Object {
// 	_time.Sleep(d)
// 	...ABEND675: TODO...
// }

GO FUNC time.Tick from time/tick.go:
// func __tick(d _time.Duration) Object {
// 	return _time.Tick(d)
// }

GO FUNC time.Unix from time/time.go:
func __unix(sec int64, nsec int64) Object {
	_res := _time.Unix(sec, nsec)
	return MakeGoObject(_res)
}

GO FUNC time.Until from time/time.go:
func __until(t _time.Time) Object {
	_res := _time.Until(t)
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package time

import (
	_time "time"
	. "github.com/candid82/joker/core"
)
GO FUNC unicode.In from unicode/graphic.go:
// func __in(r rune, ranges ...*_unicode.RangeTable)  {
// 	_res := _unicode.In(r, ranges)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode.Is from unicode/letter.go:
// func __is(rangeTab *_unicode.RangeTable, r rune)  {
// 	_res := _unicode.Is(rangeTab, r)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode.IsControl from unicode/graphic.go:
// func __isControl(r rune)  {
// 	_res := _unicode.IsControl(r)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode.IsDigit from unicode/digit.go:
// func __isDigit(r rune)  {
// 	_res := _unicode.IsDigit(r)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode.IsGraphic from unicode/graphic.go:
// func __isGraphic(r rune)  {
// 	_res := _unicode.IsGraphic(r)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode.IsLetter from unicode/graphic.go:
// func __isLetter(r rune)  {
// 	_res := _unicode.IsLetter(r)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode.IsLower from unicode/letter.go:
// func __isLower(r rune)  {
// 	_res := _unicode.IsLower(r)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode.IsMark from unicode/graphic.go:
// func __isMark(r rune)  {
// 	_res := _unicode.IsMark(r)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode.IsNumber from unicode/graphic.go:
// func __isNumber(r rune)  {
// 	_res := _unicode.IsNumber(r)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode.IsOneOf from unicode/graphic.go:
// func __isOneOf(ranges []*_unicode.RangeTable, r rune)  {
// 	_res := _unicode.IsOneOf(ranges, r)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode.IsPrint from unicode/graphic.go:
// func __isPrint(r rune)  {
// 	_res := _unicode.IsPrint(r)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode.IsPunct from unicode/graphic.go:
// func __isPunct(r rune)  {
// 	_res := _unicode.IsPunct(r)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode.IsSpace from unicode/graphic.go:
// func __isSpace(r rune)  {
// 	_res := _unicode.IsSpace(r)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode.IsSymbol from unicode/graphic.go:
// func __isSymbol(r rune)  {
// 	_res := _unicode.IsSymbol(r)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode.IsTitle from unicode/letter.go:
// func __isTitle(r rune)  {
// 	_res := _unicode.IsTitle(r)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode.IsUpper from unicode/letter.go:
// func __isUpper(r rune)  {
// 	_res := _unicode.IsUpper(r)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode.SimpleFold from unicode/letter.go:
// func __simpleFold(r rune) Object {
// 	return _unicode.SimpleFold(r)
// }

GO FUNC unicode.To from unicode/letter.go:
// func __to(_case int, r rune) Object {
// 	return _unicode.To(_case, r)
// }

GO FUNC unicode.ToLower from unicode/letter.go:
// func __toLower(r rune) Object {
// 	return _unicode.ToLower(r)
// }

GO FUNC unicode.ToTitle from unicode/letter.go:
// func __toTitle(r rune) Object {
// 	return _unicode.ToTitle(r)
// }

GO FUNC unicode.ToUpper from unicode/letter.go:
// func __toUpper(r rune) Object {
// 	return _unicode.ToUpper(r)
// }

GO FUNC unicode/utf16.Decode from unicode/utf16/utf16.go:
// func __decode(s []uint16) Object {
// 	_res := _utf16.Decode(s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(_elem1)
// 	}
// 	return _vec1
// }

GO FUNC unicode/utf16.DecodeRune from unicode/utf16/utf16.go:
// func __decodeRune(r1 rune, r2 rune) Object {
// 	return _utf16.DecodeRune(r1, r2)
// }

GO FUNC unicode/utf16.Encode from unicode/utf16/utf16.go:
// func __encode(s []rune) Object {
// 	_res := _utf16.Encode(s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC unicode/utf16.EncodeRune from unicode/utf16/utf16.go:
// func __encodeRune(r rune) Object {
// 	r1, r2 := _utf16.EncodeRune(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r1)
// 	_res = _res.Conjoin(r2)
// 	return _res
// }

GO FUNC unicode/utf16.IsSurrogate from unicode/utf16/utf16.go:
// func __isSurrogate(r rune)  {
// 	_res := _utf16.IsSurrogate(r)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode/utf8.DecodeLastRune from unicode/utf8/utf8.go:
// func __decodeLastRune(p []byte) Object {
// 	r, size := _utf8.DecodeLastRune(p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r)
// 	_res = _res.Conjoin(MakeInt(size))
// 	return _res
// }

GO FUNC unicode/utf8.DecodeLastRuneInString from unicode/utf8/utf8.go:
// func __decodeLastRuneInString(s string) Object {
// 	r, size := _utf8.DecodeLastRuneInString(s)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r)
// 	_res = _res.Conjoin(MakeInt(size))
// 	return _res
// }

GO FUNC unicode/utf8.DecodeRune from unicode/utf8/utf8.go:
// func __decodeRune(p []byte) Object {
// 	r, size := _utf8.DecodeRune(p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r)
// 	_res = _res.Conjoin(MakeInt(size))
// 	return _res
// }

GO FUNC unicode/utf8.DecodeRuneInString from unicode/utf8/utf8.go:
// func __decodeRuneInString(s string) Object {
// 	r, size := _utf8.DecodeRuneInString(s)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r)
// 	_res = _res.Conjoin(MakeInt(size))
// 	return _res
// }

GO FUNC unicode/utf8.EncodeRune from unicode/utf8/utf8.go:
// func __encodeRune(p []byte, r rune)  {
// 	_res := _utf8.EncodeRune(p, r)
// 	return MakeInt(_res)
// }

GO FUNC unicode/utf8.FullRune from unicode/utf8/utf8.go:
// func __fullRune(p []byte)  {
// 	_res := _utf8.FullRune(p)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode/utf8.RuneCount from unicode/utf8/utf8.go:
// func __runeCount(p []byte)  {
// 	_res := _utf8.RuneCount(p)
// 	return MakeInt(_res)
// }

GO FUNC unicode/utf8.RuneLen from unicode/utf8/utf8.go:
// func __runeLen(r rune)  {
// 	_res := _utf8.RuneLen(r)
// 	return MakeInt(_res)
// }

GO FUNC unicode/utf8.Valid from unicode/utf8/utf8.go:
// func __valid(p []byte)  {
// 	_res := _utf8.Valid(p)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode/utf8.ValidRune from unicode/utf8/utf8.go:
// func __validRune(r rune)  {
// 	_res := _utf8.ValidRune(r)
// 	return MakeBoolean(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package utf8

import (
)
ABENDs: 987(309) 902(301) 044(203) 043(129) 675(129) 674(127) 907(85) 906(42) 903(35) 885(16) 905(14) 883(12) 908(6) 042(2) 909(2) 901(1)
Totals: types=962 functions=7132 methods=5623 (78.84%) standalone=1509 (21.16%) generated=667 (44.20%)
