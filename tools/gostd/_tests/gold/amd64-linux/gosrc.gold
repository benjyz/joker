goSourceDir: /usr/local/go/src
goSourcePath: /home/craig/go/src
Walking from /usr/local/go/src to /usr/local/go/src/archive
Processing archive:
Walking from /usr/local/go/src to /usr/local/go/src/archive/tar
Processing archive/tar:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/archive/tar/stat_unix.go) => true <nil>
Matchfile(/usr/local/go/src/archive/tar/common.go) => true <nil>
Matchfile(/usr/local/go/src/archive/tar/format.go) => true <nil>
Matchfile(/usr/local/go/src/archive/tar/strconv.go) => true <nil>
Matchfile(/usr/local/go/src/archive/tar/stat_actime1.go) => true <nil>
Matchfile(/usr/local/go/src/archive/tar/stat_actime2.go) => false <nil>
Ignoring test code in tar_test.go
Matchfile(/usr/local/go/src/archive/tar/writer.go) => true <nil>
Matchfile(/usr/local/go/src/archive/tar/reader.go) => true <nil>
Ignoring test code in strconv_test.go
Ignoring test code in reader_test.go
Ignoring test code in writer_test.go
Processing package=archive/tar:
Excluding /usr/local/go/src/archive/tar/testdata
Walking from /usr/local/go/src to /usr/local/go/src/archive/zip
Processing archive/zip:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/archive/zip/struct.go) => true <nil>
Matchfile(/usr/local/go/src/archive/zip/writer.go) => true <nil>
Matchfile(/usr/local/go/src/archive/zip/reader.go) => true <nil>
Matchfile(/usr/local/go/src/archive/zip/register.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in writer_test.go
Ignoring test code in zip_test.go
Processing package=archive/zip:
Excluding /usr/local/go/src/archive/zip/testdata
Walking from /usr/local/go/src to /usr/local/go/src/bufio
Processing bufio:
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/bufio/bufio.go) => true <nil>
Matchfile(/usr/local/go/src/bufio/scan.go) => true <nil>
Ignoring test code in bufio_test.go
Ignoring test code in scan_test.go
Processing package=bufio:
Excluding /usr/local/go/src/builtin
Walking from /usr/local/go/src to /usr/local/go/src/bytes
Processing bytes:
Ignoring test code in example_test.go
Ignoring test code in boundary_test.go
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/bytes/buffer.go) => true <nil>
Ignoring test code in buffer_test.go
Matchfile(/usr/local/go/src/bytes/reader.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in bytes_test.go
Matchfile(/usr/local/go/src/bytes/bytes.go) => true <nil>
Ignoring test code in compare_test.go
Processing package=bytes:
Excluding /usr/local/go/src/cmd
Walking from /usr/local/go/src to /usr/local/go/src/compress
Processing compress:
Walking from /usr/local/go/src to /usr/local/go/src/compress/bzip2
Processing compress/bzip2:
Ignoring test code in bzip2_test.go
Matchfile(/usr/local/go/src/compress/bzip2/bit_reader.go) => true <nil>
Matchfile(/usr/local/go/src/compress/bzip2/move_to_front.go) => true <nil>
Matchfile(/usr/local/go/src/compress/bzip2/bzip2.go) => true <nil>
Matchfile(/usr/local/go/src/compress/bzip2/huffman.go) => true <nil>
Processing package=compress/bzip2:
Excluding /usr/local/go/src/compress/bzip2/testdata
Walking from /usr/local/go/src to /usr/local/go/src/compress/flate
Processing compress/flate:
Ignoring test code in example_test.go
Ignoring test code in flate_test.go
Ignoring test code in huffman_bit_writer_test.go
Matchfile(/usr/local/go/src/compress/flate/token.go) => true <nil>
Matchfile(/usr/local/go/src/compress/flate/deflate.go) => true <nil>
Ignoring test code in deflate_test.go
Matchfile(/usr/local/go/src/compress/flate/inflate.go) => true <nil>
Matchfile(/usr/local/go/src/compress/flate/huffman_code.go) => true <nil>
Matchfile(/usr/local/go/src/compress/flate/deflatefast.go) => true <nil>
Matchfile(/usr/local/go/src/compress/flate/huffman_bit_writer.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(/usr/local/go/src/compress/flate/dict_decoder.go) => true <nil>
Ignoring test code in inflate_test.go
Ignoring test code in writer_test.go
Ignoring test code in dict_decoder_test.go
Processing package=compress/flate:
Excluding /usr/local/go/src/compress/flate/testdata
Walking from /usr/local/go/src to /usr/local/go/src/compress/gzip
Processing compress/gzip:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/compress/gzip/gzip.go) => true <nil>
Ignoring test code in gunzip_test.go
Matchfile(/usr/local/go/src/compress/gzip/gunzip.go) => true <nil>
Ignoring test code in gzip_test.go
Ignoring test code in issue14937_test.go
Processing package=compress/gzip:
Excluding /usr/local/go/src/compress/gzip/testdata
Walking from /usr/local/go/src to /usr/local/go/src/compress/lzw
Processing compress/lzw:
Matchfile(/usr/local/go/src/compress/lzw/writer.go) => true <nil>
Matchfile(/usr/local/go/src/compress/lzw/reader.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in writer_test.go
Processing package=compress/lzw:
Excluding /usr/local/go/src/compress/testdata
Walking from /usr/local/go/src to /usr/local/go/src/compress/zlib
Processing compress/zlib:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/compress/zlib/writer.go) => true <nil>
Matchfile(/usr/local/go/src/compress/zlib/reader.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in writer_test.go
Processing package=compress/zlib:
Walking from /usr/local/go/src to /usr/local/go/src/container
Processing container:
Walking from /usr/local/go/src to /usr/local/go/src/container/heap
Processing container/heap:
Ignoring test code in example_intheap_test.go
Matchfile(/usr/local/go/src/container/heap/heap.go) => true <nil>
Ignoring test code in example_pq_test.go
Ignoring test code in heap_test.go
Processing package=container/heap:
Walking from /usr/local/go/src to /usr/local/go/src/container/list
Processing container/list:
Ignoring test code in example_test.go
Ignoring test code in list_test.go
Matchfile(/usr/local/go/src/container/list/list.go) => true <nil>
Processing package=container/list:
Walking from /usr/local/go/src to /usr/local/go/src/container/ring
Processing container/ring:
Ignoring test code in example_test.go
Ignoring test code in ring_test.go
Matchfile(/usr/local/go/src/container/ring/ring.go) => true <nil>
Processing package=container/ring:
Walking from /usr/local/go/src to /usr/local/go/src/context
Processing context:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/context/context.go) => true <nil>
Ignoring test code in net_test.go
Ignoring test code in x_test.go
Ignoring test code in context_test.go
Ignoring test code in benchmark_test.go
Processing package=context:
Walking from /usr/local/go/src to /usr/local/go/src/crypto
Processing crypto:
Ignoring test code in issue21104_test.go
Matchfile(/usr/local/go/src/crypto/crypto.go) => true <nil>
Processing package=crypto:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/aes
Processing crypto/aes:
Matchfile(/usr/local/go/src/crypto/aes/cbc_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/aes/cipher.go) => true <nil>
Ignoring test code in aes_test.go
Matchfile(/usr/local/go/src/crypto/aes/const.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/aes/cipher_asm.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/aes/cipher_generic.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/aes/ctr_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/aes/aes_gcm.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/aes/gcm_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/aes/cipher_ppc64le.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/aes/cipher_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/aes/modes.go) => true <nil>
Ignoring test code in modes_test.go
Matchfile(/usr/local/go/src/crypto/aes/block.go) => true <nil>
Processing package=crypto/aes:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/cipher
Processing crypto/cipher:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/crypto/cipher/gcm.go) => true <nil>
Ignoring test code in xor_test.go
Matchfile(/usr/local/go/src/crypto/cipher/xor_generic.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/cipher/ctr.go) => true <nil>
Ignoring test code in cipher_test.go
Matchfile(/usr/local/go/src/crypto/cipher/xor_amd64.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/cipher/cipher.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/cipher/cfb.go) => true <nil>
Ignoring test code in ofb_test.go
Matchfile(/usr/local/go/src/crypto/cipher/xor_ppc64x.go) => false <nil>
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/crypto/cipher/cbc.go) => true <nil>
Ignoring test code in gcm_test.go
Ignoring test code in common_test.go
Ignoring test code in ctr_test.go
Ignoring test code in ctr_aes_test.go
Ignoring test code in cbc_aes_test.go
Ignoring test code in cfb_test.go
Matchfile(/usr/local/go/src/crypto/cipher/io.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/cipher/ofb.go) => true <nil>
Ignoring test code in benchmark_test.go
Processing package=crypto/cipher:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/des
Processing crypto/des:
Ignoring test code in example_test.go
Ignoring test code in des_test.go
Matchfile(/usr/local/go/src/crypto/des/cipher.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/des/const.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/des/block.go) => true <nil>
Processing package=crypto/des:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/dsa
Processing crypto/dsa:
Ignoring test code in dsa_test.go
Matchfile(/usr/local/go/src/crypto/dsa/dsa.go) => true <nil>
Processing package=crypto/dsa:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/ecdsa
Processing crypto/ecdsa:
Ignoring test code in example_test.go
Ignoring test code in ecdsa_test.go
Matchfile(/usr/local/go/src/crypto/ecdsa/ecdsa.go) => true <nil>
Processing package=crypto/ecdsa:
Excluding /usr/local/go/src/crypto/ecdsa/testdata
Walking from /usr/local/go/src to /usr/local/go/src/crypto/elliptic
Processing crypto/elliptic:
Matchfile(/usr/local/go/src/crypto/elliptic/elliptic.go) => true <nil>
Ignoring test code in p224_test.go
Matchfile(/usr/local/go/src/crypto/elliptic/p224.go) => true <nil>
Ignoring test code in fuzz_test.go
Matchfile(/usr/local/go/src/crypto/elliptic/p256_asm.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/elliptic/p256_generic.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/elliptic/p256_s390x.go) => false <nil>
Ignoring test code in elliptic_test.go
Matchfile(/usr/local/go/src/crypto/elliptic/p256.go) => false <nil>
Processing package=crypto/elliptic:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/hmac
Processing crypto/hmac:
Ignoring test code in hmac_test.go
Matchfile(/usr/local/go/src/crypto/hmac/hmac.go) => true <nil>
Processing package=crypto/hmac:
Excluding /usr/local/go/src/crypto/internal
Walking from /usr/local/go/src to /usr/local/go/src/crypto/md5
Processing crypto/md5:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/crypto/md5/md5block_decl.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/md5/md5.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/md5/gen.go) => false <nil>
Ignoring test code in md5_test.go
Matchfile(/usr/local/go/src/crypto/md5/md5block_generic.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/md5/md5block.go) => true <nil>
Processing package=crypto/md5:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/rand
Processing crypto/rand:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/crypto/rand/rand_freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/rand/util.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/rand/rand_linux.go) => true <nil>
Ignoring test code in rand_batched_test.go
Matchfile(/usr/local/go/src/crypto/rand/rand_js.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/rand/eagain.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/rand/rand.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/rand/rand_batched.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/rand/rand_windows.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/rand/rand_openbsd.go) => false <nil>
Ignoring test code in util_test.go
Ignoring test code in rand_test.go
Matchfile(/usr/local/go/src/crypto/rand/rand_unix.go) => true <nil>
Processing package=crypto/rand:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/rc4
Processing crypto/rc4:
Matchfile(/usr/local/go/src/crypto/rc4/rc4.go) => true <nil>
Ignoring test code in rc4_test.go
Processing package=crypto/rc4:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/rsa
Processing crypto/rsa:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/crypto/rsa/pkcs1v15.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/rsa/rsa.go) => true <nil>
Ignoring test code in pkcs1v15_test.go
Ignoring test code in pss_test.go
Ignoring test code in rsa_test.go
Matchfile(/usr/local/go/src/crypto/rsa/pss.go) => true <nil>
Processing package=crypto/rsa:
Excluding /usr/local/go/src/crypto/rsa/testdata
Walking from /usr/local/go/src to /usr/local/go/src/crypto/sha1
Processing crypto/sha1:
Ignoring test code in sha1_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/crypto/sha1/sha1block_decl.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/sha1/sha1block_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/sha1/sha1.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/sha1/sha1block_amd64.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/sha1/sha1block.go) => true <nil>
Ignoring test code in fallback_test.go
Matchfile(/usr/local/go/src/crypto/sha1/sha1block_generic.go) => false <nil>
Ignoring test code in issue15617_test.go
Matchfile(/usr/local/go/src/crypto/sha1/sha1block_arm64.go) => false <nil>
Processing package=crypto/sha1:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/sha256
Processing crypto/sha256:
Matchfile(/usr/local/go/src/crypto/sha256/sha256block_s390x.go) => false <nil>
Ignoring test code in example_test.go
Ignoring test code in sha256_test.go
Matchfile(/usr/local/go/src/crypto/sha256/sha256.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/sha256/sha256block.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/sha256/sha256block_amd64.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/sha256/sha256block_generic.go) => false <nil>
Ignoring test code in fallback_test.go
Matchfile(/usr/local/go/src/crypto/sha256/sha256block_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/sha256/sha256block_decl.go) => true <nil>
Processing package=crypto/sha256:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/sha512
Processing crypto/sha512:
Matchfile(/usr/local/go/src/crypto/sha512/sha512block_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/sha512/sha512.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/sha512/sha512block_amd64.go) => true <nil>
Ignoring test code in sha512_test.go
Matchfile(/usr/local/go/src/crypto/sha512/sha512block.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/sha512/sha512block_generic.go) => false <nil>
Ignoring test code in fallback_test.go
Matchfile(/usr/local/go/src/crypto/sha512/sha512block_decl.go) => false <nil>
Processing package=crypto/sha512:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/subtle
Processing crypto/subtle:
Ignoring test code in constant_time_test.go
Matchfile(/usr/local/go/src/crypto/subtle/constant_time.go) => true <nil>
Processing package=crypto/subtle:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/tls
Processing crypto/tls:
Ignoring test code in conn_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/crypto/tls/handshake_server_tls13.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/tls/common.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/tls/ticket.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/tls/tls.go) => true <nil>
Ignoring test code in handshake_client_test.go
Ignoring test code in handshake_server_test.go
Matchfile(/usr/local/go/src/crypto/tls/cipher_suites.go) => true <nil>
Ignoring test code in tls_test.go
Ignoring test code in auth_test.go
Matchfile(/usr/local/go/src/crypto/tls/handshake_messages.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/tls/key_schedule.go) => true <nil>
Ignoring test code in prf_test.go
Matchfile(/usr/local/go/src/crypto/tls/handshake_server.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/tls/prf.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/tls/alert.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/tls/conn.go) => true <nil>
Ignoring test code in handshake_test.go
Matchfile(/usr/local/go/src/crypto/tls/key_agreement.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/tls/handshake_client.go) => true <nil>
Ignoring test code in handshake_messages_test.go
Matchfile(/usr/local/go/src/crypto/tls/auth.go) => true <nil>
Ignoring test code in key_schedule_test.go
Matchfile(/usr/local/go/src/crypto/tls/generate_cert.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/tls/handshake_client_tls13.go) => true <nil>
Processing package=crypto/tls:
Excluding /usr/local/go/src/crypto/tls/testdata
Walking from /usr/local/go/src to /usr/local/go/src/crypto/x509
Processing crypto/x509:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/crypto/x509/root_aix.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/x509/root_windows.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/x509/root.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/x509/pkcs8.go) => true <nil>
Ignoring test code in verify_test.go
Ignoring test code in pkcs8_test.go
Ignoring test code in root_unix_test.go
Matchfile(/usr/local/go/src/crypto/x509/root_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/x509/root_darwin_armx.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/x509/x509.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/x509/pkcs1.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/x509/root_nacl.go) => false <nil>
Ignoring test code in root_darwin_test.go
Ignoring test code in sec1_test.go
Matchfile(/usr/local/go/src/crypto/x509/root_darwin.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/x509/root_nocgo_darwin.go) => false <nil>
Ignoring test code in name_constraints_test.go
Matchfile(/usr/local/go/src/crypto/x509/root_bsd.go) => false <nil>
Ignoring test code in pem_decrypt_test.go
Matchfile(/usr/local/go/src/crypto/x509/root_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/x509/x509_test_import.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/x509/sec1.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/x509/root_linux.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/x509/root_darwin_arm_gen.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/x509/root_unix.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/x509/verify.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/x509/root_cgo_darwin.go) => false <nil>
Ignoring test code in x509_test.go
Matchfile(/usr/local/go/src/crypto/x509/root_js.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/x509/cert_pool.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/x509/pem_decrypt.go) => true <nil>
Processing package=crypto/x509:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/x509/pkix
Processing crypto/x509/pkix:
Matchfile(/usr/local/go/src/crypto/x509/pkix/pkix.go) => true <nil>
Processing package=crypto/x509/pkix:
Excluding /usr/local/go/src/crypto/x509/testdata
Walking from /usr/local/go/src to /usr/local/go/src/database
Processing database:
Walking from /usr/local/go/src to /usr/local/go/src/database/sql
Processing database/sql:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/database/sql/ctxutil.go) => true <nil>
Ignoring test code in example_cli_test.go
Ignoring test code in fakedb_test.go
Ignoring test code in convert_test.go
Matchfile(/usr/local/go/src/database/sql/convert.go) => true <nil>
Ignoring test code in sql_test.go
Matchfile(/usr/local/go/src/database/sql/sql.go) => true <nil>
Ignoring test code in example_service_test.go
Processing package=database/sql:
Walking from /usr/local/go/src to /usr/local/go/src/database/sql/driver
Processing database/sql/driver:
Ignoring test code in types_test.go
Matchfile(/usr/local/go/src/database/sql/driver/types.go) => true <nil>
Matchfile(/usr/local/go/src/database/sql/driver/driver.go) => true <nil>
Processing package=database/sql/driver:
Walking from /usr/local/go/src to /usr/local/go/src/debug
Processing debug:
Walking from /usr/local/go/src to /usr/local/go/src/debug/dwarf
Processing debug/dwarf:
Matchfile(/usr/local/go/src/debug/dwarf/buf.go) => true <nil>
Matchfile(/usr/local/go/src/debug/dwarf/open.go) => true <nil>
Matchfile(/usr/local/go/src/debug/dwarf/line.go) => true <nil>
Matchfile(/usr/local/go/src/debug/dwarf/class_string.go) => true <nil>
Matchfile(/usr/local/go/src/debug/dwarf/tag_string.go) => true <nil>
Matchfile(/usr/local/go/src/debug/dwarf/entry.go) => true <nil>
Ignoring test code in line_test.go
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/debug/dwarf/const.go) => true <nil>
Matchfile(/usr/local/go/src/debug/dwarf/unit.go) => true <nil>
Ignoring test code in type_test.go
Matchfile(/usr/local/go/src/debug/dwarf/typeunit.go) => true <nil>
Matchfile(/usr/local/go/src/debug/dwarf/type.go) => true <nil>
Ignoring test code in entry_test.go
Matchfile(/usr/local/go/src/debug/dwarf/attr_string.go) => true <nil>
Processing package=debug/dwarf:
Excluding /usr/local/go/src/debug/dwarf/testdata
Walking from /usr/local/go/src to /usr/local/go/src/debug/elf
Processing debug/elf:
Matchfile(/usr/local/go/src/debug/elf/elf.go) => true <nil>
Matchfile(/usr/local/go/src/debug/elf/reader.go) => true <nil>
Ignoring test code in symbols_test.go
Ignoring test code in elf_test.go
Matchfile(/usr/local/go/src/debug/elf/file.go) => true <nil>
Ignoring test code in file_test.go
Processing package=debug/elf:
Excluding /usr/local/go/src/debug/elf/testdata
Walking from /usr/local/go/src to /usr/local/go/src/debug/gosym
Processing debug/gosym:
Ignoring test code in symtab_test.go
Matchfile(/usr/local/go/src/debug/gosym/pclntab.go) => true <nil>
Matchfile(/usr/local/go/src/debug/gosym/symtab.go) => true <nil>
Ignoring test code in pclntab_test.go
Processing package=debug/gosym:
Excluding /usr/local/go/src/debug/gosym/testdata
Walking from /usr/local/go/src to /usr/local/go/src/debug/macho
Processing debug/macho:
Matchfile(/usr/local/go/src/debug/macho/reloctype_string.go) => true <nil>
Matchfile(/usr/local/go/src/debug/macho/reloctype.go) => true <nil>
Matchfile(/usr/local/go/src/debug/macho/fat.go) => true <nil>
Matchfile(/usr/local/go/src/debug/macho/macho.go) => true <nil>
Matchfile(/usr/local/go/src/debug/macho/file.go) => true <nil>
Ignoring test code in file_test.go
Processing package=debug/macho:
Excluding /usr/local/go/src/debug/macho/testdata
Walking from /usr/local/go/src to /usr/local/go/src/debug/pe
Processing debug/pe:
Matchfile(/usr/local/go/src/debug/pe/symbol.go) => true <nil>
Matchfile(/usr/local/go/src/debug/pe/pe.go) => true <nil>
Ignoring test code in file_cgo_test.go
Matchfile(/usr/local/go/src/debug/pe/file.go) => true <nil>
Ignoring test code in file_test.go
Matchfile(/usr/local/go/src/debug/pe/string.go) => true <nil>
Matchfile(/usr/local/go/src/debug/pe/section.go) => true <nil>
Processing package=debug/pe:
Excluding /usr/local/go/src/debug/pe/testdata
Walking from /usr/local/go/src to /usr/local/go/src/debug/plan9obj
Processing debug/plan9obj:
Matchfile(/usr/local/go/src/debug/plan9obj/file.go) => true <nil>
Ignoring test code in file_test.go
Matchfile(/usr/local/go/src/debug/plan9obj/plan9obj.go) => true <nil>
Processing package=debug/plan9obj:
Excluding /usr/local/go/src/debug/plan9obj/testdata
Walking from /usr/local/go/src to /usr/local/go/src/encoding
Processing encoding:
Matchfile(/usr/local/go/src/encoding/encoding.go) => true <nil>
Processing package=encoding:
Walking from /usr/local/go/src to /usr/local/go/src/encoding/ascii85
Processing encoding/ascii85:
Matchfile(/usr/local/go/src/encoding/ascii85/ascii85.go) => true <nil>
Ignoring test code in ascii85_test.go
Processing package=encoding/ascii85:
Walking from /usr/local/go/src to /usr/local/go/src/encoding/asn1
Processing encoding/asn1:
Matchfile(/usr/local/go/src/encoding/asn1/common.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/asn1/asn1.go) => true <nil>
Ignoring test code in asn1_test.go
Ignoring test code in marshal_test.go
Matchfile(/usr/local/go/src/encoding/asn1/marshal.go) => true <nil>
Processing package=encoding/asn1:
Walking from /usr/local/go/src to /usr/local/go/src/encoding/base32
Processing encoding/base32:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/encoding/base32/base32.go) => true <nil>
Ignoring test code in base32_test.go
Processing package=encoding/base32:
Walking from /usr/local/go/src to /usr/local/go/src/encoding/base64
Processing encoding/base64:
Matchfile(/usr/local/go/src/encoding/base64/base64.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in base64_test.go
Processing package=encoding/base64:
Walking from /usr/local/go/src to /usr/local/go/src/encoding/binary
Processing encoding/binary:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/encoding/binary/varint.go) => true <nil>
Ignoring test code in binary_test.go
Matchfile(/usr/local/go/src/encoding/binary/binary.go) => true <nil>
Ignoring test code in varint_test.go
Processing package=encoding/binary:
Walking from /usr/local/go/src to /usr/local/go/src/encoding/csv
Processing encoding/csv:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/encoding/csv/writer.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/csv/reader.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in writer_test.go
Processing package=encoding/csv:
Walking from /usr/local/go/src to /usr/local/go/src/encoding/gob
Processing encoding/gob:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/encoding/gob/enc_helpers.go) => true <nil>
Ignoring test code in encoder_test.go
Ignoring test code in gobencdec_test.go
Ignoring test code in codec_test.go
Matchfile(/usr/local/go/src/encoding/gob/decgen.go) => false <nil>
Matchfile(/usr/local/go/src/encoding/gob/dump.go) => false <nil>
Ignoring test code in example_interface_test.go
Matchfile(/usr/local/go/src/encoding/gob/decode.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/gob/error.go) => true <nil>
Ignoring test code in type_test.go
Matchfile(/usr/local/go/src/encoding/gob/encoder.go) => true <nil>
Ignoring test code in timing_test.go
Matchfile(/usr/local/go/src/encoding/gob/encode.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/gob/type.go) => true <nil>
Ignoring test code in example_encdec_test.go
Matchfile(/usr/local/go/src/encoding/gob/dec_helpers.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/gob/doc.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/gob/debug.go) => false <nil>
Matchfile(/usr/local/go/src/encoding/gob/decoder.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/gob/encgen.go) => false <nil>
Processing package=encoding/gob:
Walking from /usr/local/go/src to /usr/local/go/src/encoding/hex
Processing encoding/hex:
Ignoring test code in example_test.go
Ignoring test code in hex_test.go
Matchfile(/usr/local/go/src/encoding/hex/hex.go) => true <nil>
Processing package=encoding/hex:
Walking from /usr/local/go/src to /usr/local/go/src/encoding/json
Processing encoding/json:
Ignoring test code in number_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/encoding/json/tables.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/json/scanner.go) => true <nil>
Ignoring test code in decode_test.go
Ignoring test code in example_text_marshaling_test.go
Ignoring test code in scanner_test.go
Matchfile(/usr/local/go/src/encoding/json/fold.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/json/stream.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/json/decode.go) => true <nil>
Ignoring test code in fold_test.go
Ignoring test code in tags_test.go
Ignoring test code in stream_test.go
Matchfile(/usr/local/go/src/encoding/json/encode.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/json/tags.go) => true <nil>
Ignoring test code in tagkey_test.go
Ignoring test code in example_marshaling_test.go
Ignoring test code in bench_test.go
Ignoring test code in encode_test.go
Matchfile(/usr/local/go/src/encoding/json/indent.go) => true <nil>
Processing package=encoding/json:
Excluding /usr/local/go/src/encoding/json/testdata
Walking from /usr/local/go/src to /usr/local/go/src/encoding/pem
Processing encoding/pem:
Ignoring test code in example_test.go
Ignoring test code in pem_test.go
Matchfile(/usr/local/go/src/encoding/pem/pem.go) => true <nil>
Processing package=encoding/pem:
Walking from /usr/local/go/src to /usr/local/go/src/encoding/xml
Processing encoding/xml:
Ignoring test code in read_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/encoding/xml/typeinfo.go) => true <nil>
Ignoring test code in atom_test.go
Ignoring test code in example_text_marshaling_test.go
Ignoring test code in xml_test.go
Matchfile(/usr/local/go/src/encoding/xml/read.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/xml/xml.go) => true <nil>
Ignoring test code in marshal_test.go
Matchfile(/usr/local/go/src/encoding/xml/marshal.go) => true <nil>
Ignoring test code in example_marshaling_test.go
Processing package=encoding/xml:
Walking from /usr/local/go/src to /usr/local/go/src/errors
Processing errors:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/errors/errors.go) => true <nil>
Ignoring test code in errors_test.go
Processing package=errors:
Walking from /usr/local/go/src to /usr/local/go/src/expvar
Processing expvar:
Matchfile(/usr/local/go/src/expvar/expvar.go) => true <nil>
Ignoring test code in expvar_test.go
Processing package=expvar:
Walking from /usr/local/go/src to /usr/local/go/src/flag
Processing flag:
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Ignoring test code in example_value_test.go
Ignoring test code in flag_test.go
Matchfile(/usr/local/go/src/flag/flag.go) => true <nil>
Processing package=flag:
Walking from /usr/local/go/src to /usr/local/go/src/fmt
Processing fmt:
Matchfile(/usr/local/go/src/fmt/print.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in fmt_test.go
Ignoring test code in stringer_example_test.go
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/fmt/format.go) => true <nil>
Ignoring test code in gostringer_example_test.go
Matchfile(/usr/local/go/src/fmt/scan.go) => true <nil>
Matchfile(/usr/local/go/src/fmt/doc.go) => true <nil>
Ignoring test code in stringer_test.go
Ignoring test code in scan_test.go
Processing package=fmt:
Walking from /usr/local/go/src to /usr/local/go/src/go
Processing go:
Walking from /usr/local/go/src to /usr/local/go/src/go/ast
Processing go/ast:
Matchfile(/usr/local/go/src/go/ast/print.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/go/ast/filter.go) => true <nil>
Matchfile(/usr/local/go/src/go/ast/resolve.go) => true <nil>
Matchfile(/usr/local/go/src/go/ast/walk.go) => true <nil>
Matchfile(/usr/local/go/src/go/ast/ast.go) => true <nil>
Matchfile(/usr/local/go/src/go/ast/scope.go) => true <nil>
Ignoring test code in print_test.go
Ignoring test code in filter_test.go
Matchfile(/usr/local/go/src/go/ast/commentmap.go) => true <nil>
Ignoring test code in ast_test.go
Ignoring test code in commentmap_test.go
Matchfile(/usr/local/go/src/go/ast/import.go) => true <nil>
Processing package=go/ast:
Walking from /usr/local/go/src to /usr/local/go/src/go/build
Processing go/build:
Ignoring test code in read_test.go
Matchfile(/usr/local/go/src/go/build/read.go) => true <nil>
Ignoring test code in build_test.go
Matchfile(/usr/local/go/src/go/build/zcgo.go) => true <nil>
Matchfile(/usr/local/go/src/go/build/gc.go) => true <nil>
Ignoring test code in deps_test.go
Matchfile(/usr/local/go/src/go/build/gccgo.go) => false <nil>
Matchfile(/usr/local/go/src/go/build/doc.go) => true <nil>
Matchfile(/usr/local/go/src/go/build/build.go) => true <nil>
Matchfile(/usr/local/go/src/go/build/syslist.go) => true <nil>
Ignoring test code in syslist_test.go
Processing package=go/build:
Excluding /usr/local/go/src/go/build/testdata
Walking from /usr/local/go/src to /usr/local/go/src/go/constant
Processing go/constant:
Ignoring test code in example_test.go
Ignoring test code in value_test.go
Matchfile(/usr/local/go/src/go/constant/value.go) => true <nil>
Processing package=go/constant:
Walking from /usr/local/go/src to /usr/local/go/src/go/doc
Processing go/doc:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/go/doc/filter.go) => true <nil>
Matchfile(/usr/local/go/src/go/doc/exports.go) => true <nil>
Ignoring test code in doc_test.go
Matchfile(/usr/local/go/src/go/doc/comment.go) => true <nil>
Ignoring test code in synopsis_test.go
Matchfile(/usr/local/go/src/go/doc/reader.go) => true <nil>
Matchfile(/usr/local/go/src/go/doc/example.go) => true <nil>
Matchfile(/usr/local/go/src/go/doc/synopsis.go) => true <nil>
Ignoring test code in comment_test.go
Matchfile(/usr/local/go/src/go/doc/doc.go) => true <nil>
Matchfile(/usr/local/go/src/go/doc/lazyre.go) => true <nil>
Matchfile(/usr/local/go/src/go/doc/headscan.go) => false <nil>
Processing package=go/doc:
Excluding /usr/local/go/src/go/doc/testdata
Walking from /usr/local/go/src to /usr/local/go/src/go/format
Processing go/format:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/go/format/internal.go) => true <nil>
Matchfile(/usr/local/go/src/go/format/format.go) => true <nil>
Ignoring test code in format_test.go
Ignoring test code in benchmark_test.go
Processing package=go/format:
Walking from /usr/local/go/src to /usr/local/go/src/go/importer
Processing go/importer:
Ignoring test code in importer_test.go
Matchfile(/usr/local/go/src/go/importer/importer.go) => true <nil>
Processing package=go/importer:
Excluding /usr/local/go/src/go/internal
Walking from /usr/local/go/src to /usr/local/go/src/go/parser
Processing go/parser:
Ignoring test code in example_test.go
Ignoring test code in performance_test.go
Ignoring test code in short_test.go
Matchfile(/usr/local/go/src/go/parser/parser.go) => true <nil>
Ignoring test code in parser_test.go
Ignoring test code in error_test.go
Matchfile(/usr/local/go/src/go/parser/interface.go) => true <nil>
Processing package=go/parser:
Excluding /usr/local/go/src/go/parser/testdata
Walking from /usr/local/go/src to /usr/local/go/src/go/printer
Processing go/printer:
Matchfile(/usr/local/go/src/go/printer/printer.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in performance_test.go
Ignoring test code in printer_test.go
Matchfile(/usr/local/go/src/go/printer/nodes.go) => true <nil>
Processing package=go/printer:
Excluding /usr/local/go/src/go/printer/testdata
Walking from /usr/local/go/src to /usr/local/go/src/go/scanner
Processing go/scanner:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/go/scanner/scanner.go) => true <nil>
Ignoring test code in scanner_test.go
Matchfile(/usr/local/go/src/go/scanner/errors.go) => true <nil>
Processing package=go/scanner:
Walking from /usr/local/go/src to /usr/local/go/src/go/token
Processing go/token:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/go/token/token.go) => true <nil>
Matchfile(/usr/local/go/src/go/token/serialize.go) => true <nil>
Matchfile(/usr/local/go/src/go/token/position.go) => true <nil>
Ignoring test code in position_test.go
Ignoring test code in serialize_test.go
Processing package=go/token:
Walking from /usr/local/go/src to /usr/local/go/src/go/types
Processing go/types:
Matchfile(/usr/local/go/src/go/types/universe.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/eval.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/go/types/resolver.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/labels.go) => true <nil>
Ignoring test code in check_test.go
Ignoring test code in self_test.go
Matchfile(/usr/local/go/src/go/types/assignments.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/sizes.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/api.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/initorder.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/predicates.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/object.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/return.go) => true <nil>
Ignoring test code in exprstring_test.go
Matchfile(/usr/local/go/src/go/types/call.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/methodset.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/exprstring.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/typexpr.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/operand.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/scope.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/errors.go) => true <nil>
Ignoring test code in issues_test.go
Matchfile(/usr/local/go/src/go/types/builtins.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/expr.go) => true <nil>
Ignoring test code in typestring_test.go
Matchfile(/usr/local/go/src/go/types/lookup.go) => true <nil>
Ignoring test code in eval_test.go
Ignoring test code in builtins_test.go
Ignoring test code in hilbert_test.go
Matchfile(/usr/local/go/src/go/types/decl.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/type.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/selection.go) => true <nil>
Ignoring test code in stdlib_test.go
Matchfile(/usr/local/go/src/go/types/conversions.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/typestring.go) => true <nil>
Ignoring test code in resolver_test.go
Ignoring test code in object_test.go
Matchfile(/usr/local/go/src/go/types/interfaces.go) => true <nil>
Ignoring test code in sizes_test.go
Ignoring test code in api_test.go
Matchfile(/usr/local/go/src/go/types/check.go) => true <nil>
Ignoring test code in token_test.go
Matchfile(/usr/local/go/src/go/types/objset.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/package.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/gotype.go) => false <nil>
Matchfile(/usr/local/go/src/go/types/stmt.go) => true <nil>
Processing package=go/types:
Excluding /usr/local/go/src/go/types/testdata
Walking from /usr/local/go/src to /usr/local/go/src/hash
Processing hash:
Ignoring test code in example_test.go
Ignoring test code in marshal_test.go
Matchfile(/usr/local/go/src/hash/hash.go) => true <nil>
Processing package=hash:
Walking from /usr/local/go/src to /usr/local/go/src/hash/adler32
Processing hash/adler32:
Matchfile(/usr/local/go/src/hash/adler32/adler32.go) => true <nil>
Ignoring test code in adler32_test.go
Processing package=hash/adler32:
Walking from /usr/local/go/src to /usr/local/go/src/hash/crc32
Processing hash/crc32:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/hash/crc32/crc32_ppc64le.go) => false <nil>
Matchfile(/usr/local/go/src/hash/crc32/crc32_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/hash/crc32/crc32_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/hash/crc32/crc32_generic.go) => true <nil>
Matchfile(/usr/local/go/src/hash/crc32/gen_const_ppc64le.go) => false <nil>
Ignoring test code in crc32_test.go
Matchfile(/usr/local/go/src/hash/crc32/crc32_amd64.go) => true <nil>
Matchfile(/usr/local/go/src/hash/crc32/crc32_amd64p32.go) => false <nil>
Matchfile(/usr/local/go/src/hash/crc32/crc32_otherarch.go) => false <nil>
Matchfile(/usr/local/go/src/hash/crc32/crc32.go) => true <nil>
Processing package=hash/crc32:
Walking from /usr/local/go/src to /usr/local/go/src/hash/crc64
Processing hash/crc64:
Matchfile(/usr/local/go/src/hash/crc64/crc64.go) => true <nil>
Ignoring test code in crc64_test.go
Processing package=hash/crc64:
Walking from /usr/local/go/src to /usr/local/go/src/hash/fnv
Processing hash/fnv:
Matchfile(/usr/local/go/src/hash/fnv/fnv.go) => true <nil>
Ignoring test code in fnv_test.go
Processing package=hash/fnv:
Walking from /usr/local/go/src to /usr/local/go/src/html
Processing html:
Matchfile(/usr/local/go/src/html/escape.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in escape_test.go
Matchfile(/usr/local/go/src/html/entity.go) => true <nil>
Ignoring test code in entity_test.go
Processing package=html:
Walking from /usr/local/go/src to /usr/local/go/src/html/template
Processing html/template:
Matchfile(/usr/local/go/src/html/template/urlpart_string.go) => true <nil>
Matchfile(/usr/local/go/src/html/template/escape.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/html/template/transition.go) => true <nil>
Ignoring test code in url_test.go
Matchfile(/usr/local/go/src/html/template/content.go) => true <nil>
Matchfile(/usr/local/go/src/html/template/html.go) => true <nil>
Matchfile(/usr/local/go/src/html/template/template.go) => true <nil>
Matchfile(/usr/local/go/src/html/template/attr.go) => true <nil>
Ignoring test code in html_test.go
Ignoring test code in escape_test.go
Matchfile(/usr/local/go/src/html/template/delim_string.go) => true <nil>
Matchfile(/usr/local/go/src/html/template/context.go) => true <nil>
Matchfile(/usr/local/go/src/html/template/state_string.go) => true <nil>
Matchfile(/usr/local/go/src/html/template/url.go) => true <nil>
Ignoring test code in js_test.go
Matchfile(/usr/local/go/src/html/template/error.go) => true <nil>
Ignoring test code in template_test.go
Ignoring test code in css_test.go
Matchfile(/usr/local/go/src/html/template/doc.go) => true <nil>
Matchfile(/usr/local/go/src/html/template/jsctx_string.go) => true <nil>
Ignoring test code in transition_test.go
Matchfile(/usr/local/go/src/html/template/css.go) => true <nil>
Matchfile(/usr/local/go/src/html/template/element_string.go) => true <nil>
Ignoring test code in clone_test.go
Ignoring test code in examplefiles_test.go
Ignoring test code in content_test.go
Matchfile(/usr/local/go/src/html/template/attr_string.go) => true <nil>
Matchfile(/usr/local/go/src/html/template/js.go) => true <nil>
Processing package=html/template:
Walking from /usr/local/go/src to /usr/local/go/src/image
Processing image:
Ignoring test code in image_test.go
Ignoring test code in decode_example_test.go
Ignoring test code in decode_test.go
Ignoring test code in ycbcr_test.go
Matchfile(/usr/local/go/src/image/format.go) => true <nil>
Matchfile(/usr/local/go/src/image/ycbcr.go) => true <nil>
Ignoring test code in geom_test.go
Matchfile(/usr/local/go/src/image/names.go) => true <nil>
Matchfile(/usr/local/go/src/image/geom.go) => true <nil>
Matchfile(/usr/local/go/src/image/image.go) => true <nil>
Processing package=image:
Walking from /usr/local/go/src to /usr/local/go/src/image/color
Processing image/color:
Ignoring test code in color_test.go
Ignoring test code in ycbcr_test.go
Matchfile(/usr/local/go/src/image/color/ycbcr.go) => true <nil>
Matchfile(/usr/local/go/src/image/color/color.go) => true <nil>
Processing package=image/color:
Walking from /usr/local/go/src to /usr/local/go/src/image/color/palette
Processing image/color/palette:
Matchfile(/usr/local/go/src/image/color/palette/generate.go) => true <nil>
Matchfile(/usr/local/go/src/image/color/palette/gen.go) => false <nil>
Matchfile(/usr/local/go/src/image/color/palette/palette.go) => true <nil>
Processing package=image/color/palette:
Walking from /usr/local/go/src to /usr/local/go/src/image/draw
Processing image/draw:
Ignoring test code in example_test.go
Ignoring test code in clip_test.go
Ignoring test code in draw_test.go
Matchfile(/usr/local/go/src/image/draw/draw.go) => true <nil>
Ignoring test code in bench_test.go
Processing package=image/draw:
Walking from /usr/local/go/src to /usr/local/go/src/image/gif
Processing image/gif:
Matchfile(/usr/local/go/src/image/gif/writer.go) => true <nil>
Matchfile(/usr/local/go/src/image/gif/reader.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in writer_test.go
Processing package=image/gif:
Excluding /usr/local/go/src/image/internal
Walking from /usr/local/go/src to /usr/local/go/src/image/jpeg
Processing image/jpeg:
Matchfile(/usr/local/go/src/image/jpeg/fdct.go) => true <nil>
Matchfile(/usr/local/go/src/image/jpeg/writer.go) => true <nil>
Matchfile(/usr/local/go/src/image/jpeg/reader.go) => true <nil>
Matchfile(/usr/local/go/src/image/jpeg/scan.go) => true <nil>
Matchfile(/usr/local/go/src/image/jpeg/idct.go) => true <nil>
Matchfile(/usr/local/go/src/image/jpeg/huffman.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in dct_test.go
Ignoring test code in writer_test.go
Processing package=image/jpeg:
Walking from /usr/local/go/src to /usr/local/go/src/image/png
Processing image/png:
Ignoring test code in example_test.go
Ignoring test code in paeth_test.go
Matchfile(/usr/local/go/src/image/png/writer.go) => true <nil>
Matchfile(/usr/local/go/src/image/png/reader.go) => true <nil>
Matchfile(/usr/local/go/src/image/png/paeth.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in writer_test.go
Processing package=image/png:
Excluding /usr/local/go/src/image/png/testdata
Excluding /usr/local/go/src/image/testdata
Walking from /usr/local/go/src to /usr/local/go/src/index
Processing index:
Walking from /usr/local/go/src to /usr/local/go/src/index/suffixarray
Processing index/suffixarray:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/index/suffixarray/suffixarray.go) => true <nil>
Matchfile(/usr/local/go/src/index/suffixarray/qsufsort.go) => true <nil>
Ignoring test code in suffixarray_test.go
Processing package=index/suffixarray:
Excluding /usr/local/go/src/internal
Walking from /usr/local/go/src to /usr/local/go/src/io
Processing io:
Ignoring test code in example_test.go
Ignoring test code in multi_test.go
Ignoring test code in io_test.go
Matchfile(/usr/local/go/src/io/io.go) => true <nil>
Matchfile(/usr/local/go/src/io/multi.go) => true <nil>
Matchfile(/usr/local/go/src/io/pipe.go) => true <nil>
Ignoring test code in pipe_test.go
Processing package=io:
Walking from /usr/local/go/src to /usr/local/go/src/io/ioutil
Processing io/ioutil:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/io/ioutil/ioutil.go) => true <nil>
Ignoring test code in ioutil_test.go
Matchfile(/usr/local/go/src/io/ioutil/tempfile.go) => true <nil>
Ignoring test code in tempfile_test.go
Processing package=io/ioutil:
Excluding /usr/local/go/src/io/ioutil/testdata
Walking from /usr/local/go/src to /usr/local/go/src/log
Processing log:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/log/log.go) => true <nil>
Ignoring test code in log_test.go
Processing package=log:
Walking from /usr/local/go/src to /usr/local/go/src/log/syslog
Processing log/syslog:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/log/syslog/syslog.go) => true <nil>
Ignoring test code in syslog_test.go
Matchfile(/usr/local/go/src/log/syslog/doc.go) => true <nil>
Matchfile(/usr/local/go/src/log/syslog/syslog_unix.go) => true <nil>
Processing package=log/syslog:
Walking from /usr/local/go/src to /usr/local/go/src/math
Processing math:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/math/pow.go) => true <nil>
Ignoring test code in huge_test.go
Matchfile(/usr/local/go/src/math/expm1.go) => true <nil>
Matchfile(/usr/local/go/src/math/jn.go) => true <nil>
Matchfile(/usr/local/go/src/math/acosh.go) => true <nil>
Matchfile(/usr/local/go/src/math/j0.go) => true <nil>
Matchfile(/usr/local/go/src/math/floor.go) => true <nil>
Matchfile(/usr/local/go/src/math/unsafe.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/math/sincos.go) => true <nil>
Matchfile(/usr/local/go/src/math/erfinv.go) => true <nil>
Ignoring test code in all_test.go
Ignoring test code in export_s390x_test.go
Matchfile(/usr/local/go/src/math/const.go) => true <nil>
Matchfile(/usr/local/go/src/math/log.go) => true <nil>
Matchfile(/usr/local/go/src/math/lgamma.go) => true <nil>
Matchfile(/usr/local/go/src/math/atanh.go) => true <nil>
Matchfile(/usr/local/go/src/math/j1.go) => true <nil>
Matchfile(/usr/local/go/src/math/erf.go) => true <nil>
Matchfile(/usr/local/go/src/math/exp_asm.go) => true <nil>
Matchfile(/usr/local/go/src/math/pow10.go) => true <nil>
Matchfile(/usr/local/go/src/math/ldexp.go) => true <nil>
Matchfile(/usr/local/go/src/math/atan.go) => true <nil>
Matchfile(/usr/local/go/src/math/copysign.go) => true <nil>
Matchfile(/usr/local/go/src/math/exp.go) => true <nil>
Matchfile(/usr/local/go/src/math/modf.go) => true <nil>
Matchfile(/usr/local/go/src/math/asinh.go) => true <nil>
Matchfile(/usr/local/go/src/math/sqrt.go) => true <nil>
Matchfile(/usr/local/go/src/math/asin.go) => true <nil>
Matchfile(/usr/local/go/src/math/hypot.go) => true <nil>
Matchfile(/usr/local/go/src/math/signbit.go) => true <nil>
Matchfile(/usr/local/go/src/math/abs.go) => true <nil>
Matchfile(/usr/local/go/src/math/tan.go) => true <nil>
Matchfile(/usr/local/go/src/math/arith_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/math/frexp.go) => true <nil>
Matchfile(/usr/local/go/src/math/bits.go) => true <nil>
Matchfile(/usr/local/go/src/math/log1p.go) => true <nil>
Matchfile(/usr/local/go/src/math/nextafter.go) => true <nil>
Matchfile(/usr/local/go/src/math/logb.go) => true <nil>
Matchfile(/usr/local/go/src/math/gamma.go) => true <nil>
Matchfile(/usr/local/go/src/math/log10.go) => true <nil>
Matchfile(/usr/local/go/src/math/dim.go) => true <nil>
Ignoring test code in arith_s390x_test.go
Matchfile(/usr/local/go/src/math/remainder.go) => true <nil>
Matchfile(/usr/local/go/src/math/trig_reduce.go) => true <nil>
Matchfile(/usr/local/go/src/math/mod.go) => true <nil>
Matchfile(/usr/local/go/src/math/sin.go) => true <nil>
Matchfile(/usr/local/go/src/math/tanh.go) => true <nil>
Matchfile(/usr/local/go/src/math/sinh.go) => true <nil>
Matchfile(/usr/local/go/src/math/atan2.go) => true <nil>
Matchfile(/usr/local/go/src/math/cbrt.go) => true <nil>
Processing package=math:
Walking from /usr/local/go/src to /usr/local/go/src/math/big
Processing math/big:
Matchfile(/usr/local/go/src/math/big/arith_decl_pure.go) => false <nil>
Ignoring test code in example_test.go
Ignoring test code in prime_test.go
Matchfile(/usr/local/go/src/math/big/intmarsh.go) => true <nil>
Matchfile(/usr/local/go/src/math/big/floatmarsh.go) => true <nil>
Matchfile(/usr/local/go/src/math/big/arith_decl.go) => true <nil>
Ignoring test code in example_rat_test.go
Ignoring test code in float_test.go
Matchfile(/usr/local/go/src/math/big/accuracy_string.go) => true <nil>
Ignoring test code in bits_test.go
Ignoring test code in natconv_test.go
Matchfile(/usr/local/go/src/math/big/natconv.go) => true <nil>
Matchfile(/usr/local/go/src/math/big/arith.go) => true <nil>
Ignoring test code in floatexample_test.go
Matchfile(/usr/local/go/src/math/big/arith_amd64.go) => true <nil>
Ignoring test code in intmarsh_test.go
Ignoring test code in floatconv_test.go
Ignoring test code in int_test.go
Matchfile(/usr/local/go/src/math/big/roundingmode_string.go) => true <nil>
Matchfile(/usr/local/go/src/math/big/prime.go) => true <nil>
Matchfile(/usr/local/go/src/math/big/ftoa.go) => true <nil>
Matchfile(/usr/local/go/src/math/big/sqrt.go) => true <nil>
Ignoring test code in arith_test.go
Matchfile(/usr/local/go/src/math/big/int.go) => true <nil>
Matchfile(/usr/local/go/src/math/big/arith_decl_s390x.go) => false <nil>
Ignoring test code in nat_test.go
Ignoring test code in hilbert_test.go
Ignoring test code in calibrate_test.go
Matchfile(/usr/local/go/src/math/big/intconv.go) => true <nil>
Ignoring test code in floatmarsh_test.go
Matchfile(/usr/local/go/src/math/big/nat.go) => true <nil>
Matchfile(/usr/local/go/src/math/big/doc.go) => true <nil>
Ignoring test code in gcd_test.go
Matchfile(/usr/local/go/src/math/big/rat.go) => true <nil>
Ignoring test code in arith_s390x_test.go
Matchfile(/usr/local/go/src/math/big/floatconv.go) => true <nil>
Ignoring test code in sqrt_test.go
Matchfile(/usr/local/go/src/math/big/float.go) => true <nil>
Ignoring test code in ratmarsh_test.go
Matchfile(/usr/local/go/src/math/big/ratconv.go) => true <nil>
Matchfile(/usr/local/go/src/math/big/decimal.go) => true <nil>
Ignoring test code in intconv_test.go
Ignoring test code in rat_test.go
Matchfile(/usr/local/go/src/math/big/ratmarsh.go) => true <nil>
Ignoring test code in ratconv_test.go
Ignoring test code in decimal_test.go
Processing package=math/big:
Walking from /usr/local/go/src to /usr/local/go/src/math/bits
Processing math/bits:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/math/bits/make_tables.go) => false <nil>
Ignoring test code in bits_test.go
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/math/bits/bits_tables.go) => true <nil>
Matchfile(/usr/local/go/src/math/bits/make_examples.go) => false <nil>
Matchfile(/usr/local/go/src/math/bits/bits.go) => true <nil>
Processing package=math/bits:
Walking from /usr/local/go/src to /usr/local/go/src/math/cmplx
Processing math/cmplx:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/math/cmplx/pow.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/isinf.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/polar.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/log.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/phase.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/conj.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/exp.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/sqrt.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/asin.go) => true <nil>
Ignoring test code in cmath_test.go
Matchfile(/usr/local/go/src/math/cmplx/abs.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/tan.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/sin.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/rect.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/isnan.go) => true <nil>
Processing package=math/cmplx:
Walking from /usr/local/go/src to /usr/local/go/src/math/rand
Processing math/rand:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/math/rand/gen_cooked.go) => false <nil>
Ignoring test code in race_test.go
Ignoring test code in regress_test.go
Matchfile(/usr/local/go/src/math/rand/exp.go) => true <nil>
Matchfile(/usr/local/go/src/math/rand/rand.go) => true <nil>
Matchfile(/usr/local/go/src/math/rand/normal.go) => true <nil>
Matchfile(/usr/local/go/src/math/rand/zipf.go) => true <nil>
Ignoring test code in rand_test.go
Matchfile(/usr/local/go/src/math/rand/rng.go) => true <nil>
Processing package=math/rand:
Walking from /usr/local/go/src to /usr/local/go/src/mime
Processing mime:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/mime/type_openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/mime/type_dragonfly.go) => false <nil>
Ignoring test code in type_test.go
Matchfile(/usr/local/go/src/mime/type_freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/mime/mediatype.go) => true <nil>
Ignoring test code in encodedword_test.go
Matchfile(/usr/local/go/src/mime/type.go) => true <nil>
Ignoring test code in mediatype_test.go
Matchfile(/usr/local/go/src/mime/type_windows.go) => false <nil>
Matchfile(/usr/local/go/src/mime/type_unix.go) => true <nil>
Matchfile(/usr/local/go/src/mime/grammar.go) => true <nil>
Matchfile(/usr/local/go/src/mime/type_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/mime/encodedword.go) => true <nil>
Processing package=mime:
Walking from /usr/local/go/src to /usr/local/go/src/mime/multipart
Processing mime/multipart:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/mime/multipart/multipart.go) => true <nil>
Matchfile(/usr/local/go/src/mime/multipart/writer.go) => true <nil>
Matchfile(/usr/local/go/src/mime/multipart/formdata.go) => true <nil>
Ignoring test code in formdata_test.go
Ignoring test code in multipart_test.go
Ignoring test code in writer_test.go
Processing package=mime/multipart:
Excluding /usr/local/go/src/mime/multipart/testdata
Walking from /usr/local/go/src to /usr/local/go/src/mime/quotedprintable
Processing mime/quotedprintable:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/mime/quotedprintable/writer.go) => true <nil>
Matchfile(/usr/local/go/src/mime/quotedprintable/reader.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in writer_test.go
Processing package=mime/quotedprintable:
Excluding /usr/local/go/src/mime/testdata
Walking from /usr/local/go/src to /usr/local/go/src/net
Processing net:
Ignoring test code in nss_test.go
Matchfile(/usr/local/go/src/net/cgo_netbsd.go) => false <nil>
Ignoring test code in conn_test.go
Matchfile(/usr/local/go/src/net/udpsock_plan9.go) => false <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/net/parse.go) => true <nil>
Matchfile(/usr/local/go/src/net/sockopt_plan9.go) => false <nil>
Ignoring test code in timeout_test.go
Ignoring test code in hosts_test.go
Ignoring test code in port_test.go
Matchfile(/usr/local/go/src/net/sockopt_linux.go) => true <nil>
Matchfile(/usr/local/go/src/net/ip.go) => true <nil>
Matchfile(/usr/local/go/src/net/sock_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/sockopt_solaris.go) => false <nil>
Ignoring test code in parse_test.go
Matchfile(/usr/local/go/src/net/cgo_resold.go) => false <nil>
Ignoring test code in lookup_windows_test.go
Matchfile(/usr/local/go/src/net/udpsock_posix.go) => true <nil>
Matchfile(/usr/local/go/src/net/splice_linux.go) => true <nil>
Matchfile(/usr/local/go/src/net/sockaddr_posix.go) => true <nil>
Matchfile(/usr/local/go/src/net/interface_stub.go) => false <nil>
Matchfile(/usr/local/go/src/net/sockoptip_posix.go) => true <nil>
Matchfile(/usr/local/go/src/net/cgo_bsd.go) => false <nil>
Matchfile(/usr/local/go/src/net/lookup_windows.go) => false <nil>
Ignoring test code in protoconn_test.go
Matchfile(/usr/local/go/src/net/tcpsock_posix.go) => true <nil>
Matchfile(/usr/local/go/src/net/hook_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/sendfile_unix_alt.go) => false <nil>
Matchfile(/usr/local/go/src/net/dnsclient_unix.go) => true <nil>
Ignoring test code in udpsock_plan9_test.go
Matchfile(/usr/local/go/src/net/file_stub.go) => false <nil>
Ignoring test code in dnsclient_unix_test.go
Matchfile(/usr/local/go/src/net/interface_bsd.go) => false <nil>
Ignoring test code in lookup_test.go
Ignoring test code in interface_bsd_test.go
Ignoring test code in interface_test.go
Matchfile(/usr/local/go/src/net/cgo_unix.go) => true <nil>
Ignoring test code in error_posix_test.go
Matchfile(/usr/local/go/src/net/tcpsock.go) => true <nil>
Matchfile(/usr/local/go/src/net/cgo_socknew.go) => true <nil>
Matchfile(/usr/local/go/src/net/ipsock_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/fd_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/conf.go) => true <nil>
Matchfile(/usr/local/go/src/net/fd_windows.go) => false <nil>
Matchfile(/usr/local/go/src/net/sock_cloexec.go) => true <nil>
Ignoring test code in listen_test.go
Matchfile(/usr/local/go/src/net/sockopt_aix.go) => false <nil>
Ignoring test code in ip_test.go
Matchfile(/usr/local/go/src/net/error_nacl.go) => false <nil>
Matchfile(/usr/local/go/src/net/cgo_windows.go) => false <nil>
Matchfile(/usr/local/go/src/net/tcpsockopt_dragonfly.go) => false <nil>
Ignoring test code in main_cloexec_test.go
Ignoring test code in main_posix_test.go
Ignoring test code in main_unix_test.go
Matchfile(/usr/local/go/src/net/nss.go) => true <nil>
Ignoring test code in net_test.go
Matchfile(/usr/local/go/src/net/error_posix.go) => true <nil>
Matchfile(/usr/local/go/src/net/interface_linux.go) => true <nil>
Matchfile(/usr/local/go/src/net/fd_unix.go) => true <nil>
Ignoring test code in main_windows_test.go
Matchfile(/usr/local/go/src/net/sendfile_windows.go) => false <nil>
Matchfile(/usr/local/go/src/net/lookup_fake.go) => false <nil>
Matchfile(/usr/local/go/src/net/port_unix.go) => true <nil>
Matchfile(/usr/local/go/src/net/tcpsockopt_unix.go) => true <nil>
Matchfile(/usr/local/go/src/net/net.go) => true <nil>
Matchfile(/usr/local/go/src/net/tcpsockopt_openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/net/interface_freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/net/file_unix.go) => true <nil>
Matchfile(/usr/local/go/src/net/addrselect.go) => true <nil>
Matchfile(/usr/local/go/src/net/rawconn.go) => true <nil>
Matchfile(/usr/local/go/src/net/tcpsockopt_posix.go) => true <nil>
Matchfile(/usr/local/go/src/net/conf_netcgo.go) => false <nil>
Matchfile(/usr/local/go/src/net/sockoptip_linux.go) => true <nil>
Matchfile(/usr/local/go/src/net/hook.go) => true <nil>
Matchfile(/usr/local/go/src/net/iprawsock_posix.go) => true <nil>
Ignoring test code in main_noconf_test.go
Matchfile(/usr/local/go/src/net/sockoptip_windows.go) => false <nil>
Ignoring test code in mac_test.go
Matchfile(/usr/local/go/src/net/cgo_sockold.go) => false <nil>
Matchfile(/usr/local/go/src/net/sys_cloexec.go) => false <nil>
Ignoring test code in interface_unix_test.go
Ignoring test code in dial_unix_test.go
Matchfile(/usr/local/go/src/net/tcpsockopt_darwin.go) => false <nil>
Ignoring test code in rawconn_stub_test.go
Matchfile(/usr/local/go/src/net/interface_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/net/tcpsockopt_solaris.go) => false <nil>
Ignoring test code in error_plan9_test.go
Ignoring test code in interface_linux_test.go
Ignoring test code in writev_test.go
Ignoring test code in rawconn_test.go
Matchfile(/usr/local/go/src/net/sendfile_linux.go) => true <nil>
Matchfile(/usr/local/go/src/net/cgo_stub.go) => false <nil>
Ignoring test code in mockserver_test.go
Matchfile(/usr/local/go/src/net/sockopt_posix.go) => true <nil>
Ignoring test code in platform_test.go
Ignoring test code in tcpsock_test.go
Matchfile(/usr/local/go/src/net/unixsock.go) => true <nil>
Matchfile(/usr/local/go/src/net/hook_windows.go) => false <nil>
Ignoring test code in dial_test.go
Matchfile(/usr/local/go/src/net/lookup.go) => true <nil>
Ignoring test code in conf_test.go
Ignoring test code in rawconn_windows_test.go
Matchfile(/usr/local/go/src/net/sendfile_stub.go) => false <nil>
Matchfile(/usr/local/go/src/net/sock_linux.go) => true <nil>
Matchfile(/usr/local/go/src/net/splice_stub.go) => false <nil>
Matchfile(/usr/local/go/src/net/hosts.go) => true <nil>
Matchfile(/usr/local/go/src/net/tcpsock_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/error_plan9.go) => false <nil>
Ignoring test code in cgo_unix_test.go
Ignoring test code in server_test.go
Matchfile(/usr/local/go/src/net/port.go) => true <nil>
Matchfile(/usr/local/go/src/net/lookup_unix.go) => true <nil>
Matchfile(/usr/local/go/src/net/lookup_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/mac.go) => true <nil>
Matchfile(/usr/local/go/src/net/interface_aix.go) => false <nil>
Ignoring test code in error_windows_test.go
Matchfile(/usr/local/go/src/net/tcpsockopt_windows.go) => false <nil>
Matchfile(/usr/local/go/src/net/sock_stub.go) => false <nil>
Matchfile(/usr/local/go/src/net/ipsock_posix.go) => true <nil>
Matchfile(/usr/local/go/src/net/error_windows.go) => false <nil>
Matchfile(/usr/local/go/src/net/cgo_linux.go) => true <nil>
Matchfile(/usr/local/go/src/net/tcpsockopt_stub.go) => false <nil>
Matchfile(/usr/local/go/src/net/interface_windows.go) => false <nil>
Ignoring test code in main_plan9_test.go
Ignoring test code in main_conf_test.go
Matchfile(/usr/local/go/src/net/file.go) => true <nil>
Matchfile(/usr/local/go/src/net/interface_darwin.go) => false <nil>
Matchfile(/usr/local/go/src/net/dnsconfig_unix.go) => true <nil>
Matchfile(/usr/local/go/src/net/interface_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/iprawsock_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/writev_unix.go) => true <nil>
Matchfile(/usr/local/go/src/net/sockopt_windows.go) => false <nil>
Ignoring test code in write_unix_test.go
Ignoring test code in dnsname_test.go
Ignoring test code in ipsock_test.go
Ignoring test code in file_test.go
Ignoring test code in splice_test.go
Matchfile(/usr/local/go/src/net/net_fake.go) => false <nil>
Ignoring test code in main_test.go
Ignoring test code in external_test.go
Matchfile(/usr/local/go/src/net/sock_windows.go) => false <nil>
Matchfile(/usr/local/go/src/net/cgo_resnew.go) => true <nil>
Matchfile(/usr/local/go/src/net/cgo_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/net/file_windows.go) => false <nil>
Matchfile(/usr/local/go/src/net/cgo_android.go) => false <nil>
Matchfile(/usr/local/go/src/net/interface_bsdvar.go) => false <nil>
Ignoring test code in dnsclient_test.go
Ignoring test code in packetconn_test.go
Matchfile(/usr/local/go/src/net/tcpsockopt_plan9.go) => false <nil>
Ignoring test code in iprawsock_test.go
Ignoring test code in netgo_unix_test.go
Matchfile(/usr/local/go/src/net/cgo_openbsd.go) => false <nil>
Ignoring test code in udpsock_test.go
Matchfile(/usr/local/go/src/net/dial.go) => true <nil>
Ignoring test code in unixsock_test.go
Matchfile(/usr/local/go/src/net/sockoptip_bsdvar.go) => false <nil>
Ignoring test code in addrselect_test.go
Matchfile(/usr/local/go/src/net/sock_bsd.go) => false <nil>
Ignoring test code in dnsconfig_unix_test.go
Ignoring test code in tcpsock_unix_test.go
Ignoring test code in error_test.go
Matchfile(/usr/local/go/src/net/interface.go) => true <nil>
Matchfile(/usr/local/go/src/net/unixsock_posix.go) => true <nil>
Matchfile(/usr/local/go/src/net/hook_unix.go) => true <nil>
Matchfile(/usr/local/go/src/net/udpsock.go) => true <nil>
Matchfile(/usr/local/go/src/net/sockopt_stub.go) => false <nil>
Ignoring test code in sendfile_test.go
Ignoring test code in error_unix_test.go
Matchfile(/usr/local/go/src/net/dnsclient.go) => true <nil>
Matchfile(/usr/local/go/src/net/unixsock_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/pipe.go) => true <nil>
Matchfile(/usr/local/go/src/net/sockoptip_stub.go) => false <nil>
Ignoring test code in net_windows_test.go
Ignoring test code in pipe_test.go
Ignoring test code in rawconn_unix_test.go
Matchfile(/usr/local/go/src/net/sock_posix.go) => true <nil>
Matchfile(/usr/local/go/src/net/file_plan9.go) => false <nil>
Ignoring test code in unixsock_linux_test.go
Ignoring test code in unixsock_windows_test.go
Matchfile(/usr/local/go/src/net/iprawsock.go) => true <nil>
Matchfile(/usr/local/go/src/net/ipsock.go) => true <nil>
Matchfile(/usr/local/go/src/net/sockopt_bsd.go) => false <nil>
Matchfile(/usr/local/go/src/net/error_unix.go) => true <nil>
Processing package=net:
Walking from /usr/local/go/src to /usr/local/go/src/net/http
Processing net/http:
Matchfile(/usr/local/go/src/net/http/http.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/net/http/roundtrip.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/response.go) => true <nil>
Ignoring test code in response_test.go
Ignoring test code in npn_test.go
Matchfile(/usr/local/go/src/net/http/socks_bundle.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/method.go) => true <nil>
Ignoring test code in example_filesystem_test.go
Matchfile(/usr/local/go/src/net/http/transport.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/status.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/h2_bundle.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/roundtrip_js.go) => false <nil>
Ignoring test code in transfer_test.go
Matchfile(/usr/local/go/src/net/http/cookie.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/transfer.go) => true <nil>
Ignoring test code in export_test.go
Ignoring test code in requestwrite_test.go
Ignoring test code in header_test.go
Ignoring test code in fs_test.go
Matchfile(/usr/local/go/src/net/http/fs.go) => true <nil>
Ignoring test code in readrequest_test.go
Ignoring test code in filetransport_test.go
Matchfile(/usr/local/go/src/net/http/request.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/server.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/client.go) => true <nil>
Ignoring test code in transport_internal_test.go
Ignoring test code in cookie_test.go
Ignoring test code in transport_test.go
Matchfile(/usr/local/go/src/net/http/sniff.go) => true <nil>
Ignoring test code in proxy_test.go
Ignoring test code in server_test.go
Ignoring test code in http_test.go
Matchfile(/usr/local/go/src/net/http/doc.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/jar.go) => true <nil>
Ignoring test code in example_handle_test.go
Ignoring test code in main_test.go
Ignoring test code in range_test.go
Ignoring test code in request_test.go
Matchfile(/usr/local/go/src/net/http/header.go) => true <nil>
Ignoring test code in clientserver_test.go
Matchfile(/usr/local/go/src/net/http/triv.go) => false <nil>
Matchfile(/usr/local/go/src/net/http/filetransport.go) => true <nil>
Ignoring test code in responsewrite_test.go
Ignoring test code in serve_test.go
Ignoring test code in client_test.go
Ignoring test code in sniff_test.go
Processing package=net/http:
Walking from /usr/local/go/src to /usr/local/go/src/net/http/cgi
Processing net/http/cgi:
Ignoring test code in plan9_test.go
Ignoring test code in host_test.go
Ignoring test code in posix_test.go
Matchfile(/usr/local/go/src/net/http/cgi/child.go) => true <nil>
Ignoring test code in matryoshka_test.go
Matchfile(/usr/local/go/src/net/http/cgi/host.go) => true <nil>
Ignoring test code in child_test.go
Processing package=net/http/cgi:
Excluding /usr/local/go/src/net/http/cgi/testdata
Walking from /usr/local/go/src to /usr/local/go/src/net/http/cookiejar
Processing net/http/cookiejar:
Ignoring test code in example_test.go
Ignoring test code in dummy_publicsuffix_test.go
Ignoring test code in jar_test.go
Matchfile(/usr/local/go/src/net/http/cookiejar/punycode.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/cookiejar/jar.go) => true <nil>
Ignoring test code in punycode_test.go
Processing package=net/http/cookiejar:
Walking from /usr/local/go/src to /usr/local/go/src/net/http/fcgi
Processing net/http/fcgi:
Ignoring test code in fcgi_test.go
Matchfile(/usr/local/go/src/net/http/fcgi/fcgi.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/fcgi/child.go) => true <nil>
Processing package=net/http/fcgi:
Walking from /usr/local/go/src to /usr/local/go/src/net/http/httptest
Processing net/http/httptest:
Matchfile(/usr/local/go/src/net/http/httptest/httptest.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in httptest_test.go
Matchfile(/usr/local/go/src/net/http/httptest/server.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/httptest/recorder.go) => true <nil>
Ignoring test code in server_test.go
Ignoring test code in recorder_test.go
Processing package=net/http/httptest:
Walking from /usr/local/go/src to /usr/local/go/src/net/http/httptrace
Processing net/http/httptrace:
Ignoring test code in example_test.go
Ignoring test code in trace_test.go
Matchfile(/usr/local/go/src/net/http/httptrace/trace.go) => true <nil>
Processing package=net/http/httptrace:
Walking from /usr/local/go/src to /usr/local/go/src/net/http/httputil
Processing net/http/httputil:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/net/http/httputil/dump.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/httputil/reverseproxy.go) => true <nil>
Ignoring test code in dump_test.go
Matchfile(/usr/local/go/src/net/http/httputil/persist.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/httputil/httputil.go) => true <nil>
Ignoring test code in reverseproxy_test.go
Processing package=net/http/httputil:
Excluding /usr/local/go/src/net/http/internal
Walking from /usr/local/go/src to /usr/local/go/src/net/http/pprof
Processing net/http/pprof:
Ignoring test code in pprof_test.go
Matchfile(/usr/local/go/src/net/http/pprof/pprof.go) => true <nil>
Processing package=net/http/pprof:
Excluding /usr/local/go/src/net/http/testdata
Excluding /usr/local/go/src/net/internal
Walking from /usr/local/go/src to /usr/local/go/src/net/mail
Processing net/mail:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/net/mail/message.go) => true <nil>
Ignoring test code in message_test.go
Processing package=net/mail:
Walking from /usr/local/go/src to /usr/local/go/src/net/rpc
Processing net/rpc:
Matchfile(/usr/local/go/src/net/rpc/server.go) => true <nil>
Matchfile(/usr/local/go/src/net/rpc/client.go) => true <nil>
Ignoring test code in server_test.go
Matchfile(/usr/local/go/src/net/rpc/debug.go) => true <nil>
Ignoring test code in client_test.go
Processing package=net/rpc:
Walking from /usr/local/go/src to /usr/local/go/src/net/rpc/jsonrpc
Processing net/rpc/jsonrpc:
Ignoring test code in all_test.go
Matchfile(/usr/local/go/src/net/rpc/jsonrpc/server.go) => true <nil>
Matchfile(/usr/local/go/src/net/rpc/jsonrpc/client.go) => true <nil>
Processing package=net/rpc/jsonrpc:
Walking from /usr/local/go/src to /usr/local/go/src/net/smtp
Processing net/smtp:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/net/smtp/smtp.go) => true <nil>
Matchfile(/usr/local/go/src/net/smtp/auth.go) => true <nil>
Ignoring test code in smtp_test.go
Processing package=net/smtp:
Excluding /usr/local/go/src/net/testdata
Walking from /usr/local/go/src to /usr/local/go/src/net/textproto
Processing net/textproto:
Matchfile(/usr/local/go/src/net/textproto/writer.go) => true <nil>
Matchfile(/usr/local/go/src/net/textproto/reader.go) => true <nil>
Matchfile(/usr/local/go/src/net/textproto/pipeline.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(/usr/local/go/src/net/textproto/header.go) => true <nil>
Matchfile(/usr/local/go/src/net/textproto/textproto.go) => true <nil>
Ignoring test code in writer_test.go
Processing package=net/textproto:
Walking from /usr/local/go/src to /usr/local/go/src/net/url
Processing net/url:
Ignoring test code in example_test.go
Ignoring test code in url_test.go
Matchfile(/usr/local/go/src/net/url/url.go) => true <nil>
Processing package=net/url:
Walking from /usr/local/go/src to /usr/local/go/src/os
Processing os:
Ignoring test code in fifo_test.go
Ignoring test code in path_windows_test.go
Ignoring test code in executable_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/os/stat_unix.go) => true <nil>
Ignoring test code in export_windows_test.go
Ignoring test code in timeout_test.go
Matchfile(/usr/local/go/src/os/stat_windows.go) => false <nil>
Matchfile(/usr/local/go/src/os/wait_waitid.go) => true <nil>
Matchfile(/usr/local/go/src/os/exec_unix.go) => true <nil>
Matchfile(/usr/local/go/src/os/types_unix.go) => true <nil>
Matchfile(/usr/local/go/src/os/sys_aix.go) => false <nil>
Matchfile(/usr/local/go/src/os/exec_posix.go) => true <nil>
Ignoring test code in os_test.go
Matchfile(/usr/local/go/src/os/env_windows.go) => false <nil>
Ignoring test code in removeall_test.go
Matchfile(/usr/local/go/src/os/removeall_noat.go) => false <nil>
Ignoring test code in os_windows_test.go
Matchfile(/usr/local/go/src/os/file_posix.go) => true <nil>
Matchfile(/usr/local/go/src/os/stat_solaris.go) => false <nil>
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/os/sys_js.go) => false <nil>
Matchfile(/usr/local/go/src/os/pipe2_bsd.go) => false <nil>
Ignoring test code in path_test.go
Matchfile(/usr/local/go/src/os/stat.go) => true <nil>
Matchfile(/usr/local/go/src/os/proc.go) => true <nil>
Matchfile(/usr/local/go/src/os/dir_unix.go) => true <nil>
Matchfile(/usr/local/go/src/os/path_windows.go) => false <nil>
Matchfile(/usr/local/go/src/os/error_posix.go) => true <nil>
Matchfile(/usr/local/go/src/os/executable.go) => true <nil>
Matchfile(/usr/local/go/src/os/sys_nacl.go) => false <nil>
Matchfile(/usr/local/go/src/os/file_unix.go) => true <nil>
Matchfile(/usr/local/go/src/os/stat_aix.go) => false <nil>
Matchfile(/usr/local/go/src/os/rawconn.go) => true <nil>
Matchfile(/usr/local/go/src/os/types.go) => true <nil>
Matchfile(/usr/local/go/src/os/env_default.go) => true <nil>
Matchfile(/usr/local/go/src/os/sys.go) => true <nil>
Matchfile(/usr/local/go/src/os/executable_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/os/error.go) => true <nil>
Ignoring test code in rawconn_test.go
Matchfile(/usr/local/go/src/os/sys_linux.go) => true <nil>
Matchfile(/usr/local/go/src/os/path.go) => true <nil>
Matchfile(/usr/local/go/src/os/getwd.go) => true <nil>
Matchfile(/usr/local/go/src/os/stat_freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/os/executable_darwin.go) => false <nil>
Matchfile(/usr/local/go/src/os/stat_openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/os/exec.go) => true <nil>
Matchfile(/usr/local/go/src/os/removeall_at.go) => true <nil>
Ignoring test code in stat_test.go
Matchfile(/usr/local/go/src/os/executable_procfs.go) => true <nil>
Matchfile(/usr/local/go/src/os/sticky_notbsd.go) => true <nil>
Ignoring test code in env_unix_test.go
Matchfile(/usr/local/go/src/os/executable_path.go) => false <nil>
Matchfile(/usr/local/go/src/os/error_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/os/wait_unimp.go) => false <nil>
Matchfile(/usr/local/go/src/os/sys_unix.go) => true <nil>
Matchfile(/usr/local/go/src/os/stat_nacljs.go) => false <nil>
Matchfile(/usr/local/go/src/os/env.go) => true <nil>
Ignoring test code in error_windows_test.go
Matchfile(/usr/local/go/src/os/stat_darwin.go) => false <nil>
Matchfile(/usr/local/go/src/os/dir_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/os/types_windows.go) => false <nil>
Matchfile(/usr/local/go/src/os/error_windows.go) => false <nil>
Matchfile(/usr/local/go/src/os/executable_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/os/file.go) => true <nil>
Ignoring test code in export_unix_test.go
Matchfile(/usr/local/go/src/os/wait_wait6.go) => false <nil>
Matchfile(/usr/local/go/src/os/executable_freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/os/pipe_bsd.go) => false <nil>
Matchfile(/usr/local/go/src/os/sys_bsd.go) => false <nil>
Matchfile(/usr/local/go/src/os/sys_windows.go) => false <nil>
Matchfile(/usr/local/go/src/os/types_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/os/sticky_bsd.go) => false <nil>
Matchfile(/usr/local/go/src/os/stat_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/os/file_windows.go) => false <nil>
Matchfile(/usr/local/go/src/os/pipe_linux.go) => true <nil>
Matchfile(/usr/local/go/src/os/sys_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/os/dir_ios.go) => false <nil>
Ignoring test code in os_unix_test.go
Ignoring test code in error_test.go
Matchfile(/usr/local/go/src/os/path_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/os/exec_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/os/path_unix.go) => true <nil>
Matchfile(/usr/local/go/src/os/exec_windows.go) => false <nil>
Matchfile(/usr/local/go/src/os/executable_windows.go) => false <nil>
Ignoring test code in error_unix_test.go
Matchfile(/usr/local/go/src/os/stat_netbsd.go) => false <nil>
Matchfile(/usr/local/go/src/os/getwd_darwin.go) => false <nil>
Matchfile(/usr/local/go/src/os/dir_windows.go) => false <nil>
Ignoring test code in pipe_test.go
Matchfile(/usr/local/go/src/os/stat_dragonfly.go) => false <nil>
Matchfile(/usr/local/go/src/os/file_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/os/sys_solaris.go) => false <nil>
Ignoring test code in env_test.go
Matchfile(/usr/local/go/src/os/str.go) => true <nil>
Matchfile(/usr/local/go/src/os/stat_linux.go) => true <nil>
Matchfile(/usr/local/go/src/os/error_unix.go) => true <nil>
Matchfile(/usr/local/go/src/os/dir.go) => true <nil>
Processing package=os:
Walking from /usr/local/go/src to /usr/local/go/src/os/exec
Processing os/exec:
Ignoring test code in internal_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/os/exec/exec_unix.go) => true <nil>
Ignoring test code in lp_windows_test.go
Matchfile(/usr/local/go/src/os/exec/lp_plan9.go) => false <nil>
Ignoring test code in lp_unix_test.go
Matchfile(/usr/local/go/src/os/exec/lp_windows.go) => false <nil>
Ignoring test code in exec_test.go
Matchfile(/usr/local/go/src/os/exec/exec.go) => true <nil>
Matchfile(/usr/local/go/src/os/exec/lp_js.go) => false <nil>
Ignoring test code in exec_posix_test.go
Ignoring test code in lp_test.go
Matchfile(/usr/local/go/src/os/exec/exec_windows.go) => false <nil>
Matchfile(/usr/local/go/src/os/exec/lp_unix.go) => true <nil>
Ignoring test code in env_test.go
Processing package=os/exec:
Walking from /usr/local/go/src to /usr/local/go/src/os/signal
Processing os/signal:
Ignoring test code in example_test.go
Ignoring test code in signal_test.go
Matchfile(/usr/local/go/src/os/signal/signal.go) => true <nil>
Ignoring test code in signal_plan9_test.go
Matchfile(/usr/local/go/src/os/signal/signal_unix.go) => true <nil>
Matchfile(/usr/local/go/src/os/signal/doc.go) => true <nil>
Ignoring test code in signal_cgo_test.go
Ignoring test code in signal_windows_test.go
Matchfile(/usr/local/go/src/os/signal/signal_plan9.go) => false <nil>
Processing package=os/signal:
Excluding /usr/local/go/src/os/signal/internal
Walking from /usr/local/go/src to /usr/local/go/src/os/user
Processing os/user:
Matchfile(/usr/local/go/src/os/user/user.go) => true <nil>
Matchfile(/usr/local/go/src/os/user/getgrouplist_unix.go) => true <nil>
Matchfile(/usr/local/go/src/os/user/lookup_windows.go) => false <nil>
Matchfile(/usr/local/go/src/os/user/lookup_android.go) => false <nil>
Matchfile(/usr/local/go/src/os/user/listgroups_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/os/user/listgroups_unix.go) => true <nil>
Matchfile(/usr/local/go/src/os/user/lookup_stubs.go) => false <nil>
Matchfile(/usr/local/go/src/os/user/lookup.go) => true <nil>
Ignoring test code in lookup_unix_test.go
Ignoring test code in cgo_unix_test.go
Matchfile(/usr/local/go/src/os/user/lookup_unix.go) => false <nil>
Matchfile(/usr/local/go/src/os/user/lookup_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/os/user/getgrouplist_darwin.go) => false <nil>
Matchfile(/usr/local/go/src/os/user/cgo_lookup_unix.go) => true <nil>
Ignoring test code in user_test.go
Processing package=os/user:
Walking from /usr/local/go/src to /usr/local/go/src/path
Processing path:
Ignoring test code in example_test.go
Ignoring test code in path_test.go
Matchfile(/usr/local/go/src/path/path.go) => true <nil>
Ignoring test code in match_test.go
Matchfile(/usr/local/go/src/path/match.go) => true <nil>
Processing package=path:
Walking from /usr/local/go/src to /usr/local/go/src/path/filepath
Processing path/filepath:
Ignoring test code in path_windows_test.go
Ignoring test code in example_test.go
Ignoring test code in export_windows_test.go
Ignoring test code in example_unix_test.go
Ignoring test code in export_test.go
Ignoring test code in path_test.go
Matchfile(/usr/local/go/src/path/filepath/path_windows.go) => false <nil>
Matchfile(/usr/local/go/src/path/filepath/symlink.go) => true <nil>
Matchfile(/usr/local/go/src/path/filepath/path.go) => true <nil>
Ignoring test code in match_test.go
Matchfile(/usr/local/go/src/path/filepath/symlink_unix.go) => true <nil>
Matchfile(/usr/local/go/src/path/filepath/match.go) => true <nil>
Matchfile(/usr/local/go/src/path/filepath/symlink_windows.go) => false <nil>
Matchfile(/usr/local/go/src/path/filepath/path_plan9.go) => false <nil>
Ignoring test code in example_unix_walk_test.go
Matchfile(/usr/local/go/src/path/filepath/path_unix.go) => true <nil>
Processing package=path/filepath:
Walking from /usr/local/go/src to /usr/local/go/src/plugin
Processing plugin:
Ignoring test code in plugin_test.go
Matchfile(/usr/local/go/src/plugin/plugin_dlopen.go) => true <nil>
Matchfile(/usr/local/go/src/plugin/plugin.go) => true <nil>
Matchfile(/usr/local/go/src/plugin/plugin_stubs.go) => false <nil>
Processing package=plugin:
Walking from /usr/local/go/src to /usr/local/go/src/reflect
Processing reflect:
Ignoring test code in example_test.go
Ignoring test code in set_test.go
Ignoring test code in export_test.go
Ignoring test code in all_test.go
Matchfile(/usr/local/go/src/reflect/deepequal.go) => true <nil>
Matchfile(/usr/local/go/src/reflect/makefunc.go) => true <nil>
Ignoring test code in tostring_test.go
Matchfile(/usr/local/go/src/reflect/value.go) => true <nil>
Matchfile(/usr/local/go/src/reflect/swapper.go) => true <nil>
Matchfile(/usr/local/go/src/reflect/type.go) => true <nil>
Processing package=reflect:
Walking from /usr/local/go/src to /usr/local/go/src/regexp
Processing regexp:
Ignoring test code in example_test.go
Ignoring test code in onepass_test.go
Ignoring test code in exec2_test.go
Matchfile(/usr/local/go/src/regexp/onepass.go) => true <nil>
Ignoring test code in all_test.go
Ignoring test code in find_test.go
Matchfile(/usr/local/go/src/regexp/backtrack.go) => true <nil>
Ignoring test code in exec_test.go
Matchfile(/usr/local/go/src/regexp/regexp.go) => true <nil>
Matchfile(/usr/local/go/src/regexp/exec.go) => true <nil>
Processing package=regexp:
Walking from /usr/local/go/src to /usr/local/go/src/regexp/syntax
Processing regexp/syntax:
Matchfile(/usr/local/go/src/regexp/syntax/parse.go) => true <nil>
Ignoring test code in prog_test.go
Matchfile(/usr/local/go/src/regexp/syntax/op_string.go) => true <nil>
Ignoring test code in parse_test.go
Ignoring test code in simplify_test.go
Matchfile(/usr/local/go/src/regexp/syntax/simplify.go) => true <nil>
Matchfile(/usr/local/go/src/regexp/syntax/compile.go) => true <nil>
Matchfile(/usr/local/go/src/regexp/syntax/prog.go) => true <nil>
Matchfile(/usr/local/go/src/regexp/syntax/regexp.go) => true <nil>
Matchfile(/usr/local/go/src/regexp/syntax/perl_groups.go) => true <nil>
Matchfile(/usr/local/go/src/regexp/syntax/doc.go) => true <nil>
Processing package=regexp/syntax:
Excluding /usr/local/go/src/regexp/testdata
Walking from /usr/local/go/src to /usr/local/go/src/runtime
Processing runtime:
Ignoring test code in runtime_unix_test.go
Matchfile(/usr/local/go/src/runtime/auxv_none.go) => false <nil>
Ignoring test code in runtime_linux_test.go
Matchfile(/usr/local/go/src/runtime/extern.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_netbsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/stubs3.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_linux_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/print.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/mkduff.go) => false <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/runtime/defs_openbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/sys_ppc64x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_aix_ppc64.go) => false <nil>
Ignoring test code in export_windows_test.go
Matchfile(/usr/local/go/src/runtime/compiler.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_windows_386.go) => false <nil>
Ignoring test code in map_test.go
Matchfile(/usr/local/go/src/runtime/cgocallback.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_plan9_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/time.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_netbsd_386.go) => false <nil>
Ignoring test code in runtime_mmap_test.go
Matchfile(/usr/local/go/src/runtime/signal_openbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_linux_noauxv.go) => true <nil>
Ignoring test code in runtime_test.go
Matchfile(/usr/local/go/src/runtime/os_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_amd64x.go) => true <nil>
Ignoring test code in malloc_test.go
Matchfile(/usr/local/go/src/runtime/defs_nacl_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/map.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os_linux_be64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/vdso_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/msan.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cpuflags.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/mheap.go) => true <nil>
Ignoring test code in hash_test.go
Ignoring test code in map_benchmark_test.go
Matchfile(/usr/local/go/src/runtime/signal_linux_ppc64x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_linux_mips64x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_linux_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/race0.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/mgcstack.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/mwbbuf.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/cgo_ppc64x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_dragonfly.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/sigqueue_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_freebsd_noauxv.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os3_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mgcsweepbuf.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/stubs_linux.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_aix.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cpuprof.go) => true <nil>
Ignoring test code in proc_test.go
Matchfile(/usr/local/go/src/runtime/netpoll_kqueue.go) => false <nil>
Ignoring test code in iface_test.go
Matchfile(/usr/local/go/src/runtime/vlrt.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/map_faststr.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_openbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/debugcall.go) => true <nil>
Ignoring test code in slice_test.go
Ignoring test code in complex_test.go
Matchfile(/usr/local/go/src/runtime/mem_linux.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/map_fast32.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_windows_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_linux_mips64x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_linux_amd64.go) => true <nil>
Ignoring test code in crash_unix_test.go
Matchfile(/usr/local/go/src/runtime/os_nacl_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/trace.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/env_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/race.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_linux_amd64.go) => true <nil>
Ignoring test code in debug_test.go
Ignoring test code in chan_test.go
Ignoring test code in rwmutex_test.go
Matchfile(/usr/local/go/src/runtime/unaligned1.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/runtime/defs_nacl_amd64p32.go) => false <nil>
Ignoring test code in string_test.go
Matchfile(/usr/local/go/src/runtime/stubs32.go) => false <nil>
Ignoring test code in chanbarrier_test.go
Matchfile(/usr/local/go/src/runtime/os_nonopenbsd.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_linux_mipsx.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/timeasm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/proc.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/rwmutex.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/lfstack_32bit.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os2_nacl.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs3_linux.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_arm64.go) => false <nil>
Ignoring test code in proc_runtime_test.go
Matchfile(/usr/local/go/src/runtime/mcentral.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os_openbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/traceback.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/sys_darwin.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_linux_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_dragonfly.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/runtime2.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mem_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs2_linux.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mfinal.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/sys_nonppc64x.go) => true <nil>
Ignoring test code in crash_test.go
Matchfile(/usr/local/go/src/runtime/sys_darwin_32.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_linux_mipsx.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cputicks.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_aix_ppc64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/stubs_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/hash64.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/netpoll_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mem_js.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/hash32.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/iface.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_freebsd_386.go) => false <nil>
Ignoring test code in export_futex_test.go
Matchfile(/usr/local/go/src/runtime/rdebug.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/netpoll_epoll.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/timestub2.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/write_err_android.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/select.go) => true <nil>
Ignoring test code in export_linux_test.go
Matchfile(/usr/local/go/src/runtime/defs_darwin.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mgcmark.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_dragonfly.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_openbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/vdso_linux_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/atomic_pointer.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_darwin.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/typekind.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/sigtab_aix.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_windows.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/syscall_aix.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/utf8.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/alg.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os2_freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_windows_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/netpoll_windows.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_linux_novdso.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/stubs_nonlinux.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mbitmap.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/stubs2.go) => true <nil>
Ignoring test code in softfloat64_test.go
Matchfile(/usr/local/go/src/runtime/defs1_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/vdso_in_none.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/wincallback.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/vdso_linux_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_sighandler.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/lfstack.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_darwin_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/lock_js.go) => false <nil>
Ignoring test code in export_debug_test.go
Matchfile(/usr/local/go/src/runtime/lfstack_64bit.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/cpuflags_amd64.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/vdso_linux_amd64.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/cgo_sigaction.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs1_linux.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_unix.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/mcache.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_nacl_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mstats.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os_linux_generic.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_dragonfly_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os2_openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/error.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os_android.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/vdso_elf64.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/heapdump.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/write_err.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os2_aix.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_nacl.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cgocheck.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/map_fast64.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/stubs.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_linux_mipsx.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_dragonfly_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_freebsd.go) => false <nil>
Ignoring test code in stack_test.go
Matchfile(/usr/local/go/src/runtime/signal_nacl.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mem_aix.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_linux_ppc64x.go) => false <nil>
Ignoring test code in export_arm_test.go
Matchfile(/usr/local/go/src/runtime/panic.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/sys_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/profbuf.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/plugin.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os2_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_plan9_amd64.go) => false <nil>
Ignoring test code in gc_test.go
Matchfile(/usr/local/go/src/runtime/signal_darwin_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/msize.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/slice.go) => true <nil>
Ignoring test code in norace_linux_test.go
Ignoring test code in callers_test.go
Ignoring test code in profbuf_test.go
Matchfile(/usr/local/go/src/runtime/mmap.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/proflabel.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/cgo.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/softfloat64.go) => true <nil>
Ignoring test code in closure_test.go
Matchfile(/usr/local/go/src/runtime/signal_mipsx.go) => false <nil>
Ignoring test code in lfstack_test.go
Matchfile(/usr/local/go/src/runtime/os_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mbarrier.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/vdso_linux_ppc64x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_aix.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/msan0.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_openbsd.go) => false <nil>
Ignoring test code in syscall_windows_test.go
Matchfile(/usr/local/go/src/runtime/vdso_freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/runtime.go) => true <nil>
Ignoring test code in symtab_test.go
Matchfile(/usr/local/go/src/runtime/sigtab_linux_mipsx.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_linux_arm64.go) => false <nil>
Ignoring test code in memmove_test.go
Matchfile(/usr/local/go/src/runtime/defs_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/type.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os3_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/syscall_windows.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_freebsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mkfastlog2table.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_windows.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_linux_ppc64le.go) => false <nil>
Ignoring test code in runtime-gdb_test.go
Matchfile(/usr/local/go/src/runtime/defs_linux_ppc64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_linux_arm.go) => false <nil>
Ignoring test code in numcpu_freebsd_test.go
Matchfile(/usr/local/go/src/runtime/defs1_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/env_posix.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/mem_bsd.go) => false <nil>
Ignoring test code in gcinfo_test.go
Matchfile(/usr/local/go/src/runtime/mgcsweep.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/mksizeclasses.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/malloc.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/stubs_x86.go) => true <nil>
Ignoring test code in mfinal_test.go
Matchfile(/usr/local/go/src/runtime/debug.go) => true <nil>
Ignoring test code in vdso_linux_test.go
Matchfile(/usr/local/go/src/runtime/defs1_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_windows.go) => false <nil>
Ignoring test code in export_unix_test.go
Matchfile(/usr/local/go/src/runtime/os_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_linux.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_windows_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/vdso_linux.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/lock_futex.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/sys_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_linux.go) => false <nil>
Ignoring test code in semasleep_test.go
Matchfile(/usr/local/go/src/runtime/signal_ppc64x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mfixalloc.go) => true <nil>
Ignoring test code in crash_cgo_test.go
Matchfile(/usr/local/go/src/runtime/vdso_linux_arm64.go) => false <nil>
Ignoring test code in export_mmap_test.go
Matchfile(/usr/local/go/src/runtime/stubs_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/sigaction.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os2_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_linux_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/sizeclasses.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_mips64x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/sigqueue.go) => true <nil>
Ignoring test code in fastlog2_test.go
Matchfile(/usr/local/go/src/runtime/fastlog2table.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_darwin_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/stack.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_darwin_arm64.go) => false <nil>
Ignoring test code in norace_test.go
Matchfile(/usr/local/go/src/runtime/sys_darwin_64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/symtab.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_nacl_amd64p32.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mprof.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_nacl_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mgc.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/float.go) => true <nil>
Ignoring test code in sizeof_test.go
Matchfile(/usr/local/go/src/runtime/netpoll_stub.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/chan.go) => true <nil>
Ignoring test code in treap_test.go
Matchfile(/usr/local/go/src/runtime/unaligned2.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/syscall_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_plan9_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs1_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_js.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/runtime1.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os_plan9_arm.go) => false <nil>
Ignoring test code in runtime-lldb_test.go
Matchfile(/usr/local/go/src/runtime/sys_x86.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/mem_windows.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_arm_linux.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/vdso_elf32.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_openbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/sigtab_linux_generic.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_darwin_amd64.go) => false <nil>
Ignoring test code in rand_test.go
Matchfile(/usr/local/go/src/runtime/netpoll_aix.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_nacl_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_netbsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/fastlog2.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/sys_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/sys_mipsx.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/relax_stub.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os_netbsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/stubs_android.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/complex.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/mgcwork.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/mgclarge.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/string.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os_openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cgocall.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os_freebsd2.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/net_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/syscall2_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_darwin.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_openbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_linux_mips64x.go) => false <nil>
Ignoring test code in memmove_linux_amd64_test.go
Matchfile(/usr/local/go/src/runtime/signal_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_linux_s390x.go) => false <nil>
Ignoring test code in crash_nonunix_test.go
Matchfile(/usr/local/go/src/runtime/zcallback_windows.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/sys_mips64x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/sys_wasm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/vdso_freebsd_x86.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/netpoll.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/netpoll_fake.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cgo_mmap.go) => true <nil>
Ignoring test code in env_test.go
Matchfile(/usr/local/go/src/runtime/lock_sema.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/timestub.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/sema.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_netbsd_arm.go) => false <nil>
Ignoring test code in futex_test.go
Matchfile(/usr/local/go/src/runtime/os_netbsd_amd64.go) => false <nil>
Ignoring test code in vlop_arm_test.go
Processing package=runtime:
Walking from /usr/local/go/src to /usr/local/go/src/runtime/cgo
Processing runtime/cgo:
Matchfile(/usr/local/go/src/runtime/cgo/freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cgo/netbsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cgo/dragonfly.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cgo/callbacks.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/cgo/setenv.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/cgo/iscgo.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/cgo/openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cgo/callbacks_traceback.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/cgo/mmap.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/cgo/cgo.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/cgo/sigaction.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/cgo/signal_darwin_armx.go) => false <nil>
Processing package=runtime/cgo:
Walking from /usr/local/go/src to /usr/local/go/src/runtime/debug
Processing runtime/debug:
Matchfile(/usr/local/go/src/runtime/debug/garbage.go) => true <nil>
Ignoring test code in garbage_test.go
Matchfile(/usr/local/go/src/runtime/debug/stubs.go) => true <nil>
Ignoring test code in stack_test.go
Matchfile(/usr/local/go/src/runtime/debug/stack.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/debug/mod.go) => true <nil>
Ignoring test code in heapdump_test.go
Processing package=runtime/debug:
Excluding /usr/local/go/src/runtime/internal
Walking from /usr/local/go/src to /usr/local/go/src/runtime/msan
Processing runtime/msan:
Matchfile(/usr/local/go/src/runtime/msan/msan.go) => false <nil>
Walking from /usr/local/go/src to /usr/local/go/src/runtime/pprof
Processing runtime/pprof:
Matchfile(/usr/local/go/src/runtime/pprof/label.go) => true <nil>
Ignoring test code in protomem_test.go
Ignoring test code in proto_test.go
Ignoring test code in runtime_test.go
Matchfile(/usr/local/go/src/runtime/pprof/map.go) => true <nil>
Ignoring test code in pprof_test.go
Matchfile(/usr/local/go/src/runtime/pprof/elf.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/pprof/protobuf.go) => true <nil>
Ignoring test code in mprof_test.go
Matchfile(/usr/local/go/src/runtime/pprof/pprof.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/pprof/proto.go) => true <nil>
Ignoring test code in label_test.go
Matchfile(/usr/local/go/src/runtime/pprof/runtime.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/pprof/protomem.go) => true <nil>
Processing package=runtime/pprof:
Excluding /usr/local/go/src/runtime/pprof/internal
Excluding /usr/local/go/src/runtime/pprof/testdata
Walking from /usr/local/go/src to /usr/local/go/src/runtime/race
Processing runtime/race:
Ignoring test code in race_linux_test.go
Ignoring test code in race_test.go
Matchfile(/usr/local/go/src/runtime/race/race.go) => false <nil>
Ignoring test code in race_windows_test.go
Ignoring test code in output_test.go
Matchfile(/usr/local/go/src/runtime/race/doc.go) => true <nil>
Ignoring test code in sched_test.go
Ignoring test code in race_unix_test.go
Processing package=runtime/race:
Excluding /usr/local/go/src/runtime/race/testdata
Excluding /usr/local/go/src/runtime/testdata
Walking from /usr/local/go/src to /usr/local/go/src/runtime/trace
Processing runtime/trace:
Ignoring test code in example_test.go
Ignoring test code in trace_test.go
Matchfile(/usr/local/go/src/runtime/trace/trace.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/trace/annotation.go) => true <nil>
Ignoring test code in annotation_test.go
Ignoring test code in trace_stack_test.go
Processing package=runtime/trace:
Walking from /usr/local/go/src to /usr/local/go/src/sort
Processing sort:
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Ignoring test code in example_interface_test.go
Ignoring test code in example_search_test.go
Ignoring test code in example_keys_test.go
Matchfile(/usr/local/go/src/sort/slice.go) => true <nil>
Ignoring test code in sort_test.go
Matchfile(/usr/local/go/src/sort/search.go) => true <nil>
Matchfile(/usr/local/go/src/sort/genzfunc.go) => false <nil>
Matchfile(/usr/local/go/src/sort/zfuncversion.go) => true <nil>
Ignoring test code in example_multi_test.go
Matchfile(/usr/local/go/src/sort/sort.go) => true <nil>
Ignoring test code in example_wrapper_test.go
Ignoring test code in search_test.go
Processing package=sort:
Walking from /usr/local/go/src to /usr/local/go/src/strconv
Processing strconv:
Ignoring test code in internal_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/strconv/isprint.go) => true <nil>
Ignoring test code in fp_test.go
Matchfile(/usr/local/go/src/strconv/itoa.go) => true <nil>
Matchfile(/usr/local/go/src/strconv/quote.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/strconv/atob.go) => true <nil>
Matchfile(/usr/local/go/src/strconv/ftoa.go) => true <nil>
Ignoring test code in atoi_test.go
Matchfile(/usr/local/go/src/strconv/extfloat.go) => true <nil>
Matchfile(/usr/local/go/src/strconv/atof.go) => true <nil>
Matchfile(/usr/local/go/src/strconv/doc.go) => true <nil>
Matchfile(/usr/local/go/src/strconv/makeisprint.go) => false <nil>
Ignoring test code in strconv_test.go
Ignoring test code in atob_test.go
Ignoring test code in ftoa_test.go
Matchfile(/usr/local/go/src/strconv/atoi.go) => true <nil>
Ignoring test code in itoa_test.go
Ignoring test code in quote_test.go
Ignoring test code in atof_test.go
Matchfile(/usr/local/go/src/strconv/decimal.go) => true <nil>
Ignoring test code in decimal_test.go
Processing package=strconv:
Excluding /usr/local/go/src/strconv/testdata
Walking from /usr/local/go/src to /usr/local/go/src/strings
Processing strings:
Ignoring test code in example_test.go
Ignoring test code in strings_test.go
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/strings/builder.go) => true <nil>
Matchfile(/usr/local/go/src/strings/reader.go) => true <nil>
Matchfile(/usr/local/go/src/strings/replace.go) => true <nil>
Matchfile(/usr/local/go/src/strings/compare.go) => true <nil>
Ignoring test code in replace_test.go
Matchfile(/usr/local/go/src/strings/search.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in compare_test.go
Matchfile(/usr/local/go/src/strings/strings.go) => true <nil>
Ignoring test code in builder_test.go
Ignoring test code in search_test.go
Processing package=strings:
Walking from /usr/local/go/src to /usr/local/go/src/sync
Processing sync:
Ignoring test code in example_test.go
Ignoring test code in map_test.go
Matchfile(/usr/local/go/src/sync/map.go) => true <nil>
Ignoring test code in waitgroup_test.go
Matchfile(/usr/local/go/src/sync/waitgroup.go) => true <nil>
Ignoring test code in cond_test.go
Ignoring test code in rwmutex_test.go
Ignoring test code in map_reference_test.go
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/sync/rwmutex.go) => true <nil>
Ignoring test code in map_bench_test.go
Ignoring test code in pool_test.go
Ignoring test code in mutex_test.go
Ignoring test code in once_test.go
Matchfile(/usr/local/go/src/sync/cond.go) => true <nil>
Matchfile(/usr/local/go/src/sync/mutex.go) => true <nil>
Matchfile(/usr/local/go/src/sync/runtime.go) => true <nil>
Ignoring test code in example_pool_test.go
Ignoring test code in runtime_sema_test.go
Matchfile(/usr/local/go/src/sync/once.go) => true <nil>
Matchfile(/usr/local/go/src/sync/pool.go) => true <nil>
Processing package=sync:
Walking from /usr/local/go/src to /usr/local/go/src/sync/atomic
Processing sync/atomic:
Ignoring test code in example_test.go
Ignoring test code in value_test.go
Ignoring test code in atomic_test.go
Matchfile(/usr/local/go/src/sync/atomic/value.go) => true <nil>
Matchfile(/usr/local/go/src/sync/atomic/doc.go) => true <nil>
Processing package=sync/atomic:
Walking from /usr/local/go/src to /usr/local/go/src/syscall
Processing syscall:
Matchfile(/usr/local/go/src/syscall/zsysnum_darwin_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/endian_big.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_freebsd_arm.go) => false <nil>
Ignoring test code in syscall_plan9_test.go
Ignoring test code in export_freebsd_test.go
Matchfile(/usr/local/go/src/syscall/zerrors_windows.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/errors_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/forkpipe.go) => false <nil>
Ignoring test code in syscall_freebsd_test.go
Matchfile(/usr/local/go/src/syscall/zerrors_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_windows_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/exec_unix.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/endian_little.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_nacl_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/msan.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_aix_ppc64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_dragonfly_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_nacl_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_darwin_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_darwin_amd64.go) => false <nil>
Ignoring test code in syscall_unix_test.go
Matchfile(/usr/local/go/src/syscall/zerrors_darwin_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_openbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/route_dragonfly.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_windows.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_bsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_ppc64le.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/env_windows.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_linux_mipsx.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/mkasm_darwin.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_openbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_plan9_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_mipsle.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_mipsle.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_openbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/types_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/env_unix.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_mips.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_freebsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_openbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/env_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_getwd_bsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_windows_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_ppc64.go) => false <nil>
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/syscall/unzip_nacl.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_darwin_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_linux_amd64.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/syscall_nacl_amd64p32.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/exec_linux.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/syscall_linux_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/netlink_linux.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/net_nacl.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_ppc64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/flock_linux_32bit.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_openbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_linux_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_mips64le.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_darwin.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_aix_ppc64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/types_windows_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysctl_openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/net.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/net_js.go) => false <nil>
Ignoring test code in export_linux_test.go
Matchfile(/usr/local/go/src/syscall/ztypes_darwin_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/timestruct.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_linux_ppc64le.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_freebsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_darwin_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_openbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_mips64le.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_linux.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/types_dragonfly.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_darwin_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_aix_ppc64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_openbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_openbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_freebsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/types_openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_aix.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_nacl.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/bpf_darwin.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_linux_mips64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_ppc64le.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/flock_darwin.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_linux_mips.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/mkpost.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_linux_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_s390x.go) => false <nil>
Ignoring test code in exec_aix_test.go
Matchfile(/usr/local/go/src/syscall/ztypes_openbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/route_darwin.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/route_freebsd.go) => false <nil>
Ignoring test code in exec_solaris_test.go
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_amd64.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/exec_libc.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/route_openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/types_aix.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_mips64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_linux_mips64x.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_linux_ppc64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/route_netbsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_openbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_nacl_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_dragonfly_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/fd_nacl.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_unix.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_linux_amd64.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/sockcmsg_unix.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/syscall_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/sockcmsg_linux.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/setuidgid_32_linux.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/msan0.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_windows_386.go) => false <nil>
Ignoring test code in syscall_windows_test.go
Matchfile(/usr/local/go/src/syscall/types_windows_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_windows_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_dragonfly_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_openbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/types_freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_amd64.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_openbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/tables_nacljs.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_dragonfly_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/exec_bsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/types_netbsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_windows.go) => false <nil>
Ignoring test code in exec_linux_test.go
Matchfile(/usr/local/go/src/syscall/syscall_openbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_dragonfly_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_mips.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_windows_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_windows_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/fs_nacl.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/dir_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/types_windows.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_plan9_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_linux_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/dirent.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_amd64.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/route_freebsd_32bit.go) => false <nil>
Ignoring test code in export_unix_test.go
Matchfile(/usr/local/go/src/syscall/syscall.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_netbsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/bpf_bsd.go) => false <nil>
Ignoring test code in syscall_test.go
Matchfile(/usr/local/go/src/syscall/zerrors_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/fs_js.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/route_freebsd_64bit.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/setuidgid_linux.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/syscall_nacl_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/types_darwin.go) => false <nil>
Ignoring test code in dirent_bsd_test.go
Matchfile(/usr/local/go/src/syscall/zsyscall_darwin_386.go) => false <nil>
Ignoring test code in creds_test.go
Matchfile(/usr/local/go/src/syscall/syscall_freebsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_aix_ppc64.go) => false <nil>
Ignoring test code in mmap_unix_test.go
Matchfile(/usr/local/go/src/syscall/ztypes_linux_mips64le.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/flock_aix.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_linux_ppc64x.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/pwd_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_mips.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/types_linux.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_openbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_js.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/dll_windows.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/exec_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/const_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_mips64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/flock.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_mipsle.go) => false <nil>
Ignoring test code in syscall_bsd_test.go
Matchfile(/usr/local/go/src/syscall/syscall_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/security_windows.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/exec_windows.go) => false <nil>
Ignoring test code in syscall_linux_test.go
Matchfile(/usr/local/go/src/syscall/zerrors_freebsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_darwin_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_mips64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_plan9_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/types_windows_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_ppc64le.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/exec_darwin.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/forkpipe2.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_mips64le.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_ppc64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_dragonfly.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/str.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/mksyscall_windows.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/route_bsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_openbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_nacl_amd64p32.go) => false <nil>
Ignoring test code in exec_unix_test.go
Matchfile(/usr/local/go/src/syscall/ztypes_linux_mipsle.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/lsf_linux.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/syscall_freebsd_arm.go) => false <nil>
Processing package=syscall:
Walking from /usr/local/go/src to /usr/local/go/src/syscall/js
Processing syscall/js:
Matchfile(/usr/local/go/src/syscall/js/typedarray.go) => false <nil>
Ignoring test code in js_test.go
Matchfile(/usr/local/go/src/syscall/js/func.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/js/js.go) => false <nil>
Excluding /usr/local/go/src/testdata
Walking from /usr/local/go/src to /usr/local/go/src/testing
Processing testing:
Ignoring test code in helperfuncs_test.go
Matchfile(/usr/local/go/src/testing/testing.go) => true <nil>
Matchfile(/usr/local/go/src/testing/cover.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/testing/allocs.go) => true <nil>
Ignoring test code in helper_test.go
Ignoring test code in testing_test.go
Matchfile(/usr/local/go/src/testing/example.go) => true <nil>
Ignoring test code in match_test.go
Matchfile(/usr/local/go/src/testing/match.go) => true <nil>
Ignoring test code in allocs_test.go
Ignoring test code in sub_test.go
Matchfile(/usr/local/go/src/testing/benchmark.go) => true <nil>
Ignoring test code in benchmark_test.go
Processing package=testing:
Excluding /usr/local/go/src/testing/internal
Walking from /usr/local/go/src to /usr/local/go/src/testing/iotest
Processing testing/iotest:
Matchfile(/usr/local/go/src/testing/iotest/writer.go) => true <nil>
Matchfile(/usr/local/go/src/testing/iotest/reader.go) => true <nil>
Matchfile(/usr/local/go/src/testing/iotest/logger.go) => true <nil>
Processing package=testing/iotest:
Walking from /usr/local/go/src to /usr/local/go/src/testing/quick
Processing testing/quick:
Ignoring test code in quick_test.go
Matchfile(/usr/local/go/src/testing/quick/quick.go) => true <nil>
Processing package=testing/quick:
Walking from /usr/local/go/src to /usr/local/go/src/text
Processing text:
Walking from /usr/local/go/src to /usr/local/go/src/text/scanner
Processing text/scanner:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/text/scanner/scanner.go) => true <nil>
Ignoring test code in scanner_test.go
Processing package=text/scanner:
Walking from /usr/local/go/src to /usr/local/go/src/text/tabwriter
Processing text/tabwriter:
Ignoring test code in example_test.go
Ignoring test code in tabwriter_test.go
Matchfile(/usr/local/go/src/text/tabwriter/tabwriter.go) => true <nil>
Processing package=text/tabwriter:
Walking from /usr/local/go/src to /usr/local/go/src/text/template
Processing text/template:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/text/template/option.go) => true <nil>
Ignoring test code in examplefunc_test.go
Matchfile(/usr/local/go/src/text/template/helper.go) => true <nil>
Matchfile(/usr/local/go/src/text/template/template.go) => true <nil>
Ignoring test code in exec_test.go
Ignoring test code in multi_test.go
Matchfile(/usr/local/go/src/text/template/exec.go) => true <nil>
Matchfile(/usr/local/go/src/text/template/doc.go) => true <nil>
Ignoring test code in examplefiles_test.go
Matchfile(/usr/local/go/src/text/template/funcs.go) => true <nil>
Processing package=text/template:
Walking from /usr/local/go/src to /usr/local/go/src/text/template/parse
Processing text/template/parse:
Matchfile(/usr/local/go/src/text/template/parse/parse.go) => true <nil>
Ignoring test code in parse_test.go
Ignoring test code in lex_test.go
Matchfile(/usr/local/go/src/text/template/parse/lex.go) => true <nil>
Matchfile(/usr/local/go/src/text/template/parse/node.go) => true <nil>
Processing package=text/template/parse:
Excluding /usr/local/go/src/text/template/testdata
Walking from /usr/local/go/src to /usr/local/go/src/time
Processing time:
Ignoring test code in internal_test.go
Matchfile(/usr/local/go/src/time/zoneinfo_plan9.go) => false <nil>
Ignoring test code in example_test.go
Ignoring test code in export_windows_test.go
Matchfile(/usr/local/go/src/time/time.go) => true <nil>
Ignoring test code in zoneinfo_android_test.go
Matchfile(/usr/local/go/src/time/zoneinfo_unix.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/time/format.go) => true <nil>
Ignoring test code in export_android_test.go
Matchfile(/usr/local/go/src/time/genzabbrs.go) => false <nil>
Matchfile(/usr/local/go/src/time/zoneinfo_android.go) => false <nil>
Matchfile(/usr/local/go/src/time/zoneinfo_windows.go) => false <nil>
Matchfile(/usr/local/go/src/time/zoneinfo.go) => true <nil>
Ignoring test code in time_test.go
Ignoring test code in zoneinfo_windows_test.go
Matchfile(/usr/local/go/src/time/zoneinfo_abbrs_windows.go) => false <nil>
Ignoring test code in zoneinfo_test.go
Matchfile(/usr/local/go/src/time/zoneinfo_read.go) => true <nil>
Matchfile(/usr/local/go/src/time/sys_unix.go) => true <nil>
Matchfile(/usr/local/go/src/time/zoneinfo_ios.go) => false <nil>
Matchfile(/usr/local/go/src/time/sleep.go) => true <nil>
Matchfile(/usr/local/go/src/time/sys_windows.go) => false <nil>
Ignoring test code in mono_test.go
Matchfile(/usr/local/go/src/time/tick.go) => true <nil>
Matchfile(/usr/local/go/src/time/sys_plan9.go) => false <nil>
Ignoring test code in tick_test.go
Matchfile(/usr/local/go/src/time/zoneinfo_js.go) => false <nil>
Ignoring test code in format_test.go
Ignoring test code in sleep_test.go
Processing package=time:
Walking from /usr/local/go/src to /usr/local/go/src/unicode
Processing unicode:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/unicode/tables.go) => true <nil>
Matchfile(/usr/local/go/src/unicode/letter.go) => true <nil>
Ignoring test code in graphic_test.go
Ignoring test code in digit_test.go
Ignoring test code in letter_test.go
Ignoring test code in script_test.go
Matchfile(/usr/local/go/src/unicode/digit.go) => true <nil>
Matchfile(/usr/local/go/src/unicode/casetables.go) => true <nil>
Matchfile(/usr/local/go/src/unicode/graphic.go) => true <nil>
Matchfile(/usr/local/go/src/unicode/maketables.go) => false <nil>
Processing package=unicode:
Walking from /usr/local/go/src to /usr/local/go/src/unicode/utf16
Processing unicode/utf16:
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/unicode/utf16/utf16.go) => true <nil>
Ignoring test code in utf16_test.go
Processing package=unicode/utf16:
Walking from /usr/local/go/src to /usr/local/go/src/unicode/utf8
Processing unicode/utf8:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/unicode/utf8/utf8.go) => true <nil>
Ignoring test code in utf8_test.go
Processing package=unicode/utf8:
Walking from /usr/local/go/src to /usr/local/go/src/unsafe
Processing unsafe:
Matchfile(/usr/local/go/src/unsafe/unsafe.go) => true <nil>
NOTICE: Ignoring package unsafe in unsafe
JOKER CONSTANT FormatGNU from archive/tar/format.go:
(def
  ^{:doc "FormatGNU represents the GNU header format.\n\nThe GNU header format is older than the USTAR and PAX standards and\nis not compatible with them. The GNU format supports\narbitrary file sizes, filenames of arbitrary encoding and length,\nsparse files, and other features.\n\nIt is recommended that PAX be chosen over GNU unless the target\napplication can only parse GNU formatted archives.\n\nReference:\n\thttps://www.gnu.org/software/tar/manual/html_node/Standard.html\n"
    :added "1.0"
    :tag "Int"
    :go "int(tar.FormatGNU)"}
  FormatGNU)

JOKER CONSTANT FormatPAX from archive/tar/format.go:
(def
  ^{:doc "FormatPAX represents the PAX header format defined in POSIX.1-2001.\n\nPAX extends USTAR by writing a special file with Typeflag TypeXHeader\npreceding the original header. This file contains a set of key-value\nrecords, which are used to overcome USTAR's shortcomings, in addition to\nproviding the ability to have sub-second resolution for timestamps.\n\nSome newer formats add their own extensions to PAX by defining their\nown keys and assigning certain semantic meaning to the associated values.\nFor example, sparse file support in PAX is implemented using keys\ndefined by the GNU manual (e.g., \"GNU.sparse.map\").\n\nReference:\n\thttp://pubs.opengroup.org/onlinepubs/009695399/utilities/pax.html\n"
    :added "1.0"
    :tag "Int"
    :go "int(tar.FormatPAX)"}
  FormatPAX)

JOKER CONSTANT FormatUSTAR from archive/tar/format.go:
(def
  ^{:doc "FormatUSTAR represents the USTAR header format defined in POSIX.1-1988.\n\nWhile this format is compatible with most tar readers,\nthe format has several limitations making it unsuitable for some usages.\nMost notably, it cannot support sparse files, files larger than 8GiB,\nfilenames larger than 256 characters, and non-ASCII filenames.\n\nReference:\n\thttp://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_06\n"
    :added "1.0"
    :tag "Int"
    :go "int(tar.FormatUSTAR)"}
  FormatUSTAR)

JOKER CONSTANT FormatUnknown from archive/tar/format.go:
(def
  ^{:doc "FormatUnknown indicates that the format is unknown.\n"
    :added "1.0"
    :tag "Int"
    :go "int(tar.FormatUnknown)"}
  FormatUnknown)

JOKER CONSTANT TypeBlock from archive/tar/common.go:
(def
  ^{:doc "Block device node\n"
    :added "1.0"
    :tag "Char"
    :go "tar.TypeBlock"}
  TypeBlock)

JOKER CONSTANT TypeChar from archive/tar/common.go:
(def
  ^{:doc "Character device node\n"
    :added "1.0"
    :tag "Char"
    :go "tar.TypeChar"}
  TypeChar)

JOKER CONSTANT TypeCont from archive/tar/common.go:
(def
  ^{:doc "Type '7' is reserved.\n"
    :added "1.0"
    :tag "Char"
    :go "tar.TypeCont"}
  TypeCont)

JOKER CONSTANT TypeDir from archive/tar/common.go:
(def
  ^{:doc "Directory\n"
    :added "1.0"
    :tag "Char"
    :go "tar.TypeDir"}
  TypeDir)

JOKER CONSTANT TypeFifo from archive/tar/common.go:
(def
  ^{:doc "FIFO node\n"
    :added "1.0"
    :tag "Char"
    :go "tar.TypeFifo"}
  TypeFifo)

JOKER CONSTANT TypeGNULongLink from archive/tar/common.go:
(def
  ^{:doc "Type flags for Header.Typeflag.\n"
    :added "1.0"
    :tag "Char"
    :go "tar.TypeGNULongLink"}
  TypeGNULongLink)

JOKER CONSTANT TypeGNULongName from archive/tar/common.go:
(def
  ^{:doc "Types 'L' and 'K' are used by the GNU format for a meta file\nused to store the path or link name for the next file.\nThis package transparently handles these types.\n"
    :added "1.0"
    :tag "Char"
    :go "tar.TypeGNULongName"}
  TypeGNULongName)

JOKER CONSTANT TypeGNUSparse from archive/tar/common.go:
(def
  ^{:doc "Type 'S' indicates a sparse file in the GNU format.\n"
    :added "1.0"
    :tag "Char"
    :go "tar.TypeGNUSparse"}
  TypeGNUSparse)

JOKER CONSTANT TypeLink from archive/tar/common.go:
(def
  ^{:doc "Type '1' to '6' are header-only flags and may not have a data body.\n"
    :added "1.0"
    :tag "Char"
    :go "tar.TypeLink"}
  TypeLink)

JOKER CONSTANT TypeReg from archive/tar/common.go:
(def
  ^{:doc "Type '0' indicates a regular file.\n"
    :added "1.0"
    :tag "Char"
    :go "tar.TypeReg"}
  TypeReg)

JOKER CONSTANT TypeRegA from archive/tar/common.go:
(def
  ^{:doc "Deprecated: Use TypeReg instead.\n"
    :added "1.0"
    :tag "Char"
    :go "tar.TypeRegA"}
  TypeRegA)

JOKER CONSTANT TypeSymlink from archive/tar/common.go:
(def
  ^{:doc "Symbolic link\n"
    :added "1.0"
    :tag "Char"
    :go "tar.TypeSymlink"}
  TypeSymlink)

JOKER CONSTANT TypeXGlobalHeader from archive/tar/common.go:
(def
  ^{:doc "Type 'g' is used by the PAX format to store key-value records that\nare relevant to all subsequent files.\nThis package only supports parsing and composing such headers,\nbut does not currently support persisting the global state across files.\n"
    :added "1.0"
    :tag "Char"
    :go "tar.TypeXGlobalHeader"}
  TypeXGlobalHeader)

JOKER CONSTANT TypeXHeader from archive/tar/common.go:
(def
  ^{:doc "Type 'x' is used by the PAX format to store key-value records that\nare only relevant to the next file.\nThis package transparently handles these types.\n"
    :added "1.0"
    :tag "Char"
    :go "tar.TypeXHeader"}
  TypeXHeader)

JOKER VARIABLE ErrFieldTooLong from archive/tar/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "tar.ErrFieldTooLong"}
  ErrFieldTooLong)

JOKER VARIABLE ErrHeader from archive/tar/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "tar.ErrHeader"}
  ErrHeader)

JOKER VARIABLE ErrWriteAfterClose from archive/tar/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "tar.ErrWriteAfterClose"}
  ErrWriteAfterClose)

JOKER VARIABLE ErrWriteTooLong from archive/tar/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "tar.ErrWriteTooLong"}
  ErrWriteTooLong)

JOKER TYPE archive/tar.Format from archive/tar/format.go:
(defn ^"GoObject" Format.
  "Constructor for tar.Format"
  {:added "1.0"
   :go "_ConstructFormat(_v)"}
  [^Object _v])

JOKER TYPE archive/tar.Header from archive/tar/common.go:
;; (defn ^"GoObject" Header.
;;   "Constructor for tar.Header"
;;   {:added "1.0"
;;    :go "_ConstructHeader(_v)"}
;;   [^Object _v])

JOKER TYPE archive/tar.Reader from archive/tar/reader.go:
(defn ^"GoObject" Reader.
  "Constructor for tar.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER TYPE archive/tar.Writer from archive/tar/writer.go:
(defn ^"GoObject" Writer.
  "Constructor for tar.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC archive/tar.FileInfoHeader from archive/tar/common.go:
;; (defn FileInfoHeader
;;   "FileInfoHeader creates a partially-populated Header from fi.\nIf fi describes a symlink, FileInfoHeader records link as the link target.\nIf fi describes a directory, a slash is appended to the name.\n\nSince os.FileInfo's Name method only returns the base name of\nthe file it describes, it may be necessary to modify Header.Name\nto provide the full path name of the file.\n\nGo input arguments: (fi os.FileInfo, link string)\n\nGo return type: (*Header, error)\n\nJoker input arguments: [^go.std.os/FileInfo fi, ^String link]\n\nJoker return type: [(atom-of go.std.archive.tar/Header) Error]"
;;   {:added "1.0"
;;    :go "__fileInfoHeader(*__fi, __link)"}
;;   [^os/FileInfo __fi, ^String __link])

JOKER FUNC archive/tar.NewReader from archive/tar/reader.go:
;; (defn NewReader
;;   "NewReader creates a new Reader reading from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.archive.tar/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC archive/tar.NewWriter from archive/tar/writer.go:
;; (defn NewWriter
;;   "NewWriter creates a new Writer writing to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.archive.tar/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*__w)"}
;;   [^io/Writer __w])

JOKER TYPE go.std.archive.tar/Format:
(def
  ^{:doc "Format represents the tar archive format.\n\nThe original tar format was introduced in Unix V7.\nSince then, there have been multiple competing formats attempting to\nstandardize or extend the V7 format to overcome its limitations.\nThe most common formats are the USTAR, PAX, and GNU formats,\neach with their own advantages and limitations.\n\nThe following table captures the capabilities of each format:\n\n\t                  |  USTAR |       PAX |       GNU\n\t------------------+--------+-----------+----------\n\tName              |   256B | unlimited | unlimited\n\tLinkname          |   100B | unlimited | unlimited\n\tSize              | uint33 | unlimited |    uint89\n\tMode              | uint21 |    uint21 |    uint57\n\tUid/Gid           | uint21 | unlimited |    uint57\n\tUname/Gname       |    32B | unlimited |       32B\n\tModTime           | uint33 | unlimited |     int89\n\tAccessTime        |    n/a | unlimited |     int89\n\tChangeTime        |    n/a | unlimited |     int89\n\tDevmajor/Devminor | uint21 |    uint21 |    uint57\n\t------------------+--------+-----------+----------\n\tstring encoding   |  ASCII |     UTF-8 |    binary\n\tsub-second times  |     no |       yes |        no\n\tsparse files      |     no |       yes |       yes\n\nThe table's upper portion shows the Header fields, where each format reports\nthe maximum number of bytes allowed for each string field and\nthe integer type used to store each numeric field\n(where timestamps are stored as the number of seconds since the Unix epoch).\n\nThe table's lower portion shows specialized features of each format,\nsuch as supported string encodings, support for sub-second timestamps,\nor support for sparse files.\n\nThe Writer currently provides no support for sparse files.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Format"}
  Format)

JOKER TYPE go.std.archive.tar/Header:
(def
  ^{:doc "A Header represents a single header in a tar archive.\nSome fields may not be populated.\n\nFor forward compatibility, users that retrieve a Header from Reader.Next,\nmutate it in some ways, and then pass it back to Writer.WriteHeader\nshould do so by creating a new Header and copying the fields\nthat they are interested in preserving.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Header"}
  Header)

JOKER TYPE go.std.archive.tar/Reader:
(def
  ^{:doc "Reader provides sequential access to the contents of a tar archive.\nReader.Next advances to the next file in the archive (including the first),\nand then Reader can be treated as an io.Reader to access the file's data.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Reader"}
  Reader)

JOKER TYPE go.std.archive.tar/Writer:
(def
  ^{:doc "Writer provides sequential writing of a tar archive.\nWrite.WriteHeader begins a new file with the provided Header,\nand then Writer can be treated as an io.Writer to supply that file's data.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Writer"}
  Writer)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["archive/tar"]
    :doc "Provides a low-level interface to the archive/tar package.\n\nPackage tar implements access to tar archives.\n\nTape archives (tar) are a file format for storing a sequence of files that\ncan be read and written in a streaming manner.\nThis package aims to cover most variations of the format,\nincluding those produced by GNU and BSD tar tools.\n"
    :empty false}
  go.std.archive.tar)
JOKER CONSTANT Deflate from archive/zip/struct.go:
(def
  ^{:doc "DEFLATE compressed\n"
    :added "1.0"
    :tag "Int"
    :go "int(zip.Deflate)"}
  Deflate)

JOKER CONSTANT Store from archive/zip/struct.go:
(def
  ^{:doc "no compression\n"
    :added "1.0"
    :tag "Int"
    :go "int(zip.Store)"}
  Store)

JOKER VARIABLE ErrAlgorithm from archive/zip/reader.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "zip.ErrAlgorithm"}
  ErrAlgorithm)

JOKER VARIABLE ErrChecksum from archive/zip/reader.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "zip.ErrChecksum"}
  ErrChecksum)

JOKER VARIABLE ErrFormat from archive/zip/reader.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "zip.ErrFormat"}
  ErrFormat)

JOKER TYPE archive/zip.Compressor from archive/zip/register.go:
;; (defn ^"GoObject" Compressor.
;;   "Constructor for zip.Compressor"
;;   {:added "1.0"
;;    :go "_ConstructCompressor(_v)"}
;;   [^Object _v])

JOKER TYPE archive/zip.Decompressor from archive/zip/register.go:
;; (defn ^"GoObject" Decompressor.
;;   "Constructor for zip.Decompressor"
;;   {:added "1.0"
;;    :go "_ConstructDecompressor(_v)"}
;;   [^Object _v])

JOKER TYPE archive/zip.File from archive/zip/reader.go:
(defn ^"GoObject" File.
  "Constructor for zip.File"
  {:added "1.0"
   :go "_ConstructFile(_v)"}
  [^Object _v])

JOKER TYPE archive/zip.FileHeader from archive/zip/struct.go:
;; (defn ^"GoObject" FileHeader.
;;   "Constructor for zip.FileHeader"
;;   {:added "1.0"
;;    :go "_ConstructFileHeader(_v)"}
;;   [^Object _v])

JOKER TYPE archive/zip.ReadCloser from archive/zip/reader.go:
(defn ^"GoObject" ReadCloser.
  "Constructor for zip.ReadCloser"
  {:added "1.0"
   :go "_ConstructReadCloser(_v)"}
  [^Object _v])

JOKER TYPE archive/zip.Reader from archive/zip/reader.go:
;; (defn ^"GoObject" Reader.
;;   "Constructor for zip.Reader"
;;   {:added "1.0"
;;    :go "_ConstructReader(_v)"}
;;   [^Object _v])

JOKER TYPE archive/zip.Writer from archive/zip/writer.go:
(defn ^"GoObject" Writer.
  "Constructor for zip.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC archive/zip.FileInfoHeader from archive/zip/struct.go:
;; (defn FileInfoHeader
;;   "FileInfoHeader creates a partially-populated FileHeader from an\nos.FileInfo.\nBecause os.FileInfo's Name method returns only the base name of\nthe file it describes, it may be necessary to modify the Name field\nof the returned header to provide the full path name of the file.\nIf compression is desired, callers should set the FileHeader.Method\nfield; it is unset by default.\n\nGo input arguments: (fi os.FileInfo)\n\nGo return type: (*FileHeader, error)\n\nJoker input arguments: [^go.std.os/FileInfo fi]\n\nJoker return type: [(atom-of go.std.archive.zip/FileHeader) Error]"
;;   {:added "1.0"
;;    :go "__fileInfoHeader(*__fi)"}
;;   [^os/FileInfo __fi])

JOKER FUNC archive/zip.NewReader from archive/zip/reader.go:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from r, which is assumed to\nhave the given size in bytes.\n\nGo input arguments: (r io.ReaderAt, size int64)\n\nGo return type: (*Reader, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r, ^Number size]\n\nJoker return type: [(atom-of go.std.archive.zip/Reader) Error]"
;;   {:added "1.0"
;;    :go "__newReader(*__r, __size)"}
;;   [^io/ReaderAt __r, ^Int64 __size])

JOKER FUNC archive/zip.NewWriter from archive/zip/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer writing a zip file to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.archive.zip/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*__w)"}
;;   [^io/Writer __w])

JOKER FUNC archive/zip.OpenReader from archive/zip/reader.go:
(defn OpenReader
  "OpenReader will open the Zip file specified by name and return a ReadCloser.\n\nGo input arguments: (name string)\n\nGo return type: (*ReadCloser, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.archive.zip/ReadCloser) Error]"
  {:added "1.0"
   :go "__openReader(__name)"}
  [^String __name])

JOKER FUNC archive/zip.RegisterCompressor from archive/zip/register.go:
;; (defn RegisterCompressor
;;   "RegisterCompressor registers custom compressors for a specified method ID.\nThe common methods Store and Deflate are built in.\n\nGo input arguments: (method uint16, comp Compressor)\n\nJoker input arguments: [^Int method, ^go.std.archive.zip/Compressor comp]"
;;   {:added "1.0"
;;    :go "__registerCompressor(__method, *__comp)"}
;;   [^UInt16 __method, ^zip/Compressor __comp])

JOKER FUNC archive/zip.RegisterDecompressor from archive/zip/register.go:
;; (defn RegisterDecompressor
;;   "RegisterDecompressor allows custom decompressors for a specified method ID.\nThe common methods Store and Deflate are built in.\n\nGo input arguments: (method uint16, dcomp Decompressor)\n\nJoker input arguments: [^Int method, ^go.std.archive.zip/Decompressor dcomp]"
;;   {:added "1.0"
;;    :go "__registerDecompressor(__method, *__dcomp)"}
;;   [^UInt16 __method, ^zip/Decompressor __dcomp])

JOKER TYPE go.std.archive.zip/Compressor:
(def
  ^{:doc "A Compressor returns a new compressing writer, writing to w.\nThe WriteCloser's Close method must be used to flush pending data to w.\nThe Compressor itself must be safe to invoke from multiple goroutines\nsimultaneously, but each returned writer will be used only by\none goroutine at a time.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Compressor"}
  Compressor)

JOKER TYPE go.std.archive.zip/Decompressor:
(def
  ^{:doc "A Decompressor returns a new decompressing reader, reading from r.\nThe ReadCloser's Close method must be used to release associated resources.\nThe Decompressor itself must be safe to invoke from multiple goroutines\nsimultaneously, but each returned reader will be used only by\none goroutine at a time.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Decompressor"}
  Decompressor)

JOKER TYPE go.std.archive.zip/File:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_File"}
  File)

JOKER TYPE go.std.archive.zip/FileHeader:
(def
  ^{:doc "FileHeader describes a file within a zip file.\nSee the zip spec for details.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FileHeader"}
  FileHeader)

JOKER TYPE go.std.archive.zip/ReadCloser:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_ReadCloser"}
  ReadCloser)

JOKER TYPE go.std.archive.zip/Reader:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Reader"}
  Reader)

JOKER TYPE go.std.archive.zip/Writer:
(def
  ^{:doc "Writer implements a zip file writer.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Writer"}
  Writer)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["archive/zip"]
    :doc "Provides a low-level interface to the archive/zip package.\n\nPackage zip provides support for reading and writing ZIP archives.\n\nSee: https://www.pkware.com/appnote\n\nThis package does not support disk spanning.\n\nA note about ZIP64:\n\nTo be backwards compatible the FileHeader has both 32 and 64 bit Size\nfields. The 64 bit fields will always contain the correct value and\nfor normal archives both fields will be the same. For files requiring\nthe ZIP64 format the 32 bit fields will be 0xffffffff and the 64 bit\nfields must be used instead.\n"
    :empty false}
  go.std.archive.zip)
JOKER CONSTANT MaxScanTokenSize from bufio/scan.go:
(def
  ^{:doc "MaxScanTokenSize is the maximum size used to buffer a token\nunless the user provides an explicit buffer with Scan.Buffer.\nThe actual maximum token size may be smaller as the buffer\nmay need to include, for instance, a newline.\n"
    :added "1.0"
    :tag "Int"
    :go "bufio.MaxScanTokenSize"}
  MaxScanTokenSize)

JOKER VARIABLE ErrAdvanceTooFar from bufio/scan.go:
(def
  ^{:doc "Errors returned by Scanner.\n"
    :added "1.0"
    :tag "Var"
    :go "bufio.ErrAdvanceTooFar"}
  ErrAdvanceTooFar)

JOKER VARIABLE ErrBufferFull from bufio/bufio.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "bufio.ErrBufferFull"}
  ErrBufferFull)

JOKER VARIABLE ErrFinalToken from bufio/scan.go:
(def
  ^{:doc "ErrFinalToken is a special sentinel error value. It is intended to be\nreturned by a Split function to indicate that the token being delivered\nwith the error is the last token and scanning should stop after this one.\nAfter ErrFinalToken is received by Scan, scanning stops with no error.\nThe value is useful to stop processing early or when it is necessary to\ndeliver a final empty token. One could achieve the same behavior\nwith a custom error value but providing one here is tidier.\nSee the emptyFinalToken example for a use of this value.\n"
    :added "1.0"
    :tag "Var"
    :go "bufio.ErrFinalToken"}
  ErrFinalToken)

JOKER VARIABLE ErrInvalidUnreadByte from bufio/bufio.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "bufio.ErrInvalidUnreadByte"}
  ErrInvalidUnreadByte)

JOKER VARIABLE ErrInvalidUnreadRune from bufio/bufio.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "bufio.ErrInvalidUnreadRune"}
  ErrInvalidUnreadRune)

JOKER VARIABLE ErrNegativeAdvance from bufio/scan.go:
(def
  ^{:doc "Errors returned by Scanner.\n"
    :added "1.0"
    :tag "Var"
    :go "bufio.ErrNegativeAdvance"}
  ErrNegativeAdvance)

JOKER VARIABLE ErrNegativeCount from bufio/bufio.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "bufio.ErrNegativeCount"}
  ErrNegativeCount)

JOKER VARIABLE ErrTooLong from bufio/scan.go:
(def
  ^{:doc "Errors returned by Scanner.\n"
    :added "1.0"
    :tag "Var"
    :go "bufio.ErrTooLong"}
  ErrTooLong)

JOKER TYPE bufio.ReadWriter from bufio/bufio.go:
(defn ^"GoObject" ReadWriter.
  "Constructor for bufio.ReadWriter"
  {:added "1.0"
   :go "_ConstructReadWriter(_v)"}
  [^Object _v])

JOKER TYPE bufio.Reader from bufio/bufio.go:
(defn ^"GoObject" Reader.
  "Constructor for bufio.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER TYPE bufio.Scanner from bufio/scan.go:
(defn ^"GoObject" Scanner.
  "Constructor for bufio.Scanner"
  {:added "1.0"
   :go "_ConstructScanner(_v)"}
  [^Object _v])

JOKER TYPE bufio.SplitFunc from bufio/scan.go:
;; (defn ^"GoObject" SplitFunc.
;;   "Constructor for bufio.SplitFunc"
;;   {:added "1.0"
;;    :go "_ConstructSplitFunc(_v)"}
;;   [^Object _v])

JOKER TYPE bufio.Writer from bufio/bufio.go:
(defn ^"GoObject" Writer.
  "Constructor for bufio.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC bufio.NewReadWriter from bufio/bufio.go:
(defn NewReadWriter
  "NewReadWriter allocates a new ReadWriter that dispatches to r and w.\n\nGo input arguments: (r *Reader, w *Writer)\n\nGo return type: *ReadWriter\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) r, ^(atom-of go.std.bufio/Writer) w]\n\nJoker return type: (atom-of go.std.bufio/ReadWriter)"
  {:added "1.0"
   :go "__newReadWriter(__r, __w)"}
  [^bufio/Reader __r, ^bufio/Writer __w])

JOKER FUNC bufio.NewReader from bufio/bufio.go:
;; (defn NewReader
;;   "NewReader returns a new Reader whose buffer has the default size.\n\nGo input arguments: (rd io.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader rd]\n\nJoker return type: (atom-of go.std.bufio/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(*__rd)"}
;;   [^io/Reader __rd])

JOKER FUNC bufio.NewReaderSize from bufio/bufio.go:
;; (defn NewReaderSize
;;   "NewReaderSize returns a new Reader whose buffer has at least the specified\nsize. If the argument io.Reader is already a Reader with large enough\nsize, it returns the underlying Reader.\n\nGo input arguments: (rd io.Reader, size int)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader rd, ^Int size]\n\nJoker return type: (atom-of go.std.bufio/Reader)"
;;   {:added "1.0"
;;    :go "__newReaderSize(*__rd, __size)"}
;;   [^io/Reader __rd, ^Int __size])

JOKER FUNC bufio.NewScanner from bufio/scan.go:
;; (defn NewScanner
;;   "NewScanner returns a new Scanner to read from r.\nThe split function defaults to ScanLines.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Scanner\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.bufio/Scanner)"
;;   {:added "1.0"
;;    :go "__newScanner(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC bufio.NewWriter from bufio/bufio.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer whose buffer has the default size.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.bufio/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*__w)"}
;;   [^io/Writer __w])

JOKER FUNC bufio.NewWriterSize from bufio/bufio.go:
;; (defn NewWriterSize
;;   "NewWriterSize returns a new Writer whose buffer has at least the specified\nsize. If the argument io.Writer is already a Writer with large enough\nsize, it returns the underlying Writer.\n\nGo input arguments: (w io.Writer, size int)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w, ^Int size]\n\nJoker return type: (atom-of go.std.bufio/Writer)"
;;   {:added "1.0"
;;    :go "__newWriterSize(*__w, __size)"}
;;   [^io/Writer __w, ^Int __size])

JOKER FUNC bufio.ScanBytes from bufio/scan.go:
;; (defn ScanBytes
;;   "ScanBytes is a split function for a Scanner that returns each byte as a token.\n\nGo input arguments: (data []byte, atEOF bool)\n\nGo return type: (advance int, token []byte, err error)\n\nJoker input arguments: [^(vector-of Int) data, ^Boolean atEOF]\n\nJoker return type: [Int (vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__scanBytes(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)), __atEOF)"}
;;   [^Object __data, ^Boolean __atEOF])

JOKER FUNC bufio.ScanLines from bufio/scan.go:
;; (defn ScanLines
;;   "ScanLines is a split function for a Scanner that returns each line of\ntext, stripped of any trailing end-of-line marker. The returned line may\nbe empty. The end-of-line marker is one optional carriage return followed\nby one mandatory newline. In regular expression notation, it is `\\r?\\n`.\nThe last non-empty line of input will be returned even if it has no\nnewline.\n\nGo input arguments: (data []byte, atEOF bool)\n\nGo return type: (advance int, token []byte, err error)\n\nJoker input arguments: [^(vector-of Int) data, ^Boolean atEOF]\n\nJoker return type: [Int (vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__scanLines(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)), __atEOF)"}
;;   [^Object __data, ^Boolean __atEOF])

JOKER FUNC bufio.ScanRunes from bufio/scan.go:
;; (defn ScanRunes
;;   "ScanRunes is a split function for a Scanner that returns each\nUTF-8-encoded rune as a token. The sequence of runes returned is\nequivalent to that from a range loop over the input as a string, which\nmeans that erroneous UTF-8 encodings translate to U+FFFD = \"\\xef\\xbf\\xbd\".\nBecause of the Scan interface, this makes it impossible for the client to\ndistinguish correctly encoded replacement runes from encoding errors.\n\nGo input arguments: (data []byte, atEOF bool)\n\nGo return type: (advance int, token []byte, err error)\n\nJoker input arguments: [^(vector-of Int) data, ^Boolean atEOF]\n\nJoker return type: [Int (vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__scanRunes(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)), __atEOF)"}
;;   [^Object __data, ^Boolean __atEOF])

JOKER FUNC bufio.ScanWords from bufio/scan.go:
;; (defn ScanWords
;;   "ScanWords is a split function for a Scanner that returns each\nspace-separated word of text, with surrounding spaces deleted. It will\nnever return an empty string. The definition of space is set by\nunicode.IsSpace.\n\nGo input arguments: (data []byte, atEOF bool)\n\nGo return type: (advance int, token []byte, err error)\n\nJoker input arguments: [^(vector-of Int) data, ^Boolean atEOF]\n\nJoker return type: [Int (vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__scanWords(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)), __atEOF)"}
;;   [^Object __data, ^Boolean __atEOF])

JOKER TYPE go.std.bufio/ReadWriter:
(def
  ^{:doc "ReadWriter stores pointers to a Reader and a Writer.\nIt implements io.ReadWriter.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ReadWriter"}
  ReadWriter)

JOKER TYPE go.std.bufio/Reader:
(def
  ^{:doc "Reader implements buffering for an io.Reader object.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Reader"}
  Reader)

JOKER TYPE go.std.bufio/Scanner:
(def
  ^{:doc "Scanner provides a convenient interface for reading data such as\na file of newline-delimited lines of text. Successive calls to\nthe Scan method will step through the 'tokens' of a file, skipping\nthe bytes between the tokens. The specification of a token is\ndefined by a split function of type SplitFunc; the default split\nfunction breaks the input into lines with line termination stripped. Split\nfunctions are defined in this package for scanning a file into\nlines, bytes, UTF-8-encoded runes, and space-delimited words. The\nclient may instead provide a custom split function.\n\nScanning stops unrecoverably at EOF, the first I/O error, or a token too\nlarge to fit in the buffer. When a scan stops, the reader may have\nadvanced arbitrarily far past the last token. Programs that need more\ncontrol over error handling or large tokens, or must run sequential scans\non a reader, should use bufio.Reader instead.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Scanner"}
  Scanner)

JOKER TYPE go.std.bufio/SplitFunc:
(def
  ^{:doc "SplitFunc is the signature of the split function used to tokenize the\ninput. The arguments are an initial substring of the remaining unprocessed\ndata and a flag, atEOF, that reports whether the Reader has no more data\nto give. The return values are the number of bytes to advance the input\nand the next token to return to the user, if any, plus an error, if any.\n\nScanning stops if the function returns an error, in which case some of\nthe input may be discarded.\n\nOtherwise, the Scanner advances the input. If the token is not nil,\nthe Scanner returns it to the user. If the token is nil, the\nScanner reads more data and continues scanning; if there is no more\ndata--if atEOF was true--the Scanner returns. If the data does not\nyet hold a complete token, for instance if it has no newline while\nscanning lines, a SplitFunc can return (0, nil, nil) to signal the\nScanner to read more data into the slice and try again with a\nlonger slice starting at the same point in the input.\n\nThe function is never called with an empty data slice unless atEOF\nis true. If atEOF is true, however, data may be non-empty and,\nas always, holds unprocessed text.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SplitFunc"}
  SplitFunc)

JOKER TYPE go.std.bufio/Writer:
(def
  ^{:doc "Writer implements buffering for an io.Writer object.\nIf an error occurs writing to a Writer, no more data will be\naccepted and all subsequent writes, and Flush, will return the error.\nAfter all data has been written, the client should call the\nFlush method to guarantee all data has been forwarded to\nthe underlying io.Writer.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Writer"}
  Writer)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["bufio"]
    :doc "Provides a low-level interface to the bufio package.\n\nPackage bufio implements buffered I/O. It wraps an io.Reader or io.Writer\nobject, creating another object (Reader or Writer) that also implements\nthe interface but provides buffering and some help for textual I/O.\n"
    :empty false}
  go.std.bufio)
JOKER CONSTANT MinRead from bytes/buffer.go:
(def
  ^{:doc "MinRead is the minimum slice size passed to a Read call by\nBuffer.ReadFrom. As long as the Buffer has at least MinRead bytes beyond\nwhat is required to hold the contents of r, ReadFrom will not grow the\nunderlying buffer.\n"
    :added "1.0"
    :tag "Int"
    :go "bytes.MinRead"}
  MinRead)

JOKER VARIABLE ErrTooLarge from bytes/buffer.go:
(def
  ^{:doc "ErrTooLarge is passed to panic if memory cannot be allocated to store data in a buffer.\n"
    :added "1.0"
    :tag "Var"
    :go "bytes.ErrTooLarge"}
  ErrTooLarge)

JOKER TYPE bytes.Buffer from bytes/buffer.go:
(defn ^"GoObject" Buffer.
  "Constructor for bytes.Buffer"
  {:added "1.0"
   :go "_ConstructBuffer(_v)"}
  [^Object _v])

JOKER TYPE bytes.Reader from bytes/reader.go:
(defn ^"GoObject" Reader.
  "Constructor for bytes.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER FUNC bytes.Compare from bytes/bytes.go:
;; (defn ^"Int" Compare
;;   "Compare returns an integer comparing two byte slices lexicographically.\nThe result will be 0 if a==b, -1 if a < b, and +1 if a > b.\nA nil argument is equivalent to an empty slice.\n\nGo input arguments: (a []byte, b []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) a, ^(vector-of Int) b]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.Compare(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__a)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))"}
;;   [^Object __a, ^Object __b])

JOKER FUNC bytes.Contains from bytes/bytes.go:
;; (defn ^"Boolean" Contains
;;   "Contains reports whether subslice is within b.\n\nGo input arguments: (b []byte, subslice []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) b, ^(vector-of Int) subslice]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "bytes.Contains(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__subslice)))"}
;;   [^Object __b, ^Object __subslice])

JOKER FUNC bytes.ContainsAny from bytes/bytes.go:
;; (defn ^"Boolean" ContainsAny
;;   "ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b.\n\nGo input arguments: (b []byte, chars string)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) b, ^String chars]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "bytes.ContainsAny(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), __chars)"}
;;   [^Object __b, ^String __chars])

JOKER FUNC bytes.ContainsRune from bytes/bytes.go:
;; (defn ^"Boolean" ContainsRune
;;   "ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b.\n\nGo input arguments: (b []byte, r rune)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) b, ^Char r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "bytes.ContainsRune(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), __r)"}
;;   [^Object __b, ^Char __r])

JOKER FUNC bytes.Count from bytes/bytes.go:
;; (defn ^"Int" Count
;;   "Count counts the number of non-overlapping instances of sep in s.\nIf sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) sep]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.Count(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__sep)))"}
;;   [^Object __s, ^Object __sep])

JOKER FUNC bytes.Equal from bytes/bytes.go:
;; (defn ^"Boolean" Equal
;;   "Equal returns a boolean reporting whether a and b\nare the same length and contain the same bytes.\nA nil argument is equivalent to an empty slice.\n\nGo input arguments: (a []byte, b []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) a, ^(vector-of Int) b]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "bytes.Equal(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__a)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))"}
;;   [^Object __a, ^Object __b])

JOKER FUNC bytes.EqualFold from bytes/bytes.go:
;; (defn ^"Boolean" EqualFold
;;   "EqualFold reports whether s and t, interpreted as UTF-8 strings,\nare equal under Unicode case-folding.\n\nGo input arguments: (s []byte, t []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) t]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "bytes.EqualFold(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__t)))"}
;;   [^Object __s, ^Object __t])

JOKER FUNC bytes.Fields from bytes/bytes.go:
;; (defn Fields
;;   "Fields interprets s as a sequence of UTF-8-encoded code points.\nIt splits the slice s around each instance of one or more consecutive white space\ncharacters, as defined by unicode.IsSpace, returning a slice of subslices of s or an\nempty slice if s contains only white space.\n\nGo input arguments: (s []byte)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Int) s]\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "__fields(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)))"}
;;   [^Object __s])

JOKER FUNC bytes.FieldsFunc from bytes/bytes.go:
;; (defn FieldsFunc
;;   "FieldsFunc interprets s as a sequence of UTF-8-encoded code points.\nIt splits the slice s at each run of code points c satisfying f(c) and\nreturns a slice of subslices of s. If all code points in s satisfy f(c), or\nlen(s) == 0, an empty slice is returned.\nFieldsFunc makes no guarantees about the order in which it calls f(c).\nIf f does not return consistent results for a given c, FieldsFunc may crash.\n\nGo input arguments: (s []byte, f func)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Int) s, ^fn f]\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "__fieldsFunc(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object __s, ^fn __f])

JOKER FUNC bytes.HasPrefix from bytes/bytes.go:
;; (defn ^"Boolean" HasPrefix
;;   "HasPrefix tests whether the byte slice s begins with prefix.\n\nGo input arguments: (s []byte, prefix []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) prefix]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "bytes.HasPrefix(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__prefix)))"}
;;   [^Object __s, ^Object __prefix])

JOKER FUNC bytes.HasSuffix from bytes/bytes.go:
;; (defn ^"Boolean" HasSuffix
;;   "HasSuffix tests whether the byte slice s ends with suffix.\n\nGo input arguments: (s []byte, suffix []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) suffix]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "bytes.HasSuffix(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__suffix)))"}
;;   [^Object __s, ^Object __suffix])

JOKER FUNC bytes.Index from bytes/bytes.go:
;; (defn ^"Int" Index
;;   "Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) sep]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.Index(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__sep)))"}
;;   [^Object __s, ^Object __sep])

JOKER FUNC bytes.IndexAny from bytes/bytes.go:
;; (defn ^"Int" IndexAny
;;   "IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points.\nIt returns the byte index of the first occurrence in s of any of the Unicode\ncode points in chars. It returns -1 if chars is empty or if there is no code\npoint in common.\n\nGo input arguments: (s []byte, chars string)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) s, ^String chars]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexAny(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), __chars)"}
;;   [^Object __s, ^String __chars])

JOKER FUNC bytes.IndexByte from bytes/bytes.go:
;; (defn ^"Int" IndexByte
;;   "IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b.\n\nGo input arguments: (b []byte, c byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) b, ^Int c]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexByte(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), __c)"}
;;   [^Object __b, ^Byte __c])

JOKER FUNC bytes.IndexFunc from bytes/bytes.go:
;; (defn ^"Int" IndexFunc
;;   "IndexFunc interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index in s of the first Unicode\ncode point satisfying f(c), or -1 if none do.\n\nGo input arguments: (s []byte, f func)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) s, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexFunc(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object __s, ^fn __f])

JOKER FUNC bytes.IndexRune from bytes/bytes.go:
;; (defn ^"Int" IndexRune
;;   "IndexRune interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index of the first occurrence in s of the given rune.\nIt returns -1 if rune is not present in s.\nIf r is utf8.RuneError, it returns the first instance of any\ninvalid UTF-8 byte sequence.\n\nGo input arguments: (s []byte, r rune)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) s, ^Char r]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexRune(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), __r)"}
;;   [^Object __s, ^Char __r])

JOKER FUNC bytes.Join from bytes/bytes.go:
;; (defn Join
;;   "Join concatenates the elements of s to create a new byte slice. The separator\nsep is placed between elements in the resulting slice.\n\nGo input arguments: (s [][]byte, sep []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of (vector-of Int)) s, ^(vector-of Int) sep]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__join(ConvertToArrayOf[]byte(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s))), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__sep)))"}
;;   [^Object __s, ^Object __sep])

JOKER FUNC bytes.LastIndex from bytes/bytes.go:
;; (defn ^"Int" LastIndex
;;   "LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) sep]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.LastIndex(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__sep)))"}
;;   [^Object __s, ^Object __sep])

JOKER FUNC bytes.LastIndexAny from bytes/bytes.go:
;; (defn ^"Int" LastIndexAny
;;   "LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code\npoints. It returns the byte index of the last occurrence in s of any of\nthe Unicode code points in chars. It returns -1 if chars is empty or if\nthere is no code point in common.\n\nGo input arguments: (s []byte, chars string)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) s, ^String chars]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.LastIndexAny(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), __chars)"}
;;   [^Object __s, ^String __chars])

JOKER FUNC bytes.LastIndexByte from bytes/bytes.go:
;; (defn ^"Int" LastIndexByte
;;   "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.\n\nGo input arguments: (s []byte, c byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) s, ^Int c]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.LastIndexByte(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), __c)"}
;;   [^Object __s, ^Byte __c])

JOKER FUNC bytes.LastIndexFunc from bytes/bytes.go:
;; (defn ^"Int" LastIndexFunc
;;   "LastIndexFunc interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index in s of the last Unicode\ncode point satisfying f(c), or -1 if none do.\n\nGo input arguments: (s []byte, f func)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) s, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.LastIndexFunc(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object __s, ^fn __f])

JOKER FUNC bytes.Map from bytes/bytes.go:
;; (defn Map
;;   "Map returns a copy of the byte slice s with all its characters modified\naccording to the mapping function. If mapping returns a negative value, the character is\ndropped from the byte slice with no replacement. The characters in s and the\noutput are interpreted as UTF-8-encoded code points.\n\nGo input arguments: (mapping func, s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^fn mapping, ^(vector-of Int) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__map(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)))"}
;;   [^fn __mapping, ^Object __s])

JOKER FUNC bytes.NewBuffer from bytes/buffer.go:
;; (defn NewBuffer
;;   "NewBuffer creates and initializes a new Buffer using buf as its\ninitial contents. The new Buffer takes ownership of buf, and the\ncaller should not use buf after this call. NewBuffer is intended to\nprepare a Buffer to read existing data. It can also be used to set\nthe initial size of the internal buffer for writing. To do that,\nbuf should have the desired capacity but a length of zero.\n\nIn most cases, new(Buffer) (or just declaring a Buffer variable) is\nsufficient to initialize a Buffer.\n\nGo input arguments: (buf []byte)\n\nGo return type: *Buffer\n\nJoker input arguments: [^(vector-of Int) buf]\n\nJoker return type: (atom-of go.std.bytes/Buffer)"
;;   {:added "1.0"
;;    :go "__newBuffer(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__buf)))"}
;;   [^Object __buf])

JOKER FUNC bytes.NewBufferString from bytes/buffer.go:
(defn NewBufferString
  "NewBufferString creates and initializes a new Buffer using string s as its\ninitial contents. It is intended to prepare a buffer to read an existing\nstring.\n\nIn most cases, new(Buffer) (or just declaring a Buffer variable) is\nsufficient to initialize a Buffer.\n\nGo input arguments: (s string)\n\nGo return type: *Buffer\n\nJoker input arguments: [^String s]\n\nJoker return type: (atom-of go.std.bytes/Buffer)"
  {:added "1.0"
   :go "__newBufferString(__s)"}
  [^String __s])

JOKER FUNC bytes.NewReader from bytes/reader.go:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from b.\n\nGo input arguments: (b []byte)\n\nGo return type: *Reader\n\nJoker input arguments: [^(vector-of Int) b]\n\nJoker return type: (atom-of go.std.bytes/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))"}
;;   [^Object __b])

JOKER FUNC bytes.Repeat from bytes/bytes.go:
;; (defn Repeat
;;   "Repeat returns a new byte slice consisting of count copies of b.\n\nIt panics if count is negative or if\nthe result of (len(b) * count) overflows.\n\nGo input arguments: (b []byte, count int)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) b, ^Int count]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__repeat(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), __count)"}
;;   [^Object __b, ^Int __count])

JOKER FUNC bytes.Replace from bytes/bytes.go:
;; (defn Replace
;;   "Replace returns a copy of the slice s with the first n\nnon-overlapping instances of old replaced by new.\nIf old is empty, it matches at the beginning of the slice\nand after each UTF-8 sequence, yielding up to k+1 replacements\nfor a k-rune slice.\nIf n < 0, there is no limit on the number of replacements.\n\nGo input arguments: (s []byte, old []byte, new []byte, n int)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) old, ^(vector-of Int) new, ^Int n]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__replace(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__old)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__new)), __n)"}
;;   [^Object __s, ^Object __old, ^Object __new, ^Int __n])

JOKER FUNC bytes.ReplaceAll from bytes/bytes.go:
;; (defn ReplaceAll
;;   "ReplaceAll returns a copy of the slice s with all\nnon-overlapping instances of old replaced by new.\nIf old is empty, it matches at the beginning of the slice\nand after each UTF-8 sequence, yielding up to k+1 replacements\nfor a k-rune slice.\n\nGo input arguments: (s []byte, old []byte, new []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) old, ^(vector-of Int) new]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__replaceAll(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__old)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__new)))"}
;;   [^Object __s, ^Object __old, ^Object __new])

JOKER FUNC bytes.Runes from bytes/bytes.go:
;; (defn Runes
;;   "Runes interprets s as a sequence of UTF-8-encoded code points.\nIt returns a slice of runes (Unicode code points) equivalent to s.\n\nGo input arguments: (s []byte)\n\nGo return type: []rune\n\nJoker input arguments: [^(vector-of Int) s]\n\nJoker return type: (vector-of Char)"
;;   {:added "1.0"
;;    :go "__runes(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)))"}
;;   [^Object __s])

JOKER FUNC bytes.Split from bytes/bytes.go:
;; (defn Split
;;   "Split slices s into all subslices separated by sep and returns a slice of\nthe subslices between those separators.\nIf sep is empty, Split splits after each UTF-8 sequence.\nIt is equivalent to SplitN with a count of -1.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) sep]\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "__split(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__sep)))"}
;;   [^Object __s, ^Object __sep])

JOKER FUNC bytes.SplitAfter from bytes/bytes.go:
;; (defn SplitAfter
;;   "SplitAfter slices s into all subslices after each instance of sep and\nreturns a slice of those subslices.\nIf sep is empty, SplitAfter splits after each UTF-8 sequence.\nIt is equivalent to SplitAfterN with a count of -1.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) sep]\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "__splitAfter(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__sep)))"}
;;   [^Object __s, ^Object __sep])

JOKER FUNC bytes.SplitAfterN from bytes/bytes.go:
;; (defn SplitAfterN
;;   "SplitAfterN slices s into subslices after each instance of sep and\nreturns a slice of those subslices.\nIf sep is empty, SplitAfterN splits after each UTF-8 sequence.\nThe count determines the number of subslices to return:\n  n > 0: at most n subslices; the last subslice will be the unsplit remainder.\n  n == 0: the result is nil (zero subslices)\n  n < 0: all subslices\n\nGo input arguments: (s []byte, sep []byte, n int)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) sep, ^Int n]\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "__splitAfterN(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__sep)), __n)"}
;;   [^Object __s, ^Object __sep, ^Int __n])

JOKER FUNC bytes.SplitN from bytes/bytes.go:
;; (defn SplitN
;;   "SplitN slices s into subslices separated by sep and returns a slice of\nthe subslices between those separators.\nIf sep is empty, SplitN splits after each UTF-8 sequence.\nThe count determines the number of subslices to return:\n  n > 0: at most n subslices; the last subslice will be the unsplit remainder.\n  n == 0: the result is nil (zero subslices)\n  n < 0: all subslices\n\nGo input arguments: (s []byte, sep []byte, n int)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) sep, ^Int n]\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "__splitN(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__sep)), __n)"}
;;   [^Object __s, ^Object __sep, ^Int __n])

JOKER FUNC bytes.Title from bytes/bytes.go:
;; (defn Title
;;   "Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin\nwords mapped to their title case.\n\nBUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\n\nGo input arguments: (s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__title(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)))"}
;;   [^Object __s])

JOKER FUNC bytes.ToLower from bytes/bytes.go:
;; (defn ToLower
;;   "ToLower treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case.\n\nGo input arguments: (s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__toLower(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)))"}
;;   [^Object __s])

JOKER FUNC bytes.ToLowerSpecial from bytes/bytes.go:
;; (defn ToLowerSpecial
;;   "ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\nlower case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^(vector-of Int) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__toLowerSpecial(*__c, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)))"}
;;   [^unicode/SpecialCase __c, ^Object __s])

JOKER FUNC bytes.ToTitle from bytes/bytes.go:
;; (defn ToTitle
;;   "ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.\n\nGo input arguments: (s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__toTitle(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)))"}
;;   [^Object __s])

JOKER FUNC bytes.ToTitleSpecial from bytes/bytes.go:
;; (defn ToTitleSpecial
;;   "ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\ntitle case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^(vector-of Int) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__toTitleSpecial(*__c, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)))"}
;;   [^unicode/SpecialCase __c, ^Object __s])

JOKER FUNC bytes.ToUpper from bytes/bytes.go:
;; (defn ToUpper
;;   "ToUpper treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters within it mapped to their upper case.\n\nGo input arguments: (s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__toUpper(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)))"}
;;   [^Object __s])

JOKER FUNC bytes.ToUpperSpecial from bytes/bytes.go:
;; (defn ToUpperSpecial
;;   "ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\nupper case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^(vector-of Int) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__toUpperSpecial(*__c, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)))"}
;;   [^unicode/SpecialCase __c, ^Object __s])

JOKER FUNC bytes.Trim from bytes/bytes.go:
;; (defn Trim
;;   "Trim returns a subslice of s by slicing off all leading and\ntrailing UTF-8-encoded code points contained in cutset.\n\nGo input arguments: (s []byte, cutset string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s, ^String cutset]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trim(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), __cutset)"}
;;   [^Object __s, ^String __cutset])

JOKER FUNC bytes.TrimFunc from bytes/bytes.go:
;; (defn TrimFunc
;;   "TrimFunc returns a subslice of s by slicing off all leading and trailing\nUTF-8-encoded code points c that satisfy f(c).\n\nGo input arguments: (s []byte, f func)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s, ^fn f]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimFunc(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object __s, ^fn __f])

JOKER FUNC bytes.TrimLeft from bytes/bytes.go:
;; (defn TrimLeft
;;   "TrimLeft returns a subslice of s by slicing off all leading\nUTF-8-encoded code points contained in cutset.\n\nGo input arguments: (s []byte, cutset string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s, ^String cutset]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimLeft(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), __cutset)"}
;;   [^Object __s, ^String __cutset])

JOKER FUNC bytes.TrimLeftFunc from bytes/bytes.go:
;; (defn TrimLeftFunc
;;   "TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off\nall leading UTF-8-encoded code points c that satisfy f(c).\n\nGo input arguments: (s []byte, f func)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s, ^fn f]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimLeftFunc(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object __s, ^fn __f])

JOKER FUNC bytes.TrimPrefix from bytes/bytes.go:
;; (defn TrimPrefix
;;   "TrimPrefix returns s without the provided leading prefix string.\nIf s doesn't start with prefix, s is returned unchanged.\n\nGo input arguments: (s []byte, prefix []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) prefix]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimPrefix(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__prefix)))"}
;;   [^Object __s, ^Object __prefix])

JOKER FUNC bytes.TrimRight from bytes/bytes.go:
;; (defn TrimRight
;;   "TrimRight returns a subslice of s by slicing off all trailing\nUTF-8-encoded code points that are contained in cutset.\n\nGo input arguments: (s []byte, cutset string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s, ^String cutset]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimRight(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), __cutset)"}
;;   [^Object __s, ^String __cutset])

JOKER FUNC bytes.TrimRightFunc from bytes/bytes.go:
;; (defn TrimRightFunc
;;   "TrimRightFunc returns a subslice of s by slicing off all trailing\nUTF-8-encoded code points c that satisfy f(c).\n\nGo input arguments: (s []byte, f func)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s, ^fn f]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimRightFunc(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object __s, ^fn __f])

JOKER FUNC bytes.TrimSpace from bytes/bytes.go:
;; (defn TrimSpace
;;   "TrimSpace returns a subslice of s by slicing off all leading and\ntrailing white space, as defined by Unicode.\n\nGo input arguments: (s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimSpace(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)))"}
;;   [^Object __s])

JOKER FUNC bytes.TrimSuffix from bytes/bytes.go:
;; (defn TrimSuffix
;;   "TrimSuffix returns s without the provided trailing suffix string.\nIf s doesn't end with suffix, s is returned unchanged.\n\nGo input arguments: (s []byte, suffix []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) suffix]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimSuffix(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__suffix)))"}
;;   [^Object __s, ^Object __suffix])

JOKER TYPE go.std.bytes/Buffer:
(def
  ^{:doc "A Buffer is a variable-sized buffer of bytes with Read and Write methods.\nThe zero value for Buffer is an empty buffer ready to use.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Buffer"}
  Buffer)

JOKER TYPE go.std.bytes/Reader:
(def
  ^{:doc "A Reader implements the io.Reader, io.ReaderAt, io.WriterTo, io.Seeker,\nio.ByteScanner, and io.RuneScanner interfaces by reading from\na byte slice.\nUnlike a Buffer, a Reader is read-only and supports seeking.\nThe zero value for Reader operates like a Reader of an empty slice.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Reader"}
  Reader)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["bytes"]
    :doc "Provides a low-level interface to the bytes package.\n\nPackage bytes implements functions for the manipulation of byte slices.\nIt is analogous to the facilities of the strings package.\n"
    :empty false}
  go.std.bytes)
JOKER TYPE compress/bzip2.StructuralError from compress/bzip2/bzip2.go:
(defn ^"GoObject" StructuralError.
  "Constructor for bzip2.StructuralError"
  {:added "1.0"
   :go "_ConstructStructuralError(_v)"}
  [^Object _v])

JOKER FUNC compress/bzip2.NewReader from compress/bzip2/bzip2.go:
;; (defn NewReader
;;   "NewReader returns an io.Reader which decompresses bzip2 data from r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__newReader(*__r)"}
;;   [^io/Reader __r])

JOKER TYPE go.std.compress.bzip2/StructuralError:
(def
  ^{:doc "A StructuralError is returned when the bzip2 data is found to be\nsyntactically invalid.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_StructuralError"}
  StructuralError)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the compress/bzip2 package.\n\nPackage bzip2 implements bzip2 decompression.\n"
    :empty false}
  go.std.compress.bzip2)
JOKER CONSTANT BestCompression from compress/flate/deflate.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "flate.BestCompression"}
  BestCompression)

JOKER CONSTANT BestSpeed from compress/flate/deflate.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "flate.BestSpeed"}
  BestSpeed)

JOKER CONSTANT DefaultCompression from compress/flate/deflate.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "flate.DefaultCompression"}
  DefaultCompression)

JOKER CONSTANT HuffmanOnly from compress/flate/deflate.go:
(def
  ^{:doc "HuffmanOnly disables Lempel-Ziv match searching and only performs Huffman\nentropy encoding. This mode is useful in compressing data that has\nalready been compressed with an LZ style algorithm (e.g. Snappy or LZ4)\nthat lacks an entropy encoder. Compression gains are achieved when\ncertain bytes in the input stream occur more frequently than others.\n\nNote that HuffmanOnly produces a compressed output that is\nRFC 1951 compliant. That is, any valid DEFLATE decompressor will\ncontinue to be able to decompress this output.\n"
    :added "1.0"
    :tag "Int"
    :go "flate.HuffmanOnly"}
  HuffmanOnly)

JOKER CONSTANT NoCompression from compress/flate/deflate.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "flate.NoCompression"}
  NoCompression)

JOKER TYPE compress/flate.CorruptInputError from compress/flate/inflate.go:
(defn ^"GoObject" CorruptInputError.
  "Constructor for flate.CorruptInputError"
  {:added "1.0"
   :go "_ConstructCorruptInputError(_v)"}
  [^Object _v])

JOKER TYPE compress/flate.InternalError from compress/flate/inflate.go:
(defn ^"GoObject" InternalError.
  "Constructor for flate.InternalError"
  {:added "1.0"
   :go "_ConstructInternalError(_v)"}
  [^Object _v])

JOKER TYPE compress/flate.ReadError from compress/flate/inflate.go:
(defn ^"GoObject" ReadError.
  "Constructor for flate.ReadError"
  {:added "1.0"
   :go "_ConstructReadError(_v)"}
  [^Object _v])

JOKER TYPE compress/flate.Reader from compress/flate/inflate.go:
;; (defn ^"GoObject" Reader.
;;   "Constructor for flate.Reader"
;;   {:added "1.0"
;;    :go "_ConstructReader(_v)"}
;;   [^Object _v])

JOKER TYPE compress/flate.Resetter from compress/flate/inflate.go:
;; (defn ^"GoObject" Resetter.
;;   "Constructor for flate.Resetter"
;;   {:added "1.0"
;;    :go "_ConstructResetter(_v)"}
;;   [^Object _v])

JOKER TYPE compress/flate.WriteError from compress/flate/inflate.go:
(defn ^"GoObject" WriteError.
  "Constructor for flate.WriteError"
  {:added "1.0"
   :go "_ConstructWriteError(_v)"}
  [^Object _v])

JOKER TYPE compress/flate.Writer from compress/flate/deflate.go:
(defn ^"GoObject" Writer.
  "Constructor for flate.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC compress/flate.NewReader from compress/flate/inflate.go:
;; (defn NewReader
;;   "NewReader returns a new ReadCloser that can be used\nto read the uncompressed version of r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser\nwhen finished reading.\n\nThe ReadCloser returned by NewReader also implements Resetter.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.ReadCloser\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "__newReader(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC compress/flate.NewReaderDict from compress/flate/inflate.go:
;; (defn NewReaderDict
;;   "NewReaderDict is like NewReader but initializes the reader\nwith a preset dictionary. The returned Reader behaves as if\nthe uncompressed data stream started with the given dictionary,\nwhich has already been read. NewReaderDict is typically used\nto read data compressed by NewWriterDict.\n\nThe ReadCloser returned by NewReader also implements Resetter.\n\nGo input arguments: (r io.Reader, dict []byte)\n\nGo return type: io.ReadCloser\n\nJoker input arguments: [^go.std.io/Reader r, ^(vector-of Int) dict]\n\nJoker return type: go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "__newReaderDict(*__r, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__dict)))"}
;;   [^io/Reader __r, ^Object __dict])

JOKER FUNC compress/flate.NewWriter from compress/flate/deflate.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer compressing data at the given level.\nFollowing zlib, levels range from 1 (BestSpeed) to 9 (BestCompression);\nhigher levels typically run slower but compress more. Level 0\n(NoCompression) does not attempt any compression; it only adds the\nnecessary DEFLATE framing.\nLevel -1 (DefaultCompression) uses the default compression level.\nLevel -2 (HuffmanOnly) will use Huffman compression only, giving\na very fast compression for all types of input, but sacrificing considerable\ncompression efficiency.\n\nIf level is in the range [-2, 9] then the error returned will be nil.\nOtherwise the error returned will be non-nil.\n\nGo input arguments: (w io.Writer, level int)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Int level]\n\nJoker return type: [(atom-of go.std.compress.flate/Writer) Error]"
;;   {:added "1.0"
;;    :go "__newWriter(*__w, __level)"}
;;   [^io/Writer __w, ^Int __level])

JOKER FUNC compress/flate.NewWriterDict from compress/flate/deflate.go:
;; (defn NewWriterDict
;;   "NewWriterDict is like NewWriter but initializes the new\nWriter with a preset dictionary. The returned Writer behaves\nas if the dictionary had been written to it without producing\nany compressed output. The compressed data written to w\ncan only be decompressed by a Reader initialized with the\nsame dictionary.\n\nGo input arguments: (w io.Writer, level int, dict []byte)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Int level, ^(vector-of Int) dict]\n\nJoker return type: [(atom-of go.std.compress.flate/Writer) Error]"
;;   {:added "1.0"
;;    :go "__newWriterDict(*__w, __level, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__dict)))"}
;;   [^io/Writer __w, ^Int __level, ^Object __dict])

JOKER TYPE go.std.compress.flate/CorruptInputError:
(def
  ^{:doc "A CorruptInputError reports the presence of corrupt input at a given offset.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CorruptInputError"}
  CorruptInputError)

JOKER TYPE go.std.compress.flate/InternalError:
(def
  ^{:doc "An InternalError reports an error in the flate code itself.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_InternalError"}
  InternalError)

JOKER TYPE go.std.compress.flate/ReadError:
(def
  ^{:doc "A ReadError reports an error encountered while reading input.\n\nDeprecated: No longer returned.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ReadError"}
  ReadError)

JOKER TYPE go.std.compress.flate/Reader:
(def
  ^{:doc "The actual read interface needed by NewReader.\nIf the passed in io.Reader does not also have ReadByte,\nthe NewReader will introduce its own buffering.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Reader"}
  Reader)

JOKER TYPE go.std.compress.flate/Resetter:
(def
  ^{:doc "Resetter resets a ReadCloser returned by NewReader or NewReaderDict\nto switch to a new underlying Reader. This permits reusing a ReadCloser\ninstead of allocating a new one.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Resetter"}
  Resetter)

JOKER TYPE go.std.compress.flate/WriteError:
(def
  ^{:doc "A WriteError reports an error encountered while writing output.\n\nDeprecated: No longer returned.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_WriteError"}
  WriteError)

JOKER TYPE go.std.compress.flate/Writer:
(def
  ^{:doc "A Writer takes data written to it and writes the compressed\nform of that data to an underlying writer (see NewWriter).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Writer"}
  Writer)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["compress/flate"]
    :doc "Provides a low-level interface to the compress/flate package.\n\nPackage flate implements the DEFLATE compressed data format, described in\nRFC 1951.  The gzip and zlib packages implement access to DEFLATE-based file\nformats.\n"
    :empty false}
  go.std.compress.flate)
JOKER VARIABLE ErrChecksum from compress/gzip/gunzip.go:
(def
  ^{:doc "ErrChecksum is returned when reading GZIP data that has an invalid checksum.\n"
    :added "1.0"
    :tag "Var"
    :go "gzip.ErrChecksum"}
  ErrChecksum)

JOKER VARIABLE ErrHeader from compress/gzip/gunzip.go:
(def
  ^{:doc "ErrHeader is returned when reading GZIP data that has an invalid header.\n"
    :added "1.0"
    :tag "Var"
    :go "gzip.ErrHeader"}
  ErrHeader)

JOKER TYPE compress/gzip.Header from compress/gzip/gunzip.go:
;; (defn ^"GoObject" Header.
;;   "Constructor for gzip.Header"
;;   {:added "1.0"
;;    :go "_ConstructHeader(_v)"}
;;   [^Object _v])

JOKER TYPE compress/gzip.Reader from compress/gzip/gunzip.go:
(defn ^"GoObject" Reader.
  "Constructor for gzip.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER TYPE compress/gzip.Writer from compress/gzip/gzip.go:
(defn ^"GoObject" Writer.
  "Constructor for gzip.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC compress/gzip.NewReader from compress/gzip/gunzip.go:
;; (defn NewReader
;;   "NewReader creates a new Reader reading the given reader.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\n\nIt is the caller's responsibility to call Close on the Reader when done.\n\nThe Reader.Header fields will be valid in the Reader returned.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (*Reader, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [(atom-of go.std.compress.gzip/Reader) Error]"
;;   {:added "1.0"
;;    :go "__newReader(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC compress/gzip.NewWriter from compress/gzip/gzip.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer.\nWrites to the returned writer are compressed and written to w.\n\nIt is the caller's responsibility to call Close on the Writer when done.\nWrites may be buffered and not flushed until Close.\n\nCallers that wish to set the fields in Writer.Header must do so before\nthe first call to Write, Flush, or Close.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.compress.gzip/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*__w)"}
;;   [^io/Writer __w])

JOKER FUNC compress/gzip.NewWriterLevel from compress/gzip/gzip.go:
;; (defn NewWriterLevel
;;   "NewWriterLevel is like NewWriter but specifies the compression level instead\nof assuming DefaultCompression.\n\nThe compression level can be DefaultCompression, NoCompression, HuffmanOnly\nor any integer value between BestSpeed and BestCompression inclusive.\nThe error returned will be nil if the level is valid.\n\nGo input arguments: (w io.Writer, level int)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Int level]\n\nJoker return type: [(atom-of go.std.compress.gzip/Writer) Error]"
;;   {:added "1.0"
;;    :go "__newWriterLevel(*__w, __level)"}
;;   [^io/Writer __w, ^Int __level])

JOKER TYPE go.std.compress.gzip/Header:
(def
  ^{:doc "The gzip file stores a header giving metadata about the compressed file.\nThat header is exposed as the fields of the Writer and Reader structs.\n\nStrings must be UTF-8 encoded and may only contain Unicode code points\nU+0001 through U+00FF, due to limitations of the GZIP file format.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Header"}
  Header)

JOKER TYPE go.std.compress.gzip/Reader:
(def
  ^{:doc "A Reader is an io.Reader that can be read to retrieve\nuncompressed data from a gzip-format compressed file.\n\nIn general, a gzip file can be a concatenation of gzip files,\neach with its own header. Reads from the Reader\nreturn the concatenation of the uncompressed data of each.\nOnly the first header is recorded in the Reader fields.\n\nGzip files store a length and checksum of the uncompressed data.\nThe Reader will return an ErrChecksum when Read\nreaches the end of the uncompressed data if it does not\nhave the expected length or checksum. Clients should treat data\nreturned by Read as tentative until they receive the io.EOF\nmarking the end of the data.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Reader"}
  Reader)

JOKER TYPE go.std.compress.gzip/Writer:
(def
  ^{:doc "A Writer is an io.WriteCloser.\nWrites to a Writer are compressed and written to w.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Writer"}
  Writer)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["compress/gzip"]
    :doc "Provides a low-level interface to the compress/gzip package.\n\nPackage gzip implements reading and writing of gzip format compressed files,\nas specified in RFC 1952.\n"
    :empty false}
  go.std.compress.gzip)
JOKER CONSTANT LSB from compress/lzw/reader.go:
(def
  ^{:doc "LSB means Least Significant Bits first, as used in the GIF file format.\n"
    :added "1.0"
    :tag "Int"
    :go "int(lzw.LSB)"}
  LSB)

JOKER CONSTANT MSB from compress/lzw/reader.go:
(def
  ^{:doc "MSB means Most Significant Bits first, as used in the TIFF and PDF\nfile formats.\n"
    :added "1.0"
    :tag "Int"
    :go "int(lzw.MSB)"}
  MSB)

JOKER TYPE compress/lzw.Order from compress/lzw/reader.go:
(defn ^"GoObject" Order.
  "Constructor for lzw.Order"
  {:added "1.0"
   :go "_ConstructOrder(_v)"}
  [^Object _v])

JOKER FUNC compress/lzw.NewReader from compress/lzw/reader.go:
;; (defn NewReader
;;   "NewReader creates a new io.ReadCloser.\nReads from the returned io.ReadCloser read and decompress data from r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser when\nfinished reading.\nThe number of bits to use for literal codes, litWidth, must be in the\nrange [2,8] and is typically 8. It must equal the litWidth\nused during compression.\n\nGo input arguments: (r io.Reader, order Order, litWidth int)\n\nGo return type: io.ReadCloser\n\nJoker input arguments: [^go.std.io/Reader r, ^go.std.compress.lzw/Order order, ^Int litWidth]\n\nJoker return type: go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "__newReader(*__r, *__order, __litWidth)"}
;;   [^io/Reader __r, ^lzw/Order __order, ^Int __litWidth])

JOKER FUNC compress/lzw.NewWriter from compress/lzw/writer.go:
;; (defn NewWriter
;;   "NewWriter creates a new io.WriteCloser.\nWrites to the returned io.WriteCloser are compressed and written to w.\nIt is the caller's responsibility to call Close on the WriteCloser when\nfinished writing.\nThe number of bits to use for literal codes, litWidth, must be in the\nrange [2,8] and is typically 8. Input bytes must be less than 1<<litWidth.\n\nGo input arguments: (w io.Writer, order Order, litWidth int)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^go.std.io/Writer w, ^go.std.compress.lzw/Order order, ^Int litWidth]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "__newWriter(*__w, *__order, __litWidth)"}
;;   [^io/Writer __w, ^lzw/Order __order, ^Int __litWidth])

JOKER TYPE go.std.compress.lzw/Order:
(def
  ^{:doc "Order specifies the bit ordering in an LZW data stream.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Order"}
  Order)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["compress/lzw"]
    :doc "Provides a low-level interface to the compress/lzw package.\n\nPackage lzw implements the Lempel-Ziv-Welch compressed data format,\ndescribed in T. A. Welch, ``A Technique for High-Performance Data\nCompression'', Computer, 17(6) (June 1984), pp 8-19.\n\nIn particular, it implements LZW as used by the GIF and PDF file\nformats, which means variable-width codes up to 12 bits and the first\ntwo non-literal codes are a clear code and an EOF code.\n\nThe TIFF file format uses a similar but incompatible version of the LZW\nalgorithm. See the golang.org/x/image/tiff/lzw package for an\nimplementation.\n"
    :empty false}
  go.std.compress.lzw)
JOKER VARIABLE ErrChecksum from compress/zlib/reader.go:
(def
  ^{:doc "ErrChecksum is returned when reading ZLIB data that has an invalid checksum.\n"
    :added "1.0"
    :tag "Var"
    :go "zlib.ErrChecksum"}
  ErrChecksum)

JOKER VARIABLE ErrDictionary from compress/zlib/reader.go:
(def
  ^{:doc "ErrDictionary is returned when reading ZLIB data that has an invalid dictionary.\n"
    :added "1.0"
    :tag "Var"
    :go "zlib.ErrDictionary"}
  ErrDictionary)

JOKER VARIABLE ErrHeader from compress/zlib/reader.go:
(def
  ^{:doc "ErrHeader is returned when reading ZLIB data that has an invalid header.\n"
    :added "1.0"
    :tag "Var"
    :go "zlib.ErrHeader"}
  ErrHeader)

JOKER TYPE compress/zlib.Resetter from compress/zlib/reader.go:
;; (defn ^"GoObject" Resetter.
;;   "Constructor for zlib.Resetter"
;;   {:added "1.0"
;;    :go "_ConstructResetter(_v)"}
;;   [^Object _v])

JOKER TYPE compress/zlib.Writer from compress/zlib/writer.go:
(defn ^"GoObject" Writer.
  "Constructor for zlib.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC compress/zlib.NewReader from compress/zlib/reader.go:
;; (defn NewReader
;;   "NewReader creates a new ReadCloser.\nReads from the returned ReadCloser read and decompress data from r.\nIf r does not implement io.ByteReader, the decompressor may read more\ndata than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser when done.\n\nThe ReadCloser returned by NewReader also implements Resetter.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (io.ReadCloser, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.io/ReadCloser Error]"
;;   {:added "1.0"
;;    :go "__newReader(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC compress/zlib.NewReaderDict from compress/zlib/reader.go:
;; (defn NewReaderDict
;;   "NewReaderDict is like NewReader but uses a preset dictionary.\nNewReaderDict ignores the dictionary if the compressed data does not refer to it.\nIf the compressed data refers to a different dictionary, NewReaderDict returns ErrDictionary.\n\nThe ReadCloser returned by NewReaderDict also implements Resetter.\n\nGo input arguments: (r io.Reader, dict []byte)\n\nGo return type: (io.ReadCloser, error)\n\nJoker input arguments: [^go.std.io/Reader r, ^(vector-of Int) dict]\n\nJoker return type: [go.std.io/ReadCloser Error]"
;;   {:added "1.0"
;;    :go "__newReaderDict(*__r, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__dict)))"}
;;   [^io/Reader __r, ^Object __dict])

JOKER FUNC compress/zlib.NewWriter from compress/zlib/writer.go:
;; (defn NewWriter
;;   "NewWriter creates a new Writer.\nWrites to the returned Writer are compressed and written to w.\n\nIt is the caller's responsibility to call Close on the Writer when done.\nWrites may be buffered and not flushed until Close.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.compress.zlib/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*__w)"}
;;   [^io/Writer __w])

JOKER FUNC compress/zlib.NewWriterLevel from compress/zlib/writer.go:
;; (defn NewWriterLevel
;;   "NewWriterLevel is like NewWriter but specifies the compression level instead\nof assuming DefaultCompression.\n\nThe compression level can be DefaultCompression, NoCompression, HuffmanOnly\nor any integer value between BestSpeed and BestCompression inclusive.\nThe error returned will be nil if the level is valid.\n\nGo input arguments: (w io.Writer, level int)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Int level]\n\nJoker return type: [(atom-of go.std.compress.zlib/Writer) Error]"
;;   {:added "1.0"
;;    :go "__newWriterLevel(*__w, __level)"}
;;   [^io/Writer __w, ^Int __level])

JOKER FUNC compress/zlib.NewWriterLevelDict from compress/zlib/writer.go:
;; (defn NewWriterLevelDict
;;   "NewWriterLevelDict is like NewWriterLevel but specifies a dictionary to\ncompress with.\n\nThe dictionary may be nil. If not, its contents should not be modified until\nthe Writer is closed.\n\nGo input arguments: (w io.Writer, level int, dict []byte)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Int level, ^(vector-of Int) dict]\n\nJoker return type: [(atom-of go.std.compress.zlib/Writer) Error]"
;;   {:added "1.0"
;;    :go "__newWriterLevelDict(*__w, __level, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__dict)))"}
;;   [^io/Writer __w, ^Int __level, ^Object __dict])

JOKER TYPE go.std.compress.zlib/Resetter:
(def
  ^{:doc "Resetter resets a ReadCloser returned by NewReader or NewReaderDict\nto switch to a new underlying Reader. This permits reusing a ReadCloser\ninstead of allocating a new one.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Resetter"}
  Resetter)

JOKER TYPE go.std.compress.zlib/Writer:
(def
  ^{:doc "A Writer takes data written to it and writes the compressed\nform of that data to an underlying writer (see NewWriter).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Writer"}
  Writer)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["compress/zlib"]
    :doc "Provides a low-level interface to the compress/zlib package.\n\nPackage zlib implements reading and writing of zlib format compressed data,\nas specified in RFC 1950.\n\nThe implementation provides filters that uncompress during reading\nand compress during writing.  For example, to write compressed data\nto a buffer:\n\n\tvar b bytes.Buffer\n\tw := zlib.NewWriter(&b)\n\tw.Write([]byte(\"hello, world\\n\"))\n\tw.Close()\n\nand to read that data back:\n\n\tr, err := zlib.NewReader(&b)\n\tio.Copy(os.Stdout, r)\n\tr.Close()\n"
    :empty false}
  go.std.compress.zlib)
JOKER FUNC container/heap.Fix from container/heap/heap.go:
;; (defn Fix
;;   "Fix re-establishes the heap ordering after the element at index i has changed its value.\nChanging the value of the element at index i and then calling Fix is equivalent to,\nbut less expensive than, calling Remove(h, i) followed by a Push of the new value.\nThe complexity is O(log n) where n = h.Len().\n\nGo input arguments: (h Interface, i int)\n\nJoker input arguments: [^go.std.container.heap/Interface h, ^Int i]"
;;   {:added "1.0"
;;    :go "__fix(*__h, __i)"}
;;   [^heap/Interface __h, ^Int __i])

JOKER FUNC container/heap.Init from container/heap/heap.go:
;; (defn Init
;;   "Init establishes the heap invariants required by the other routines in this package.\nInit is idempotent with respect to the heap invariants\nand may be called whenever the heap invariants may have been invalidated.\nThe complexity is O(n) where n = h.Len().\n\nGo input arguments: (h Interface)\n\nJoker input arguments: [^go.std.container.heap/Interface h]"
;;   {:added "1.0"
;;    :go "__init(*__h)"}
;;   [^heap/Interface __h])

JOKER FUNC container/heap.Pop from container/heap/heap.go:
;; (defn Pop
;;   "Pop removes and returns the minimum element (according to Less) from the heap.\nThe complexity is O(log n) where n = h.Len().\nPop is equivalent to Remove(h, 0).\n\nGo input arguments: (h Interface)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.container.heap/Interface h]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.InterfaceType at: /usr/local/go/src/container/heap/heap.go:60:23)"
;;   {:added "1.0"
;;    :go "__pop(*__h)"}
;;   [^heap/Interface __h])

JOKER FUNC container/heap.Push from container/heap/heap.go:
;; (defn Push
;;   "Push pushes the element x onto the heap.\nThe complexity is O(log n) where n = h.Len().\n\nGo input arguments: (h Interface, x interface {})\n\nJoker input arguments: [^go.std.container.heap/Interface h, ^<protocol-or-something> x]"
;;   {:added "1.0"
;;    :go "__push(*__h, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^heap/Interface __h, ^<protocol-or-something> __x])

JOKER FUNC container/heap.Remove from container/heap/heap.go:
;; (defn Remove
;;   "Remove removes and returns the element at index i from the heap.\nThe complexity is O(log n) where n = h.Len().\n\nGo input arguments: (h Interface, i int)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.container.heap/Interface h, ^Int i]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.InterfaceType at: /usr/local/go/src/container/heap/heap.go:69:33)"
;;   {:added "1.0"
;;    :go "__remove(*__h, __i)"}
;;   [^heap/Interface __h, ^Int __i])

JOKER TYPE go.std.container.heap/Interface:
(def
  ^{:doc "The Interface type describes the requirements\nfor a type using the routines in this package.\nAny type that implements it may be used as a\nmin-heap with the following invariants (established after\nInit has been called or if the data is empty or sorted):\n\n\t!h.Less(j, i) for 0 <= i < h.Len() and 2*i+1 <= j <= 2*i+2 and j < h.Len()\n\nNote that Push and Pop in this interface are for package heap's\nimplementation to call. To add and remove things from the heap,\nuse heap.Push and heap.Pop.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Interface"}
  Interface)

JOKER TYPE container/list.Element from container/list/list.go:
;; (defn ^"GoObject" Element.
;;   "Constructor for list.Element"
;;   {:added "1.0"
;;    :go "_ConstructElement(_v)"}
;;   [^Object _v])

JOKER TYPE container/list.List from container/list/list.go:
(defn ^"GoObject" List.
  "Constructor for list.List"
  {:added "1.0"
   :go "_ConstructList(_v)"}
  [^Object _v])

JOKER FUNC container/list.New from container/list/list.go:
(defn New
  "New returns an initialized list.\n\nGo return type: *List\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.container.list/List)"
  {:added "1.0"
   :go "__new()"}
  [])

JOKER TYPE go.std.container.list/Element:
(def
  ^{:doc "Element is an element of a linked list.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Element"}
  Element)

JOKER TYPE go.std.container.list/List:
(def
  ^{:doc "List represents a doubly linked list.\nThe zero value for List is an empty list ready to use.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_List"}
  List)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the container/list package.\n\nPackage list implements a doubly linked list.\n\nTo iterate over a list (where l is a *List):\n\tfor e := l.Front(); e != nil; e = e.Next() {\n\t\t// do something with e.Value\n\t}\n"
    :empty false}
  go.std.container.list)
JOKER TYPE container/ring.Ring from container/ring/ring.go:
;; (defn ^"GoObject" Ring.
;;   "Constructor for ring.Ring"
;;   {:added "1.0"
;;    :go "_ConstructRing(_v)"}
;;   [^Object _v])

JOKER FUNC container/ring.New from container/ring/ring.go:
(defn New
  "New creates a ring of n elements.\n\nGo input arguments: (n int)\n\nGo return type: *Ring\n\nJoker input arguments: [^Int n]\n\nJoker return type: (atom-of go.std.container.ring/Ring)"
  {:added "1.0"
   :go "__new(__n)"}
  [^Int __n])

JOKER TYPE go.std.container.ring/Ring:
(def
  ^{:doc "A Ring is an element of a circular list, or ring.\nRings do not have a beginning or end; a pointer to any ring element\nserves as reference to the entire ring. Empty rings are represented\nas nil Ring pointers. The zero value for a Ring is a one-element\nring with a nil Value.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Ring"}
  Ring)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the container/ring package.\n\nPackage ring implements operations on circular lists.\n"
    :empty false}
  go.std.container.ring)
JOKER VARIABLE Canceled from context/context.go:
(def
  ^{:doc "Canceled is the error returned by Context.Err when the context is canceled.\n"
    :added "1.0"
    :tag "Var"
    :go "context.Canceled"}
  Canceled)

JOKER VARIABLE DeadlineExceeded from context/context.go:
(def
  ^{:doc "DeadlineExceeded is the error returned by Context.Err when the context's\ndeadline passes.\n"
    :added "1.0"
    :tag "Var"
    :go "context.DeadlineExceeded"}
  DeadlineExceeded)

JOKER TYPE context.CancelFunc from context/context.go:
;; (defn ^"GoObject" CancelFunc.
;;   "Constructor for context.CancelFunc"
;;   {:added "1.0"
;;    :go "_ConstructCancelFunc(_v)"}
;;   [^Object _v])

JOKER TYPE context.Context from context/context.go:
;; (defn ^"GoObject" Context.
;;   "Constructor for context.Context"
;;   {:added "1.0"
;;    :go "_ConstructContext(_v)"}
;;   [^Object _v])

JOKER FUNC context.Background from context/context.go:
(defn Background
  "Background returns a non-nil, empty Context. It is never canceled, has no\nvalues, and has no deadline. It is typically used by the main function,\ninitialization, and tests, and as the top-level Context for incoming\nrequests.\n\nGo return type: Context\n\nJoker input arguments: []\n\nJoker return type: go.std.context/Context"
  {:added "1.0"
   :go "__background()"}
  [])

JOKER FUNC context.TODO from context/context.go:
(defn TODO
  "TODO returns a non-nil, empty Context. Code should use context.TODO when\nit's unclear which Context to use or it is not yet available (because the\nsurrounding function has not yet been extended to accept a Context\nparameter).\n\nGo return type: Context\n\nJoker input arguments: []\n\nJoker return type: go.std.context/Context"
  {:added "1.0"
   :go "__tODO()"}
  [])

JOKER FUNC context.WithCancel from context/context.go:
(defn WithCancel
  "WithCancel returns a copy of parent with a new Done channel. The returned\ncontext's Done channel is closed when the returned cancel function is called\nor when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete.\n\nGo input arguments: (parent Context)\n\nGo return type: (ctx Context, cancel CancelFunc)\n\nJoker input arguments: [^go.std.context/Context parent]\n\nJoker return type: [go.std.context/Context go.std.context/CancelFunc]"
  {:added "1.0"
   :go "__withCancel(*__parent)"}
  [^context/Context __parent])

JOKER FUNC context.WithDeadline from context/context.go:
;; (defn WithDeadline
;;   "WithDeadline returns a copy of the parent context with the deadline adjusted\nto be no later than d. If the parent's deadline is already earlier than d,\nWithDeadline(parent, d) is semantically equivalent to parent. The returned\ncontext's Done channel is closed when the deadline expires, when the returned\ncancel function is called, or when the parent context's Done channel is\nclosed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete.\n\nGo input arguments: (parent Context, d time.Time)\n\nGo return type: (Context, CancelFunc)\n\nJoker input arguments: [^go.std.context/Context parent, ^go.std.time/Time d]\n\nJoker return type: [go.std.context/Context go.std.context/CancelFunc]"
;;   {:added "1.0"
;;    :go "__withDeadline(*__parent, *__d)"}
;;   [^context/Context __parent, ^time/Time __d])

JOKER FUNC context.WithTimeout from context/context.go:
;; (defn WithTimeout
;;   "WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete:\n\n\tfunc slowOperationWithTimeout(ctx context.Context) (Result, error) {\n\t\tctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)\n\t\tdefer cancel()  // releases resources if slowOperation completes before timeout elapses\n\t\treturn slowOperation(ctx)\n\t}\n\nGo input arguments: (parent Context, timeout time.Duration)\n\nGo return type: (Context, CancelFunc)\n\nJoker input arguments: [^go.std.context/Context parent, ^go.std.time/Duration timeout]\n\nJoker return type: [go.std.context/Context go.std.context/CancelFunc]"
;;   {:added "1.0"
;;    :go "__withTimeout(*__parent, *__timeout)"}
;;   [^context/Context __parent, ^time/Duration __timeout])

JOKER FUNC context.WithValue from context/context.go:
;; (defn WithValue
;;   "WithValue returns a copy of parent in which the value associated with key is\nval.\n\nUse context Values only for request-scoped data that transits processes and\nAPIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type\nstring or any other built-in type to avoid collisions between\npackages using context. Users of WithValue should define their own\ntypes for keys. To avoid allocating when assigning to an\ninterface{}, context keys often have concrete type\nstruct{}. Alternatively, exported context key variables' static\ntype should be a pointer or interface.\n\nGo input arguments: (parent Context, key interface {}, val interface {})\n\nGo return type: Context\n\nJoker input arguments: [^go.std.context/Context parent, ^<protocol-or-something> key, ^<protocol-or-something> val]\n\nJoker return type: go.std.context/Context"
;;   {:added "1.0"
;;    :go "__withValue(*__parent, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^context/Context __parent, ^<protocol-or-something> __key, ^<protocol-or-something> __val])

JOKER TYPE go.std.context/CancelFunc:
(def
  ^{:doc "A CancelFunc tells an operation to abandon its work.\nA CancelFunc does not wait for the work to stop.\nAfter the first call, subsequent calls to a CancelFunc do nothing.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CancelFunc"}
  CancelFunc)

JOKER TYPE go.std.context/Context:
(def
  ^{:doc "A Context carries a deadline, a cancelation signal, and other values across\nAPI boundaries.\n\nContext's methods may be called by multiple goroutines simultaneously.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Context"}
  Context)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["context"]
    :doc "Provides a low-level interface to the context package.\n\nPackage context defines the Context type, which carries deadlines,\ncancelation signals, and other request-scoped values across API boundaries\nand between processes.\n\nIncoming requests to a server should create a Context, and outgoing\ncalls to servers should accept a Context. The chain of function\ncalls between them must propagate the Context, optionally replacing\nit with a derived Context created using WithCancel, WithDeadline,\nWithTimeout, or WithValue. When a Context is canceled, all\nContexts derived from it are also canceled.\n\nThe WithCancel, WithDeadline, and WithTimeout functions take a\nContext (the parent) and return a derived Context (the child) and a\nCancelFunc. Calling the CancelFunc cancels the child and its\nchildren, removes the parent's reference to the child, and stops\nany associated timers. Failing to call the CancelFunc leaks the\nchild and its children until the parent is canceled or the timer\nfires. The go vet tool checks that CancelFuncs are used on all\ncontrol-flow paths.\n\nPrograms that use Contexts should follow these rules to keep interfaces\nconsistent across packages and enable static analysis tools to check context\npropagation:\n\nDo not store Contexts inside a struct type; instead, pass a Context\nexplicitly to each function that needs it. The Context should be the first\nparameter, typically named ctx:\n\n\tfunc DoSomething(ctx context.Context, arg Arg) error {\n\t\t// ... use ctx ...\n\t}\n\nDo not pass a nil Context, even if a function permits it. Pass context.TODO\nif you are unsure about which Context to use.\n\nUse context Values only for request-scoped data that transits processes and\nAPIs, not for passing optional parameters to functions.\n\nThe same Context may be passed to functions running in different goroutines;\nContexts are safe for simultaneous use by multiple goroutines.\n\nSee https://blog.golang.org/context for example code for a server that uses\nContexts.\n"
    :empty false}
  go.std.context)
JOKER CONSTANT BLAKE2b_256 from crypto/crypto.go:
(def
  ^{:doc "import golang.org/x/crypto/blake2b\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(crypto.BLAKE2b_256))"}
  BLAKE2b_256)

JOKER CONSTANT BLAKE2b_384 from crypto/crypto.go:
(def
  ^{:doc "import golang.org/x/crypto/blake2b\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(crypto.BLAKE2b_384))"}
  BLAKE2b_384)

JOKER CONSTANT BLAKE2b_512 from crypto/crypto.go:
(def
  ^{:doc "import golang.org/x/crypto/blake2b\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(crypto.BLAKE2b_512))"}
  BLAKE2b_512)

JOKER CONSTANT BLAKE2s_256 from crypto/crypto.go:
(def
  ^{:doc "import golang.org/x/crypto/blake2s\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(crypto.BLAKE2s_256))"}
  BLAKE2s_256)

JOKER CONSTANT MD4 from crypto/crypto.go:
(def
  ^{:doc "import golang.org/x/crypto/md4\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(crypto.MD4))"}
  MD4)

JOKER CONSTANT MD5 from crypto/crypto.go:
(def
  ^{:doc "import crypto/md5\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(crypto.MD5))"}
  MD5)

JOKER CONSTANT MD5SHA1 from crypto/crypto.go:
(def
  ^{:doc "no implementation; MD5+SHA1 used for TLS RSA\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(crypto.MD5SHA1))"}
  MD5SHA1)

JOKER CONSTANT RIPEMD160 from crypto/crypto.go:
(def
  ^{:doc "import golang.org/x/crypto/ripemd160\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(crypto.RIPEMD160))"}
  RIPEMD160)

JOKER CONSTANT SHA1 from crypto/crypto.go:
(def
  ^{:doc "import crypto/sha1\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(crypto.SHA1))"}
  SHA1)

JOKER CONSTANT SHA224 from crypto/crypto.go:
(def
  ^{:doc "import crypto/sha256\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(crypto.SHA224))"}
  SHA224)

JOKER CONSTANT SHA256 from crypto/crypto.go:
(def
  ^{:doc "import crypto/sha256\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(crypto.SHA256))"}
  SHA256)

JOKER CONSTANT SHA384 from crypto/crypto.go:
(def
  ^{:doc "import crypto/sha512\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(crypto.SHA384))"}
  SHA384)

JOKER CONSTANT SHA3_224 from crypto/crypto.go:
(def
  ^{:doc "import golang.org/x/crypto/sha3\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(crypto.SHA3_224))"}
  SHA3_224)

JOKER CONSTANT SHA3_256 from crypto/crypto.go:
(def
  ^{:doc "import golang.org/x/crypto/sha3\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(crypto.SHA3_256))"}
  SHA3_256)

JOKER CONSTANT SHA3_384 from crypto/crypto.go:
(def
  ^{:doc "import golang.org/x/crypto/sha3\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(crypto.SHA3_384))"}
  SHA3_384)

JOKER CONSTANT SHA3_512 from crypto/crypto.go:
(def
  ^{:doc "import golang.org/x/crypto/sha3\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(crypto.SHA3_512))"}
  SHA3_512)

JOKER CONSTANT SHA512 from crypto/crypto.go:
(def
  ^{:doc "import crypto/sha512\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(crypto.SHA512))"}
  SHA512)

JOKER CONSTANT SHA512_224 from crypto/crypto.go:
(def
  ^{:doc "import crypto/sha512\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(crypto.SHA512_224))"}
  SHA512_224)

JOKER CONSTANT SHA512_256 from crypto/crypto.go:
(def
  ^{:doc "import crypto/sha512\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(crypto.SHA512_256))"}
  SHA512_256)

JOKER TYPE crypto.Decrypter from crypto/crypto.go:
;; (defn ^"GoObject" Decrypter.
;;   "Constructor for crypto.Decrypter"
;;   {:added "1.0"
;;    :go "_ConstructDecrypter(_v)"}
;;   [^Object _v])

JOKER TYPE crypto.DecrypterOpts from crypto/crypto.go:
;; (defn ^"GoObject" DecrypterOpts.
;;   "Constructor for crypto.DecrypterOpts"
;;   {:added "1.0"
;;    :go "_ConstructDecrypterOpts(_v)"}
;;   [^Object _v])

JOKER TYPE crypto.Hash from crypto/crypto.go:
(defn ^"GoObject" Hash.
  "Constructor for crypto.Hash"
  {:added "1.0"
   :go "_ConstructHash(_v)"}
  [^Object _v])

JOKER TYPE crypto.PrivateKey from crypto/crypto.go:
;; (defn ^"GoObject" PrivateKey.
;;   "Constructor for crypto.PrivateKey"
;;   {:added "1.0"
;;    :go "_ConstructPrivateKey(_v)"}
;;   [^Object _v])

JOKER TYPE crypto.PublicKey from crypto/crypto.go:
;; (defn ^"GoObject" PublicKey.
;;   "Constructor for crypto.PublicKey"
;;   {:added "1.0"
;;    :go "_ConstructPublicKey(_v)"}
;;   [^Object _v])

JOKER TYPE crypto.Signer from crypto/crypto.go:
;; (defn ^"GoObject" Signer.
;;   "Constructor for crypto.Signer"
;;   {:added "1.0"
;;    :go "_ConstructSigner(_v)"}
;;   [^Object _v])

JOKER TYPE crypto.SignerOpts from crypto/crypto.go:
;; (defn ^"GoObject" SignerOpts.
;;   "Constructor for crypto.SignerOpts"
;;   {:added "1.0"
;;    :go "_ConstructSignerOpts(_v)"}
;;   [^Object _v])

JOKER FUNC crypto.RegisterHash from crypto/crypto.go:
;; (defn RegisterHash
;;   "RegisterHash registers a function that returns a new instance of the given\nhash function. This is intended to be called from the init function in\npackages that implement hash functions.\n\nGo input arguments: (h Hash, f func)\n\nJoker input arguments: [^go.std.crypto/Hash h, ^fn f]"
;;   {:added "1.0"
;;    :go "__registerHash(*__h, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^crypto/Hash __h, ^fn __f])

JOKER TYPE go.std.crypto/Decrypter:
(def
  ^{:doc "Decrypter is an interface for an opaque private key that can be used for\nasymmetric decryption operations. An example would be an RSA key\nkept in a hardware module.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Decrypter"}
  Decrypter)

JOKER TYPE go.std.crypto/DecrypterOpts:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_DecrypterOpts"}
  DecrypterOpts)

JOKER TYPE go.std.crypto/Hash:
(def
  ^{:doc "Hash identifies a cryptographic hash function that is implemented in another\npackage.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Hash"}
  Hash)

JOKER TYPE go.std.crypto/PrivateKey:
(def
  ^{:doc "PrivateKey represents a private key using an unspecified algorithm.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PrivateKey"}
  PrivateKey)

JOKER TYPE go.std.crypto/PublicKey:
(def
  ^{:doc "PublicKey represents a public key using an unspecified algorithm.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PublicKey"}
  PublicKey)

JOKER TYPE go.std.crypto/Signer:
(def
  ^{:doc "Signer is an interface for an opaque private key that can be used for\nsigning operations. For example, an RSA key kept in a hardware module.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Signer"}
  Signer)

JOKER TYPE go.std.crypto/SignerOpts:
(def
  ^{:doc "SignerOpts contains options for signing with a Signer.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SignerOpts"}
  SignerOpts)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["crypto"]
    :doc "Provides a low-level interface to the crypto package.\n\nPackage crypto collects common cryptographic constants.\n"
    :empty false}
  go.std.crypto)
JOKER CONSTANT BlockSize from crypto/aes/cipher.go:
(def
  ^{:doc "The AES block size in bytes.\n"
    :added "1.0"
    :tag "Int"
    :go "aes.BlockSize"}
  BlockSize)

JOKER TYPE crypto/aes.KeySizeError from crypto/aes/cipher.go:
(defn ^"GoObject" KeySizeError.
  "Constructor for aes.KeySizeError"
  {:added "1.0"
   :go "_ConstructKeySizeError(_v)"}
  [^Object _v])

JOKER FUNC crypto/aes.NewCipher from crypto/aes/cipher.go:
;; (defn NewCipher
;;   "NewCipher creates and returns a new cipher.Block.\nThe key argument should be the AES key,\neither 16, 24, or 32 bytes to select\nAES-128, AES-192, or AES-256.\n\nGo input arguments: (key []byte)\n\nGo return type: (crypto/cipher.Block, error)\n\nJoker input arguments: [^(vector-of Int) key]\n\nJoker return type: [go.std.crypto.cipher/Block Error]"
;;   {:added "1.0"
;;    :go "__newCipher(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__key)))"}
;;   [^Object __key])

JOKER TYPE go.std.crypto.aes/KeySizeError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_KeySizeError"}
  KeySizeError)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["crypto/aes"]
    :doc "Provides a low-level interface to the crypto/aes package.\n\nPackage aes implements AES encryption (formerly Rijndael), as defined in\nU.S. Federal Information Processing Standards Publication 197.\n\nThe AES operations in this package are not implemented using constant-time algorithms.\nAn exception is when running on systems with enabled hardware support for AES\nthat makes these operations constant-time. Examples include amd64 systems using AES-NI\nextensions and s390x systems using Message-Security-Assist extensions.\nOn such systems, when the result of NewCipher is passed to cipher.NewGCM,\nthe GHASH operation used by GCM is also constant-time.\n"
    :empty false}
  go.std.crypto.aes)
JOKER TYPE crypto/cipher.AEAD from crypto/cipher/gcm.go:
;; (defn ^"GoObject" AEAD.
;;   "Constructor for cipher.AEAD"
;;   {:added "1.0"
;;    :go "_ConstructAEAD(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/cipher.Block from crypto/cipher/cipher.go:
;; (defn ^"GoObject" Block.
;;   "Constructor for cipher.Block"
;;   {:added "1.0"
;;    :go "_ConstructBlock(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/cipher.BlockMode from crypto/cipher/cipher.go:
;; (defn ^"GoObject" BlockMode.
;;   "Constructor for cipher.BlockMode"
;;   {:added "1.0"
;;    :go "_ConstructBlockMode(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/cipher.Stream from crypto/cipher/cipher.go:
;; (defn ^"GoObject" Stream.
;;   "Constructor for cipher.Stream"
;;   {:added "1.0"
;;    :go "_ConstructStream(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/cipher.StreamReader from crypto/cipher/io.go:
;; (defn ^"GoObject" StreamReader.
;;   "Constructor for cipher.StreamReader"
;;   {:added "1.0"
;;    :go "_ConstructStreamReader(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/cipher.StreamWriter from crypto/cipher/io.go:
;; (defn ^"GoObject" StreamWriter.
;;   "Constructor for cipher.StreamWriter"
;;   {:added "1.0"
;;    :go "_ConstructStreamWriter(_v)"}
;;   [^Object _v])

JOKER FUNC crypto/cipher.NewCBCDecrypter from crypto/cipher/cbc.go:
;; (defn NewCBCDecrypter
;;   "NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining\nmode, using the given Block. The length of iv must be the same as the\nBlock's block size and must match the iv used to encrypt the data.\n\nGo input arguments: (b Block, iv []byte)\n\nGo return type: BlockMode\n\nJoker input arguments: [^go.std.crypto.cipher/Block b, ^(vector-of Int) iv]\n\nJoker return type: go.std.crypto.cipher/BlockMode"
;;   {:added "1.0"
;;    :go "__newCBCDecrypter(*__b, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__iv)))"}
;;   [^cipher/Block __b, ^Object __iv])

JOKER FUNC crypto/cipher.NewCBCEncrypter from crypto/cipher/cbc.go:
;; (defn NewCBCEncrypter
;;   "NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining\nmode, using the given Block. The length of iv must be the same as the\nBlock's block size.\n\nGo input arguments: (b Block, iv []byte)\n\nGo return type: BlockMode\n\nJoker input arguments: [^go.std.crypto.cipher/Block b, ^(vector-of Int) iv]\n\nJoker return type: go.std.crypto.cipher/BlockMode"
;;   {:added "1.0"
;;    :go "__newCBCEncrypter(*__b, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__iv)))"}
;;   [^cipher/Block __b, ^Object __iv])

JOKER FUNC crypto/cipher.NewCFBDecrypter from crypto/cipher/cfb.go:
;; (defn NewCFBDecrypter
;;   "NewCFBDecrypter returns a Stream which decrypts with cipher feedback mode,\nusing the given Block. The iv must be the same length as the Block's block\nsize.\n\nGo input arguments: (block Block, iv []byte)\n\nGo return type: Stream\n\nJoker input arguments: [^go.std.crypto.cipher/Block block, ^(vector-of Int) iv]\n\nJoker return type: go.std.crypto.cipher/Stream"
;;   {:added "1.0"
;;    :go "__newCFBDecrypter(*__block, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__iv)))"}
;;   [^cipher/Block __block, ^Object __iv])

JOKER FUNC crypto/cipher.NewCFBEncrypter from crypto/cipher/cfb.go:
;; (defn NewCFBEncrypter
;;   "NewCFBEncrypter returns a Stream which encrypts with cipher feedback mode,\nusing the given Block. The iv must be the same length as the Block's block\nsize.\n\nGo input arguments: (block Block, iv []byte)\n\nGo return type: Stream\n\nJoker input arguments: [^go.std.crypto.cipher/Block block, ^(vector-of Int) iv]\n\nJoker return type: go.std.crypto.cipher/Stream"
;;   {:added "1.0"
;;    :go "__newCFBEncrypter(*__block, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__iv)))"}
;;   [^cipher/Block __block, ^Object __iv])

JOKER FUNC crypto/cipher.NewCTR from crypto/cipher/ctr.go:
;; (defn NewCTR
;;   "NewCTR returns a Stream which encrypts/decrypts using the given Block in\ncounter mode. The length of iv must be the same as the Block's block size.\n\nGo input arguments: (block Block, iv []byte)\n\nGo return type: Stream\n\nJoker input arguments: [^go.std.crypto.cipher/Block block, ^(vector-of Int) iv]\n\nJoker return type: go.std.crypto.cipher/Stream"
;;   {:added "1.0"
;;    :go "__newCTR(*__block, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__iv)))"}
;;   [^cipher/Block __block, ^Object __iv])

JOKER FUNC crypto/cipher.NewGCM from crypto/cipher/gcm.go:
(defn NewGCM
  "NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode\nwith the standard nonce length.\n\nIn general, the GHASH operation performed by this implementation of GCM is not constant-time.\nAn exception is when the underlying Block was created by aes.NewCipher\non systems with hardware support for AES. See the crypto/aes package documentation for details.\n\nGo input arguments: (cipher Block)\n\nGo return type: (AEAD, error)\n\nJoker input arguments: [^go.std.crypto.cipher/Block cipher]\n\nJoker return type: [go.std.crypto.cipher/AEAD Error]"
  {:added "1.0"
   :go "__newGCM(*__cipher)"}
  [^cipher/Block __cipher])

JOKER FUNC crypto/cipher.NewGCMWithNonceSize from crypto/cipher/gcm.go:
(defn NewGCMWithNonceSize
  "NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois\nCounter Mode, which accepts nonces of the given length.\n\nOnly use this function if you require compatibility with an existing\ncryptosystem that uses non-standard nonce lengths. All other users should use\nNewGCM, which is faster and more resistant to misuse.\n\nGo input arguments: (cipher Block, size int)\n\nGo return type: (AEAD, error)\n\nJoker input arguments: [^go.std.crypto.cipher/Block cipher, ^Int size]\n\nJoker return type: [go.std.crypto.cipher/AEAD Error]"
  {:added "1.0"
   :go "__newGCMWithNonceSize(*__cipher, __size)"}
  [^cipher/Block __cipher, ^Int __size])

JOKER FUNC crypto/cipher.NewGCMWithTagSize from crypto/cipher/gcm.go:
(defn NewGCMWithTagSize
  "NewGCMWithTagSize returns the given 128-bit, block cipher wrapped in Galois\nCounter Mode, which generates tags with the given length.\n\nTag sizes between 12 and 16 bytes are allowed.\n\nOnly use this function if you require compatibility with an existing\ncryptosystem that uses non-standard tag lengths. All other users should use\nNewGCM, which is more resistant to misuse.\n\nGo input arguments: (cipher Block, tagSize int)\n\nGo return type: (AEAD, error)\n\nJoker input arguments: [^go.std.crypto.cipher/Block cipher, ^Int tagSize]\n\nJoker return type: [go.std.crypto.cipher/AEAD Error]"
  {:added "1.0"
   :go "__newGCMWithTagSize(*__cipher, __tagSize)"}
  [^cipher/Block __cipher, ^Int __tagSize])

JOKER FUNC crypto/cipher.NewOFB from crypto/cipher/ofb.go:
;; (defn NewOFB
;;   "NewOFB returns a Stream that encrypts or decrypts using the block cipher b\nin output feedback mode. The initialization vector iv's length must be equal\nto b's block size.\n\nGo input arguments: (b Block, iv []byte)\n\nGo return type: Stream\n\nJoker input arguments: [^go.std.crypto.cipher/Block b, ^(vector-of Int) iv]\n\nJoker return type: go.std.crypto.cipher/Stream"
;;   {:added "1.0"
;;    :go "__newOFB(*__b, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__iv)))"}
;;   [^cipher/Block __b, ^Object __iv])

JOKER TYPE go.std.crypto.cipher/AEAD:
(def
  ^{:doc "AEAD is a cipher mode providing authenticated encryption with associated\ndata. For a description of the methodology, see\n\thttps://en.wikipedia.org/wiki/Authenticated_encryption\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_AEAD"}
  AEAD)

JOKER TYPE go.std.crypto.cipher/Block:
(def
  ^{:doc "A Block represents an implementation of block cipher\nusing a given key. It provides the capability to encrypt\nor decrypt individual blocks. The mode implementations\nextend that capability to streams of blocks.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Block"}
  Block)

JOKER TYPE go.std.crypto.cipher/BlockMode:
(def
  ^{:doc "A BlockMode represents a block cipher running in a block-based mode (CBC,\nECB etc).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BlockMode"}
  BlockMode)

JOKER TYPE go.std.crypto.cipher/Stream:
(def
  ^{:doc "A Stream represents a stream cipher.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Stream"}
  Stream)

JOKER TYPE go.std.crypto.cipher/StreamReader:
(def
  ^{:doc "StreamReader wraps a Stream into an io.Reader. It calls XORKeyStream\nto process each slice of data which passes through.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_StreamReader"}
  StreamReader)

JOKER TYPE go.std.crypto.cipher/StreamWriter:
(def
  ^{:doc "StreamWriter wraps a Stream into an io.Writer. It calls XORKeyStream\nto process each slice of data which passes through. If any Write call\nreturns short then the StreamWriter is out of sync and must be discarded.\nA StreamWriter has no internal buffering; Close does not need\nto be called to flush write data.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_StreamWriter"}
  StreamWriter)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/cipher package.\n\nPackage cipher implements standard block cipher modes that can be wrapped\naround low-level block cipher implementations.\nSee https://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html\nand NIST Special Publication 800-38A.\n"
    :empty false}
  go.std.crypto.cipher)
JOKER CONSTANT BlockSize from crypto/des/cipher.go:
(def
  ^{:doc "The DES block size in bytes.\n"
    :added "1.0"
    :tag "Int"
    :go "des.BlockSize"}
  BlockSize)

JOKER TYPE crypto/des.KeySizeError from crypto/des/cipher.go:
(defn ^"GoObject" KeySizeError.
  "Constructor for des.KeySizeError"
  {:added "1.0"
   :go "_ConstructKeySizeError(_v)"}
  [^Object _v])

JOKER FUNC crypto/des.NewCipher from crypto/des/cipher.go:
;; (defn NewCipher
;;   "NewCipher creates and returns a new cipher.Block.\n\nGo input arguments: (key []byte)\n\nGo return type: (crypto/cipher.Block, error)\n\nJoker input arguments: [^(vector-of Int) key]\n\nJoker return type: [go.std.crypto.cipher/Block Error]"
;;   {:added "1.0"
;;    :go "__newCipher(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__key)))"}
;;   [^Object __key])

JOKER FUNC crypto/des.NewTripleDESCipher from crypto/des/cipher.go:
;; (defn NewTripleDESCipher
;;   "NewTripleDESCipher creates and returns a new cipher.Block.\n\nGo input arguments: (key []byte)\n\nGo return type: (crypto/cipher.Block, error)\n\nJoker input arguments: [^(vector-of Int) key]\n\nJoker return type: [go.std.crypto.cipher/Block Error]"
;;   {:added "1.0"
;;    :go "__newTripleDESCipher(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__key)))"}
;;   [^Object __key])

JOKER TYPE go.std.crypto.des/KeySizeError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_KeySizeError"}
  KeySizeError)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["crypto/des"]
    :doc "Provides a low-level interface to the crypto/des package.\n\nPackage des implements the Data Encryption Standard (DES) and the\nTriple Data Encryption Algorithm (TDEA) as defined\nin U.S. Federal Information Processing Standards Publication 46-3.\n\nDES is cryptographically broken and should not be used for secure\napplications.\n"
    :empty false}
  go.std.crypto.des)
JOKER CONSTANT L1024N160 from crypto/dsa/dsa.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(dsa.L1024N160)"}
  L1024N160)

JOKER CONSTANT L2048N224 from crypto/dsa/dsa.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(dsa.L2048N224)"}
  L2048N224)

JOKER CONSTANT L2048N256 from crypto/dsa/dsa.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(dsa.L2048N256)"}
  L2048N256)

JOKER CONSTANT L3072N256 from crypto/dsa/dsa.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(dsa.L3072N256)"}
  L3072N256)

JOKER VARIABLE ErrInvalidPublicKey from crypto/dsa/dsa.go:
(def
  ^{:doc "ErrInvalidPublicKey results when a public key is not usable by this code.\nFIPS is quite strict about the format of DSA keys, but other code may be\nless so. Thus, when using keys which may have been generated by other code,\nthis error must be handled.\n"
    :added "1.0"
    :tag "Var"
    :go "dsa.ErrInvalidPublicKey"}
  ErrInvalidPublicKey)

JOKER TYPE crypto/dsa.ParameterSizes from crypto/dsa/dsa.go:
(defn ^"GoObject" ParameterSizes.
  "Constructor for dsa.ParameterSizes"
  {:added "1.0"
   :go "_ConstructParameterSizes(_v)"}
  [^Object _v])

JOKER TYPE crypto/dsa.Parameters from crypto/dsa/dsa.go:
;; (defn ^"GoObject" Parameters.
;;   "Constructor for dsa.Parameters"
;;   {:added "1.0"
;;    :go "_ConstructParameters(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/dsa.PrivateKey from crypto/dsa/dsa.go:
;; (defn ^"GoObject" PrivateKey.
;;   "Constructor for dsa.PrivateKey"
;;   {:added "1.0"
;;    :go "_ConstructPrivateKey(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/dsa.PublicKey from crypto/dsa/dsa.go:
;; (defn ^"GoObject" PublicKey.
;;   "Constructor for dsa.PublicKey"
;;   {:added "1.0"
;;    :go "_ConstructPublicKey(_v)"}
;;   [^Object _v])

JOKER FUNC crypto/dsa.GenerateKey from crypto/dsa/dsa.go:
;; (defn ^"Error" GenerateKey
;;   "GenerateKey generates a public&private key pair. The Parameters of the\nPrivateKey must already be valid (see GenerateParameters).\n\nGo input arguments: (priv *PrivateKey, rand io.Reader)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.crypto.dsa/PrivateKey) priv, ^go.std.io/Reader rand]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "dsa.GenerateKey(__priv, *__rand)"}
;;   [^dsa/PrivateKey __priv, ^io/Reader __rand])

JOKER FUNC crypto/dsa.GenerateParameters from crypto/dsa/dsa.go:
;; (defn ^"Error" GenerateParameters
;;   "GenerateParameters puts a random, valid set of DSA parameters into params.\nThis function can take many seconds, even on fast machines.\n\nGo input arguments: (params *Parameters, rand io.Reader, sizes ParameterSizes)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.crypto.dsa/Parameters) params, ^go.std.io/Reader rand, ^go.std.crypto.dsa/ParameterSizes sizes]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "dsa.GenerateParameters(__params, *__rand, *__sizes)"}
;;   [^dsa/Parameters __params, ^io/Reader __rand, ^dsa/ParameterSizes __sizes])

JOKER FUNC crypto/dsa.Sign from crypto/dsa/dsa.go:
;; (defn Sign
;;   "Sign signs an arbitrary length hash (which should be the result of hashing a\nlarger message) using the private key, priv. It returns the signature as a\npair of integers. The security of the private key depends on the entropy of\nrand.\n\nNote that FIPS 186-3 section 4.6 specifies that the hash should be truncated\nto the byte-length of the subgroup. This function does not perform that\ntruncation itself.\n\nBe aware that calling Sign with an attacker-controlled PrivateKey may\nrequire an arbitrary amount of CPU.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, hash []byte)\n\nGo return type: (r *math/big.Int, s *math/big.Int, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.dsa/PrivateKey) priv, ^(vector-of Int) hash]\n\nJoker return type: [(atom-of go.std.math.big/Int) (atom-of go.std.math.big/Int) Error]"
;;   {:added "1.0"
;;    :go "__sign(*__rand, __priv, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__hash)))"}
;;   [^io/Reader __rand, ^dsa/PrivateKey __priv, ^Object __hash])

JOKER FUNC crypto/dsa.Verify from crypto/dsa/dsa.go:
;; (defn ^"Boolean" Verify
;;   "Verify verifies the signature in r, s of hash using the public key, pub. It\nreports whether the signature is valid.\n\nNote that FIPS 186-3 section 4.6 specifies that the hash should be truncated\nto the byte-length of the subgroup. This function does not perform that\ntruncation itself.\n\nGo input arguments: (pub *PublicKey, hash []byte, r *big.Int, s *big.Int)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.crypto.dsa/PublicKey) pub, ^(vector-of Int) hash, ^(atom-of go.std.math.big/Int) r, ^(atom-of go.std.math.big/Int) s]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "dsa.Verify(__pub, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__hash)), __r, __s)"}
;;   [^dsa/PublicKey __pub, ^Object __hash, ^big/Int __r, ^big/Int __s])

JOKER TYPE go.std.crypto.dsa/ParameterSizes:
(def
  ^{:doc "ParameterSizes is an enumeration of the acceptable bit lengths of the primes\nin a set of DSA parameters. See FIPS 186-3, section 4.2.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ParameterSizes"}
  ParameterSizes)

JOKER TYPE go.std.crypto.dsa/Parameters:
(def
  ^{:doc "Parameters represents the domain parameters for a key. These parameters can\nbe shared across many keys. The bit length of Q must be a multiple of 8.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Parameters"}
  Parameters)

JOKER TYPE go.std.crypto.dsa/PrivateKey:
(def
  ^{:doc "PrivateKey represents a DSA private key.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PrivateKey"}
  PrivateKey)

JOKER TYPE go.std.crypto.dsa/PublicKey:
(def
  ^{:doc "PublicKey represents a DSA public key.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PublicKey"}
  PublicKey)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["crypto/dsa"]
    :doc "Provides a low-level interface to the crypto/dsa package.\n\nPackage dsa implements the Digital Signature Algorithm, as defined in FIPS 186-3.\n\nThe DSA operations in this package are not implemented using constant-time algorithms.\n"
    :empty false}
  go.std.crypto.dsa)
JOKER TYPE crypto/ecdsa.PrivateKey from crypto/ecdsa/ecdsa.go:
;; (defn ^"GoObject" PrivateKey.
;;   "Constructor for ecdsa.PrivateKey"
;;   {:added "1.0"
;;    :go "_ConstructPrivateKey(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/ecdsa.PublicKey from crypto/ecdsa/ecdsa.go:
;; (defn ^"GoObject" PublicKey.
;;   "Constructor for ecdsa.PublicKey"
;;   {:added "1.0"
;;    :go "_ConstructPublicKey(_v)"}
;;   [^Object _v])

JOKER FUNC crypto/ecdsa.GenerateKey from crypto/ecdsa/ecdsa.go:
;; (defn GenerateKey
;;   "GenerateKey generates a public and private key pair.\n\nGo input arguments: (c elliptic.Curve, rand io.Reader)\n\nGo return type: (*PrivateKey, error)\n\nJoker input arguments: [^go.std.crypto.elliptic/Curve c, ^go.std.io/Reader rand]\n\nJoker return type: [(atom-of go.std.crypto.ecdsa/PrivateKey) Error]"
;;   {:added "1.0"
;;    :go "__generateKey(*__c, *__rand)"}
;;   [^elliptic/Curve __c, ^io/Reader __rand])

JOKER FUNC crypto/ecdsa.Sign from crypto/ecdsa/ecdsa.go:
;; (defn Sign
;;   "Sign signs a hash (which should be the result of hashing a larger message)\nusing the private key, priv. If the hash is longer than the bit-length of the\nprivate key's curve order, the hash will be truncated to that length.  It\nreturns the signature as a pair of integers. The security of the private key\ndepends on the entropy of rand.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, hash []byte)\n\nGo return type: (r *math/big.Int, s *math/big.Int, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.ecdsa/PrivateKey) priv, ^(vector-of Int) hash]\n\nJoker return type: [(atom-of go.std.math.big/Int) (atom-of go.std.math.big/Int) Error]"
;;   {:added "1.0"
;;    :go "__sign(*__rand, __priv, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__hash)))"}
;;   [^io/Reader __rand, ^ecdsa/PrivateKey __priv, ^Object __hash])

JOKER FUNC crypto/ecdsa.Verify from crypto/ecdsa/ecdsa.go:
;; (defn ^"Boolean" Verify
;;   "Verify verifies the signature in r, s of hash using the public key, pub. Its\nreturn value records whether the signature is valid.\n\nGo input arguments: (pub *PublicKey, hash []byte, r *big.Int, s *big.Int)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.crypto.ecdsa/PublicKey) pub, ^(vector-of Int) hash, ^(atom-of go.std.math.big/Int) r, ^(atom-of go.std.math.big/Int) s]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "ecdsa.Verify(__pub, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__hash)), __r, __s)"}
;;   [^ecdsa/PublicKey __pub, ^Object __hash, ^big/Int __r, ^big/Int __s])

JOKER TYPE go.std.crypto.ecdsa/PrivateKey:
(def
  ^{:doc "PrivateKey represents an ECDSA private key.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PrivateKey"}
  PrivateKey)

JOKER TYPE go.std.crypto.ecdsa/PublicKey:
(def
  ^{:doc "PublicKey represents an ECDSA public key.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PublicKey"}
  PublicKey)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/ecdsa package.\n\nPackage ecdsa implements the Elliptic Curve Digital Signature Algorithm, as\ndefined in FIPS 186-3.\n\nThis implementation  derives the nonce from an AES-CTR CSPRNG keyed by\nChopMD(256, SHA2-512(priv.D || entropy || hash)). The CSPRNG key is IRO by\na result of Coron; the AES-CTR stream is IRO under standard assumptions.\n"
    :empty false}
  go.std.crypto.ecdsa)
JOKER TYPE crypto/elliptic.Curve from crypto/elliptic/elliptic.go:
;; (defn ^"GoObject" Curve.
;;   "Constructor for elliptic.Curve"
;;   {:added "1.0"
;;    :go "_ConstructCurve(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/elliptic.CurveParams from crypto/elliptic/elliptic.go:
;; (defn ^"GoObject" CurveParams.
;;   "Constructor for elliptic.CurveParams"
;;   {:added "1.0"
;;    :go "_ConstructCurveParams(_v)"}
;;   [^Object _v])

JOKER FUNC crypto/elliptic.GenerateKey from crypto/elliptic/elliptic.go:
;; (defn GenerateKey
;;   "GenerateKey returns a public/private key pair. The private key is\ngenerated using the given reader, which must return random data.\n\nGo input arguments: (curve Curve, rand io.Reader)\n\nGo return type: (priv []byte, x *math/big.Int, y *math/big.Int, err error)\n\nJoker input arguments: [^go.std.crypto.elliptic/Curve curve, ^go.std.io/Reader rand]\n\nJoker return type: [(vector-of Int) (atom-of go.std.math.big/Int) (atom-of go.std.math.big/Int) Error]"
;;   {:added "1.0"
;;    :go "__generateKey(*__curve, *__rand)"}
;;   [^elliptic/Curve __curve, ^io/Reader __rand])

JOKER FUNC crypto/elliptic.Marshal from crypto/elliptic/elliptic.go:
;; (defn Marshal
;;   "Marshal converts a point into the uncompressed form specified in section 4.3.6 of ANSI X9.62.\n\nGo input arguments: (curve Curve, x *big.Int, y *big.Int)\n\nGo return type: []byte\n\nJoker input arguments: [^go.std.crypto.elliptic/Curve curve, ^(atom-of go.std.math.big/Int) x, ^(atom-of go.std.math.big/Int) y]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__marshal(*__curve, __x, __y)"}
;;   [^elliptic/Curve __curve, ^big/Int __x, ^big/Int __y])

JOKER FUNC crypto/elliptic.P224 from crypto/elliptic/p224.go:
(defn P224
  "P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2).\n\nThe cryptographic operations are implemented using constant-time algorithms.\n\nGo return type: Curve\n\nJoker input arguments: []\n\nJoker return type: go.std.crypto.elliptic/Curve"
  {:added "1.0"
   :go "__p224()"}
  [])

JOKER FUNC crypto/elliptic.P256 from crypto/elliptic/elliptic.go:
(defn P256
  "P256 returns a Curve which implements P-256 (see FIPS 186-3, section D.2.3)\n\nThe cryptographic operations are implemented using constant-time algorithms.\n\nGo return type: Curve\n\nJoker input arguments: []\n\nJoker return type: go.std.crypto.elliptic/Curve"
  {:added "1.0"
   :go "__p256()"}
  [])

JOKER FUNC crypto/elliptic.P384 from crypto/elliptic/elliptic.go:
(defn P384
  "P384 returns a Curve which implements P-384 (see FIPS 186-3, section D.2.4)\n\nThe cryptographic operations do not use constant-time algorithms.\n\nGo return type: Curve\n\nJoker input arguments: []\n\nJoker return type: go.std.crypto.elliptic/Curve"
  {:added "1.0"
   :go "__p384()"}
  [])

JOKER FUNC crypto/elliptic.P521 from crypto/elliptic/elliptic.go:
(defn P521
  "P521 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5)\n\nThe cryptographic operations do not use constant-time algorithms.\n\nGo return type: Curve\n\nJoker input arguments: []\n\nJoker return type: go.std.crypto.elliptic/Curve"
  {:added "1.0"
   :go "__p521()"}
  [])

JOKER FUNC crypto/elliptic.Unmarshal from crypto/elliptic/elliptic.go:
;; (defn Unmarshal
;;   "Unmarshal converts a point, serialized by Marshal, into an x, y pair.\nIt is an error if the point is not in uncompressed form or is not on the curve.\nOn error, x = nil.\n\nGo input arguments: (curve Curve, data []byte)\n\nGo return type: (x *math/big.Int, y *math/big.Int)\n\nJoker input arguments: [^go.std.crypto.elliptic/Curve curve, ^(vector-of Int) data]\n\nJoker return type: [(atom-of go.std.math.big/Int) (atom-of go.std.math.big/Int)]"
;;   {:added "1.0"
;;    :go "__unmarshal(*__curve, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)))"}
;;   [^elliptic/Curve __curve, ^Object __data])

JOKER TYPE go.std.crypto.elliptic/Curve:
(def
  ^{:doc "A Curve represents a short-form Weierstrass curve with a=-3.\nSee https://www.hyperelliptic.org/EFD/g1p/auto-shortw.html\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Curve"}
  Curve)

JOKER TYPE go.std.crypto.elliptic/CurveParams:
(def
  ^{:doc "CurveParams contains the parameters of an elliptic curve and also provides\na generic, non-constant time implementation of Curve.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CurveParams"}
  CurveParams)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/elliptic package.\n\nPackage elliptic implements several standard elliptic curves over prime\nfields.\n"
    :empty false}
  go.std.crypto.elliptic)
JOKER FUNC crypto/hmac.Equal from crypto/hmac/hmac.go:
;; (defn ^"Boolean" Equal
;;   "Equal compares two MACs for equality without leaking timing information.\n\nGo input arguments: (mac1 []byte, mac2 []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) mac1, ^(vector-of Int) mac2]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "hmac.Equal(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__mac1)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__mac2)))"}
;;   [^Object __mac1, ^Object __mac2])

JOKER FUNC crypto/hmac.New from crypto/hmac/hmac.go:
;; (defn New
;;   "New returns a new HMAC hash using the given hash.Hash type and key.\nNote that unlike other hash implementations in the standard library,\nthe returned Hash does not implement encoding.BinaryMarshaler\nor encoding.BinaryUnmarshaler.\n\nGo input arguments: (h func, key []byte)\n\nGo return type: hash.Hash\n\nJoker input arguments: [^fn h, ^(vector-of Int) key]\n\nJoker return type: go.std.hash/Hash"
;;   {:added "1.0"
;;    :go "__new(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__key)))"}
;;   [^fn __h, ^Object __key])

JOKER CONSTANT BlockSize from crypto/md5/md5.go:
(def
  ^{:doc "The blocksize of MD5 in bytes.\n"
    :added "1.0"
    :tag "Int"
    :go "md5.BlockSize"}
  BlockSize)

JOKER CONSTANT Size from crypto/md5/md5.go:
(def
  ^{:doc "The size of an MD5 checksum in bytes.\n"
    :added "1.0"
    :tag "Int"
    :go "md5.Size"}
  Size)

JOKER FUNC crypto/md5.New from crypto/md5/md5.go:
(defn New
  "New returns a new hash.Hash computing the MD5 checksum. The Hash also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new()"}
  [])

JOKER FUNC crypto/md5.Sum from crypto/md5/md5.go:
;; (defn Sum
;;   "Sum returns the MD5 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)))"}
;;   [^Object __data])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["crypto/md5"]
    :doc "Provides a low-level interface to the crypto/md5 package.\n\nPackage md5 implements the MD5 hash algorithm as defined in RFC 1321.\n\nMD5 is cryptographically broken and should not be used for secure\napplications.\n"
    :empty false}
  go.std.crypto.md5)
JOKER VARIABLE Reader from crypto/rand/rand.go:
(def
  ^{:doc "Reader is a global, shared instance of a cryptographically\nsecure random number generator.\n\nOn Linux and FreeBSD, Reader uses getrandom(2) if available, /dev/urandom otherwise.\nOn OpenBSD, Reader uses getentropy(2).\nOn other Unix-like systems, Reader reads from /dev/urandom.\nOn Windows systems, Reader uses the CryptGenRandom API.\nOn Wasm, Reader uses the Web Crypto API.\n"
    :added "1.0"
    :tag "Var"
    :go "rand.Reader"}
  Reader)

JOKER FUNC crypto/rand.Int from crypto/rand/util.go:
;; (defn Int
;;   "Int returns a uniform random value in [0, max). It panics if max <= 0.\n\nGo input arguments: (rand io.Reader, max *big.Int)\n\nGo return type: (n *math/big.Int, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.math.big/Int) max]\n\nJoker return type: [(atom-of go.std.math.big/Int) Error]"
;;   {:added "1.0"
;;    :go "__int(*__rand, __max)"}
;;   [^io/Reader __rand, ^big/Int __max])

JOKER FUNC crypto/rand.Prime from crypto/rand/util.go:
;; (defn Prime
;;   "Prime returns a number, p, of the given size, such that p is prime\nwith high probability.\nPrime will return error for any error returned by rand.Read or if bits < 2.\n\nGo input arguments: (rand io.Reader, bits int)\n\nGo return type: (p *math/big.Int, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^Int bits]\n\nJoker return type: [(atom-of go.std.math.big/Int) Error]"
;;   {:added "1.0"
;;    :go "__prime(*__rand, __bits)"}
;;   [^io/Reader __rand, ^Int __bits])

JOKER FUNC crypto/rand.Read from crypto/rand/rand.go:
;; (defn Read
;;   "Read is a helper function that calls Reader.Read using io.ReadFull.\nOn return, n == len(b) if and only if err == nil.\n\nGo input arguments: (b []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(vector-of Int) b]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__read(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))"}
;;   [^Object __b])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["crypto/rand"]
    :doc "Provides a low-level interface to the crypto/rand package.\n\nPackage rand implements a cryptographically secure\nrandom number generator.\n"
    :empty false}
  go.std.crypto.rand)
JOKER TYPE crypto/rc4.Cipher from crypto/rc4/rc4.go:
(defn ^"GoObject" Cipher.
  "Constructor for rc4.Cipher"
  {:added "1.0"
   :go "_ConstructCipher(_v)"}
  [^Object _v])

JOKER TYPE crypto/rc4.KeySizeError from crypto/rc4/rc4.go:
(defn ^"GoObject" KeySizeError.
  "Constructor for rc4.KeySizeError"
  {:added "1.0"
   :go "_ConstructKeySizeError(_v)"}
  [^Object _v])

JOKER FUNC crypto/rc4.NewCipher from crypto/rc4/rc4.go:
;; (defn NewCipher
;;   "NewCipher creates and returns a new Cipher. The key argument should be the\nRC4 key, at least 1 byte and at most 256 bytes.\n\nGo input arguments: (key []byte)\n\nGo return type: (*Cipher, error)\n\nJoker input arguments: [^(vector-of Int) key]\n\nJoker return type: [(atom-of go.std.crypto.rc4/Cipher) Error]"
;;   {:added "1.0"
;;    :go "__newCipher(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__key)))"}
;;   [^Object __key])

JOKER TYPE go.std.crypto.rc4/Cipher:
(def
  ^{:doc "A Cipher is an instance of RC4 using a particular key.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Cipher"}
  Cipher)

JOKER TYPE go.std.crypto.rc4/KeySizeError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_KeySizeError"}
  KeySizeError)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/rc4 package.\n\nPackage rc4 implements RC4 encryption, as defined in Bruce Schneier's\nApplied Cryptography.\n\nRC4 is cryptographically broken and should not be used for secure\napplications.\n"
    :empty false}
  go.std.crypto.rc4)
JOKER CONSTANT PSSSaltLengthAuto from crypto/rsa/pss.go:
(def
  ^{:doc "PSSSaltLengthAuto causes the salt in a PSS signature to be as large\nas possible when signing, and to be auto-detected when verifying.\n"
    :added "1.0"
    :tag "Int"
    :go "rsa.PSSSaltLengthAuto"}
  PSSSaltLengthAuto)

JOKER CONSTANT PSSSaltLengthEqualsHash from crypto/rsa/pss.go:
(def
  ^{:doc "PSSSaltLengthEqualsHash causes the salt length to equal the length\nof the hash used in the signature.\n"
    :added "1.0"
    :tag "Int"
    :go "rsa.PSSSaltLengthEqualsHash"}
  PSSSaltLengthEqualsHash)

JOKER VARIABLE ErrDecryption from crypto/rsa/rsa.go:
(def
  ^{:doc "ErrDecryption represents a failure to decrypt a message.\nIt is deliberately vague to avoid adaptive attacks.\n"
    :added "1.0"
    :tag "Var"
    :go "rsa.ErrDecryption"}
  ErrDecryption)

JOKER VARIABLE ErrMessageTooLong from crypto/rsa/rsa.go:
(def
  ^{:doc "ErrMessageTooLong is returned when attempting to encrypt a message which is\ntoo large for the size of the public key.\n"
    :added "1.0"
    :tag "Var"
    :go "rsa.ErrMessageTooLong"}
  ErrMessageTooLong)

JOKER VARIABLE ErrVerification from crypto/rsa/rsa.go:
(def
  ^{:doc "ErrVerification represents a failure to verify a signature.\nIt is deliberately vague to avoid adaptive attacks.\n"
    :added "1.0"
    :tag "Var"
    :go "rsa.ErrVerification"}
  ErrVerification)

JOKER TYPE crypto/rsa.CRTValue from crypto/rsa/rsa.go:
;; (defn ^"GoObject" CRTValue.
;;   "Constructor for rsa.CRTValue"
;;   {:added "1.0"
;;    :go "_ConstructCRTValue(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/rsa.OAEPOptions from crypto/rsa/rsa.go:
;; (defn ^"GoObject" OAEPOptions.
;;   "Constructor for rsa.OAEPOptions"
;;   {:added "1.0"
;;    :go "_ConstructOAEPOptions(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/rsa.PKCS1v15DecryptOptions from crypto/rsa/pkcs1v15.go:
(defn ^"GoObject" PKCS1v15DecryptOptions.
  "Constructor for rsa.PKCS1v15DecryptOptions"
  {:added "1.0"
   :go "_ConstructPKCS1v15DecryptOptions(_v)"}
  [^Object _v])

JOKER TYPE crypto/rsa.PSSOptions from crypto/rsa/pss.go:
;; (defn ^"GoObject" PSSOptions.
;;   "Constructor for rsa.PSSOptions"
;;   {:added "1.0"
;;    :go "_ConstructPSSOptions(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/rsa.PrecomputedValues from crypto/rsa/rsa.go:
;; (defn ^"GoObject" PrecomputedValues.
;;   "Constructor for rsa.PrecomputedValues"
;;   {:added "1.0"
;;    :go "_ConstructPrecomputedValues(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/rsa.PrivateKey from crypto/rsa/rsa.go:
;; (defn ^"GoObject" PrivateKey.
;;   "Constructor for rsa.PrivateKey"
;;   {:added "1.0"
;;    :go "_ConstructPrivateKey(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/rsa.PublicKey from crypto/rsa/rsa.go:
;; (defn ^"GoObject" PublicKey.
;;   "Constructor for rsa.PublicKey"
;;   {:added "1.0"
;;    :go "_ConstructPublicKey(_v)"}
;;   [^Object _v])

JOKER FUNC crypto/rsa.DecryptOAEP from crypto/rsa/rsa.go:
;; (defn DecryptOAEP
;;   "OAEP is parameterised by a hash function that is used as a random oracle.\nEncryption and decryption of a given message must use the same hash function\nand sha256.New() is a reasonable choice.\n\nThe random parameter, if not nil, is used to blind the private-key operation\nand avoid timing side-channel attacks. Blinding is purely internal to this\nfunction – the random data need not match that used when encrypting.\n\nThe label parameter must match the value given when encrypting. See\nEncryptOAEP for details.\n\nGo input arguments: (hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.hash/Hash hash, ^go.std.io/Reader random, ^(atom-of go.std.crypto.rsa/PrivateKey) priv, ^(vector-of Int) ciphertext, ^(vector-of Int) label]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__decryptOAEP(*__hash, *__random, __priv, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__ciphertext)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__label)))"}
;;   [^hash/Hash __hash, ^io/Reader __random, ^rsa/PrivateKey __priv, ^Object __ciphertext, ^Object __label])

JOKER FUNC crypto/rsa.DecryptPKCS1v15 from crypto/rsa/pkcs1v15.go:
;; (defn DecryptPKCS1v15
;;   "DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5.\nIf rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\n\nNote that whether this function returns an error or not discloses secret\ninformation. If an attacker can cause this function to run repeatedly and\nlearn whether each instance returned an error then they can decrypt and\nforge signatures as if they had the private key. See\nDecryptPKCS1v15SessionKey for a way of solving this problem.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, ciphertext []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.rsa/PrivateKey) priv, ^(vector-of Int) ciphertext]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__decryptPKCS1v15(*__rand, __priv, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__ciphertext)))"}
;;   [^io/Reader __rand, ^rsa/PrivateKey __priv, ^Object __ciphertext])

JOKER FUNC crypto/rsa.DecryptPKCS1v15SessionKey from crypto/rsa/pkcs1v15.go:
;; (defn ^"Error" DecryptPKCS1v15SessionKey
;;   "DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding scheme from PKCS#1 v1.5.\nIf rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\nIt returns an error if the ciphertext is the wrong length or if the\nciphertext is greater than the public modulus. Otherwise, no error is\nreturned. If the padding is valid, the resulting plaintext message is copied\ninto key. Otherwise, key is unchanged. These alternatives occur in constant\ntime. It is intended that the user of this function generate a random\nsession key beforehand and continue the protocol with the resulting value.\nThis will remove any possibility that an attacker can learn any information\nabout the plaintext.\nSee ``Chosen Ciphertext Attacks Against Protocols Based on the RSA\nEncryption Standard PKCS #1'', Daniel Bleichenbacher, Advances in Cryptology\n(Crypto '98).\n\nNote that if the session key is too small then it may be possible for an\nattacker to brute-force it. If they can do that then they can learn whether\na random value was used (because it'll be different for the same ciphertext)\nand thus whether the padding was correct. This defeats the point of this\nfunction. Using at least a 16-byte key will protect against this attack.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, ciphertext []byte, key []byte)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.rsa/PrivateKey) priv, ^(vector-of Int) ciphertext, ^(vector-of Int) key]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rsa.DecryptPKCS1v15SessionKey(*__rand, __priv, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__ciphertext)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__key)))"}
;;   [^io/Reader __rand, ^rsa/PrivateKey __priv, ^Object __ciphertext, ^Object __key])

JOKER FUNC crypto/rsa.EncryptOAEP from crypto/rsa/rsa.go:
;; (defn EncryptOAEP
;;   "EncryptOAEP encrypts the given message with RSA-OAEP.\n\nOAEP is parameterised by a hash function that is used as a random oracle.\nEncryption and decryption of a given message must use the same hash function\nand sha256.New() is a reasonable choice.\n\nThe random parameter is used as a source of entropy to ensure that\nencrypting the same message twice doesn't result in the same ciphertext.\n\nThe label parameter may contain arbitrary data that will not be encrypted,\nbut which gives important context to the message. For example, if a given\npublic key is used to decrypt two types of messages then distinct label\nvalues could be used to ensure that a ciphertext for one purpose cannot be\nused for another by an attacker. If not required it can be empty.\n\nThe message must be no longer than the length of the public modulus minus\ntwice the hash length, minus a further 2.\n\nGo input arguments: (hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.hash/Hash hash, ^go.std.io/Reader random, ^(atom-of go.std.crypto.rsa/PublicKey) pub, ^(vector-of Int) msg, ^(vector-of Int) label]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__encryptOAEP(*__hash, *__random, __pub, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__msg)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__label)))"}
;;   [^hash/Hash __hash, ^io/Reader __random, ^rsa/PublicKey __pub, ^Object __msg, ^Object __label])

JOKER FUNC crypto/rsa.EncryptPKCS1v15 from crypto/rsa/pkcs1v15.go:
;; (defn EncryptPKCS1v15
;;   "EncryptPKCS1v15 encrypts the given message with RSA and the padding\nscheme from PKCS#1 v1.5.  The message must be no longer than the\nlength of the public modulus minus 11 bytes.\n\nThe rand parameter is used as a source of entropy to ensure that\nencrypting the same message twice doesn't result in the same\nciphertext.\n\nWARNING: use of this function to encrypt plaintexts other than\nsession keys is dangerous. Use RSA OAEP in new protocols.\n\nGo input arguments: (rand io.Reader, pub *PublicKey, msg []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.rsa/PublicKey) pub, ^(vector-of Int) msg]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__encryptPKCS1v15(*__rand, __pub, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__msg)))"}
;;   [^io/Reader __rand, ^rsa/PublicKey __pub, ^Object __msg])

JOKER FUNC crypto/rsa.GenerateKey from crypto/rsa/rsa.go:
;; (defn GenerateKey
;;   "GenerateKey generates an RSA keypair of the given bit size using the\nrandom source random (for example, crypto/rand.Reader).\n\nGo input arguments: (random io.Reader, bits int)\n\nGo return type: (*PrivateKey, error)\n\nJoker input arguments: [^go.std.io/Reader random, ^Int bits]\n\nJoker return type: [(atom-of go.std.crypto.rsa/PrivateKey) Error]"
;;   {:added "1.0"
;;    :go "__generateKey(*__random, __bits)"}
;;   [^io/Reader __random, ^Int __bits])

JOKER FUNC crypto/rsa.GenerateMultiPrimeKey from crypto/rsa/rsa.go:
;; (defn GenerateMultiPrimeKey
;;   "GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit\nsize and the given random source, as suggested in [1]. Although the public\nkeys are compatible (actually, indistinguishable) from the 2-prime case,\nthe private keys are not. Thus it may not be possible to export multi-prime\nprivate keys in certain formats or to subsequently import them into other\ncode.\n\nTable 1 in [2] suggests maximum numbers of primes for a given size.\n\n[1] US patent 4405829 (1972, expired)\n[2] http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf\n\nGo input arguments: (random io.Reader, nprimes int, bits int)\n\nGo return type: (*PrivateKey, error)\n\nJoker input arguments: [^go.std.io/Reader random, ^Int nprimes, ^Int bits]\n\nJoker return type: [(atom-of go.std.crypto.rsa/PrivateKey) Error]"
;;   {:added "1.0"
;;    :go "__generateMultiPrimeKey(*__random, __nprimes, __bits)"}
;;   [^io/Reader __random, ^Int __nprimes, ^Int __bits])

JOKER FUNC crypto/rsa.SignPKCS1v15 from crypto/rsa/pkcs1v15.go:
;; (defn SignPKCS1v15
;;   "SignPKCS1v15 calculates the signature of hashed using\nRSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5.  Note that hashed must\nbe the result of hashing the input message using the given hash\nfunction. If hash is zero, hashed is signed directly. This isn't\nadvisable except for interoperability.\n\nIf rand is not nil then RSA blinding will be used to avoid timing\nside-channel attacks.\n\nThis function is deterministic. Thus, if the set of possible\nmessages is small, an attacker may be able to build a map from\nmessages to signatures and identify the signed messages. As ever,\nsignatures provide authenticity, not confidentiality.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.rsa/PrivateKey) priv, ^go.std.crypto/Hash hash, ^(vector-of Int) hashed]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__signPKCS1v15(*__rand, __priv, *__hash, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__hashed)))"}
;;   [^io/Reader __rand, ^rsa/PrivateKey __priv, ^crypto/Hash __hash, ^Object __hashed])

JOKER FUNC crypto/rsa.SignPSS from crypto/rsa/pss.go:
;; (defn SignPSS
;;   "SignPSS calculates the signature of hashed using RSASSA-PSS [1].\nNote that hashed must be the result of hashing the input message using the\ngiven hash function. The opts argument may be nil, in which case sensible\ndefaults are used.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte, opts *PSSOptions)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.rsa/PrivateKey) priv, ^go.std.crypto/Hash hash, ^(vector-of Int) hashed, ^(atom-of go.std.crypto.rsa/PSSOptions) opts]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__signPSS(*__rand, __priv, *__hash, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__hashed)), __opts)"}
;;   [^io/Reader __rand, ^rsa/PrivateKey __priv, ^crypto/Hash __hash, ^Object __hashed, ^rsa/PSSOptions __opts])

JOKER FUNC crypto/rsa.VerifyPKCS1v15 from crypto/rsa/pkcs1v15.go:
;; (defn ^"Error" VerifyPKCS1v15
;;   "VerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature.\nhashed is the result of hashing the input message using the given hash\nfunction and sig is the signature. A valid signature is indicated by\nreturning a nil error. If hash is zero then hashed is used directly. This\nisn't advisable except for interoperability.\n\nGo input arguments: (pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.crypto.rsa/PublicKey) pub, ^go.std.crypto/Hash hash, ^(vector-of Int) hashed, ^(vector-of Int) sig]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rsa.VerifyPKCS1v15(__pub, *__hash, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__hashed)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__sig)))"}
;;   [^rsa/PublicKey __pub, ^crypto/Hash __hash, ^Object __hashed, ^Object __sig])

JOKER FUNC crypto/rsa.VerifyPSS from crypto/rsa/pss.go:
;; (defn ^"Error" VerifyPSS
;;   "VerifyPSS verifies a PSS signature.\nhashed is the result of hashing the input message using the given hash\nfunction and sig is the signature. A valid signature is indicated by\nreturning a nil error. The opts argument may be nil, in which case sensible\ndefaults are used.\n\nGo input arguments: (pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte, opts *PSSOptions)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.crypto.rsa/PublicKey) pub, ^go.std.crypto/Hash hash, ^(vector-of Int) hashed, ^(vector-of Int) sig, ^(atom-of go.std.crypto.rsa/PSSOptions) opts]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rsa.VerifyPSS(__pub, *__hash, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__hashed)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__sig)), __opts)"}
;;   [^rsa/PublicKey __pub, ^crypto/Hash __hash, ^Object __hashed, ^Object __sig, ^rsa/PSSOptions __opts])

JOKER TYPE go.std.crypto.rsa/CRTValue:
(def
  ^{:doc "CRTValue contains the precomputed Chinese remainder theorem values.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CRTValue"}
  CRTValue)

JOKER TYPE go.std.crypto.rsa/OAEPOptions:
(def
  ^{:doc "OAEPOptions is an interface for passing options to OAEP decryption using the\ncrypto.Decrypter interface.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_OAEPOptions"}
  OAEPOptions)

JOKER TYPE go.std.crypto.rsa/PKCS1v15DecryptOptions:
(def
  ^{:doc "PKCS1v15DecrypterOpts is for passing options to PKCS#1 v1.5 decryption using\nthe crypto.Decrypter interface.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PKCS1v15DecryptOptions"}
  PKCS1v15DecryptOptions)

JOKER TYPE go.std.crypto.rsa/PSSOptions:
(def
  ^{:doc "PSSOptions contains options for creating and verifying PSS signatures.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PSSOptions"}
  PSSOptions)

JOKER TYPE go.std.crypto.rsa/PrecomputedValues:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PrecomputedValues"}
  PrecomputedValues)

JOKER TYPE go.std.crypto.rsa/PrivateKey:
(def
  ^{:doc "A PrivateKey represents an RSA key\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PrivateKey"}
  PrivateKey)

JOKER TYPE go.std.crypto.rsa/PublicKey:
(def
  ^{:doc "A PublicKey represents the public part of an RSA key.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PublicKey"}
  PublicKey)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["crypto/rsa"]
    :doc "Provides a low-level interface to the crypto/rsa package.\n\nPackage rsa implements RSA encryption as specified in PKCS#1.\n\nRSA is a single, fundamental operation that is used in this package to\nimplement either public-key encryption or public-key signatures.\n\nThe original specification for encryption and signatures with RSA is PKCS#1\nand the terms \"RSA encryption\" and \"RSA signatures\" by default refer to\nPKCS#1 version 1.5. However, that specification has flaws and new designs\nshould use version two, usually called by just OAEP and PSS, where\npossible.\n\nTwo sets of interfaces are included in this package. When a more abstract\ninterface isn't necessary, there are functions for encrypting/decrypting\nwith v1.5/OAEP and signing/verifying with v1.5/PSS. If one needs to abstract\nover the public-key primitive, the PrivateKey struct implements the\nDecrypter and Signer interfaces from the crypto package.\n\nThe RSA operations in this package are not implemented using constant-time algorithms.\n"
    :empty false}
  go.std.crypto.rsa)
JOKER CONSTANT BlockSize from crypto/sha1/sha1.go:
(def
  ^{:doc "The blocksize of SHA-1 in bytes.\n"
    :added "1.0"
    :tag "Int"
    :go "sha1.BlockSize"}
  BlockSize)

JOKER CONSTANT Size from crypto/sha1/sha1.go:
(def
  ^{:doc "The size of a SHA-1 checksum in bytes.\n"
    :added "1.0"
    :tag "Int"
    :go "sha1.Size"}
  Size)

JOKER FUNC crypto/sha1.New from crypto/sha1/sha1.go:
(defn New
  "New returns a new hash.Hash computing the SHA1 checksum. The Hash also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new()"}
  [])

JOKER FUNC crypto/sha1.Sum from crypto/sha1/sha1.go:
;; (defn Sum
;;   "Sum returns the SHA-1 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)))"}
;;   [^Object __data])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["crypto/sha1"]
    :doc "Provides a low-level interface to the crypto/sha1 package.\n\nPackage sha1 implements the SHA-1 hash algorithm as defined in RFC 3174.\n\nSHA-1 is cryptographically broken and should not be used for secure\napplications.\n"
    :empty false}
  go.std.crypto.sha1)
JOKER CONSTANT BlockSize from crypto/sha256/sha256.go:
(def
  ^{:doc "The blocksize of SHA256 and SHA224 in bytes.\n"
    :added "1.0"
    :tag "Int"
    :go "sha256.BlockSize"}
  BlockSize)

JOKER CONSTANT Size from crypto/sha256/sha256.go:
(def
  ^{:doc "The size of a SHA256 checksum in bytes.\n"
    :added "1.0"
    :tag "Int"
    :go "sha256.Size"}
  Size)

JOKER CONSTANT Size224 from crypto/sha256/sha256.go:
(def
  ^{:doc "The size of a SHA224 checksum in bytes.\n"
    :added "1.0"
    :tag "Int"
    :go "sha256.Size224"}
  Size224)

JOKER FUNC crypto/sha256.New from crypto/sha256/sha256.go:
(defn New
  "New returns a new hash.Hash computing the SHA256 checksum. The Hash\nalso implements encoding.BinaryMarshaler and\nencoding.BinaryUnmarshaler to marshal and unmarshal the internal\nstate of the hash.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new()"}
  [])

JOKER FUNC crypto/sha256.New224 from crypto/sha256/sha256.go:
(defn New224
  "New224 returns a new hash.Hash computing the SHA224 checksum.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new224()"}
  [])

JOKER FUNC crypto/sha256.Sum224 from crypto/sha256/sha256.go:
;; (defn Sum224
;;   "Sum224 returns the SHA224 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum224(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)))"}
;;   [^Object __data])

JOKER FUNC crypto/sha256.Sum256 from crypto/sha256/sha256.go:
;; (defn Sum256
;;   "Sum256 returns the SHA256 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum256(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)))"}
;;   [^Object __data])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["crypto/sha256"]
    :doc "Provides a low-level interface to the crypto/sha256 package.\n\nPackage sha256 implements the SHA224 and SHA256 hash algorithms as defined\nin FIPS 180-4.\n"
    :empty false}
  go.std.crypto.sha256)
JOKER CONSTANT BlockSize from crypto/sha512/sha512.go:
(def
  ^{:doc "BlockSize is the block size, in bytes, of the SHA-512/224,\nSHA-512/256, SHA-384 and SHA-512 hash functions.\n"
    :added "1.0"
    :tag "Int"
    :go "sha512.BlockSize"}
  BlockSize)

JOKER CONSTANT Size from crypto/sha512/sha512.go:
(def
  ^{:doc "Size is the size, in bytes, of a SHA-512 checksum.\n"
    :added "1.0"
    :tag "Int"
    :go "sha512.Size"}
  Size)

JOKER CONSTANT Size224 from crypto/sha512/sha512.go:
(def
  ^{:doc "Size224 is the size, in bytes, of a SHA-512/224 checksum.\n"
    :added "1.0"
    :tag "Int"
    :go "sha512.Size224"}
  Size224)

JOKER CONSTANT Size256 from crypto/sha512/sha512.go:
(def
  ^{:doc "Size256 is the size, in bytes, of a SHA-512/256 checksum.\n"
    :added "1.0"
    :tag "Int"
    :go "sha512.Size256"}
  Size256)

JOKER CONSTANT Size384 from crypto/sha512/sha512.go:
(def
  ^{:doc "Size384 is the size, in bytes, of a SHA-384 checksum.\n"
    :added "1.0"
    :tag "Int"
    :go "sha512.Size384"}
  Size384)

JOKER FUNC crypto/sha512.New from crypto/sha512/sha512.go:
(defn New
  "New returns a new hash.Hash computing the SHA-512 checksum.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new()"}
  [])

JOKER FUNC crypto/sha512.New384 from crypto/sha512/sha512.go:
(defn New384
  "New384 returns a new hash.Hash computing the SHA-384 checksum.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new384()"}
  [])

JOKER FUNC crypto/sha512.New512_224 from crypto/sha512/sha512.go:
(defn New512_224
  "New512_224 returns a new hash.Hash computing the SHA-512/224 checksum.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new512_224()"}
  [])

JOKER FUNC crypto/sha512.New512_256 from crypto/sha512/sha512.go:
(defn New512_256
  "New512_256 returns a new hash.Hash computing the SHA-512/256 checksum.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new512_256()"}
  [])

JOKER FUNC crypto/sha512.Sum384 from crypto/sha512/sha512.go:
;; (defn Sum384
;;   "Sum384 returns the SHA384 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum384(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)))"}
;;   [^Object __data])

JOKER FUNC crypto/sha512.Sum512 from crypto/sha512/sha512.go:
;; (defn Sum512
;;   "Sum512 returns the SHA512 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum512(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)))"}
;;   [^Object __data])

JOKER FUNC crypto/sha512.Sum512_224 from crypto/sha512/sha512.go:
;; (defn Sum512_224
;;   "Sum512_224 returns the Sum512/224 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum512_224(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)))"}
;;   [^Object __data])

JOKER FUNC crypto/sha512.Sum512_256 from crypto/sha512/sha512.go:
;; (defn Sum512_256
;;   "Sum512_256 returns the Sum512/256 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum512_256(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)))"}
;;   [^Object __data])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["crypto/sha512"]
    :doc "Provides a low-level interface to the crypto/sha512 package.\n\nPackage sha512 implements the SHA-384, SHA-512, SHA-512/224, and SHA-512/256\nhash algorithms as defined in FIPS 180-4.\n\nAll the hash.Hash implementations returned by this package also\nimplement encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n"
    :empty false}
  go.std.crypto.sha512)
JOKER FUNC crypto/subtle.ConstantTimeByteEq from crypto/subtle/constant_time.go:
(defn ^"Int" ConstantTimeByteEq
  "ConstantTimeByteEq returns 1 if x == y and 0 otherwise.\n\nGo input arguments: (x uint8, y uint8)\n\nGo return type: int\n\nJoker input arguments: [^Int x, ^Int y]\n\nJoker return type: Int"
  {:added "1.0"
   :go "subtle.ConstantTimeByteEq(__x, __y)"}
  [^UInt8 __x, ^UInt8 __y])

JOKER FUNC crypto/subtle.ConstantTimeCompare from crypto/subtle/constant_time.go:
;; (defn ^"Int" ConstantTimeCompare
;;   "ConstantTimeCompare returns 1 if the two slices, x and y, have equal contents\nand 0 otherwise. The time taken is a function of the length of the slices and\nis independent of the contents.\n\nGo input arguments: (x []byte, y []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) x, ^(vector-of Int) y]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "subtle.ConstantTimeCompare(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__x)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__y)))"}
;;   [^Object __x, ^Object __y])

JOKER FUNC crypto/subtle.ConstantTimeCopy from crypto/subtle/constant_time.go:
;; (defn ConstantTimeCopy
;;   "ConstantTimeCopy copies the contents of y into x (a slice of equal length)\nif v == 1. If v == 0, x is left unchanged. Its behavior is undefined if v\ntakes any other value.\n\nGo input arguments: (v int, x []byte, y []byte)\n\nJoker input arguments: [^Int v, ^(vector-of Int) x, ^(vector-of Int) y]"
;;   {:added "1.0"
;;    :go "__constantTimeCopy(__v, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__x)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__y)))"}
;;   [^Int __v, ^Object __x, ^Object __y])

JOKER FUNC crypto/subtle.ConstantTimeEq from crypto/subtle/constant_time.go:
(defn ^"Int" ConstantTimeEq
  "ConstantTimeEq returns 1 if x == y and 0 otherwise.\n\nGo input arguments: (x int32, y int32)\n\nGo return type: int\n\nJoker input arguments: [^Int x, ^Int y]\n\nJoker return type: Int"
  {:added "1.0"
   :go "subtle.ConstantTimeEq(__x, __y)"}
  [^Int32 __x, ^Int32 __y])

JOKER FUNC crypto/subtle.ConstantTimeLessOrEq from crypto/subtle/constant_time.go:
(defn ^"Int" ConstantTimeLessOrEq
  "ConstantTimeLessOrEq returns 1 if x <= y and 0 otherwise.\nIts behavior is undefined if x or y are negative or > 2**31 - 1.\n\nGo input arguments: (x int, y int)\n\nGo return type: int\n\nJoker input arguments: [^Int x, ^Int y]\n\nJoker return type: Int"
  {:added "1.0"
   :go "subtle.ConstantTimeLessOrEq(__x, __y)"}
  [^Int __x, ^Int __y])

JOKER FUNC crypto/subtle.ConstantTimeSelect from crypto/subtle/constant_time.go:
(defn ^"Int" ConstantTimeSelect
  "ConstantTimeSelect returns x if v == 1 and y if v == 0.\nIts behavior is undefined if v takes any other value.\n\nGo input arguments: (v int, x int, y int)\n\nGo return type: int\n\nJoker input arguments: [^Int v, ^Int x, ^Int y]\n\nJoker return type: Int"
  {:added "1.0"
   :go "subtle.ConstantTimeSelect(__v, __x, __y)"}
  [^Int __v, ^Int __x, ^Int __y])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["crypto/subtle"]
    :doc "Provides a low-level interface to the crypto/subtle package.\n\nPackage subtle implements functions that are often useful in cryptographic\ncode but require careful thought to use correctly.\n"
    :empty false}
  go.std.crypto.subtle)
JOKER CONSTANT CurveP256 from crypto/tls/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint16(tls.CurveP256))"}
  CurveP256)

JOKER CONSTANT CurveP384 from crypto/tls/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint16(tls.CurveP384))"}
  CurveP384)

JOKER CONSTANT CurveP521 from crypto/tls/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint16(tls.CurveP521))"}
  CurveP521)

JOKER CONSTANT ECDSAWithP256AndSHA256 from crypto/tls/common.go:
(def
  ^{:doc "ECDSA algorithms. Only constrained to a specific curve in TLS 1.3.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(tls.ECDSAWithP256AndSHA256))"}
  ECDSAWithP256AndSHA256)

JOKER CONSTANT ECDSAWithP384AndSHA384 from crypto/tls/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint16(tls.ECDSAWithP384AndSHA384))"}
  ECDSAWithP384AndSHA384)

JOKER CONSTANT ECDSAWithP521AndSHA512 from crypto/tls/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint16(tls.ECDSAWithP521AndSHA512))"}
  ECDSAWithP521AndSHA512)

JOKER CONSTANT ECDSAWithSHA1 from crypto/tls/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint16(tls.ECDSAWithSHA1))"}
  ECDSAWithSHA1)

JOKER CONSTANT NoClientCert from crypto/tls/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(tls.NoClientCert)"}
  NoClientCert)

JOKER CONSTANT PKCS1WithSHA1 from crypto/tls/common.go:
(def
  ^{:doc "Legacy signature and hash algorithms for TLS 1.2.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(tls.PKCS1WithSHA1))"}
  PKCS1WithSHA1)

JOKER CONSTANT PKCS1WithSHA256 from crypto/tls/common.go:
(def
  ^{:doc "RSASSA-PKCS1-v1_5 algorithms.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(tls.PKCS1WithSHA256))"}
  PKCS1WithSHA256)

JOKER CONSTANT PKCS1WithSHA384 from crypto/tls/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint16(tls.PKCS1WithSHA384))"}
  PKCS1WithSHA384)

JOKER CONSTANT PKCS1WithSHA512 from crypto/tls/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint16(tls.PKCS1WithSHA512))"}
  PKCS1WithSHA512)

JOKER CONSTANT PSSWithSHA256 from crypto/tls/common.go:
(def
  ^{:doc "RSASSA-PSS algorithms with public key OID rsaEncryption.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(tls.PSSWithSHA256))"}
  PSSWithSHA256)

JOKER CONSTANT PSSWithSHA384 from crypto/tls/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint16(tls.PSSWithSHA384))"}
  PSSWithSHA384)

JOKER CONSTANT PSSWithSHA512 from crypto/tls/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint16(tls.PSSWithSHA512))"}
  PSSWithSHA512)

JOKER CONSTANT RenegotiateFreelyAsClient from crypto/tls/common.go:
(def
  ^{:doc "RenegotiateFreelyAsClient allows a remote server to repeatedly\nrequest renegotiation.\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.RenegotiateFreelyAsClient)"}
  RenegotiateFreelyAsClient)

JOKER CONSTANT RenegotiateNever from crypto/tls/common.go:
(def
  ^{:doc "RenegotiateNever disables renegotiation.\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.RenegotiateNever)"}
  RenegotiateNever)

JOKER CONSTANT RenegotiateOnceAsClient from crypto/tls/common.go:
(def
  ^{:doc "RenegotiateOnceAsClient allows a remote server to request\nrenegotiation once per connection.\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.RenegotiateOnceAsClient)"}
  RenegotiateOnceAsClient)

JOKER CONSTANT RequestClientCert from crypto/tls/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(tls.RequestClientCert)"}
  RequestClientCert)

JOKER CONSTANT RequireAndVerifyClientCert from crypto/tls/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(tls.RequireAndVerifyClientCert)"}
  RequireAndVerifyClientCert)

JOKER CONSTANT RequireAnyClientCert from crypto/tls/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(tls.RequireAnyClientCert)"}
  RequireAnyClientCert)

JOKER CONSTANT TLS_AES_128_GCM_SHA256 from crypto/tls/cipher_suites.go:
(def
  ^{:doc "TLS 1.3 cipher suites.\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_AES_128_GCM_SHA256)"}
  TLS_AES_128_GCM_SHA256)

JOKER CONSTANT TLS_AES_256_GCM_SHA384 from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_AES_256_GCM_SHA384)"}
  TLS_AES_256_GCM_SHA384)

JOKER CONSTANT TLS_CHACHA20_POLY1305_SHA256 from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_CHACHA20_POLY1305_SHA256)"}
  TLS_CHACHA20_POLY1305_SHA256)

JOKER CONSTANT TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA)"}
  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA)

JOKER CONSTANT TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256)"}
  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256)

JOKER CONSTANT TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256)"}
  TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256)

JOKER CONSTANT TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA)"}
  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA)

JOKER CONSTANT TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384)"}
  TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384)

JOKER CONSTANT TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305)"}
  TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305)

JOKER CONSTANT TLS_ECDHE_ECDSA_WITH_RC4_128_SHA from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA)"}
  TLS_ECDHE_ECDSA_WITH_RC4_128_SHA)

JOKER CONSTANT TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA)"}
  TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA)

JOKER CONSTANT TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA)"}
  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA)

JOKER CONSTANT TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256)"}
  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256)

JOKER CONSTANT TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256)"}
  TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256)

JOKER CONSTANT TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA)"}
  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA)

JOKER CONSTANT TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384)"}
  TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384)

JOKER CONSTANT TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305 from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305)"}
  TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305)

JOKER CONSTANT TLS_ECDHE_RSA_WITH_RC4_128_SHA from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA)"}
  TLS_ECDHE_RSA_WITH_RC4_128_SHA)

JOKER CONSTANT TLS_FALLBACK_SCSV from crypto/tls/cipher_suites.go:
(def
  ^{:doc "TLS_FALLBACK_SCSV isn't a standard cipher suite but an indicator\nthat the client is doing version fallback. See RFC 7507.\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_FALLBACK_SCSV)"}
  TLS_FALLBACK_SCSV)

JOKER CONSTANT TLS_RSA_WITH_3DES_EDE_CBC_SHA from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_RSA_WITH_3DES_EDE_CBC_SHA)"}
  TLS_RSA_WITH_3DES_EDE_CBC_SHA)

JOKER CONSTANT TLS_RSA_WITH_AES_128_CBC_SHA from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_RSA_WITH_AES_128_CBC_SHA)"}
  TLS_RSA_WITH_AES_128_CBC_SHA)

JOKER CONSTANT TLS_RSA_WITH_AES_128_CBC_SHA256 from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_RSA_WITH_AES_128_CBC_SHA256)"}
  TLS_RSA_WITH_AES_128_CBC_SHA256)

JOKER CONSTANT TLS_RSA_WITH_AES_128_GCM_SHA256 from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_RSA_WITH_AES_128_GCM_SHA256)"}
  TLS_RSA_WITH_AES_128_GCM_SHA256)

JOKER CONSTANT TLS_RSA_WITH_AES_256_CBC_SHA from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_RSA_WITH_AES_256_CBC_SHA)"}
  TLS_RSA_WITH_AES_256_CBC_SHA)

JOKER CONSTANT TLS_RSA_WITH_AES_256_GCM_SHA384 from crypto/tls/cipher_suites.go:
(def
  ^{:doc "A list of cipher suite IDs that are, or have been, implemented by this\npackage.\n\nTaken from https://www.iana.org/assignments/tls-parameters/tls-parameters.xml\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_RSA_WITH_AES_256_GCM_SHA384)"}
  TLS_RSA_WITH_AES_256_GCM_SHA384)

JOKER CONSTANT TLS_RSA_WITH_RC4_128_SHA from crypto/tls/cipher_suites.go:
(def
  ^{:doc "TLS 1.0 - 1.2 cipher suites.\n"
    :added "1.0"
    :tag "Int"
    :go "int(tls.TLS_RSA_WITH_RC4_128_SHA)"}
  TLS_RSA_WITH_RC4_128_SHA)

JOKER CONSTANT VerifyClientCertIfGiven from crypto/tls/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(tls.VerifyClientCertIfGiven)"}
  VerifyClientCertIfGiven)

JOKER CONSTANT VersionSSL30 from crypto/tls/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "tls.VersionSSL30"}
  VersionSSL30)

JOKER CONSTANT VersionTLS10 from crypto/tls/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "tls.VersionTLS10"}
  VersionTLS10)

JOKER CONSTANT VersionTLS11 from crypto/tls/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "tls.VersionTLS11"}
  VersionTLS11)

JOKER CONSTANT VersionTLS12 from crypto/tls/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "tls.VersionTLS12"}
  VersionTLS12)

JOKER CONSTANT VersionTLS13 from crypto/tls/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "tls.VersionTLS13"}
  VersionTLS13)

JOKER CONSTANT X25519 from crypto/tls/common.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint16(tls.X25519))"}
  X25519)

JOKER TYPE crypto/tls.Certificate from crypto/tls/common.go:
;; (defn ^"GoObject" Certificate.
;;   "Constructor for tls.Certificate"
;;   {:added "1.0"
;;    :go "_ConstructCertificate(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/tls.CertificateRequestInfo from crypto/tls/common.go:
;; (defn ^"GoObject" CertificateRequestInfo.
;;   "Constructor for tls.CertificateRequestInfo"
;;   {:added "1.0"
;;    :go "_ConstructCertificateRequestInfo(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/tls.ClientAuthType from crypto/tls/common.go:
(defn ^"GoObject" ClientAuthType.
  "Constructor for tls.ClientAuthType"
  {:added "1.0"
   :go "_ConstructClientAuthType(_v)"}
  [^Object _v])

JOKER TYPE crypto/tls.ClientHelloInfo from crypto/tls/common.go:
;; (defn ^"GoObject" ClientHelloInfo.
;;   "Constructor for tls.ClientHelloInfo"
;;   {:added "1.0"
;;    :go "_ConstructClientHelloInfo(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/tls.ClientSessionCache from crypto/tls/common.go:
;; (defn ^"GoObject" ClientSessionCache.
;;   "Constructor for tls.ClientSessionCache"
;;   {:added "1.0"
;;    :go "_ConstructClientSessionCache(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/tls.ClientSessionState from crypto/tls/common.go:
(defn ^"GoObject" ClientSessionState.
  "Constructor for tls.ClientSessionState"
  {:added "1.0"
   :go "_ConstructClientSessionState(_v)"}
  [^Object _v])

JOKER TYPE crypto/tls.Config from crypto/tls/common.go:
;; (defn ^"GoObject" Config.
;;   "Constructor for tls.Config"
;;   {:added "1.0"
;;    :go "_ConstructConfig(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/tls.Conn from crypto/tls/conn.go:
(defn ^"GoObject" Conn.
  "Constructor for tls.Conn"
  {:added "1.0"
   :go "_ConstructConn(_v)"}
  [^Object _v])

JOKER TYPE crypto/tls.ConnectionState from crypto/tls/common.go:
;; (defn ^"GoObject" ConnectionState.
;;   "Constructor for tls.ConnectionState"
;;   {:added "1.0"
;;    :go "_ConstructConnectionState(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/tls.CurveID from crypto/tls/common.go:
(defn ^"GoObject" CurveID.
  "Constructor for tls.CurveID"
  {:added "1.0"
   :go "_ConstructCurveID(_v)"}
  [^Object _v])

JOKER TYPE crypto/tls.RecordHeaderError from crypto/tls/conn.go:
;; (defn ^"GoObject" RecordHeaderError.
;;   "Constructor for tls.RecordHeaderError"
;;   {:added "1.0"
;;    :go "_ConstructRecordHeaderError(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/tls.RenegotiationSupport from crypto/tls/common.go:
(defn ^"GoObject" RenegotiationSupport.
  "Constructor for tls.RenegotiationSupport"
  {:added "1.0"
   :go "_ConstructRenegotiationSupport(_v)"}
  [^Object _v])

JOKER TYPE crypto/tls.SignatureScheme from crypto/tls/common.go:
(defn ^"GoObject" SignatureScheme.
  "Constructor for tls.SignatureScheme"
  {:added "1.0"
   :go "_ConstructSignatureScheme(_v)"}
  [^Object _v])

JOKER FUNC crypto/tls.Client from crypto/tls/tls.go:
;; (defn Client
;;   "Client returns a new TLS client side connection\nusing conn as the underlying transport.\nThe config cannot be nil: users must set either ServerName or\nInsecureSkipVerify in the config.\n\nGo input arguments: (conn net.Conn, config *Config)\n\nGo return type: *Conn\n\nJoker input arguments: [^go.std.net/Conn conn, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: (atom-of go.std.crypto.tls/Conn)"
;;   {:added "1.0"
;;    :go "__client(*__conn, __config)"}
;;   [^net/Conn __conn, ^tls/Config __config])

JOKER FUNC crypto/tls.Dial from crypto/tls/tls.go:
(defn Dial
  "Dial connects to the given network address using net.Dial\nand then initiates a TLS handshake, returning the resulting\nTLS connection.\nDial interprets a nil configuration as equivalent to\nthe zero configuration; see the documentation of Config\nfor the defaults.\n\nGo input arguments: (network string, addr string, config *Config)\n\nGo return type: (*Conn, error)\n\nJoker input arguments: [^String network, ^String addr, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: [(atom-of go.std.crypto.tls/Conn) Error]"
  {:added "1.0"
   :go "__dial(__network, __addr, __config)"}
  [^String __network, ^String __addr, ^tls/Config __config])

JOKER FUNC crypto/tls.DialWithDialer from crypto/tls/tls.go:
;; (defn DialWithDialer
;;   "DialWithDialer connects to the given network address using dialer.Dial and\nthen initiates a TLS handshake, returning the resulting TLS connection. Any\ntimeout or deadline given in the dialer apply to connection and TLS\nhandshake as a whole.\n\nDialWithDialer interprets a nil configuration as equivalent to the zero\nconfiguration; see the documentation of Config for the defaults.\n\nGo input arguments: (dialer *net.Dialer, network string, addr string, config *Config)\n\nGo return type: (*Conn, error)\n\nJoker input arguments: [^(atom-of go.std.net/Dialer) dialer, ^String network, ^String addr, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: [(atom-of go.std.crypto.tls/Conn) Error]"
;;   {:added "1.0"
;;    :go "__dialWithDialer(__dialer, __network, __addr, __config)"}
;;   [^net/Dialer __dialer, ^String __network, ^String __addr, ^tls/Config __config])

JOKER FUNC crypto/tls.Listen from crypto/tls/tls.go:
(defn Listen
  "Listen creates a TLS listener accepting connections on the\ngiven network address using net.Listen.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\n\nGo input arguments: (network string, laddr string, config *Config)\n\nGo return type: (net.Listener, error)\n\nJoker input arguments: [^String network, ^String laddr, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: [go.std.net/Listener Error]"
  {:added "1.0"
   :go "__listen(__network, __laddr, __config)"}
  [^String __network, ^String __laddr, ^tls/Config __config])

JOKER FUNC crypto/tls.LoadX509KeyPair from crypto/tls/tls.go:
(defn LoadX509KeyPair
  "LoadX509KeyPair reads and parses a public/private key pair from a pair\nof files. The files must contain PEM encoded data. The certificate file\nmay contain intermediate certificates following the leaf certificate to\nform a certificate chain. On successful return, Certificate.Leaf will\nbe nil because the parsed form of the certificate is not retained.\n\nGo input arguments: (certFile string, keyFile string)\n\nGo return type: (Certificate, error)\n\nJoker input arguments: [^String certFile, ^String keyFile]\n\nJoker return type: [go.std.crypto.tls/Certificate Error]"
  {:added "1.0"
   :go "__loadX509KeyPair(__certFile, __keyFile)"}
  [^String __certFile, ^String __keyFile])

JOKER FUNC crypto/tls.NewLRUClientSessionCache from crypto/tls/common.go:
(defn NewLRUClientSessionCache
  "NewLRUClientSessionCache returns a ClientSessionCache with the given\ncapacity that uses an LRU strategy. If capacity is < 1, a default capacity\nis used instead.\n\nGo input arguments: (capacity int)\n\nGo return type: ClientSessionCache\n\nJoker input arguments: [^Int capacity]\n\nJoker return type: go.std.crypto.tls/ClientSessionCache"
  {:added "1.0"
   :go "__newLRUClientSessionCache(__capacity)"}
  [^Int __capacity])

JOKER FUNC crypto/tls.NewListener from crypto/tls/tls.go:
;; (defn NewListener
;;   "NewListener creates a Listener which accepts connections from an inner\nListener and wraps each connection with Server.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\n\nGo input arguments: (inner net.Listener, config *Config)\n\nGo return type: net.Listener\n\nJoker input arguments: [^go.std.net/Listener inner, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: go.std.net/Listener"
;;   {:added "1.0"
;;    :go "__newListener(*__inner, __config)"}
;;   [^net/Listener __inner, ^tls/Config __config])

JOKER FUNC crypto/tls.Server from crypto/tls/tls.go:
;; (defn Server
;;   "Server returns a new TLS server side connection\nusing conn as the underlying transport.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\n\nGo input arguments: (conn net.Conn, config *Config)\n\nGo return type: *Conn\n\nJoker input arguments: [^go.std.net/Conn conn, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: (atom-of go.std.crypto.tls/Conn)"
;;   {:added "1.0"
;;    :go "__server(*__conn, __config)"}
;;   [^net/Conn __conn, ^tls/Config __config])

JOKER FUNC crypto/tls.X509KeyPair from crypto/tls/tls.go:
;; (defn X509KeyPair
;;   "X509KeyPair parses a public/private key pair from a pair of\nPEM encoded data. On successful return, Certificate.Leaf will be nil because\nthe parsed form of the certificate is not retained.\n\nGo input arguments: (certPEMBlock []byte, keyPEMBlock []byte)\n\nGo return type: (Certificate, error)\n\nJoker input arguments: [^(vector-of Int) certPEMBlock, ^(vector-of Int) keyPEMBlock]\n\nJoker return type: [go.std.crypto.tls/Certificate Error]"
;;   {:added "1.0"
;;    :go "__x509KeyPair(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__certPEMBlock)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__keyPEMBlock)))"}
;;   [^Object __certPEMBlock, ^Object __keyPEMBlock])

JOKER TYPE go.std.crypto.tls/Certificate:
(def
  ^{:doc "A Certificate is a chain of one or more certificates, leaf first.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Certificate"}
  Certificate)

JOKER TYPE go.std.crypto.tls/CertificateRequestInfo:
(def
  ^{:doc "CertificateRequestInfo contains information from a server's\nCertificateRequest message, which is used to demand a certificate and proof\nof control from a client.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CertificateRequestInfo"}
  CertificateRequestInfo)

JOKER TYPE go.std.crypto.tls/ClientAuthType:
(def
  ^{:doc "ClientAuthType declares the policy the server will follow for\nTLS Client Authentication.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ClientAuthType"}
  ClientAuthType)

JOKER TYPE go.std.crypto.tls/ClientHelloInfo:
(def
  ^{:doc "ClientHelloInfo contains information from a ClientHello message in order to\nguide certificate selection in the GetCertificate callback.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ClientHelloInfo"}
  ClientHelloInfo)

JOKER TYPE go.std.crypto.tls/ClientSessionCache:
(def
  ^{:doc "ClientSessionCache is a cache of ClientSessionState objects that can be used\nby a client to resume a TLS session with a given server. ClientSessionCache\nimplementations should expect to be called concurrently from different\ngoroutines. Up to TLS 1.2, only ticket-based resumption is supported, not\nSessionID-based resumption. In TLS 1.3 they were merged into PSK modes, which\nare supported via this interface.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ClientSessionCache"}
  ClientSessionCache)

JOKER TYPE go.std.crypto.tls/ClientSessionState:
(def
  ^{:doc "ClientSessionState contains the state needed by clients to resume TLS\nsessions.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ClientSessionState"}
  ClientSessionState)

JOKER TYPE go.std.crypto.tls/Config:
(def
  ^{:doc "A Config structure is used to configure a TLS client or server.\nAfter one has been passed to a TLS function it must not be\nmodified. A Config may be reused; the tls package will also not\nmodify it.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Config"}
  Config)

JOKER TYPE go.std.crypto.tls/Conn:
(def
  ^{:doc "A Conn represents a secured connection.\nIt implements the net.Conn interface.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Conn"}
  Conn)

JOKER TYPE go.std.crypto.tls/ConnectionState:
(def
  ^{:doc "ConnectionState records basic TLS details about the connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ConnectionState"}
  ConnectionState)

JOKER TYPE go.std.crypto.tls/CurveID:
(def
  ^{:doc "CurveID is the type of a TLS identifier for an elliptic curve. See\nhttps://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8.\n\nIn TLS 1.3, this type is called NamedGroup, but at this time this library\nonly supports Elliptic Curve based groups. See RFC 8446, Section 4.2.7.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CurveID"}
  CurveID)

JOKER TYPE go.std.crypto.tls/RecordHeaderError:
(def
  ^{:doc "RecordHeaderError is returned when a TLS record header is invalid.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RecordHeaderError"}
  RecordHeaderError)

JOKER TYPE go.std.crypto.tls/RenegotiationSupport:
(def
  ^{:doc "RenegotiationSupport enumerates the different levels of support for TLS\nrenegotiation. TLS renegotiation is the act of performing subsequent\nhandshakes on a connection after the first. This significantly complicates\nthe state machine and has been the source of numerous, subtle security\nissues. Initiating a renegotiation is not supported, but support for\naccepting renegotiation requests may be enabled.\n\nEven when enabled, the server may not change its identity between handshakes\n(i.e. the leaf certificate must be the same). Additionally, concurrent\nhandshake and application data flow is not permitted so renegotiation can\nonly be used with protocols that synchronise with the renegotiation, such as\nHTTPS.\n\nRenegotiation is not defined in TLS 1.3.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RenegotiationSupport"}
  RenegotiationSupport)

JOKER TYPE go.std.crypto.tls/SignatureScheme:
(def
  ^{:doc "SignatureScheme identifies a signature algorithm supported by TLS. See\nRFC 8446, Section 4.2.3.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SignatureScheme"}
  SignatureScheme)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["crypto/tls"]
    :doc "Provides a low-level interface to the crypto/tls package.\n\nPackage tls partially implements TLS 1.2, as specified in RFC 5246,\nand TLS 1.3, as specified in RFC 8446.\n\nTLS 1.3 is available only on an opt-in basis in Go 1.12. To enable\nit, set the GODEBUG environment variable (comma-separated key=value\noptions) such that it includes \"tls13=1\". To enable it from within\nthe process, set the environment variable before any use of TLS:\n\n    func init() {\n        os.Setenv(\"GODEBUG\", os.Getenv(\"GODEBUG\")+\",tls13=1\")\n    }\n"
    :empty false}
  go.std.crypto.tls)
JOKER CONSTANT CANotAuthorizedForExtKeyUsage from crypto/x509/verify.go:
(def
  ^{:doc "CANotAuthorizedForExtKeyUsage results when an intermediate or root\ncertificate does not permit a requested extended key usage.\n"
    :added "1.0"
    :tag "Int"
    :go "int(x509.CANotAuthorizedForExtKeyUsage)"}
  CANotAuthorizedForExtKeyUsage)

JOKER CONSTANT CANotAuthorizedForThisName from crypto/x509/verify.go:
(def
  ^{:doc "CANotAuthorizedForThisName results when an intermediate or root\ncertificate has a name constraint which doesn't permit a DNS or\nother name (including IP address) in the leaf certificate.\n"
    :added "1.0"
    :tag "Int"
    :go "int(x509.CANotAuthorizedForThisName)"}
  CANotAuthorizedForThisName)

JOKER CONSTANT DSA from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.DSA)"}
  DSA)

JOKER CONSTANT DSAWithSHA1 from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.DSAWithSHA1)"}
  DSAWithSHA1)

JOKER CONSTANT DSAWithSHA256 from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.DSAWithSHA256)"}
  DSAWithSHA256)

JOKER CONSTANT ECDSA from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.ECDSA)"}
  ECDSA)

JOKER CONSTANT ECDSAWithSHA1 from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.ECDSAWithSHA1)"}
  ECDSAWithSHA1)

JOKER CONSTANT ECDSAWithSHA256 from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.ECDSAWithSHA256)"}
  ECDSAWithSHA256)

JOKER CONSTANT ECDSAWithSHA384 from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.ECDSAWithSHA384)"}
  ECDSAWithSHA384)

JOKER CONSTANT ECDSAWithSHA512 from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.ECDSAWithSHA512)"}
  ECDSAWithSHA512)

JOKER CONSTANT Expired from crypto/x509/verify.go:
(def
  ^{:doc "Expired results when a certificate has expired, based on the time\ngiven in the VerifyOptions.\n"
    :added "1.0"
    :tag "Int"
    :go "int(x509.Expired)"}
  Expired)

JOKER CONSTANT ExtKeyUsageAny from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.ExtKeyUsageAny)"}
  ExtKeyUsageAny)

JOKER CONSTANT ExtKeyUsageClientAuth from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.ExtKeyUsageClientAuth)"}
  ExtKeyUsageClientAuth)

JOKER CONSTANT ExtKeyUsageCodeSigning from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.ExtKeyUsageCodeSigning)"}
  ExtKeyUsageCodeSigning)

JOKER CONSTANT ExtKeyUsageEmailProtection from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.ExtKeyUsageEmailProtection)"}
  ExtKeyUsageEmailProtection)

JOKER CONSTANT ExtKeyUsageIPSECEndSystem from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.ExtKeyUsageIPSECEndSystem)"}
  ExtKeyUsageIPSECEndSystem)

JOKER CONSTANT ExtKeyUsageIPSECTunnel from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.ExtKeyUsageIPSECTunnel)"}
  ExtKeyUsageIPSECTunnel)

JOKER CONSTANT ExtKeyUsageIPSECUser from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.ExtKeyUsageIPSECUser)"}
  ExtKeyUsageIPSECUser)

JOKER CONSTANT ExtKeyUsageMicrosoftCommercialCodeSigning from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.ExtKeyUsageMicrosoftCommercialCodeSigning)"}
  ExtKeyUsageMicrosoftCommercialCodeSigning)

JOKER CONSTANT ExtKeyUsageMicrosoftKernelCodeSigning from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.ExtKeyUsageMicrosoftKernelCodeSigning)"}
  ExtKeyUsageMicrosoftKernelCodeSigning)

JOKER CONSTANT ExtKeyUsageMicrosoftServerGatedCrypto from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.ExtKeyUsageMicrosoftServerGatedCrypto)"}
  ExtKeyUsageMicrosoftServerGatedCrypto)

JOKER CONSTANT ExtKeyUsageNetscapeServerGatedCrypto from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.ExtKeyUsageNetscapeServerGatedCrypto)"}
  ExtKeyUsageNetscapeServerGatedCrypto)

JOKER CONSTANT ExtKeyUsageOCSPSigning from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.ExtKeyUsageOCSPSigning)"}
  ExtKeyUsageOCSPSigning)

JOKER CONSTANT ExtKeyUsageServerAuth from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.ExtKeyUsageServerAuth)"}
  ExtKeyUsageServerAuth)

JOKER CONSTANT ExtKeyUsageTimeStamping from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.ExtKeyUsageTimeStamping)"}
  ExtKeyUsageTimeStamping)

JOKER CONSTANT IncompatibleUsage from crypto/x509/verify.go:
(def
  ^{:doc "IncompatibleUsage results when the certificate's key usage indicates\nthat it may only be used for a different purpose.\n"
    :added "1.0"
    :tag "Int"
    :go "int(x509.IncompatibleUsage)"}
  IncompatibleUsage)

JOKER CONSTANT KeyUsageCRLSign from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.KeyUsageCRLSign)"}
  KeyUsageCRLSign)

JOKER CONSTANT KeyUsageCertSign from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.KeyUsageCertSign)"}
  KeyUsageCertSign)

JOKER CONSTANT KeyUsageContentCommitment from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.KeyUsageContentCommitment)"}
  KeyUsageContentCommitment)

JOKER CONSTANT KeyUsageDataEncipherment from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.KeyUsageDataEncipherment)"}
  KeyUsageDataEncipherment)

JOKER CONSTANT KeyUsageDecipherOnly from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.KeyUsageDecipherOnly)"}
  KeyUsageDecipherOnly)

JOKER CONSTANT KeyUsageDigitalSignature from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.KeyUsageDigitalSignature)"}
  KeyUsageDigitalSignature)

JOKER CONSTANT KeyUsageEncipherOnly from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.KeyUsageEncipherOnly)"}
  KeyUsageEncipherOnly)

JOKER CONSTANT KeyUsageKeyAgreement from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.KeyUsageKeyAgreement)"}
  KeyUsageKeyAgreement)

JOKER CONSTANT KeyUsageKeyEncipherment from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.KeyUsageKeyEncipherment)"}
  KeyUsageKeyEncipherment)

JOKER CONSTANT MD2WithRSA from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.MD2WithRSA)"}
  MD2WithRSA)

JOKER CONSTANT MD5WithRSA from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.MD5WithRSA)"}
  MD5WithRSA)

JOKER CONSTANT NameConstraintsWithoutSANs from crypto/x509/verify.go:
(def
  ^{:doc "NameConstraintsWithoutSANs results when a leaf certificate doesn't\ncontain a Subject Alternative Name extension, but a CA certificate\ncontains name constraints, and the Common Name can be interpreted as\na hostname.\n\nYou can avoid this error by setting the experimental GODEBUG environment\nvariable to \"x509ignoreCN=1\", disabling Common Name matching entirely.\nThis behavior might become the default in the future.\n"
    :added "1.0"
    :tag "Int"
    :go "int(x509.NameConstraintsWithoutSANs)"}
  NameConstraintsWithoutSANs)

JOKER CONSTANT NameMismatch from crypto/x509/verify.go:
(def
  ^{:doc "NameMismatch results when the subject name of a parent certificate\ndoes not match the issuer name in the child.\n"
    :added "1.0"
    :tag "Int"
    :go "int(x509.NameMismatch)"}
  NameMismatch)

JOKER CONSTANT NotAuthorizedToSign from crypto/x509/verify.go:
(def
  ^{:doc "NotAuthorizedToSign results when a certificate is signed by another\nwhich isn't marked as a CA certificate.\n"
    :added "1.0"
    :tag "Int"
    :go "int(x509.NotAuthorizedToSign)"}
  NotAuthorizedToSign)

JOKER CONSTANT PEMCipher3DES from crypto/x509/pem_decrypt.go:
(def
  ^{:doc "Possible values for the EncryptPEMBlock encryption algorithm.\n"
    :added "1.0"
    :tag "Int"
    :go "int(x509.PEMCipher3DES)"}
  PEMCipher3DES)

JOKER CONSTANT PEMCipherAES128 from crypto/x509/pem_decrypt.go:
(def
  ^{:doc "Possible values for the EncryptPEMBlock encryption algorithm.\n"
    :added "1.0"
    :tag "Int"
    :go "int(x509.PEMCipherAES128)"}
  PEMCipherAES128)

JOKER CONSTANT PEMCipherAES192 from crypto/x509/pem_decrypt.go:
(def
  ^{:doc "Possible values for the EncryptPEMBlock encryption algorithm.\n"
    :added "1.0"
    :tag "Int"
    :go "int(x509.PEMCipherAES192)"}
  PEMCipherAES192)

JOKER CONSTANT PEMCipherAES256 from crypto/x509/pem_decrypt.go:
(def
  ^{:doc "Possible values for the EncryptPEMBlock encryption algorithm.\n"
    :added "1.0"
    :tag "Int"
    :go "int(x509.PEMCipherAES256)"}
  PEMCipherAES256)

JOKER CONSTANT PEMCipherDES from crypto/x509/pem_decrypt.go:
(def
  ^{:doc "Possible values for the EncryptPEMBlock encryption algorithm.\n"
    :added "1.0"
    :tag "Int"
    :go "int(x509.PEMCipherDES)"}
  PEMCipherDES)

JOKER CONSTANT RSA from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.RSA)"}
  RSA)

JOKER CONSTANT SHA1WithRSA from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.SHA1WithRSA)"}
  SHA1WithRSA)

JOKER CONSTANT SHA256WithRSA from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.SHA256WithRSA)"}
  SHA256WithRSA)

JOKER CONSTANT SHA256WithRSAPSS from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.SHA256WithRSAPSS)"}
  SHA256WithRSAPSS)

JOKER CONSTANT SHA384WithRSA from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.SHA384WithRSA)"}
  SHA384WithRSA)

JOKER CONSTANT SHA384WithRSAPSS from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.SHA384WithRSAPSS)"}
  SHA384WithRSAPSS)

JOKER CONSTANT SHA512WithRSA from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.SHA512WithRSA)"}
  SHA512WithRSA)

JOKER CONSTANT SHA512WithRSAPSS from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.SHA512WithRSAPSS)"}
  SHA512WithRSAPSS)

JOKER CONSTANT TooManyConstraints from crypto/x509/verify.go:
(def
  ^{:doc "TooManyConstraints results when the number of comparison operations\nneeded to check a certificate exceeds the limit set by\nVerifyOptions.MaxConstraintComparisions. This limit exists to\nprevent pathological certificates can consuming excessive amounts of\nCPU time to verify.\n"
    :added "1.0"
    :tag "Int"
    :go "int(x509.TooManyConstraints)"}
  TooManyConstraints)

JOKER CONSTANT TooManyIntermediates from crypto/x509/verify.go:
(def
  ^{:doc "TooManyIntermediates results when a path length constraint is\nviolated.\n"
    :added "1.0"
    :tag "Int"
    :go "int(x509.TooManyIntermediates)"}
  TooManyIntermediates)

JOKER CONSTANT UnconstrainedName from crypto/x509/verify.go:
(def
  ^{:doc "UnconstrainedName results when a CA certificate contains permitted\nname constraints, but leaf certificate contains a name of an\nunsupported or unconstrained type.\n"
    :added "1.0"
    :tag "Int"
    :go "int(x509.UnconstrainedName)"}
  UnconstrainedName)

JOKER CONSTANT UnknownPublicKeyAlgorithm from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.UnknownPublicKeyAlgorithm)"}
  UnknownPublicKeyAlgorithm)

JOKER CONSTANT UnknownSignatureAlgorithm from crypto/x509/x509.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(x509.UnknownSignatureAlgorithm)"}
  UnknownSignatureAlgorithm)

JOKER VARIABLE ErrUnsupportedAlgorithm from crypto/x509/x509.go:
(def
  ^{:doc "ErrUnsupportedAlgorithm results from attempting to perform an operation that\ninvolves algorithms that are not currently implemented.\n"
    :added "1.0"
    :tag "Var"
    :go "x509.ErrUnsupportedAlgorithm"}
  ErrUnsupportedAlgorithm)

JOKER VARIABLE IncorrectPasswordError from crypto/x509/pem_decrypt.go:
(def
  ^{:doc "IncorrectPasswordError is returned when an incorrect password is detected.\n"
    :added "1.0"
    :tag "Var"
    :go "x509.IncorrectPasswordError"}
  IncorrectPasswordError)

JOKER TYPE crypto/x509.CertPool from crypto/x509/cert_pool.go:
(defn ^"GoObject" CertPool.
  "Constructor for x509.CertPool"
  {:added "1.0"
   :go "_ConstructCertPool(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.Certificate from crypto/x509/x509.go:
;; (defn ^"GoObject" Certificate.
;;   "Constructor for x509.Certificate"
;;   {:added "1.0"
;;    :go "_ConstructCertificate(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509.CertificateInvalidError from crypto/x509/verify.go:
;; (defn ^"GoObject" CertificateInvalidError.
;;   "Constructor for x509.CertificateInvalidError"
;;   {:added "1.0"
;;    :go "_ConstructCertificateInvalidError(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509.CertificateRequest from crypto/x509/x509.go:
;; (defn ^"GoObject" CertificateRequest.
;;   "Constructor for x509.CertificateRequest"
;;   {:added "1.0"
;;    :go "_ConstructCertificateRequest(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509.ConstraintViolationError from crypto/x509/x509.go:
(defn ^"GoObject" ConstraintViolationError.
  "Constructor for x509.ConstraintViolationError"
  {:added "1.0"
   :go "_ConstructConstraintViolationError(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.ExtKeyUsage from crypto/x509/x509.go:
(defn ^"GoObject" ExtKeyUsage.
  "Constructor for x509.ExtKeyUsage"
  {:added "1.0"
   :go "_ConstructExtKeyUsage(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.HostnameError from crypto/x509/verify.go:
;; (defn ^"GoObject" HostnameError.
;;   "Constructor for x509.HostnameError"
;;   {:added "1.0"
;;    :go "_ConstructHostnameError(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509.InsecureAlgorithmError from crypto/x509/x509.go:
;; (defn ^"GoObject" InsecureAlgorithmError.
;;   "Constructor for x509.InsecureAlgorithmError"
;;   {:added "1.0"
;;    :go "_ConstructInsecureAlgorithmError(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509.InvalidReason from crypto/x509/verify.go:
(defn ^"GoObject" InvalidReason.
  "Constructor for x509.InvalidReason"
  {:added "1.0"
   :go "_ConstructInvalidReason(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.KeyUsage from crypto/x509/x509.go:
(defn ^"GoObject" KeyUsage.
  "Constructor for x509.KeyUsage"
  {:added "1.0"
   :go "_ConstructKeyUsage(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.PEMCipher from crypto/x509/pem_decrypt.go:
(defn ^"GoObject" PEMCipher.
  "Constructor for x509.PEMCipher"
  {:added "1.0"
   :go "_ConstructPEMCipher(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.PublicKeyAlgorithm from crypto/x509/x509.go:
(defn ^"GoObject" PublicKeyAlgorithm.
  "Constructor for x509.PublicKeyAlgorithm"
  {:added "1.0"
   :go "_ConstructPublicKeyAlgorithm(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.SignatureAlgorithm from crypto/x509/x509.go:
(defn ^"GoObject" SignatureAlgorithm.
  "Constructor for x509.SignatureAlgorithm"
  {:added "1.0"
   :go "_ConstructSignatureAlgorithm(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.SystemRootsError from crypto/x509/verify.go:
(defn ^"GoObject" SystemRootsError.
  "Constructor for x509.SystemRootsError"
  {:added "1.0"
   :go "_ConstructSystemRootsError(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.UnhandledCriticalExtension from crypto/x509/x509.go:
(defn ^"GoObject" UnhandledCriticalExtension.
  "Constructor for x509.UnhandledCriticalExtension"
  {:added "1.0"
   :go "_ConstructUnhandledCriticalExtension(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.UnknownAuthorityError from crypto/x509/verify.go:
;; (defn ^"GoObject" UnknownAuthorityError.
;;   "Constructor for x509.UnknownAuthorityError"
;;   {:added "1.0"
;;    :go "_ConstructUnknownAuthorityError(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509.VerifyOptions from crypto/x509/verify.go:
;; (defn ^"GoObject" VerifyOptions.
;;   "Constructor for x509.VerifyOptions"
;;   {:added "1.0"
;;    :go "_ConstructVerifyOptions(_v)"}
;;   [^Object _v])

JOKER FUNC crypto/x509.CreateCertificate from crypto/x509/x509.go:
;; (defn CreateCertificate
;;   "CreateCertificate creates a new X.509v3 certificate based on a template.\nThe following members of template are used:\n\n - AuthorityKeyId\n - BasicConstraintsValid\n - CRLDistributionPoints\n - DNSNames\n - EmailAddresses\n - ExcludedDNSDomains\n - ExcludedEmailAddresses\n - ExcludedIPRanges\n - ExcludedURIDomains\n - ExtKeyUsage\n - ExtraExtensions\n - IsCA\n - IssuingCertificateURL\n - KeyUsage\n - MaxPathLen\n - MaxPathLenZero\n - NotAfter\n - NotBefore\n - OCSPServer\n - PermittedDNSDomains\n - PermittedDNSDomainsCritical\n - PermittedEmailAddresses\n - PermittedIPRanges\n - PermittedURIDomains\n - PolicyIdentifiers\n - SerialNumber\n - SignatureAlgorithm\n - Subject\n - SubjectKeyId\n - URIs\n - UnknownExtKeyUsage\n\nThe certificate is signed by parent. If parent is equal to template then the\ncertificate is self-signed. The parameter pub is the public key of the\nsignee and priv is the private key of the signer.\n\nThe returned slice is the certificate in DER encoding.\n\nAll keys types that are implemented via crypto.Signer are supported (This\nincludes *rsa.PublicKey and *ecdsa.PublicKey.)\n\nThe AuthorityKeyId will be taken from the SubjectKeyId of parent, if any,\nunless the resulting certificate is self-signed. Otherwise the value from\ntemplate will be used.\n\nGo input arguments: (rand io.Reader, template *Certificate, parent *Certificate, pub interface {}, priv interface {})\n\nGo return type: (cert []byte, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.x509/Certificate) template, ^(atom-of go.std.crypto.x509/Certificate) parent, ^<protocol-or-something> pub, ^<protocol-or-something> priv]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__createCertificate(*__rand, __template, __parent, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io/Reader __rand, ^x509/Certificate __template, ^x509/Certificate __parent, ^<protocol-or-something> __pub, ^<protocol-or-something> __priv])

JOKER FUNC crypto/x509.CreateCertificateRequest from crypto/x509/x509.go:
;; (defn CreateCertificateRequest
;;   "CreateCertificateRequest creates a new certificate request based on a\ntemplate. The following members of template are used:\n\n - SignatureAlgorithm\n - Subject\n - DNSNames\n - EmailAddresses\n - IPAddresses\n - URIs\n - ExtraExtensions\n - Attributes (deprecated)\n\npriv is the private key to sign the CSR with, and the corresponding public\nkey will be included in the CSR. It must implement crypto.Signer and its\nPublic() method must return a *rsa.PublicKey or a *ecdsa.PublicKey. (A\n*rsa.PrivateKey or *ecdsa.PrivateKey satisfies this.)\n\nThe returned slice is the certificate request in DER encoding.\n\nGo input arguments: (rand io.Reader, template *CertificateRequest, priv interface {})\n\nGo return type: (csr []byte, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.x509/CertificateRequest) template, ^<protocol-or-something> priv]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__createCertificateRequest(*__rand, __template, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io/Reader __rand, ^x509/CertificateRequest __template, ^<protocol-or-something> __priv])

JOKER FUNC crypto/x509.DecryptPEMBlock from crypto/x509/pem_decrypt.go:
;; (defn DecryptPEMBlock
;;   "DecryptPEMBlock takes a password encrypted PEM block and the password used to\nencrypt it and returns a slice of decrypted DER encoded bytes. It inspects\nthe DEK-Info header to determine the algorithm used for decryption. If no\nDEK-Info header is present, an error is returned. If an incorrect password\nis detected an IncorrectPasswordError is returned. Because of deficiencies\nin the encrypted-PEM format, it's not always possible to detect an incorrect\npassword. In these cases no error will be returned but the decrypted DER\nbytes will be random noise.\n\nGo input arguments: (b *pem.Block, password []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.encoding.pem/Block) b, ^(vector-of Int) password]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__decryptPEMBlock(__b, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__password)))"}
;;   [^pem/Block __b, ^Object __password])

JOKER FUNC crypto/x509.EncryptPEMBlock from crypto/x509/pem_decrypt.go:
;; (defn EncryptPEMBlock
;;   "EncryptPEMBlock returns a PEM block of the specified type holding the\ngiven DER-encoded data encrypted with the specified algorithm and\npassword.\n\nGo input arguments: (rand io.Reader, blockType string, data []byte, password []byte, alg PEMCipher)\n\nGo return type: (*encoding/pem.Block, error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^String blockType, ^(vector-of Int) data, ^(vector-of Int) password, ^go.std.crypto.x509/PEMCipher alg]\n\nJoker return type: [(atom-of go.std.encoding.pem/Block) Error]"
;;   {:added "1.0"
;;    :go "__encryptPEMBlock(*__rand, __blockType, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__password)), *__alg)"}
;;   [^io/Reader __rand, ^String __blockType, ^Object __data, ^Object __password, ^x509/PEMCipher __alg])

JOKER FUNC crypto/x509.IsEncryptedPEMBlock from crypto/x509/pem_decrypt.go:
;; (defn ^"Boolean" IsEncryptedPEMBlock
;;   "IsEncryptedPEMBlock returns if the PEM block is password encrypted.\n\nGo input arguments: (b *pem.Block)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.encoding.pem/Block) b]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "x509.IsEncryptedPEMBlock(__b)"}
;;   [^pem/Block __b])

JOKER FUNC crypto/x509.MarshalECPrivateKey from crypto/x509/sec1.go:
;; (defn MarshalECPrivateKey
;;   "MarshalECPrivateKey marshals an EC private key into ASN.1, DER format.\n\nGo input arguments: (key *ecdsa.PrivateKey)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.crypto.ecdsa/PrivateKey) key]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshalECPrivateKey(__key)"}
;;   [^ecdsa/PrivateKey __key])

JOKER FUNC crypto/x509.MarshalPKCS1PrivateKey from crypto/x509/pkcs1.go:
;; (defn MarshalPKCS1PrivateKey
;;   "MarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form.\n\nGo input arguments: (key *rsa.PrivateKey)\n\nGo return type: []byte\n\nJoker input arguments: [^(atom-of go.std.crypto.rsa/PrivateKey) key]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__marshalPKCS1PrivateKey(__key)"}
;;   [^rsa/PrivateKey __key])

JOKER FUNC crypto/x509.MarshalPKCS1PublicKey from crypto/x509/pkcs1.go:
;; (defn MarshalPKCS1PublicKey
;;   "MarshalPKCS1PublicKey converts an RSA public key to PKCS#1, ASN.1 DER form.\n\nGo input arguments: (key *rsa.PublicKey)\n\nGo return type: []byte\n\nJoker input arguments: [^(atom-of go.std.crypto.rsa/PublicKey) key]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__marshalPKCS1PublicKey(__key)"}
;;   [^rsa/PublicKey __key])

JOKER FUNC crypto/x509.MarshalPKCS8PrivateKey from crypto/x509/pkcs8.go:
;; (defn MarshalPKCS8PrivateKey
;;   "MarshalPKCS8PrivateKey converts a private key to PKCS#8 encoded form.\nThe following key types are supported: *rsa.PrivateKey, *ecdsa.PrivateKey.\nUnsupported key types result in an error.\n\nSee RFC 5208.\n\nGo input arguments: (key interface {})\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> key]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshalPKCS8PrivateKey(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> __key])

JOKER FUNC crypto/x509.MarshalPKIXPublicKey from crypto/x509/x509.go:
;; (defn MarshalPKIXPublicKey
;;   "MarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format.\n\nGo input arguments: (pub interface {})\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> pub]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshalPKIXPublicKey(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> __pub])

JOKER FUNC crypto/x509.NewCertPool from crypto/x509/cert_pool.go:
(defn NewCertPool
  "NewCertPool returns a new, empty CertPool.\n\nGo return type: *CertPool\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.crypto.x509/CertPool)"
  {:added "1.0"
   :go "__newCertPool()"}
  [])

JOKER FUNC crypto/x509.ParseCRL from crypto/x509/x509.go:
;; (defn ParseCRL
;;   "ParseCRL parses a CRL from the given bytes. It's often the case that PEM\nencoded CRLs will appear where they should be DER encoded, so this function\nwill transparently handle PEM encoding as long as there isn't any leading\ngarbage.\n\nGo input arguments: (crlBytes []byte)\n\nGo return type: (*crypto/x509/pkix.CertificateList, error)\n\nJoker input arguments: [^(vector-of Int) crlBytes]\n\nJoker return type: [(atom-of go.std.crypto.x509.pkix/CertificateList) Error]"
;;   {:added "1.0"
;;    :go "__parseCRL(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__crlBytes)))"}
;;   [^Object __crlBytes])

JOKER FUNC crypto/x509.ParseCertificate from crypto/x509/x509.go:
;; (defn ParseCertificate
;;   "ParseCertificate parses a single certificate from the given ASN.1 DER data.\n\nGo input arguments: (asn1Data []byte)\n\nGo return type: (*Certificate, error)\n\nJoker input arguments: [^(vector-of Int) asn1Data]\n\nJoker return type: [(atom-of go.std.crypto.x509/Certificate) Error]"
;;   {:added "1.0"
;;    :go "__parseCertificate(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__asn1Data)))"}
;;   [^Object __asn1Data])

JOKER FUNC crypto/x509.ParseCertificateRequest from crypto/x509/x509.go:
;; (defn ParseCertificateRequest
;;   "ParseCertificateRequest parses a single certificate request from the\ngiven ASN.1 DER data.\n\nGo input arguments: (asn1Data []byte)\n\nGo return type: (*CertificateRequest, error)\n\nJoker input arguments: [^(vector-of Int) asn1Data]\n\nJoker return type: [(atom-of go.std.crypto.x509/CertificateRequest) Error]"
;;   {:added "1.0"
;;    :go "__parseCertificateRequest(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__asn1Data)))"}
;;   [^Object __asn1Data])

JOKER FUNC crypto/x509.ParseCertificates from crypto/x509/x509.go:
;; (defn ParseCertificates
;;   "ParseCertificates parses one or more certificates from the given ASN.1 DER\ndata. The certificates must be concatenated with no intermediate padding.\n\nGo input arguments: (asn1Data []byte)\n\nGo return type: ([]*Certificate, error)\n\nJoker input arguments: [^(vector-of Int) asn1Data]\n\nJoker return type: [(vector-of (atom-of go.std.crypto.x509/Certificate)) Error]"
;;   {:added "1.0"
;;    :go "__parseCertificates(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__asn1Data)))"}
;;   [^Object __asn1Data])

JOKER FUNC crypto/x509.ParseDERCRL from crypto/x509/x509.go:
;; (defn ParseDERCRL
;;   "ParseDERCRL parses a DER encoded CRL from the given bytes.\n\nGo input arguments: (derBytes []byte)\n\nGo return type: (*crypto/x509/pkix.CertificateList, error)\n\nJoker input arguments: [^(vector-of Int) derBytes]\n\nJoker return type: [(atom-of go.std.crypto.x509.pkix/CertificateList) Error]"
;;   {:added "1.0"
;;    :go "__parseDERCRL(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__derBytes)))"}
;;   [^Object __derBytes])

JOKER FUNC crypto/x509.ParseECPrivateKey from crypto/x509/sec1.go:
;; (defn ParseECPrivateKey
;;   "ParseECPrivateKey parses an ASN.1 Elliptic Curve Private Key Structure.\n\nGo input arguments: (der []byte)\n\nGo return type: (*crypto/ecdsa.PrivateKey, error)\n\nJoker input arguments: [^(vector-of Int) der]\n\nJoker return type: [(atom-of go.std.crypto.ecdsa/PrivateKey) Error]"
;;   {:added "1.0"
;;    :go "__parseECPrivateKey(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__der)))"}
;;   [^Object __der])

JOKER FUNC crypto/x509.ParsePKCS1PrivateKey from crypto/x509/pkcs1.go:
;; (defn ParsePKCS1PrivateKey
;;   "ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form.\n\nGo input arguments: (der []byte)\n\nGo return type: (*crypto/rsa.PrivateKey, error)\n\nJoker input arguments: [^(vector-of Int) der]\n\nJoker return type: [(atom-of go.std.crypto.rsa/PrivateKey) Error]"
;;   {:added "1.0"
;;    :go "__parsePKCS1PrivateKey(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__der)))"}
;;   [^Object __der])

JOKER FUNC crypto/x509.ParsePKCS1PublicKey from crypto/x509/pkcs1.go:
;; (defn ParsePKCS1PublicKey
;;   "ParsePKCS1PublicKey parses a PKCS#1 public key in ASN.1 DER form.\n\nGo input arguments: (der []byte)\n\nGo return type: (*crypto/rsa.PublicKey, error)\n\nJoker input arguments: [^(vector-of Int) der]\n\nJoker return type: [(atom-of go.std.crypto.rsa/PublicKey) Error]"
;;   {:added "1.0"
;;    :go "__parsePKCS1PublicKey(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__der)))"}
;;   [^Object __der])

JOKER FUNC crypto/x509.ParsePKCS8PrivateKey from crypto/x509/pkcs8.go:
;; (defn ParsePKCS8PrivateKey
;;   "ParsePKCS8PrivateKey parses an unencrypted, PKCS#8 private key.\nSee RFC 5208.\n\nGo input arguments: (der []byte)\n\nGo return type: (key ..., err error)\n\nJoker input arguments: [^(vector-of Int) der]\n\nJoker return type: [ABEND883(post.go: unrecognized Expr type *ast.InterfaceType at: /usr/local/go/src/crypto/x509/pkcs8.go:28:44) Error]"
;;   {:added "1.0"
;;    :go "__parsePKCS8PrivateKey(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__der)))"}
;;   [^Object __der])

JOKER FUNC crypto/x509.ParsePKIXPublicKey from crypto/x509/x509.go:
;; (defn ParsePKIXPublicKey
;;   "ParsePKIXPublicKey parses a DER encoded public key. These values are\ntypically found in PEM blocks with \"BEGIN PUBLIC KEY\".\n\nSupported key types include RSA, DSA, and ECDSA. Unknown key\ntypes result in an error.\n\nOn success, pub will be of type *rsa.PublicKey, *dsa.PublicKey,\nor *ecdsa.PublicKey.\n\nGo input arguments: (derBytes []byte)\n\nGo return type: (pub ..., err error)\n\nJoker input arguments: [^(vector-of Int) derBytes]\n\nJoker return type: [ABEND883(post.go: unrecognized Expr type *ast.InterfaceType at: /usr/local/go/src/crypto/x509/x509.go:54:47) Error]"
;;   {:added "1.0"
;;    :go "__parsePKIXPublicKey(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__derBytes)))"}
;;   [^Object __derBytes])

JOKER FUNC crypto/x509.SystemCertPool from crypto/x509/cert_pool.go:
(defn SystemCertPool
  "SystemCertPool returns a copy of the system cert pool.\n\nAny mutations to the returned pool are not written to disk and do\nnot affect any other pool returned by SystemCertPool.\n\nNew changes in the system cert pool might not be reflected\nin subsequent calls.\n\nGo return type: (*CertPool, error)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.crypto.x509/CertPool) Error]"
  {:added "1.0"
   :go "__systemCertPool()"}
  [])

JOKER TYPE go.std.crypto.x509/CertPool:
(def
  ^{:doc "CertPool is a set of certificates.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CertPool"}
  CertPool)

JOKER TYPE go.std.crypto.x509/Certificate:
(def
  ^{:doc "A Certificate represents an X.509 certificate.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Certificate"}
  Certificate)

JOKER TYPE go.std.crypto.x509/CertificateInvalidError:
(def
  ^{:doc "CertificateInvalidError results when an odd error occurs. Users of this\nlibrary probably want to handle all these errors uniformly.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CertificateInvalidError"}
  CertificateInvalidError)

JOKER TYPE go.std.crypto.x509/CertificateRequest:
(def
  ^{:doc "CertificateRequest represents a PKCS #10, certificate signature request.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CertificateRequest"}
  CertificateRequest)

JOKER TYPE go.std.crypto.x509/ConstraintViolationError:
(def
  ^{:doc "ConstraintViolationError results when a requested usage is not permitted by\na certificate. For example: checking a signature when the public key isn't a\ncertificate signing key.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ConstraintViolationError"}
  ConstraintViolationError)

JOKER TYPE go.std.crypto.x509/ExtKeyUsage:
(def
  ^{:doc "ExtKeyUsage represents an extended set of actions that are valid for a given key.\nEach of the ExtKeyUsage* constants define a unique action.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ExtKeyUsage"}
  ExtKeyUsage)

JOKER TYPE go.std.crypto.x509/HostnameError:
(def
  ^{:doc "HostnameError results when the set of authorized names doesn't match the\nrequested name.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_HostnameError"}
  HostnameError)

JOKER TYPE go.std.crypto.x509/InsecureAlgorithmError:
(def
  ^{:doc "An InsecureAlgorithmError\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_InsecureAlgorithmError"}
  InsecureAlgorithmError)

JOKER TYPE go.std.crypto.x509/InvalidReason:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_InvalidReason"}
  InvalidReason)

JOKER TYPE go.std.crypto.x509/KeyUsage:
(def
  ^{:doc "KeyUsage represents the set of actions that are valid for a given key. It's\na bitmap of the KeyUsage* constants.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_KeyUsage"}
  KeyUsage)

JOKER TYPE go.std.crypto.x509/PEMCipher:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PEMCipher"}
  PEMCipher)

JOKER TYPE go.std.crypto.x509/PublicKeyAlgorithm:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PublicKeyAlgorithm"}
  PublicKeyAlgorithm)

JOKER TYPE go.std.crypto.x509/SignatureAlgorithm:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_SignatureAlgorithm"}
  SignatureAlgorithm)

JOKER TYPE go.std.crypto.x509/SystemRootsError:
(def
  ^{:doc "SystemRootsError results when we fail to load the system root certificates.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SystemRootsError"}
  SystemRootsError)

JOKER TYPE go.std.crypto.x509/UnhandledCriticalExtension:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_UnhandledCriticalExtension"}
  UnhandledCriticalExtension)

JOKER TYPE go.std.crypto.x509/UnknownAuthorityError:
(def
  ^{:doc "UnknownAuthorityError results when the certificate issuer is unknown\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnknownAuthorityError"}
  UnknownAuthorityError)

JOKER TYPE go.std.crypto.x509/VerifyOptions:
(def
  ^{:doc "VerifyOptions contains parameters for Certificate.Verify. It's a structure\nbecause other PKIX verification APIs have ended up needing many options.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_VerifyOptions"}
  VerifyOptions)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["crypto/x509"]
    :doc "Provides a low-level interface to the crypto/x509 package.\n\nPackage x509 parses X.509-encoded keys and certificates.\n\nOn UNIX systems the environment variables SSL_CERT_FILE and SSL_CERT_DIR\ncan be used to override the system default locations for the SSL certificate\nfile and SSL certificate files directory, respectively.\n"
    :empty false}
  go.std.crypto.x509)
JOKER TYPE crypto/x509/pkix.AlgorithmIdentifier from crypto/x509/pkix/pkix.go:
;; (defn ^"GoObject" AlgorithmIdentifier.
;;   "Constructor for pkix.AlgorithmIdentifier"
;;   {:added "1.0"
;;    :go "_ConstructAlgorithmIdentifier(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509/pkix.AttributeTypeAndValue from crypto/x509/pkix/pkix.go:
;; (defn ^"GoObject" AttributeTypeAndValue.
;;   "Constructor for pkix.AttributeTypeAndValue"
;;   {:added "1.0"
;;    :go "_ConstructAttributeTypeAndValue(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509/pkix.AttributeTypeAndValueSET from crypto/x509/pkix/pkix.go:
;; (defn ^"GoObject" AttributeTypeAndValueSET.
;;   "Constructor for pkix.AttributeTypeAndValueSET"
;;   {:added "1.0"
;;    :go "_ConstructAttributeTypeAndValueSET(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509/pkix.CertificateList from crypto/x509/pkix/pkix.go:
;; (defn ^"GoObject" CertificateList.
;;   "Constructor for pkix.CertificateList"
;;   {:added "1.0"
;;    :go "_ConstructCertificateList(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509/pkix.Extension from crypto/x509/pkix/pkix.go:
;; (defn ^"GoObject" Extension.
;;   "Constructor for pkix.Extension"
;;   {:added "1.0"
;;    :go "_ConstructExtension(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509/pkix.Name from crypto/x509/pkix/pkix.go:
;; (defn ^"GoObject" Name.
;;   "Constructor for pkix.Name"
;;   {:added "1.0"
;;    :go "_ConstructName(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509/pkix.RDNSequence from crypto/x509/pkix/pkix.go:
;; (defn ^"GoObject" RDNSequence.
;;   "Constructor for pkix.RDNSequence"
;;   {:added "1.0"
;;    :go "_ConstructRDNSequence(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509/pkix.RelativeDistinguishedNameSET from crypto/x509/pkix/pkix.go:
;; (defn ^"GoObject" RelativeDistinguishedNameSET.
;;   "Constructor for pkix.RelativeDistinguishedNameSET"
;;   {:added "1.0"
;;    :go "_ConstructRelativeDistinguishedNameSET(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509/pkix.RevokedCertificate from crypto/x509/pkix/pkix.go:
;; (defn ^"GoObject" RevokedCertificate.
;;   "Constructor for pkix.RevokedCertificate"
;;   {:added "1.0"
;;    :go "_ConstructRevokedCertificate(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509/pkix.TBSCertificateList from crypto/x509/pkix/pkix.go:
;; (defn ^"GoObject" TBSCertificateList.
;;   "Constructor for pkix.TBSCertificateList"
;;   {:added "1.0"
;;    :go "_ConstructTBSCertificateList(_v)"}
;;   [^Object _v])

JOKER TYPE go.std.crypto.x509.pkix/AlgorithmIdentifier:
(def
  ^{:doc "AlgorithmIdentifier represents the ASN.1 structure of the same name. See RFC\n5280, section 4.1.1.2.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_AlgorithmIdentifier"}
  AlgorithmIdentifier)

JOKER TYPE go.std.crypto.x509.pkix/AttributeTypeAndValue:
(def
  ^{:doc "AttributeTypeAndValue mirrors the ASN.1 structure of the same name in\nRFC 5280, Section 4.1.2.4.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_AttributeTypeAndValue"}
  AttributeTypeAndValue)

JOKER TYPE go.std.crypto.x509.pkix/AttributeTypeAndValueSET:
(def
  ^{:doc "AttributeTypeAndValueSET represents a set of ASN.1 sequences of\nAttributeTypeAndValue sequences from RFC 2986 (PKCS #10).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_AttributeTypeAndValueSET"}
  AttributeTypeAndValueSET)

JOKER TYPE go.std.crypto.x509.pkix/CertificateList:
(def
  ^{:doc "CertificateList represents the ASN.1 structure of the same name. See RFC\n5280, section 5.1. Use Certificate.CheckCRLSignature to verify the\nsignature.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CertificateList"}
  CertificateList)

JOKER TYPE go.std.crypto.x509.pkix/Extension:
(def
  ^{:doc "Extension represents the ASN.1 structure of the same name. See RFC\n5280, section 4.2.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Extension"}
  Extension)

JOKER TYPE go.std.crypto.x509.pkix/Name:
(def
  ^{:doc "Name represents an X.509 distinguished name. This only includes the common\nelements of a DN. When parsing, all elements are stored in Names and\nnon-standard elements can be extracted from there. When marshaling, elements\nin ExtraNames are appended and override other values with the same OID.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Name"}
  Name)

JOKER TYPE go.std.crypto.x509.pkix/RDNSequence:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_RDNSequence"}
  RDNSequence)

JOKER TYPE go.std.crypto.x509.pkix/RelativeDistinguishedNameSET:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_RelativeDistinguishedNameSET"}
  RelativeDistinguishedNameSET)

JOKER TYPE go.std.crypto.x509.pkix/RevokedCertificate:
(def
  ^{:doc "RevokedCertificate represents the ASN.1 structure of the same name. See RFC\n5280, section 5.1.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RevokedCertificate"}
  RevokedCertificate)

JOKER TYPE go.std.crypto.x509.pkix/TBSCertificateList:
(def
  ^{:doc "TBSCertificateList represents the ASN.1 structure of the same name. See RFC\n5280, section 5.1.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TBSCertificateList"}
  TBSCertificateList)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/x509/pkix package.\n\nPackage pkix contains shared, low level structures used for ASN.1 parsing\nand serialization of X.509 certificates, CRL and OCSP.\n"
    :empty false}
  go.std.crypto.x509.pkix)
JOKER CONSTANT LevelDefault from database/sql/sql.go:
(def
  ^{:doc "Various isolation levels that drivers may support in BeginTx.\nIf a driver does not support a given isolation level an error may be returned.\n\nSee https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels.\n"
    :added "1.0"
    :tag "Int"
    :go "int(sql.LevelDefault)"}
  LevelDefault)

JOKER CONSTANT LevelLinearizable from database/sql/sql.go:
(def
  ^{:doc "Various isolation levels that drivers may support in BeginTx.\nIf a driver does not support a given isolation level an error may be returned.\n\nSee https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels.\n"
    :added "1.0"
    :tag "Int"
    :go "int(sql.LevelLinearizable)"}
  LevelLinearizable)

JOKER CONSTANT LevelReadCommitted from database/sql/sql.go:
(def
  ^{:doc "Various isolation levels that drivers may support in BeginTx.\nIf a driver does not support a given isolation level an error may be returned.\n\nSee https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels.\n"
    :added "1.0"
    :tag "Int"
    :go "int(sql.LevelReadCommitted)"}
  LevelReadCommitted)

JOKER CONSTANT LevelReadUncommitted from database/sql/sql.go:
(def
  ^{:doc "Various isolation levels that drivers may support in BeginTx.\nIf a driver does not support a given isolation level an error may be returned.\n\nSee https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels.\n"
    :added "1.0"
    :tag "Int"
    :go "int(sql.LevelReadUncommitted)"}
  LevelReadUncommitted)

JOKER CONSTANT LevelRepeatableRead from database/sql/sql.go:
(def
  ^{:doc "Various isolation levels that drivers may support in BeginTx.\nIf a driver does not support a given isolation level an error may be returned.\n\nSee https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels.\n"
    :added "1.0"
    :tag "Int"
    :go "int(sql.LevelRepeatableRead)"}
  LevelRepeatableRead)

JOKER CONSTANT LevelSerializable from database/sql/sql.go:
(def
  ^{:doc "Various isolation levels that drivers may support in BeginTx.\nIf a driver does not support a given isolation level an error may be returned.\n\nSee https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels.\n"
    :added "1.0"
    :tag "Int"
    :go "int(sql.LevelSerializable)"}
  LevelSerializable)

JOKER CONSTANT LevelSnapshot from database/sql/sql.go:
(def
  ^{:doc "Various isolation levels that drivers may support in BeginTx.\nIf a driver does not support a given isolation level an error may be returned.\n\nSee https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels.\n"
    :added "1.0"
    :tag "Int"
    :go "int(sql.LevelSnapshot)"}
  LevelSnapshot)

JOKER CONSTANT LevelWriteCommitted from database/sql/sql.go:
(def
  ^{:doc "Various isolation levels that drivers may support in BeginTx.\nIf a driver does not support a given isolation level an error may be returned.\n\nSee https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels.\n"
    :added "1.0"
    :tag "Int"
    :go "int(sql.LevelWriteCommitted)"}
  LevelWriteCommitted)

JOKER VARIABLE ErrConnDone from database/sql/sql.go:
(def
  ^{:doc "ErrConnDone is returned by any operation that is performed on a connection\nthat has already been returned to the connection pool.\n"
    :added "1.0"
    :tag "Var"
    :go "sql.ErrConnDone"}
  ErrConnDone)

JOKER VARIABLE ErrNoRows from database/sql/sql.go:
(def
  ^{:doc "ErrNoRows is returned by Scan when QueryRow doesn't return a\nrow. In such a case, QueryRow returns a placeholder *Row value that\ndefers this error until a Scan.\n"
    :added "1.0"
    :tag "Var"
    :go "sql.ErrNoRows"}
  ErrNoRows)

JOKER VARIABLE ErrTxDone from database/sql/sql.go:
(def
  ^{:doc "ErrTxDone is returned by any operation that is performed on a transaction\nthat has already been committed or rolled back.\n"
    :added "1.0"
    :tag "Var"
    :go "sql.ErrTxDone"}
  ErrTxDone)

JOKER TYPE database/sql.ColumnType from database/sql/sql.go:
(defn ^"GoObject" ColumnType.
  "Constructor for sql.ColumnType"
  {:added "1.0"
   :go "_ConstructColumnType(_v)"}
  [^Object _v])

JOKER TYPE database/sql.Conn from database/sql/sql.go:
(defn ^"GoObject" Conn.
  "Constructor for sql.Conn"
  {:added "1.0"
   :go "_ConstructConn(_v)"}
  [^Object _v])

JOKER TYPE database/sql.DB from database/sql/sql.go:
(defn ^"GoObject" DB.
  "Constructor for sql.DB"
  {:added "1.0"
   :go "_ConstructDB(_v)"}
  [^Object _v])

JOKER TYPE database/sql.DBStats from database/sql/sql.go:
;; (defn ^"GoObject" DBStats.
;;   "Constructor for sql.DBStats"
;;   {:added "1.0"
;;    :go "_ConstructDBStats(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql.IsolationLevel from database/sql/sql.go:
(defn ^"GoObject" IsolationLevel.
  "Constructor for sql.IsolationLevel"
  {:added "1.0"
   :go "_ConstructIsolationLevel(_v)"}
  [^Object _v])

JOKER TYPE database/sql.NamedArg from database/sql/sql.go:
;; (defn ^"GoObject" NamedArg.
;;   "Constructor for sql.NamedArg"
;;   {:added "1.0"
;;    :go "_ConstructNamedArg(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql.NullBool from database/sql/sql.go:
(defn ^"GoObject" NullBool.
  "Constructor for sql.NullBool"
  {:added "1.0"
   :go "_ConstructNullBool(_v)"}
  [^Object _v])

JOKER TYPE database/sql.NullFloat64 from database/sql/sql.go:
(defn ^"GoObject" NullFloat64.
  "Constructor for sql.NullFloat64"
  {:added "1.0"
   :go "_ConstructNullFloat64(_v)"}
  [^Object _v])

JOKER TYPE database/sql.NullInt64 from database/sql/sql.go:
(defn ^"GoObject" NullInt64.
  "Constructor for sql.NullInt64"
  {:added "1.0"
   :go "_ConstructNullInt64(_v)"}
  [^Object _v])

JOKER TYPE database/sql.NullString from database/sql/sql.go:
(defn ^"GoObject" NullString.
  "Constructor for sql.NullString"
  {:added "1.0"
   :go "_ConstructNullString(_v)"}
  [^Object _v])

JOKER TYPE database/sql.Out from database/sql/sql.go:
;; (defn ^"GoObject" Out.
;;   "Constructor for sql.Out"
;;   {:added "1.0"
;;    :go "_ConstructOut(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql.RawBytes from database/sql/sql.go:
;; (defn ^"GoObject" RawBytes.
;;   "Constructor for sql.RawBytes"
;;   {:added "1.0"
;;    :go "_ConstructRawBytes(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql.Result from database/sql/sql.go:
;; (defn ^"GoObject" Result.
;;   "Constructor for sql.Result"
;;   {:added "1.0"
;;    :go "_ConstructResult(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql.Row from database/sql/sql.go:
(defn ^"GoObject" Row.
  "Constructor for sql.Row"
  {:added "1.0"
   :go "_ConstructRow(_v)"}
  [^Object _v])

JOKER TYPE database/sql.Rows from database/sql/sql.go:
(defn ^"GoObject" Rows.
  "Constructor for sql.Rows"
  {:added "1.0"
   :go "_ConstructRows(_v)"}
  [^Object _v])

JOKER TYPE database/sql.Scanner from database/sql/sql.go:
;; (defn ^"GoObject" Scanner.
;;   "Constructor for sql.Scanner"
;;   {:added "1.0"
;;    :go "_ConstructScanner(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql.Stmt from database/sql/sql.go:
(defn ^"GoObject" Stmt.
  "Constructor for sql.Stmt"
  {:added "1.0"
   :go "_ConstructStmt(_v)"}
  [^Object _v])

JOKER TYPE database/sql.Tx from database/sql/sql.go:
(defn ^"GoObject" Tx.
  "Constructor for sql.Tx"
  {:added "1.0"
   :go "_ConstructTx(_v)"}
  [^Object _v])

JOKER TYPE database/sql.TxOptions from database/sql/sql.go:
(defn ^"GoObject" TxOptions.
  "Constructor for sql.TxOptions"
  {:added "1.0"
   :go "_ConstructTxOptions(_v)"}
  [^Object _v])

JOKER FUNC database/sql.Drivers from database/sql/sql.go:
(defn Drivers
  "Drivers returns a sorted list of the names of the registered drivers.\n\nGo return type: []string\n\nJoker input arguments: []\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__drivers()"}
  [])

JOKER FUNC database/sql.Named from database/sql/sql.go:
;; (defn Named
;;   "Named provides a more concise way to create NamedArg values.\n\nExample usage:\n\n    db.ExecContext(ctx, `\n        delete from Invoice\n        where\n            TimeCreated < @end\n            and TimeCreated >= @start;`,\n        sql.Named(\"start\", startTime),\n        sql.Named(\"end\", endTime),\n    )\n\nGo input arguments: (name string, value interface {})\n\nGo return type: NamedArg\n\nJoker input arguments: [^String name, ^<protocol-or-something> value]\n\nJoker return type: go.std.database.sql/NamedArg"
;;   {:added "1.0"
;;    :go "__named(__name, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^String __name, ^<protocol-or-something> __value])

JOKER FUNC database/sql.Open from database/sql/sql.go:
(defn Open
  "Open opens a database specified by its database driver name and a\ndriver-specific data source name, usually consisting of at least a\ndatabase name and connection information.\n\nMost users will open a database via a driver-specific connection\nhelper function that returns a *DB. No database drivers are included\nin the Go standard library. See https://golang.org/s/sqldrivers for\na list of third-party drivers.\n\nOpen may just validate its arguments without creating a connection\nto the database. To verify that the data source name is valid, call\nPing.\n\nThe returned DB is safe for concurrent use by multiple goroutines\nand maintains its own pool of idle connections. Thus, the Open\nfunction should be called just once. It is rarely necessary to\nclose a DB.\n\nGo input arguments: (driverName string, dataSourceName string)\n\nGo return type: (*DB, error)\n\nJoker input arguments: [^String driverName, ^String dataSourceName]\n\nJoker return type: [(atom-of go.std.database.sql/DB) Error]"
  {:added "1.0"
   :go "__open(__driverName, __dataSourceName)"}
  [^String __driverName, ^String __dataSourceName])

JOKER FUNC database/sql.OpenDB from database/sql/sql.go:
;; (defn OpenDB
;;   "OpenDB opens a database using a Connector, allowing drivers to\nbypass a string based data source name.\n\nMost users will open a database via a driver-specific connection\nhelper function that returns a *DB. No database drivers are included\nin the Go standard library. See https://golang.org/s/sqldrivers for\na list of third-party drivers.\n\nOpenDB may just validate its arguments without creating a connection\nto the database. To verify that the data source name is valid, call\nPing.\n\nThe returned DB is safe for concurrent use by multiple goroutines\nand maintains its own pool of idle connections. Thus, the OpenDB\nfunction should be called just once. It is rarely necessary to\nclose a DB.\n\nGo input arguments: (c driver.Connector)\n\nGo return type: *DB\n\nJoker input arguments: [^go.std.database.sql.driver/Connector c]\n\nJoker return type: (atom-of go.std.database.sql/DB)"
;;   {:added "1.0"
;;    :go "__openDB(*__c)"}
;;   [^driver/Connector __c])

JOKER FUNC database/sql.Register from database/sql/sql.go:
;; (defn Register
;;   "Register makes a database driver available by the provided name.\nIf Register is called twice with the same name or if driver is nil,\nit panics.\n\nGo input arguments: (name string, driver driver.Driver)\n\nJoker input arguments: [^String name, ^go.std.database.sql.driver/Driver driver]"
;;   {:added "1.0"
;;    :go "__register(__name, *__driver)"}
;;   [^String __name, ^driver/Driver __driver])

JOKER TYPE go.std.database.sql/ColumnType:
(def
  ^{:doc "ColumnType contains the name and type of a column.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ColumnType"}
  ColumnType)

JOKER TYPE go.std.database.sql/Conn:
(def
  ^{:doc "Conn represents a single database connection rather than a pool of database\nconnections. Prefer running queries from DB unless there is a specific\nneed for a continuous single database connection.\n\nA Conn must call Close to return the connection to the database pool\nand may do so concurrently with a running query.\n\nAfter a call to Close, all operations on the\nconnection fail with ErrConnDone.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Conn"}
  Conn)

JOKER TYPE go.std.database.sql/DB:
(def
  ^{:doc "DB is a database handle representing a pool of zero or more\nunderlying connections. It's safe for concurrent use by multiple\ngoroutines.\n\nThe sql package creates and frees connections automatically; it\nalso maintains a free pool of idle connections. If the database has\na concept of per-connection state, such state can be reliably observed\nwithin a transaction (Tx) or connection (Conn). Once DB.Begin is called, the\nreturned Tx is bound to a single connection. Once Commit or\nRollback is called on the transaction, that transaction's\nconnection is returned to DB's idle connection pool. The pool size\ncan be controlled with SetMaxIdleConns.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DB"}
  DB)

JOKER TYPE go.std.database.sql/DBStats:
(def
  ^{:doc "DBStats contains database statistics.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DBStats"}
  DBStats)

JOKER TYPE go.std.database.sql/IsolationLevel:
(def
  ^{:doc "IsolationLevel is the transaction isolation level used in TxOptions.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IsolationLevel"}
  IsolationLevel)

JOKER TYPE go.std.database.sql/NamedArg:
(def
  ^{:doc "A NamedArg is a named argument. NamedArg values may be used as\narguments to Query or Exec and bind to the corresponding named\nparameter in the SQL statement.\n\nFor a more concise way to create NamedArg values, see\nthe Named function.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NamedArg"}
  NamedArg)

JOKER TYPE go.std.database.sql/NullBool:
(def
  ^{:doc "NullBool represents a bool that may be null.\nNullBool implements the Scanner interface so\nit can be used as a scan destination, similar to NullString.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NullBool"}
  NullBool)

JOKER TYPE go.std.database.sql/NullFloat64:
(def
  ^{:doc "NullFloat64 represents a float64 that may be null.\nNullFloat64 implements the Scanner interface so\nit can be used as a scan destination, similar to NullString.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NullFloat64"}
  NullFloat64)

JOKER TYPE go.std.database.sql/NullInt64:
(def
  ^{:doc "NullInt64 represents an int64 that may be null.\nNullInt64 implements the Scanner interface so\nit can be used as a scan destination, similar to NullString.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NullInt64"}
  NullInt64)

JOKER TYPE go.std.database.sql/NullString:
(def
  ^{:doc "NullString represents a string that may be null.\nNullString implements the Scanner interface so\nit can be used as a scan destination:\n\n var s NullString\n err := db.QueryRow(\"SELECT name FROM foo WHERE id=?\", id).Scan(&s)\n ...\n if s.Valid {\n    // use s.String\n } else {\n    // NULL value\n }\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NullString"}
  NullString)

JOKER TYPE go.std.database.sql/Out:
(def
  ^{:doc "Out may be used to retrieve OUTPUT value parameters from stored procedures.\n\nNot all drivers and databases support OUTPUT value parameters.\n\nExample usage:\n\n  var outArg string\n  _, err := db.ExecContext(ctx, \"ProcName\", sql.Named(\"Arg1\", sql.Out{Dest: &outArg}))\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Out"}
  Out)

JOKER TYPE go.std.database.sql/RawBytes:
(def
  ^{:doc "RawBytes is a byte slice that holds a reference to memory owned by\nthe database itself. After a Scan into a RawBytes, the slice is only\nvalid until the next call to Next, Scan, or Close.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RawBytes"}
  RawBytes)

JOKER TYPE go.std.database.sql/Result:
(def
  ^{:doc "A Result summarizes an executed SQL command.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Result"}
  Result)

JOKER TYPE go.std.database.sql/Row:
(def
  ^{:doc "Row is the result of calling QueryRow to select a single row.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Row"}
  Row)

JOKER TYPE go.std.database.sql/Rows:
(def
  ^{:doc "Rows is the result of a query. Its cursor starts before the first row\nof the result set. Use Next to advance from row to row.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Rows"}
  Rows)

JOKER TYPE go.std.database.sql/Scanner:
(def
  ^{:doc "Scanner is an interface used by Scan.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Scanner"}
  Scanner)

JOKER TYPE go.std.database.sql/Stmt:
(def
  ^{:doc "Stmt is a prepared statement.\nA Stmt is safe for concurrent use by multiple goroutines.\n\nIf a Stmt is prepared on a Tx or Conn, it will be bound to a single\nunderlying connection forever. If the Tx or Conn closes, the Stmt will\nbecome unusable and all operations will return an error.\nIf a Stmt is prepared on a DB, it will remain usable for the lifetime of the\nDB. When the Stmt needs to execute on a new underlying connection, it will\nprepare itself on the new connection automatically.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Stmt"}
  Stmt)

JOKER TYPE go.std.database.sql/Tx:
(def
  ^{:doc "Tx is an in-progress database transaction.\n\nA transaction must end with a call to Commit or Rollback.\n\nAfter a call to Commit or Rollback, all operations on the\ntransaction fail with ErrTxDone.\n\nThe statements prepared for a transaction by calling\nthe transaction's Prepare or Stmt methods are closed\nby the call to Commit or Rollback.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Tx"}
  Tx)

JOKER TYPE go.std.database.sql/TxOptions:
(def
  ^{:doc "TxOptions holds the transaction options to be used in DB.BeginTx.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TxOptions"}
  TxOptions)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["database/sql"]
    :doc "Provides a low-level interface to the database/sql package.\n\nPackage sql provides a generic interface around SQL (or SQL-like)\ndatabases.\n\nThe sql package must be used in conjunction with a database driver.\nSee https://golang.org/s/sqldrivers for a list of drivers.\n\nDrivers that do not support context cancelation will not return until\nafter the query is completed.\n\nFor usage examples, see the wiki page at\nhttps://golang.org/s/sqlwiki.\n"
    :empty false}
  go.std.database.sql)
JOKER VARIABLE Bool from database/sql/driver/types.go:
(def
  ^{:doc "Bool is a ValueConverter that converts input values to bools.\n\nThe conversion rules are:\n - booleans are returned unchanged\n - for integer types,\n      1 is true\n      0 is false,\n      other integers are an error\n - for strings and []byte, same rules as strconv.ParseBool\n - all other types are an error\n"
    :added "1.0"
    :tag "Var"
    :go "driver.Bool"}
  Bool)

JOKER VARIABLE DefaultParameterConverter from database/sql/driver/types.go:
(def
  ^{:doc "DefaultParameterConverter is the default implementation of\nValueConverter that's used when a Stmt doesn't implement\nColumnConverter.\n\nDefaultParameterConverter returns its argument directly if\nIsValue(arg). Otherwise, if the argument implements Valuer, its\nValue method is used to return a Value. As a fallback, the provided\nargument's underlying type is used to convert it to a Value:\nunderlying integer types are converted to int64, floats to float64,\nbool, string, and []byte to themselves. If the argument is a nil\npointer, ConvertValue returns a nil Value. If the argument is a\nnon-nil pointer, it is dereferenced and ConvertValue is called\nrecursively. Other types are an error.\n"
    :added "1.0"
    :tag "Var"
    :go "driver.DefaultParameterConverter"}
  DefaultParameterConverter)

JOKER VARIABLE ErrBadConn from database/sql/driver/driver.go:
(def
  ^{:doc "ErrBadConn should be returned by a driver to signal to the sql\npackage that a driver.Conn is in a bad state (such as the server\nhaving earlier closed the connection) and the sql package should\nretry on a new connection.\n\nTo prevent duplicate operations, ErrBadConn should NOT be returned\nif there's a possibility that the database server might have\nperformed the operation. Even if the server sends back an error,\nyou shouldn't return ErrBadConn.\n"
    :added "1.0"
    :tag "Var"
    :go "driver.ErrBadConn"}
  ErrBadConn)

JOKER VARIABLE ErrRemoveArgument from database/sql/driver/driver.go:
(def
  ^{:doc "ErrRemoveArgument may be returned from NamedValueChecker to instruct the\nsql package to not pass the argument to the driver query interface.\nReturn when accepting query specific options or structures that aren't\nSQL query arguments.\n"
    :added "1.0"
    :tag "Var"
    :go "driver.ErrRemoveArgument"}
  ErrRemoveArgument)

JOKER VARIABLE ErrSkip from database/sql/driver/driver.go:
(def
  ^{:doc "ErrSkip may be returned by some optional interfaces' methods to\nindicate at runtime that the fast path is unavailable and the sql\npackage should continue as if the optional interface was not\nimplemented. ErrSkip is only supported where explicitly\ndocumented.\n"
    :added "1.0"
    :tag "Var"
    :go "driver.ErrSkip"}
  ErrSkip)

JOKER VARIABLE Int32 from database/sql/driver/types.go:
(def
  ^{:doc "Int32 is a ValueConverter that converts input values to int64,\nrespecting the limits of an int32 value.\n"
    :added "1.0"
    :tag "Var"
    :go "driver.Int32"}
  Int32)

JOKER VARIABLE ResultNoRows from database/sql/driver/driver.go:
(def
  ^{:doc "ResultNoRows is a pre-defined Result for drivers to return when a DDL\ncommand (such as a CREATE TABLE) succeeds. It returns an error for both\nLastInsertId and RowsAffected.\n"
    :added "1.0"
    :tag "Var"
    :go "driver.ResultNoRows"}
  ResultNoRows)

JOKER VARIABLE String from database/sql/driver/types.go:
(def
  ^{:doc "String is a ValueConverter that converts its input to a string.\nIf the value is already a string or []byte, it's unchanged.\nIf the value is of another type, conversion to string is done\nwith fmt.Sprintf(\"%v\", v).\n"
    :added "1.0"
    :tag "Var"
    :go "driver.String"}
  String-renamed)

JOKER TYPE database/sql/driver.ColumnConverter from database/sql/driver/driver.go:
;; (defn ^"GoObject" ColumnConverter.
;;   "Constructor for driver.ColumnConverter"
;;   {:added "1.0"
;;    :go "_ConstructColumnConverter(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Conn from database/sql/driver/driver.go:
;; (defn ^"GoObject" Conn.
;;   "Constructor for driver.Conn"
;;   {:added "1.0"
;;    :go "_ConstructConn(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.ConnBeginTx from database/sql/driver/driver.go:
;; (defn ^"GoObject" ConnBeginTx.
;;   "Constructor for driver.ConnBeginTx"
;;   {:added "1.0"
;;    :go "_ConstructConnBeginTx(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.ConnPrepareContext from database/sql/driver/driver.go:
;; (defn ^"GoObject" ConnPrepareContext.
;;   "Constructor for driver.ConnPrepareContext"
;;   {:added "1.0"
;;    :go "_ConstructConnPrepareContext(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Connector from database/sql/driver/driver.go:
;; (defn ^"GoObject" Connector.
;;   "Constructor for driver.Connector"
;;   {:added "1.0"
;;    :go "_ConstructConnector(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Driver from database/sql/driver/driver.go:
;; (defn ^"GoObject" Driver.
;;   "Constructor for driver.Driver"
;;   {:added "1.0"
;;    :go "_ConstructDriver(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.DriverContext from database/sql/driver/driver.go:
;; (defn ^"GoObject" DriverContext.
;;   "Constructor for driver.DriverContext"
;;   {:added "1.0"
;;    :go "_ConstructDriverContext(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Execer from database/sql/driver/driver.go:
;; (defn ^"GoObject" Execer.
;;   "Constructor for driver.Execer"
;;   {:added "1.0"
;;    :go "_ConstructExecer(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.ExecerContext from database/sql/driver/driver.go:
;; (defn ^"GoObject" ExecerContext.
;;   "Constructor for driver.ExecerContext"
;;   {:added "1.0"
;;    :go "_ConstructExecerContext(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.IsolationLevel from database/sql/driver/driver.go:
(defn ^"GoObject" IsolationLevel.
  "Constructor for driver.IsolationLevel"
  {:added "1.0"
   :go "_ConstructIsolationLevel(_v)"}
  [^Object _v])

JOKER TYPE database/sql/driver.NamedValue from database/sql/driver/driver.go:
;; (defn ^"GoObject" NamedValue.
;;   "Constructor for driver.NamedValue"
;;   {:added "1.0"
;;    :go "_ConstructNamedValue(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.NamedValueChecker from database/sql/driver/driver.go:
;; (defn ^"GoObject" NamedValueChecker.
;;   "Constructor for driver.NamedValueChecker"
;;   {:added "1.0"
;;    :go "_ConstructNamedValueChecker(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.NotNull from database/sql/driver/types.go:
;; (defn ^"GoObject" NotNull.
;;   "Constructor for driver.NotNull"
;;   {:added "1.0"
;;    :go "_ConstructNotNull(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Null from database/sql/driver/types.go:
;; (defn ^"GoObject" Null.
;;   "Constructor for driver.Null"
;;   {:added "1.0"
;;    :go "_ConstructNull(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Pinger from database/sql/driver/driver.go:
;; (defn ^"GoObject" Pinger.
;;   "Constructor for driver.Pinger"
;;   {:added "1.0"
;;    :go "_ConstructPinger(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Queryer from database/sql/driver/driver.go:
;; (defn ^"GoObject" Queryer.
;;   "Constructor for driver.Queryer"
;;   {:added "1.0"
;;    :go "_ConstructQueryer(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.QueryerContext from database/sql/driver/driver.go:
;; (defn ^"GoObject" QueryerContext.
;;   "Constructor for driver.QueryerContext"
;;   {:added "1.0"
;;    :go "_ConstructQueryerContext(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Result from database/sql/driver/driver.go:
;; (defn ^"GoObject" Result.
;;   "Constructor for driver.Result"
;;   {:added "1.0"
;;    :go "_ConstructResult(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Rows from database/sql/driver/driver.go:
;; (defn ^"GoObject" Rows.
;;   "Constructor for driver.Rows"
;;   {:added "1.0"
;;    :go "_ConstructRows(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.RowsAffected from database/sql/driver/driver.go:
(defn ^"GoObject" RowsAffected.
  "Constructor for driver.RowsAffected"
  {:added "1.0"
   :go "_ConstructRowsAffected(_v)"}
  [^Object _v])

JOKER TYPE database/sql/driver.RowsColumnTypeDatabaseTypeName from database/sql/driver/driver.go:
;; (defn ^"GoObject" RowsColumnTypeDatabaseTypeName.
;;   "Constructor for driver.RowsColumnTypeDatabaseTypeName"
;;   {:added "1.0"
;;    :go "_ConstructRowsColumnTypeDatabaseTypeName(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.RowsColumnTypeLength from database/sql/driver/driver.go:
;; (defn ^"GoObject" RowsColumnTypeLength.
;;   "Constructor for driver.RowsColumnTypeLength"
;;   {:added "1.0"
;;    :go "_ConstructRowsColumnTypeLength(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.RowsColumnTypeNullable from database/sql/driver/driver.go:
;; (defn ^"GoObject" RowsColumnTypeNullable.
;;   "Constructor for driver.RowsColumnTypeNullable"
;;   {:added "1.0"
;;    :go "_ConstructRowsColumnTypeNullable(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.RowsColumnTypePrecisionScale from database/sql/driver/driver.go:
;; (defn ^"GoObject" RowsColumnTypePrecisionScale.
;;   "Constructor for driver.RowsColumnTypePrecisionScale"
;;   {:added "1.0"
;;    :go "_ConstructRowsColumnTypePrecisionScale(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.RowsColumnTypeScanType from database/sql/driver/driver.go:
;; (defn ^"GoObject" RowsColumnTypeScanType.
;;   "Constructor for driver.RowsColumnTypeScanType"
;;   {:added "1.0"
;;    :go "_ConstructRowsColumnTypeScanType(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.RowsNextResultSet from database/sql/driver/driver.go:
;; (defn ^"GoObject" RowsNextResultSet.
;;   "Constructor for driver.RowsNextResultSet"
;;   {:added "1.0"
;;    :go "_ConstructRowsNextResultSet(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.SessionResetter from database/sql/driver/driver.go:
;; (defn ^"GoObject" SessionResetter.
;;   "Constructor for driver.SessionResetter"
;;   {:added "1.0"
;;    :go "_ConstructSessionResetter(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Stmt from database/sql/driver/driver.go:
;; (defn ^"GoObject" Stmt.
;;   "Constructor for driver.Stmt"
;;   {:added "1.0"
;;    :go "_ConstructStmt(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.StmtExecContext from database/sql/driver/driver.go:
;; (defn ^"GoObject" StmtExecContext.
;;   "Constructor for driver.StmtExecContext"
;;   {:added "1.0"
;;    :go "_ConstructStmtExecContext(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.StmtQueryContext from database/sql/driver/driver.go:
;; (defn ^"GoObject" StmtQueryContext.
;;   "Constructor for driver.StmtQueryContext"
;;   {:added "1.0"
;;    :go "_ConstructStmtQueryContext(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Tx from database/sql/driver/driver.go:
;; (defn ^"GoObject" Tx.
;;   "Constructor for driver.Tx"
;;   {:added "1.0"
;;    :go "_ConstructTx(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.TxOptions from database/sql/driver/driver.go:
(defn ^"GoObject" TxOptions.
  "Constructor for driver.TxOptions"
  {:added "1.0"
   :go "_ConstructTxOptions(_v)"}
  [^Object _v])

JOKER TYPE database/sql/driver.Value from database/sql/driver/driver.go:
;; (defn ^"GoObject" Value.
;;   "Constructor for driver.Value"
;;   {:added "1.0"
;;    :go "_ConstructValue(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.ValueConverter from database/sql/driver/types.go:
;; (defn ^"GoObject" ValueConverter.
;;   "Constructor for driver.ValueConverter"
;;   {:added "1.0"
;;    :go "_ConstructValueConverter(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Valuer from database/sql/driver/types.go:
;; (defn ^"GoObject" Valuer.
;;   "Constructor for driver.Valuer"
;;   {:added "1.0"
;;    :go "_ConstructValuer(_v)"}
;;   [^Object _v])

JOKER FUNC database/sql/driver.IsScanValue from database/sql/driver/types.go:
;; (defn ^"Boolean" IsScanValue
;;   "IsScanValue is equivalent to IsValue.\nIt exists for compatibility.\n\nGo input arguments: (v interface {})\n\nGo return type: bool\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "driver.IsScanValue(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> __v])

JOKER FUNC database/sql/driver.IsValue from database/sql/driver/types.go:
;; (defn ^"Boolean" IsValue
;;   "IsValue reports whether v is a valid Value parameter type.\n\nGo input arguments: (v interface {})\n\nGo return type: bool\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "driver.IsValue(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> __v])

JOKER TYPE go.std.database.sql.driver/ColumnConverter:
(def
  ^{:doc "ColumnConverter may be optionally implemented by Stmt if the\nstatement is aware of its own columns' types and can convert from\nany type to a driver Value.\n\nDeprecated: Drivers should implement NamedValueChecker.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ColumnConverter"}
  ColumnConverter)

JOKER TYPE go.std.database.sql.driver/Conn:
(def
  ^{:doc "Conn is a connection to a database. It is not used concurrently\nby multiple goroutines.\n\nConn is assumed to be stateful.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Conn"}
  Conn)

JOKER TYPE go.std.database.sql.driver/ConnBeginTx:
(def
  ^{:doc "ConnBeginTx enhances the Conn interface with context and TxOptions.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ConnBeginTx"}
  ConnBeginTx)

JOKER TYPE go.std.database.sql.driver/ConnPrepareContext:
(def
  ^{:doc "ConnPrepareContext enhances the Conn interface with context.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ConnPrepareContext"}
  ConnPrepareContext)

JOKER TYPE go.std.database.sql.driver/Connector:
(def
  ^{:doc "A Connector represents a driver in a fixed configuration\nand can create any number of equivalent Conns for use\nby multiple goroutines.\n\nA Connector can be passed to sql.OpenDB, to allow drivers\nto implement their own sql.DB constructors, or returned by\nDriverContext's OpenConnector method, to allow drivers\naccess to context and to avoid repeated parsing of driver\nconfiguration.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Connector"}
  Connector)

JOKER TYPE go.std.database.sql.driver/Driver:
(def
  ^{:doc "Driver is the interface that must be implemented by a database\ndriver.\n\nDatabase drivers may implement DriverContext for access\nto contexts and to parse the name only once for a pool of connections,\ninstead of once per connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Driver"}
  Driver)

JOKER TYPE go.std.database.sql.driver/DriverContext:
(def
  ^{:doc "If a Driver implements DriverContext, then sql.DB will call\nOpenConnector to obtain a Connector and then invoke\nthat Connector's Conn method to obtain each needed connection,\ninstead of invoking the Driver's Open method for each connection.\nThe two-step sequence allows drivers to parse the name just once\nand also provides access to per-Conn contexts.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DriverContext"}
  DriverContext)

JOKER TYPE go.std.database.sql.driver/Execer:
(def
  ^{:doc "Execer is an optional interface that may be implemented by a Conn.\n\nIf a Conn implements neither ExecerContext nor Execer,\nthe sql package's DB.Exec will first prepare a query, execute the statement,\nand then close the statement.\n\nExec may return ErrSkip.\n\nDeprecated: Drivers should implement ExecerContext instead.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Execer"}
  Execer)

JOKER TYPE go.std.database.sql.driver/ExecerContext:
(def
  ^{:doc "ExecerContext is an optional interface that may be implemented by a Conn.\n\nIf a Conn does not implement ExecerContext, the sql package's DB.Exec\nwill fall back to Execer; if the Conn does not implement Execer either,\nDB.Exec will first prepare a query, execute the statement, and then\nclose the statement.\n\nExecerContext may return ErrSkip.\n\nExecerContext must honor the context timeout and return when the context is canceled.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ExecerContext"}
  ExecerContext)

JOKER TYPE go.std.database.sql.driver/IsolationLevel:
(def
  ^{:doc "IsolationLevel is the transaction isolation level stored in TxOptions.\n\nThis type should be considered identical to sql.IsolationLevel along\nwith any values defined on it.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IsolationLevel"}
  IsolationLevel)

JOKER TYPE go.std.database.sql.driver/NamedValue:
(def
  ^{:doc "NamedValue holds both the value name and value.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NamedValue"}
  NamedValue)

JOKER TYPE go.std.database.sql.driver/NamedValueChecker:
(def
  ^{:doc "NamedValueChecker may be optionally implemented by Conn or Stmt. It provides\nthe driver more control to handle Go and database types beyond the default\nValues types allowed.\n\nThe sql package checks for value checkers in the following order,\nstopping at the first found match: Stmt.NamedValueChecker, Conn.NamedValueChecker,\nStmt.ColumnConverter, DefaultParameterConverter.\n\nIf CheckNamedValue returns ErrRemoveArgument, the NamedValue will not be included in\nthe final query arguments. This may be used to pass special options to\nthe query itself.\n\nIf ErrSkip is returned the column converter error checking\npath is used for the argument. Drivers may wish to return ErrSkip after\nthey have exhausted their own special cases.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NamedValueChecker"}
  NamedValueChecker)

JOKER TYPE go.std.database.sql.driver/NotNull:
(def
  ^{:doc "NotNull is a type that implements ValueConverter by disallowing nil\nvalues but otherwise delegating to another ValueConverter.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NotNull"}
  NotNull)

JOKER TYPE go.std.database.sql.driver/Null:
(def
  ^{:doc "Null is a type that implements ValueConverter by allowing nil\nvalues but otherwise delegating to another ValueConverter.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Null"}
  Null)

JOKER TYPE go.std.database.sql.driver/Pinger:
(def
  ^{:doc "Pinger is an optional interface that may be implemented by a Conn.\n\nIf a Conn does not implement Pinger, the sql package's DB.Ping and\nDB.PingContext will check if there is at least one Conn available.\n\nIf Conn.Ping returns ErrBadConn, DB.Ping and DB.PingContext will remove\nthe Conn from pool.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Pinger"}
  Pinger)

JOKER TYPE go.std.database.sql.driver/Queryer:
(def
  ^{:doc "Queryer is an optional interface that may be implemented by a Conn.\n\nIf a Conn implements neither QueryerContext nor Queryer,\nthe sql package's DB.Query will first prepare a query, execute the statement,\nand then close the statement.\n\nQuery may return ErrSkip.\n\nDeprecated: Drivers should implement QueryerContext instead.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Queryer"}
  Queryer)

JOKER TYPE go.std.database.sql.driver/QueryerContext:
(def
  ^{:doc "QueryerContext is an optional interface that may be implemented by a Conn.\n\nIf a Conn does not implement QueryerContext, the sql package's DB.Query\nwill fall back to Queryer; if the Conn does not implement Queryer either,\nDB.Query will first prepare a query, execute the statement, and then\nclose the statement.\n\nQueryerContext may return ErrSkip.\n\nQueryerContext must honor the context timeout and return when the context is canceled.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_QueryerContext"}
  QueryerContext)

JOKER TYPE go.std.database.sql.driver/Result:
(def
  ^{:doc "Result is the result of a query execution.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Result"}
  Result)

JOKER TYPE go.std.database.sql.driver/Rows:
(def
  ^{:doc "Rows is an iterator over an executed query's results.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Rows"}
  Rows)

JOKER TYPE go.std.database.sql.driver/RowsAffected:
(def
  ^{:doc "RowsAffected implements Result for an INSERT or UPDATE operation\nwhich mutates a number of rows.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RowsAffected"}
  RowsAffected)

JOKER TYPE go.std.database.sql.driver/RowsColumnTypeDatabaseTypeName:
(def
  ^{:doc "RowsColumnTypeDatabaseTypeName may be implemented by Rows. It should return the\ndatabase system type name without the length. Type names should be uppercase.\nExamples of returned types: \"VARCHAR\", \"NVARCHAR\", \"VARCHAR2\", \"CHAR\", \"TEXT\",\n\"DECIMAL\", \"SMALLINT\", \"INT\", \"BIGINT\", \"BOOL\", \"[]BIGINT\", \"JSONB\", \"XML\",\n\"TIMESTAMP\".\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RowsColumnTypeDatabaseTypeName"}
  RowsColumnTypeDatabaseTypeName)

JOKER TYPE go.std.database.sql.driver/RowsColumnTypeLength:
(def
  ^{:doc "RowsColumnTypeLength may be implemented by Rows. It should return the length\nof the column type if the column is a variable length type. If the column is\nnot a variable length type ok should return false.\nIf length is not limited other than system limits, it should return math.MaxInt64.\nThe following are examples of returned values for various types:\n  TEXT          (math.MaxInt64, true)\n  varchar(10)   (10, true)\n  nvarchar(10)  (10, true)\n  decimal       (0, false)\n  int           (0, false)\n  bytea(30)     (30, true)\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RowsColumnTypeLength"}
  RowsColumnTypeLength)

JOKER TYPE go.std.database.sql.driver/RowsColumnTypeNullable:
(def
  ^{:doc "RowsColumnTypeNullable may be implemented by Rows. The nullable value should\nbe true if it is known the column may be null, or false if the column is known\nto be not nullable.\nIf the column nullability is unknown, ok should be false.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RowsColumnTypeNullable"}
  RowsColumnTypeNullable)

JOKER TYPE go.std.database.sql.driver/RowsColumnTypePrecisionScale:
(def
  ^{:doc "RowsColumnTypePrecisionScale may be implemented by Rows. It should return\nthe precision and scale for decimal types. If not applicable, ok should be false.\nThe following are examples of returned values for various types:\n  decimal(38, 4)    (38, 4, true)\n  int               (0, 0, false)\n  decimal           (math.MaxInt64, math.MaxInt64, true)\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RowsColumnTypePrecisionScale"}
  RowsColumnTypePrecisionScale)

JOKER TYPE go.std.database.sql.driver/RowsColumnTypeScanType:
(def
  ^{:doc "RowsColumnTypeScanType may be implemented by Rows. It should return\nthe value type that can be used to scan types into. For example, the database\ncolumn type \"bigint\" this should return \"reflect.TypeOf(int64(0))\".\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RowsColumnTypeScanType"}
  RowsColumnTypeScanType)

JOKER TYPE go.std.database.sql.driver/RowsNextResultSet:
(def
  ^{:doc "RowsNextResultSet extends the Rows interface by providing a way to signal\nthe driver to advance to the next result set.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RowsNextResultSet"}
  RowsNextResultSet)

JOKER TYPE go.std.database.sql.driver/SessionResetter:
(def
  ^{:doc "SessionResetter may be implemented by Conn to allow drivers to reset the\nsession state associated with the connection and to signal a bad connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SessionResetter"}
  SessionResetter)

JOKER TYPE go.std.database.sql.driver/Stmt:
(def
  ^{:doc "Stmt is a prepared statement. It is bound to a Conn and not\nused by multiple goroutines concurrently.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Stmt"}
  Stmt)

JOKER TYPE go.std.database.sql.driver/StmtExecContext:
(def
  ^{:doc "StmtExecContext enhances the Stmt interface by providing Exec with context.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_StmtExecContext"}
  StmtExecContext)

JOKER TYPE go.std.database.sql.driver/StmtQueryContext:
(def
  ^{:doc "StmtQueryContext enhances the Stmt interface by providing Query with context.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_StmtQueryContext"}
  StmtQueryContext)

JOKER TYPE go.std.database.sql.driver/Tx:
(def
  ^{:doc "Tx is a transaction.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Tx"}
  Tx)

JOKER TYPE go.std.database.sql.driver/TxOptions:
(def
  ^{:doc "TxOptions holds the transaction options.\n\nThis type should be considered identical to sql.TxOptions.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TxOptions"}
  TxOptions)

JOKER TYPE go.std.database.sql.driver/Value:
(def
  ^{:doc "Value is a value that drivers must be able to handle.\nIt is either nil, a type handled by a database driver's NamedValueChecker\ninterface, or an instance of one of these types:\n\n  int64\n  float64\n  bool\n  []byte\n  string\n  time.Time\n\nIf the driver supports cursors, a returned Value may also implement the Rows interface\nin this package. This is used when, for example, when a user selects a cursor\nsuch as \"select cursor(select * from my_table) from dual\". If the Rows\nfrom the select is closed, the cursor Rows will also be closed.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Value"}
  Value)

JOKER TYPE go.std.database.sql.driver/ValueConverter:
(def
  ^{:doc "ValueConverter is the interface providing the ConvertValue method.\n\nVarious implementations of ValueConverter are provided by the\ndriver package to provide consistent implementations of conversions\nbetween drivers. The ValueConverters have several uses:\n\n * converting from the Value types as provided by the sql package\n   into a database table's specific column type and making sure it\n   fits, such as making sure a particular int64 fits in a\n   table's uint16 column.\n\n * converting a value as given from the database into one of the\n   driver Value types.\n\n * by the sql package, for converting from a driver's Value type\n   to a user's type in a scan.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ValueConverter"}
  ValueConverter)

JOKER TYPE go.std.database.sql.driver/Valuer:
(def
  ^{:doc "Valuer is the interface providing the Value method.\n\nTypes implementing Valuer interface are able to convert\nthemselves to a driver Value.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Valuer"}
  Valuer)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["database/sql/driver"]
    :doc "Provides a low-level interface to the database/sql/driver package.\n\nPackage driver defines interfaces to be implemented by database\ndrivers as used by package sql.\n\nMost code should use package sql.\n"
    :empty false}
  go.std.database.sql.driver)
JOKER CONSTANT AttrAbstractOrigin from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrAbstractOrigin))"}
  AttrAbstractOrigin)

JOKER CONSTANT AttrAccessibility from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrAccessibility))"}
  AttrAccessibility)

JOKER CONSTANT AttrAddrClass from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrAddrClass))"}
  AttrAddrClass)

JOKER CONSTANT AttrAllocated from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrAllocated))"}
  AttrAllocated)

JOKER CONSTANT AttrArtificial from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrArtificial))"}
  AttrArtificial)

JOKER CONSTANT AttrAssociated from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrAssociated))"}
  AttrAssociated)

JOKER CONSTANT AttrBaseTypes from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrBaseTypes))"}
  AttrBaseTypes)

JOKER CONSTANT AttrBitOffset from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrBitOffset))"}
  AttrBitOffset)

JOKER CONSTANT AttrBitSize from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrBitSize))"}
  AttrBitSize)

JOKER CONSTANT AttrByteSize from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrByteSize))"}
  AttrByteSize)

JOKER CONSTANT AttrCallColumn from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrCallColumn))"}
  AttrCallColumn)

JOKER CONSTANT AttrCallFile from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrCallFile))"}
  AttrCallFile)

JOKER CONSTANT AttrCallLine from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrCallLine))"}
  AttrCallLine)

JOKER CONSTANT AttrCalling from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrCalling))"}
  AttrCalling)

JOKER CONSTANT AttrCommonRef from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrCommonRef))"}
  AttrCommonRef)

JOKER CONSTANT AttrCompDir from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrCompDir))"}
  AttrCompDir)

JOKER CONSTANT AttrConstValue from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrConstValue))"}
  AttrConstValue)

JOKER CONSTANT AttrContainingType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrContainingType))"}
  AttrContainingType)

JOKER CONSTANT AttrCount from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrCount))"}
  AttrCount)

JOKER CONSTANT AttrDataLocation from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrDataLocation))"}
  AttrDataLocation)

JOKER CONSTANT AttrDataMemberLoc from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrDataMemberLoc))"}
  AttrDataMemberLoc)

JOKER CONSTANT AttrDeclColumn from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrDeclColumn))"}
  AttrDeclColumn)

JOKER CONSTANT AttrDeclFile from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrDeclFile))"}
  AttrDeclFile)

JOKER CONSTANT AttrDeclLine from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrDeclLine))"}
  AttrDeclLine)

JOKER CONSTANT AttrDeclaration from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrDeclaration))"}
  AttrDeclaration)

JOKER CONSTANT AttrDefaultValue from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrDefaultValue))"}
  AttrDefaultValue)

JOKER CONSTANT AttrDescription from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrDescription))"}
  AttrDescription)

JOKER CONSTANT AttrDiscr from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrDiscr))"}
  AttrDiscr)

JOKER CONSTANT AttrDiscrList from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrDiscrList))"}
  AttrDiscrList)

JOKER CONSTANT AttrDiscrValue from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrDiscrValue))"}
  AttrDiscrValue)

JOKER CONSTANT AttrEncoding from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrEncoding))"}
  AttrEncoding)

JOKER CONSTANT AttrEntrypc from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrEntrypc))"}
  AttrEntrypc)

JOKER CONSTANT AttrExtension from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrExtension))"}
  AttrExtension)

JOKER CONSTANT AttrExternal from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrExternal))"}
  AttrExternal)

JOKER CONSTANT AttrFrameBase from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrFrameBase))"}
  AttrFrameBase)

JOKER CONSTANT AttrFriend from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrFriend))"}
  AttrFriend)

JOKER CONSTANT AttrHighpc from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrHighpc))"}
  AttrHighpc)

JOKER CONSTANT AttrIdentifierCase from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrIdentifierCase))"}
  AttrIdentifierCase)

JOKER CONSTANT AttrImport from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrImport))"}
  AttrImport)

JOKER CONSTANT AttrInline from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrInline))"}
  AttrInline)

JOKER CONSTANT AttrIsOptional from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrIsOptional))"}
  AttrIsOptional)

JOKER CONSTANT AttrLanguage from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrLanguage))"}
  AttrLanguage)

JOKER CONSTANT AttrLocation from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrLocation))"}
  AttrLocation)

JOKER CONSTANT AttrLowerBound from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrLowerBound))"}
  AttrLowerBound)

JOKER CONSTANT AttrLowpc from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrLowpc))"}
  AttrLowpc)

JOKER CONSTANT AttrMacroInfo from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrMacroInfo))"}
  AttrMacroInfo)

JOKER CONSTANT AttrName from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrName))"}
  AttrName)

JOKER CONSTANT AttrNamelistItem from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrNamelistItem))"}
  AttrNamelistItem)

JOKER CONSTANT AttrOrdering from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrOrdering))"}
  AttrOrdering)

JOKER CONSTANT AttrPriority from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrPriority))"}
  AttrPriority)

JOKER CONSTANT AttrProducer from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrProducer))"}
  AttrProducer)

JOKER CONSTANT AttrPrototyped from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrPrototyped))"}
  AttrPrototyped)

JOKER CONSTANT AttrRanges from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrRanges))"}
  AttrRanges)

JOKER CONSTANT AttrReturnAddr from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrReturnAddr))"}
  AttrReturnAddr)

JOKER CONSTANT AttrSegment from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrSegment))"}
  AttrSegment)

JOKER CONSTANT AttrSibling from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrSibling))"}
  AttrSibling)

JOKER CONSTANT AttrSpecification from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrSpecification))"}
  AttrSpecification)

JOKER CONSTANT AttrStartScope from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrStartScope))"}
  AttrStartScope)

JOKER CONSTANT AttrStaticLink from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrStaticLink))"}
  AttrStaticLink)

JOKER CONSTANT AttrStmtList from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrStmtList))"}
  AttrStmtList)

JOKER CONSTANT AttrStride from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrStride))"}
  AttrStride)

JOKER CONSTANT AttrStrideSize from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrStrideSize))"}
  AttrStrideSize)

JOKER CONSTANT AttrStringLength from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrStringLength))"}
  AttrStringLength)

JOKER CONSTANT AttrTrampoline from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrTrampoline))"}
  AttrTrampoline)

JOKER CONSTANT AttrType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrType))"}
  AttrType)

JOKER CONSTANT AttrUpperBound from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrUpperBound))"}
  AttrUpperBound)

JOKER CONSTANT AttrUseLocation from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrUseLocation))"}
  AttrUseLocation)

JOKER CONSTANT AttrUseUTF8 from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrUseUTF8))"}
  AttrUseUTF8)

JOKER CONSTANT AttrVarParam from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrVarParam))"}
  AttrVarParam)

JOKER CONSTANT AttrVirtuality from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrVirtuality))"}
  AttrVirtuality)

JOKER CONSTANT AttrVisibility from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrVisibility))"}
  AttrVisibility)

JOKER CONSTANT AttrVtableElemLoc from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.AttrVtableElemLoc))"}
  AttrVtableElemLoc)

JOKER CONSTANT ClassAddress from debug/dwarf/entry.go:
(def
  ^{:doc "ClassAddress represents values of type uint64 that are\naddresses on the target machine.\n"
    :added "1.0"
    :tag "Int"
    :go "int(dwarf.ClassAddress)"}
  ClassAddress)

JOKER CONSTANT ClassBlock from debug/dwarf/entry.go:
(def
  ^{:doc "ClassBlock represents values of type []byte whose\ninterpretation depends on the attribute.\n"
    :added "1.0"
    :tag "Int"
    :go "int(dwarf.ClassBlock)"}
  ClassBlock)

JOKER CONSTANT ClassConstant from debug/dwarf/entry.go:
(def
  ^{:doc "ClassConstant represents values of type int64 that are\nconstants. The interpretation of this constant depends on\nthe attribute.\n"
    :added "1.0"
    :tag "Int"
    :go "int(dwarf.ClassConstant)"}
  ClassConstant)

JOKER CONSTANT ClassExprLoc from debug/dwarf/entry.go:
(def
  ^{:doc "ClassExprLoc represents values of type []byte that contain\nan encoded DWARF expression or location description.\n"
    :added "1.0"
    :tag "Int"
    :go "int(dwarf.ClassExprLoc)"}
  ClassExprLoc)

JOKER CONSTANT ClassFlag from debug/dwarf/entry.go:
(def
  ^{:doc "ClassFlag represents values of type bool.\n"
    :added "1.0"
    :tag "Int"
    :go "int(dwarf.ClassFlag)"}
  ClassFlag)

JOKER CONSTANT ClassLinePtr from debug/dwarf/entry.go:
(def
  ^{:doc "ClassLinePtr represents values that are an int64 offset\ninto the \"line\" section.\n"
    :added "1.0"
    :tag "Int"
    :go "int(dwarf.ClassLinePtr)"}
  ClassLinePtr)

JOKER CONSTANT ClassLocListPtr from debug/dwarf/entry.go:
(def
  ^{:doc "ClassLocListPtr represents values that are an int64 offset\ninto the \"loclist\" section.\n"
    :added "1.0"
    :tag "Int"
    :go "int(dwarf.ClassLocListPtr)"}
  ClassLocListPtr)

JOKER CONSTANT ClassMacPtr from debug/dwarf/entry.go:
(def
  ^{:doc "ClassMacPtr represents values that are an int64 offset into\nthe \"mac\" section.\n"
    :added "1.0"
    :tag "Int"
    :go "int(dwarf.ClassMacPtr)"}
  ClassMacPtr)

JOKER CONSTANT ClassRangeListPtr from debug/dwarf/entry.go:
(def
  ^{:doc "ClassMacPtr represents values that are an int64 offset into\nthe \"rangelist\" section.\n"
    :added "1.0"
    :tag "Int"
    :go "int(dwarf.ClassRangeListPtr)"}
  ClassRangeListPtr)

JOKER CONSTANT ClassReference from debug/dwarf/entry.go:
(def
  ^{:doc "ClassReference represents values that are an Offset offset\nof an Entry in the info section (for use with Reader.Seek).\nThe DWARF specification combines ClassReference and\nClassReferenceSig into class \"reference\".\n"
    :added "1.0"
    :tag "Int"
    :go "int(dwarf.ClassReference)"}
  ClassReference)

JOKER CONSTANT ClassReferenceAlt from debug/dwarf/entry.go:
(def
  ^{:doc "ClassReferenceAlt represents values of type int64 that are\nan offset into the DWARF \"info\" section of an alternate\nobject file.\n"
    :added "1.0"
    :tag "Int"
    :go "int(dwarf.ClassReferenceAlt)"}
  ClassReferenceAlt)

JOKER CONSTANT ClassReferenceSig from debug/dwarf/entry.go:
(def
  ^{:doc "ClassReferenceSig represents values that are a uint64 type\nsignature referencing a type Entry.\n"
    :added "1.0"
    :tag "Int"
    :go "int(dwarf.ClassReferenceSig)"}
  ClassReferenceSig)

JOKER CONSTANT ClassString from debug/dwarf/entry.go:
(def
  ^{:doc "ClassString represents values that are strings. If the\ncompilation unit specifies the AttrUseUTF8 flag (strongly\nrecommended), the string value will be encoded in UTF-8.\nOtherwise, the encoding is unspecified.\n"
    :added "1.0"
    :tag "Int"
    :go "int(dwarf.ClassString)"}
  ClassString)

JOKER CONSTANT ClassStringAlt from debug/dwarf/entry.go:
(def
  ^{:doc "ClassStringAlt represents values of type int64 that are an\noffset into the DWARF string section of an alternate object\nfile.\n"
    :added "1.0"
    :tag "Int"
    :go "int(dwarf.ClassStringAlt)"}
  ClassStringAlt)

JOKER CONSTANT ClassUnknown from debug/dwarf/entry.go:
(def
  ^{:doc "ClassUnknown represents values of unknown DWARF class.\n"
    :added "1.0"
    :tag "Int"
    :go "int(dwarf.ClassUnknown)"}
  ClassUnknown)

JOKER CONSTANT TagAccessDeclaration from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagAccessDeclaration))"}
  TagAccessDeclaration)

JOKER CONSTANT TagArrayType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagArrayType))"}
  TagArrayType)

JOKER CONSTANT TagBaseType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagBaseType))"}
  TagBaseType)

JOKER CONSTANT TagCatchDwarfBlock from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagCatchDwarfBlock))"}
  TagCatchDwarfBlock)

JOKER CONSTANT TagClassType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagClassType))"}
  TagClassType)

JOKER CONSTANT TagCommonDwarfBlock from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagCommonDwarfBlock))"}
  TagCommonDwarfBlock)

JOKER CONSTANT TagCommonInclusion from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagCommonInclusion))"}
  TagCommonInclusion)

JOKER CONSTANT TagCompileUnit from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagCompileUnit))"}
  TagCompileUnit)

JOKER CONSTANT TagCondition from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagCondition))"}
  TagCondition)

JOKER CONSTANT TagConstType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagConstType))"}
  TagConstType)

JOKER CONSTANT TagConstant from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagConstant))"}
  TagConstant)

JOKER CONSTANT TagDwarfProcedure from debug/dwarf/const.go:
(def
  ^{:doc "The following are new in DWARF 3.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagDwarfProcedure))"}
  TagDwarfProcedure)

JOKER CONSTANT TagEntryPoint from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagEntryPoint))"}
  TagEntryPoint)

JOKER CONSTANT TagEnumerationType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagEnumerationType))"}
  TagEnumerationType)

JOKER CONSTANT TagEnumerator from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagEnumerator))"}
  TagEnumerator)

JOKER CONSTANT TagFileType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagFileType))"}
  TagFileType)

JOKER CONSTANT TagFormalParameter from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagFormalParameter))"}
  TagFormalParameter)

JOKER CONSTANT TagFriend from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagFriend))"}
  TagFriend)

JOKER CONSTANT TagImportedDeclaration from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagImportedDeclaration))"}
  TagImportedDeclaration)

JOKER CONSTANT TagImportedModule from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagImportedModule))"}
  TagImportedModule)

JOKER CONSTANT TagImportedUnit from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagImportedUnit))"}
  TagImportedUnit)

JOKER CONSTANT TagInheritance from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagInheritance))"}
  TagInheritance)

JOKER CONSTANT TagInlinedSubroutine from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagInlinedSubroutine))"}
  TagInlinedSubroutine)

JOKER CONSTANT TagInterfaceType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagInterfaceType))"}
  TagInterfaceType)

JOKER CONSTANT TagLabel from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagLabel))"}
  TagLabel)

JOKER CONSTANT TagLexDwarfBlock from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagLexDwarfBlock))"}
  TagLexDwarfBlock)

JOKER CONSTANT TagMember from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagMember))"}
  TagMember)

JOKER CONSTANT TagModule from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagModule))"}
  TagModule)

JOKER CONSTANT TagMutableType from debug/dwarf/const.go:
(def
  ^{:doc "Later removed from DWARF.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagMutableType))"}
  TagMutableType)

JOKER CONSTANT TagNamelist from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagNamelist))"}
  TagNamelist)

JOKER CONSTANT TagNamelistItem from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagNamelistItem))"}
  TagNamelistItem)

JOKER CONSTANT TagNamespace from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagNamespace))"}
  TagNamespace)

JOKER CONSTANT TagPackedType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagPackedType))"}
  TagPackedType)

JOKER CONSTANT TagPartialUnit from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagPartialUnit))"}
  TagPartialUnit)

JOKER CONSTANT TagPointerType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagPointerType))"}
  TagPointerType)

JOKER CONSTANT TagPtrToMemberType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagPtrToMemberType))"}
  TagPtrToMemberType)

JOKER CONSTANT TagReferenceType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagReferenceType))"}
  TagReferenceType)

JOKER CONSTANT TagRestrictType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagRestrictType))"}
  TagRestrictType)

JOKER CONSTANT TagRvalueReferenceType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagRvalueReferenceType))"}
  TagRvalueReferenceType)

JOKER CONSTANT TagSetType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagSetType))"}
  TagSetType)

JOKER CONSTANT TagSharedType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagSharedType))"}
  TagSharedType)

JOKER CONSTANT TagStringType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagStringType))"}
  TagStringType)

JOKER CONSTANT TagStructType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagStructType))"}
  TagStructType)

JOKER CONSTANT TagSubprogram from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagSubprogram))"}
  TagSubprogram)

JOKER CONSTANT TagSubrangeType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagSubrangeType))"}
  TagSubrangeType)

JOKER CONSTANT TagSubroutineType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagSubroutineType))"}
  TagSubroutineType)

JOKER CONSTANT TagTemplateAlias from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagTemplateAlias))"}
  TagTemplateAlias)

JOKER CONSTANT TagTemplateTypeParameter from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagTemplateTypeParameter))"}
  TagTemplateTypeParameter)

JOKER CONSTANT TagTemplateValueParameter from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagTemplateValueParameter))"}
  TagTemplateValueParameter)

JOKER CONSTANT TagThrownType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagThrownType))"}
  TagThrownType)

JOKER CONSTANT TagTryDwarfBlock from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagTryDwarfBlock))"}
  TagTryDwarfBlock)

JOKER CONSTANT TagTypeUnit from debug/dwarf/const.go:
(def
  ^{:doc "The following are new in DWARF 4.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagTypeUnit))"}
  TagTypeUnit)

JOKER CONSTANT TagTypedef from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagTypedef))"}
  TagTypedef)

JOKER CONSTANT TagUnionType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagUnionType))"}
  TagUnionType)

JOKER CONSTANT TagUnspecifiedParameters from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagUnspecifiedParameters))"}
  TagUnspecifiedParameters)

JOKER CONSTANT TagUnspecifiedType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagUnspecifiedType))"}
  TagUnspecifiedType)

JOKER CONSTANT TagVariable from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagVariable))"}
  TagVariable)

JOKER CONSTANT TagVariant from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagVariant))"}
  TagVariant)

JOKER CONSTANT TagVariantPart from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagVariantPart))"}
  TagVariantPart)

JOKER CONSTANT TagVolatileType from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagVolatileType))"}
  TagVolatileType)

JOKER CONSTANT TagWithStmt from debug/dwarf/const.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(dwarf.TagWithStmt))"}
  TagWithStmt)

JOKER VARIABLE ErrUnknownPC from debug/dwarf/line.go:
(def
  ^{:doc "ErrUnknownPC is the error returned by LineReader.ScanPC when the\nseek PC is not covered by any entry in the line table.\n"
    :added "1.0"
    :tag "Var"
    :go "dwarf.ErrUnknownPC"}
  ErrUnknownPC)

JOKER TYPE debug/dwarf.AddrType from debug/dwarf/type.go:
(defn ^"GoObject" AddrType.
  "Constructor for dwarf.AddrType"
  {:added "1.0"
   :go "_ConstructAddrType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.ArrayType from debug/dwarf/type.go:
;; (defn ^"GoObject" ArrayType.
;;   "Constructor for dwarf.ArrayType"
;;   {:added "1.0"
;;    :go "_ConstructArrayType(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.Attr from debug/dwarf/const.go:
(defn ^"GoObject" Attr.
  "Constructor for dwarf.Attr"
  {:added "1.0"
   :go "_ConstructAttr(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.BasicType from debug/dwarf/type.go:
(defn ^"GoObject" BasicType.
  "Constructor for dwarf.BasicType"
  {:added "1.0"
   :go "_ConstructBasicType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.BoolType from debug/dwarf/type.go:
(defn ^"GoObject" BoolType.
  "Constructor for dwarf.BoolType"
  {:added "1.0"
   :go "_ConstructBoolType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.CharType from debug/dwarf/type.go:
(defn ^"GoObject" CharType.
  "Constructor for dwarf.CharType"
  {:added "1.0"
   :go "_ConstructCharType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.Class from debug/dwarf/entry.go:
(defn ^"GoObject" Class.
  "Constructor for dwarf.Class"
  {:added "1.0"
   :go "_ConstructClass(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.CommonType from debug/dwarf/type.go:
(defn ^"GoObject" CommonType.
  "Constructor for dwarf.CommonType"
  {:added "1.0"
   :go "_ConstructCommonType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.ComplexType from debug/dwarf/type.go:
(defn ^"GoObject" ComplexType.
  "Constructor for dwarf.ComplexType"
  {:added "1.0"
   :go "_ConstructComplexType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.Data from debug/dwarf/open.go:
(defn ^"GoObject" Data.
  "Constructor for dwarf.Data"
  {:added "1.0"
   :go "_ConstructData(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.DecodeError from debug/dwarf/buf.go:
(defn ^"GoObject" DecodeError.
  "Constructor for dwarf.DecodeError"
  {:added "1.0"
   :go "_ConstructDecodeError(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.DotDotDotType from debug/dwarf/type.go:
(defn ^"GoObject" DotDotDotType.
  "Constructor for dwarf.DotDotDotType"
  {:added "1.0"
   :go "_ConstructDotDotDotType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.Entry from debug/dwarf/entry.go:
;; (defn ^"GoObject" Entry.
;;   "Constructor for dwarf.Entry"
;;   {:added "1.0"
;;    :go "_ConstructEntry(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.EnumType from debug/dwarf/type.go:
;; (defn ^"GoObject" EnumType.
;;   "Constructor for dwarf.EnumType"
;;   {:added "1.0"
;;    :go "_ConstructEnumType(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.EnumValue from debug/dwarf/type.go:
(defn ^"GoObject" EnumValue.
  "Constructor for dwarf.EnumValue"
  {:added "1.0"
   :go "_ConstructEnumValue(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.Field from debug/dwarf/entry.go:
;; (defn ^"GoObject" Field.
;;   "Constructor for dwarf.Field"
;;   {:added "1.0"
;;    :go "_ConstructField(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.FloatType from debug/dwarf/type.go:
(defn ^"GoObject" FloatType.
  "Constructor for dwarf.FloatType"
  {:added "1.0"
   :go "_ConstructFloatType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.FuncType from debug/dwarf/type.go:
;; (defn ^"GoObject" FuncType.
;;   "Constructor for dwarf.FuncType"
;;   {:added "1.0"
;;    :go "_ConstructFuncType(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.IntType from debug/dwarf/type.go:
(defn ^"GoObject" IntType.
  "Constructor for dwarf.IntType"
  {:added "1.0"
   :go "_ConstructIntType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.LineEntry from debug/dwarf/line.go:
;; (defn ^"GoObject" LineEntry.
;;   "Constructor for dwarf.LineEntry"
;;   {:added "1.0"
;;    :go "_ConstructLineEntry(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.LineFile from debug/dwarf/line.go:
(defn ^"GoObject" LineFile.
  "Constructor for dwarf.LineFile"
  {:added "1.0"
   :go "_ConstructLineFile(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.LineReader from debug/dwarf/line.go:
(defn ^"GoObject" LineReader.
  "Constructor for dwarf.LineReader"
  {:added "1.0"
   :go "_ConstructLineReader(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.LineReaderPos from debug/dwarf/line.go:
(defn ^"GoObject" LineReaderPos.
  "Constructor for dwarf.LineReaderPos"
  {:added "1.0"
   :go "_ConstructLineReaderPos(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.Offset from debug/dwarf/entry.go:
(defn ^"GoObject" Offset.
  "Constructor for dwarf.Offset"
  {:added "1.0"
   :go "_ConstructOffset(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.PtrType from debug/dwarf/type.go:
;; (defn ^"GoObject" PtrType.
;;   "Constructor for dwarf.PtrType"
;;   {:added "1.0"
;;    :go "_ConstructPtrType(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.QualType from debug/dwarf/type.go:
;; (defn ^"GoObject" QualType.
;;   "Constructor for dwarf.QualType"
;;   {:added "1.0"
;;    :go "_ConstructQualType(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.Reader from debug/dwarf/entry.go:
(defn ^"GoObject" Reader.
  "Constructor for dwarf.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.StructField from debug/dwarf/type.go:
;; (defn ^"GoObject" StructField.
;;   "Constructor for dwarf.StructField"
;;   {:added "1.0"
;;    :go "_ConstructStructField(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.StructType from debug/dwarf/type.go:
;; (defn ^"GoObject" StructType.
;;   "Constructor for dwarf.StructType"
;;   {:added "1.0"
;;    :go "_ConstructStructType(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.Tag from debug/dwarf/const.go:
(defn ^"GoObject" Tag.
  "Constructor for dwarf.Tag"
  {:added "1.0"
   :go "_ConstructTag(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.Type from debug/dwarf/type.go:
;; (defn ^"GoObject" Type.
;;   "Constructor for dwarf.Type"
;;   {:added "1.0"
;;    :go "_ConstructType(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.TypedefType from debug/dwarf/type.go:
;; (defn ^"GoObject" TypedefType.
;;   "Constructor for dwarf.TypedefType"
;;   {:added "1.0"
;;    :go "_ConstructTypedefType(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.UcharType from debug/dwarf/type.go:
(defn ^"GoObject" UcharType.
  "Constructor for dwarf.UcharType"
  {:added "1.0"
   :go "_ConstructUcharType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.UintType from debug/dwarf/type.go:
(defn ^"GoObject" UintType.
  "Constructor for dwarf.UintType"
  {:added "1.0"
   :go "_ConstructUintType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.UnspecifiedType from debug/dwarf/type.go:
(defn ^"GoObject" UnspecifiedType.
  "Constructor for dwarf.UnspecifiedType"
  {:added "1.0"
   :go "_ConstructUnspecifiedType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.VoidType from debug/dwarf/type.go:
(defn ^"GoObject" VoidType.
  "Constructor for dwarf.VoidType"
  {:added "1.0"
   :go "_ConstructVoidType(_v)"}
  [^Object _v])

JOKER FUNC debug/dwarf.New from debug/dwarf/open.go:
;; (defn New
;;   "New returns a new Data object initialized from the given parameters.\nRather than calling this function directly, clients should typically use\nthe DWARF method of the File type of the appropriate package debug/elf,\ndebug/macho, or debug/pe.\n\nThe []byte arguments are the data from the corresponding debug section\nin the object file; for example, for an ELF object, abbrev is the contents of\nthe \".debug_abbrev\" section.\n\nGo input arguments: (abbrev []byte, aranges []byte, frame []byte, info []byte, line []byte, pubnames []byte, ranges []byte, str []byte)\n\nGo return type: (*Data, error)\n\nJoker input arguments: [^(vector-of Int) abbrev, ^(vector-of Int) aranges, ^(vector-of Int) frame, ^(vector-of Int) info, ^(vector-of Int) line, ^(vector-of Int) pubnames, ^(vector-of Int) ranges, ^(vector-of Int) str]\n\nJoker return type: [(atom-of go.std.debug.dwarf/Data) Error]"
;;   {:added "1.0"
;;    :go "__new(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__abbrev)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__aranges)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__frame)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__info)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__line)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__pubnames)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__ranges)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__str)))"}
;;   [^Object __abbrev, ^Object __aranges, ^Object __frame, ^Object __info, ^Object __line, ^Object __pubnames, ^Object __ranges, ^Object __str])

JOKER TYPE go.std.debug.dwarf/AddrType:
(def
  ^{:doc "An AddrType represents a machine address type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_AddrType"}
  AddrType)

JOKER TYPE go.std.debug.dwarf/ArrayType:
(def
  ^{:doc "An ArrayType represents a fixed size array type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayType"}
  ArrayType)

JOKER TYPE go.std.debug.dwarf/Attr:
(def
  ^{:doc "An Attr identifies the attribute type in a DWARF Entry's Field.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Attr"}
  Attr)

JOKER TYPE go.std.debug.dwarf/BasicType:
(def
  ^{:doc "A BasicType holds fields common to all basic types.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BasicType"}
  BasicType)

JOKER TYPE go.std.debug.dwarf/BoolType:
(def
  ^{:doc "A BoolType represents a boolean type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BoolType"}
  BoolType)

JOKER TYPE go.std.debug.dwarf/CharType:
(def
  ^{:doc "A CharType represents a signed character type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CharType"}
  CharType)

JOKER TYPE go.std.debug.dwarf/Class:
(def
  ^{:doc "A Class is the DWARF 4 class of an attribute value.\n\nIn general, a given attribute's value may take on one of several\npossible classes defined by DWARF, each of which leads to a\nslightly different interpretation of the attribute.\n\nDWARF version 4 distinguishes attribute value classes more finely\nthan previous versions of DWARF. The reader will disambiguate\ncoarser classes from earlier versions of DWARF into the appropriate\nDWARF 4 class. For example, DWARF 2 uses \"constant\" for constants\nas well as all types of section offsets, but the reader will\ncanonicalize attributes in DWARF 2 files that refer to section\noffsets to one of the Class*Ptr classes, even though these classes\nwere only defined in DWARF 3.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Class"}
  Class)

JOKER TYPE go.std.debug.dwarf/CommonType:
(def
  ^{:doc "A CommonType holds fields common to multiple types.\nIf a field is not known or not applicable for a given type,\nthe zero value is used.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CommonType"}
  CommonType)

JOKER TYPE go.std.debug.dwarf/ComplexType:
(def
  ^{:doc "A ComplexType represents a complex floating point type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ComplexType"}
  ComplexType)

JOKER TYPE go.std.debug.dwarf/Data:
(def
  ^{:doc "Data represents the DWARF debugging information\nloaded from an executable file (for example, an ELF or Mach-O executable).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Data"}
  Data)

JOKER TYPE go.std.debug.dwarf/DecodeError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_DecodeError"}
  DecodeError)

JOKER TYPE go.std.debug.dwarf/DotDotDotType:
(def
  ^{:doc "A DotDotDotType represents the variadic ... function parameter.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DotDotDotType"}
  DotDotDotType)

JOKER TYPE go.std.debug.dwarf/Entry:
(def
  ^{:doc "An entry is a sequence of attribute/value pairs.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Entry"}
  Entry)

JOKER TYPE go.std.debug.dwarf/EnumType:
(def
  ^{:doc "An EnumType represents an enumerated type.\nThe only indication of its native integer type is its ByteSize\n(inside CommonType).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_EnumType"}
  EnumType)

JOKER TYPE go.std.debug.dwarf/EnumValue:
(def
  ^{:doc "An EnumValue represents a single enumeration value.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_EnumValue"}
  EnumValue)

JOKER TYPE go.std.debug.dwarf/Field:
(def
  ^{:doc "A Field is a single attribute/value pair in an Entry.\n\nA value can be one of several \"attribute classes\" defined by DWARF.\nThe Go types corresponding to each class are:\n\n   DWARF class       Go type        Class\n   -----------       -------        -----\n   address           uint64         ClassAddress\n   block             []byte         ClassBlock\n   constant          int64          ClassConstant\n   flag              bool           ClassFlag\n   reference\n     to info         dwarf.Offset   ClassReference\n     to type unit    uint64         ClassReferenceSig\n   string            string         ClassString\n   exprloc           []byte         ClassExprLoc\n   lineptr           int64          ClassLinePtr\n   loclistptr        int64          ClassLocListPtr\n   macptr            int64          ClassMacPtr\n   rangelistptr      int64          ClassRangeListPtr\n\nFor unrecognized or vendor-defined attributes, Class may be\nClassUnknown.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Field"}
  Field)

JOKER TYPE go.std.debug.dwarf/FloatType:
(def
  ^{:doc "A FloatType represents a floating point type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FloatType"}
  FloatType)

JOKER TYPE go.std.debug.dwarf/FuncType:
(def
  ^{:doc "A FuncType represents a function type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FuncType"}
  FuncType)

JOKER TYPE go.std.debug.dwarf/IntType:
(def
  ^{:doc "An IntType represents a signed integer type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IntType"}
  IntType)

JOKER TYPE go.std.debug.dwarf/LineEntry:
(def
  ^{:doc "A LineEntry is a row in a DWARF line table.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_LineEntry"}
  LineEntry)

JOKER TYPE go.std.debug.dwarf/LineFile:
(def
  ^{:doc "A LineFile is a source file referenced by a DWARF line table entry.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_LineFile"}
  LineFile)

JOKER TYPE go.std.debug.dwarf/LineReader:
(def
  ^{:doc "A LineReader reads a sequence of LineEntry structures from a DWARF\n\"line\" section for a single compilation unit. LineEntries occur in\norder of increasing PC and each LineEntry gives metadata for the\ninstructions from that LineEntry's PC to just before the next\nLineEntry's PC. The last entry will have its EndSequence field set.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_LineReader"}
  LineReader)

JOKER TYPE go.std.debug.dwarf/LineReaderPos:
(def
  ^{:doc "A LineReaderPos represents a position in a line table.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_LineReaderPos"}
  LineReaderPos)

JOKER TYPE go.std.debug.dwarf/Offset:
(def
  ^{:doc "An Offset represents the location of an Entry within the DWARF info.\n(See Reader.Seek.)\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Offset"}
  Offset)

JOKER TYPE go.std.debug.dwarf/PtrType:
(def
  ^{:doc "A PtrType represents a pointer type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrType"}
  PtrType)

JOKER TYPE go.std.debug.dwarf/QualType:
(def
  ^{:doc "A QualType represents a type that has the C/C++ \"const\", \"restrict\", or \"volatile\" qualifier.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_QualType"}
  QualType)

JOKER TYPE go.std.debug.dwarf/Reader:
(def
  ^{:doc "A Reader allows reading Entry structures from a DWARF ``info'' section.\nThe Entry structures are arranged in a tree. The Reader's Next function\nreturn successive entries from a pre-order traversal of the tree.\nIf an entry has children, its Children field will be true, and the children\nfollow, terminated by an Entry with Tag 0.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Reader"}
  Reader)

JOKER TYPE go.std.debug.dwarf/StructField:
(def
  ^{:doc "A StructField represents a field in a struct, union, or C++ class type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_StructField"}
  StructField)

JOKER TYPE go.std.debug.dwarf/StructType:
(def
  ^{:doc "A StructType represents a struct, union, or C++ class type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_StructType"}
  StructType)

JOKER TYPE go.std.debug.dwarf/Tag:
(def
  ^{:doc "A Tag is the classification (the type) of an Entry.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Tag"}
  Tag)

JOKER TYPE go.std.debug.dwarf/Type:
(def
  ^{:doc "A Type conventionally represents a pointer to any of the\nspecific Type structures (CharType, StructType, etc.).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Type"}
  Type)

JOKER TYPE go.std.debug.dwarf/TypedefType:
(def
  ^{:doc "A TypedefType represents a named type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TypedefType"}
  TypedefType)

JOKER TYPE go.std.debug.dwarf/UcharType:
(def
  ^{:doc "A UcharType represents an unsigned character type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UcharType"}
  UcharType)

JOKER TYPE go.std.debug.dwarf/UintType:
(def
  ^{:doc "A UintType represents an unsigned integer type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UintType"}
  UintType)

JOKER TYPE go.std.debug.dwarf/UnspecifiedType:
(def
  ^{:doc "An UnspecifiedType represents an implicit, unknown, ambiguous or nonexistent type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnspecifiedType"}
  UnspecifiedType)

JOKER TYPE go.std.debug.dwarf/VoidType:
(def
  ^{:doc "A VoidType represents the C void type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_VoidType"}
  VoidType)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["debug/dwarf"]
    :doc "Provides a low-level interface to the debug/dwarf package.\n\nPackage dwarf provides access to DWARF debugging information loaded from\nexecutable files, as defined in the DWARF 2.0 Standard at\nhttp://dwarfstd.org/doc/dwarf-2.0.0.pdf\n"
    :empty false}
  go.std.debug.dwarf)
JOKER CONSTANT ARM_MAGIC_TRAMP_NUMBER from debug/elf/elf.go:
(def
  ^{:doc "Magic number for the elf trampoline, chosen wisely to be an immediate value.\n"
    :added "1.0"
    :tag "Int"
    :go "elf.ARM_MAGIC_TRAMP_NUMBER"}
  ARM_MAGIC_TRAMP_NUMBER)

JOKER CONSTANT COMPRESS_HIOS from debug/elf/elf.go:
(def
  ^{:doc " Last OS-specific.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.COMPRESS_HIOS)"}
  COMPRESS_HIOS)

JOKER CONSTANT COMPRESS_HIPROC from debug/elf/elf.go:
(def
  ^{:doc " Last processor-specific type.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.COMPRESS_HIPROC)"}
  COMPRESS_HIPROC)

JOKER CONSTANT COMPRESS_LOOS from debug/elf/elf.go:
(def
  ^{:doc " First OS-specific.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.COMPRESS_LOOS)"}
  COMPRESS_LOOS)

JOKER CONSTANT COMPRESS_LOPROC from debug/elf/elf.go:
(def
  ^{:doc " First processor-specific type.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.COMPRESS_LOPROC)"}
  COMPRESS_LOPROC)

JOKER CONSTANT COMPRESS_ZLIB from debug/elf/elf.go:
(def
  ^{:doc " ZLIB compression.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.COMPRESS_ZLIB)"}
  COMPRESS_ZLIB)

JOKER CONSTANT DF_BIND_NOW from debug/elf/elf.go:
(def
  ^{:doc " Indicates that the dynamic linker should\n\t   process all relocations for the object\n\t   containing this entry before transferring\n\t   control to the program.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DF_BIND_NOW)"}
  DF_BIND_NOW)

JOKER CONSTANT DF_ORIGIN from debug/elf/elf.go:
(def
  ^{:doc " Indicates that the object being loaded may\n\t   make reference to the\n\t   $ORIGIN substitution string\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DF_ORIGIN)"}
  DF_ORIGIN)

JOKER CONSTANT DF_STATIC_TLS from debug/elf/elf.go:
(def
  ^{:doc " Indicates that the shared object or\n\t   executable contains code using a static\n\t   thread-local storage scheme.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DF_STATIC_TLS)"}
  DF_STATIC_TLS)

JOKER CONSTANT DF_SYMBOLIC from debug/elf/elf.go:
(def
  ^{:doc " Indicates \"symbolic\" linking.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DF_SYMBOLIC)"}
  DF_SYMBOLIC)

JOKER CONSTANT DF_TEXTREL from debug/elf/elf.go:
(def
  ^{:doc " Indicates there may be relocations in non-writable segments.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DF_TEXTREL)"}
  DF_TEXTREL)

JOKER CONSTANT DT_BIND_NOW from debug/elf/elf.go:
(def
  ^{:doc " [sup]\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_BIND_NOW)"}
  DT_BIND_NOW)

JOKER CONSTANT DT_DEBUG from debug/elf/elf.go:
(def
  ^{:doc " Reserved (not used).\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_DEBUG)"}
  DT_DEBUG)

JOKER CONSTANT DT_ENCODING from debug/elf/elf.go:
(def
  ^{:doc " Values greater than or equal to DT_ENCODING\n\t   and less than DT_LOOS follow the rules for\n\t   the interpretation of the d_un union\n\t   as follows: even == 'd_ptr', even == 'd_val'\n\t   or none\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_ENCODING)"}
  DT_ENCODING)

JOKER CONSTANT DT_FINI from debug/elf/elf.go:
(def
  ^{:doc " Address of finalization function.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_FINI)"}
  DT_FINI)

JOKER CONSTANT DT_FINI_ARRAY from debug/elf/elf.go:
(def
  ^{:doc " Address of the array of pointers to termination functions\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_FINI_ARRAY)"}
  DT_FINI_ARRAY)

JOKER CONSTANT DT_FINI_ARRAYSZ from debug/elf/elf.go:
(def
  ^{:doc " Size in bytes of the array of termination functions.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_FINI_ARRAYSZ)"}
  DT_FINI_ARRAYSZ)

JOKER CONSTANT DT_FLAGS from debug/elf/elf.go:
(def
  ^{:doc " Object specific flag values.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_FLAGS)"}
  DT_FLAGS)

JOKER CONSTANT DT_HASH from debug/elf/elf.go:
(def
  ^{:doc " Address of symbol hash table.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_HASH)"}
  DT_HASH)

JOKER CONSTANT DT_HIOS from debug/elf/elf.go:
(def
  ^{:doc " Last OS-specific\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_HIOS)"}
  DT_HIOS)

JOKER CONSTANT DT_HIPROC from debug/elf/elf.go:
(def
  ^{:doc " Last processor-specific type.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_HIPROC)"}
  DT_HIPROC)

JOKER CONSTANT DT_INIT from debug/elf/elf.go:
(def
  ^{:doc " Address of initialization function.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_INIT)"}
  DT_INIT)

JOKER CONSTANT DT_INIT_ARRAY from debug/elf/elf.go:
(def
  ^{:doc " Address of the array of pointers to initialization functions\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_INIT_ARRAY)"}
  DT_INIT_ARRAY)

JOKER CONSTANT DT_INIT_ARRAYSZ from debug/elf/elf.go:
(def
  ^{:doc " Size in bytes of the array of initialization functions.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_INIT_ARRAYSZ)"}
  DT_INIT_ARRAYSZ)

JOKER CONSTANT DT_JMPREL from debug/elf/elf.go:
(def
  ^{:doc " Address of PLT relocations.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_JMPREL)"}
  DT_JMPREL)

JOKER CONSTANT DT_LOOS from debug/elf/elf.go:
(def
  ^{:doc " First OS-specific\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_LOOS)"}
  DT_LOOS)

JOKER CONSTANT DT_LOPROC from debug/elf/elf.go:
(def
  ^{:doc " First processor-specific type.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_LOPROC)"}
  DT_LOPROC)

JOKER CONSTANT DT_NEEDED from debug/elf/elf.go:
(def
  ^{:doc " String table offset of a needed shared library.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_NEEDED)"}
  DT_NEEDED)

JOKER CONSTANT DT_NULL from debug/elf/elf.go:
(def
  ^{:doc " Terminating entry.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_NULL)"}
  DT_NULL)

JOKER CONSTANT DT_PLTGOT from debug/elf/elf.go:
(def
  ^{:doc " Processor-dependent address.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_PLTGOT)"}
  DT_PLTGOT)

JOKER CONSTANT DT_PLTREL from debug/elf/elf.go:
(def
  ^{:doc " Type of relocation used for PLT.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_PLTREL)"}
  DT_PLTREL)

JOKER CONSTANT DT_PLTRELSZ from debug/elf/elf.go:
(def
  ^{:doc " Total size in bytes of PLT relocations.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_PLTRELSZ)"}
  DT_PLTRELSZ)

JOKER CONSTANT DT_PREINIT_ARRAY from debug/elf/elf.go:
(def
  ^{:doc " Address of the array of pointers to pre-initialization functions.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_PREINIT_ARRAY)"}
  DT_PREINIT_ARRAY)

JOKER CONSTANT DT_PREINIT_ARRAYSZ from debug/elf/elf.go:
(def
  ^{:doc " Size in bytes of the array of pre-initialization functions.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_PREINIT_ARRAYSZ)"}
  DT_PREINIT_ARRAYSZ)

JOKER CONSTANT DT_REL from debug/elf/elf.go:
(def
  ^{:doc " Address of ElfNN_Rel relocations.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_REL)"}
  DT_REL)

JOKER CONSTANT DT_RELA from debug/elf/elf.go:
(def
  ^{:doc " Address of ElfNN_Rela relocations.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_RELA)"}
  DT_RELA)

JOKER CONSTANT DT_RELAENT from debug/elf/elf.go:
(def
  ^{:doc " Size of each ElfNN_Rela relocation entry.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_RELAENT)"}
  DT_RELAENT)

JOKER CONSTANT DT_RELASZ from debug/elf/elf.go:
(def
  ^{:doc " Total size of ElfNN_Rela relocations.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_RELASZ)"}
  DT_RELASZ)

JOKER CONSTANT DT_RELENT from debug/elf/elf.go:
(def
  ^{:doc " Size of each ElfNN_Rel relocation.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_RELENT)"}
  DT_RELENT)

JOKER CONSTANT DT_RELSZ from debug/elf/elf.go:
(def
  ^{:doc " Total size of ElfNN_Rel relocations.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_RELSZ)"}
  DT_RELSZ)

JOKER CONSTANT DT_RPATH from debug/elf/elf.go:
(def
  ^{:doc " String table offset of library path. [sup]\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_RPATH)"}
  DT_RPATH)

JOKER CONSTANT DT_RUNPATH from debug/elf/elf.go:
(def
  ^{:doc " String table offset of a null-terminated library search path string.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_RUNPATH)"}
  DT_RUNPATH)

JOKER CONSTANT DT_SONAME from debug/elf/elf.go:
(def
  ^{:doc " String table offset of shared object name.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_SONAME)"}
  DT_SONAME)

JOKER CONSTANT DT_STRSZ from debug/elf/elf.go:
(def
  ^{:doc " Size of string table.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_STRSZ)"}
  DT_STRSZ)

JOKER CONSTANT DT_STRTAB from debug/elf/elf.go:
(def
  ^{:doc " Address of string table.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_STRTAB)"}
  DT_STRTAB)

JOKER CONSTANT DT_SYMBOLIC from debug/elf/elf.go:
(def
  ^{:doc " Indicates \"symbolic\" linking. [sup]\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_SYMBOLIC)"}
  DT_SYMBOLIC)

JOKER CONSTANT DT_SYMENT from debug/elf/elf.go:
(def
  ^{:doc " Size of each symbol table entry.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_SYMENT)"}
  DT_SYMENT)

JOKER CONSTANT DT_SYMTAB from debug/elf/elf.go:
(def
  ^{:doc " Address of symbol table.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_SYMTAB)"}
  DT_SYMTAB)

JOKER CONSTANT DT_TEXTREL from debug/elf/elf.go:
(def
  ^{:doc " Indicates there may be relocations in non-writable segments. [sup]\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_TEXTREL)"}
  DT_TEXTREL)

JOKER CONSTANT DT_VERNEED from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_VERNEED)"}
  DT_VERNEED)

JOKER CONSTANT DT_VERNEEDNUM from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_VERNEEDNUM)"}
  DT_VERNEEDNUM)

JOKER CONSTANT DT_VERSYM from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.DT_VERSYM)"}
  DT_VERSYM)

JOKER CONSTANT EI_ABIVERSION from debug/elf/elf.go:
(def
  ^{:doc " ABI version\n"
    :added "1.0"
    :tag "Int"
    :go "elf.EI_ABIVERSION"}
  EI_ABIVERSION)

JOKER CONSTANT EI_CLASS from debug/elf/elf.go:
(def
  ^{:doc " Class of machine.\n"
    :added "1.0"
    :tag "Int"
    :go "elf.EI_CLASS"}
  EI_CLASS)

JOKER CONSTANT EI_DATA from debug/elf/elf.go:
(def
  ^{:doc " Data format.\n"
    :added "1.0"
    :tag "Int"
    :go "elf.EI_DATA"}
  EI_DATA)

JOKER CONSTANT EI_NIDENT from debug/elf/elf.go:
(def
  ^{:doc " Size of e_ident array.\n"
    :added "1.0"
    :tag "Int"
    :go "elf.EI_NIDENT"}
  EI_NIDENT)

JOKER CONSTANT EI_OSABI from debug/elf/elf.go:
(def
  ^{:doc " Operating system / ABI identification\n"
    :added "1.0"
    :tag "Int"
    :go "elf.EI_OSABI"}
  EI_OSABI)

JOKER CONSTANT EI_PAD from debug/elf/elf.go:
(def
  ^{:doc " Start of padding (per SVR4 ABI).\n"
    :added "1.0"
    :tag "Int"
    :go "elf.EI_PAD"}
  EI_PAD)

JOKER CONSTANT EI_VERSION from debug/elf/elf.go:
(def
  ^{:doc " ELF format version.\n"
    :added "1.0"
    :tag "Int"
    :go "elf.EI_VERSION"}
  EI_VERSION)

JOKER CONSTANT ELFCLASS32 from debug/elf/elf.go:
(def
  ^{:doc " 32-bit architecture.\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFCLASS32))"}
  ELFCLASS32)

JOKER CONSTANT ELFCLASS64 from debug/elf/elf.go:
(def
  ^{:doc " 64-bit architecture.\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFCLASS64))"}
  ELFCLASS64)

JOKER CONSTANT ELFCLASSNONE from debug/elf/elf.go:
(def
  ^{:doc " Unknown class.\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFCLASSNONE))"}
  ELFCLASSNONE)

JOKER CONSTANT ELFDATA2LSB from debug/elf/elf.go:
(def
  ^{:doc " 2's complement little-endian.\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFDATA2LSB))"}
  ELFDATA2LSB)

JOKER CONSTANT ELFDATA2MSB from debug/elf/elf.go:
(def
  ^{:doc " 2's complement big-endian.\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFDATA2MSB))"}
  ELFDATA2MSB)

JOKER CONSTANT ELFDATANONE from debug/elf/elf.go:
(def
  ^{:doc " Unknown data format.\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFDATANONE))"}
  ELFDATANONE)

JOKER CONSTANT ELFMAG from debug/elf/elf.go:
(def
  ^{:doc "Initial magic number for ELF files.\n"
    :added "1.0"
    :tag "String"
    :go "elf.ELFMAG"}
  ELFMAG)

JOKER CONSTANT ELFOSABI_86OPEN from debug/elf/elf.go:
(def
  ^{:doc " 86Open common IA32 ABI\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFOSABI_86OPEN))"}
  ELFOSABI_86OPEN)

JOKER CONSTANT ELFOSABI_AIX from debug/elf/elf.go:
(def
  ^{:doc " AIX\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFOSABI_AIX))"}
  ELFOSABI_AIX)

JOKER CONSTANT ELFOSABI_ARM from debug/elf/elf.go:
(def
  ^{:doc " ARM\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFOSABI_ARM))"}
  ELFOSABI_ARM)

JOKER CONSTANT ELFOSABI_AROS from debug/elf/elf.go:
(def
  ^{:doc " Amiga Research OS\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFOSABI_AROS))"}
  ELFOSABI_AROS)

JOKER CONSTANT ELFOSABI_CLOUDABI from debug/elf/elf.go:
(def
  ^{:doc " Nuxi CloudABI\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFOSABI_CLOUDABI))"}
  ELFOSABI_CLOUDABI)

JOKER CONSTANT ELFOSABI_FENIXOS from debug/elf/elf.go:
(def
  ^{:doc " The FenixOS highly scalable multi-core OS\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFOSABI_FENIXOS))"}
  ELFOSABI_FENIXOS)

JOKER CONSTANT ELFOSABI_FREEBSD from debug/elf/elf.go:
(def
  ^{:doc " FreeBSD\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFOSABI_FREEBSD))"}
  ELFOSABI_FREEBSD)

JOKER CONSTANT ELFOSABI_HPUX from debug/elf/elf.go:
(def
  ^{:doc " HP-UX operating system\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFOSABI_HPUX))"}
  ELFOSABI_HPUX)

JOKER CONSTANT ELFOSABI_HURD from debug/elf/elf.go:
(def
  ^{:doc " GNU/Hurd\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFOSABI_HURD))"}
  ELFOSABI_HURD)

JOKER CONSTANT ELFOSABI_IRIX from debug/elf/elf.go:
(def
  ^{:doc " IRIX\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFOSABI_IRIX))"}
  ELFOSABI_IRIX)

JOKER CONSTANT ELFOSABI_LINUX from debug/elf/elf.go:
(def
  ^{:doc " GNU/Linux\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFOSABI_LINUX))"}
  ELFOSABI_LINUX)

JOKER CONSTANT ELFOSABI_MODESTO from debug/elf/elf.go:
(def
  ^{:doc " Novell Modesto\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFOSABI_MODESTO))"}
  ELFOSABI_MODESTO)

JOKER CONSTANT ELFOSABI_NETBSD from debug/elf/elf.go:
(def
  ^{:doc " NetBSD\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFOSABI_NETBSD))"}
  ELFOSABI_NETBSD)

JOKER CONSTANT ELFOSABI_NONE from debug/elf/elf.go:
(def
  ^{:doc " UNIX System V ABI\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFOSABI_NONE))"}
  ELFOSABI_NONE)

JOKER CONSTANT ELFOSABI_NSK from debug/elf/elf.go:
(def
  ^{:doc " HP Non-Stop Kernel\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFOSABI_NSK))"}
  ELFOSABI_NSK)

JOKER CONSTANT ELFOSABI_OPENBSD from debug/elf/elf.go:
(def
  ^{:doc " OpenBSD\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFOSABI_OPENBSD))"}
  ELFOSABI_OPENBSD)

JOKER CONSTANT ELFOSABI_OPENVMS from debug/elf/elf.go:
(def
  ^{:doc " Open VMS\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFOSABI_OPENVMS))"}
  ELFOSABI_OPENVMS)

JOKER CONSTANT ELFOSABI_SOLARIS from debug/elf/elf.go:
(def
  ^{:doc " Solaris\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFOSABI_SOLARIS))"}
  ELFOSABI_SOLARIS)

JOKER CONSTANT ELFOSABI_STANDALONE from debug/elf/elf.go:
(def
  ^{:doc " Standalone (embedded) application\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFOSABI_STANDALONE))"}
  ELFOSABI_STANDALONE)

JOKER CONSTANT ELFOSABI_TRU64 from debug/elf/elf.go:
(def
  ^{:doc " TRU64 UNIX\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.ELFOSABI_TRU64))"}
  ELFOSABI_TRU64)

JOKER CONSTANT EM_386 from debug/elf/elf.go:
(def
  ^{:doc " Intel i386.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_386))"}
  EM_386)

JOKER CONSTANT EM_486 from debug/elf/elf.go:
(def
  ^{:doc " Non-standard or deprecated.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_486))"}
  EM_486)

JOKER CONSTANT EM_56800EX from debug/elf/elf.go:
(def
  ^{:doc " Freescale 56800EX Digital Signal Controller (DSC)\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_56800EX))"}
  EM_56800EX)

JOKER CONSTANT EM_68HC05 from debug/elf/elf.go:
(def
  ^{:doc " Motorola MC68HC05 Microcontroller\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_68HC05))"}
  EM_68HC05)

JOKER CONSTANT EM_68HC08 from debug/elf/elf.go:
(def
  ^{:doc " Motorola MC68HC08 Microcontroller\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_68HC08))"}
  EM_68HC08)

JOKER CONSTANT EM_68HC11 from debug/elf/elf.go:
(def
  ^{:doc " Motorola MC68HC11 Microcontroller\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_68HC11))"}
  EM_68HC11)

JOKER CONSTANT EM_68HC12 from debug/elf/elf.go:
(def
  ^{:doc " Motorola M68HC12.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_68HC12))"}
  EM_68HC12)

JOKER CONSTANT EM_68HC16 from debug/elf/elf.go:
(def
  ^{:doc " Motorola MC68HC16 Microcontroller\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_68HC16))"}
  EM_68HC16)

JOKER CONSTANT EM_68K from debug/elf/elf.go:
(def
  ^{:doc " Motorola 68000.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_68K))"}
  EM_68K)

JOKER CONSTANT EM_78KOR from debug/elf/elf.go:
(def
  ^{:doc " Renesas 78KOR family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_78KOR))"}
  EM_78KOR)

JOKER CONSTANT EM_8051 from debug/elf/elf.go:
(def
  ^{:doc " Intel 8051 and variants\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_8051))"}
  EM_8051)

JOKER CONSTANT EM_860 from debug/elf/elf.go:
(def
  ^{:doc " Intel i860.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_860))"}
  EM_860)

JOKER CONSTANT EM_88K from debug/elf/elf.go:
(def
  ^{:doc " Motorola 88000.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_88K))"}
  EM_88K)

JOKER CONSTANT EM_960 from debug/elf/elf.go:
(def
  ^{:doc " Intel 80960.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_960))"}
  EM_960)

JOKER CONSTANT EM_AARCH64 from debug/elf/elf.go:
(def
  ^{:doc " ARM 64-bit Architecture (AArch64)\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_AARCH64))"}
  EM_AARCH64)

JOKER CONSTANT EM_ALPHA from debug/elf/elf.go:
(def
  ^{:doc " Alpha (written in the absence of an ABI)\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_ALPHA))"}
  EM_ALPHA)

JOKER CONSTANT EM_ALPHA_STD from debug/elf/elf.go:
(def
  ^{:doc " Digital Alpha (standard value).\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_ALPHA_STD))"}
  EM_ALPHA_STD)

JOKER CONSTANT EM_ALTERA_NIOS2 from debug/elf/elf.go:
(def
  ^{:doc " Altera Nios II soft-core processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_ALTERA_NIOS2))"}
  EM_ALTERA_NIOS2)

JOKER CONSTANT EM_AMDGPU from debug/elf/elf.go:
(def
  ^{:doc " AMD GPU architecture\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_AMDGPU))"}
  EM_AMDGPU)

JOKER CONSTANT EM_ARC from debug/elf/elf.go:
(def
  ^{:doc " Argonaut RISC Core.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_ARC))"}
  EM_ARC)

JOKER CONSTANT EM_ARCA from debug/elf/elf.go:
(def
  ^{:doc " Arca RISC Microprocessor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_ARCA))"}
  EM_ARCA)

JOKER CONSTANT EM_ARC_COMPACT from debug/elf/elf.go:
(def
  ^{:doc " ARC International ARCompact processor (old spelling/synonym: EM_ARC_A5)\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_ARC_COMPACT))"}
  EM_ARC_COMPACT)

JOKER CONSTANT EM_ARC_COMPACT2 from debug/elf/elf.go:
(def
  ^{:doc " Synopsys ARCompact V2\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_ARC_COMPACT2))"}
  EM_ARC_COMPACT2)

JOKER CONSTANT EM_ARM from debug/elf/elf.go:
(def
  ^{:doc " ARM.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_ARM))"}
  EM_ARM)

JOKER CONSTANT EM_AVR from debug/elf/elf.go:
(def
  ^{:doc " Atmel AVR 8-bit microcontroller\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_AVR))"}
  EM_AVR)

JOKER CONSTANT EM_AVR32 from debug/elf/elf.go:
(def
  ^{:doc " Atmel Corporation 32-bit microprocessor family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_AVR32))"}
  EM_AVR32)

JOKER CONSTANT EM_BA1 from debug/elf/elf.go:
(def
  ^{:doc " Beyond BA1 CPU architecture\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_BA1))"}
  EM_BA1)

JOKER CONSTANT EM_BA2 from debug/elf/elf.go:
(def
  ^{:doc " Beyond BA2 CPU architecture\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_BA2))"}
  EM_BA2)

JOKER CONSTANT EM_BLACKFIN from debug/elf/elf.go:
(def
  ^{:doc " Analog Devices Blackfin (DSP) processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_BLACKFIN))"}
  EM_BLACKFIN)

JOKER CONSTANT EM_BPF from debug/elf/elf.go:
(def
  ^{:doc " Linux BPF – in-kernel virtual machine\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_BPF))"}
  EM_BPF)

JOKER CONSTANT EM_C166 from debug/elf/elf.go:
(def
  ^{:doc " Infineon C16x/XC16x processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_C166))"}
  EM_C166)

JOKER CONSTANT EM_CDP from debug/elf/elf.go:
(def
  ^{:doc " Paneve CDP architecture family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_CDP))"}
  EM_CDP)

JOKER CONSTANT EM_CE from debug/elf/elf.go:
(def
  ^{:doc " Freescale Communication Engine RISC core\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_CE))"}
  EM_CE)

JOKER CONSTANT EM_CLOUDSHIELD from debug/elf/elf.go:
(def
  ^{:doc " CloudShield architecture family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_CLOUDSHIELD))"}
  EM_CLOUDSHIELD)

JOKER CONSTANT EM_COGE from debug/elf/elf.go:
(def
  ^{:doc " Cognitive Smart Memory Processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_COGE))"}
  EM_COGE)

JOKER CONSTANT EM_COLDFIRE from debug/elf/elf.go:
(def
  ^{:doc " Motorola ColdFire.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_COLDFIRE))"}
  EM_COLDFIRE)

JOKER CONSTANT EM_COOL from debug/elf/elf.go:
(def
  ^{:doc " Bluechip Systems CoolEngine\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_COOL))"}
  EM_COOL)

JOKER CONSTANT EM_COREA_1ST from debug/elf/elf.go:
(def
  ^{:doc " KIPO-KAIST Core-A 1st generation processor family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_COREA_1ST))"}
  EM_COREA_1ST)

JOKER CONSTANT EM_COREA_2ND from debug/elf/elf.go:
(def
  ^{:doc " KIPO-KAIST Core-A 2nd generation processor family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_COREA_2ND))"}
  EM_COREA_2ND)

JOKER CONSTANT EM_CR from debug/elf/elf.go:
(def
  ^{:doc " National Semiconductor CompactRISC microprocessor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_CR))"}
  EM_CR)

JOKER CONSTANT EM_CR16 from debug/elf/elf.go:
(def
  ^{:doc " National Semiconductor CompactRISC CR16 16-bit microprocessor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_CR16))"}
  EM_CR16)

JOKER CONSTANT EM_CRAYNV2 from debug/elf/elf.go:
(def
  ^{:doc " Cray Inc. NV2 vector architecture\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_CRAYNV2))"}
  EM_CRAYNV2)

JOKER CONSTANT EM_CRIS from debug/elf/elf.go:
(def
  ^{:doc " Axis Communications 32-bit embedded processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_CRIS))"}
  EM_CRIS)

JOKER CONSTANT EM_CRX from debug/elf/elf.go:
(def
  ^{:doc " National Semiconductor CompactRISC CRX microprocessor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_CRX))"}
  EM_CRX)

JOKER CONSTANT EM_CSR_KALIMBA from debug/elf/elf.go:
(def
  ^{:doc " CSR Kalimba architecture family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_CSR_KALIMBA))"}
  EM_CSR_KALIMBA)

JOKER CONSTANT EM_CUDA from debug/elf/elf.go:
(def
  ^{:doc " NVIDIA CUDA architecture\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_CUDA))"}
  EM_CUDA)

JOKER CONSTANT EM_CYPRESS_M8C from debug/elf/elf.go:
(def
  ^{:doc " Cypress M8C microprocessor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_CYPRESS_M8C))"}
  EM_CYPRESS_M8C)

JOKER CONSTANT EM_D10V from debug/elf/elf.go:
(def
  ^{:doc " Mitsubishi D10V\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_D10V))"}
  EM_D10V)

JOKER CONSTANT EM_D30V from debug/elf/elf.go:
(def
  ^{:doc " Mitsubishi D30V\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_D30V))"}
  EM_D30V)

JOKER CONSTANT EM_DSP24 from debug/elf/elf.go:
(def
  ^{:doc " New Japan Radio (NJR) 24-bit DSP Processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_DSP24))"}
  EM_DSP24)

JOKER CONSTANT EM_DSPIC30F from debug/elf/elf.go:
(def
  ^{:doc " Microchip Technology dsPIC30F Digital Signal Controller\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_DSPIC30F))"}
  EM_DSPIC30F)

JOKER CONSTANT EM_DXP from debug/elf/elf.go:
(def
  ^{:doc " Icera Semiconductor Inc. Deep Execution Processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_DXP))"}
  EM_DXP)

JOKER CONSTANT EM_ECOG1 from debug/elf/elf.go:
(def
  ^{:doc " Cyan Technology eCOG1X family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_ECOG1))"}
  EM_ECOG1)

JOKER CONSTANT EM_ECOG16 from debug/elf/elf.go:
(def
  ^{:doc " Cyan Technology eCOG16 family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_ECOG16))"}
  EM_ECOG16)

JOKER CONSTANT EM_ECOG1X from debug/elf/elf.go:
(def
  ^{:doc " Cyan Technology eCOG1X family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_ECOG1X))"}
  EM_ECOG1X)

JOKER CONSTANT EM_ECOG2 from debug/elf/elf.go:
(def
  ^{:doc " Cyan Technology eCOG2 microprocessor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_ECOG2))"}
  EM_ECOG2)

JOKER CONSTANT EM_ETPU from debug/elf/elf.go:
(def
  ^{:doc " Freescale Extended Time Processing Unit\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_ETPU))"}
  EM_ETPU)

JOKER CONSTANT EM_EXCESS from debug/elf/elf.go:
(def
  ^{:doc " eXcess: 16/32/64-bit configurable embedded CPU\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_EXCESS))"}
  EM_EXCESS)

JOKER CONSTANT EM_F2MC16 from debug/elf/elf.go:
(def
  ^{:doc " Fujitsu F2MC16\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_F2MC16))"}
  EM_F2MC16)

JOKER CONSTANT EM_FIREPATH from debug/elf/elf.go:
(def
  ^{:doc " Element 14 64-bit DSP Processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_FIREPATH))"}
  EM_FIREPATH)

JOKER CONSTANT EM_FR20 from debug/elf/elf.go:
(def
  ^{:doc " Fujitsu FR20.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_FR20))"}
  EM_FR20)

JOKER CONSTANT EM_FR30 from debug/elf/elf.go:
(def
  ^{:doc " Fujitsu FR30\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_FR30))"}
  EM_FR30)

JOKER CONSTANT EM_FT32 from debug/elf/elf.go:
(def
  ^{:doc " FTDI Chip FT32 high performance 32-bit RISC architecture\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_FT32))"}
  EM_FT32)

JOKER CONSTANT EM_FX66 from debug/elf/elf.go:
(def
  ^{:doc " Siemens FX66 microcontroller\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_FX66))"}
  EM_FX66)

JOKER CONSTANT EM_H8S from debug/elf/elf.go:
(def
  ^{:doc " Hitachi H8S.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_H8S))"}
  EM_H8S)

JOKER CONSTANT EM_H8_300 from debug/elf/elf.go:
(def
  ^{:doc " Hitachi H8/300.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_H8_300))"}
  EM_H8_300)

JOKER CONSTANT EM_H8_300H from debug/elf/elf.go:
(def
  ^{:doc " Hitachi H8/300H.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_H8_300H))"}
  EM_H8_300H)

JOKER CONSTANT EM_H8_500 from debug/elf/elf.go:
(def
  ^{:doc " Hitachi H8/500.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_H8_500))"}
  EM_H8_500)

JOKER CONSTANT EM_HUANY from debug/elf/elf.go:
(def
  ^{:doc " Harvard University machine-independent object files\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_HUANY))"}
  EM_HUANY)

JOKER CONSTANT EM_IA_64 from debug/elf/elf.go:
(def
  ^{:doc " Intel IA-64 Processor.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_IA_64))"}
  EM_IA_64)

JOKER CONSTANT EM_INTEL205 from debug/elf/elf.go:
(def
  ^{:doc " Reserved by Intel\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_INTEL205))"}
  EM_INTEL205)

JOKER CONSTANT EM_INTEL206 from debug/elf/elf.go:
(def
  ^{:doc " Reserved by Intel\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_INTEL206))"}
  EM_INTEL206)

JOKER CONSTANT EM_INTEL207 from debug/elf/elf.go:
(def
  ^{:doc " Reserved by Intel\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_INTEL207))"}
  EM_INTEL207)

JOKER CONSTANT EM_INTEL208 from debug/elf/elf.go:
(def
  ^{:doc " Reserved by Intel\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_INTEL208))"}
  EM_INTEL208)

JOKER CONSTANT EM_INTEL209 from debug/elf/elf.go:
(def
  ^{:doc " Reserved by Intel\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_INTEL209))"}
  EM_INTEL209)

JOKER CONSTANT EM_IP2K from debug/elf/elf.go:
(def
  ^{:doc " Ubicom IP2xxx microcontroller family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_IP2K))"}
  EM_IP2K)

JOKER CONSTANT EM_JAVELIN from debug/elf/elf.go:
(def
  ^{:doc " Infineon Technologies 32-bit embedded processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_JAVELIN))"}
  EM_JAVELIN)

JOKER CONSTANT EM_K10M from debug/elf/elf.go:
(def
  ^{:doc " Intel K10M\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_K10M))"}
  EM_K10M)

JOKER CONSTANT EM_KM32 from debug/elf/elf.go:
(def
  ^{:doc " KM211 KM32 32-bit processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_KM32))"}
  EM_KM32)

JOKER CONSTANT EM_KMX16 from debug/elf/elf.go:
(def
  ^{:doc " KM211 KMX16 16-bit processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_KMX16))"}
  EM_KMX16)

JOKER CONSTANT EM_KMX32 from debug/elf/elf.go:
(def
  ^{:doc " KM211 KMX32 32-bit processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_KMX32))"}
  EM_KMX32)

JOKER CONSTANT EM_KMX8 from debug/elf/elf.go:
(def
  ^{:doc " KM211 KMX8 8-bit processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_KMX8))"}
  EM_KMX8)

JOKER CONSTANT EM_KVARC from debug/elf/elf.go:
(def
  ^{:doc " KM211 KVARC processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_KVARC))"}
  EM_KVARC)

JOKER CONSTANT EM_L10M from debug/elf/elf.go:
(def
  ^{:doc " Intel L10M\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_L10M))"}
  EM_L10M)

JOKER CONSTANT EM_LANAI from debug/elf/elf.go:
(def
  ^{:doc " Lanai 32-bit processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_LANAI))"}
  EM_LANAI)

JOKER CONSTANT EM_LATTICEMICO32 from debug/elf/elf.go:
(def
  ^{:doc " RISC processor for Lattice FPGA architecture\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_LATTICEMICO32))"}
  EM_LATTICEMICO32)

JOKER CONSTANT EM_M16C from debug/elf/elf.go:
(def
  ^{:doc " Renesas M16C series microprocessors\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_M16C))"}
  EM_M16C)

JOKER CONSTANT EM_M32 from debug/elf/elf.go:
(def
  ^{:doc " AT&T WE32100.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_M32))"}
  EM_M32)

JOKER CONSTANT EM_M32C from debug/elf/elf.go:
(def
  ^{:doc " Renesas M32C series microprocessors\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_M32C))"}
  EM_M32C)

JOKER CONSTANT EM_M32R from debug/elf/elf.go:
(def
  ^{:doc " Mitsubishi M32R\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_M32R))"}
  EM_M32R)

JOKER CONSTANT EM_MANIK from debug/elf/elf.go:
(def
  ^{:doc " M2000 Reconfigurable RISC Microprocessor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_MANIK))"}
  EM_MANIK)

JOKER CONSTANT EM_MAX from debug/elf/elf.go:
(def
  ^{:doc " MAX Processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_MAX))"}
  EM_MAX)

JOKER CONSTANT EM_MAXQ30 from debug/elf/elf.go:
(def
  ^{:doc " Dallas Semiconductor MAXQ30 Core Micro-controllers\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_MAXQ30))"}
  EM_MAXQ30)

JOKER CONSTANT EM_MCHP_PIC from debug/elf/elf.go:
(def
  ^{:doc " Microchip 8-bit PIC(r) family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_MCHP_PIC))"}
  EM_MCHP_PIC)

JOKER CONSTANT EM_MCST_ELBRUS from debug/elf/elf.go:
(def
  ^{:doc " MCST Elbrus general purpose hardware architecture\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_MCST_ELBRUS))"}
  EM_MCST_ELBRUS)

JOKER CONSTANT EM_ME16 from debug/elf/elf.go:
(def
  ^{:doc " Toyota ME16 processor.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_ME16))"}
  EM_ME16)

JOKER CONSTANT EM_METAG from debug/elf/elf.go:
(def
  ^{:doc " Imagination Technologies META processor architecture\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_METAG))"}
  EM_METAG)

JOKER CONSTANT EM_MICROBLAZE from debug/elf/elf.go:
(def
  ^{:doc " Xilinx MicroBlaze 32-bit RISC soft processor core\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_MICROBLAZE))"}
  EM_MICROBLAZE)

JOKER CONSTANT EM_MIPS from debug/elf/elf.go:
(def
  ^{:doc " MIPS R3000 Big-Endian only.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_MIPS))"}
  EM_MIPS)

JOKER CONSTANT EM_MIPS_RS3_LE from debug/elf/elf.go:
(def
  ^{:doc " MIPS R3000 Little-Endian.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_MIPS_RS3_LE))"}
  EM_MIPS_RS3_LE)

JOKER CONSTANT EM_MIPS_RS4_BE from debug/elf/elf.go:
(def
  ^{:doc " MIPS R4000 Big-Endian\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_MIPS_RS4_BE))"}
  EM_MIPS_RS4_BE)

JOKER CONSTANT EM_MIPS_X from debug/elf/elf.go:
(def
  ^{:doc " Stanford MIPS-X.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_MIPS_X))"}
  EM_MIPS_X)

JOKER CONSTANT EM_MMA from debug/elf/elf.go:
(def
  ^{:doc " Fujitsu MMA.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_MMA))"}
  EM_MMA)

JOKER CONSTANT EM_MMDSP_PLUS from debug/elf/elf.go:
(def
  ^{:doc " STMicroelectronics 64bit VLIW Data Signal Processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_MMDSP_PLUS))"}
  EM_MMDSP_PLUS)

JOKER CONSTANT EM_MMIX from debug/elf/elf.go:
(def
  ^{:doc " Donald Knuth's educational 64-bit processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_MMIX))"}
  EM_MMIX)

JOKER CONSTANT EM_MN10200 from debug/elf/elf.go:
(def
  ^{:doc " Matsushita MN10200\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_MN10200))"}
  EM_MN10200)

JOKER CONSTANT EM_MN10300 from debug/elf/elf.go:
(def
  ^{:doc " Matsushita MN10300\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_MN10300))"}
  EM_MN10300)

JOKER CONSTANT EM_MOXIE from debug/elf/elf.go:
(def
  ^{:doc " Moxie processor family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_MOXIE))"}
  EM_MOXIE)

JOKER CONSTANT EM_MSP430 from debug/elf/elf.go:
(def
  ^{:doc " Texas Instruments embedded microcontroller msp430\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_MSP430))"}
  EM_MSP430)

JOKER CONSTANT EM_NCPU from debug/elf/elf.go:
(def
  ^{:doc " Sony nCPU.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_NCPU))"}
  EM_NCPU)

JOKER CONSTANT EM_NDR1 from debug/elf/elf.go:
(def
  ^{:doc " Denso NDR1 microprocessor.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_NDR1))"}
  EM_NDR1)

JOKER CONSTANT EM_NDS32 from debug/elf/elf.go:
(def
  ^{:doc " Andes Technology compact code size embedded RISC processor family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_NDS32))"}
  EM_NDS32)

JOKER CONSTANT EM_NONE from debug/elf/elf.go:
(def
  ^{:doc " Unknown machine.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_NONE))"}
  EM_NONE)

JOKER CONSTANT EM_NORC from debug/elf/elf.go:
(def
  ^{:doc " Nanoradio Optimized RISC\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_NORC))"}
  EM_NORC)

JOKER CONSTANT EM_NS32K from debug/elf/elf.go:
(def
  ^{:doc " National Semiconductor 32000 series\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_NS32K))"}
  EM_NS32K)

JOKER CONSTANT EM_OPEN8 from debug/elf/elf.go:
(def
  ^{:doc " Open8 8-bit RISC soft processor core\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_OPEN8))"}
  EM_OPEN8)

JOKER CONSTANT EM_OPENRISC from debug/elf/elf.go:
(def
  ^{:doc " OpenRISC 32-bit embedded processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_OPENRISC))"}
  EM_OPENRISC)

JOKER CONSTANT EM_PARISC from debug/elf/elf.go:
(def
  ^{:doc " HP PA-RISC.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_PARISC))"}
  EM_PARISC)

JOKER CONSTANT EM_PCP from debug/elf/elf.go:
(def
  ^{:doc " Siemens PCP.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_PCP))"}
  EM_PCP)

JOKER CONSTANT EM_PDP10 from debug/elf/elf.go:
(def
  ^{:doc " Digital Equipment Corp. PDP-10\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_PDP10))"}
  EM_PDP10)

JOKER CONSTANT EM_PDP11 from debug/elf/elf.go:
(def
  ^{:doc " Digital Equipment Corp. PDP-11\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_PDP11))"}
  EM_PDP11)

JOKER CONSTANT EM_PDSP from debug/elf/elf.go:
(def
  ^{:doc " Sony DSP Processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_PDSP))"}
  EM_PDSP)

JOKER CONSTANT EM_PJ from debug/elf/elf.go:
(def
  ^{:doc " picoJava\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_PJ))"}
  EM_PJ)

JOKER CONSTANT EM_PPC from debug/elf/elf.go:
(def
  ^{:doc " PowerPC 32-bit.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_PPC))"}
  EM_PPC)

JOKER CONSTANT EM_PPC64 from debug/elf/elf.go:
(def
  ^{:doc " PowerPC 64-bit.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_PPC64))"}
  EM_PPC64)

JOKER CONSTANT EM_PRISM from debug/elf/elf.go:
(def
  ^{:doc " SiTera Prism\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_PRISM))"}
  EM_PRISM)

JOKER CONSTANT EM_QDSP6 from debug/elf/elf.go:
(def
  ^{:doc " QUALCOMM DSP6 Processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_QDSP6))"}
  EM_QDSP6)

JOKER CONSTANT EM_R32C from debug/elf/elf.go:
(def
  ^{:doc " Renesas R32C series microprocessors\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_R32C))"}
  EM_R32C)

JOKER CONSTANT EM_RCE from debug/elf/elf.go:
(def
  ^{:doc " Motorola RCE.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_RCE))"}
  EM_RCE)

JOKER CONSTANT EM_RH32 from debug/elf/elf.go:
(def
  ^{:doc " TRW RH-32.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_RH32))"}
  EM_RH32)

JOKER CONSTANT EM_RISCV from debug/elf/elf.go:
(def
  ^{:doc " RISC-V\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_RISCV))"}
  EM_RISCV)

JOKER CONSTANT EM_RL78 from debug/elf/elf.go:
(def
  ^{:doc " Renesas RL78 family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_RL78))"}
  EM_RL78)

JOKER CONSTANT EM_RS08 from debug/elf/elf.go:
(def
  ^{:doc " Freescale RS08 embedded processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_RS08))"}
  EM_RS08)

JOKER CONSTANT EM_RX from debug/elf/elf.go:
(def
  ^{:doc " Renesas RX family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_RX))"}
  EM_RX)

JOKER CONSTANT EM_S370 from debug/elf/elf.go:
(def
  ^{:doc " IBM System/370.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_S370))"}
  EM_S370)

JOKER CONSTANT EM_S390 from debug/elf/elf.go:
(def
  ^{:doc " IBM System/390.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_S390))"}
  EM_S390)

JOKER CONSTANT EM_SCORE7 from debug/elf/elf.go:
(def
  ^{:doc " Sunplus S+core7 RISC processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_SCORE7))"}
  EM_SCORE7)

JOKER CONSTANT EM_SEP from debug/elf/elf.go:
(def
  ^{:doc " Sharp embedded microprocessor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_SEP))"}
  EM_SEP)

JOKER CONSTANT EM_SE_C17 from debug/elf/elf.go:
(def
  ^{:doc " Seiko Epson C17 family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_SE_C17))"}
  EM_SE_C17)

JOKER CONSTANT EM_SE_C33 from debug/elf/elf.go:
(def
  ^{:doc " S1C33 Family of Seiko Epson processors\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_SE_C33))"}
  EM_SE_C33)

JOKER CONSTANT EM_SH from debug/elf/elf.go:
(def
  ^{:doc " Hitachi SH.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_SH))"}
  EM_SH)

JOKER CONSTANT EM_SHARC from debug/elf/elf.go:
(def
  ^{:doc " Analog Devices SHARC family of 32-bit DSP processors\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_SHARC))"}
  EM_SHARC)

JOKER CONSTANT EM_SLE9X from debug/elf/elf.go:
(def
  ^{:doc " Infineon Technologies SLE9X core\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_SLE9X))"}
  EM_SLE9X)

JOKER CONSTANT EM_SNP1K from debug/elf/elf.go:
(def
  ^{:doc " Trebia SNP 1000 processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_SNP1K))"}
  EM_SNP1K)

JOKER CONSTANT EM_SPARC from debug/elf/elf.go:
(def
  ^{:doc " Sun SPARC.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_SPARC))"}
  EM_SPARC)

JOKER CONSTANT EM_SPARC32PLUS from debug/elf/elf.go:
(def
  ^{:doc " SPARC v8plus.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_SPARC32PLUS))"}
  EM_SPARC32PLUS)

JOKER CONSTANT EM_SPARCV9 from debug/elf/elf.go:
(def
  ^{:doc " SPARC v9 64-bit.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_SPARCV9))"}
  EM_SPARCV9)

JOKER CONSTANT EM_ST100 from debug/elf/elf.go:
(def
  ^{:doc " STMicroelectronics ST100 processor.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_ST100))"}
  EM_ST100)

JOKER CONSTANT EM_ST19 from debug/elf/elf.go:
(def
  ^{:doc " STMicroelectronics ST19 8-bit microcontroller\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_ST19))"}
  EM_ST19)

JOKER CONSTANT EM_ST200 from debug/elf/elf.go:
(def
  ^{:doc " STMicroelectronics (www.st.com) ST200 microcontroller\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_ST200))"}
  EM_ST200)

JOKER CONSTANT EM_ST7 from debug/elf/elf.go:
(def
  ^{:doc " STMicroelectronics ST7 8-bit microcontroller\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_ST7))"}
  EM_ST7)

JOKER CONSTANT EM_ST9PLUS from debug/elf/elf.go:
(def
  ^{:doc " STMicroelectronics ST9+ 8/16 bit microcontroller\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_ST9PLUS))"}
  EM_ST9PLUS)

JOKER CONSTANT EM_STARCORE from debug/elf/elf.go:
(def
  ^{:doc " Motorola Star*Core processor.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_STARCORE))"}
  EM_STARCORE)

JOKER CONSTANT EM_STM8 from debug/elf/elf.go:
(def
  ^{:doc " STMicroeletronics STM8 8-bit microcontroller\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_STM8))"}
  EM_STM8)

JOKER CONSTANT EM_STXP7X from debug/elf/elf.go:
(def
  ^{:doc " STMicroelectronics STxP7x family of configurable and extensible RISC processors\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_STXP7X))"}
  EM_STXP7X)

JOKER CONSTANT EM_SVX from debug/elf/elf.go:
(def
  ^{:doc " Silicon Graphics SVx\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_SVX))"}
  EM_SVX)

JOKER CONSTANT EM_TILE64 from debug/elf/elf.go:
(def
  ^{:doc " Tilera TILE64 multicore architecture family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_TILE64))"}
  EM_TILE64)

JOKER CONSTANT EM_TILEGX from debug/elf/elf.go:
(def
  ^{:doc " Tilera TILE-Gx multicore architecture family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_TILEGX))"}
  EM_TILEGX)

JOKER CONSTANT EM_TILEPRO from debug/elf/elf.go:
(def
  ^{:doc " Tilera TILEPro multicore architecture family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_TILEPRO))"}
  EM_TILEPRO)

JOKER CONSTANT EM_TINYJ from debug/elf/elf.go:
(def
  ^{:doc " Advanced Logic Corp. TinyJ processor.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_TINYJ))"}
  EM_TINYJ)

JOKER CONSTANT EM_TI_ARP32 from debug/elf/elf.go:
(def
  ^{:doc " Texas Instruments Application Specific RISC Processor, 32bit fetch\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_TI_ARP32))"}
  EM_TI_ARP32)

JOKER CONSTANT EM_TI_C2000 from debug/elf/elf.go:
(def
  ^{:doc " The Texas Instruments TMS320C2000 DSP family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_TI_C2000))"}
  EM_TI_C2000)

JOKER CONSTANT EM_TI_C5500 from debug/elf/elf.go:
(def
  ^{:doc " The Texas Instruments TMS320C55x DSP family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_TI_C5500))"}
  EM_TI_C5500)

JOKER CONSTANT EM_TI_C6000 from debug/elf/elf.go:
(def
  ^{:doc " The Texas Instruments TMS320C6000 DSP family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_TI_C6000))"}
  EM_TI_C6000)

JOKER CONSTANT EM_TI_PRU from debug/elf/elf.go:
(def
  ^{:doc " Texas Instruments Programmable Realtime Unit\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_TI_PRU))"}
  EM_TI_PRU)

JOKER CONSTANT EM_TMM_GPP from debug/elf/elf.go:
(def
  ^{:doc " Thompson Multimedia General Purpose Processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_TMM_GPP))"}
  EM_TMM_GPP)

JOKER CONSTANT EM_TPC from debug/elf/elf.go:
(def
  ^{:doc " Tenor Network TPC processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_TPC))"}
  EM_TPC)

JOKER CONSTANT EM_TRICORE from debug/elf/elf.go:
(def
  ^{:doc " Siemens TriCore embedded processor.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_TRICORE))"}
  EM_TRICORE)

JOKER CONSTANT EM_TRIMEDIA from debug/elf/elf.go:
(def
  ^{:doc " NXP Semiconductors TriMedia architecture family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_TRIMEDIA))"}
  EM_TRIMEDIA)

JOKER CONSTANT EM_TSK3000 from debug/elf/elf.go:
(def
  ^{:doc " Altium TSK3000 core\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_TSK3000))"}
  EM_TSK3000)

JOKER CONSTANT EM_UNICORE from debug/elf/elf.go:
(def
  ^{:doc " Microprocessor series from PKU-Unity Ltd. and MPRC of Peking University\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_UNICORE))"}
  EM_UNICORE)

JOKER CONSTANT EM_V800 from debug/elf/elf.go:
(def
  ^{:doc " NEC V800.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_V800))"}
  EM_V800)

JOKER CONSTANT EM_V850 from debug/elf/elf.go:
(def
  ^{:doc " NEC v850\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_V850))"}
  EM_V850)

JOKER CONSTANT EM_VAX from debug/elf/elf.go:
(def
  ^{:doc " Digital VAX\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_VAX))"}
  EM_VAX)

JOKER CONSTANT EM_VIDEOCORE from debug/elf/elf.go:
(def
  ^{:doc " Alphamosaic VideoCore processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_VIDEOCORE))"}
  EM_VIDEOCORE)

JOKER CONSTANT EM_VIDEOCORE3 from debug/elf/elf.go:
(def
  ^{:doc " Broadcom VideoCore III processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_VIDEOCORE3))"}
  EM_VIDEOCORE3)

JOKER CONSTANT EM_VIDEOCORE5 from debug/elf/elf.go:
(def
  ^{:doc " Broadcom VideoCore V processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_VIDEOCORE5))"}
  EM_VIDEOCORE5)

JOKER CONSTANT EM_VISIUM from debug/elf/elf.go:
(def
  ^{:doc " Controls and Data Services VISIUMcore processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_VISIUM))"}
  EM_VISIUM)

JOKER CONSTANT EM_VPP500 from debug/elf/elf.go:
(def
  ^{:doc " Fujitsu VPP500.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_VPP500))"}
  EM_VPP500)

JOKER CONSTANT EM_X86_64 from debug/elf/elf.go:
(def
  ^{:doc " Advanced Micro Devices x86-64\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_X86_64))"}
  EM_X86_64)

JOKER CONSTANT EM_XCORE from debug/elf/elf.go:
(def
  ^{:doc " XMOS xCORE processor family\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_XCORE))"}
  EM_XCORE)

JOKER CONSTANT EM_XGATE from debug/elf/elf.go:
(def
  ^{:doc " Motorola XGATE embedded processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_XGATE))"}
  EM_XGATE)

JOKER CONSTANT EM_XIMO16 from debug/elf/elf.go:
(def
  ^{:doc " New Japan Radio (NJR) 16-bit DSP Processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_XIMO16))"}
  EM_XIMO16)

JOKER CONSTANT EM_XTENSA from debug/elf/elf.go:
(def
  ^{:doc " Tensilica Xtensa Architecture\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_XTENSA))"}
  EM_XTENSA)

JOKER CONSTANT EM_Z80 from debug/elf/elf.go:
(def
  ^{:doc " Zilog Z80\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_Z80))"}
  EM_Z80)

JOKER CONSTANT EM_ZSP from debug/elf/elf.go:
(def
  ^{:doc " LSI Logic 16-bit DSP Processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.EM_ZSP))"}
  EM_ZSP)

JOKER CONSTANT ET_CORE from debug/elf/elf.go:
(def
  ^{:doc " Core file.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.ET_CORE))"}
  ET_CORE)

JOKER CONSTANT ET_DYN from debug/elf/elf.go:
(def
  ^{:doc " Shared object.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.ET_DYN))"}
  ET_DYN)

JOKER CONSTANT ET_EXEC from debug/elf/elf.go:
(def
  ^{:doc " Executable.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.ET_EXEC))"}
  ET_EXEC)

JOKER CONSTANT ET_HIOS from debug/elf/elf.go:
(def
  ^{:doc " Last operating system-specific.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.ET_HIOS))"}
  ET_HIOS)

JOKER CONSTANT ET_HIPROC from debug/elf/elf.go:
(def
  ^{:doc " Last processor-specific.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.ET_HIPROC))"}
  ET_HIPROC)

JOKER CONSTANT ET_LOOS from debug/elf/elf.go:
(def
  ^{:doc " First operating system specific.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.ET_LOOS))"}
  ET_LOOS)

JOKER CONSTANT ET_LOPROC from debug/elf/elf.go:
(def
  ^{:doc " First processor-specific.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.ET_LOPROC))"}
  ET_LOPROC)

JOKER CONSTANT ET_NONE from debug/elf/elf.go:
(def
  ^{:doc " Unknown type.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.ET_NONE))"}
  ET_NONE)

JOKER CONSTANT ET_REL from debug/elf/elf.go:
(def
  ^{:doc " Relocatable.\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(elf.ET_REL))"}
  ET_REL)

JOKER CONSTANT EV_CURRENT from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.EV_CURRENT))"}
  EV_CURRENT)

JOKER CONSTANT EV_NONE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(byte(elf.EV_NONE))"}
  EV_NONE)

JOKER CONSTANT NT_FPREGSET from debug/elf/elf.go:
(def
  ^{:doc " Floating point registers.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.NT_FPREGSET)"}
  NT_FPREGSET)

JOKER CONSTANT NT_PRPSINFO from debug/elf/elf.go:
(def
  ^{:doc " Process state info.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.NT_PRPSINFO)"}
  NT_PRPSINFO)

JOKER CONSTANT NT_PRSTATUS from debug/elf/elf.go:
(def
  ^{:doc " Process status.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.NT_PRSTATUS)"}
  NT_PRSTATUS)

JOKER CONSTANT PF_MASKOS from debug/elf/elf.go:
(def
  ^{:doc " Operating system-specific.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.PF_MASKOS))"}
  PF_MASKOS)

JOKER CONSTANT PF_MASKPROC from debug/elf/elf.go:
(def
  ^{:doc " Processor-specific.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.PF_MASKPROC))"}
  PF_MASKPROC)

JOKER CONSTANT PF_R from debug/elf/elf.go:
(def
  ^{:doc " Readable.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.PF_R))"}
  PF_R)

JOKER CONSTANT PF_W from debug/elf/elf.go:
(def
  ^{:doc " Writable.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.PF_W))"}
  PF_W)

JOKER CONSTANT PF_X from debug/elf/elf.go:
(def
  ^{:doc " Executable.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.PF_X))"}
  PF_X)

JOKER CONSTANT PT_DYNAMIC from debug/elf/elf.go:
(def
  ^{:doc " Dynamic linking information segment.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.PT_DYNAMIC)"}
  PT_DYNAMIC)

JOKER CONSTANT PT_HIOS from debug/elf/elf.go:
(def
  ^{:doc " Last OS-specific.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.PT_HIOS)"}
  PT_HIOS)

JOKER CONSTANT PT_HIPROC from debug/elf/elf.go:
(def
  ^{:doc " Last processor-specific type.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.PT_HIPROC)"}
  PT_HIPROC)

JOKER CONSTANT PT_INTERP from debug/elf/elf.go:
(def
  ^{:doc " Pathname of interpreter.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.PT_INTERP)"}
  PT_INTERP)

JOKER CONSTANT PT_LOAD from debug/elf/elf.go:
(def
  ^{:doc " Loadable segment.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.PT_LOAD)"}
  PT_LOAD)

JOKER CONSTANT PT_LOOS from debug/elf/elf.go:
(def
  ^{:doc " First OS-specific.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.PT_LOOS)"}
  PT_LOOS)

JOKER CONSTANT PT_LOPROC from debug/elf/elf.go:
(def
  ^{:doc " First processor-specific type.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.PT_LOPROC)"}
  PT_LOPROC)

JOKER CONSTANT PT_NOTE from debug/elf/elf.go:
(def
  ^{:doc " Auxiliary information.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.PT_NOTE)"}
  PT_NOTE)

JOKER CONSTANT PT_NULL from debug/elf/elf.go:
(def
  ^{:doc " Unused entry.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.PT_NULL)"}
  PT_NULL)

JOKER CONSTANT PT_PHDR from debug/elf/elf.go:
(def
  ^{:doc " Location of program header itself.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.PT_PHDR)"}
  PT_PHDR)

JOKER CONSTANT PT_SHLIB from debug/elf/elf.go:
(def
  ^{:doc " Reserved (not used).\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.PT_SHLIB)"}
  PT_SHLIB)

JOKER CONSTANT PT_TLS from debug/elf/elf.go:
(def
  ^{:doc " Thread local storage segment\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.PT_TLS)"}
  PT_TLS)

JOKER CONSTANT R_386_16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_16)"}
  R_386_16)

JOKER CONSTANT R_386_32 from debug/elf/elf.go:
(def
  ^{:doc " Add symbol value.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_32)"}
  R_386_32)

JOKER CONSTANT R_386_32PLT from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_32PLT)"}
  R_386_32PLT)

JOKER CONSTANT R_386_8 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_8)"}
  R_386_8)

JOKER CONSTANT R_386_COPY from debug/elf/elf.go:
(def
  ^{:doc " Copy data from shared object.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_COPY)"}
  R_386_COPY)

JOKER CONSTANT R_386_GLOB_DAT from debug/elf/elf.go:
(def
  ^{:doc " Set GOT entry to data address.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_GLOB_DAT)"}
  R_386_GLOB_DAT)

JOKER CONSTANT R_386_GOT32 from debug/elf/elf.go:
(def
  ^{:doc " Add PC-relative GOT offset.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_GOT32)"}
  R_386_GOT32)

JOKER CONSTANT R_386_GOT32X from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_GOT32X)"}
  R_386_GOT32X)

JOKER CONSTANT R_386_GOTOFF from debug/elf/elf.go:
(def
  ^{:doc " Add GOT-relative symbol address.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_GOTOFF)"}
  R_386_GOTOFF)

JOKER CONSTANT R_386_GOTPC from debug/elf/elf.go:
(def
  ^{:doc " Add PC-relative GOT table address.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_GOTPC)"}
  R_386_GOTPC)

JOKER CONSTANT R_386_IRELATIVE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_IRELATIVE)"}
  R_386_IRELATIVE)

JOKER CONSTANT R_386_JMP_SLOT from debug/elf/elf.go:
(def
  ^{:doc " Set GOT entry to code address.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_JMP_SLOT)"}
  R_386_JMP_SLOT)

JOKER CONSTANT R_386_NONE from debug/elf/elf.go:
(def
  ^{:doc " No relocation.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_NONE)"}
  R_386_NONE)

JOKER CONSTANT R_386_PC16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_PC16)"}
  R_386_PC16)

JOKER CONSTANT R_386_PC32 from debug/elf/elf.go:
(def
  ^{:doc " Add PC-relative symbol value.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_PC32)"}
  R_386_PC32)

JOKER CONSTANT R_386_PC8 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_PC8)"}
  R_386_PC8)

JOKER CONSTANT R_386_PLT32 from debug/elf/elf.go:
(def
  ^{:doc " Add PC-relative PLT offset.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_PLT32)"}
  R_386_PLT32)

JOKER CONSTANT R_386_RELATIVE from debug/elf/elf.go:
(def
  ^{:doc " Add load address of shared object.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_RELATIVE)"}
  R_386_RELATIVE)

JOKER CONSTANT R_386_SIZE32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_SIZE32)"}
  R_386_SIZE32)

JOKER CONSTANT R_386_TLS_DESC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_DESC)"}
  R_386_TLS_DESC)

JOKER CONSTANT R_386_TLS_DESC_CALL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_DESC_CALL)"}
  R_386_TLS_DESC_CALL)

JOKER CONSTANT R_386_TLS_DTPMOD32 from debug/elf/elf.go:
(def
  ^{:doc " GOT entry containing TLS index\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_DTPMOD32)"}
  R_386_TLS_DTPMOD32)

JOKER CONSTANT R_386_TLS_DTPOFF32 from debug/elf/elf.go:
(def
  ^{:doc " GOT entry containing TLS offset\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_DTPOFF32)"}
  R_386_TLS_DTPOFF32)

JOKER CONSTANT R_386_TLS_GD from debug/elf/elf.go:
(def
  ^{:doc " 32 bit offset to GOT (index,off) pair\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_GD)"}
  R_386_TLS_GD)

JOKER CONSTANT R_386_TLS_GD_32 from debug/elf/elf.go:
(def
  ^{:doc " 32 bit offset to GOT (index,off) pair\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_GD_32)"}
  R_386_TLS_GD_32)

JOKER CONSTANT R_386_TLS_GD_CALL from debug/elf/elf.go:
(def
  ^{:doc " call instruction for Sun ABI GD sequence\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_GD_CALL)"}
  R_386_TLS_GD_CALL)

JOKER CONSTANT R_386_TLS_GD_POP from debug/elf/elf.go:
(def
  ^{:doc " popl instruction for Sun ABI GD sequence\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_GD_POP)"}
  R_386_TLS_GD_POP)

JOKER CONSTANT R_386_TLS_GD_PUSH from debug/elf/elf.go:
(def
  ^{:doc " pushl instruction for Sun ABI GD sequence\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_GD_PUSH)"}
  R_386_TLS_GD_PUSH)

JOKER CONSTANT R_386_TLS_GOTDESC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_GOTDESC)"}
  R_386_TLS_GOTDESC)

JOKER CONSTANT R_386_TLS_GOTIE from debug/elf/elf.go:
(def
  ^{:doc " GOT entry for negative static TLS block\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_GOTIE)"}
  R_386_TLS_GOTIE)

JOKER CONSTANT R_386_TLS_IE from debug/elf/elf.go:
(def
  ^{:doc " Absolute address of GOT for -ve static TLS\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_IE)"}
  R_386_TLS_IE)

JOKER CONSTANT R_386_TLS_IE_32 from debug/elf/elf.go:
(def
  ^{:doc " 32 bit offset to GOT static TLS offset entry\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_IE_32)"}
  R_386_TLS_IE_32)

JOKER CONSTANT R_386_TLS_LDM from debug/elf/elf.go:
(def
  ^{:doc " 32 bit offset to GOT (index,zero) pair\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_LDM)"}
  R_386_TLS_LDM)

JOKER CONSTANT R_386_TLS_LDM_32 from debug/elf/elf.go:
(def
  ^{:doc " 32 bit offset to GOT (index,zero) pair\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_LDM_32)"}
  R_386_TLS_LDM_32)

JOKER CONSTANT R_386_TLS_LDM_CALL from debug/elf/elf.go:
(def
  ^{:doc " call instruction for Sun ABI LD sequence\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_LDM_CALL)"}
  R_386_TLS_LDM_CALL)

JOKER CONSTANT R_386_TLS_LDM_POP from debug/elf/elf.go:
(def
  ^{:doc " popl instruction for Sun ABI LD sequence\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_LDM_POP)"}
  R_386_TLS_LDM_POP)

JOKER CONSTANT R_386_TLS_LDM_PUSH from debug/elf/elf.go:
(def
  ^{:doc " pushl instruction for Sun ABI LD sequence\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_LDM_PUSH)"}
  R_386_TLS_LDM_PUSH)

JOKER CONSTANT R_386_TLS_LDO_32 from debug/elf/elf.go:
(def
  ^{:doc " 32 bit offset from start of TLS block\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_LDO_32)"}
  R_386_TLS_LDO_32)

JOKER CONSTANT R_386_TLS_LE from debug/elf/elf.go:
(def
  ^{:doc " Negative offset relative to static TLS\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_LE)"}
  R_386_TLS_LE)

JOKER CONSTANT R_386_TLS_LE_32 from debug/elf/elf.go:
(def
  ^{:doc " 32 bit offset within static TLS block\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_LE_32)"}
  R_386_TLS_LE_32)

JOKER CONSTANT R_386_TLS_TPOFF from debug/elf/elf.go:
(def
  ^{:doc " Negative offset in static TLS block\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_TPOFF)"}
  R_386_TLS_TPOFF)

JOKER CONSTANT R_386_TLS_TPOFF32 from debug/elf/elf.go:
(def
  ^{:doc " GOT entry of -ve static TLS offset\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_386_TLS_TPOFF32)"}
  R_386_TLS_TPOFF32)

JOKER CONSTANT R_390_12 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_12)"}
  R_390_12)

JOKER CONSTANT R_390_16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_16)"}
  R_390_16)

JOKER CONSTANT R_390_20 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_20)"}
  R_390_20)

JOKER CONSTANT R_390_32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_32)"}
  R_390_32)

JOKER CONSTANT R_390_64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_64)"}
  R_390_64)

JOKER CONSTANT R_390_8 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_8)"}
  R_390_8)

JOKER CONSTANT R_390_COPY from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_COPY)"}
  R_390_COPY)

JOKER CONSTANT R_390_GLOB_DAT from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_GLOB_DAT)"}
  R_390_GLOB_DAT)

JOKER CONSTANT R_390_GOT12 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_GOT12)"}
  R_390_GOT12)

JOKER CONSTANT R_390_GOT16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_GOT16)"}
  R_390_GOT16)

JOKER CONSTANT R_390_GOT20 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_GOT20)"}
  R_390_GOT20)

JOKER CONSTANT R_390_GOT32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_GOT32)"}
  R_390_GOT32)

JOKER CONSTANT R_390_GOT64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_GOT64)"}
  R_390_GOT64)

JOKER CONSTANT R_390_GOTENT from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_GOTENT)"}
  R_390_GOTENT)

JOKER CONSTANT R_390_GOTOFF from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_GOTOFF)"}
  R_390_GOTOFF)

JOKER CONSTANT R_390_GOTOFF16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_GOTOFF16)"}
  R_390_GOTOFF16)

JOKER CONSTANT R_390_GOTOFF64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_GOTOFF64)"}
  R_390_GOTOFF64)

JOKER CONSTANT R_390_GOTPC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_GOTPC)"}
  R_390_GOTPC)

JOKER CONSTANT R_390_GOTPCDBL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_GOTPCDBL)"}
  R_390_GOTPCDBL)

JOKER CONSTANT R_390_GOTPLT12 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_GOTPLT12)"}
  R_390_GOTPLT12)

JOKER CONSTANT R_390_GOTPLT16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_GOTPLT16)"}
  R_390_GOTPLT16)

JOKER CONSTANT R_390_GOTPLT20 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_GOTPLT20)"}
  R_390_GOTPLT20)

JOKER CONSTANT R_390_GOTPLT32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_GOTPLT32)"}
  R_390_GOTPLT32)

JOKER CONSTANT R_390_GOTPLT64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_GOTPLT64)"}
  R_390_GOTPLT64)

JOKER CONSTANT R_390_GOTPLTENT from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_GOTPLTENT)"}
  R_390_GOTPLTENT)

JOKER CONSTANT R_390_GOTPLTOFF16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_GOTPLTOFF16)"}
  R_390_GOTPLTOFF16)

JOKER CONSTANT R_390_GOTPLTOFF32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_GOTPLTOFF32)"}
  R_390_GOTPLTOFF32)

JOKER CONSTANT R_390_GOTPLTOFF64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_GOTPLTOFF64)"}
  R_390_GOTPLTOFF64)

JOKER CONSTANT R_390_JMP_SLOT from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_JMP_SLOT)"}
  R_390_JMP_SLOT)

JOKER CONSTANT R_390_NONE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_NONE)"}
  R_390_NONE)

JOKER CONSTANT R_390_PC16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_PC16)"}
  R_390_PC16)

JOKER CONSTANT R_390_PC16DBL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_PC16DBL)"}
  R_390_PC16DBL)

JOKER CONSTANT R_390_PC32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_PC32)"}
  R_390_PC32)

JOKER CONSTANT R_390_PC32DBL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_PC32DBL)"}
  R_390_PC32DBL)

JOKER CONSTANT R_390_PC64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_PC64)"}
  R_390_PC64)

JOKER CONSTANT R_390_PLT16DBL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_PLT16DBL)"}
  R_390_PLT16DBL)

JOKER CONSTANT R_390_PLT32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_PLT32)"}
  R_390_PLT32)

JOKER CONSTANT R_390_PLT32DBL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_PLT32DBL)"}
  R_390_PLT32DBL)

JOKER CONSTANT R_390_PLT64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_PLT64)"}
  R_390_PLT64)

JOKER CONSTANT R_390_RELATIVE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_RELATIVE)"}
  R_390_RELATIVE)

JOKER CONSTANT R_390_TLS_DTPMOD from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_TLS_DTPMOD)"}
  R_390_TLS_DTPMOD)

JOKER CONSTANT R_390_TLS_DTPOFF from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_TLS_DTPOFF)"}
  R_390_TLS_DTPOFF)

JOKER CONSTANT R_390_TLS_GD32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_TLS_GD32)"}
  R_390_TLS_GD32)

JOKER CONSTANT R_390_TLS_GD64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_TLS_GD64)"}
  R_390_TLS_GD64)

JOKER CONSTANT R_390_TLS_GDCALL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_TLS_GDCALL)"}
  R_390_TLS_GDCALL)

JOKER CONSTANT R_390_TLS_GOTIE12 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_TLS_GOTIE12)"}
  R_390_TLS_GOTIE12)

JOKER CONSTANT R_390_TLS_GOTIE20 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_TLS_GOTIE20)"}
  R_390_TLS_GOTIE20)

JOKER CONSTANT R_390_TLS_GOTIE32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_TLS_GOTIE32)"}
  R_390_TLS_GOTIE32)

JOKER CONSTANT R_390_TLS_GOTIE64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_TLS_GOTIE64)"}
  R_390_TLS_GOTIE64)

JOKER CONSTANT R_390_TLS_IE32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_TLS_IE32)"}
  R_390_TLS_IE32)

JOKER CONSTANT R_390_TLS_IE64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_TLS_IE64)"}
  R_390_TLS_IE64)

JOKER CONSTANT R_390_TLS_IEENT from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_TLS_IEENT)"}
  R_390_TLS_IEENT)

JOKER CONSTANT R_390_TLS_LDCALL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_TLS_LDCALL)"}
  R_390_TLS_LDCALL)

JOKER CONSTANT R_390_TLS_LDM32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_TLS_LDM32)"}
  R_390_TLS_LDM32)

JOKER CONSTANT R_390_TLS_LDM64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_TLS_LDM64)"}
  R_390_TLS_LDM64)

JOKER CONSTANT R_390_TLS_LDO32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_TLS_LDO32)"}
  R_390_TLS_LDO32)

JOKER CONSTANT R_390_TLS_LDO64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_TLS_LDO64)"}
  R_390_TLS_LDO64)

JOKER CONSTANT R_390_TLS_LE32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_TLS_LE32)"}
  R_390_TLS_LE32)

JOKER CONSTANT R_390_TLS_LE64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_TLS_LE64)"}
  R_390_TLS_LE64)

JOKER CONSTANT R_390_TLS_LOAD from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_TLS_LOAD)"}
  R_390_TLS_LOAD)

JOKER CONSTANT R_390_TLS_TPOFF from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_390_TLS_TPOFF)"}
  R_390_TLS_TPOFF)

JOKER CONSTANT R_AARCH64_ABS16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_ABS16)"}
  R_AARCH64_ABS16)

JOKER CONSTANT R_AARCH64_ABS32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_ABS32)"}
  R_AARCH64_ABS32)

JOKER CONSTANT R_AARCH64_ABS64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_ABS64)"}
  R_AARCH64_ABS64)

JOKER CONSTANT R_AARCH64_ADD_ABS_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_ADD_ABS_LO12_NC)"}
  R_AARCH64_ADD_ABS_LO12_NC)

JOKER CONSTANT R_AARCH64_ADR_GOT_PAGE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_ADR_GOT_PAGE)"}
  R_AARCH64_ADR_GOT_PAGE)

JOKER CONSTANT R_AARCH64_ADR_PREL_LO21 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_ADR_PREL_LO21)"}
  R_AARCH64_ADR_PREL_LO21)

JOKER CONSTANT R_AARCH64_ADR_PREL_PG_HI21 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_ADR_PREL_PG_HI21)"}
  R_AARCH64_ADR_PREL_PG_HI21)

JOKER CONSTANT R_AARCH64_ADR_PREL_PG_HI21_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_ADR_PREL_PG_HI21_NC)"}
  R_AARCH64_ADR_PREL_PG_HI21_NC)

JOKER CONSTANT R_AARCH64_CALL26 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_CALL26)"}
  R_AARCH64_CALL26)

JOKER CONSTANT R_AARCH64_CONDBR19 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_CONDBR19)"}
  R_AARCH64_CONDBR19)

JOKER CONSTANT R_AARCH64_COPY from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_COPY)"}
  R_AARCH64_COPY)

JOKER CONSTANT R_AARCH64_GLOB_DAT from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_GLOB_DAT)"}
  R_AARCH64_GLOB_DAT)

JOKER CONSTANT R_AARCH64_GOT_LD_PREL19 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_GOT_LD_PREL19)"}
  R_AARCH64_GOT_LD_PREL19)

JOKER CONSTANT R_AARCH64_IRELATIVE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_IRELATIVE)"}
  R_AARCH64_IRELATIVE)

JOKER CONSTANT R_AARCH64_JUMP26 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_JUMP26)"}
  R_AARCH64_JUMP26)

JOKER CONSTANT R_AARCH64_JUMP_SLOT from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_JUMP_SLOT)"}
  R_AARCH64_JUMP_SLOT)

JOKER CONSTANT R_AARCH64_LD64_GOTOFF_LO15 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_LD64_GOTOFF_LO15)"}
  R_AARCH64_LD64_GOTOFF_LO15)

JOKER CONSTANT R_AARCH64_LD64_GOTPAGE_LO15 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_LD64_GOTPAGE_LO15)"}
  R_AARCH64_LD64_GOTPAGE_LO15)

JOKER CONSTANT R_AARCH64_LD64_GOT_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_LD64_GOT_LO12_NC)"}
  R_AARCH64_LD64_GOT_LO12_NC)

JOKER CONSTANT R_AARCH64_LDST128_ABS_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_LDST128_ABS_LO12_NC)"}
  R_AARCH64_LDST128_ABS_LO12_NC)

JOKER CONSTANT R_AARCH64_LDST16_ABS_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_LDST16_ABS_LO12_NC)"}
  R_AARCH64_LDST16_ABS_LO12_NC)

JOKER CONSTANT R_AARCH64_LDST32_ABS_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_LDST32_ABS_LO12_NC)"}
  R_AARCH64_LDST32_ABS_LO12_NC)

JOKER CONSTANT R_AARCH64_LDST64_ABS_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_LDST64_ABS_LO12_NC)"}
  R_AARCH64_LDST64_ABS_LO12_NC)

JOKER CONSTANT R_AARCH64_LDST8_ABS_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_LDST8_ABS_LO12_NC)"}
  R_AARCH64_LDST8_ABS_LO12_NC)

JOKER CONSTANT R_AARCH64_LD_PREL_LO19 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_LD_PREL_LO19)"}
  R_AARCH64_LD_PREL_LO19)

JOKER CONSTANT R_AARCH64_MOVW_SABS_G0 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_MOVW_SABS_G0)"}
  R_AARCH64_MOVW_SABS_G0)

JOKER CONSTANT R_AARCH64_MOVW_SABS_G1 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_MOVW_SABS_G1)"}
  R_AARCH64_MOVW_SABS_G1)

JOKER CONSTANT R_AARCH64_MOVW_SABS_G2 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_MOVW_SABS_G2)"}
  R_AARCH64_MOVW_SABS_G2)

JOKER CONSTANT R_AARCH64_MOVW_UABS_G0 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_MOVW_UABS_G0)"}
  R_AARCH64_MOVW_UABS_G0)

JOKER CONSTANT R_AARCH64_MOVW_UABS_G0_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_MOVW_UABS_G0_NC)"}
  R_AARCH64_MOVW_UABS_G0_NC)

JOKER CONSTANT R_AARCH64_MOVW_UABS_G1 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_MOVW_UABS_G1)"}
  R_AARCH64_MOVW_UABS_G1)

JOKER CONSTANT R_AARCH64_MOVW_UABS_G1_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_MOVW_UABS_G1_NC)"}
  R_AARCH64_MOVW_UABS_G1_NC)

JOKER CONSTANT R_AARCH64_MOVW_UABS_G2 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_MOVW_UABS_G2)"}
  R_AARCH64_MOVW_UABS_G2)

JOKER CONSTANT R_AARCH64_MOVW_UABS_G2_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_MOVW_UABS_G2_NC)"}
  R_AARCH64_MOVW_UABS_G2_NC)

JOKER CONSTANT R_AARCH64_MOVW_UABS_G3 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_MOVW_UABS_G3)"}
  R_AARCH64_MOVW_UABS_G3)

JOKER CONSTANT R_AARCH64_NONE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_NONE)"}
  R_AARCH64_NONE)

JOKER CONSTANT R_AARCH64_NULL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_NULL)"}
  R_AARCH64_NULL)

JOKER CONSTANT R_AARCH64_P32_ABS16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_ABS16)"}
  R_AARCH64_P32_ABS16)

JOKER CONSTANT R_AARCH64_P32_ABS32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_ABS32)"}
  R_AARCH64_P32_ABS32)

JOKER CONSTANT R_AARCH64_P32_ADD_ABS_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_ADD_ABS_LO12_NC)"}
  R_AARCH64_P32_ADD_ABS_LO12_NC)

JOKER CONSTANT R_AARCH64_P32_ADR_GOT_PAGE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_ADR_GOT_PAGE)"}
  R_AARCH64_P32_ADR_GOT_PAGE)

JOKER CONSTANT R_AARCH64_P32_ADR_PREL_LO21 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_ADR_PREL_LO21)"}
  R_AARCH64_P32_ADR_PREL_LO21)

JOKER CONSTANT R_AARCH64_P32_ADR_PREL_PG_HI21 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_ADR_PREL_PG_HI21)"}
  R_AARCH64_P32_ADR_PREL_PG_HI21)

JOKER CONSTANT R_AARCH64_P32_CALL26 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_CALL26)"}
  R_AARCH64_P32_CALL26)

JOKER CONSTANT R_AARCH64_P32_CONDBR19 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_CONDBR19)"}
  R_AARCH64_P32_CONDBR19)

JOKER CONSTANT R_AARCH64_P32_COPY from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_COPY)"}
  R_AARCH64_P32_COPY)

JOKER CONSTANT R_AARCH64_P32_GLOB_DAT from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_GLOB_DAT)"}
  R_AARCH64_P32_GLOB_DAT)

JOKER CONSTANT R_AARCH64_P32_GOT_LD_PREL19 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_GOT_LD_PREL19)"}
  R_AARCH64_P32_GOT_LD_PREL19)

JOKER CONSTANT R_AARCH64_P32_IRELATIVE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_IRELATIVE)"}
  R_AARCH64_P32_IRELATIVE)

JOKER CONSTANT R_AARCH64_P32_JUMP26 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_JUMP26)"}
  R_AARCH64_P32_JUMP26)

JOKER CONSTANT R_AARCH64_P32_JUMP_SLOT from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_JUMP_SLOT)"}
  R_AARCH64_P32_JUMP_SLOT)

JOKER CONSTANT R_AARCH64_P32_LD32_GOT_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_LD32_GOT_LO12_NC)"}
  R_AARCH64_P32_LD32_GOT_LO12_NC)

JOKER CONSTANT R_AARCH64_P32_LDST128_ABS_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_LDST128_ABS_LO12_NC)"}
  R_AARCH64_P32_LDST128_ABS_LO12_NC)

JOKER CONSTANT R_AARCH64_P32_LDST16_ABS_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_LDST16_ABS_LO12_NC)"}
  R_AARCH64_P32_LDST16_ABS_LO12_NC)

JOKER CONSTANT R_AARCH64_P32_LDST32_ABS_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_LDST32_ABS_LO12_NC)"}
  R_AARCH64_P32_LDST32_ABS_LO12_NC)

JOKER CONSTANT R_AARCH64_P32_LDST64_ABS_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_LDST64_ABS_LO12_NC)"}
  R_AARCH64_P32_LDST64_ABS_LO12_NC)

JOKER CONSTANT R_AARCH64_P32_LDST8_ABS_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_LDST8_ABS_LO12_NC)"}
  R_AARCH64_P32_LDST8_ABS_LO12_NC)

JOKER CONSTANT R_AARCH64_P32_LD_PREL_LO19 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_LD_PREL_LO19)"}
  R_AARCH64_P32_LD_PREL_LO19)

JOKER CONSTANT R_AARCH64_P32_MOVW_SABS_G0 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_MOVW_SABS_G0)"}
  R_AARCH64_P32_MOVW_SABS_G0)

JOKER CONSTANT R_AARCH64_P32_MOVW_UABS_G0 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_MOVW_UABS_G0)"}
  R_AARCH64_P32_MOVW_UABS_G0)

JOKER CONSTANT R_AARCH64_P32_MOVW_UABS_G0_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_MOVW_UABS_G0_NC)"}
  R_AARCH64_P32_MOVW_UABS_G0_NC)

JOKER CONSTANT R_AARCH64_P32_MOVW_UABS_G1 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_MOVW_UABS_G1)"}
  R_AARCH64_P32_MOVW_UABS_G1)

JOKER CONSTANT R_AARCH64_P32_PREL16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_PREL16)"}
  R_AARCH64_P32_PREL16)

JOKER CONSTANT R_AARCH64_P32_PREL32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_PREL32)"}
  R_AARCH64_P32_PREL32)

JOKER CONSTANT R_AARCH64_P32_RELATIVE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_RELATIVE)"}
  R_AARCH64_P32_RELATIVE)

JOKER CONSTANT R_AARCH64_P32_TLSDESC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TLSDESC)"}
  R_AARCH64_P32_TLSDESC)

JOKER CONSTANT R_AARCH64_P32_TLSDESC_ADD_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TLSDESC_ADD_LO12_NC)"}
  R_AARCH64_P32_TLSDESC_ADD_LO12_NC)

JOKER CONSTANT R_AARCH64_P32_TLSDESC_ADR_PAGE21 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TLSDESC_ADR_PAGE21)"}
  R_AARCH64_P32_TLSDESC_ADR_PAGE21)

JOKER CONSTANT R_AARCH64_P32_TLSDESC_ADR_PREL21 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TLSDESC_ADR_PREL21)"}
  R_AARCH64_P32_TLSDESC_ADR_PREL21)

JOKER CONSTANT R_AARCH64_P32_TLSDESC_CALL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TLSDESC_CALL)"}
  R_AARCH64_P32_TLSDESC_CALL)

JOKER CONSTANT R_AARCH64_P32_TLSDESC_LD32_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TLSDESC_LD32_LO12_NC)"}
  R_AARCH64_P32_TLSDESC_LD32_LO12_NC)

JOKER CONSTANT R_AARCH64_P32_TLSDESC_LD_PREL19 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TLSDESC_LD_PREL19)"}
  R_AARCH64_P32_TLSDESC_LD_PREL19)

JOKER CONSTANT R_AARCH64_P32_TLSGD_ADD_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TLSGD_ADD_LO12_NC)"}
  R_AARCH64_P32_TLSGD_ADD_LO12_NC)

JOKER CONSTANT R_AARCH64_P32_TLSGD_ADR_PAGE21 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TLSGD_ADR_PAGE21)"}
  R_AARCH64_P32_TLSGD_ADR_PAGE21)

JOKER CONSTANT R_AARCH64_P32_TLSIE_ADR_GOTTPREL_PAGE21 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TLSIE_ADR_GOTTPREL_PAGE21)"}
  R_AARCH64_P32_TLSIE_ADR_GOTTPREL_PAGE21)

JOKER CONSTANT R_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC)"}
  R_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC)

JOKER CONSTANT R_AARCH64_P32_TLSIE_LD_GOTTPREL_PREL19 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TLSIE_LD_GOTTPREL_PREL19)"}
  R_AARCH64_P32_TLSIE_LD_GOTTPREL_PREL19)

JOKER CONSTANT R_AARCH64_P32_TLSLE_ADD_TPREL_HI12 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TLSLE_ADD_TPREL_HI12)"}
  R_AARCH64_P32_TLSLE_ADD_TPREL_HI12)

JOKER CONSTANT R_AARCH64_P32_TLSLE_ADD_TPREL_LO12 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TLSLE_ADD_TPREL_LO12)"}
  R_AARCH64_P32_TLSLE_ADD_TPREL_LO12)

JOKER CONSTANT R_AARCH64_P32_TLSLE_ADD_TPREL_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TLSLE_ADD_TPREL_LO12_NC)"}
  R_AARCH64_P32_TLSLE_ADD_TPREL_LO12_NC)

JOKER CONSTANT R_AARCH64_P32_TLSLE_MOVW_TPREL_G0 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TLSLE_MOVW_TPREL_G0)"}
  R_AARCH64_P32_TLSLE_MOVW_TPREL_G0)

JOKER CONSTANT R_AARCH64_P32_TLSLE_MOVW_TPREL_G0_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TLSLE_MOVW_TPREL_G0_NC)"}
  R_AARCH64_P32_TLSLE_MOVW_TPREL_G0_NC)

JOKER CONSTANT R_AARCH64_P32_TLSLE_MOVW_TPREL_G1 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TLSLE_MOVW_TPREL_G1)"}
  R_AARCH64_P32_TLSLE_MOVW_TPREL_G1)

JOKER CONSTANT R_AARCH64_P32_TLS_DTPMOD from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TLS_DTPMOD)"}
  R_AARCH64_P32_TLS_DTPMOD)

JOKER CONSTANT R_AARCH64_P32_TLS_DTPREL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TLS_DTPREL)"}
  R_AARCH64_P32_TLS_DTPREL)

JOKER CONSTANT R_AARCH64_P32_TLS_TPREL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TLS_TPREL)"}
  R_AARCH64_P32_TLS_TPREL)

JOKER CONSTANT R_AARCH64_P32_TSTBR14 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_P32_TSTBR14)"}
  R_AARCH64_P32_TSTBR14)

JOKER CONSTANT R_AARCH64_PREL16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_PREL16)"}
  R_AARCH64_PREL16)

JOKER CONSTANT R_AARCH64_PREL32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_PREL32)"}
  R_AARCH64_PREL32)

JOKER CONSTANT R_AARCH64_PREL64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_PREL64)"}
  R_AARCH64_PREL64)

JOKER CONSTANT R_AARCH64_RELATIVE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_RELATIVE)"}
  R_AARCH64_RELATIVE)

JOKER CONSTANT R_AARCH64_TLSDESC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSDESC)"}
  R_AARCH64_TLSDESC)

JOKER CONSTANT R_AARCH64_TLSDESC_ADD from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSDESC_ADD)"}
  R_AARCH64_TLSDESC_ADD)

JOKER CONSTANT R_AARCH64_TLSDESC_ADD_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSDESC_ADD_LO12_NC)"}
  R_AARCH64_TLSDESC_ADD_LO12_NC)

JOKER CONSTANT R_AARCH64_TLSDESC_ADR_PAGE21 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSDESC_ADR_PAGE21)"}
  R_AARCH64_TLSDESC_ADR_PAGE21)

JOKER CONSTANT R_AARCH64_TLSDESC_ADR_PREL21 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSDESC_ADR_PREL21)"}
  R_AARCH64_TLSDESC_ADR_PREL21)

JOKER CONSTANT R_AARCH64_TLSDESC_CALL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSDESC_CALL)"}
  R_AARCH64_TLSDESC_CALL)

JOKER CONSTANT R_AARCH64_TLSDESC_LD64_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSDESC_LD64_LO12_NC)"}
  R_AARCH64_TLSDESC_LD64_LO12_NC)

JOKER CONSTANT R_AARCH64_TLSDESC_LDR from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSDESC_LDR)"}
  R_AARCH64_TLSDESC_LDR)

JOKER CONSTANT R_AARCH64_TLSDESC_LD_PREL19 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSDESC_LD_PREL19)"}
  R_AARCH64_TLSDESC_LD_PREL19)

JOKER CONSTANT R_AARCH64_TLSDESC_OFF_G0_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSDESC_OFF_G0_NC)"}
  R_AARCH64_TLSDESC_OFF_G0_NC)

JOKER CONSTANT R_AARCH64_TLSDESC_OFF_G1 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSDESC_OFF_G1)"}
  R_AARCH64_TLSDESC_OFF_G1)

JOKER CONSTANT R_AARCH64_TLSGD_ADD_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSGD_ADD_LO12_NC)"}
  R_AARCH64_TLSGD_ADD_LO12_NC)

JOKER CONSTANT R_AARCH64_TLSGD_ADR_PAGE21 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSGD_ADR_PAGE21)"}
  R_AARCH64_TLSGD_ADR_PAGE21)

JOKER CONSTANT R_AARCH64_TLSGD_ADR_PREL21 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSGD_ADR_PREL21)"}
  R_AARCH64_TLSGD_ADR_PREL21)

JOKER CONSTANT R_AARCH64_TLSGD_MOVW_G0_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSGD_MOVW_G0_NC)"}
  R_AARCH64_TLSGD_MOVW_G0_NC)

JOKER CONSTANT R_AARCH64_TLSGD_MOVW_G1 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSGD_MOVW_G1)"}
  R_AARCH64_TLSGD_MOVW_G1)

JOKER CONSTANT R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21)"}
  R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21)

JOKER CONSTANT R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC)"}
  R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC)

JOKER CONSTANT R_AARCH64_TLSIE_LD_GOTTPREL_PREL19 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSIE_LD_GOTTPREL_PREL19)"}
  R_AARCH64_TLSIE_LD_GOTTPREL_PREL19)

JOKER CONSTANT R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC)"}
  R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC)

JOKER CONSTANT R_AARCH64_TLSIE_MOVW_GOTTPREL_G1 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSIE_MOVW_GOTTPREL_G1)"}
  R_AARCH64_TLSIE_MOVW_GOTTPREL_G1)

JOKER CONSTANT R_AARCH64_TLSLD_ADR_PAGE21 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSLD_ADR_PAGE21)"}
  R_AARCH64_TLSLD_ADR_PAGE21)

JOKER CONSTANT R_AARCH64_TLSLD_ADR_PREL21 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSLD_ADR_PREL21)"}
  R_AARCH64_TLSLD_ADR_PREL21)

JOKER CONSTANT R_AARCH64_TLSLD_LDST128_DTPREL_LO12 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSLD_LDST128_DTPREL_LO12)"}
  R_AARCH64_TLSLD_LDST128_DTPREL_LO12)

JOKER CONSTANT R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC)"}
  R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC)

JOKER CONSTANT R_AARCH64_TLSLE_ADD_TPREL_HI12 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSLE_ADD_TPREL_HI12)"}
  R_AARCH64_TLSLE_ADD_TPREL_HI12)

JOKER CONSTANT R_AARCH64_TLSLE_ADD_TPREL_LO12 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSLE_ADD_TPREL_LO12)"}
  R_AARCH64_TLSLE_ADD_TPREL_LO12)

JOKER CONSTANT R_AARCH64_TLSLE_ADD_TPREL_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSLE_ADD_TPREL_LO12_NC)"}
  R_AARCH64_TLSLE_ADD_TPREL_LO12_NC)

JOKER CONSTANT R_AARCH64_TLSLE_LDST128_TPREL_LO12 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSLE_LDST128_TPREL_LO12)"}
  R_AARCH64_TLSLE_LDST128_TPREL_LO12)

JOKER CONSTANT R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC)"}
  R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC)

JOKER CONSTANT R_AARCH64_TLSLE_MOVW_TPREL_G0 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSLE_MOVW_TPREL_G0)"}
  R_AARCH64_TLSLE_MOVW_TPREL_G0)

JOKER CONSTANT R_AARCH64_TLSLE_MOVW_TPREL_G0_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSLE_MOVW_TPREL_G0_NC)"}
  R_AARCH64_TLSLE_MOVW_TPREL_G0_NC)

JOKER CONSTANT R_AARCH64_TLSLE_MOVW_TPREL_G1 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSLE_MOVW_TPREL_G1)"}
  R_AARCH64_TLSLE_MOVW_TPREL_G1)

JOKER CONSTANT R_AARCH64_TLSLE_MOVW_TPREL_G1_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSLE_MOVW_TPREL_G1_NC)"}
  R_AARCH64_TLSLE_MOVW_TPREL_G1_NC)

JOKER CONSTANT R_AARCH64_TLSLE_MOVW_TPREL_G2 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLSLE_MOVW_TPREL_G2)"}
  R_AARCH64_TLSLE_MOVW_TPREL_G2)

JOKER CONSTANT R_AARCH64_TLS_DTPMOD64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLS_DTPMOD64)"}
  R_AARCH64_TLS_DTPMOD64)

JOKER CONSTANT R_AARCH64_TLS_DTPREL64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLS_DTPREL64)"}
  R_AARCH64_TLS_DTPREL64)

JOKER CONSTANT R_AARCH64_TLS_TPREL64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TLS_TPREL64)"}
  R_AARCH64_TLS_TPREL64)

JOKER CONSTANT R_AARCH64_TSTBR14 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_AARCH64_TSTBR14)"}
  R_AARCH64_TSTBR14)

JOKER CONSTANT R_ALPHA_BRADDR from debug/elf/elf.go:
(def
  ^{:doc " PC+4 relative 23 bit shifted\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_BRADDR)"}
  R_ALPHA_BRADDR)

JOKER CONSTANT R_ALPHA_COPY from debug/elf/elf.go:
(def
  ^{:doc " Copy symbol at runtime\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_COPY)"}
  R_ALPHA_COPY)

JOKER CONSTANT R_ALPHA_GLOB_DAT from debug/elf/elf.go:
(def
  ^{:doc " Create GOT entry\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_GLOB_DAT)"}
  R_ALPHA_GLOB_DAT)

JOKER CONSTANT R_ALPHA_GPDISP from debug/elf/elf.go:
(def
  ^{:doc " Add displacement to GP\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_GPDISP)"}
  R_ALPHA_GPDISP)

JOKER CONSTANT R_ALPHA_GPREL32 from debug/elf/elf.go:
(def
  ^{:doc " GP relative 32 bit\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_GPREL32)"}
  R_ALPHA_GPREL32)

JOKER CONSTANT R_ALPHA_GPRELHIGH from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_GPRELHIGH)"}
  R_ALPHA_GPRELHIGH)

JOKER CONSTANT R_ALPHA_GPRELLOW from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_GPRELLOW)"}
  R_ALPHA_GPRELLOW)

JOKER CONSTANT R_ALPHA_GPVALUE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_GPVALUE)"}
  R_ALPHA_GPVALUE)

JOKER CONSTANT R_ALPHA_HINT from debug/elf/elf.go:
(def
  ^{:doc " PC+4 relative 16 bit shifted\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_HINT)"}
  R_ALPHA_HINT)

JOKER CONSTANT R_ALPHA_IMMED_BR_HI32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_IMMED_BR_HI32)"}
  R_ALPHA_IMMED_BR_HI32)

JOKER CONSTANT R_ALPHA_IMMED_GP_16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_IMMED_GP_16)"}
  R_ALPHA_IMMED_GP_16)

JOKER CONSTANT R_ALPHA_IMMED_GP_HI32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_IMMED_GP_HI32)"}
  R_ALPHA_IMMED_GP_HI32)

JOKER CONSTANT R_ALPHA_IMMED_LO32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_IMMED_LO32)"}
  R_ALPHA_IMMED_LO32)

JOKER CONSTANT R_ALPHA_IMMED_SCN_HI32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_IMMED_SCN_HI32)"}
  R_ALPHA_IMMED_SCN_HI32)

JOKER CONSTANT R_ALPHA_JMP_SLOT from debug/elf/elf.go:
(def
  ^{:doc " Create PLT entry\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_JMP_SLOT)"}
  R_ALPHA_JMP_SLOT)

JOKER CONSTANT R_ALPHA_LITERAL from debug/elf/elf.go:
(def
  ^{:doc " GP relative 16 bit w/optimization\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_LITERAL)"}
  R_ALPHA_LITERAL)

JOKER CONSTANT R_ALPHA_LITUSE from debug/elf/elf.go:
(def
  ^{:doc " Optimization hint for LITERAL\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_LITUSE)"}
  R_ALPHA_LITUSE)

JOKER CONSTANT R_ALPHA_NONE from debug/elf/elf.go:
(def
  ^{:doc " No reloc\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_NONE)"}
  R_ALPHA_NONE)

JOKER CONSTANT R_ALPHA_OP_PRSHIFT from debug/elf/elf.go:
(def
  ^{:doc " OP stack right shift\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_OP_PRSHIFT)"}
  R_ALPHA_OP_PRSHIFT)

JOKER CONSTANT R_ALPHA_OP_PSUB from debug/elf/elf.go:
(def
  ^{:doc " OP stack subtract\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_OP_PSUB)"}
  R_ALPHA_OP_PSUB)

JOKER CONSTANT R_ALPHA_OP_PUSH from debug/elf/elf.go:
(def
  ^{:doc " OP stack push\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_OP_PUSH)"}
  R_ALPHA_OP_PUSH)

JOKER CONSTANT R_ALPHA_OP_STORE from debug/elf/elf.go:
(def
  ^{:doc " OP stack pop and store\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_OP_STORE)"}
  R_ALPHA_OP_STORE)

JOKER CONSTANT R_ALPHA_REFLONG from debug/elf/elf.go:
(def
  ^{:doc " Direct 32 bit\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_REFLONG)"}
  R_ALPHA_REFLONG)

JOKER CONSTANT R_ALPHA_REFQUAD from debug/elf/elf.go:
(def
  ^{:doc " Direct 64 bit\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_REFQUAD)"}
  R_ALPHA_REFQUAD)

JOKER CONSTANT R_ALPHA_RELATIVE from debug/elf/elf.go:
(def
  ^{:doc " Adjust by program base\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_RELATIVE)"}
  R_ALPHA_RELATIVE)

JOKER CONSTANT R_ALPHA_SREL16 from debug/elf/elf.go:
(def
  ^{:doc " PC relative 16 bit\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_SREL16)"}
  R_ALPHA_SREL16)

JOKER CONSTANT R_ALPHA_SREL32 from debug/elf/elf.go:
(def
  ^{:doc " PC relative 32 bit\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_SREL32)"}
  R_ALPHA_SREL32)

JOKER CONSTANT R_ALPHA_SREL64 from debug/elf/elf.go:
(def
  ^{:doc " PC relative 64 bit\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ALPHA_SREL64)"}
  R_ALPHA_SREL64)

JOKER CONSTANT R_ARM_ABS12 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_ABS12)"}
  R_ARM_ABS12)

JOKER CONSTANT R_ARM_ABS16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_ABS16)"}
  R_ARM_ABS16)

JOKER CONSTANT R_ARM_ABS32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_ABS32)"}
  R_ARM_ABS32)

JOKER CONSTANT R_ARM_ABS32_NOI from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_ABS32_NOI)"}
  R_ARM_ABS32_NOI)

JOKER CONSTANT R_ARM_ABS8 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_ABS8)"}
  R_ARM_ABS8)

JOKER CONSTANT R_ARM_ALU_PCREL_15_8 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_ALU_PCREL_15_8)"}
  R_ARM_ALU_PCREL_15_8)

JOKER CONSTANT R_ARM_ALU_PCREL_23_15 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_ALU_PCREL_23_15)"}
  R_ARM_ALU_PCREL_23_15)

JOKER CONSTANT R_ARM_ALU_PCREL_7_0 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_ALU_PCREL_7_0)"}
  R_ARM_ALU_PCREL_7_0)

JOKER CONSTANT R_ARM_ALU_PC_G0 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_ALU_PC_G0)"}
  R_ARM_ALU_PC_G0)

JOKER CONSTANT R_ARM_ALU_PC_G0_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_ALU_PC_G0_NC)"}
  R_ARM_ALU_PC_G0_NC)

JOKER CONSTANT R_ARM_ALU_PC_G1 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_ALU_PC_G1)"}
  R_ARM_ALU_PC_G1)

JOKER CONSTANT R_ARM_ALU_PC_G1_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_ALU_PC_G1_NC)"}
  R_ARM_ALU_PC_G1_NC)

JOKER CONSTANT R_ARM_ALU_PC_G2 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_ALU_PC_G2)"}
  R_ARM_ALU_PC_G2)

JOKER CONSTANT R_ARM_ALU_SBREL_19_12_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_ALU_SBREL_19_12_NC)"}
  R_ARM_ALU_SBREL_19_12_NC)

JOKER CONSTANT R_ARM_ALU_SBREL_27_20_CK from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_ALU_SBREL_27_20_CK)"}
  R_ARM_ALU_SBREL_27_20_CK)

JOKER CONSTANT R_ARM_ALU_SB_G0 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_ALU_SB_G0)"}
  R_ARM_ALU_SB_G0)

JOKER CONSTANT R_ARM_ALU_SB_G0_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_ALU_SB_G0_NC)"}
  R_ARM_ALU_SB_G0_NC)

JOKER CONSTANT R_ARM_ALU_SB_G1 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_ALU_SB_G1)"}
  R_ARM_ALU_SB_G1)

JOKER CONSTANT R_ARM_ALU_SB_G1_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_ALU_SB_G1_NC)"}
  R_ARM_ALU_SB_G1_NC)

JOKER CONSTANT R_ARM_ALU_SB_G2 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_ALU_SB_G2)"}
  R_ARM_ALU_SB_G2)

JOKER CONSTANT R_ARM_AMP_VCALL9 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_AMP_VCALL9)"}
  R_ARM_AMP_VCALL9)

JOKER CONSTANT R_ARM_BASE_ABS from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_BASE_ABS)"}
  R_ARM_BASE_ABS)

JOKER CONSTANT R_ARM_CALL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_CALL)"}
  R_ARM_CALL)

JOKER CONSTANT R_ARM_COPY from debug/elf/elf.go:
(def
  ^{:doc " Copy data from shared object.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_COPY)"}
  R_ARM_COPY)

JOKER CONSTANT R_ARM_GLOB_DAT from debug/elf/elf.go:
(def
  ^{:doc " Set GOT entry to data address.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_GLOB_DAT)"}
  R_ARM_GLOB_DAT)

JOKER CONSTANT R_ARM_GNU_VTENTRY from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_GNU_VTENTRY)"}
  R_ARM_GNU_VTENTRY)

JOKER CONSTANT R_ARM_GNU_VTINHERIT from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_GNU_VTINHERIT)"}
  R_ARM_GNU_VTINHERIT)

JOKER CONSTANT R_ARM_GOT32 from debug/elf/elf.go:
(def
  ^{:doc " Add PC-relative GOT offset.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_GOT32)"}
  R_ARM_GOT32)

JOKER CONSTANT R_ARM_GOTOFF from debug/elf/elf.go:
(def
  ^{:doc " Add GOT-relative symbol address.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_GOTOFF)"}
  R_ARM_GOTOFF)

JOKER CONSTANT R_ARM_GOTOFF12 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_GOTOFF12)"}
  R_ARM_GOTOFF12)

JOKER CONSTANT R_ARM_GOTPC from debug/elf/elf.go:
(def
  ^{:doc " Add PC-relative GOT table address.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_GOTPC)"}
  R_ARM_GOTPC)

JOKER CONSTANT R_ARM_GOTRELAX from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_GOTRELAX)"}
  R_ARM_GOTRELAX)

JOKER CONSTANT R_ARM_GOT_ABS from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_GOT_ABS)"}
  R_ARM_GOT_ABS)

JOKER CONSTANT R_ARM_GOT_BREL12 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_GOT_BREL12)"}
  R_ARM_GOT_BREL12)

JOKER CONSTANT R_ARM_GOT_PREL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_GOT_PREL)"}
  R_ARM_GOT_PREL)

JOKER CONSTANT R_ARM_IRELATIVE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_IRELATIVE)"}
  R_ARM_IRELATIVE)

JOKER CONSTANT R_ARM_JUMP24 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_JUMP24)"}
  R_ARM_JUMP24)

JOKER CONSTANT R_ARM_JUMP_SLOT from debug/elf/elf.go:
(def
  ^{:doc " Set GOT entry to code address.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_JUMP_SLOT)"}
  R_ARM_JUMP_SLOT)

JOKER CONSTANT R_ARM_LDC_PC_G0 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_LDC_PC_G0)"}
  R_ARM_LDC_PC_G0)

JOKER CONSTANT R_ARM_LDC_PC_G1 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_LDC_PC_G1)"}
  R_ARM_LDC_PC_G1)

JOKER CONSTANT R_ARM_LDC_PC_G2 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_LDC_PC_G2)"}
  R_ARM_LDC_PC_G2)

JOKER CONSTANT R_ARM_LDC_SB_G0 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_LDC_SB_G0)"}
  R_ARM_LDC_SB_G0)

JOKER CONSTANT R_ARM_LDC_SB_G1 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_LDC_SB_G1)"}
  R_ARM_LDC_SB_G1)

JOKER CONSTANT R_ARM_LDC_SB_G2 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_LDC_SB_G2)"}
  R_ARM_LDC_SB_G2)

JOKER CONSTANT R_ARM_LDRS_PC_G0 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_LDRS_PC_G0)"}
  R_ARM_LDRS_PC_G0)

JOKER CONSTANT R_ARM_LDRS_PC_G1 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_LDRS_PC_G1)"}
  R_ARM_LDRS_PC_G1)

JOKER CONSTANT R_ARM_LDRS_PC_G2 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_LDRS_PC_G2)"}
  R_ARM_LDRS_PC_G2)

JOKER CONSTANT R_ARM_LDRS_SB_G0 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_LDRS_SB_G0)"}
  R_ARM_LDRS_SB_G0)

JOKER CONSTANT R_ARM_LDRS_SB_G1 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_LDRS_SB_G1)"}
  R_ARM_LDRS_SB_G1)

JOKER CONSTANT R_ARM_LDRS_SB_G2 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_LDRS_SB_G2)"}
  R_ARM_LDRS_SB_G2)

JOKER CONSTANT R_ARM_LDR_PC_G1 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_LDR_PC_G1)"}
  R_ARM_LDR_PC_G1)

JOKER CONSTANT R_ARM_LDR_PC_G2 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_LDR_PC_G2)"}
  R_ARM_LDR_PC_G2)

JOKER CONSTANT R_ARM_LDR_SBREL_11_10_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_LDR_SBREL_11_10_NC)"}
  R_ARM_LDR_SBREL_11_10_NC)

JOKER CONSTANT R_ARM_LDR_SB_G0 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_LDR_SB_G0)"}
  R_ARM_LDR_SB_G0)

JOKER CONSTANT R_ARM_LDR_SB_G1 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_LDR_SB_G1)"}
  R_ARM_LDR_SB_G1)

JOKER CONSTANT R_ARM_LDR_SB_G2 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_LDR_SB_G2)"}
  R_ARM_LDR_SB_G2)

JOKER CONSTANT R_ARM_ME_TOO from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_ME_TOO)"}
  R_ARM_ME_TOO)

JOKER CONSTANT R_ARM_MOVT_ABS from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_MOVT_ABS)"}
  R_ARM_MOVT_ABS)

JOKER CONSTANT R_ARM_MOVT_BREL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_MOVT_BREL)"}
  R_ARM_MOVT_BREL)

JOKER CONSTANT R_ARM_MOVT_PREL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_MOVT_PREL)"}
  R_ARM_MOVT_PREL)

JOKER CONSTANT R_ARM_MOVW_ABS_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_MOVW_ABS_NC)"}
  R_ARM_MOVW_ABS_NC)

JOKER CONSTANT R_ARM_MOVW_BREL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_MOVW_BREL)"}
  R_ARM_MOVW_BREL)

JOKER CONSTANT R_ARM_MOVW_BREL_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_MOVW_BREL_NC)"}
  R_ARM_MOVW_BREL_NC)

JOKER CONSTANT R_ARM_MOVW_PREL_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_MOVW_PREL_NC)"}
  R_ARM_MOVW_PREL_NC)

JOKER CONSTANT R_ARM_NONE from debug/elf/elf.go:
(def
  ^{:doc " No relocation.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_NONE)"}
  R_ARM_NONE)

JOKER CONSTANT R_ARM_PC13 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_PC13)"}
  R_ARM_PC13)

JOKER CONSTANT R_ARM_PC24 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_PC24)"}
  R_ARM_PC24)

JOKER CONSTANT R_ARM_PLT32 from debug/elf/elf.go:
(def
  ^{:doc " Add PC-relative PLT offset.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_PLT32)"}
  R_ARM_PLT32)

JOKER CONSTANT R_ARM_PLT32_ABS from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_PLT32_ABS)"}
  R_ARM_PLT32_ABS)

JOKER CONSTANT R_ARM_PREL31 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_PREL31)"}
  R_ARM_PREL31)

JOKER CONSTANT R_ARM_PRIVATE_0 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_PRIVATE_0)"}
  R_ARM_PRIVATE_0)

JOKER CONSTANT R_ARM_PRIVATE_1 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_PRIVATE_1)"}
  R_ARM_PRIVATE_1)

JOKER CONSTANT R_ARM_PRIVATE_10 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_PRIVATE_10)"}
  R_ARM_PRIVATE_10)

JOKER CONSTANT R_ARM_PRIVATE_11 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_PRIVATE_11)"}
  R_ARM_PRIVATE_11)

JOKER CONSTANT R_ARM_PRIVATE_12 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_PRIVATE_12)"}
  R_ARM_PRIVATE_12)

JOKER CONSTANT R_ARM_PRIVATE_13 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_PRIVATE_13)"}
  R_ARM_PRIVATE_13)

JOKER CONSTANT R_ARM_PRIVATE_14 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_PRIVATE_14)"}
  R_ARM_PRIVATE_14)

JOKER CONSTANT R_ARM_PRIVATE_15 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_PRIVATE_15)"}
  R_ARM_PRIVATE_15)

JOKER CONSTANT R_ARM_PRIVATE_2 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_PRIVATE_2)"}
  R_ARM_PRIVATE_2)

JOKER CONSTANT R_ARM_PRIVATE_3 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_PRIVATE_3)"}
  R_ARM_PRIVATE_3)

JOKER CONSTANT R_ARM_PRIVATE_4 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_PRIVATE_4)"}
  R_ARM_PRIVATE_4)

JOKER CONSTANT R_ARM_PRIVATE_5 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_PRIVATE_5)"}
  R_ARM_PRIVATE_5)

JOKER CONSTANT R_ARM_PRIVATE_6 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_PRIVATE_6)"}
  R_ARM_PRIVATE_6)

JOKER CONSTANT R_ARM_PRIVATE_7 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_PRIVATE_7)"}
  R_ARM_PRIVATE_7)

JOKER CONSTANT R_ARM_PRIVATE_8 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_PRIVATE_8)"}
  R_ARM_PRIVATE_8)

JOKER CONSTANT R_ARM_PRIVATE_9 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_PRIVATE_9)"}
  R_ARM_PRIVATE_9)

JOKER CONSTANT R_ARM_RABS32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_RABS32)"}
  R_ARM_RABS32)

JOKER CONSTANT R_ARM_RBASE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_RBASE)"}
  R_ARM_RBASE)

JOKER CONSTANT R_ARM_REL32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_REL32)"}
  R_ARM_REL32)

JOKER CONSTANT R_ARM_REL32_NOI from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_REL32_NOI)"}
  R_ARM_REL32_NOI)

JOKER CONSTANT R_ARM_RELATIVE from debug/elf/elf.go:
(def
  ^{:doc " Add load address of shared object.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_RELATIVE)"}
  R_ARM_RELATIVE)

JOKER CONSTANT R_ARM_RPC24 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_RPC24)"}
  R_ARM_RPC24)

JOKER CONSTANT R_ARM_RREL32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_RREL32)"}
  R_ARM_RREL32)

JOKER CONSTANT R_ARM_RSBREL32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_RSBREL32)"}
  R_ARM_RSBREL32)

JOKER CONSTANT R_ARM_RXPC25 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_RXPC25)"}
  R_ARM_RXPC25)

JOKER CONSTANT R_ARM_SBREL31 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_SBREL31)"}
  R_ARM_SBREL31)

JOKER CONSTANT R_ARM_SBREL32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_SBREL32)"}
  R_ARM_SBREL32)

JOKER CONSTANT R_ARM_SWI24 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_SWI24)"}
  R_ARM_SWI24)

JOKER CONSTANT R_ARM_TARGET1 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_TARGET1)"}
  R_ARM_TARGET1)

JOKER CONSTANT R_ARM_TARGET2 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_TARGET2)"}
  R_ARM_TARGET2)

JOKER CONSTANT R_ARM_THM_ABS5 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_ABS5)"}
  R_ARM_THM_ABS5)

JOKER CONSTANT R_ARM_THM_ALU_ABS_G0_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_ALU_ABS_G0_NC)"}
  R_ARM_THM_ALU_ABS_G0_NC)

JOKER CONSTANT R_ARM_THM_ALU_ABS_G1_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_ALU_ABS_G1_NC)"}
  R_ARM_THM_ALU_ABS_G1_NC)

JOKER CONSTANT R_ARM_THM_ALU_ABS_G2_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_ALU_ABS_G2_NC)"}
  R_ARM_THM_ALU_ABS_G2_NC)

JOKER CONSTANT R_ARM_THM_ALU_ABS_G3 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_ALU_ABS_G3)"}
  R_ARM_THM_ALU_ABS_G3)

JOKER CONSTANT R_ARM_THM_ALU_PREL_11_0 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_ALU_PREL_11_0)"}
  R_ARM_THM_ALU_PREL_11_0)

JOKER CONSTANT R_ARM_THM_GOT_BREL12 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_GOT_BREL12)"}
  R_ARM_THM_GOT_BREL12)

JOKER CONSTANT R_ARM_THM_JUMP11 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_JUMP11)"}
  R_ARM_THM_JUMP11)

JOKER CONSTANT R_ARM_THM_JUMP19 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_JUMP19)"}
  R_ARM_THM_JUMP19)

JOKER CONSTANT R_ARM_THM_JUMP24 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_JUMP24)"}
  R_ARM_THM_JUMP24)

JOKER CONSTANT R_ARM_THM_JUMP6 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_JUMP6)"}
  R_ARM_THM_JUMP6)

JOKER CONSTANT R_ARM_THM_JUMP8 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_JUMP8)"}
  R_ARM_THM_JUMP8)

JOKER CONSTANT R_ARM_THM_MOVT_ABS from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_MOVT_ABS)"}
  R_ARM_THM_MOVT_ABS)

JOKER CONSTANT R_ARM_THM_MOVT_BREL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_MOVT_BREL)"}
  R_ARM_THM_MOVT_BREL)

JOKER CONSTANT R_ARM_THM_MOVT_PREL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_MOVT_PREL)"}
  R_ARM_THM_MOVT_PREL)

JOKER CONSTANT R_ARM_THM_MOVW_ABS_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_MOVW_ABS_NC)"}
  R_ARM_THM_MOVW_ABS_NC)

JOKER CONSTANT R_ARM_THM_MOVW_BREL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_MOVW_BREL)"}
  R_ARM_THM_MOVW_BREL)

JOKER CONSTANT R_ARM_THM_MOVW_BREL_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_MOVW_BREL_NC)"}
  R_ARM_THM_MOVW_BREL_NC)

JOKER CONSTANT R_ARM_THM_MOVW_PREL_NC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_MOVW_PREL_NC)"}
  R_ARM_THM_MOVW_PREL_NC)

JOKER CONSTANT R_ARM_THM_PC12 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_PC12)"}
  R_ARM_THM_PC12)

JOKER CONSTANT R_ARM_THM_PC22 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_PC22)"}
  R_ARM_THM_PC22)

JOKER CONSTANT R_ARM_THM_PC8 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_PC8)"}
  R_ARM_THM_PC8)

JOKER CONSTANT R_ARM_THM_RPC22 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_RPC22)"}
  R_ARM_THM_RPC22)

JOKER CONSTANT R_ARM_THM_SWI8 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_SWI8)"}
  R_ARM_THM_SWI8)

JOKER CONSTANT R_ARM_THM_TLS_CALL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_TLS_CALL)"}
  R_ARM_THM_TLS_CALL)

JOKER CONSTANT R_ARM_THM_TLS_DESCSEQ16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_TLS_DESCSEQ16)"}
  R_ARM_THM_TLS_DESCSEQ16)

JOKER CONSTANT R_ARM_THM_TLS_DESCSEQ32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_TLS_DESCSEQ32)"}
  R_ARM_THM_TLS_DESCSEQ32)

JOKER CONSTANT R_ARM_THM_XPC22 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_THM_XPC22)"}
  R_ARM_THM_XPC22)

JOKER CONSTANT R_ARM_TLS_CALL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_TLS_CALL)"}
  R_ARM_TLS_CALL)

JOKER CONSTANT R_ARM_TLS_DESCSEQ from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_TLS_DESCSEQ)"}
  R_ARM_TLS_DESCSEQ)

JOKER CONSTANT R_ARM_TLS_DTPMOD32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_TLS_DTPMOD32)"}
  R_ARM_TLS_DTPMOD32)

JOKER CONSTANT R_ARM_TLS_DTPOFF32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_TLS_DTPOFF32)"}
  R_ARM_TLS_DTPOFF32)

JOKER CONSTANT R_ARM_TLS_GD32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_TLS_GD32)"}
  R_ARM_TLS_GD32)

JOKER CONSTANT R_ARM_TLS_GOTDESC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_TLS_GOTDESC)"}
  R_ARM_TLS_GOTDESC)

JOKER CONSTANT R_ARM_TLS_IE12GP from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_TLS_IE12GP)"}
  R_ARM_TLS_IE12GP)

JOKER CONSTANT R_ARM_TLS_IE32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_TLS_IE32)"}
  R_ARM_TLS_IE32)

JOKER CONSTANT R_ARM_TLS_LDM32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_TLS_LDM32)"}
  R_ARM_TLS_LDM32)

JOKER CONSTANT R_ARM_TLS_LDO12 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_TLS_LDO12)"}
  R_ARM_TLS_LDO12)

JOKER CONSTANT R_ARM_TLS_LDO32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_TLS_LDO32)"}
  R_ARM_TLS_LDO32)

JOKER CONSTANT R_ARM_TLS_LE12 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_TLS_LE12)"}
  R_ARM_TLS_LE12)

JOKER CONSTANT R_ARM_TLS_LE32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_TLS_LE32)"}
  R_ARM_TLS_LE32)

JOKER CONSTANT R_ARM_TLS_TPOFF32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_TLS_TPOFF32)"}
  R_ARM_TLS_TPOFF32)

JOKER CONSTANT R_ARM_V4BX from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_V4BX)"}
  R_ARM_V4BX)

JOKER CONSTANT R_ARM_XPC25 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_ARM_XPC25)"}
  R_ARM_XPC25)

JOKER CONSTANT R_MIPS_16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_16)"}
  R_MIPS_16)

JOKER CONSTANT R_MIPS_26 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_26)"}
  R_MIPS_26)

JOKER CONSTANT R_MIPS_32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_32)"}
  R_MIPS_32)

JOKER CONSTANT R_MIPS_64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_64)"}
  R_MIPS_64)

JOKER CONSTANT R_MIPS_ADD_IMMEDIATE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_ADD_IMMEDIATE)"}
  R_MIPS_ADD_IMMEDIATE)

JOKER CONSTANT R_MIPS_CALL16 from debug/elf/elf.go:
(def
  ^{:doc " 16 bit call through glbl offset tbl\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_CALL16)"}
  R_MIPS_CALL16)

JOKER CONSTANT R_MIPS_CALL_HI16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_CALL_HI16)"}
  R_MIPS_CALL_HI16)

JOKER CONSTANT R_MIPS_CALL_LO16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_CALL_LO16)"}
  R_MIPS_CALL_LO16)

JOKER CONSTANT R_MIPS_DELETE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_DELETE)"}
  R_MIPS_DELETE)

JOKER CONSTANT R_MIPS_GOT16 from debug/elf/elf.go:
(def
  ^{:doc " Reference to global offset table\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_GOT16)"}
  R_MIPS_GOT16)

JOKER CONSTANT R_MIPS_GOT_DISP from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_GOT_DISP)"}
  R_MIPS_GOT_DISP)

JOKER CONSTANT R_MIPS_GOT_HI16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_GOT_HI16)"}
  R_MIPS_GOT_HI16)

JOKER CONSTANT R_MIPS_GOT_LO16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_GOT_LO16)"}
  R_MIPS_GOT_LO16)

JOKER CONSTANT R_MIPS_GOT_OFST from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_GOT_OFST)"}
  R_MIPS_GOT_OFST)

JOKER CONSTANT R_MIPS_GOT_PAGE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_GOT_PAGE)"}
  R_MIPS_GOT_PAGE)

JOKER CONSTANT R_MIPS_GPREL16 from debug/elf/elf.go:
(def
  ^{:doc " GP-relative reference\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_GPREL16)"}
  R_MIPS_GPREL16)

JOKER CONSTANT R_MIPS_GPREL32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_GPREL32)"}
  R_MIPS_GPREL32)

JOKER CONSTANT R_MIPS_HI16 from debug/elf/elf.go:
(def
  ^{:doc " high 16 bits of symbol value\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_HI16)"}
  R_MIPS_HI16)

JOKER CONSTANT R_MIPS_HIGHER from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_HIGHER)"}
  R_MIPS_HIGHER)

JOKER CONSTANT R_MIPS_HIGHEST from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_HIGHEST)"}
  R_MIPS_HIGHEST)

JOKER CONSTANT R_MIPS_INSERT_A from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_INSERT_A)"}
  R_MIPS_INSERT_A)

JOKER CONSTANT R_MIPS_INSERT_B from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_INSERT_B)"}
  R_MIPS_INSERT_B)

JOKER CONSTANT R_MIPS_JALR from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_JALR)"}
  R_MIPS_JALR)

JOKER CONSTANT R_MIPS_LITERAL from debug/elf/elf.go:
(def
  ^{:doc " Reference to literal section\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_LITERAL)"}
  R_MIPS_LITERAL)

JOKER CONSTANT R_MIPS_LO16 from debug/elf/elf.go:
(def
  ^{:doc " low 16 bits of symbol value\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_LO16)"}
  R_MIPS_LO16)

JOKER CONSTANT R_MIPS_NONE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_NONE)"}
  R_MIPS_NONE)

JOKER CONSTANT R_MIPS_PC16 from debug/elf/elf.go:
(def
  ^{:doc " 16 bit PC relative reference\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_PC16)"}
  R_MIPS_PC16)

JOKER CONSTANT R_MIPS_PJUMP from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_PJUMP)"}
  R_MIPS_PJUMP)

JOKER CONSTANT R_MIPS_REL16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_REL16)"}
  R_MIPS_REL16)

JOKER CONSTANT R_MIPS_REL32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_REL32)"}
  R_MIPS_REL32)

JOKER CONSTANT R_MIPS_RELGOT from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_RELGOT)"}
  R_MIPS_RELGOT)

JOKER CONSTANT R_MIPS_SCN_DISP from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_SCN_DISP)"}
  R_MIPS_SCN_DISP)

JOKER CONSTANT R_MIPS_SHIFT5 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_SHIFT5)"}
  R_MIPS_SHIFT5)

JOKER CONSTANT R_MIPS_SHIFT6 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_SHIFT6)"}
  R_MIPS_SHIFT6)

JOKER CONSTANT R_MIPS_SUB from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_SUB)"}
  R_MIPS_SUB)

JOKER CONSTANT R_MIPS_TLS_DTPMOD32 from debug/elf/elf.go:
(def
  ^{:doc " Module number 32 bit\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_TLS_DTPMOD32)"}
  R_MIPS_TLS_DTPMOD32)

JOKER CONSTANT R_MIPS_TLS_DTPMOD64 from debug/elf/elf.go:
(def
  ^{:doc " Module number 64 bit\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_TLS_DTPMOD64)"}
  R_MIPS_TLS_DTPMOD64)

JOKER CONSTANT R_MIPS_TLS_DTPREL32 from debug/elf/elf.go:
(def
  ^{:doc " Module-relative offset 32 bit\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_TLS_DTPREL32)"}
  R_MIPS_TLS_DTPREL32)

JOKER CONSTANT R_MIPS_TLS_DTPREL64 from debug/elf/elf.go:
(def
  ^{:doc " Module-relative offset 64 bit\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_TLS_DTPREL64)"}
  R_MIPS_TLS_DTPREL64)

JOKER CONSTANT R_MIPS_TLS_DTPREL_HI16 from debug/elf/elf.go:
(def
  ^{:doc " Module-relative offset, high 16 bits\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_TLS_DTPREL_HI16)"}
  R_MIPS_TLS_DTPREL_HI16)

JOKER CONSTANT R_MIPS_TLS_DTPREL_LO16 from debug/elf/elf.go:
(def
  ^{:doc " Module-relative offset, low 16 bits\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_TLS_DTPREL_LO16)"}
  R_MIPS_TLS_DTPREL_LO16)

JOKER CONSTANT R_MIPS_TLS_GD from debug/elf/elf.go:
(def
  ^{:doc " 16 bit GOT offset for GD\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_TLS_GD)"}
  R_MIPS_TLS_GD)

JOKER CONSTANT R_MIPS_TLS_GOTTPREL from debug/elf/elf.go:
(def
  ^{:doc " 16 bit GOT offset for IE\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_TLS_GOTTPREL)"}
  R_MIPS_TLS_GOTTPREL)

JOKER CONSTANT R_MIPS_TLS_LDM from debug/elf/elf.go:
(def
  ^{:doc " 16 bit GOT offset for LDM\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_TLS_LDM)"}
  R_MIPS_TLS_LDM)

JOKER CONSTANT R_MIPS_TLS_TPREL32 from debug/elf/elf.go:
(def
  ^{:doc " TP-relative offset, 32 bit\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_TLS_TPREL32)"}
  R_MIPS_TLS_TPREL32)

JOKER CONSTANT R_MIPS_TLS_TPREL64 from debug/elf/elf.go:
(def
  ^{:doc " TP-relative offset, 64 bit\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_TLS_TPREL64)"}
  R_MIPS_TLS_TPREL64)

JOKER CONSTANT R_MIPS_TLS_TPREL_HI16 from debug/elf/elf.go:
(def
  ^{:doc " TP-relative offset, high 16 bits\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_TLS_TPREL_HI16)"}
  R_MIPS_TLS_TPREL_HI16)

JOKER CONSTANT R_MIPS_TLS_TPREL_LO16 from debug/elf/elf.go:
(def
  ^{:doc " TP-relative offset, low 16 bits\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_MIPS_TLS_TPREL_LO16)"}
  R_MIPS_TLS_TPREL_LO16)

JOKER CONSTANT R_PPC64_ADDR14 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_ADDR14\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_ADDR14)"}
  R_PPC64_ADDR14)

JOKER CONSTANT R_PPC64_ADDR14_BRNTAKEN from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_ADDR14_BRNTAKEN\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_ADDR14_BRNTAKEN)"}
  R_PPC64_ADDR14_BRNTAKEN)

JOKER CONSTANT R_PPC64_ADDR14_BRTAKEN from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_ADDR14_BRTAKEN\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_ADDR14_BRTAKEN)"}
  R_PPC64_ADDR14_BRTAKEN)

JOKER CONSTANT R_PPC64_ADDR16 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_ADDR16\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_ADDR16)"}
  R_PPC64_ADDR16)

JOKER CONSTANT R_PPC64_ADDR16_DS from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_ADDR16_DS)"}
  R_PPC64_ADDR16_DS)

JOKER CONSTANT R_PPC64_ADDR16_HA from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_ADDR16_HA\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_ADDR16_HA)"}
  R_PPC64_ADDR16_HA)

JOKER CONSTANT R_PPC64_ADDR16_HI from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_ADDR16_HI\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_ADDR16_HI)"}
  R_PPC64_ADDR16_HI)

JOKER CONSTANT R_PPC64_ADDR16_HIGH from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_ADDR16_HIGH)"}
  R_PPC64_ADDR16_HIGH)

JOKER CONSTANT R_PPC64_ADDR16_HIGHA from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_ADDR16_HIGHA)"}
  R_PPC64_ADDR16_HIGHA)

JOKER CONSTANT R_PPC64_ADDR16_HIGHER from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_ADDR16_HIGHER)"}
  R_PPC64_ADDR16_HIGHER)

JOKER CONSTANT R_PPC64_ADDR16_HIGHERA from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_ADDR16_HIGHERA)"}
  R_PPC64_ADDR16_HIGHERA)

JOKER CONSTANT R_PPC64_ADDR16_HIGHEST from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_ADDR16_HIGHEST)"}
  R_PPC64_ADDR16_HIGHEST)

JOKER CONSTANT R_PPC64_ADDR16_HIGHESTA from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_ADDR16_HIGHESTA)"}
  R_PPC64_ADDR16_HIGHESTA)

JOKER CONSTANT R_PPC64_ADDR16_LO from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_ADDR16_LO\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_ADDR16_LO)"}
  R_PPC64_ADDR16_LO)

JOKER CONSTANT R_PPC64_ADDR16_LO_DS from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_ADDR16_LO_DS)"}
  R_PPC64_ADDR16_LO_DS)

JOKER CONSTANT R_PPC64_ADDR24 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_ADDR24\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_ADDR24)"}
  R_PPC64_ADDR24)

JOKER CONSTANT R_PPC64_ADDR32 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_ADDR32\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_ADDR32)"}
  R_PPC64_ADDR32)

JOKER CONSTANT R_PPC64_ADDR64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_ADDR64)"}
  R_PPC64_ADDR64)

JOKER CONSTANT R_PPC64_ADDR64_LOCAL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_ADDR64_LOCAL)"}
  R_PPC64_ADDR64_LOCAL)

JOKER CONSTANT R_PPC64_DTPMOD64 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_DTPMOD64\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_DTPMOD64)"}
  R_PPC64_DTPMOD64)

JOKER CONSTANT R_PPC64_DTPREL16 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_DTPREL16\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_DTPREL16)"}
  R_PPC64_DTPREL16)

JOKER CONSTANT R_PPC64_DTPREL16_DS from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_DTPREL16_DS)"}
  R_PPC64_DTPREL16_DS)

JOKER CONSTANT R_PPC64_DTPREL16_HA from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_DTPREL16_HA\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_DTPREL16_HA)"}
  R_PPC64_DTPREL16_HA)

JOKER CONSTANT R_PPC64_DTPREL16_HI from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_DTPREL16_HI\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_DTPREL16_HI)"}
  R_PPC64_DTPREL16_HI)

JOKER CONSTANT R_PPC64_DTPREL16_HIGH from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_DTPREL16_HIGH)"}
  R_PPC64_DTPREL16_HIGH)

JOKER CONSTANT R_PPC64_DTPREL16_HIGHA from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_DTPREL16_HIGHA)"}
  R_PPC64_DTPREL16_HIGHA)

JOKER CONSTANT R_PPC64_DTPREL16_HIGHER from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_DTPREL16_HIGHER)"}
  R_PPC64_DTPREL16_HIGHER)

JOKER CONSTANT R_PPC64_DTPREL16_HIGHERA from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_DTPREL16_HIGHERA)"}
  R_PPC64_DTPREL16_HIGHERA)

JOKER CONSTANT R_PPC64_DTPREL16_HIGHEST from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_DTPREL16_HIGHEST)"}
  R_PPC64_DTPREL16_HIGHEST)

JOKER CONSTANT R_PPC64_DTPREL16_HIGHESTA from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_DTPREL16_HIGHESTA)"}
  R_PPC64_DTPREL16_HIGHESTA)

JOKER CONSTANT R_PPC64_DTPREL16_LO from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_DTPREL16_LO\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_DTPREL16_LO)"}
  R_PPC64_DTPREL16_LO)

JOKER CONSTANT R_PPC64_DTPREL16_LO_DS from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_DTPREL16_LO_DS)"}
  R_PPC64_DTPREL16_LO_DS)

JOKER CONSTANT R_PPC64_DTPREL64 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_DTPREL64\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_DTPREL64)"}
  R_PPC64_DTPREL64)

JOKER CONSTANT R_PPC64_ENTRY from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_ENTRY)"}
  R_PPC64_ENTRY)

JOKER CONSTANT R_PPC64_GOT16 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT16\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT16)"}
  R_PPC64_GOT16)

JOKER CONSTANT R_PPC64_GOT16_DS from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT16_DS)"}
  R_PPC64_GOT16_DS)

JOKER CONSTANT R_PPC64_GOT16_HA from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT16_HA\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT16_HA)"}
  R_PPC64_GOT16_HA)

JOKER CONSTANT R_PPC64_GOT16_HI from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT16_HI\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT16_HI)"}
  R_PPC64_GOT16_HI)

JOKER CONSTANT R_PPC64_GOT16_LO from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT16_LO\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT16_LO)"}
  R_PPC64_GOT16_LO)

JOKER CONSTANT R_PPC64_GOT16_LO_DS from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT16_LO_DS)"}
  R_PPC64_GOT16_LO_DS)

JOKER CONSTANT R_PPC64_GOT_DTPREL16_DS from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_DTPREL16_DS\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT_DTPREL16_DS)"}
  R_PPC64_GOT_DTPREL16_DS)

JOKER CONSTANT R_PPC64_GOT_DTPREL16_HA from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_DTPREL16_HA\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT_DTPREL16_HA)"}
  R_PPC64_GOT_DTPREL16_HA)

JOKER CONSTANT R_PPC64_GOT_DTPREL16_HI from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_DTPREL16_HI\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT_DTPREL16_HI)"}
  R_PPC64_GOT_DTPREL16_HI)

JOKER CONSTANT R_PPC64_GOT_DTPREL16_LO_DS from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_DTPREL16_LO_DS\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT_DTPREL16_LO_DS)"}
  R_PPC64_GOT_DTPREL16_LO_DS)

JOKER CONSTANT R_PPC64_GOT_TLSGD16 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TLSGD16\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT_TLSGD16)"}
  R_PPC64_GOT_TLSGD16)

JOKER CONSTANT R_PPC64_GOT_TLSGD16_HA from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TLSGD16_HA\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT_TLSGD16_HA)"}
  R_PPC64_GOT_TLSGD16_HA)

JOKER CONSTANT R_PPC64_GOT_TLSGD16_HI from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TLSGD16_HI\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT_TLSGD16_HI)"}
  R_PPC64_GOT_TLSGD16_HI)

JOKER CONSTANT R_PPC64_GOT_TLSGD16_LO from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TLSGD16_LO\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT_TLSGD16_LO)"}
  R_PPC64_GOT_TLSGD16_LO)

JOKER CONSTANT R_PPC64_GOT_TLSLD16 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TLSLD16\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT_TLSLD16)"}
  R_PPC64_GOT_TLSLD16)

JOKER CONSTANT R_PPC64_GOT_TLSLD16_HA from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TLSLD16_HA\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT_TLSLD16_HA)"}
  R_PPC64_GOT_TLSLD16_HA)

JOKER CONSTANT R_PPC64_GOT_TLSLD16_HI from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TLSLD16_HI\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT_TLSLD16_HI)"}
  R_PPC64_GOT_TLSLD16_HI)

JOKER CONSTANT R_PPC64_GOT_TLSLD16_LO from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TLSLD16_LO\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT_TLSLD16_LO)"}
  R_PPC64_GOT_TLSLD16_LO)

JOKER CONSTANT R_PPC64_GOT_TPREL16_DS from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TPREL16_DS\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT_TPREL16_DS)"}
  R_PPC64_GOT_TPREL16_DS)

JOKER CONSTANT R_PPC64_GOT_TPREL16_HA from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TPREL16_HA\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT_TPREL16_HA)"}
  R_PPC64_GOT_TPREL16_HA)

JOKER CONSTANT R_PPC64_GOT_TPREL16_HI from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TPREL16_HI\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT_TPREL16_HI)"}
  R_PPC64_GOT_TPREL16_HI)

JOKER CONSTANT R_PPC64_GOT_TPREL16_LO_DS from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TPREL16_LO_DS\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_GOT_TPREL16_LO_DS)"}
  R_PPC64_GOT_TPREL16_LO_DS)

JOKER CONSTANT R_PPC64_IRELATIVE from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_IRELATIVE\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_IRELATIVE)"}
  R_PPC64_IRELATIVE)

JOKER CONSTANT R_PPC64_JMP_IREL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_JMP_IREL)"}
  R_PPC64_JMP_IREL)

JOKER CONSTANT R_PPC64_JMP_SLOT from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_JMP_SLOT\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_JMP_SLOT)"}
  R_PPC64_JMP_SLOT)

JOKER CONSTANT R_PPC64_NONE from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_NONE\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_NONE)"}
  R_PPC64_NONE)

JOKER CONSTANT R_PPC64_PLT16_LO_DS from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_PLT16_LO_DS)"}
  R_PPC64_PLT16_LO_DS)

JOKER CONSTANT R_PPC64_PLTGOT16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_PLTGOT16)"}
  R_PPC64_PLTGOT16)

JOKER CONSTANT R_PPC64_PLTGOT16_DS from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_PLTGOT16_DS)"}
  R_PPC64_PLTGOT16_DS)

JOKER CONSTANT R_PPC64_PLTGOT16_HA from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_PLTGOT16_HA)"}
  R_PPC64_PLTGOT16_HA)

JOKER CONSTANT R_PPC64_PLTGOT16_HI from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_PLTGOT16_HI)"}
  R_PPC64_PLTGOT16_HI)

JOKER CONSTANT R_PPC64_PLTGOT16_LO from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_PLTGOT16_LO)"}
  R_PPC64_PLTGOT16_LO)

JOKER CONSTANT R_PPC64_PLTGOT_LO_DS from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_PLTGOT_LO_DS)"}
  R_PPC64_PLTGOT_LO_DS)

JOKER CONSTANT R_PPC64_REL14 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_REL14\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_REL14)"}
  R_PPC64_REL14)

JOKER CONSTANT R_PPC64_REL14_BRNTAKEN from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_REL14_BRNTAKEN\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_REL14_BRNTAKEN)"}
  R_PPC64_REL14_BRNTAKEN)

JOKER CONSTANT R_PPC64_REL14_BRTAKEN from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_REL14_BRTAKEN\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_REL14_BRTAKEN)"}
  R_PPC64_REL14_BRTAKEN)

JOKER CONSTANT R_PPC64_REL16 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_REL16\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_REL16)"}
  R_PPC64_REL16)

JOKER CONSTANT R_PPC64_REL16DX_HA from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_REL16DX_HA\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_REL16DX_HA)"}
  R_PPC64_REL16DX_HA)

JOKER CONSTANT R_PPC64_REL16_HA from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_REL16_HA\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_REL16_HA)"}
  R_PPC64_REL16_HA)

JOKER CONSTANT R_PPC64_REL16_HI from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_REL16_HI\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_REL16_HI)"}
  R_PPC64_REL16_HI)

JOKER CONSTANT R_PPC64_REL16_LO from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_REL16_LO\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_REL16_LO)"}
  R_PPC64_REL16_LO)

JOKER CONSTANT R_PPC64_REL24 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_REL24\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_REL24)"}
  R_PPC64_REL24)

JOKER CONSTANT R_PPC64_REL24_NOTOC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_REL24_NOTOC)"}
  R_PPC64_REL24_NOTOC)

JOKER CONSTANT R_PPC64_REL32 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_REL32\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_REL32)"}
  R_PPC64_REL32)

JOKER CONSTANT R_PPC64_REL64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_REL64)"}
  R_PPC64_REL64)

JOKER CONSTANT R_PPC64_SECTOFF_DS from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_SECTOFF_DS)"}
  R_PPC64_SECTOFF_DS)

JOKER CONSTANT R_PPC64_SECTOFF_LO_DS from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_SECTOFF_LO_DS)"}
  R_PPC64_SECTOFF_LO_DS)

JOKER CONSTANT R_PPC64_TLS from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_TLS\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TLS)"}
  R_PPC64_TLS)

JOKER CONSTANT R_PPC64_TLSGD from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TLSGD)"}
  R_PPC64_TLSGD)

JOKER CONSTANT R_PPC64_TLSLD from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TLSLD)"}
  R_PPC64_TLSLD)

JOKER CONSTANT R_PPC64_TOC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TOC)"}
  R_PPC64_TOC)

JOKER CONSTANT R_PPC64_TOC16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TOC16)"}
  R_PPC64_TOC16)

JOKER CONSTANT R_PPC64_TOC16_DS from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TOC16_DS)"}
  R_PPC64_TOC16_DS)

JOKER CONSTANT R_PPC64_TOC16_HA from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TOC16_HA)"}
  R_PPC64_TOC16_HA)

JOKER CONSTANT R_PPC64_TOC16_HI from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TOC16_HI)"}
  R_PPC64_TOC16_HI)

JOKER CONSTANT R_PPC64_TOC16_LO from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TOC16_LO)"}
  R_PPC64_TOC16_LO)

JOKER CONSTANT R_PPC64_TOC16_LO_DS from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TOC16_LO_DS)"}
  R_PPC64_TOC16_LO_DS)

JOKER CONSTANT R_PPC64_TOCSAVE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TOCSAVE)"}
  R_PPC64_TOCSAVE)

JOKER CONSTANT R_PPC64_TPREL16 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_TPREL16\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TPREL16)"}
  R_PPC64_TPREL16)

JOKER CONSTANT R_PPC64_TPREL16_DS from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TPREL16_DS)"}
  R_PPC64_TPREL16_DS)

JOKER CONSTANT R_PPC64_TPREL16_HA from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_TPREL16_HA\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TPREL16_HA)"}
  R_PPC64_TPREL16_HA)

JOKER CONSTANT R_PPC64_TPREL16_HI from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_TPREL16_HI\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TPREL16_HI)"}
  R_PPC64_TPREL16_HI)

JOKER CONSTANT R_PPC64_TPREL16_HIGH from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TPREL16_HIGH)"}
  R_PPC64_TPREL16_HIGH)

JOKER CONSTANT R_PPC64_TPREL16_HIGHA from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TPREL16_HIGHA)"}
  R_PPC64_TPREL16_HIGHA)

JOKER CONSTANT R_PPC64_TPREL16_HIGHER from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TPREL16_HIGHER)"}
  R_PPC64_TPREL16_HIGHER)

JOKER CONSTANT R_PPC64_TPREL16_HIGHERA from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TPREL16_HIGHERA)"}
  R_PPC64_TPREL16_HIGHERA)

JOKER CONSTANT R_PPC64_TPREL16_HIGHEST from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TPREL16_HIGHEST)"}
  R_PPC64_TPREL16_HIGHEST)

JOKER CONSTANT R_PPC64_TPREL16_HIGHESTA from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TPREL16_HIGHESTA)"}
  R_PPC64_TPREL16_HIGHESTA)

JOKER CONSTANT R_PPC64_TPREL16_LO from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_TPREL16_LO\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TPREL16_LO)"}
  R_PPC64_TPREL16_LO)

JOKER CONSTANT R_PPC64_TPREL16_LO_DS from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TPREL16_LO_DS)"}
  R_PPC64_TPREL16_LO_DS)

JOKER CONSTANT R_PPC64_TPREL64 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_TPREL64\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC64_TPREL64)"}
  R_PPC64_TPREL64)

JOKER CONSTANT R_PPC_ADDR14 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_ADDR14\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_ADDR14)"}
  R_PPC_ADDR14)

JOKER CONSTANT R_PPC_ADDR14_BRNTAKEN from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_ADDR14_BRNTAKEN\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_ADDR14_BRNTAKEN)"}
  R_PPC_ADDR14_BRNTAKEN)

JOKER CONSTANT R_PPC_ADDR14_BRTAKEN from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_ADDR14_BRTAKEN\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_ADDR14_BRTAKEN)"}
  R_PPC_ADDR14_BRTAKEN)

JOKER CONSTANT R_PPC_ADDR16 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_ADDR16\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_ADDR16)"}
  R_PPC_ADDR16)

JOKER CONSTANT R_PPC_ADDR16_HA from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_ADDR16_HA\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_ADDR16_HA)"}
  R_PPC_ADDR16_HA)

JOKER CONSTANT R_PPC_ADDR16_HI from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_ADDR16_HI\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_ADDR16_HI)"}
  R_PPC_ADDR16_HI)

JOKER CONSTANT R_PPC_ADDR16_LO from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_ADDR16_LO\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_ADDR16_LO)"}
  R_PPC_ADDR16_LO)

JOKER CONSTANT R_PPC_ADDR24 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_ADDR24\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_ADDR24)"}
  R_PPC_ADDR24)

JOKER CONSTANT R_PPC_ADDR32 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_ADDR32\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_ADDR32)"}
  R_PPC_ADDR32)

JOKER CONSTANT R_PPC_COPY from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_COPY\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_COPY)"}
  R_PPC_COPY)

JOKER CONSTANT R_PPC_DTPMOD32 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_DTPMOD32\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_DTPMOD32)"}
  R_PPC_DTPMOD32)

JOKER CONSTANT R_PPC_DTPREL16 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_DTPREL16\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_DTPREL16)"}
  R_PPC_DTPREL16)

JOKER CONSTANT R_PPC_DTPREL16_HA from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_DTPREL16_HA\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_DTPREL16_HA)"}
  R_PPC_DTPREL16_HA)

JOKER CONSTANT R_PPC_DTPREL16_HI from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_DTPREL16_HI\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_DTPREL16_HI)"}
  R_PPC_DTPREL16_HI)

JOKER CONSTANT R_PPC_DTPREL16_LO from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_DTPREL16_LO\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_DTPREL16_LO)"}
  R_PPC_DTPREL16_LO)

JOKER CONSTANT R_PPC_DTPREL32 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_DTPREL32\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_DTPREL32)"}
  R_PPC_DTPREL32)

JOKER CONSTANT R_PPC_EMB_BIT_FLD from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_EMB_BIT_FLD)"}
  R_PPC_EMB_BIT_FLD)

JOKER CONSTANT R_PPC_EMB_MRKREF from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_EMB_MRKREF)"}
  R_PPC_EMB_MRKREF)

JOKER CONSTANT R_PPC_EMB_NADDR16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_EMB_NADDR16)"}
  R_PPC_EMB_NADDR16)

JOKER CONSTANT R_PPC_EMB_NADDR16_HA from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_EMB_NADDR16_HA)"}
  R_PPC_EMB_NADDR16_HA)

JOKER CONSTANT R_PPC_EMB_NADDR16_HI from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_EMB_NADDR16_HI)"}
  R_PPC_EMB_NADDR16_HI)

JOKER CONSTANT R_PPC_EMB_NADDR16_LO from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_EMB_NADDR16_LO)"}
  R_PPC_EMB_NADDR16_LO)

JOKER CONSTANT R_PPC_EMB_NADDR32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_EMB_NADDR32)"}
  R_PPC_EMB_NADDR32)

JOKER CONSTANT R_PPC_EMB_RELSDA from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_EMB_RELSDA)"}
  R_PPC_EMB_RELSDA)

JOKER CONSTANT R_PPC_EMB_RELSEC16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_EMB_RELSEC16)"}
  R_PPC_EMB_RELSEC16)

JOKER CONSTANT R_PPC_EMB_RELST_HA from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_EMB_RELST_HA)"}
  R_PPC_EMB_RELST_HA)

JOKER CONSTANT R_PPC_EMB_RELST_HI from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_EMB_RELST_HI)"}
  R_PPC_EMB_RELST_HI)

JOKER CONSTANT R_PPC_EMB_RELST_LO from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_EMB_RELST_LO)"}
  R_PPC_EMB_RELST_LO)

JOKER CONSTANT R_PPC_EMB_SDA21 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_EMB_SDA21)"}
  R_PPC_EMB_SDA21)

JOKER CONSTANT R_PPC_EMB_SDA2I16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_EMB_SDA2I16)"}
  R_PPC_EMB_SDA2I16)

JOKER CONSTANT R_PPC_EMB_SDA2REL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_EMB_SDA2REL)"}
  R_PPC_EMB_SDA2REL)

JOKER CONSTANT R_PPC_EMB_SDAI16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_EMB_SDAI16)"}
  R_PPC_EMB_SDAI16)

JOKER CONSTANT R_PPC_GLOB_DAT from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GLOB_DAT\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_GLOB_DAT)"}
  R_PPC_GLOB_DAT)

JOKER CONSTANT R_PPC_GOT16 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT16\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_GOT16)"}
  R_PPC_GOT16)

JOKER CONSTANT R_PPC_GOT16_HA from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT16_HA\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_GOT16_HA)"}
  R_PPC_GOT16_HA)

JOKER CONSTANT R_PPC_GOT16_HI from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT16_HI\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_GOT16_HI)"}
  R_PPC_GOT16_HI)

JOKER CONSTANT R_PPC_GOT16_LO from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT16_LO\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_GOT16_LO)"}
  R_PPC_GOT16_LO)

JOKER CONSTANT R_PPC_GOT_TLSGD16 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TLSGD16\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_GOT_TLSGD16)"}
  R_PPC_GOT_TLSGD16)

JOKER CONSTANT R_PPC_GOT_TLSGD16_HA from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TLSGD16_HA\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_GOT_TLSGD16_HA)"}
  R_PPC_GOT_TLSGD16_HA)

JOKER CONSTANT R_PPC_GOT_TLSGD16_HI from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TLSGD16_HI\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_GOT_TLSGD16_HI)"}
  R_PPC_GOT_TLSGD16_HI)

JOKER CONSTANT R_PPC_GOT_TLSGD16_LO from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TLSGD16_LO\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_GOT_TLSGD16_LO)"}
  R_PPC_GOT_TLSGD16_LO)

JOKER CONSTANT R_PPC_GOT_TLSLD16 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TLSLD16\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_GOT_TLSLD16)"}
  R_PPC_GOT_TLSLD16)

JOKER CONSTANT R_PPC_GOT_TLSLD16_HA from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TLSLD16_HA\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_GOT_TLSLD16_HA)"}
  R_PPC_GOT_TLSLD16_HA)

JOKER CONSTANT R_PPC_GOT_TLSLD16_HI from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TLSLD16_HI\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_GOT_TLSLD16_HI)"}
  R_PPC_GOT_TLSLD16_HI)

JOKER CONSTANT R_PPC_GOT_TLSLD16_LO from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TLSLD16_LO\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_GOT_TLSLD16_LO)"}
  R_PPC_GOT_TLSLD16_LO)

JOKER CONSTANT R_PPC_GOT_TPREL16 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TPREL16\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_GOT_TPREL16)"}
  R_PPC_GOT_TPREL16)

JOKER CONSTANT R_PPC_GOT_TPREL16_HA from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TPREL16_HA\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_GOT_TPREL16_HA)"}
  R_PPC_GOT_TPREL16_HA)

JOKER CONSTANT R_PPC_GOT_TPREL16_HI from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TPREL16_HI\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_GOT_TPREL16_HI)"}
  R_PPC_GOT_TPREL16_HI)

JOKER CONSTANT R_PPC_GOT_TPREL16_LO from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_GOT_TPREL16_LO\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_GOT_TPREL16_LO)"}
  R_PPC_GOT_TPREL16_LO)

JOKER CONSTANT R_PPC_JMP_SLOT from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_JMP_SLOT\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_JMP_SLOT)"}
  R_PPC_JMP_SLOT)

JOKER CONSTANT R_PPC_LOCAL24PC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_LOCAL24PC)"}
  R_PPC_LOCAL24PC)

JOKER CONSTANT R_PPC_NONE from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_NONE\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_NONE)"}
  R_PPC_NONE)

JOKER CONSTANT R_PPC_PLT16_HA from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_PLT16_HA\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_PLT16_HA)"}
  R_PPC_PLT16_HA)

JOKER CONSTANT R_PPC_PLT16_HI from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_PLT16_HI\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_PLT16_HI)"}
  R_PPC_PLT16_HI)

JOKER CONSTANT R_PPC_PLT16_LO from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_PLT16_LO\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_PLT16_LO)"}
  R_PPC_PLT16_LO)

JOKER CONSTANT R_PPC_PLT32 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_PLT32\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_PLT32)"}
  R_PPC_PLT32)

JOKER CONSTANT R_PPC_PLTREL24 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_PLTREL24)"}
  R_PPC_PLTREL24)

JOKER CONSTANT R_PPC_PLTREL32 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_PLTREL32\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_PLTREL32)"}
  R_PPC_PLTREL32)

JOKER CONSTANT R_PPC_REL14 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_REL14\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_REL14)"}
  R_PPC_REL14)

JOKER CONSTANT R_PPC_REL14_BRNTAKEN from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_REL14_BRNTAKEN\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_REL14_BRNTAKEN)"}
  R_PPC_REL14_BRNTAKEN)

JOKER CONSTANT R_PPC_REL14_BRTAKEN from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_REL14_BRTAKEN\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_REL14_BRTAKEN)"}
  R_PPC_REL14_BRTAKEN)

JOKER CONSTANT R_PPC_REL24 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_REL24\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_REL24)"}
  R_PPC_REL24)

JOKER CONSTANT R_PPC_REL32 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_REL32\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_REL32)"}
  R_PPC_REL32)

JOKER CONSTANT R_PPC_RELATIVE from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_RELATIVE\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_RELATIVE)"}
  R_PPC_RELATIVE)

JOKER CONSTANT R_PPC_SDAREL16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_SDAREL16)"}
  R_PPC_SDAREL16)

JOKER CONSTANT R_PPC_SECTOFF from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_SECTOFF\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_SECTOFF)"}
  R_PPC_SECTOFF)

JOKER CONSTANT R_PPC_SECTOFF_HA from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_SECTOFF_HA\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_SECTOFF_HA)"}
  R_PPC_SECTOFF_HA)

JOKER CONSTANT R_PPC_SECTOFF_HI from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_SECTOFF_HI\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_SECTOFF_HI)"}
  R_PPC_SECTOFF_HI)

JOKER CONSTANT R_PPC_SECTOFF_LO from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_SECTOFF_LO\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_SECTOFF_LO)"}
  R_PPC_SECTOFF_LO)

JOKER CONSTANT R_PPC_TLS from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_TLS\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_TLS)"}
  R_PPC_TLS)

JOKER CONSTANT R_PPC_TPREL16 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_TPREL16\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_TPREL16)"}
  R_PPC_TPREL16)

JOKER CONSTANT R_PPC_TPREL16_HA from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_TPREL16_HA\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_TPREL16_HA)"}
  R_PPC_TPREL16_HA)

JOKER CONSTANT R_PPC_TPREL16_HI from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_TPREL16_HI\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_TPREL16_HI)"}
  R_PPC_TPREL16_HI)

JOKER CONSTANT R_PPC_TPREL16_LO from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_TPREL16_LO\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_TPREL16_LO)"}
  R_PPC_TPREL16_LO)

JOKER CONSTANT R_PPC_TPREL32 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_TPREL32\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_TPREL32)"}
  R_PPC_TPREL32)

JOKER CONSTANT R_PPC_UADDR16 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_UADDR16\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_UADDR16)"}
  R_PPC_UADDR16)

JOKER CONSTANT R_PPC_UADDR32 from debug/elf/elf.go:
(def
  ^{:doc "R_POWERPC_UADDR32\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_PPC_UADDR32)"}
  R_PPC_UADDR32)

JOKER CONSTANT R_RISCV_32 from debug/elf/elf.go:
(def
  ^{:doc " Add 32 bit zero extended symbol value\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_32)"}
  R_RISCV_32)

JOKER CONSTANT R_RISCV_32_PCREL from debug/elf/elf.go:
(def
  ^{:doc " 32-bit PC relative\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_32_PCREL)"}
  R_RISCV_32_PCREL)

JOKER CONSTANT R_RISCV_64 from debug/elf/elf.go:
(def
  ^{:doc " Add 64 bit symbol value.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_64)"}
  R_RISCV_64)

JOKER CONSTANT R_RISCV_ADD16 from debug/elf/elf.go:
(def
  ^{:doc " 16-bit label addition\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_ADD16)"}
  R_RISCV_ADD16)

JOKER CONSTANT R_RISCV_ADD32 from debug/elf/elf.go:
(def
  ^{:doc " 32-bit label addition\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_ADD32)"}
  R_RISCV_ADD32)

JOKER CONSTANT R_RISCV_ADD64 from debug/elf/elf.go:
(def
  ^{:doc " 64-bit label addition\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_ADD64)"}
  R_RISCV_ADD64)

JOKER CONSTANT R_RISCV_ADD8 from debug/elf/elf.go:
(def
  ^{:doc " 8-bit label addition\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_ADD8)"}
  R_RISCV_ADD8)

JOKER CONSTANT R_RISCV_ALIGN from debug/elf/elf.go:
(def
  ^{:doc " Alignment statement\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_ALIGN)"}
  R_RISCV_ALIGN)

JOKER CONSTANT R_RISCV_BRANCH from debug/elf/elf.go:
(def
  ^{:doc " PC-relative branch\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_BRANCH)"}
  R_RISCV_BRANCH)

JOKER CONSTANT R_RISCV_CALL from debug/elf/elf.go:
(def
  ^{:doc " PC-relative call\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_CALL)"}
  R_RISCV_CALL)

JOKER CONSTANT R_RISCV_CALL_PLT from debug/elf/elf.go:
(def
  ^{:doc " PC-relative call (PLT)\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_CALL_PLT)"}
  R_RISCV_CALL_PLT)

JOKER CONSTANT R_RISCV_COPY from debug/elf/elf.go:
(def
  ^{:doc " Copy data from shared object.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_COPY)"}
  R_RISCV_COPY)

JOKER CONSTANT R_RISCV_GNU_VTENTRY from debug/elf/elf.go:
(def
  ^{:doc " GNU C++ vtable member usage\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_GNU_VTENTRY)"}
  R_RISCV_GNU_VTENTRY)

JOKER CONSTANT R_RISCV_GNU_VTINHERIT from debug/elf/elf.go:
(def
  ^{:doc " GNU C++ vtable hierarchy\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_GNU_VTINHERIT)"}
  R_RISCV_GNU_VTINHERIT)

JOKER CONSTANT R_RISCV_GOT_HI20 from debug/elf/elf.go:
(def
  ^{:doc " PC-relative GOT reference\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_GOT_HI20)"}
  R_RISCV_GOT_HI20)

JOKER CONSTANT R_RISCV_GPREL_I from debug/elf/elf.go:
(def
  ^{:doc " GP-relative reference\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_GPREL_I)"}
  R_RISCV_GPREL_I)

JOKER CONSTANT R_RISCV_GPREL_S from debug/elf/elf.go:
(def
  ^{:doc " GP-relative reference\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_GPREL_S)"}
  R_RISCV_GPREL_S)

JOKER CONSTANT R_RISCV_HI20 from debug/elf/elf.go:
(def
  ^{:doc " Absolute address\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_HI20)"}
  R_RISCV_HI20)

JOKER CONSTANT R_RISCV_JAL from debug/elf/elf.go:
(def
  ^{:doc " PC-relative jump\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_JAL)"}
  R_RISCV_JAL)

JOKER CONSTANT R_RISCV_JUMP_SLOT from debug/elf/elf.go:
(def
  ^{:doc " Set GOT entry to code address.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_JUMP_SLOT)"}
  R_RISCV_JUMP_SLOT)

JOKER CONSTANT R_RISCV_LO12_I from debug/elf/elf.go:
(def
  ^{:doc " Absolute address\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_LO12_I)"}
  R_RISCV_LO12_I)

JOKER CONSTANT R_RISCV_LO12_S from debug/elf/elf.go:
(def
  ^{:doc " Absolute address\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_LO12_S)"}
  R_RISCV_LO12_S)

JOKER CONSTANT R_RISCV_NONE from debug/elf/elf.go:
(def
  ^{:doc " No relocation.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_NONE)"}
  R_RISCV_NONE)

JOKER CONSTANT R_RISCV_PCREL_HI20 from debug/elf/elf.go:
(def
  ^{:doc " PC-relative reference\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_PCREL_HI20)"}
  R_RISCV_PCREL_HI20)

JOKER CONSTANT R_RISCV_PCREL_LO12_I from debug/elf/elf.go:
(def
  ^{:doc " PC-relative reference\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_PCREL_LO12_I)"}
  R_RISCV_PCREL_LO12_I)

JOKER CONSTANT R_RISCV_PCREL_LO12_S from debug/elf/elf.go:
(def
  ^{:doc " PC-relative reference\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_PCREL_LO12_S)"}
  R_RISCV_PCREL_LO12_S)

JOKER CONSTANT R_RISCV_RELATIVE from debug/elf/elf.go:
(def
  ^{:doc " Add load address of shared object.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_RELATIVE)"}
  R_RISCV_RELATIVE)

JOKER CONSTANT R_RISCV_RELAX from debug/elf/elf.go:
(def
  ^{:doc " Instruction pair can be relaxed\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_RELAX)"}
  R_RISCV_RELAX)

JOKER CONSTANT R_RISCV_RVC_BRANCH from debug/elf/elf.go:
(def
  ^{:doc " PC-relative branch offset\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_RVC_BRANCH)"}
  R_RISCV_RVC_BRANCH)

JOKER CONSTANT R_RISCV_RVC_JUMP from debug/elf/elf.go:
(def
  ^{:doc " PC-relative jump offset\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_RVC_JUMP)"}
  R_RISCV_RVC_JUMP)

JOKER CONSTANT R_RISCV_RVC_LUI from debug/elf/elf.go:
(def
  ^{:doc " Absolute address\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_RVC_LUI)"}
  R_RISCV_RVC_LUI)

JOKER CONSTANT R_RISCV_SET16 from debug/elf/elf.go:
(def
  ^{:doc " Local label subtraction\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_SET16)"}
  R_RISCV_SET16)

JOKER CONSTANT R_RISCV_SET32 from debug/elf/elf.go:
(def
  ^{:doc " Local label subtraction\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_SET32)"}
  R_RISCV_SET32)

JOKER CONSTANT R_RISCV_SET6 from debug/elf/elf.go:
(def
  ^{:doc " Local label subtraction\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_SET6)"}
  R_RISCV_SET6)

JOKER CONSTANT R_RISCV_SET8 from debug/elf/elf.go:
(def
  ^{:doc " Local label subtraction\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_SET8)"}
  R_RISCV_SET8)

JOKER CONSTANT R_RISCV_SUB16 from debug/elf/elf.go:
(def
  ^{:doc " 16-bit label subtraction\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_SUB16)"}
  R_RISCV_SUB16)

JOKER CONSTANT R_RISCV_SUB32 from debug/elf/elf.go:
(def
  ^{:doc " 32-bit label subtraction\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_SUB32)"}
  R_RISCV_SUB32)

JOKER CONSTANT R_RISCV_SUB6 from debug/elf/elf.go:
(def
  ^{:doc " Local label subtraction\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_SUB6)"}
  R_RISCV_SUB6)

JOKER CONSTANT R_RISCV_SUB64 from debug/elf/elf.go:
(def
  ^{:doc " 64-bit label subtraction\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_SUB64)"}
  R_RISCV_SUB64)

JOKER CONSTANT R_RISCV_SUB8 from debug/elf/elf.go:
(def
  ^{:doc " 8-bit label subtraction\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_SUB8)"}
  R_RISCV_SUB8)

JOKER CONSTANT R_RISCV_TLS_DTPMOD32 from debug/elf/elf.go:
(def
  ^{:doc " 32 bit ID of module containing symbol\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_TLS_DTPMOD32)"}
  R_RISCV_TLS_DTPMOD32)

JOKER CONSTANT R_RISCV_TLS_DTPMOD64 from debug/elf/elf.go:
(def
  ^{:doc " ID of module containing symbol\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_TLS_DTPMOD64)"}
  R_RISCV_TLS_DTPMOD64)

JOKER CONSTANT R_RISCV_TLS_DTPREL32 from debug/elf/elf.go:
(def
  ^{:doc " 32 bit relative offset in TLS block\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_TLS_DTPREL32)"}
  R_RISCV_TLS_DTPREL32)

JOKER CONSTANT R_RISCV_TLS_DTPREL64 from debug/elf/elf.go:
(def
  ^{:doc " Relative offset in TLS block\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_TLS_DTPREL64)"}
  R_RISCV_TLS_DTPREL64)

JOKER CONSTANT R_RISCV_TLS_GD_HI20 from debug/elf/elf.go:
(def
  ^{:doc " PC-relative TLS GD reference\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_TLS_GD_HI20)"}
  R_RISCV_TLS_GD_HI20)

JOKER CONSTANT R_RISCV_TLS_GOT_HI20 from debug/elf/elf.go:
(def
  ^{:doc " PC-relative TLS IE GOT offset\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_TLS_GOT_HI20)"}
  R_RISCV_TLS_GOT_HI20)

JOKER CONSTANT R_RISCV_TLS_TPREL32 from debug/elf/elf.go:
(def
  ^{:doc " 32 bit relative offset in static TLS block\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_TLS_TPREL32)"}
  R_RISCV_TLS_TPREL32)

JOKER CONSTANT R_RISCV_TLS_TPREL64 from debug/elf/elf.go:
(def
  ^{:doc " Relative offset in static TLS block\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_TLS_TPREL64)"}
  R_RISCV_TLS_TPREL64)

JOKER CONSTANT R_RISCV_TPREL_ADD from debug/elf/elf.go:
(def
  ^{:doc " TLS LE thread usage\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_TPREL_ADD)"}
  R_RISCV_TPREL_ADD)

JOKER CONSTANT R_RISCV_TPREL_HI20 from debug/elf/elf.go:
(def
  ^{:doc " TLS LE thread offset\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_TPREL_HI20)"}
  R_RISCV_TPREL_HI20)

JOKER CONSTANT R_RISCV_TPREL_I from debug/elf/elf.go:
(def
  ^{:doc " TP-relative TLS LE load\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_TPREL_I)"}
  R_RISCV_TPREL_I)

JOKER CONSTANT R_RISCV_TPREL_LO12_I from debug/elf/elf.go:
(def
  ^{:doc " TLS LE thread offset\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_TPREL_LO12_I)"}
  R_RISCV_TPREL_LO12_I)

JOKER CONSTANT R_RISCV_TPREL_LO12_S from debug/elf/elf.go:
(def
  ^{:doc " TLS LE thread offset\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_TPREL_LO12_S)"}
  R_RISCV_TPREL_LO12_S)

JOKER CONSTANT R_RISCV_TPREL_S from debug/elf/elf.go:
(def
  ^{:doc " TP-relative TLS LE store\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_RISCV_TPREL_S)"}
  R_RISCV_TPREL_S)

JOKER CONSTANT R_SPARC_10 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_10)"}
  R_SPARC_10)

JOKER CONSTANT R_SPARC_11 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_11)"}
  R_SPARC_11)

JOKER CONSTANT R_SPARC_13 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_13)"}
  R_SPARC_13)

JOKER CONSTANT R_SPARC_16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_16)"}
  R_SPARC_16)

JOKER CONSTANT R_SPARC_22 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_22)"}
  R_SPARC_22)

JOKER CONSTANT R_SPARC_32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_32)"}
  R_SPARC_32)

JOKER CONSTANT R_SPARC_5 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_5)"}
  R_SPARC_5)

JOKER CONSTANT R_SPARC_6 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_6)"}
  R_SPARC_6)

JOKER CONSTANT R_SPARC_64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_64)"}
  R_SPARC_64)

JOKER CONSTANT R_SPARC_7 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_7)"}
  R_SPARC_7)

JOKER CONSTANT R_SPARC_8 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_8)"}
  R_SPARC_8)

JOKER CONSTANT R_SPARC_COPY from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_COPY)"}
  R_SPARC_COPY)

JOKER CONSTANT R_SPARC_DISP16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_DISP16)"}
  R_SPARC_DISP16)

JOKER CONSTANT R_SPARC_DISP32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_DISP32)"}
  R_SPARC_DISP32)

JOKER CONSTANT R_SPARC_DISP64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_DISP64)"}
  R_SPARC_DISP64)

JOKER CONSTANT R_SPARC_DISP8 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_DISP8)"}
  R_SPARC_DISP8)

JOKER CONSTANT R_SPARC_GLOB_DAT from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_GLOB_DAT)"}
  R_SPARC_GLOB_DAT)

JOKER CONSTANT R_SPARC_GLOB_JMP from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_GLOB_JMP)"}
  R_SPARC_GLOB_JMP)

JOKER CONSTANT R_SPARC_GOT10 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_GOT10)"}
  R_SPARC_GOT10)

JOKER CONSTANT R_SPARC_GOT13 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_GOT13)"}
  R_SPARC_GOT13)

JOKER CONSTANT R_SPARC_GOT22 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_GOT22)"}
  R_SPARC_GOT22)

JOKER CONSTANT R_SPARC_H44 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_H44)"}
  R_SPARC_H44)

JOKER CONSTANT R_SPARC_HH22 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_HH22)"}
  R_SPARC_HH22)

JOKER CONSTANT R_SPARC_HI22 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_HI22)"}
  R_SPARC_HI22)

JOKER CONSTANT R_SPARC_HIPLT22 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_HIPLT22)"}
  R_SPARC_HIPLT22)

JOKER CONSTANT R_SPARC_HIX22 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_HIX22)"}
  R_SPARC_HIX22)

JOKER CONSTANT R_SPARC_HM10 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_HM10)"}
  R_SPARC_HM10)

JOKER CONSTANT R_SPARC_JMP_SLOT from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_JMP_SLOT)"}
  R_SPARC_JMP_SLOT)

JOKER CONSTANT R_SPARC_L44 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_L44)"}
  R_SPARC_L44)

JOKER CONSTANT R_SPARC_LM22 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_LM22)"}
  R_SPARC_LM22)

JOKER CONSTANT R_SPARC_LO10 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_LO10)"}
  R_SPARC_LO10)

JOKER CONSTANT R_SPARC_LOPLT10 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_LOPLT10)"}
  R_SPARC_LOPLT10)

JOKER CONSTANT R_SPARC_LOX10 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_LOX10)"}
  R_SPARC_LOX10)

JOKER CONSTANT R_SPARC_M44 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_M44)"}
  R_SPARC_M44)

JOKER CONSTANT R_SPARC_NONE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_NONE)"}
  R_SPARC_NONE)

JOKER CONSTANT R_SPARC_OLO10 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_OLO10)"}
  R_SPARC_OLO10)

JOKER CONSTANT R_SPARC_PC10 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_PC10)"}
  R_SPARC_PC10)

JOKER CONSTANT R_SPARC_PC22 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_PC22)"}
  R_SPARC_PC22)

JOKER CONSTANT R_SPARC_PCPLT10 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_PCPLT10)"}
  R_SPARC_PCPLT10)

JOKER CONSTANT R_SPARC_PCPLT22 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_PCPLT22)"}
  R_SPARC_PCPLT22)

JOKER CONSTANT R_SPARC_PCPLT32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_PCPLT32)"}
  R_SPARC_PCPLT32)

JOKER CONSTANT R_SPARC_PC_HH22 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_PC_HH22)"}
  R_SPARC_PC_HH22)

JOKER CONSTANT R_SPARC_PC_HM10 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_PC_HM10)"}
  R_SPARC_PC_HM10)

JOKER CONSTANT R_SPARC_PC_LM22 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_PC_LM22)"}
  R_SPARC_PC_LM22)

JOKER CONSTANT R_SPARC_PLT32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_PLT32)"}
  R_SPARC_PLT32)

JOKER CONSTANT R_SPARC_PLT64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_PLT64)"}
  R_SPARC_PLT64)

JOKER CONSTANT R_SPARC_REGISTER from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_REGISTER)"}
  R_SPARC_REGISTER)

JOKER CONSTANT R_SPARC_RELATIVE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_RELATIVE)"}
  R_SPARC_RELATIVE)

JOKER CONSTANT R_SPARC_UA16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_UA16)"}
  R_SPARC_UA16)

JOKER CONSTANT R_SPARC_UA32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_UA32)"}
  R_SPARC_UA32)

JOKER CONSTANT R_SPARC_UA64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_UA64)"}
  R_SPARC_UA64)

JOKER CONSTANT R_SPARC_WDISP16 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_WDISP16)"}
  R_SPARC_WDISP16)

JOKER CONSTANT R_SPARC_WDISP19 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_WDISP19)"}
  R_SPARC_WDISP19)

JOKER CONSTANT R_SPARC_WDISP22 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_WDISP22)"}
  R_SPARC_WDISP22)

JOKER CONSTANT R_SPARC_WDISP30 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_WDISP30)"}
  R_SPARC_WDISP30)

JOKER CONSTANT R_SPARC_WPLT30 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_SPARC_WPLT30)"}
  R_SPARC_WPLT30)

JOKER CONSTANT R_X86_64_16 from debug/elf/elf.go:
(def
  ^{:doc " Add 16 bit zero extended symbol value\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_16)"}
  R_X86_64_16)

JOKER CONSTANT R_X86_64_32 from debug/elf/elf.go:
(def
  ^{:doc " Add 32 bit zero extended symbol value\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_32)"}
  R_X86_64_32)

JOKER CONSTANT R_X86_64_32S from debug/elf/elf.go:
(def
  ^{:doc " Add 32 bit sign extended symbol value\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_32S)"}
  R_X86_64_32S)

JOKER CONSTANT R_X86_64_64 from debug/elf/elf.go:
(def
  ^{:doc " Add 64 bit symbol value.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_64)"}
  R_X86_64_64)

JOKER CONSTANT R_X86_64_8 from debug/elf/elf.go:
(def
  ^{:doc " Add 8 bit zero extended symbol value\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_8)"}
  R_X86_64_8)

JOKER CONSTANT R_X86_64_COPY from debug/elf/elf.go:
(def
  ^{:doc " Copy data from shared object.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_COPY)"}
  R_X86_64_COPY)

JOKER CONSTANT R_X86_64_DTPMOD64 from debug/elf/elf.go:
(def
  ^{:doc " ID of module containing symbol\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_DTPMOD64)"}
  R_X86_64_DTPMOD64)

JOKER CONSTANT R_X86_64_DTPOFF32 from debug/elf/elf.go:
(def
  ^{:doc " Offset in TLS block\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_DTPOFF32)"}
  R_X86_64_DTPOFF32)

JOKER CONSTANT R_X86_64_DTPOFF64 from debug/elf/elf.go:
(def
  ^{:doc " Offset in TLS block\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_DTPOFF64)"}
  R_X86_64_DTPOFF64)

JOKER CONSTANT R_X86_64_GLOB_DAT from debug/elf/elf.go:
(def
  ^{:doc " Set GOT entry to data address.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_GLOB_DAT)"}
  R_X86_64_GLOB_DAT)

JOKER CONSTANT R_X86_64_GOT32 from debug/elf/elf.go:
(def
  ^{:doc " PC-relative 32 bit GOT offset.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_GOT32)"}
  R_X86_64_GOT32)

JOKER CONSTANT R_X86_64_GOT64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_GOT64)"}
  R_X86_64_GOT64)

JOKER CONSTANT R_X86_64_GOTOFF64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_GOTOFF64)"}
  R_X86_64_GOTOFF64)

JOKER CONSTANT R_X86_64_GOTPC32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_GOTPC32)"}
  R_X86_64_GOTPC32)

JOKER CONSTANT R_X86_64_GOTPC32_TLSDESC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_GOTPC32_TLSDESC)"}
  R_X86_64_GOTPC32_TLSDESC)

JOKER CONSTANT R_X86_64_GOTPC64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_GOTPC64)"}
  R_X86_64_GOTPC64)

JOKER CONSTANT R_X86_64_GOTPCREL from debug/elf/elf.go:
(def
  ^{:doc " Add 32 bit signed pcrel offset to GOT.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_GOTPCREL)"}
  R_X86_64_GOTPCREL)

JOKER CONSTANT R_X86_64_GOTPCREL64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_GOTPCREL64)"}
  R_X86_64_GOTPCREL64)

JOKER CONSTANT R_X86_64_GOTPCRELX from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_GOTPCRELX)"}
  R_X86_64_GOTPCRELX)

JOKER CONSTANT R_X86_64_GOTPLT64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_GOTPLT64)"}
  R_X86_64_GOTPLT64)

JOKER CONSTANT R_X86_64_GOTTPOFF from debug/elf/elf.go:
(def
  ^{:doc " PC relative offset to IE GOT entry\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_GOTTPOFF)"}
  R_X86_64_GOTTPOFF)

JOKER CONSTANT R_X86_64_IRELATIVE from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_IRELATIVE)"}
  R_X86_64_IRELATIVE)

JOKER CONSTANT R_X86_64_JMP_SLOT from debug/elf/elf.go:
(def
  ^{:doc " Set GOT entry to code address.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_JMP_SLOT)"}
  R_X86_64_JMP_SLOT)

JOKER CONSTANT R_X86_64_NONE from debug/elf/elf.go:
(def
  ^{:doc " No relocation.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_NONE)"}
  R_X86_64_NONE)

JOKER CONSTANT R_X86_64_PC16 from debug/elf/elf.go:
(def
  ^{:doc " Add 16 bit signed extended pc relative symbol value\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_PC16)"}
  R_X86_64_PC16)

JOKER CONSTANT R_X86_64_PC32 from debug/elf/elf.go:
(def
  ^{:doc " PC-relative 32 bit signed sym value.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_PC32)"}
  R_X86_64_PC32)

JOKER CONSTANT R_X86_64_PC32_BND from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_PC32_BND)"}
  R_X86_64_PC32_BND)

JOKER CONSTANT R_X86_64_PC64 from debug/elf/elf.go:
(def
  ^{:doc " PC relative 64-bit sign extended symbol value.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_PC64)"}
  R_X86_64_PC64)

JOKER CONSTANT R_X86_64_PC8 from debug/elf/elf.go:
(def
  ^{:doc " Add 8 bit signed extended pc relative symbol value\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_PC8)"}
  R_X86_64_PC8)

JOKER CONSTANT R_X86_64_PLT32 from debug/elf/elf.go:
(def
  ^{:doc " PC-relative 32 bit PLT offset.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_PLT32)"}
  R_X86_64_PLT32)

JOKER CONSTANT R_X86_64_PLT32_BND from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_PLT32_BND)"}
  R_X86_64_PLT32_BND)

JOKER CONSTANT R_X86_64_PLTOFF64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_PLTOFF64)"}
  R_X86_64_PLTOFF64)

JOKER CONSTANT R_X86_64_RELATIVE from debug/elf/elf.go:
(def
  ^{:doc " Add load address of shared object.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_RELATIVE)"}
  R_X86_64_RELATIVE)

JOKER CONSTANT R_X86_64_RELATIVE64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_RELATIVE64)"}
  R_X86_64_RELATIVE64)

JOKER CONSTANT R_X86_64_REX_GOTPCRELX from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_REX_GOTPCRELX)"}
  R_X86_64_REX_GOTPCRELX)

JOKER CONSTANT R_X86_64_SIZE32 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_SIZE32)"}
  R_X86_64_SIZE32)

JOKER CONSTANT R_X86_64_SIZE64 from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_SIZE64)"}
  R_X86_64_SIZE64)

JOKER CONSTANT R_X86_64_TLSDESC from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_TLSDESC)"}
  R_X86_64_TLSDESC)

JOKER CONSTANT R_X86_64_TLSDESC_CALL from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_TLSDESC_CALL)"}
  R_X86_64_TLSDESC_CALL)

JOKER CONSTANT R_X86_64_TLSGD from debug/elf/elf.go:
(def
  ^{:doc " PC relative offset to GD GOT entry\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_TLSGD)"}
  R_X86_64_TLSGD)

JOKER CONSTANT R_X86_64_TLSLD from debug/elf/elf.go:
(def
  ^{:doc " PC relative offset to LD GOT entry\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_TLSLD)"}
  R_X86_64_TLSLD)

JOKER CONSTANT R_X86_64_TPOFF32 from debug/elf/elf.go:
(def
  ^{:doc " Offset in static TLS block\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_TPOFF32)"}
  R_X86_64_TPOFF32)

JOKER CONSTANT R_X86_64_TPOFF64 from debug/elf/elf.go:
(def
  ^{:doc " Offset in static TLS block\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.R_X86_64_TPOFF64)"}
  R_X86_64_TPOFF64)

JOKER CONSTANT SHF_ALLOC from debug/elf/elf.go:
(def
  ^{:doc " Section occupies memory.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHF_ALLOC))"}
  SHF_ALLOC)

JOKER CONSTANT SHF_COMPRESSED from debug/elf/elf.go:
(def
  ^{:doc " Section is compressed.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHF_COMPRESSED))"}
  SHF_COMPRESSED)

JOKER CONSTANT SHF_EXECINSTR from debug/elf/elf.go:
(def
  ^{:doc " Section contains instructions.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHF_EXECINSTR))"}
  SHF_EXECINSTR)

JOKER CONSTANT SHF_GROUP from debug/elf/elf.go:
(def
  ^{:doc " Member of section group.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHF_GROUP))"}
  SHF_GROUP)

JOKER CONSTANT SHF_INFO_LINK from debug/elf/elf.go:
(def
  ^{:doc " sh_info holds section index.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHF_INFO_LINK))"}
  SHF_INFO_LINK)

JOKER CONSTANT SHF_LINK_ORDER from debug/elf/elf.go:
(def
  ^{:doc " Special ordering requirements.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHF_LINK_ORDER))"}
  SHF_LINK_ORDER)

JOKER CONSTANT SHF_MASKOS from debug/elf/elf.go:
(def
  ^{:doc " OS-specific semantics.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHF_MASKOS))"}
  SHF_MASKOS)

JOKER CONSTANT SHF_MASKPROC from debug/elf/elf.go:
(def
  ^{:doc " Processor-specific semantics.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHF_MASKPROC))"}
  SHF_MASKPROC)

JOKER CONSTANT SHF_MERGE from debug/elf/elf.go:
(def
  ^{:doc " Section may be merged.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHF_MERGE))"}
  SHF_MERGE)

JOKER CONSTANT SHF_OS_NONCONFORMING from debug/elf/elf.go:
(def
  ^{:doc " OS-specific processing required.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHF_OS_NONCONFORMING))"}
  SHF_OS_NONCONFORMING)

JOKER CONSTANT SHF_STRINGS from debug/elf/elf.go:
(def
  ^{:doc " Section contains strings.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHF_STRINGS))"}
  SHF_STRINGS)

JOKER CONSTANT SHF_TLS from debug/elf/elf.go:
(def
  ^{:doc " Section contains TLS data.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHF_TLS))"}
  SHF_TLS)

JOKER CONSTANT SHF_WRITE from debug/elf/elf.go:
(def
  ^{:doc " Section contains writable data.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHF_WRITE))"}
  SHF_WRITE)

JOKER CONSTANT SHN_ABS from debug/elf/elf.go:
(def
  ^{:doc " Absolute values.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.SHN_ABS)"}
  SHN_ABS)

JOKER CONSTANT SHN_COMMON from debug/elf/elf.go:
(def
  ^{:doc " Common data.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.SHN_COMMON)"}
  SHN_COMMON)

JOKER CONSTANT SHN_HIOS from debug/elf/elf.go:
(def
  ^{:doc " Last operating system-specific.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.SHN_HIOS)"}
  SHN_HIOS)

JOKER CONSTANT SHN_HIPROC from debug/elf/elf.go:
(def
  ^{:doc " Last processor-specific.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.SHN_HIPROC)"}
  SHN_HIPROC)

JOKER CONSTANT SHN_HIRESERVE from debug/elf/elf.go:
(def
  ^{:doc " Last of reserved range.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.SHN_HIRESERVE)"}
  SHN_HIRESERVE)

JOKER CONSTANT SHN_LOOS from debug/elf/elf.go:
(def
  ^{:doc " First operating system-specific.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.SHN_LOOS)"}
  SHN_LOOS)

JOKER CONSTANT SHN_LOPROC from debug/elf/elf.go:
(def
  ^{:doc " First processor-specific.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.SHN_LOPROC)"}
  SHN_LOPROC)

JOKER CONSTANT SHN_LORESERVE from debug/elf/elf.go:
(def
  ^{:doc " First of reserved range.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.SHN_LORESERVE)"}
  SHN_LORESERVE)

JOKER CONSTANT SHN_UNDEF from debug/elf/elf.go:
(def
  ^{:doc " Undefined, missing, irrelevant.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.SHN_UNDEF)"}
  SHN_UNDEF)

JOKER CONSTANT SHN_XINDEX from debug/elf/elf.go:
(def
  ^{:doc " Escape; index stored elsewhere.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.SHN_XINDEX)"}
  SHN_XINDEX)

JOKER CONSTANT SHT_DYNAMIC from debug/elf/elf.go:
(def
  ^{:doc " dynamic section\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_DYNAMIC))"}
  SHT_DYNAMIC)

JOKER CONSTANT SHT_DYNSYM from debug/elf/elf.go:
(def
  ^{:doc " dynamic symbol table section\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_DYNSYM))"}
  SHT_DYNSYM)

JOKER CONSTANT SHT_FINI_ARRAY from debug/elf/elf.go:
(def
  ^{:doc " Termination function pointers.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_FINI_ARRAY))"}
  SHT_FINI_ARRAY)

JOKER CONSTANT SHT_GNU_ATTRIBUTES from debug/elf/elf.go:
(def
  ^{:doc " GNU object attributes\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_GNU_ATTRIBUTES))"}
  SHT_GNU_ATTRIBUTES)

JOKER CONSTANT SHT_GNU_HASH from debug/elf/elf.go:
(def
  ^{:doc " GNU hash table\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_GNU_HASH))"}
  SHT_GNU_HASH)

JOKER CONSTANT SHT_GNU_LIBLIST from debug/elf/elf.go:
(def
  ^{:doc " GNU prelink library list\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_GNU_LIBLIST))"}
  SHT_GNU_LIBLIST)

JOKER CONSTANT SHT_GNU_VERDEF from debug/elf/elf.go:
(def
  ^{:doc " GNU version definition section\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_GNU_VERDEF))"}
  SHT_GNU_VERDEF)

JOKER CONSTANT SHT_GNU_VERNEED from debug/elf/elf.go:
(def
  ^{:doc " GNU version needs section\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_GNU_VERNEED))"}
  SHT_GNU_VERNEED)

JOKER CONSTANT SHT_GNU_VERSYM from debug/elf/elf.go:
(def
  ^{:doc " GNU version symbol table\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_GNU_VERSYM))"}
  SHT_GNU_VERSYM)

JOKER CONSTANT SHT_GROUP from debug/elf/elf.go:
(def
  ^{:doc " Section group.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_GROUP))"}
  SHT_GROUP)

JOKER CONSTANT SHT_HASH from debug/elf/elf.go:
(def
  ^{:doc " symbol hash table section\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_HASH))"}
  SHT_HASH)

JOKER CONSTANT SHT_HIOS from debug/elf/elf.go:
(def
  ^{:doc " Last of OS specific semantics\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_HIOS))"}
  SHT_HIOS)

JOKER CONSTANT SHT_HIPROC from debug/elf/elf.go:
(def
  ^{:doc " specific section header types\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_HIPROC))"}
  SHT_HIPROC)

JOKER CONSTANT SHT_HIUSER from debug/elf/elf.go:
(def
  ^{:doc " specific indexes\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_HIUSER))"}
  SHT_HIUSER)

JOKER CONSTANT SHT_INIT_ARRAY from debug/elf/elf.go:
(def
  ^{:doc " Initialization function pointers.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_INIT_ARRAY))"}
  SHT_INIT_ARRAY)

JOKER CONSTANT SHT_LOOS from debug/elf/elf.go:
(def
  ^{:doc " First of OS specific semantics\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_LOOS))"}
  SHT_LOOS)

JOKER CONSTANT SHT_LOPROC from debug/elf/elf.go:
(def
  ^{:doc " reserved range for processor\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_LOPROC))"}
  SHT_LOPROC)

JOKER CONSTANT SHT_LOUSER from debug/elf/elf.go:
(def
  ^{:doc " reserved range for application\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_LOUSER))"}
  SHT_LOUSER)

JOKER CONSTANT SHT_NOBITS from debug/elf/elf.go:
(def
  ^{:doc " no space section\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_NOBITS))"}
  SHT_NOBITS)

JOKER CONSTANT SHT_NOTE from debug/elf/elf.go:
(def
  ^{:doc " note section\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_NOTE))"}
  SHT_NOTE)

JOKER CONSTANT SHT_NULL from debug/elf/elf.go:
(def
  ^{:doc " inactive\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_NULL))"}
  SHT_NULL)

JOKER CONSTANT SHT_PREINIT_ARRAY from debug/elf/elf.go:
(def
  ^{:doc " Pre-initialization function ptrs.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_PREINIT_ARRAY))"}
  SHT_PREINIT_ARRAY)

JOKER CONSTANT SHT_PROGBITS from debug/elf/elf.go:
(def
  ^{:doc " program defined information\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_PROGBITS))"}
  SHT_PROGBITS)

JOKER CONSTANT SHT_REL from debug/elf/elf.go:
(def
  ^{:doc " relocation section - no addends\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_REL))"}
  SHT_REL)

JOKER CONSTANT SHT_RELA from debug/elf/elf.go:
(def
  ^{:doc " relocation section with addends\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_RELA))"}
  SHT_RELA)

JOKER CONSTANT SHT_SHLIB from debug/elf/elf.go:
(def
  ^{:doc " reserved - purpose unknown\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_SHLIB))"}
  SHT_SHLIB)

JOKER CONSTANT SHT_STRTAB from debug/elf/elf.go:
(def
  ^{:doc " string table section\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_STRTAB))"}
  SHT_STRTAB)

JOKER CONSTANT SHT_SYMTAB from debug/elf/elf.go:
(def
  ^{:doc " symbol table section\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_SYMTAB))"}
  SHT_SYMTAB)

JOKER CONSTANT SHT_SYMTAB_SHNDX from debug/elf/elf.go:
(def
  ^{:doc " Section indexes (see SHN_XINDEX).\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(elf.SHT_SYMTAB_SHNDX))"}
  SHT_SYMTAB_SHNDX)

JOKER CONSTANT STB_GLOBAL from debug/elf/elf.go:
(def
  ^{:doc " Global symbol\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STB_GLOBAL)"}
  STB_GLOBAL)

JOKER CONSTANT STB_HIOS from debug/elf/elf.go:
(def
  ^{:doc "   specific semantics.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STB_HIOS)"}
  STB_HIOS)

JOKER CONSTANT STB_HIPROC from debug/elf/elf.go:
(def
  ^{:doc "   specific semantics.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STB_HIPROC)"}
  STB_HIPROC)

JOKER CONSTANT STB_LOCAL from debug/elf/elf.go:
(def
  ^{:doc " Local symbol\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STB_LOCAL)"}
  STB_LOCAL)

JOKER CONSTANT STB_LOOS from debug/elf/elf.go:
(def
  ^{:doc " Reserved range for operating system\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STB_LOOS)"}
  STB_LOOS)

JOKER CONSTANT STB_LOPROC from debug/elf/elf.go:
(def
  ^{:doc " reserved range for processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STB_LOPROC)"}
  STB_LOPROC)

JOKER CONSTANT STB_WEAK from debug/elf/elf.go:
(def
  ^{:doc " like global - lower precedence\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STB_WEAK)"}
  STB_WEAK)

JOKER CONSTANT STT_COMMON from debug/elf/elf.go:
(def
  ^{:doc " Uninitialized common block.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STT_COMMON)"}
  STT_COMMON)

JOKER CONSTANT STT_FILE from debug/elf/elf.go:
(def
  ^{:doc " Source file.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STT_FILE)"}
  STT_FILE)

JOKER CONSTANT STT_FUNC from debug/elf/elf.go:
(def
  ^{:doc " Function.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STT_FUNC)"}
  STT_FUNC)

JOKER CONSTANT STT_HIOS from debug/elf/elf.go:
(def
  ^{:doc "   specific semantics.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STT_HIOS)"}
  STT_HIOS)

JOKER CONSTANT STT_HIPROC from debug/elf/elf.go:
(def
  ^{:doc "   specific semantics.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STT_HIPROC)"}
  STT_HIPROC)

JOKER CONSTANT STT_LOOS from debug/elf/elf.go:
(def
  ^{:doc " Reserved range for operating system\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STT_LOOS)"}
  STT_LOOS)

JOKER CONSTANT STT_LOPROC from debug/elf/elf.go:
(def
  ^{:doc " reserved range for processor\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STT_LOPROC)"}
  STT_LOPROC)

JOKER CONSTANT STT_NOTYPE from debug/elf/elf.go:
(def
  ^{:doc " Unspecified type.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STT_NOTYPE)"}
  STT_NOTYPE)

JOKER CONSTANT STT_OBJECT from debug/elf/elf.go:
(def
  ^{:doc " Data object.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STT_OBJECT)"}
  STT_OBJECT)

JOKER CONSTANT STT_SECTION from debug/elf/elf.go:
(def
  ^{:doc " Section.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STT_SECTION)"}
  STT_SECTION)

JOKER CONSTANT STT_TLS from debug/elf/elf.go:
(def
  ^{:doc " TLS object.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STT_TLS)"}
  STT_TLS)

JOKER CONSTANT STV_DEFAULT from debug/elf/elf.go:
(def
  ^{:doc " Default visibility (see binding).\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STV_DEFAULT)"}
  STV_DEFAULT)

JOKER CONSTANT STV_HIDDEN from debug/elf/elf.go:
(def
  ^{:doc " Not visible.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STV_HIDDEN)"}
  STV_HIDDEN)

JOKER CONSTANT STV_INTERNAL from debug/elf/elf.go:
(def
  ^{:doc " Special meaning in relocatable objects.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STV_INTERNAL)"}
  STV_INTERNAL)

JOKER CONSTANT STV_PROTECTED from debug/elf/elf.go:
(def
  ^{:doc " Visible but not preemptible.\n"
    :added "1.0"
    :tag "Int"
    :go "int(elf.STV_PROTECTED)"}
  STV_PROTECTED)

JOKER CONSTANT Sym32Size from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "elf.Sym32Size"}
  Sym32Size)

JOKER CONSTANT Sym64Size from debug/elf/elf.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "elf.Sym64Size"}
  Sym64Size)

JOKER VARIABLE ErrNoSymbols from debug/elf/file.go:
(def
  ^{:doc "ErrNoSymbols is returned by File.Symbols and File.DynamicSymbols\nif there is no such section in the File.\n"
    :added "1.0"
    :tag "Var"
    :go "elf.ErrNoSymbols"}
  ErrNoSymbols)

JOKER TYPE debug/elf.Chdr32 from debug/elf/elf.go:
(defn ^"GoObject" Chdr32.
  "Constructor for elf.Chdr32"
  {:added "1.0"
   :go "_ConstructChdr32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Chdr64 from debug/elf/elf.go:
(defn ^"GoObject" Chdr64.
  "Constructor for elf.Chdr64"
  {:added "1.0"
   :go "_ConstructChdr64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Class from debug/elf/elf.go:
(defn ^"GoObject" Class.
  "Constructor for elf.Class"
  {:added "1.0"
   :go "_ConstructClass(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.CompressionType from debug/elf/elf.go:
(defn ^"GoObject" CompressionType.
  "Constructor for elf.CompressionType"
  {:added "1.0"
   :go "_ConstructCompressionType(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Data from debug/elf/elf.go:
(defn ^"GoObject" Data.
  "Constructor for elf.Data"
  {:added "1.0"
   :go "_ConstructData(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Dyn32 from debug/elf/elf.go:
(defn ^"GoObject" Dyn32.
  "Constructor for elf.Dyn32"
  {:added "1.0"
   :go "_ConstructDyn32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Dyn64 from debug/elf/elf.go:
(defn ^"GoObject" Dyn64.
  "Constructor for elf.Dyn64"
  {:added "1.0"
   :go "_ConstructDyn64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.DynFlag from debug/elf/elf.go:
(defn ^"GoObject" DynFlag.
  "Constructor for elf.DynFlag"
  {:added "1.0"
   :go "_ConstructDynFlag(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.DynTag from debug/elf/elf.go:
(defn ^"GoObject" DynTag.
  "Constructor for elf.DynTag"
  {:added "1.0"
   :go "_ConstructDynTag(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.File from debug/elf/file.go:
;; (defn ^"GoObject" File.
;;   "Constructor for elf.File"
;;   {:added "1.0"
;;    :go "_ConstructFile(_v)"}
;;   [^Object _v])

JOKER TYPE debug/elf.FileHeader from debug/elf/file.go:
;; (defn ^"GoObject" FileHeader.
;;   "Constructor for elf.FileHeader"
;;   {:added "1.0"
;;    :go "_ConstructFileHeader(_v)"}
;;   [^Object _v])

JOKER TYPE debug/elf.FormatError from debug/elf/file.go:
(defn ^"GoObject" FormatError.
  "Constructor for elf.FormatError"
  {:added "1.0"
   :go "_ConstructFormatError(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Header32 from debug/elf/elf.go:
;; (defn ^"GoObject" Header32.
;;   "Constructor for elf.Header32"
;;   {:added "1.0"
;;    :go "_ConstructHeader32(_v)"}
;;   [^Object _v])

JOKER TYPE debug/elf.Header64 from debug/elf/elf.go:
;; (defn ^"GoObject" Header64.
;;   "Constructor for elf.Header64"
;;   {:added "1.0"
;;    :go "_ConstructHeader64(_v)"}
;;   [^Object _v])

JOKER TYPE debug/elf.ImportedSymbol from debug/elf/file.go:
(defn ^"GoObject" ImportedSymbol.
  "Constructor for elf.ImportedSymbol"
  {:added "1.0"
   :go "_ConstructImportedSymbol(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Machine from debug/elf/elf.go:
(defn ^"GoObject" Machine.
  "Constructor for elf.Machine"
  {:added "1.0"
   :go "_ConstructMachine(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.NType from debug/elf/elf.go:
(defn ^"GoObject" NType.
  "Constructor for elf.NType"
  {:added "1.0"
   :go "_ConstructNType(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.OSABI from debug/elf/elf.go:
(defn ^"GoObject" OSABI.
  "Constructor for elf.OSABI"
  {:added "1.0"
   :go "_ConstructOSABI(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Prog from debug/elf/file.go:
(defn ^"GoObject" Prog.
  "Constructor for elf.Prog"
  {:added "1.0"
   :go "_ConstructProg(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Prog32 from debug/elf/elf.go:
(defn ^"GoObject" Prog32.
  "Constructor for elf.Prog32"
  {:added "1.0"
   :go "_ConstructProg32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Prog64 from debug/elf/elf.go:
(defn ^"GoObject" Prog64.
  "Constructor for elf.Prog64"
  {:added "1.0"
   :go "_ConstructProg64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.ProgFlag from debug/elf/elf.go:
(defn ^"GoObject" ProgFlag.
  "Constructor for elf.ProgFlag"
  {:added "1.0"
   :go "_ConstructProgFlag(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.ProgHeader from debug/elf/file.go:
(defn ^"GoObject" ProgHeader.
  "Constructor for elf.ProgHeader"
  {:added "1.0"
   :go "_ConstructProgHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.ProgType from debug/elf/elf.go:
(defn ^"GoObject" ProgType.
  "Constructor for elf.ProgType"
  {:added "1.0"
   :go "_ConstructProgType(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_386 from debug/elf/elf.go:
(defn ^"GoObject" R_386.
  "Constructor for elf.R_386"
  {:added "1.0"
   :go "_ConstructR_386(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_390 from debug/elf/elf.go:
(defn ^"GoObject" R_390.
  "Constructor for elf.R_390"
  {:added "1.0"
   :go "_ConstructR_390(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_AARCH64 from debug/elf/elf.go:
(defn ^"GoObject" R_AARCH64.
  "Constructor for elf.R_AARCH64"
  {:added "1.0"
   :go "_ConstructR_AARCH64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_ALPHA from debug/elf/elf.go:
(defn ^"GoObject" R_ALPHA.
  "Constructor for elf.R_ALPHA"
  {:added "1.0"
   :go "_ConstructR_ALPHA(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_ARM from debug/elf/elf.go:
(defn ^"GoObject" R_ARM.
  "Constructor for elf.R_ARM"
  {:added "1.0"
   :go "_ConstructR_ARM(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_MIPS from debug/elf/elf.go:
(defn ^"GoObject" R_MIPS.
  "Constructor for elf.R_MIPS"
  {:added "1.0"
   :go "_ConstructR_MIPS(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_PPC from debug/elf/elf.go:
(defn ^"GoObject" R_PPC.
  "Constructor for elf.R_PPC"
  {:added "1.0"
   :go "_ConstructR_PPC(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_PPC64 from debug/elf/elf.go:
(defn ^"GoObject" R_PPC64.
  "Constructor for elf.R_PPC64"
  {:added "1.0"
   :go "_ConstructR_PPC64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_RISCV from debug/elf/elf.go:
(defn ^"GoObject" R_RISCV.
  "Constructor for elf.R_RISCV"
  {:added "1.0"
   :go "_ConstructR_RISCV(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_SPARC from debug/elf/elf.go:
(defn ^"GoObject" R_SPARC.
  "Constructor for elf.R_SPARC"
  {:added "1.0"
   :go "_ConstructR_SPARC(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_X86_64 from debug/elf/elf.go:
(defn ^"GoObject" R_X86_64.
  "Constructor for elf.R_X86_64"
  {:added "1.0"
   :go "_ConstructR_X86_64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Rel32 from debug/elf/elf.go:
(defn ^"GoObject" Rel32.
  "Constructor for elf.Rel32"
  {:added "1.0"
   :go "_ConstructRel32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Rel64 from debug/elf/elf.go:
(defn ^"GoObject" Rel64.
  "Constructor for elf.Rel64"
  {:added "1.0"
   :go "_ConstructRel64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Rela32 from debug/elf/elf.go:
(defn ^"GoObject" Rela32.
  "Constructor for elf.Rela32"
  {:added "1.0"
   :go "_ConstructRela32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Rela64 from debug/elf/elf.go:
(defn ^"GoObject" Rela64.
  "Constructor for elf.Rela64"
  {:added "1.0"
   :go "_ConstructRela64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Section from debug/elf/file.go:
(defn ^"GoObject" Section.
  "Constructor for elf.Section"
  {:added "1.0"
   :go "_ConstructSection(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Section32 from debug/elf/elf.go:
(defn ^"GoObject" Section32.
  "Constructor for elf.Section32"
  {:added "1.0"
   :go "_ConstructSection32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Section64 from debug/elf/elf.go:
(defn ^"GoObject" Section64.
  "Constructor for elf.Section64"
  {:added "1.0"
   :go "_ConstructSection64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.SectionFlag from debug/elf/elf.go:
(defn ^"GoObject" SectionFlag.
  "Constructor for elf.SectionFlag"
  {:added "1.0"
   :go "_ConstructSectionFlag(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.SectionHeader from debug/elf/file.go:
(defn ^"GoObject" SectionHeader.
  "Constructor for elf.SectionHeader"
  {:added "1.0"
   :go "_ConstructSectionHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.SectionIndex from debug/elf/elf.go:
(defn ^"GoObject" SectionIndex.
  "Constructor for elf.SectionIndex"
  {:added "1.0"
   :go "_ConstructSectionIndex(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.SectionType from debug/elf/elf.go:
(defn ^"GoObject" SectionType.
  "Constructor for elf.SectionType"
  {:added "1.0"
   :go "_ConstructSectionType(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Sym32 from debug/elf/elf.go:
(defn ^"GoObject" Sym32.
  "Constructor for elf.Sym32"
  {:added "1.0"
   :go "_ConstructSym32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Sym64 from debug/elf/elf.go:
(defn ^"GoObject" Sym64.
  "Constructor for elf.Sym64"
  {:added "1.0"
   :go "_ConstructSym64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.SymBind from debug/elf/elf.go:
(defn ^"GoObject" SymBind.
  "Constructor for elf.SymBind"
  {:added "1.0"
   :go "_ConstructSymBind(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.SymType from debug/elf/elf.go:
(defn ^"GoObject" SymType.
  "Constructor for elf.SymType"
  {:added "1.0"
   :go "_ConstructSymType(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.SymVis from debug/elf/elf.go:
(defn ^"GoObject" SymVis.
  "Constructor for elf.SymVis"
  {:added "1.0"
   :go "_ConstructSymVis(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Symbol from debug/elf/file.go:
(defn ^"GoObject" Symbol.
  "Constructor for elf.Symbol"
  {:added "1.0"
   :go "_ConstructSymbol(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Type from debug/elf/elf.go:
(defn ^"GoObject" Type.
  "Constructor for elf.Type"
  {:added "1.0"
   :go "_ConstructType(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Version from debug/elf/elf.go:
(defn ^"GoObject" Version.
  "Constructor for elf.Version"
  {:added "1.0"
   :go "_ConstructVersion(_v)"}
  [^Object _v])

JOKER FUNC debug/elf.NewFile from debug/elf/file.go:
;; (defn NewFile
;;   "NewFile creates a new File for accessing an ELF binary in an underlying reader.\nThe ELF binary is expected to start at position 0 in the ReaderAt.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r]\n\nJoker return type: [(atom-of go.std.debug.elf/File) Error]"
;;   {:added "1.0"
;;    :go "__newFile(*__r)"}
;;   [^io/ReaderAt __r])

JOKER FUNC debug/elf.Open from debug/elf/file.go:
(defn Open
  "Open opens the named file using os.Open and prepares it for use as an ELF binary.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.debug.elf/File) Error]"
  {:added "1.0"
   :go "__open(__name)"}
  [^String __name])

JOKER FUNC debug/elf.R_INFO from debug/elf/elf.go:
(defn R_INFO
  "Go input arguments: (sym uint32, typ uint32)\n\nGo return type: uint64\n\nJoker input arguments: [^Number sym, ^Number typ]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__r_INFO(__sym, __typ)"}
  [^UInt32 __sym, ^UInt32 __typ])

JOKER FUNC debug/elf.R_INFO32 from debug/elf/elf.go:
(defn R_INFO32
  "Go input arguments: (sym uint32, typ uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^Number sym, ^Number typ]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__r_INFO32(__sym, __typ)"}
  [^UInt32 __sym, ^UInt32 __typ])

JOKER FUNC debug/elf.R_SYM32 from debug/elf/elf.go:
(defn R_SYM32
  "Go input arguments: (info uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^Number info]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__r_SYM32(__info)"}
  [^UInt32 __info])

JOKER FUNC debug/elf.R_SYM64 from debug/elf/elf.go:
(defn R_SYM64
  "Go input arguments: (info uint64)\n\nGo return type: uint32\n\nJoker input arguments: [^Number info]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__r_SYM64(__info)"}
  [^UInt64 __info])

JOKER FUNC debug/elf.R_TYPE32 from debug/elf/elf.go:
(defn R_TYPE32
  "Go input arguments: (info uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^Number info]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__r_TYPE32(__info)"}
  [^UInt32 __info])

JOKER FUNC debug/elf.R_TYPE64 from debug/elf/elf.go:
(defn R_TYPE64
  "Go input arguments: (info uint64)\n\nGo return type: uint32\n\nJoker input arguments: [^Number info]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__r_TYPE64(__info)"}
  [^UInt64 __info])

JOKER FUNC debug/elf.ST_BIND from debug/elf/elf.go:
(defn ST_BIND
  "Go input arguments: (info uint8)\n\nGo return type: SymBind\n\nJoker input arguments: [^Int info]\n\nJoker return type: go.std.debug.elf/SymBind"
  {:added "1.0"
   :go "__sT_BIND(__info)"}
  [^UInt8 __info])

JOKER FUNC debug/elf.ST_INFO from debug/elf/elf.go:
(defn ST_INFO
  "Go input arguments: (bind SymBind, typ SymType)\n\nGo return type: uint8\n\nJoker input arguments: [^go.std.debug.elf/SymBind bind, ^go.std.debug.elf/SymType typ]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__sT_INFO(*__bind, *__typ)"}
  [^elf/SymBind __bind, ^elf/SymType __typ])

JOKER FUNC debug/elf.ST_TYPE from debug/elf/elf.go:
(defn ST_TYPE
  "Go input arguments: (info uint8)\n\nGo return type: SymType\n\nJoker input arguments: [^Int info]\n\nJoker return type: go.std.debug.elf/SymType"
  {:added "1.0"
   :go "__sT_TYPE(__info)"}
  [^UInt8 __info])

JOKER FUNC debug/elf.ST_VISIBILITY from debug/elf/elf.go:
(defn ST_VISIBILITY
  "Go input arguments: (other uint8)\n\nGo return type: SymVis\n\nJoker input arguments: [^Int other]\n\nJoker return type: go.std.debug.elf/SymVis"
  {:added "1.0"
   :go "__sT_VISIBILITY(__other)"}
  [^UInt8 __other])

JOKER TYPE go.std.debug.elf/Chdr32:
(def
  ^{:doc "ELF32 Compression header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Chdr32"}
  Chdr32)

JOKER TYPE go.std.debug.elf/Chdr64:
(def
  ^{:doc "ELF64 Compression header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Chdr64"}
  Chdr64)

JOKER TYPE go.std.debug.elf/Class:
(def
  ^{:doc "Class is found in Header.Ident[EI_CLASS] and Header.Class.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Class"}
  Class)

JOKER TYPE go.std.debug.elf/CompressionType:
(def
  ^{:doc "Section compression type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CompressionType"}
  CompressionType)

JOKER TYPE go.std.debug.elf/Data:
(def
  ^{:doc "Data is found in Header.Ident[EI_DATA] and Header.Data.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Data"}
  Data)

JOKER TYPE go.std.debug.elf/Dyn32:
(def
  ^{:doc "ELF32 Dynamic structure. The \".dynamic\" section contains an array of them.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Dyn32"}
  Dyn32)

JOKER TYPE go.std.debug.elf/Dyn64:
(def
  ^{:doc "ELF64 Dynamic structure. The \".dynamic\" section contains an array of them.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Dyn64"}
  Dyn64)

JOKER TYPE go.std.debug.elf/DynFlag:
(def
  ^{:doc "DT_FLAGS values.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DynFlag"}
  DynFlag)

JOKER TYPE go.std.debug.elf/DynTag:
(def
  ^{:doc "Dyn.Tag\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DynTag"}
  DynTag)

JOKER TYPE go.std.debug.elf/File:
(def
  ^{:doc "A File represents an open ELF file.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_File"}
  File)

JOKER TYPE go.std.debug.elf/FileHeader:
(def
  ^{:doc "A FileHeader represents an ELF file header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FileHeader"}
  FileHeader)

JOKER TYPE go.std.debug.elf/FormatError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_FormatError"}
  FormatError)

JOKER TYPE go.std.debug.elf/Header32:
(def
  ^{:doc "ELF32 File header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Header32"}
  Header32)

JOKER TYPE go.std.debug.elf/Header64:
(def
  ^{:doc "ELF64 file header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Header64"}
  Header64)

JOKER TYPE go.std.debug.elf/ImportedSymbol:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_ImportedSymbol"}
  ImportedSymbol)

JOKER TYPE go.std.debug.elf/Machine:
(def
  ^{:doc "Machine is found in Header.Machine.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Machine"}
  Machine)

JOKER TYPE go.std.debug.elf/NType:
(def
  ^{:doc "NType values; used in core files.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NType"}
  NType)

JOKER TYPE go.std.debug.elf/OSABI:
(def
  ^{:doc "OSABI is found in Header.Ident[EI_OSABI] and Header.OSABI.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_OSABI"}
  OSABI)

JOKER TYPE go.std.debug.elf/Prog:
(def
  ^{:doc "A Prog represents a single ELF program header in an ELF binary.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Prog"}
  Prog)

JOKER TYPE go.std.debug.elf/Prog32:
(def
  ^{:doc "ELF32 Program header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Prog32"}
  Prog32)

JOKER TYPE go.std.debug.elf/Prog64:
(def
  ^{:doc "ELF64 Program header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Prog64"}
  Prog64)

JOKER TYPE go.std.debug.elf/ProgFlag:
(def
  ^{:doc "Prog.Flag\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ProgFlag"}
  ProgFlag)

JOKER TYPE go.std.debug.elf/ProgHeader:
(def
  ^{:doc "A ProgHeader represents a single ELF program header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ProgHeader"}
  ProgHeader)

JOKER TYPE go.std.debug.elf/ProgType:
(def
  ^{:doc "Prog.Type\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ProgType"}
  ProgType)

JOKER TYPE go.std.debug.elf/R_386:
(def
  ^{:doc "Relocation types for 386.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_R_386"}
  R_386)

JOKER TYPE go.std.debug.elf/R_390:
(def
  ^{:doc "Relocation types for s390x processors.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_R_390"}
  R_390)

JOKER TYPE go.std.debug.elf/R_AARCH64:
(def
  ^{:doc "Relocation types for AArch64 (aka arm64)\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_R_AARCH64"}
  R_AARCH64)

JOKER TYPE go.std.debug.elf/R_ALPHA:
(def
  ^{:doc "Relocation types for Alpha.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_R_ALPHA"}
  R_ALPHA)

JOKER TYPE go.std.debug.elf/R_ARM:
(def
  ^{:doc "Relocation types for ARM.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_R_ARM"}
  R_ARM)

JOKER TYPE go.std.debug.elf/R_MIPS:
(def
  ^{:doc "Relocation types for MIPS.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_R_MIPS"}
  R_MIPS)

JOKER TYPE go.std.debug.elf/R_PPC:
(def
  ^{:doc "Relocation types for PowerPC.\n\nValues that are shared by both R_PPC and R_PPC64 are prefixed with\nR_POWERPC_ in the ELF standard. For the R_PPC type, the relevant\nshared relocations have been renamed with the prefix R_PPC_.\nThe original name follows the value in a comment.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_R_PPC"}
  R_PPC)

JOKER TYPE go.std.debug.elf/R_PPC64:
(def
  ^{:doc "Relocation types for 64-bit PowerPC or Power Architecture processors.\n\nValues that are shared by both R_PPC and R_PPC64 are prefixed with\nR_POWERPC_ in the ELF standard. For the R_PPC64 type, the relevant\nshared relocations have been renamed with the prefix R_PPC64_.\nThe original name follows the value in a comment.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_R_PPC64"}
  R_PPC64)

JOKER TYPE go.std.debug.elf/R_RISCV:
(def
  ^{:doc "Relocation types for RISC-V processors.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_R_RISCV"}
  R_RISCV)

JOKER TYPE go.std.debug.elf/R_SPARC:
(def
  ^{:doc "Relocation types for SPARC.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_R_SPARC"}
  R_SPARC)

JOKER TYPE go.std.debug.elf/R_X86_64:
(def
  ^{:doc "Relocation types for x86-64.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_R_X86_64"}
  R_X86_64)

JOKER TYPE go.std.debug.elf/Rel32:
(def
  ^{:doc "ELF32 Relocations that don't need an addend field.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Rel32"}
  Rel32)

JOKER TYPE go.std.debug.elf/Rel64:
(def
  ^{:doc " ELF64 relocations that don't need an addend field.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Rel64"}
  Rel64)

JOKER TYPE go.std.debug.elf/Rela32:
(def
  ^{:doc "ELF32 Relocations that need an addend field.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Rela32"}
  Rela32)

JOKER TYPE go.std.debug.elf/Rela64:
(def
  ^{:doc " ELF64 relocations that need an addend field.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Rela64"}
  Rela64)

JOKER TYPE go.std.debug.elf/Section:
(def
  ^{:doc "A Section represents a single section in an ELF file.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Section"}
  Section)

JOKER TYPE go.std.debug.elf/Section32:
(def
  ^{:doc "ELF32 Section header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Section32"}
  Section32)

JOKER TYPE go.std.debug.elf/Section64:
(def
  ^{:doc "ELF64 Section header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Section64"}
  Section64)

JOKER TYPE go.std.debug.elf/SectionFlag:
(def
  ^{:doc "Section flags.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SectionFlag"}
  SectionFlag)

JOKER TYPE go.std.debug.elf/SectionHeader:
(def
  ^{:doc "A SectionHeader represents a single ELF section header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SectionHeader"}
  SectionHeader)

JOKER TYPE go.std.debug.elf/SectionIndex:
(def
  ^{:doc "Special section indices.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SectionIndex"}
  SectionIndex)

JOKER TYPE go.std.debug.elf/SectionType:
(def
  ^{:doc "Section type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SectionType"}
  SectionType)

JOKER TYPE go.std.debug.elf/Sym32:
(def
  ^{:doc "ELF32 Symbol.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Sym32"}
  Sym32)

JOKER TYPE go.std.debug.elf/Sym64:
(def
  ^{:doc "ELF64 symbol table entries.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Sym64"}
  Sym64)

JOKER TYPE go.std.debug.elf/SymBind:
(def
  ^{:doc " Symbol Binding - ELFNN_ST_BIND - st_info\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SymBind"}
  SymBind)

JOKER TYPE go.std.debug.elf/SymType:
(def
  ^{:doc " Symbol type - ELFNN_ST_TYPE - st_info\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SymType"}
  SymType)

JOKER TYPE go.std.debug.elf/SymVis:
(def
  ^{:doc " Symbol visibility - ELFNN_ST_VISIBILITY - st_other\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SymVis"}
  SymVis)

JOKER TYPE go.std.debug.elf/Symbol:
(def
  ^{:doc "A Symbol represents an entry in an ELF symbol table section.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Symbol"}
  Symbol)

JOKER TYPE go.std.debug.elf/Type:
(def
  ^{:doc "Type is found in Header.Type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Type"}
  Type)

JOKER TYPE go.std.debug.elf/Version:
(def
  ^{:doc "Version is found in Header.Ident[EI_VERSION] and Header.Version.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Version"}
  Version)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["debug/elf"]
    :doc "Provides a low-level interface to the debug/elf package.\n\nPackage elf implements access to ELF object files.\n"
    :empty false}
  go.std.debug.elf)
JOKER TYPE debug/gosym.DecodingError from debug/gosym/symtab.go:
(defn ^"GoObject" DecodingError.
  "Constructor for gosym.DecodingError"
  {:added "1.0"
   :go "_ConstructDecodingError(_v)"}
  [^Object _v])

JOKER TYPE debug/gosym.Func from debug/gosym/symtab.go:
;; (defn ^"GoObject" Func.
;;   "Constructor for gosym.Func"
;;   {:added "1.0"
;;    :go "_ConstructFunc(_v)"}
;;   [^Object _v])

JOKER TYPE debug/gosym.LineTable from debug/gosym/pclntab.go:
;; (defn ^"GoObject" LineTable.
;;   "Constructor for gosym.LineTable"
;;   {:added "1.0"
;;    :go "_ConstructLineTable(_v)"}
;;   [^Object _v])

JOKER TYPE debug/gosym.Obj from debug/gosym/symtab.go:
;; (defn ^"GoObject" Obj.
;;   "Constructor for gosym.Obj"
;;   {:added "1.0"
;;    :go "_ConstructObj(_v)"}
;;   [^Object _v])

JOKER TYPE debug/gosym.Sym from debug/gosym/symtab.go:
;; (defn ^"GoObject" Sym.
;;   "Constructor for gosym.Sym"
;;   {:added "1.0"
;;    :go "_ConstructSym(_v)"}
;;   [^Object _v])

JOKER TYPE debug/gosym.Table from debug/gosym/symtab.go:
;; (defn ^"GoObject" Table.
;;   "Constructor for gosym.Table"
;;   {:added "1.0"
;;    :go "_ConstructTable(_v)"}
;;   [^Object _v])

JOKER TYPE debug/gosym.UnknownFileError from debug/gosym/symtab.go:
(defn ^"GoObject" UnknownFileError.
  "Constructor for gosym.UnknownFileError"
  {:added "1.0"
   :go "_ConstructUnknownFileError(_v)"}
  [^Object _v])

JOKER TYPE debug/gosym.UnknownLineError from debug/gosym/symtab.go:
(defn ^"GoObject" UnknownLineError.
  "Constructor for gosym.UnknownLineError"
  {:added "1.0"
   :go "_ConstructUnknownLineError(_v)"}
  [^Object _v])

JOKER FUNC debug/gosym.NewLineTable from debug/gosym/pclntab.go:
;; (defn NewLineTable
;;   "NewLineTable returns a new PC/line table\ncorresponding to the encoded data.\nText must be the start address of the\ncorresponding text segment.\n\nGo input arguments: (data []byte, text uint64)\n\nGo return type: *LineTable\n\nJoker input arguments: [^(vector-of Int) data, ^Number text]\n\nJoker return type: (atom-of go.std.debug.gosym/LineTable)"
;;   {:added "1.0"
;;    :go "__newLineTable(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)), __text)"}
;;   [^Object __data, ^UInt64 __text])

JOKER FUNC debug/gosym.NewTable from debug/gosym/symtab.go:
;; (defn NewTable
;;   "NewTable decodes the Go symbol table (the \".gosymtab\" section in ELF),\nreturning an in-memory representation.\nStarting with Go 1.3, the Go symbol table no longer includes symbol data.\n\nGo input arguments: (symtab []byte, pcln *LineTable)\n\nGo return type: (*Table, error)\n\nJoker input arguments: [^(vector-of Int) symtab, ^(atom-of go.std.debug.gosym/LineTable) pcln]\n\nJoker return type: [(atom-of go.std.debug.gosym/Table) Error]"
;;   {:added "1.0"
;;    :go "__newTable(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__symtab)), __pcln)"}
;;   [^Object __symtab, ^gosym/LineTable __pcln])

JOKER TYPE go.std.debug.gosym/DecodingError:
(def
  ^{:doc "DecodingError represents an error during the decoding of\nthe symbol table.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DecodingError"}
  DecodingError)

JOKER TYPE go.std.debug.gosym/Func:
(def
  ^{:doc "A Func collects information about a single function.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Func"}
  Func)

JOKER TYPE go.std.debug.gosym/LineTable:
(def
  ^{:doc "A LineTable is a data structure mapping program counters to line numbers.\n\nIn Go 1.1 and earlier, each function (represented by a Func) had its own LineTable,\nand the line number corresponded to a numbering of all source lines in the\nprogram, across all files. That absolute line number would then have to be\nconverted separately to a file name and line number within the file.\n\nIn Go 1.2, the format of the data changed so that there is a single LineTable\nfor the entire program, shared by all Funcs, and there are no absolute line\nnumbers, just line numbers within specific files.\n\nFor the most part, LineTable's methods should be treated as an internal\ndetail of the package; callers should use the methods on Table instead.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_LineTable"}
  LineTable)

JOKER TYPE go.std.debug.gosym/Obj:
(def
  ^{:doc "An Obj represents a collection of functions in a symbol table.\n\nThe exact method of division of a binary into separate Objs is an internal detail\nof the symbol table format.\n\nIn early versions of Go each source file became a different Obj.\n\nIn Go 1 and Go 1.1, each package produced one Obj for all Go sources\nand one Obj per C source file.\n\nIn Go 1.2, there is a single Obj for the entire program.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Obj"}
  Obj)

JOKER TYPE go.std.debug.gosym/Sym:
(def
  ^{:doc "A Sym represents a single symbol table entry.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Sym"}
  Sym)

JOKER TYPE go.std.debug.gosym/Table:
(def
  ^{:doc "Table represents a Go symbol table. It stores all of the\nsymbols decoded from the program and provides methods to translate\nbetween symbols, names, and addresses.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Table"}
  Table)

JOKER TYPE go.std.debug.gosym/UnknownFileError:
(def
  ^{:doc "UnknownFileError represents a failure to find the specific file in\nthe symbol table.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnknownFileError"}
  UnknownFileError)

JOKER TYPE go.std.debug.gosym/UnknownLineError:
(def
  ^{:doc "UnknownLineError represents a failure to map a line to a program\ncounter, either because the line is beyond the bounds of the file\nor because there is no code on the given line.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnknownLineError"}
  UnknownLineError)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the debug/gosym package.\n\nPackage gosym implements access to the Go symbol\nand line number tables embedded in Go binaries generated\nby the gc compilers.\n"
    :empty false}
  go.std.debug.gosym)
JOKER CONSTANT ARM64_RELOC_ADDEND from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.ARM64_RELOC_ADDEND)"}
  ARM64_RELOC_ADDEND)

JOKER CONSTANT ARM64_RELOC_BRANCH26 from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.ARM64_RELOC_BRANCH26)"}
  ARM64_RELOC_BRANCH26)

JOKER CONSTANT ARM64_RELOC_GOT_LOAD_PAGE21 from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.ARM64_RELOC_GOT_LOAD_PAGE21)"}
  ARM64_RELOC_GOT_LOAD_PAGE21)

JOKER CONSTANT ARM64_RELOC_GOT_LOAD_PAGEOFF12 from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.ARM64_RELOC_GOT_LOAD_PAGEOFF12)"}
  ARM64_RELOC_GOT_LOAD_PAGEOFF12)

JOKER CONSTANT ARM64_RELOC_PAGE21 from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.ARM64_RELOC_PAGE21)"}
  ARM64_RELOC_PAGE21)

JOKER CONSTANT ARM64_RELOC_PAGEOFF12 from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.ARM64_RELOC_PAGEOFF12)"}
  ARM64_RELOC_PAGEOFF12)

JOKER CONSTANT ARM64_RELOC_POINTER_TO_GOT from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.ARM64_RELOC_POINTER_TO_GOT)"}
  ARM64_RELOC_POINTER_TO_GOT)

JOKER CONSTANT ARM64_RELOC_SUBTRACTOR from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.ARM64_RELOC_SUBTRACTOR)"}
  ARM64_RELOC_SUBTRACTOR)

JOKER CONSTANT ARM64_RELOC_TLVP_LOAD_PAGE21 from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.ARM64_RELOC_TLVP_LOAD_PAGE21)"}
  ARM64_RELOC_TLVP_LOAD_PAGE21)

JOKER CONSTANT ARM64_RELOC_TLVP_LOAD_PAGEOFF12 from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.ARM64_RELOC_TLVP_LOAD_PAGEOFF12)"}
  ARM64_RELOC_TLVP_LOAD_PAGEOFF12)

JOKER CONSTANT ARM64_RELOC_UNSIGNED from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.ARM64_RELOC_UNSIGNED)"}
  ARM64_RELOC_UNSIGNED)

JOKER CONSTANT ARM_RELOC_BR24 from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.ARM_RELOC_BR24)"}
  ARM_RELOC_BR24)

JOKER CONSTANT ARM_RELOC_HALF from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.ARM_RELOC_HALF)"}
  ARM_RELOC_HALF)

JOKER CONSTANT ARM_RELOC_HALF_SECTDIFF from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.ARM_RELOC_HALF_SECTDIFF)"}
  ARM_RELOC_HALF_SECTDIFF)

JOKER CONSTANT ARM_RELOC_LOCAL_SECTDIFF from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.ARM_RELOC_LOCAL_SECTDIFF)"}
  ARM_RELOC_LOCAL_SECTDIFF)

JOKER CONSTANT ARM_RELOC_PAIR from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.ARM_RELOC_PAIR)"}
  ARM_RELOC_PAIR)

JOKER CONSTANT ARM_RELOC_PB_LA_PTR from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.ARM_RELOC_PB_LA_PTR)"}
  ARM_RELOC_PB_LA_PTR)

JOKER CONSTANT ARM_RELOC_SECTDIFF from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.ARM_RELOC_SECTDIFF)"}
  ARM_RELOC_SECTDIFF)

JOKER CONSTANT ARM_RELOC_VANILLA from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.ARM_RELOC_VANILLA)"}
  ARM_RELOC_VANILLA)

JOKER CONSTANT ARM_THUMB_32BIT_BRANCH from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.ARM_THUMB_32BIT_BRANCH)"}
  ARM_THUMB_32BIT_BRANCH)

JOKER CONSTANT ARM_THUMB_RELOC_BR22 from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.ARM_THUMB_RELOC_BR22)"}
  ARM_THUMB_RELOC_BR22)

JOKER CONSTANT Cpu386 from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(macho.Cpu386))"}
  Cpu386)

JOKER CONSTANT CpuAmd64 from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(macho.CpuAmd64))"}
  CpuAmd64)

JOKER CONSTANT CpuArm from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(macho.CpuArm))"}
  CpuArm)

JOKER CONSTANT CpuArm64 from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(macho.CpuArm64))"}
  CpuArm64)

JOKER CONSTANT CpuPpc from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(macho.CpuPpc))"}
  CpuPpc)

JOKER CONSTANT CpuPpc64 from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(macho.CpuPpc64))"}
  CpuPpc64)

JOKER CONSTANT FlagAllModsBound from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagAllModsBound)"}
  FlagAllModsBound)

JOKER CONSTANT FlagAllowStackExecution from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagAllowStackExecution)"}
  FlagAllowStackExecution)

JOKER CONSTANT FlagAppExtensionSafe from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagAppExtensionSafe)"}
  FlagAppExtensionSafe)

JOKER CONSTANT FlagBindAtLoad from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagBindAtLoad)"}
  FlagBindAtLoad)

JOKER CONSTANT FlagBindsToWeak from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagBindsToWeak)"}
  FlagBindsToWeak)

JOKER CONSTANT FlagCanonical from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagCanonical)"}
  FlagCanonical)

JOKER CONSTANT FlagDeadStrippableDylib from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagDeadStrippableDylib)"}
  FlagDeadStrippableDylib)

JOKER CONSTANT FlagDyldLink from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagDyldLink)"}
  FlagDyldLink)

JOKER CONSTANT FlagForceFlat from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagForceFlat)"}
  FlagForceFlat)

JOKER CONSTANT FlagHasTLVDescriptors from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagHasTLVDescriptors)"}
  FlagHasTLVDescriptors)

JOKER CONSTANT FlagIncrLink from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagIncrLink)"}
  FlagIncrLink)

JOKER CONSTANT FlagLazyInit from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagLazyInit)"}
  FlagLazyInit)

JOKER CONSTANT FlagNoFixPrebinding from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagNoFixPrebinding)"}
  FlagNoFixPrebinding)

JOKER CONSTANT FlagNoHeapExecution from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagNoHeapExecution)"}
  FlagNoHeapExecution)

JOKER CONSTANT FlagNoMultiDefs from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagNoMultiDefs)"}
  FlagNoMultiDefs)

JOKER CONSTANT FlagNoReexportedDylibs from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagNoReexportedDylibs)"}
  FlagNoReexportedDylibs)

JOKER CONSTANT FlagNoUndefs from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagNoUndefs)"}
  FlagNoUndefs)

JOKER CONSTANT FlagPIE from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagPIE)"}
  FlagPIE)

JOKER CONSTANT FlagPrebindable from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagPrebindable)"}
  FlagPrebindable)

JOKER CONSTANT FlagPrebound from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagPrebound)"}
  FlagPrebound)

JOKER CONSTANT FlagRootSafe from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagRootSafe)"}
  FlagRootSafe)

JOKER CONSTANT FlagSetuidSafe from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagSetuidSafe)"}
  FlagSetuidSafe)

JOKER CONSTANT FlagSplitSegs from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagSplitSegs)"}
  FlagSplitSegs)

JOKER CONSTANT FlagSubsectionsViaSymbols from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagSubsectionsViaSymbols)"}
  FlagSubsectionsViaSymbols)

JOKER CONSTANT FlagTwoLevel from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagTwoLevel)"}
  FlagTwoLevel)

JOKER CONSTANT FlagWeakDefines from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.FlagWeakDefines)"}
  FlagWeakDefines)

JOKER CONSTANT GENERIC_RELOC_LOCAL_SECTDIFF from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.GENERIC_RELOC_LOCAL_SECTDIFF)"}
  GENERIC_RELOC_LOCAL_SECTDIFF)

JOKER CONSTANT GENERIC_RELOC_PAIR from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.GENERIC_RELOC_PAIR)"}
  GENERIC_RELOC_PAIR)

JOKER CONSTANT GENERIC_RELOC_PB_LA_PTR from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.GENERIC_RELOC_PB_LA_PTR)"}
  GENERIC_RELOC_PB_LA_PTR)

JOKER CONSTANT GENERIC_RELOC_SECTDIFF from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.GENERIC_RELOC_SECTDIFF)"}
  GENERIC_RELOC_SECTDIFF)

JOKER CONSTANT GENERIC_RELOC_TLV from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.GENERIC_RELOC_TLV)"}
  GENERIC_RELOC_TLV)

JOKER CONSTANT GENERIC_RELOC_VANILLA from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.GENERIC_RELOC_VANILLA)"}
  GENERIC_RELOC_VANILLA)

JOKER CONSTANT LoadCmdDylib from debug/macho/macho.go:
(def
  ^{:doc "load dylib command\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(macho.LoadCmdDylib))"}
  LoadCmdDylib)

JOKER CONSTANT LoadCmdDylinker from debug/macho/macho.go:
(def
  ^{:doc "id dylinker command (not load dylinker command)\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(macho.LoadCmdDylinker))"}
  LoadCmdDylinker)

JOKER CONSTANT LoadCmdDysymtab from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(macho.LoadCmdDysymtab))"}
  LoadCmdDysymtab)

JOKER CONSTANT LoadCmdRpath from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(macho.LoadCmdRpath))"}
  LoadCmdRpath)

JOKER CONSTANT LoadCmdSegment from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(macho.LoadCmdSegment))"}
  LoadCmdSegment)

JOKER CONSTANT LoadCmdSegment64 from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(macho.LoadCmdSegment64))"}
  LoadCmdSegment64)

JOKER CONSTANT LoadCmdSymtab from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(macho.LoadCmdSymtab))"}
  LoadCmdSymtab)

JOKER CONSTANT LoadCmdThread from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(macho.LoadCmdThread))"}
  LoadCmdThread)

JOKER CONSTANT LoadCmdUnixThread from debug/macho/macho.go:
(def
  ^{:doc "thread+stack\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(macho.LoadCmdUnixThread))"}
  LoadCmdUnixThread)

JOKER CONSTANT Magic32 from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.Magic32)"}
  Magic32)

JOKER CONSTANT Magic64 from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.Magic64)"}
  Magic64)

JOKER CONSTANT MagicFat from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(macho.MagicFat)"}
  MagicFat)

JOKER CONSTANT TypeBundle from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(macho.TypeBundle))"}
  TypeBundle)

JOKER CONSTANT TypeDylib from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(macho.TypeDylib))"}
  TypeDylib)

JOKER CONSTANT TypeExec from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(macho.TypeExec))"}
  TypeExec)

JOKER CONSTANT TypeObj from debug/macho/macho.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(macho.TypeObj))"}
  TypeObj)

JOKER CONSTANT X86_64_RELOC_BRANCH from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.X86_64_RELOC_BRANCH)"}
  X86_64_RELOC_BRANCH)

JOKER CONSTANT X86_64_RELOC_GOT from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.X86_64_RELOC_GOT)"}
  X86_64_RELOC_GOT)

JOKER CONSTANT X86_64_RELOC_GOT_LOAD from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.X86_64_RELOC_GOT_LOAD)"}
  X86_64_RELOC_GOT_LOAD)

JOKER CONSTANT X86_64_RELOC_SIGNED from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.X86_64_RELOC_SIGNED)"}
  X86_64_RELOC_SIGNED)

JOKER CONSTANT X86_64_RELOC_SIGNED_1 from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.X86_64_RELOC_SIGNED_1)"}
  X86_64_RELOC_SIGNED_1)

JOKER CONSTANT X86_64_RELOC_SIGNED_2 from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.X86_64_RELOC_SIGNED_2)"}
  X86_64_RELOC_SIGNED_2)

JOKER CONSTANT X86_64_RELOC_SIGNED_4 from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.X86_64_RELOC_SIGNED_4)"}
  X86_64_RELOC_SIGNED_4)

JOKER CONSTANT X86_64_RELOC_SUBTRACTOR from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.X86_64_RELOC_SUBTRACTOR)"}
  X86_64_RELOC_SUBTRACTOR)

JOKER CONSTANT X86_64_RELOC_TLV from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.X86_64_RELOC_TLV)"}
  X86_64_RELOC_TLV)

JOKER CONSTANT X86_64_RELOC_UNSIGNED from debug/macho/reloctype.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(macho.X86_64_RELOC_UNSIGNED)"}
  X86_64_RELOC_UNSIGNED)

JOKER VARIABLE ErrNotFat from debug/macho/fat.go:
(def
  ^{:doc "ErrNotFat is returned from NewFatFile or OpenFat when the file is not a\nuniversal binary but may be a thin binary, based on its magic number.\n"
    :added "1.0"
    :tag "Var"
    :go "macho.ErrNotFat"}
  ErrNotFat)

JOKER TYPE debug/macho.Cpu from debug/macho/macho.go:
(defn ^"GoObject" Cpu.
  "Constructor for macho.Cpu"
  {:added "1.0"
   :go "_ConstructCpu(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Dylib from debug/macho/file.go:
(defn ^"GoObject" Dylib.
  "Constructor for macho.Dylib"
  {:added "1.0"
   :go "_ConstructDylib(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.DylibCmd from debug/macho/macho.go:
(defn ^"GoObject" DylibCmd.
  "Constructor for macho.DylibCmd"
  {:added "1.0"
   :go "_ConstructDylibCmd(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Dysymtab from debug/macho/file.go:
;; (defn ^"GoObject" Dysymtab.
;;   "Constructor for macho.Dysymtab"
;;   {:added "1.0"
;;    :go "_ConstructDysymtab(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.DysymtabCmd from debug/macho/macho.go:
(defn ^"GoObject" DysymtabCmd.
  "Constructor for macho.DysymtabCmd"
  {:added "1.0"
   :go "_ConstructDysymtabCmd(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.FatArch from debug/macho/fat.go:
(defn ^"GoObject" FatArch.
  "Constructor for macho.FatArch"
  {:added "1.0"
   :go "_ConstructFatArch(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.FatArchHeader from debug/macho/fat.go:
(defn ^"GoObject" FatArchHeader.
  "Constructor for macho.FatArchHeader"
  {:added "1.0"
   :go "_ConstructFatArchHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.FatFile from debug/macho/fat.go:
;; (defn ^"GoObject" FatFile.
;;   "Constructor for macho.FatFile"
;;   {:added "1.0"
;;    :go "_ConstructFatFile(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.File from debug/macho/file.go:
;; (defn ^"GoObject" File.
;;   "Constructor for macho.File"
;;   {:added "1.0"
;;    :go "_ConstructFile(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.FileHeader from debug/macho/macho.go:
(defn ^"GoObject" FileHeader.
  "Constructor for macho.FileHeader"
  {:added "1.0"
   :go "_ConstructFileHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.FormatError from debug/macho/file.go:
(defn ^"GoObject" FormatError.
  "Constructor for macho.FormatError"
  {:added "1.0"
   :go "_ConstructFormatError(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Load from debug/macho/file.go:
;; (defn ^"GoObject" Load.
;;   "Constructor for macho.Load"
;;   {:added "1.0"
;;    :go "_ConstructLoad(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.LoadBytes from debug/macho/file.go:
;; (defn ^"GoObject" LoadBytes.
;;   "Constructor for macho.LoadBytes"
;;   {:added "1.0"
;;    :go "_ConstructLoadBytes(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.LoadCmd from debug/macho/macho.go:
(defn ^"GoObject" LoadCmd.
  "Constructor for macho.LoadCmd"
  {:added "1.0"
   :go "_ConstructLoadCmd(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Nlist32 from debug/macho/macho.go:
(defn ^"GoObject" Nlist32.
  "Constructor for macho.Nlist32"
  {:added "1.0"
   :go "_ConstructNlist32(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Nlist64 from debug/macho/macho.go:
(defn ^"GoObject" Nlist64.
  "Constructor for macho.Nlist64"
  {:added "1.0"
   :go "_ConstructNlist64(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Regs386 from debug/macho/macho.go:
(defn ^"GoObject" Regs386.
  "Constructor for macho.Regs386"
  {:added "1.0"
   :go "_ConstructRegs386(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.RegsAMD64 from debug/macho/macho.go:
(defn ^"GoObject" RegsAMD64.
  "Constructor for macho.RegsAMD64"
  {:added "1.0"
   :go "_ConstructRegsAMD64(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Reloc from debug/macho/file.go:
(defn ^"GoObject" Reloc.
  "Constructor for macho.Reloc"
  {:added "1.0"
   :go "_ConstructReloc(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.RelocTypeARM from debug/macho/reloctype.go:
(defn ^"GoObject" RelocTypeARM.
  "Constructor for macho.RelocTypeARM"
  {:added "1.0"
   :go "_ConstructRelocTypeARM(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.RelocTypeARM64 from debug/macho/reloctype.go:
(defn ^"GoObject" RelocTypeARM64.
  "Constructor for macho.RelocTypeARM64"
  {:added "1.0"
   :go "_ConstructRelocTypeARM64(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.RelocTypeGeneric from debug/macho/reloctype.go:
(defn ^"GoObject" RelocTypeGeneric.
  "Constructor for macho.RelocTypeGeneric"
  {:added "1.0"
   :go "_ConstructRelocTypeGeneric(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.RelocTypeX86_64 from debug/macho/reloctype.go:
(defn ^"GoObject" RelocTypeX86_64.
  "Constructor for macho.RelocTypeX86_64"
  {:added "1.0"
   :go "_ConstructRelocTypeX86_64(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Rpath from debug/macho/file.go:
(defn ^"GoObject" Rpath.
  "Constructor for macho.Rpath"
  {:added "1.0"
   :go "_ConstructRpath(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.RpathCmd from debug/macho/macho.go:
(defn ^"GoObject" RpathCmd.
  "Constructor for macho.RpathCmd"
  {:added "1.0"
   :go "_ConstructRpathCmd(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Section from debug/macho/file.go:
;; (defn ^"GoObject" Section.
;;   "Constructor for macho.Section"
;;   {:added "1.0"
;;    :go "_ConstructSection(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.Section32 from debug/macho/macho.go:
;; (defn ^"GoObject" Section32.
;;   "Constructor for macho.Section32"
;;   {:added "1.0"
;;    :go "_ConstructSection32(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.Section64 from debug/macho/macho.go:
;; (defn ^"GoObject" Section64.
;;   "Constructor for macho.Section64"
;;   {:added "1.0"
;;    :go "_ConstructSection64(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.SectionHeader from debug/macho/file.go:
(defn ^"GoObject" SectionHeader.
  "Constructor for macho.SectionHeader"
  {:added "1.0"
   :go "_ConstructSectionHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Segment from debug/macho/file.go:
(defn ^"GoObject" Segment.
  "Constructor for macho.Segment"
  {:added "1.0"
   :go "_ConstructSegment(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Segment32 from debug/macho/macho.go:
;; (defn ^"GoObject" Segment32.
;;   "Constructor for macho.Segment32"
;;   {:added "1.0"
;;    :go "_ConstructSegment32(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.Segment64 from debug/macho/macho.go:
;; (defn ^"GoObject" Segment64.
;;   "Constructor for macho.Segment64"
;;   {:added "1.0"
;;    :go "_ConstructSegment64(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.SegmentHeader from debug/macho/file.go:
(defn ^"GoObject" SegmentHeader.
  "Constructor for macho.SegmentHeader"
  {:added "1.0"
   :go "_ConstructSegmentHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Symbol from debug/macho/file.go:
(defn ^"GoObject" Symbol.
  "Constructor for macho.Symbol"
  {:added "1.0"
   :go "_ConstructSymbol(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Symtab from debug/macho/file.go:
;; (defn ^"GoObject" Symtab.
;;   "Constructor for macho.Symtab"
;;   {:added "1.0"
;;    :go "_ConstructSymtab(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.SymtabCmd from debug/macho/macho.go:
(defn ^"GoObject" SymtabCmd.
  "Constructor for macho.SymtabCmd"
  {:added "1.0"
   :go "_ConstructSymtabCmd(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Thread from debug/macho/macho.go:
;; (defn ^"GoObject" Thread.
;;   "Constructor for macho.Thread"
;;   {:added "1.0"
;;    :go "_ConstructThread(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.Type from debug/macho/macho.go:
(defn ^"GoObject" Type.
  "Constructor for macho.Type"
  {:added "1.0"
   :go "_ConstructType(_v)"}
  [^Object _v])

JOKER FUNC debug/macho.NewFatFile from debug/macho/fat.go:
;; (defn NewFatFile
;;   "NewFatFile creates a new FatFile for accessing all the Mach-O images in a\nuniversal binary. The Mach-O binary is expected to start at position 0 in\nthe ReaderAt.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*FatFile, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r]\n\nJoker return type: [(atom-of go.std.debug.macho/FatFile) Error]"
;;   {:added "1.0"
;;    :go "__newFatFile(*__r)"}
;;   [^io/ReaderAt __r])

JOKER FUNC debug/macho.NewFile from debug/macho/file.go:
;; (defn NewFile
;;   "NewFile creates a new File for accessing a Mach-O binary in an underlying reader.\nThe Mach-O binary is expected to start at position 0 in the ReaderAt.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r]\n\nJoker return type: [(atom-of go.std.debug.macho/File) Error]"
;;   {:added "1.0"
;;    :go "__newFile(*__r)"}
;;   [^io/ReaderAt __r])

JOKER FUNC debug/macho.Open from debug/macho/file.go:
(defn Open
  "Open opens the named file using os.Open and prepares it for use as a Mach-O binary.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.debug.macho/File) Error]"
  {:added "1.0"
   :go "__open(__name)"}
  [^String __name])

JOKER FUNC debug/macho.OpenFat from debug/macho/fat.go:
(defn OpenFat
  "OpenFat opens the named file using os.Open and prepares it for use as a Mach-O\nuniversal binary.\n\nGo input arguments: (name string)\n\nGo return type: (*FatFile, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.debug.macho/FatFile) Error]"
  {:added "1.0"
   :go "__openFat(__name)"}
  [^String __name])

JOKER TYPE go.std.debug.macho/Cpu:
(def
  ^{:doc "A Cpu is a Mach-O cpu type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Cpu"}
  Cpu)

JOKER TYPE go.std.debug.macho/Dylib:
(def
  ^{:doc "A Dylib represents a Mach-O load dynamic library command.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Dylib"}
  Dylib)

JOKER TYPE go.std.debug.macho/DylibCmd:
(def
  ^{:doc "A DylibCmd is a Mach-O load dynamic library command.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DylibCmd"}
  DylibCmd)

JOKER TYPE go.std.debug.macho/Dysymtab:
(def
  ^{:doc "A Dysymtab represents a Mach-O dynamic symbol table command.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Dysymtab"}
  Dysymtab)

JOKER TYPE go.std.debug.macho/DysymtabCmd:
(def
  ^{:doc "A DysymtabCmd is a Mach-O dynamic symbol table command.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DysymtabCmd"}
  DysymtabCmd)

JOKER TYPE go.std.debug.macho/FatArch:
(def
  ^{:doc "A FatArch is a Mach-O File inside a FatFile.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FatArch"}
  FatArch)

JOKER TYPE go.std.debug.macho/FatArchHeader:
(def
  ^{:doc "A FatArchHeader represents a fat header for a specific image architecture.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FatArchHeader"}
  FatArchHeader)

JOKER TYPE go.std.debug.macho/FatFile:
(def
  ^{:doc "A FatFile is a Mach-O universal binary that contains at least one architecture.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FatFile"}
  FatFile)

JOKER TYPE go.std.debug.macho/File:
(def
  ^{:doc "A File represents an open Mach-O file.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_File"}
  File)

JOKER TYPE go.std.debug.macho/FileHeader:
(def
  ^{:doc "A FileHeader represents a Mach-O file header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FileHeader"}
  FileHeader)

JOKER TYPE go.std.debug.macho/FormatError:
(def
  ^{:doc "FormatError is returned by some operations if the data does\nnot have the correct format for an object file.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FormatError"}
  FormatError)

JOKER TYPE go.std.debug.macho/Load:
(def
  ^{:doc "A Load represents any Mach-O load command.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Load"}
  Load)

JOKER TYPE go.std.debug.macho/LoadBytes:
(def
  ^{:doc "A LoadBytes is the uninterpreted bytes of a Mach-O load command.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_LoadBytes"}
  LoadBytes)

JOKER TYPE go.std.debug.macho/LoadCmd:
(def
  ^{:doc "A LoadCmd is a Mach-O load command.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_LoadCmd"}
  LoadCmd)

JOKER TYPE go.std.debug.macho/Nlist32:
(def
  ^{:doc "An Nlist32 is a Mach-O 32-bit symbol table entry.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Nlist32"}
  Nlist32)

JOKER TYPE go.std.debug.macho/Nlist64:
(def
  ^{:doc "An Nlist64 is a Mach-O 64-bit symbol table entry.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Nlist64"}
  Nlist64)

JOKER TYPE go.std.debug.macho/Regs386:
(def
  ^{:doc "Regs386 is the Mach-O 386 register structure.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Regs386"}
  Regs386)

JOKER TYPE go.std.debug.macho/RegsAMD64:
(def
  ^{:doc "RegsAMD64 is the Mach-O AMD64 register structure.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RegsAMD64"}
  RegsAMD64)

JOKER TYPE go.std.debug.macho/Reloc:
(def
  ^{:doc "A Reloc represents a Mach-O relocation.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Reloc"}
  Reloc)

JOKER TYPE go.std.debug.macho/RelocTypeARM:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_RelocTypeARM"}
  RelocTypeARM)

JOKER TYPE go.std.debug.macho/RelocTypeARM64:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_RelocTypeARM64"}
  RelocTypeARM64)

JOKER TYPE go.std.debug.macho/RelocTypeGeneric:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_RelocTypeGeneric"}
  RelocTypeGeneric)

JOKER TYPE go.std.debug.macho/RelocTypeX86_64:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_RelocTypeX86_64"}
  RelocTypeX86_64)

JOKER TYPE go.std.debug.macho/Rpath:
(def
  ^{:doc "A Rpath represents a Mach-O rpath command.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Rpath"}
  Rpath)

JOKER TYPE go.std.debug.macho/RpathCmd:
(def
  ^{:doc "A RpathCmd is a Mach-O rpath command.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RpathCmd"}
  RpathCmd)

JOKER TYPE go.std.debug.macho/Section:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Section"}
  Section)

JOKER TYPE go.std.debug.macho/Section32:
(def
  ^{:doc "A Section32 is a 32-bit Mach-O section header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Section32"}
  Section32)

JOKER TYPE go.std.debug.macho/Section64:
(def
  ^{:doc "A Section64 is a 64-bit Mach-O section header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Section64"}
  Section64)

JOKER TYPE go.std.debug.macho/SectionHeader:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_SectionHeader"}
  SectionHeader)

JOKER TYPE go.std.debug.macho/Segment:
(def
  ^{:doc "A Segment represents a Mach-O 32-bit or 64-bit load segment command.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Segment"}
  Segment)

JOKER TYPE go.std.debug.macho/Segment32:
(def
  ^{:doc "A Segment32 is a 32-bit Mach-O segment load command.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Segment32"}
  Segment32)

JOKER TYPE go.std.debug.macho/Segment64:
(def
  ^{:doc "A Segment64 is a 64-bit Mach-O segment load command.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Segment64"}
  Segment64)

JOKER TYPE go.std.debug.macho/SegmentHeader:
(def
  ^{:doc "A SegmentHeader is the header for a Mach-O 32-bit or 64-bit load segment command.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SegmentHeader"}
  SegmentHeader)

JOKER TYPE go.std.debug.macho/Symbol:
(def
  ^{:doc "A Symbol is a Mach-O 32-bit or 64-bit symbol table entry.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Symbol"}
  Symbol)

JOKER TYPE go.std.debug.macho/Symtab:
(def
  ^{:doc "A Symtab represents a Mach-O symbol table command.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Symtab"}
  Symtab)

JOKER TYPE go.std.debug.macho/SymtabCmd:
(def
  ^{:doc "A SymtabCmd is a Mach-O symbol table command.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SymtabCmd"}
  SymtabCmd)

JOKER TYPE go.std.debug.macho/Thread:
(def
  ^{:doc "A Thread is a Mach-O thread state command.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Thread"}
  Thread)

JOKER TYPE go.std.debug.macho/Type:
(def
  ^{:doc "A Type is the Mach-O file type, e.g. an object file, executable, or dynamic library.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Type"}
  Type)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["debug/macho"]
    :doc "Provides a low-level interface to the debug/macho package.\n\nPackage macho implements access to Mach-O object files.\n"
    :empty false}
  go.std.debug.macho)
JOKER CONSTANT COFFSymbolSize from debug/pe/symbol.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.COFFSymbolSize"}
  COFFSymbolSize)

JOKER CONSTANT IMAGE_DIRECTORY_ENTRY_ARCHITECTURE from debug/pe/pe.go:
(def
  ^{:doc "IMAGE_DIRECTORY_ENTRY constants\n"
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_DIRECTORY_ENTRY_ARCHITECTURE"}
  IMAGE_DIRECTORY_ENTRY_ARCHITECTURE)

JOKER CONSTANT IMAGE_DIRECTORY_ENTRY_BASERELOC from debug/pe/pe.go:
(def
  ^{:doc "IMAGE_DIRECTORY_ENTRY constants\n"
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_DIRECTORY_ENTRY_BASERELOC"}
  IMAGE_DIRECTORY_ENTRY_BASERELOC)

JOKER CONSTANT IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT from debug/pe/pe.go:
(def
  ^{:doc "IMAGE_DIRECTORY_ENTRY constants\n"
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT"}
  IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT)

JOKER CONSTANT IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR from debug/pe/pe.go:
(def
  ^{:doc "IMAGE_DIRECTORY_ENTRY constants\n"
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR"}
  IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR)

JOKER CONSTANT IMAGE_DIRECTORY_ENTRY_DEBUG from debug/pe/pe.go:
(def
  ^{:doc "IMAGE_DIRECTORY_ENTRY constants\n"
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_DIRECTORY_ENTRY_DEBUG"}
  IMAGE_DIRECTORY_ENTRY_DEBUG)

JOKER CONSTANT IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT from debug/pe/pe.go:
(def
  ^{:doc "IMAGE_DIRECTORY_ENTRY constants\n"
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT"}
  IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT)

JOKER CONSTANT IMAGE_DIRECTORY_ENTRY_EXCEPTION from debug/pe/pe.go:
(def
  ^{:doc "IMAGE_DIRECTORY_ENTRY constants\n"
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_DIRECTORY_ENTRY_EXCEPTION"}
  IMAGE_DIRECTORY_ENTRY_EXCEPTION)

JOKER CONSTANT IMAGE_DIRECTORY_ENTRY_EXPORT from debug/pe/pe.go:
(def
  ^{:doc "IMAGE_DIRECTORY_ENTRY constants\n"
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_DIRECTORY_ENTRY_EXPORT"}
  IMAGE_DIRECTORY_ENTRY_EXPORT)

JOKER CONSTANT IMAGE_DIRECTORY_ENTRY_GLOBALPTR from debug/pe/pe.go:
(def
  ^{:doc "IMAGE_DIRECTORY_ENTRY constants\n"
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_DIRECTORY_ENTRY_GLOBALPTR"}
  IMAGE_DIRECTORY_ENTRY_GLOBALPTR)

JOKER CONSTANT IMAGE_DIRECTORY_ENTRY_IAT from debug/pe/pe.go:
(def
  ^{:doc "IMAGE_DIRECTORY_ENTRY constants\n"
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_DIRECTORY_ENTRY_IAT"}
  IMAGE_DIRECTORY_ENTRY_IAT)

JOKER CONSTANT IMAGE_DIRECTORY_ENTRY_IMPORT from debug/pe/pe.go:
(def
  ^{:doc "IMAGE_DIRECTORY_ENTRY constants\n"
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_DIRECTORY_ENTRY_IMPORT"}
  IMAGE_DIRECTORY_ENTRY_IMPORT)

JOKER CONSTANT IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG from debug/pe/pe.go:
(def
  ^{:doc "IMAGE_DIRECTORY_ENTRY constants\n"
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG"}
  IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG)

JOKER CONSTANT IMAGE_DIRECTORY_ENTRY_RESOURCE from debug/pe/pe.go:
(def
  ^{:doc "IMAGE_DIRECTORY_ENTRY constants\n"
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_DIRECTORY_ENTRY_RESOURCE"}
  IMAGE_DIRECTORY_ENTRY_RESOURCE)

JOKER CONSTANT IMAGE_DIRECTORY_ENTRY_SECURITY from debug/pe/pe.go:
(def
  ^{:doc "IMAGE_DIRECTORY_ENTRY constants\n"
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_DIRECTORY_ENTRY_SECURITY"}
  IMAGE_DIRECTORY_ENTRY_SECURITY)

JOKER CONSTANT IMAGE_DIRECTORY_ENTRY_TLS from debug/pe/pe.go:
(def
  ^{:doc "IMAGE_DIRECTORY_ENTRY constants\n"
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_DIRECTORY_ENTRY_TLS"}
  IMAGE_DIRECTORY_ENTRY_TLS)

JOKER CONSTANT IMAGE_FILE_MACHINE_AM33 from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_AM33"}
  IMAGE_FILE_MACHINE_AM33)

JOKER CONSTANT IMAGE_FILE_MACHINE_AMD64 from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_AMD64"}
  IMAGE_FILE_MACHINE_AMD64)

JOKER CONSTANT IMAGE_FILE_MACHINE_ARM from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_ARM"}
  IMAGE_FILE_MACHINE_ARM)

JOKER CONSTANT IMAGE_FILE_MACHINE_ARM64 from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_ARM64"}
  IMAGE_FILE_MACHINE_ARM64)

JOKER CONSTANT IMAGE_FILE_MACHINE_ARMNT from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_ARMNT"}
  IMAGE_FILE_MACHINE_ARMNT)

JOKER CONSTANT IMAGE_FILE_MACHINE_EBC from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_EBC"}
  IMAGE_FILE_MACHINE_EBC)

JOKER CONSTANT IMAGE_FILE_MACHINE_I386 from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_I386"}
  IMAGE_FILE_MACHINE_I386)

JOKER CONSTANT IMAGE_FILE_MACHINE_IA64 from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_IA64"}
  IMAGE_FILE_MACHINE_IA64)

JOKER CONSTANT IMAGE_FILE_MACHINE_M32R from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_M32R"}
  IMAGE_FILE_MACHINE_M32R)

JOKER CONSTANT IMAGE_FILE_MACHINE_MIPS16 from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_MIPS16"}
  IMAGE_FILE_MACHINE_MIPS16)

JOKER CONSTANT IMAGE_FILE_MACHINE_MIPSFPU from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_MIPSFPU"}
  IMAGE_FILE_MACHINE_MIPSFPU)

JOKER CONSTANT IMAGE_FILE_MACHINE_MIPSFPU16 from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_MIPSFPU16"}
  IMAGE_FILE_MACHINE_MIPSFPU16)

JOKER CONSTANT IMAGE_FILE_MACHINE_POWERPC from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_POWERPC"}
  IMAGE_FILE_MACHINE_POWERPC)

JOKER CONSTANT IMAGE_FILE_MACHINE_POWERPCFP from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_POWERPCFP"}
  IMAGE_FILE_MACHINE_POWERPCFP)

JOKER CONSTANT IMAGE_FILE_MACHINE_R4000 from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_R4000"}
  IMAGE_FILE_MACHINE_R4000)

JOKER CONSTANT IMAGE_FILE_MACHINE_SH3 from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_SH3"}
  IMAGE_FILE_MACHINE_SH3)

JOKER CONSTANT IMAGE_FILE_MACHINE_SH3DSP from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_SH3DSP"}
  IMAGE_FILE_MACHINE_SH3DSP)

JOKER CONSTANT IMAGE_FILE_MACHINE_SH4 from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_SH4"}
  IMAGE_FILE_MACHINE_SH4)

JOKER CONSTANT IMAGE_FILE_MACHINE_SH5 from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_SH5"}
  IMAGE_FILE_MACHINE_SH5)

JOKER CONSTANT IMAGE_FILE_MACHINE_THUMB from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_THUMB"}
  IMAGE_FILE_MACHINE_THUMB)

JOKER CONSTANT IMAGE_FILE_MACHINE_UNKNOWN from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_UNKNOWN"}
  IMAGE_FILE_MACHINE_UNKNOWN)

JOKER CONSTANT IMAGE_FILE_MACHINE_WCEMIPSV2 from debug/pe/pe.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "pe.IMAGE_FILE_MACHINE_WCEMIPSV2"}
  IMAGE_FILE_MACHINE_WCEMIPSV2)

JOKER TYPE debug/pe.COFFSymbol from debug/pe/symbol.go:
;; (defn ^"GoObject" COFFSymbol.
;;   "Constructor for pe.COFFSymbol"
;;   {:added "1.0"
;;    :go "_ConstructCOFFSymbol(_v)"}
;;   [^Object _v])

JOKER TYPE debug/pe.DataDirectory from debug/pe/pe.go:
(defn ^"GoObject" DataDirectory.
  "Constructor for pe.DataDirectory"
  {:added "1.0"
   :go "_ConstructDataDirectory(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.File from debug/pe/file.go:
;; (defn ^"GoObject" File.
;;   "Constructor for pe.File"
;;   {:added "1.0"
;;    :go "_ConstructFile(_v)"}
;;   [^Object _v])

JOKER TYPE debug/pe.FileHeader from debug/pe/pe.go:
(defn ^"GoObject" FileHeader.
  "Constructor for pe.FileHeader"
  {:added "1.0"
   :go "_ConstructFileHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.FormatError from debug/pe/file.go:
(defn ^"GoObject" FormatError.
  "Constructor for pe.FormatError"
  {:added "1.0"
   :go "_ConstructFormatError(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.ImportDirectory from debug/pe/file.go:
(defn ^"GoObject" ImportDirectory.
  "Constructor for pe.ImportDirectory"
  {:added "1.0"
   :go "_ConstructImportDirectory(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.OptionalHeader32 from debug/pe/pe.go:
;; (defn ^"GoObject" OptionalHeader32.
;;   "Constructor for pe.OptionalHeader32"
;;   {:added "1.0"
;;    :go "_ConstructOptionalHeader32(_v)"}
;;   [^Object _v])

JOKER TYPE debug/pe.OptionalHeader64 from debug/pe/pe.go:
;; (defn ^"GoObject" OptionalHeader64.
;;   "Constructor for pe.OptionalHeader64"
;;   {:added "1.0"
;;    :go "_ConstructOptionalHeader64(_v)"}
;;   [^Object _v])

JOKER TYPE debug/pe.Reloc from debug/pe/section.go:
(defn ^"GoObject" Reloc.
  "Constructor for pe.Reloc"
  {:added "1.0"
   :go "_ConstructReloc(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.Section from debug/pe/section.go:
;; (defn ^"GoObject" Section.
;;   "Constructor for pe.Section"
;;   {:added "1.0"
;;    :go "_ConstructSection(_v)"}
;;   [^Object _v])

JOKER TYPE debug/pe.SectionHeader from debug/pe/section.go:
(defn ^"GoObject" SectionHeader.
  "Constructor for pe.SectionHeader"
  {:added "1.0"
   :go "_ConstructSectionHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.SectionHeader32 from debug/pe/section.go:
;; (defn ^"GoObject" SectionHeader32.
;;   "Constructor for pe.SectionHeader32"
;;   {:added "1.0"
;;    :go "_ConstructSectionHeader32(_v)"}
;;   [^Object _v])

JOKER TYPE debug/pe.StringTable from debug/pe/string.go:
;; (defn ^"GoObject" StringTable.
;;   "Constructor for pe.StringTable"
;;   {:added "1.0"
;;    :go "_ConstructStringTable(_v)"}
;;   [^Object _v])

JOKER TYPE debug/pe.Symbol from debug/pe/symbol.go:
(defn ^"GoObject" Symbol.
  "Constructor for pe.Symbol"
  {:added "1.0"
   :go "_ConstructSymbol(_v)"}
  [^Object _v])

JOKER FUNC debug/pe.NewFile from debug/pe/file.go:
;; (defn NewFile
;;   "NewFile creates a new File for accessing a PE binary in an underlying reader.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r]\n\nJoker return type: [(atom-of go.std.debug.pe/File) Error]"
;;   {:added "1.0"
;;    :go "__newFile(*__r)"}
;;   [^io/ReaderAt __r])

JOKER FUNC debug/pe.Open from debug/pe/file.go:
(defn Open
  "Open opens the named file using os.Open and prepares it for use as a PE binary.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.debug.pe/File) Error]"
  {:added "1.0"
   :go "__open(__name)"}
  [^String __name])

JOKER TYPE go.std.debug.pe/COFFSymbol:
(def
  ^{:doc "COFFSymbol represents single COFF symbol table record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_COFFSymbol"}
  COFFSymbol)

JOKER TYPE go.std.debug.pe/DataDirectory:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_DataDirectory"}
  DataDirectory)

JOKER TYPE go.std.debug.pe/File:
(def
  ^{:doc "A File represents an open PE file.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_File"}
  File)

JOKER TYPE go.std.debug.pe/FileHeader:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_FileHeader"}
  FileHeader)

JOKER TYPE go.std.debug.pe/FormatError:
(def
  ^{:doc "FormatError is unused.\nThe type is retained for compatibility.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FormatError"}
  FormatError)

JOKER TYPE go.std.debug.pe/ImportDirectory:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_ImportDirectory"}
  ImportDirectory)

JOKER TYPE go.std.debug.pe/OptionalHeader32:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_OptionalHeader32"}
  OptionalHeader32)

JOKER TYPE go.std.debug.pe/OptionalHeader64:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_OptionalHeader64"}
  OptionalHeader64)

JOKER TYPE go.std.debug.pe/Reloc:
(def
  ^{:doc "Reloc represents a PE COFF relocation.\nEach section contains its own relocation list.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Reloc"}
  Reloc)

JOKER TYPE go.std.debug.pe/Section:
(def
  ^{:doc "Section provides access to PE COFF section.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Section"}
  Section)

JOKER TYPE go.std.debug.pe/SectionHeader:
(def
  ^{:doc "SectionHeader is similar to SectionHeader32 with Name\nfield replaced by Go string.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SectionHeader"}
  SectionHeader)

JOKER TYPE go.std.debug.pe/SectionHeader32:
(def
  ^{:doc "SectionHeader32 represents real PE COFF section header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SectionHeader32"}
  SectionHeader32)

JOKER TYPE go.std.debug.pe/StringTable:
(def
  ^{:doc "StringTable is a COFF string table.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_StringTable"}
  StringTable)

JOKER TYPE go.std.debug.pe/Symbol:
(def
  ^{:doc "Symbol is similar to COFFSymbol with Name field replaced\nby Go string. Symbol also does not have NumberOfAuxSymbols.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Symbol"}
  Symbol)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["debug/pe"]
    :doc "Provides a low-level interface to the debug/pe package.\n\nPackage pe implements access to PE (Microsoft Windows Portable Executable) files.\n"
    :empty false}
  go.std.debug.pe)
JOKER CONSTANT Magic386 from debug/plan9obj/plan9obj.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "plan9obj.Magic386"}
  Magic386)

JOKER CONSTANT Magic64 from debug/plan9obj/plan9obj.go:
(def
  ^{:doc "64-bit expanded header\n"
    :added "1.0"
    :tag "Int"
    :go "plan9obj.Magic64"}
  Magic64)

JOKER CONSTANT MagicAMD64 from debug/plan9obj/plan9obj.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "plan9obj.MagicAMD64"}
  MagicAMD64)

JOKER CONSTANT MagicARM from debug/plan9obj/plan9obj.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "plan9obj.MagicARM"}
  MagicARM)

JOKER TYPE debug/plan9obj.File from debug/plan9obj/file.go:
;; (defn ^"GoObject" File.
;;   "Constructor for plan9obj.File"
;;   {:added "1.0"
;;    :go "_ConstructFile(_v)"}
;;   [^Object _v])

JOKER TYPE debug/plan9obj.FileHeader from debug/plan9obj/file.go:
(defn ^"GoObject" FileHeader.
  "Constructor for plan9obj.FileHeader"
  {:added "1.0"
   :go "_ConstructFileHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/plan9obj.Section from debug/plan9obj/file.go:
(defn ^"GoObject" Section.
  "Constructor for plan9obj.Section"
  {:added "1.0"
   :go "_ConstructSection(_v)"}
  [^Object _v])

JOKER TYPE debug/plan9obj.SectionHeader from debug/plan9obj/file.go:
(defn ^"GoObject" SectionHeader.
  "Constructor for plan9obj.SectionHeader"
  {:added "1.0"
   :go "_ConstructSectionHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/plan9obj.Sym from debug/plan9obj/file.go:
(defn ^"GoObject" Sym.
  "Constructor for plan9obj.Sym"
  {:added "1.0"
   :go "_ConstructSym(_v)"}
  [^Object _v])

JOKER FUNC debug/plan9obj.NewFile from debug/plan9obj/file.go:
;; (defn NewFile
;;   "NewFile creates a new File for accessing a Plan 9 binary in an underlying reader.\nThe Plan 9 binary is expected to start at position 0 in the ReaderAt.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r]\n\nJoker return type: [(atom-of go.std.debug.plan9obj/File) Error]"
;;   {:added "1.0"
;;    :go "__newFile(*__r)"}
;;   [^io/ReaderAt __r])

JOKER FUNC debug/plan9obj.Open from debug/plan9obj/file.go:
(defn Open
  "Open opens the named file using os.Open and prepares it for use as a Plan 9 a.out binary.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.debug.plan9obj/File) Error]"
  {:added "1.0"
   :go "__open(__name)"}
  [^String __name])

JOKER TYPE go.std.debug.plan9obj/File:
(def
  ^{:doc "A File represents an open Plan 9 a.out file.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_File"}
  File)

JOKER TYPE go.std.debug.plan9obj/FileHeader:
(def
  ^{:doc "A FileHeader represents a Plan 9 a.out file header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FileHeader"}
  FileHeader)

JOKER TYPE go.std.debug.plan9obj/Section:
(def
  ^{:doc "A Section represents a single section in a Plan 9 a.out file.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Section"}
  Section)

JOKER TYPE go.std.debug.plan9obj/SectionHeader:
(def
  ^{:doc "A SectionHeader represents a single Plan 9 a.out section header.\nThis structure doesn't exist on-disk, but eases navigation\nthrough the object file.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SectionHeader"}
  SectionHeader)

JOKER TYPE go.std.debug.plan9obj/Sym:
(def
  ^{:doc "A Symbol represents an entry in a Plan 9 a.out symbol table section.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Sym"}
  Sym)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["debug/plan9obj"]
    :doc "Provides a low-level interface to the debug/plan9obj package.\n\nPackage plan9obj implements access to Plan 9 a.out object files.\n"
    :empty false}
  go.std.debug.plan9obj)
JOKER TYPE go.std.encoding/BinaryMarshaler:
(def
  ^{:doc "BinaryMarshaler is the interface implemented by an object that can\nmarshal itself into a binary form.\n\nMarshalBinary encodes the receiver into a binary form and returns the result.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BinaryMarshaler"}
  BinaryMarshaler)

JOKER TYPE go.std.encoding/BinaryUnmarshaler:
(def
  ^{:doc "BinaryUnmarshaler is the interface implemented by an object that can\nunmarshal a binary representation of itself.\n\nUnmarshalBinary must be able to decode the form generated by MarshalBinary.\nUnmarshalBinary must copy the data if it wishes to retain the data\nafter returning.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BinaryUnmarshaler"}
  BinaryUnmarshaler)

JOKER TYPE go.std.encoding/TextMarshaler:
(def
  ^{:doc "TextMarshaler is the interface implemented by an object that can\nmarshal itself into a textual form.\n\nMarshalText encodes the receiver into UTF-8-encoded text and returns the result.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TextMarshaler"}
  TextMarshaler)

JOKER TYPE go.std.encoding/TextUnmarshaler:
(def
  ^{:doc "TextUnmarshaler is the interface implemented by an object that can\nunmarshal a textual representation of itself.\n\nUnmarshalText must be able to decode the form generated by MarshalText.\nUnmarshalText must copy the text if it wishes to retain the text\nafter returning.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TextUnmarshaler"}
  TextUnmarshaler)

JOKER TYPE encoding/ascii85.CorruptInputError from encoding/ascii85/ascii85.go:
(defn ^"GoObject" CorruptInputError.
  "Constructor for ascii85.CorruptInputError"
  {:added "1.0"
   :go "_ConstructCorruptInputError(_v)"}
  [^Object _v])

JOKER FUNC encoding/ascii85.Decode from encoding/ascii85/ascii85.go:
;; (defn Decode
;;   "Decode decodes src into dst, returning both the number\nof bytes written to dst and the number consumed from src.\nIf src contains invalid ascii85 data, Decode will return the\nnumber of bytes successfully written and a CorruptInputError.\nDecode ignores space and control characters in src.\nOften, ascii85-encoded data is wrapped in <~ and ~> symbols.\nDecode expects these to have been stripped by the caller.\n\nIf flush is true, Decode assumes that src represents the\nend of the input stream and processes it completely rather\nthan wait for the completion of another 32-bit block.\n\nNewDecoder wraps an io.Reader interface around Decode.\n\nGo input arguments: (dst []byte, src []byte, flush bool)\n\nGo return type: (ndst int, nsrc int, err error)\n\nJoker input arguments: [^(vector-of Int) dst, ^(vector-of Int) src, ^Boolean flush]\n\nJoker return type: [Int Int Error]"
;;   {:added "1.0"
;;    :go "__decode(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__dst)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__src)), __flush)"}
;;   [^Object __dst, ^Object __src, ^Boolean __flush])

JOKER FUNC encoding/ascii85.Encode from encoding/ascii85/ascii85.go:
;; (defn ^"Int" Encode
;;   "Encode encodes src into at most MaxEncodedLen(len(src))\nbytes of dst, returning the actual number of bytes written.\n\nThe encoding handles 4-byte chunks, using a special encoding\nfor the last fragment, so Encode is not appropriate for use on\nindividual blocks of a large data stream. Use NewEncoder() instead.\n\nOften, ascii85-encoded data is wrapped in <~ and ~> symbols.\nEncode does not add these.\n\nGo input arguments: (dst []byte, src []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) dst, ^(vector-of Int) src]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "ascii85.Encode(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__dst)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__src)))"}
;;   [^Object __dst, ^Object __src])

JOKER FUNC encoding/ascii85.MaxEncodedLen from encoding/ascii85/ascii85.go:
(defn ^"Int" MaxEncodedLen
  "MaxEncodedLen returns the maximum length of an encoding of n source bytes.\n\nGo input arguments: (n int)\n\nGo return type: int\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "ascii85.MaxEncodedLen(__n)"}
  [^Int __n])

JOKER FUNC encoding/ascii85.NewDecoder from encoding/ascii85/ascii85.go:
;; (defn NewDecoder
;;   "NewDecoder constructs a new ascii85 stream decoder.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__newDecoder(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC encoding/ascii85.NewEncoder from encoding/ascii85/ascii85.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new ascii85 stream encoder. Data written to\nthe returned writer will be encoded and then written to w.\nAscii85 encodings operate in 32-bit blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\ntrailing partial block.\n\nGo input arguments: (w io.Writer)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "__newEncoder(*__w)"}
;;   [^io/Writer __w])

JOKER TYPE go.std.encoding.ascii85/CorruptInputError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_CorruptInputError"}
  CorruptInputError)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["encoding/ascii85"]
    :doc "Provides a low-level interface to the encoding/ascii85 package.\n\nPackage ascii85 implements the ascii85 data encoding\nas used in the btoa tool and Adobe's PostScript and PDF document formats.\n"
    :empty false}
  go.std.encoding.ascii85)
JOKER CONSTANT ClassApplication from encoding/asn1/common.go:
(def
  ^{:doc "ASN.1 class types represent the namespace of the tag.\n"
    :added "1.0"
    :tag "Int"
    :go "asn1.ClassApplication"}
  ClassApplication)

JOKER CONSTANT ClassContextSpecific from encoding/asn1/common.go:
(def
  ^{:doc "ASN.1 class types represent the namespace of the tag.\n"
    :added "1.0"
    :tag "Int"
    :go "asn1.ClassContextSpecific"}
  ClassContextSpecific)

JOKER CONSTANT ClassPrivate from encoding/asn1/common.go:
(def
  ^{:doc "ASN.1 class types represent the namespace of the tag.\n"
    :added "1.0"
    :tag "Int"
    :go "asn1.ClassPrivate"}
  ClassPrivate)

JOKER CONSTANT ClassUniversal from encoding/asn1/common.go:
(def
  ^{:doc "ASN.1 class types represent the namespace of the tag.\n"
    :added "1.0"
    :tag "Int"
    :go "asn1.ClassUniversal"}
  ClassUniversal)

JOKER CONSTANT TagBitString from encoding/asn1/common.go:
(def
  ^{:doc "ASN.1 tags represent the type of the following object.\n"
    :added "1.0"
    :tag "Int"
    :go "asn1.TagBitString"}
  TagBitString)

JOKER CONSTANT TagBoolean from encoding/asn1/common.go:
(def
  ^{:doc "ASN.1 tags represent the type of the following object.\n"
    :added "1.0"
    :tag "Int"
    :go "asn1.TagBoolean"}
  TagBoolean)

JOKER CONSTANT TagEnum from encoding/asn1/common.go:
(def
  ^{:doc "ASN.1 tags represent the type of the following object.\n"
    :added "1.0"
    :tag "Int"
    :go "asn1.TagEnum"}
  TagEnum)

JOKER CONSTANT TagGeneralString from encoding/asn1/common.go:
(def
  ^{:doc "ASN.1 tags represent the type of the following object.\n"
    :added "1.0"
    :tag "Int"
    :go "asn1.TagGeneralString"}
  TagGeneralString)

JOKER CONSTANT TagGeneralizedTime from encoding/asn1/common.go:
(def
  ^{:doc "ASN.1 tags represent the type of the following object.\n"
    :added "1.0"
    :tag "Int"
    :go "asn1.TagGeneralizedTime"}
  TagGeneralizedTime)

JOKER CONSTANT TagIA5String from encoding/asn1/common.go:
(def
  ^{:doc "ASN.1 tags represent the type of the following object.\n"
    :added "1.0"
    :tag "Int"
    :go "asn1.TagIA5String"}
  TagIA5String)

JOKER CONSTANT TagInteger from encoding/asn1/common.go:
(def
  ^{:doc "ASN.1 tags represent the type of the following object.\n"
    :added "1.0"
    :tag "Int"
    :go "asn1.TagInteger"}
  TagInteger)

JOKER CONSTANT TagNull from encoding/asn1/common.go:
(def
  ^{:doc "ASN.1 tags represent the type of the following object.\n"
    :added "1.0"
    :tag "Int"
    :go "asn1.TagNull"}
  TagNull)

JOKER CONSTANT TagNumericString from encoding/asn1/common.go:
(def
  ^{:doc "ASN.1 tags represent the type of the following object.\n"
    :added "1.0"
    :tag "Int"
    :go "asn1.TagNumericString"}
  TagNumericString)

JOKER CONSTANT TagOID from encoding/asn1/common.go:
(def
  ^{:doc "ASN.1 tags represent the type of the following object.\n"
    :added "1.0"
    :tag "Int"
    :go "asn1.TagOID"}
  TagOID)

JOKER CONSTANT TagOctetString from encoding/asn1/common.go:
(def
  ^{:doc "ASN.1 tags represent the type of the following object.\n"
    :added "1.0"
    :tag "Int"
    :go "asn1.TagOctetString"}
  TagOctetString)

JOKER CONSTANT TagPrintableString from encoding/asn1/common.go:
(def
  ^{:doc "ASN.1 tags represent the type of the following object.\n"
    :added "1.0"
    :tag "Int"
    :go "asn1.TagPrintableString"}
  TagPrintableString)

JOKER CONSTANT TagSequence from encoding/asn1/common.go:
(def
  ^{:doc "ASN.1 tags represent the type of the following object.\n"
    :added "1.0"
    :tag "Int"
    :go "asn1.TagSequence"}
  TagSequence)

JOKER CONSTANT TagSet from encoding/asn1/common.go:
(def
  ^{:doc "ASN.1 tags represent the type of the following object.\n"
    :added "1.0"
    :tag "Int"
    :go "asn1.TagSet"}
  TagSet)

JOKER CONSTANT TagT61String from encoding/asn1/common.go:
(def
  ^{:doc "ASN.1 tags represent the type of the following object.\n"
    :added "1.0"
    :tag "Int"
    :go "asn1.TagT61String"}
  TagT61String)

JOKER CONSTANT TagUTCTime from encoding/asn1/common.go:
(def
  ^{:doc "ASN.1 tags represent the type of the following object.\n"
    :added "1.0"
    :tag "Int"
    :go "asn1.TagUTCTime"}
  TagUTCTime)

JOKER CONSTANT TagUTF8String from encoding/asn1/common.go:
(def
  ^{:doc "ASN.1 tags represent the type of the following object.\n"
    :added "1.0"
    :tag "Int"
    :go "asn1.TagUTF8String"}
  TagUTF8String)

JOKER VARIABLE NullBytes from encoding/asn1/asn1.go:
(def
  ^{:doc "NullBytes contains bytes representing the DER-encoded ASN.1 NULL type.\n"
    :added "1.0"
    :tag "Var"
    :go "asn1.NullBytes"}
  NullBytes)

JOKER VARIABLE NullRawValue from encoding/asn1/asn1.go:
(def
  ^{:doc "NullRawValue is a RawValue with its Tag set to the ASN.1 NULL type tag (5).\n"
    :added "1.0"
    :tag "Var"
    :go "asn1.NullRawValue"}
  NullRawValue)

JOKER TYPE encoding/asn1.BitString from encoding/asn1/asn1.go:
;; (defn ^"GoObject" BitString.
;;   "Constructor for asn1.BitString"
;;   {:added "1.0"
;;    :go "_ConstructBitString(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/asn1.Enumerated from encoding/asn1/asn1.go:
(defn ^"GoObject" Enumerated.
  "Constructor for asn1.Enumerated"
  {:added "1.0"
   :go "_ConstructEnumerated(_v)"}
  [^Object _v])

JOKER TYPE encoding/asn1.Flag from encoding/asn1/asn1.go:
(defn ^"GoObject" Flag.
  "Constructor for asn1.Flag"
  {:added "1.0"
   :go "_ConstructFlag(_v)"}
  [^Object _v])

JOKER TYPE encoding/asn1.ObjectIdentifier from encoding/asn1/asn1.go:
;; (defn ^"GoObject" ObjectIdentifier.
;;   "Constructor for asn1.ObjectIdentifier"
;;   {:added "1.0"
;;    :go "_ConstructObjectIdentifier(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/asn1.RawContent from encoding/asn1/asn1.go:
;; (defn ^"GoObject" RawContent.
;;   "Constructor for asn1.RawContent"
;;   {:added "1.0"
;;    :go "_ConstructRawContent(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/asn1.RawValue from encoding/asn1/asn1.go:
;; (defn ^"GoObject" RawValue.
;;   "Constructor for asn1.RawValue"
;;   {:added "1.0"
;;    :go "_ConstructRawValue(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/asn1.StructuralError from encoding/asn1/asn1.go:
(defn ^"GoObject" StructuralError.
  "Constructor for asn1.StructuralError"
  {:added "1.0"
   :go "_ConstructStructuralError(_v)"}
  [^Object _v])

JOKER TYPE encoding/asn1.SyntaxError from encoding/asn1/asn1.go:
(defn ^"GoObject" SyntaxError.
  "Constructor for asn1.SyntaxError"
  {:added "1.0"
   :go "_ConstructSyntaxError(_v)"}
  [^Object _v])

JOKER FUNC encoding/asn1.Marshal from encoding/asn1/marshal.go:
;; (defn Marshal
;;   "Marshal returns the ASN.1 encoding of val.\n\nIn addition to the struct tags recognised by Unmarshal, the following can be\nused:\n\n\tia5:         causes strings to be marshaled as ASN.1, IA5String values\n\tomitempty:   causes empty slices to be skipped\n\tprintable:   causes strings to be marshaled as ASN.1, PrintableString values\n\tutf8:        causes strings to be marshaled as ASN.1, UTF8String values\n\tutc:         causes time.Time to be marshaled as ASN.1, UTCTime values\n\tgeneralized: causes time.Time to be marshaled as ASN.1, GeneralizedTime values\n\nGo input arguments: (val interface {})\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> val]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshal(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> __val])

JOKER FUNC encoding/asn1.MarshalWithParams from encoding/asn1/marshal.go:
;; (defn MarshalWithParams
;;   "MarshalWithParams allows field parameters to be specified for the\ntop-level element. The form of the params is the same as the field tags.\n\nGo input arguments: (val interface {}, params string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> val, ^String params]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshalWithParams(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), __params)"}
;;   [^<protocol-or-something> __val, ^String __params])

JOKER FUNC encoding/asn1.Unmarshal from encoding/asn1/asn1.go:
;; (defn Unmarshal
;;   "Unmarshal parses the DER-encoded ASN.1 data structure b\nand uses the reflect package to fill in an arbitrary value pointed at by val.\nBecause Unmarshal uses the reflect package, the structs\nbeing written to must use upper case field names.\n\nAn ASN.1 INTEGER can be written to an int, int32, int64,\nor *big.Int (from the math/big package).\nIf the encoded value does not fit in the Go type,\nUnmarshal returns a parse error.\n\nAn ASN.1 BIT STRING can be written to a BitString.\n\nAn ASN.1 OCTET STRING can be written to a []byte.\n\nAn ASN.1 OBJECT IDENTIFIER can be written to an\nObjectIdentifier.\n\nAn ASN.1 ENUMERATED can be written to an Enumerated.\n\nAn ASN.1 UTCTIME or GENERALIZEDTIME can be written to a time.Time.\n\nAn ASN.1 PrintableString, IA5String, or NumericString can be written to a string.\n\nAny of the above ASN.1 values can be written to an interface{}.\nThe value stored in the interface has the corresponding Go type.\nFor integers, that type is int64.\n\nAn ASN.1 SEQUENCE OF x or SET OF x can be written\nto a slice if an x can be written to the slice's element type.\n\nAn ASN.1 SEQUENCE or SET can be written to a struct\nif each of the elements in the sequence can be\nwritten to the corresponding element in the struct.\n\nThe following tags on struct fields have special meaning to Unmarshal:\n\n\tapplication specifies that an APPLICATION tag is used\n\tprivate     specifies that a PRIVATE tag is used\n\tdefault:x   sets the default value for optional integer fields (only used if optional is also present)\n\texplicit    specifies that an additional, explicit tag wraps the implicit one\n\toptional    marks the field as ASN.1 OPTIONAL\n\tset         causes a SET, rather than a SEQUENCE type to be expected\n\ttag:x       specifies the ASN.1 tag number; implies ASN.1 CONTEXT SPECIFIC\n\nIf the type of the first field of a structure is RawContent then the raw\nASN1 contents of the struct will be stored in it.\n\nIf the type name of a slice element ends with \"SET\" then it's treated as if\nthe \"set\" tag was set on it. This can be used with nested slices where a\nstruct tag cannot be given.\n\nOther ASN.1 types are not supported; if it encounters them,\nUnmarshal returns a parse error.\n\nGo input arguments: (b []byte, val interface {})\n\nGo return type: (rest []byte, err error)\n\nJoker input arguments: [^(vector-of Int) b, ^<protocol-or-something> val]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__unmarshal(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^Object __b, ^<protocol-or-something> __val])

JOKER FUNC encoding/asn1.UnmarshalWithParams from encoding/asn1/asn1.go:
;; (defn UnmarshalWithParams
;;   "UnmarshalWithParams allows field parameters to be specified for the\ntop-level element. The form of the params is the same as the field tags.\n\nGo input arguments: (b []byte, val interface {}, params string)\n\nGo return type: (rest []byte, err error)\n\nJoker input arguments: [^(vector-of Int) b, ^<protocol-or-something> val, ^String params]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__unmarshalWithParams(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), __params)"}
;;   [^Object __b, ^<protocol-or-something> __val, ^String __params])

JOKER TYPE go.std.encoding.asn1/BitString:
(def
  ^{:doc "BitString is the structure to use when you want an ASN.1 BIT STRING type. A\nbit string is padded up to the nearest byte in memory and the number of\nvalid bits is recorded. Padding bits will be zero.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BitString"}
  BitString)

JOKER TYPE go.std.encoding.asn1/Enumerated:
(def
  ^{:doc "An Enumerated is represented as a plain int.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Enumerated"}
  Enumerated)

JOKER TYPE go.std.encoding.asn1/Flag:
(def
  ^{:doc "A Flag accepts any data and is set to true if present.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Flag"}
  Flag)

JOKER TYPE go.std.encoding.asn1/ObjectIdentifier:
(def
  ^{:doc "An ObjectIdentifier represents an ASN.1 OBJECT IDENTIFIER.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ObjectIdentifier"}
  ObjectIdentifier)

JOKER TYPE go.std.encoding.asn1/RawContent:
(def
  ^{:doc "RawContent is used to signal that the undecoded, DER data needs to be\npreserved for a struct. To use it, the first field of the struct must have\nthis type. It's an error for any of the other fields to have this type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RawContent"}
  RawContent)

JOKER TYPE go.std.encoding.asn1/RawValue:
(def
  ^{:doc "A RawValue represents an undecoded ASN.1 object.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RawValue"}
  RawValue)

JOKER TYPE go.std.encoding.asn1/StructuralError:
(def
  ^{:doc "A StructuralError suggests that the ASN.1 data is valid, but the Go type\nwhich is receiving it doesn't match.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_StructuralError"}
  StructuralError)

JOKER TYPE go.std.encoding.asn1/SyntaxError:
(def
  ^{:doc "A SyntaxError suggests that the ASN.1 data is invalid.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SyntaxError"}
  SyntaxError)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["encoding/asn1"]
    :doc "Provides a low-level interface to the encoding/asn1 package.\n\nPackage asn1 implements parsing of DER-encoded ASN.1 data structures,\nas defined in ITU-T Rec X.690.\n\nSee also ``A Layman's Guide to a Subset of ASN.1, BER, and DER,''\nhttp://luca.ntop.org/Teaching/Appunti/asn1.html.\n"
    :empty false}
  go.std.encoding.asn1)
JOKER CONSTANT NoPadding from encoding/base32/base32.go:
(def
  ^{:doc "No padding\n"
    :added "1.0"
    :tag "Char"
    :go "base32.NoPadding"}
  NoPadding)

JOKER CONSTANT StdPadding from encoding/base32/base32.go:
(def
  ^{:doc "Standard padding character\n"
    :added "1.0"
    :tag "Char"
    :go "base32.StdPadding"}
  StdPadding)

JOKER VARIABLE HexEncoding from encoding/base32/base32.go:
(def
  ^{:doc "HexEncoding is the ``Extended Hex Alphabet'' defined in RFC 4648.\nIt is typically used in DNS.\n"
    :added "1.0"
    :tag "Var"
    :go "base32.HexEncoding"}
  HexEncoding)

JOKER VARIABLE StdEncoding from encoding/base32/base32.go:
(def
  ^{:doc "StdEncoding is the standard base32 encoding, as defined in\nRFC 4648.\n"
    :added "1.0"
    :tag "Var"
    :go "base32.StdEncoding"}
  StdEncoding)

JOKER TYPE encoding/base32.CorruptInputError from encoding/base32/base32.go:
(defn ^"GoObject" CorruptInputError.
  "Constructor for base32.CorruptInputError"
  {:added "1.0"
   :go "_ConstructCorruptInputError(_v)"}
  [^Object _v])

JOKER TYPE encoding/base32.Encoding from encoding/base32/base32.go:
(defn ^"GoObject" Encoding.
  "Constructor for base32.Encoding"
  {:added "1.0"
   :go "_ConstructEncoding(_v)"}
  [^Object _v])

JOKER FUNC encoding/base32.NewDecoder from encoding/base32/base32.go:
;; (defn NewDecoder
;;   "NewDecoder constructs a new base32 stream decoder.\n\nGo input arguments: (enc *Encoding, r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^(atom-of go.std.encoding.base32/Encoding) enc, ^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__newDecoder(__enc, *__r)"}
;;   [^base32/Encoding __enc, ^io/Reader __r])

JOKER FUNC encoding/base32.NewEncoder from encoding/base32/base32.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new base32 stream encoder. Data written to\nthe returned writer will be encoded using enc and then written to w.\nBase32 encodings operate in 5-byte blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\npartially written blocks.\n\nGo input arguments: (enc *Encoding, w io.Writer)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^(atom-of go.std.encoding.base32/Encoding) enc, ^go.std.io/Writer w]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "__newEncoder(__enc, *__w)"}
;;   [^base32/Encoding __enc, ^io/Writer __w])

JOKER FUNC encoding/base32.NewEncoding from encoding/base32/base32.go:
(defn NewEncoding
  "NewEncoding returns a new Encoding defined by the given alphabet,\nwhich must be a 32-byte string.\n\nGo input arguments: (encoder string)\n\nGo return type: *Encoding\n\nJoker input arguments: [^String encoder]\n\nJoker return type: (atom-of go.std.encoding.base32/Encoding)"
  {:added "1.0"
   :go "__newEncoding(__encoder)"}
  [^String __encoder])

JOKER TYPE go.std.encoding.base32/CorruptInputError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_CorruptInputError"}
  CorruptInputError)

JOKER TYPE go.std.encoding.base32/Encoding:
(def
  ^{:doc "An Encoding is a radix 32 encoding/decoding scheme, defined by a\n32-character alphabet. The most common is the \"base32\" encoding\nintroduced for SASL GSSAPI and standardized in RFC 4648.\nThe alternate \"base32hex\" encoding is used in DNSSEC.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Encoding"}
  Encoding)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["encoding/base32"]
    :doc "Provides a low-level interface to the encoding/base32 package.\n\nPackage base32 implements base32 encoding as specified by RFC 4648.\n"
    :empty false}
  go.std.encoding.base32)
JOKER CONSTANT NoPadding from encoding/base64/base64.go:
(def
  ^{:doc "No padding\n"
    :added "1.0"
    :tag "Char"
    :go "base64.NoPadding"}
  NoPadding)

JOKER CONSTANT StdPadding from encoding/base64/base64.go:
(def
  ^{:doc "Standard padding character\n"
    :added "1.0"
    :tag "Char"
    :go "base64.StdPadding"}
  StdPadding)

JOKER VARIABLE RawStdEncoding from encoding/base64/base64.go:
(def
  ^{:doc "RawStdEncoding is the standard raw, unpadded base64 encoding,\nas defined in RFC 4648 section 3.2.\nThis is the same as StdEncoding but omits padding characters.\n"
    :added "1.0"
    :tag "Var"
    :go "base64.RawStdEncoding"}
  RawStdEncoding)

JOKER VARIABLE RawURLEncoding from encoding/base64/base64.go:
(def
  ^{:doc "RawURLEncoding is the unpadded alternate base64 encoding defined in RFC 4648.\nIt is typically used in URLs and file names.\nThis is the same as URLEncoding but omits padding characters.\n"
    :added "1.0"
    :tag "Var"
    :go "base64.RawURLEncoding"}
  RawURLEncoding)

JOKER VARIABLE StdEncoding from encoding/base64/base64.go:
(def
  ^{:doc "StdEncoding is the standard base64 encoding, as defined in\nRFC 4648.\n"
    :added "1.0"
    :tag "Var"
    :go "base64.StdEncoding"}
  StdEncoding)

JOKER VARIABLE URLEncoding from encoding/base64/base64.go:
(def
  ^{:doc "URLEncoding is the alternate base64 encoding defined in RFC 4648.\nIt is typically used in URLs and file names.\n"
    :added "1.0"
    :tag "Var"
    :go "base64.URLEncoding"}
  URLEncoding)

JOKER TYPE encoding/base64.CorruptInputError from encoding/base64/base64.go:
(defn ^"GoObject" CorruptInputError.
  "Constructor for base64.CorruptInputError"
  {:added "1.0"
   :go "_ConstructCorruptInputError(_v)"}
  [^Object _v])

JOKER TYPE encoding/base64.Encoding from encoding/base64/base64.go:
(defn ^"GoObject" Encoding.
  "Constructor for base64.Encoding"
  {:added "1.0"
   :go "_ConstructEncoding(_v)"}
  [^Object _v])

JOKER FUNC encoding/base64.NewDecoder from encoding/base64/base64.go:
;; (defn NewDecoder
;;   "NewDecoder constructs a new base64 stream decoder.\n\nGo input arguments: (enc *Encoding, r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^(atom-of go.std.encoding.base64/Encoding) enc, ^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__newDecoder(__enc, *__r)"}
;;   [^base64/Encoding __enc, ^io/Reader __r])

JOKER FUNC encoding/base64.NewEncoder from encoding/base64/base64.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new base64 stream encoder. Data written to\nthe returned writer will be encoded using enc and then written to w.\nBase64 encodings operate in 4-byte blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\npartially written blocks.\n\nGo input arguments: (enc *Encoding, w io.Writer)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^(atom-of go.std.encoding.base64/Encoding) enc, ^go.std.io/Writer w]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "__newEncoder(__enc, *__w)"}
;;   [^base64/Encoding __enc, ^io/Writer __w])

JOKER FUNC encoding/base64.NewEncoding from encoding/base64/base64.go:
(defn NewEncoding
  "NewEncoding returns a new padded Encoding defined by the given alphabet,\nwhich must be a 64-byte string that does not contain the padding character\nor CR / LF ('\\r', '\\n').\nThe resulting Encoding uses the default padding character ('='),\nwhich may be changed or disabled via WithPadding.\n\nGo input arguments: (encoder string)\n\nGo return type: *Encoding\n\nJoker input arguments: [^String encoder]\n\nJoker return type: (atom-of go.std.encoding.base64/Encoding)"
  {:added "1.0"
   :go "__newEncoding(__encoder)"}
  [^String __encoder])

JOKER TYPE go.std.encoding.base64/CorruptInputError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_CorruptInputError"}
  CorruptInputError)

JOKER TYPE go.std.encoding.base64/Encoding:
(def
  ^{:doc "An Encoding is a radix 64 encoding/decoding scheme, defined by a\n64-character alphabet. The most common encoding is the \"base64\"\nencoding defined in RFC 4648 and used in MIME (RFC 2045) and PEM\n(RFC 1421).  RFC 4648 also defines an alternate encoding, which is\nthe standard encoding with - and _ substituted for + and /.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Encoding"}
  Encoding)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["encoding/base64"]
    :doc "Provides a low-level interface to the encoding/base64 package.\n\nPackage base64 implements base64 encoding as specified by RFC 4648.\n"
    :empty false}
  go.std.encoding.base64)
JOKER CONSTANT MaxVarintLen16 from encoding/binary/varint.go:
(def
  ^{:doc "MaxVarintLenN is the maximum length of a varint-encoded N-bit integer.\n"
    :added "1.0"
    :tag "Int"
    :go "binary.MaxVarintLen16"}
  MaxVarintLen16)

JOKER CONSTANT MaxVarintLen32 from encoding/binary/varint.go:
(def
  ^{:doc "MaxVarintLenN is the maximum length of a varint-encoded N-bit integer.\n"
    :added "1.0"
    :tag "Int"
    :go "binary.MaxVarintLen32"}
  MaxVarintLen32)

JOKER CONSTANT MaxVarintLen64 from encoding/binary/varint.go:
(def
  ^{:doc "MaxVarintLenN is the maximum length of a varint-encoded N-bit integer.\n"
    :added "1.0"
    :tag "Int"
    :go "binary.MaxVarintLen64"}
  MaxVarintLen64)

JOKER VARIABLE BigEndian from encoding/binary/binary.go:
(def
  ^{:doc "BigEndian is the big-endian implementation of ByteOrder.\n"
    :added "1.0"
    :tag "Var"
    :go "binary.BigEndian"}
  BigEndian)

JOKER VARIABLE LittleEndian from encoding/binary/binary.go:
(def
  ^{:doc "LittleEndian is the little-endian implementation of ByteOrder.\n"
    :added "1.0"
    :tag "Var"
    :go "binary.LittleEndian"}
  LittleEndian)

JOKER TYPE encoding/binary.ByteOrder from encoding/binary/binary.go:
;; (defn ^"GoObject" ByteOrder.
;;   "Constructor for binary.ByteOrder"
;;   {:added "1.0"
;;    :go "_ConstructByteOrder(_v)"}
;;   [^Object _v])

JOKER FUNC encoding/binary.PutUvarint from encoding/binary/varint.go:
;; (defn ^"Int" PutUvarint
;;   "PutUvarint encodes a uint64 into buf and returns the number of bytes written.\nIf the buffer is too small, PutUvarint will panic.\n\nGo input arguments: (buf []byte, x uint64)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) buf, ^Number x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "binary.PutUvarint(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__buf)), __x)"}
;;   [^Object __buf, ^UInt64 __x])

JOKER FUNC encoding/binary.PutVarint from encoding/binary/varint.go:
;; (defn ^"Int" PutVarint
;;   "PutVarint encodes an int64 into buf and returns the number of bytes written.\nIf the buffer is too small, PutVarint will panic.\n\nGo input arguments: (buf []byte, x int64)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) buf, ^Number x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "binary.PutVarint(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__buf)), __x)"}
;;   [^Object __buf, ^Int64 __x])

JOKER FUNC encoding/binary.Read from encoding/binary/binary.go:
;; (defn ^"Error" Read
;;   "Read reads structured binary data from r into data.\nData must be a pointer to a fixed-size value or a slice\nof fixed-size values.\nBytes read from r are decoded using the specified byte order\nand written to successive fields of the data.\nWhen decoding boolean values, a zero byte is decoded as false, and\nany other non-zero byte is decoded as true.\nWhen reading into structs, the field data for fields with\nblank (_) field names is skipped; i.e., blank field names\nmay be used for padding.\nWhen reading into a struct, all non-blank fields must be exported\nor Read may panic.\n\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading some but not all the bytes,\nRead returns ErrUnexpectedEOF.\n\nGo input arguments: (r io.Reader, order ByteOrder, data interface {})\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Reader r, ^go.std.encoding.binary/ByteOrder order, ^<protocol-or-something> data]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "binary.Read(*__r, *__order, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io/Reader __r, ^binary/ByteOrder __order, ^<protocol-or-something> __data])

JOKER FUNC encoding/binary.ReadUvarint from encoding/binary/varint.go:
;; (defn ReadUvarint
;;   "ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.\n\nGo input arguments: (r io.ByteReader)\n\nGo return type: (uint64, error)\n\nJoker input arguments: [^go.std.io/ByteReader r]\n\nJoker return type: [Number Error]"
;;   {:added "1.0"
;;    :go "__readUvarint(*__r)"}
;;   [^io/ByteReader __r])

JOKER FUNC encoding/binary.ReadVarint from encoding/binary/varint.go:
;; (defn ReadVarint
;;   "ReadVarint reads an encoded signed integer from r and returns it as an int64.\n\nGo input arguments: (r io.ByteReader)\n\nGo return type: (int64, error)\n\nJoker input arguments: [^go.std.io/ByteReader r]\n\nJoker return type: [Number Error]"
;;   {:added "1.0"
;;    :go "__readVarint(*__r)"}
;;   [^io/ByteReader __r])

JOKER FUNC encoding/binary.Size from encoding/binary/binary.go:
;; (defn ^"Int" Size
;;   "Size returns how many bytes Write would generate to encode the value v, which\nmust be a fixed-size value or a slice of fixed-size values, or a pointer to such data.\nIf v is neither of these, Size returns -1.\n\nGo input arguments: (v interface {})\n\nGo return type: int\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "binary.Size(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> __v])

JOKER FUNC encoding/binary.Uvarint from encoding/binary/varint.go:
;; (defn Uvarint
;;   "Uvarint decodes a uint64 from buf and returns that value and the\nnumber of bytes read (> 0). If an error occurred, the value is 0\nand the number of bytes n is <= 0 meaning:\n\n\tn == 0: buf too small\n\tn  < 0: value larger than 64 bits (overflow)\n\t        and -n is the number of bytes read\n\nGo input arguments: (buf []byte)\n\nGo return type: (uint64, int)\n\nJoker input arguments: [^(vector-of Int) buf]\n\nJoker return type: [Number Int]"
;;   {:added "1.0"
;;    :go "__uvarint(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__buf)))"}
;;   [^Object __buf])

JOKER FUNC encoding/binary.Varint from encoding/binary/varint.go:
;; (defn Varint
;;   "Varint decodes an int64 from buf and returns that value and the\nnumber of bytes read (> 0). If an error occurred, the value is 0\nand the number of bytes n is <= 0 with the following meaning:\n\n\tn == 0: buf too small\n\tn  < 0: value larger than 64 bits (overflow)\n\t        and -n is the number of bytes read\n\nGo input arguments: (buf []byte)\n\nGo return type: (int64, int)\n\nJoker input arguments: [^(vector-of Int) buf]\n\nJoker return type: [Number Int]"
;;   {:added "1.0"
;;    :go "__varint(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__buf)))"}
;;   [^Object __buf])

JOKER FUNC encoding/binary.Write from encoding/binary/binary.go:
;; (defn ^"Error" Write
;;   "Write writes the binary representation of data into w.\nData must be a fixed-size value or a slice of fixed-size\nvalues, or a pointer to such data.\nBoolean values encode as one byte: 1 for true, and 0 for false.\nBytes written to w are encoded using the specified byte order\nand read from successive fields of the data.\nWhen writing structs, zero values are written for fields\nwith blank (_) field names.\n\nGo input arguments: (w io.Writer, order ByteOrder, data interface {})\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^go.std.encoding.binary/ByteOrder order, ^<protocol-or-something> data]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "binary.Write(*__w, *__order, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io/Writer __w, ^binary/ByteOrder __order, ^<protocol-or-something> __data])

JOKER TYPE go.std.encoding.binary/ByteOrder:
(def
  ^{:doc "A ByteOrder specifies how to convert byte sequences into\n16-, 32-, or 64-bit unsigned integers.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ByteOrder"}
  ByteOrder)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["encoding/binary"]
    :doc "Provides a low-level interface to the encoding/binary package.\n\nPackage binary implements simple translation between numbers and byte\nsequences and encoding and decoding of varints.\n\nNumbers are translated by reading and writing fixed-size values.\nA fixed-size value is either a fixed-size arithmetic\ntype (bool, int8, uint8, int16, float32, complex64, ...)\nor an array or struct containing only fixed-size values.\n\nThe varint functions encode and decode single integer values using\na variable-length encoding; smaller values require fewer bytes.\nFor a specification, see\nhttps://developers.google.com/protocol-buffers/docs/encoding.\n\nThis package favors simplicity over efficiency. Clients that require\nhigh-performance serialization, especially for large data structures,\nshould look at more advanced solutions such as the encoding/gob\npackage or protocol buffers.\n"
    :empty false}
  go.std.encoding.binary)
JOKER VARIABLE ErrBareQuote from encoding/csv/reader.go:
(def
  ^{:doc "These are the errors that can be returned in ParseError.Err.\n"
    :added "1.0"
    :tag "Var"
    :go "csv.ErrBareQuote"}
  ErrBareQuote)

JOKER VARIABLE ErrFieldCount from encoding/csv/reader.go:
(def
  ^{:doc "These are the errors that can be returned in ParseError.Err.\n"
    :added "1.0"
    :tag "Var"
    :go "csv.ErrFieldCount"}
  ErrFieldCount)

JOKER VARIABLE ErrQuote from encoding/csv/reader.go:
(def
  ^{:doc "These are the errors that can be returned in ParseError.Err.\n"
    :added "1.0"
    :tag "Var"
    :go "csv.ErrQuote"}
  ErrQuote)

JOKER VARIABLE ErrTrailingComma from encoding/csv/reader.go:
(def
  ^{:doc "Deprecated: No longer used.\n"
    :added "1.0"
    :tag "Var"
    :go "csv.ErrTrailingComma"}
  ErrTrailingComma)

JOKER TYPE encoding/csv.ParseError from encoding/csv/reader.go:
(defn ^"GoObject" ParseError.
  "Constructor for csv.ParseError"
  {:added "1.0"
   :go "_ConstructParseError(_v)"}
  [^Object _v])

JOKER TYPE encoding/csv.Reader from encoding/csv/reader.go:
(defn ^"GoObject" Reader.
  "Constructor for csv.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER TYPE encoding/csv.Writer from encoding/csv/writer.go:
(defn ^"GoObject" Writer.
  "Constructor for csv.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC encoding/csv.NewReader from encoding/csv/reader.go:
;; (defn NewReader
;;   "NewReader returns a new Reader that reads from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.encoding.csv/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC encoding/csv.NewWriter from encoding/csv/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer that writes to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.encoding.csv/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*__w)"}
;;   [^io/Writer __w])

JOKER TYPE go.std.encoding.csv/ParseError:
(def
  ^{:doc "A ParseError is returned for parsing errors.\nLine numbers are 1-indexed and columns are 0-indexed.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ParseError"}
  ParseError)

JOKER TYPE go.std.encoding.csv/Reader:
(def
  ^{:doc "A Reader reads records from a CSV-encoded file.\n\nAs returned by NewReader, a Reader expects input conforming to RFC 4180.\nThe exported fields can be changed to customize the details before the\nfirst call to Read or ReadAll.\n\nThe Reader converts all \\r\\n sequences in its input to plain \\n,\nincluding in multiline field values, so that the returned data does\nnot depend on which line-ending convention an input file uses.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Reader"}
  Reader)

JOKER TYPE go.std.encoding.csv/Writer:
(def
  ^{:doc "A Writer writes records to a CSV encoded file.\n\nAs returned by NewWriter, a Writer writes records terminated by a\nnewline and uses ',' as the field delimiter. The exported fields can be\nchanged to customize the details before the first call to Write or WriteAll.\n\nComma is the field delimiter.\n\nIf UseCRLF is true, the Writer ends each output line with \\r\\n instead of \\n.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Writer"}
  Writer)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["encoding/csv"]
    :doc "Provides a low-level interface to the encoding/csv package.\n\nPackage csv reads and writes comma-separated values (CSV) files.\nThere are many kinds of CSV files; this package supports the format\ndescribed in RFC 4180.\n\nA csv file contains zero or more records of one or more fields per record.\nEach record is separated by the newline character. The final record may\noptionally be followed by a newline character.\n\n\tfield1,field2,field3\n\nWhite space is considered part of a field.\n\nCarriage returns before newline characters are silently removed.\n\nBlank lines are ignored. A line with only whitespace characters (excluding\nthe ending newline character) is not considered a blank line.\n\nFields which start and stop with the quote character \" are called\nquoted-fields. The beginning and ending quote are not part of the\nfield.\n\nThe source:\n\n\tnormal string,\"quoted-field\"\n\nresults in the fields\n\n\t{`normal string`, `quoted-field`}\n\nWithin a quoted-field a quote character followed by a second quote\ncharacter is considered a single quote.\n\n\t\"the \"\"word\"\" is true\",\"a \"\"quoted-field\"\"\"\n\nresults in\n\n\t{`the \"word\" is true`, `a \"quoted-field\"`}\n\nNewlines and commas may be included in a quoted-field\n\n\t\"Multi-line\n\tfield\",\"comma is ,\"\n\nresults in\n\n\t{`Multi-line\n\tfield`, `comma is ,`}\n"
    :empty false}
  go.std.encoding.csv)
JOKER FUNC encoding/gob.NewDecoder from encoding/gob/decoder.go:
;; (defn NewDecoder
;;   "NewDecoder returns a new decoder that reads from the io.Reader.\nIf r does not also implement io.ByteReader, it will be wrapped in a\nbufio.Reader.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Decoder\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.encoding.gob/Decoder)"
;;   {:added "1.0"
;;    :go "__newDecoder(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC encoding/gob.NewEncoder from encoding/gob/encoder.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new encoder that will transmit on the io.Writer.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Encoder\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.encoding.gob/Encoder)"
;;   {:added "1.0"
;;    :go "__newEncoder(*__w)"}
;;   [^io/Writer __w])

JOKER FUNC encoding/gob.Register from encoding/gob/type.go:
;; (defn Register
;;   "Register records a type, identified by a value for that type, under its\ninternal type name. That name will identify the concrete type of a value\nsent or received as an interface variable. Only types that will be\ntransferred as implementations of interface values need to be registered.\nExpecting to be used only during initialization, it panics if the mapping\nbetween types and names is not a bijection.\n\nGo input arguments: (value interface {})\n\nJoker input arguments: [^<protocol-or-something> value]"
;;   {:added "1.0"
;;    :go "__register(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> __value])

JOKER FUNC encoding/gob.RegisterName from encoding/gob/type.go:
;; (defn RegisterName
;;   "RegisterName is like Register but uses the provided name rather than the\ntype's default.\n\nGo input arguments: (name string, value interface {})\n\nJoker input arguments: [^String name, ^<protocol-or-something> value]"
;;   {:added "1.0"
;;    :go "__registerName(__name, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^String __name, ^<protocol-or-something> __value])

JOKER TYPE go.std.encoding.gob/CommonType:
(def
  ^{:doc "CommonType holds elements of all types.\nIt is a historical artifact, kept for binary compatibility and exported\nonly for the benefit of the package's encoding of type descriptors. It is\nnot intended for direct use by clients.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CommonType"}
  CommonType)

JOKER TYPE go.std.encoding.gob/Decoder:
(def
  ^{:doc "A Decoder manages the receipt of type and data information read from the\nremote side of a connection.  It is safe for concurrent use by multiple\ngoroutines.\n\nThe Decoder does only basic sanity checking on decoded input sizes,\nand its limits are not configurable. Take caution when decoding gob data\nfrom untrusted sources.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Decoder"}
  Decoder)

JOKER TYPE go.std.encoding.gob/Encoder:
(def
  ^{:doc "An Encoder manages the transmission of type and data information to the\nother side of a connection.  It is safe for concurrent use by multiple\ngoroutines.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Encoder"}
  Encoder)

JOKER TYPE go.std.encoding.gob/GobDecoder:
(def
  ^{:doc "GobDecoder is the interface describing data that provides its own\nroutine for decoding transmitted values sent by a GobEncoder.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_GobDecoder"}
  GobDecoder)

JOKER TYPE go.std.encoding.gob/GobEncoder:
(def
  ^{:doc "GobEncoder is the interface describing data that provides its own\nrepresentation for encoding values for transmission to a GobDecoder.\nA type that implements GobEncoder and GobDecoder has complete\ncontrol over the representation of its data and may therefore\ncontain things such as private fields, channels, and functions,\nwhich are not usually transmissible in gob streams.\n\nNote: Since gobs can be stored permanently, it is good design\nto guarantee the encoding used by a GobEncoder is stable as the\nsoftware evolves. For instance, it might make sense for GobEncode\nto include a version number in the encoding.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_GobEncoder"}
  GobEncoder)

JOKER VARIABLE ErrLength from encoding/hex/hex.go:
(def
  ^{:doc "ErrLength reports an attempt to decode an odd-length input\nusing Decode or DecodeString.\nThe stream-based Decoder returns io.ErrUnexpectedEOF instead of ErrLength.\n"
    :added "1.0"
    :tag "Var"
    :go "hex.ErrLength"}
  ErrLength)

JOKER TYPE encoding/hex.InvalidByteError from encoding/hex/hex.go:
(defn ^"GoObject" InvalidByteError.
  "Constructor for hex.InvalidByteError"
  {:added "1.0"
   :go "_ConstructInvalidByteError(_v)"}
  [^Object _v])

JOKER FUNC encoding/hex.Decode from encoding/hex/hex.go:
;; (defn Decode
;;   "Decode decodes src into DecodedLen(len(src)) bytes,\nreturning the actual number of bytes written to dst.\n\nDecode expects that src contains only hexadecimal\ncharacters and that src has even length.\nIf the input is malformed, Decode returns the number\nof bytes decoded before the error.\n\nGo input arguments: (dst []byte, src []byte)\n\nGo return type: (int, error)\n\nJoker input arguments: [^(vector-of Int) dst, ^(vector-of Int) src]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__decode(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__dst)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__src)))"}
;;   [^Object __dst, ^Object __src])

JOKER FUNC encoding/hex.DecodeString from encoding/hex/hex.go:
(defn DecodeString
  "DecodeString returns the bytes represented by the hexadecimal string s.\n\nDecodeString expects that src contains only hexadecimal\ncharacters and that src has even length.\nIf the input is malformed, DecodeString returns\nthe bytes decoded before the error.\n\nGo input arguments: (s string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__decodeString(__s)"}
  [^String __s])

JOKER FUNC encoding/hex.DecodedLen from encoding/hex/hex.go:
(defn ^"Int" DecodedLen
  "DecodedLen returns the length of a decoding of x source bytes.\nSpecifically, it returns x / 2.\n\nGo input arguments: (x int)\n\nGo return type: int\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "hex.DecodedLen(__x)"}
  [^Int __x])

JOKER FUNC encoding/hex.Dump from encoding/hex/hex.go:
;; (defn ^"String" Dump
;;   "Dump returns a string that contains a hex dump of the given data. The format\nof the hex dump matches the output of `hexdump -C` on the command line.\n\nGo input arguments: (data []byte)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "hex.Dump(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)))"}
;;   [^Object __data])

JOKER FUNC encoding/hex.Dumper from encoding/hex/hex.go:
;; (defn Dumper
;;   "Dumper returns a WriteCloser that writes a hex dump of all written data to\nw. The format of the dump matches the output of `hexdump -C` on the command\nline.\n\nGo input arguments: (w io.Writer)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "__dumper(*__w)"}
;;   [^io/Writer __w])

JOKER FUNC encoding/hex.Encode from encoding/hex/hex.go:
;; (defn ^"Int" Encode
;;   "Encode encodes src into EncodedLen(len(src))\nbytes of dst. As a convenience, it returns the number\nof bytes written to dst, but this value is always EncodedLen(len(src)).\nEncode implements hexadecimal encoding.\n\nGo input arguments: (dst []byte, src []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) dst, ^(vector-of Int) src]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "hex.Encode(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__dst)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__src)))"}
;;   [^Object __dst, ^Object __src])

JOKER FUNC encoding/hex.EncodeToString from encoding/hex/hex.go:
;; (defn ^"String" EncodeToString
;;   "EncodeToString returns the hexadecimal encoding of src.\n\nGo input arguments: (src []byte)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of Int) src]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "hex.EncodeToString(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__src)))"}
;;   [^Object __src])

JOKER FUNC encoding/hex.EncodedLen from encoding/hex/hex.go:
(defn ^"Int" EncodedLen
  "EncodedLen returns the length of an encoding of n source bytes.\nSpecifically, it returns n * 2.\n\nGo input arguments: (n int)\n\nGo return type: int\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "hex.EncodedLen(__n)"}
  [^Int __n])

JOKER FUNC encoding/hex.NewDecoder from encoding/hex/hex.go:
;; (defn NewDecoder
;;   "NewDecoder returns an io.Reader that decodes hexadecimal characters from r.\nNewDecoder expects that r contain only an even number of hexadecimal characters.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__newDecoder(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC encoding/hex.NewEncoder from encoding/hex/hex.go:
;; (defn NewEncoder
;;   "NewEncoder returns an io.Writer that writes lowercase hexadecimal characters to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: io.Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: go.std.io/Writer"
;;   {:added "1.0"
;;    :go "__newEncoder(*__w)"}
;;   [^io/Writer __w])

JOKER TYPE go.std.encoding.hex/InvalidByteError:
(def
  ^{:doc "InvalidByteError values describe errors resulting from an invalid byte in a hex string.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_InvalidByteError"}
  InvalidByteError)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["encoding/hex"]
    :doc "Provides a low-level interface to the encoding/hex package.\n\nPackage hex implements hexadecimal encoding and decoding.\n"
    :empty false}
  go.std.encoding.hex)
JOKER TYPE encoding/json.Decoder from encoding/json/stream.go:
(defn ^"GoObject" Decoder.
  "Constructor for json.Decoder"
  {:added "1.0"
   :go "_ConstructDecoder(_v)"}
  [^Object _v])

JOKER TYPE encoding/json.Delim from encoding/json/stream.go:
(defn ^"GoObject" Delim.
  "Constructor for json.Delim"
  {:added "1.0"
   :go "_ConstructDelim(_v)"}
  [^Object _v])

JOKER TYPE encoding/json.Encoder from encoding/json/stream.go:
(defn ^"GoObject" Encoder.
  "Constructor for json.Encoder"
  {:added "1.0"
   :go "_ConstructEncoder(_v)"}
  [^Object _v])

JOKER TYPE encoding/json.InvalidUTF8Error from encoding/json/encode.go:
(defn ^"GoObject" InvalidUTF8Error.
  "Constructor for json.InvalidUTF8Error"
  {:added "1.0"
   :go "_ConstructInvalidUTF8Error(_v)"}
  [^Object _v])

JOKER TYPE encoding/json.InvalidUnmarshalError from encoding/json/decode.go:
;; (defn ^"GoObject" InvalidUnmarshalError.
;;   "Constructor for json.InvalidUnmarshalError"
;;   {:added "1.0"
;;    :go "_ConstructInvalidUnmarshalError(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/json.Marshaler from encoding/json/encode.go:
;; (defn ^"GoObject" Marshaler.
;;   "Constructor for json.Marshaler"
;;   {:added "1.0"
;;    :go "_ConstructMarshaler(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/json.MarshalerError from encoding/json/encode.go:
;; (defn ^"GoObject" MarshalerError.
;;   "Constructor for json.MarshalerError"
;;   {:added "1.0"
;;    :go "_ConstructMarshalerError(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/json.Number from encoding/json/decode.go:
(defn ^"GoObject" Number.
  "Constructor for json.Number"
  {:added "1.0"
   :go "_ConstructNumber(_v)"}
  [^Object _v])

JOKER TYPE encoding/json.RawMessage from encoding/json/stream.go:
;; (defn ^"GoObject" RawMessage.
;;   "Constructor for json.RawMessage"
;;   {:added "1.0"
;;    :go "_ConstructRawMessage(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/json.SyntaxError from encoding/json/scanner.go:
(defn ^"GoObject" SyntaxError.
  "Constructor for json.SyntaxError"
  {:added "1.0"
   :go "_ConstructSyntaxError(_v)"}
  [^Object _v])

JOKER TYPE encoding/json.Token from encoding/json/stream.go:
;; (defn ^"GoObject" Token.
;;   "Constructor for json.Token"
;;   {:added "1.0"
;;    :go "_ConstructToken(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/json.UnmarshalFieldError from encoding/json/decode.go:
;; (defn ^"GoObject" UnmarshalFieldError.
;;   "Constructor for json.UnmarshalFieldError"
;;   {:added "1.0"
;;    :go "_ConstructUnmarshalFieldError(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/json.UnmarshalTypeError from encoding/json/decode.go:
;; (defn ^"GoObject" UnmarshalTypeError.
;;   "Constructor for json.UnmarshalTypeError"
;;   {:added "1.0"
;;    :go "_ConstructUnmarshalTypeError(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/json.Unmarshaler from encoding/json/decode.go:
;; (defn ^"GoObject" Unmarshaler.
;;   "Constructor for json.Unmarshaler"
;;   {:added "1.0"
;;    :go "_ConstructUnmarshaler(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/json.UnsupportedTypeError from encoding/json/encode.go:
;; (defn ^"GoObject" UnsupportedTypeError.
;;   "Constructor for json.UnsupportedTypeError"
;;   {:added "1.0"
;;    :go "_ConstructUnsupportedTypeError(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/json.UnsupportedValueError from encoding/json/encode.go:
;; (defn ^"GoObject" UnsupportedValueError.
;;   "Constructor for json.UnsupportedValueError"
;;   {:added "1.0"
;;    :go "_ConstructUnsupportedValueError(_v)"}
;;   [^Object _v])

JOKER FUNC encoding/json.Compact from encoding/json/indent.go:
;; (defn ^"Error" Compact
;;   "Compact appends to dst the JSON-encoded src with\ninsignificant space characters elided.\n\nGo input arguments: (dst *bytes.Buffer, src []byte)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) dst, ^(vector-of Int) src]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "json.Compact(__dst, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__src)))"}
;;   [^bytes/Buffer __dst, ^Object __src])

JOKER FUNC encoding/json.HTMLEscape from encoding/json/encode.go:
;; (defn HTMLEscape
;;   "HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and U+2029\ncharacters inside string literals changed to \\u003c, \\u003e, \\u0026, \\u2028, \\u2029\nso that the JSON will be safe to embed inside HTML <script> tags.\nFor historical reasons, web browsers don't honor standard HTML\nescaping within <script> tags, so an alternative JSON encoding must\nbe used.\n\nGo input arguments: (dst *bytes.Buffer, src []byte)\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) dst, ^(vector-of Int) src]"
;;   {:added "1.0"
;;    :go "__hTMLEscape(__dst, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__src)))"}
;;   [^bytes/Buffer __dst, ^Object __src])

JOKER FUNC encoding/json.Indent from encoding/json/indent.go:
;; (defn ^"Error" Indent
;;   "Indent appends to dst an indented form of the JSON-encoded src.\nEach element in a JSON object or array begins on a new,\nindented line beginning with prefix followed by one or more\ncopies of indent according to the indentation nesting.\nThe data appended to dst does not begin with the prefix nor\nany indentation, to make it easier to embed inside other formatted JSON data.\nAlthough leading space characters (space, tab, carriage return, newline)\nat the beginning of src are dropped, trailing space characters\nat the end of src are preserved and copied to dst.\nFor example, if src has no trailing spaces, neither will dst;\nif src ends in a trailing newline, so will dst.\n\nGo input arguments: (dst *bytes.Buffer, src []byte, prefix string, indent string)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) dst, ^(vector-of Int) src, ^String prefix, ^String indent]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "json.Indent(__dst, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__src)), __prefix, __indent)"}
;;   [^bytes/Buffer __dst, ^Object __src, ^String __prefix, ^String __indent])

JOKER FUNC encoding/json.Marshal from encoding/json/encode.go:
;; (defn Marshal
;;   "Marshal returns the JSON encoding of v.\n\nMarshal traverses the value v recursively.\nIf an encountered value implements the Marshaler interface\nand is not a nil pointer, Marshal calls its MarshalJSON method\nto produce JSON. If no MarshalJSON method is present but the\nvalue implements encoding.TextMarshaler instead, Marshal calls\nits MarshalText method and encodes the result as a JSON string.\nThe nil pointer exception is not strictly necessary\nbut mimics a similar, necessary exception in the behavior of\nUnmarshalJSON.\n\nOtherwise, Marshal uses the following type-dependent default encodings:\n\nBoolean values encode as JSON booleans.\n\nFloating point, integer, and Number values encode as JSON numbers.\n\nString values encode as JSON strings coerced to valid UTF-8,\nreplacing invalid bytes with the Unicode replacement rune.\nThe angle brackets \"<\" and \">\" are escaped to \"\\u003c\" and \"\\u003e\"\nto keep some browsers from misinterpreting JSON output as HTML.\nAmpersand \"&\" is also escaped to \"\\u0026\" for the same reason.\nThis escaping can be disabled using an Encoder that had SetEscapeHTML(false)\ncalled on it.\n\nArray and slice values encode as JSON arrays, except that\n[]byte encodes as a base64-encoded string, and a nil slice\nencodes as the null JSON value.\n\nStruct values encode as JSON objects.\nEach exported struct field becomes a member of the object, using the\nfield name as the object key, unless the field is omitted for one of the\nreasons given below.\n\nThe encoding of each struct field can be customized by the format string\nstored under the \"json\" key in the struct field's tag.\nThe format string gives the name of the field, possibly followed by a\ncomma-separated list of options. The name may be empty in order to\nspecify options without overriding the default field name.\n\nThe \"omitempty\" option specifies that the field should be omitted\nfrom the encoding if the field has an empty value, defined as\nfalse, 0, a nil pointer, a nil interface value, and any empty array,\nslice, map, or string.\n\nAs a special case, if the field tag is \"-\", the field is always omitted.\nNote that a field with name \"-\" can still be generated using the tag \"-,\".\n\nExamples of struct field tags and their meanings:\n\n  // Field appears in JSON as key \"myName\".\n  Field int `json:\"myName\"`\n\n  // Field appears in JSON as key \"myName\" and\n  // the field is omitted from the object if its value is empty,\n  // as defined above.\n  Field int `json:\"myName,omitempty\"`\n\n  // Field appears in JSON as key \"Field\" (the default), but\n  // the field is skipped if empty.\n  // Note the leading comma.\n  Field int `json:\",omitempty\"`\n\n  // Field is ignored by this package.\n  Field int `json:\"-\"`\n\n  // Field appears in JSON as key \"-\".\n  Field int `json:\"-,\"`\n\nThe \"string\" option signals that a field is stored as JSON inside a\nJSON-encoded string. It applies only to fields of string, floating point,\ninteger, or boolean types. This extra level of encoding is sometimes used\nwhen communicating with JavaScript programs:\n\n   Int64String int64 `json:\",string\"`\n\nThe key name will be used if it's a non-empty string consisting of\nonly Unicode letters, digits, and ASCII punctuation except quotation\nmarks, backslash, and comma.\n\nAnonymous struct fields are usually marshaled as if their inner exported fields\nwere fields in the outer struct, subject to the usual Go visibility rules amended\nas described in the next paragraph.\nAn anonymous struct field with a name given in its JSON tag is treated as\nhaving that name, rather than being anonymous.\nAn anonymous struct field of interface type is treated the same as having\nthat type as its name, rather than being anonymous.\n\nThe Go visibility rules for struct fields are amended for JSON when\ndeciding which field to marshal or unmarshal. If there are\nmultiple fields at the same level, and that level is the least\nnested (and would therefore be the nesting level selected by the\nusual Go rules), the following extra rules apply:\n\n1) Of those fields, if any are JSON-tagged, only tagged fields are considered,\neven if there are multiple untagged fields that would otherwise conflict.\n\n2) If there is exactly one field (tagged or not according to the first rule), that is selected.\n\n3) Otherwise there are multiple fields, and all are ignored; no error occurs.\n\nHandling of anonymous struct fields is new in Go 1.1.\nPrior to Go 1.1, anonymous struct fields were ignored. To force ignoring of\nan anonymous struct field in both current and earlier versions, give the field\na JSON tag of \"-\".\n\nMap values encode as JSON objects. The map's key type must either be a\nstring, an integer type, or implement encoding.TextMarshaler. The map keys\nare sorted and used as JSON object keys by applying the following rules,\nsubject to the UTF-8 coercion described for string values above:\n  - string keys are used directly\n  - encoding.TextMarshalers are marshaled\n  - integer keys are converted to strings\n\nPointer values encode as the value pointed to.\nA nil pointer encodes as the null JSON value.\n\nInterface values encode as the value contained in the interface.\nA nil interface value encodes as the null JSON value.\n\nChannel, complex, and function values cannot be encoded in JSON.\nAttempting to encode such a value causes Marshal to return\nan UnsupportedTypeError.\n\nJSON cannot represent cyclic data structures and Marshal does not\nhandle them. Passing cyclic structures to Marshal will result in\nan infinite recursion.\n\nGo input arguments: (v interface {})\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshal(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> __v])

JOKER FUNC encoding/json.MarshalIndent from encoding/json/encode.go:
;; (defn MarshalIndent
;;   "MarshalIndent is like Marshal but applies Indent to format the output.\nEach JSON element in the output will begin on a new line beginning with prefix\nfollowed by one or more copies of indent according to the indentation nesting.\n\nGo input arguments: (v interface {}, prefix string, indent string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> v, ^String prefix, ^String indent]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshalIndent(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), __prefix, __indent)"}
;;   [^<protocol-or-something> __v, ^String __prefix, ^String __indent])

JOKER FUNC encoding/json.NewDecoder from encoding/json/stream.go:
;; (defn NewDecoder
;;   "NewDecoder returns a new decoder that reads from r.\n\nThe decoder introduces its own buffering and may\nread data from r beyond the JSON values requested.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Decoder\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.encoding.json/Decoder)"
;;   {:added "1.0"
;;    :go "__newDecoder(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC encoding/json.NewEncoder from encoding/json/stream.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new encoder that writes to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Encoder\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.encoding.json/Encoder)"
;;   {:added "1.0"
;;    :go "__newEncoder(*__w)"}
;;   [^io/Writer __w])

JOKER FUNC encoding/json.Unmarshal from encoding/json/decode.go:
;; (defn ^"Error" Unmarshal
;;   "Unmarshal parses the JSON-encoded data and stores the result\nin the value pointed to by v. If v is nil or not a pointer,\nUnmarshal returns an InvalidUnmarshalError.\n\nUnmarshal uses the inverse of the encodings that\nMarshal uses, allocating maps, slices, and pointers as necessary,\nwith the following additional rules:\n\nTo unmarshal JSON into a pointer, Unmarshal first handles the case of\nthe JSON being the JSON literal null. In that case, Unmarshal sets\nthe pointer to nil. Otherwise, Unmarshal unmarshals the JSON into\nthe value pointed at by the pointer. If the pointer is nil, Unmarshal\nallocates a new value for it to point to.\n\nTo unmarshal JSON into a value implementing the Unmarshaler interface,\nUnmarshal calls that value's UnmarshalJSON method, including\nwhen the input is a JSON null.\nOtherwise, if the value implements encoding.TextUnmarshaler\nand the input is a JSON quoted string, Unmarshal calls that value's\nUnmarshalText method with the unquoted form of the string.\n\nTo unmarshal JSON into a struct, Unmarshal matches incoming object\nkeys to the keys used by Marshal (either the struct field name or its tag),\npreferring an exact match but also accepting a case-insensitive match. By\ndefault, object keys which don't have a corresponding struct field are\nignored (see Decoder.DisallowUnknownFields for an alternative).\n\nTo unmarshal JSON into an interface value,\nUnmarshal stores one of these in the interface value:\n\n\tbool, for JSON booleans\n\tfloat64, for JSON numbers\n\tstring, for JSON strings\n\t[]interface{}, for JSON arrays\n\tmap[string]interface{}, for JSON objects\n\tnil for JSON null\n\nTo unmarshal a JSON array into a slice, Unmarshal resets the slice length\nto zero and then appends each element to the slice.\nAs a special case, to unmarshal an empty JSON array into a slice,\nUnmarshal replaces the slice with a new empty slice.\n\nTo unmarshal a JSON array into a Go array, Unmarshal decodes\nJSON array elements into corresponding Go array elements.\nIf the Go array is smaller than the JSON array,\nthe additional JSON array elements are discarded.\nIf the JSON array is smaller than the Go array,\nthe additional Go array elements are set to zero values.\n\nTo unmarshal a JSON object into a map, Unmarshal first establishes a map to\nuse. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal\nreuses the existing map, keeping existing entries. Unmarshal then stores\nkey-value pairs from the JSON object into the map. The map's key type must\neither be a string, an integer, or implement encoding.TextUnmarshaler.\n\nIf a JSON value is not appropriate for a given target type,\nor if a JSON number overflows the target type, Unmarshal\nskips that field and completes the unmarshaling as best it can.\nIf no more serious errors are encountered, Unmarshal returns\nan UnmarshalTypeError describing the earliest such error. In any\ncase, it's not guaranteed that all the remaining fields following\nthe problematic one will be unmarshaled into the target object.\n\nThe JSON null value unmarshals into an interface, map, pointer, or slice\nby setting that Go value to nil. Because null is often used in JSON to mean\n``not present,'' unmarshaling a JSON null into any other Go type has no effect\non the value and produces no error.\n\nWhen unmarshaling quoted strings, invalid UTF-8 or\ninvalid UTF-16 surrogate pairs are not treated as an error.\nInstead, they are replaced by the Unicode replacement\ncharacter U+FFFD.\n\nGo input arguments: (data []byte, v interface {})\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) data, ^<protocol-or-something> v]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "json.Unmarshal(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^Object __data, ^<protocol-or-something> __v])

JOKER FUNC encoding/json.Valid from encoding/json/scanner.go:
;; (defn ^"Boolean" Valid
;;   "Valid reports whether data is a valid JSON encoding.\n\nGo input arguments: (data []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "json.Valid(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)))"}
;;   [^Object __data])

JOKER TYPE go.std.encoding.json/Decoder:
(def
  ^{:doc "A Decoder reads and decodes JSON values from an input stream.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Decoder"}
  Decoder)

JOKER TYPE go.std.encoding.json/Delim:
(def
  ^{:doc "A Delim is a JSON array or object delimiter, one of [ ] { or }.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Delim"}
  Delim)

JOKER TYPE go.std.encoding.json/Encoder:
(def
  ^{:doc "An Encoder writes JSON values to an output stream.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Encoder"}
  Encoder)

JOKER TYPE go.std.encoding.json/InvalidUTF8Error:
(def
  ^{:doc "Before Go 1.2, an InvalidUTF8Error was returned by Marshal when\nattempting to encode a string value with invalid UTF-8 sequences.\nAs of Go 1.2, Marshal instead coerces the string to valid UTF-8 by\nreplacing invalid bytes with the Unicode replacement rune U+FFFD.\n\nDeprecated: No longer used; kept for compatibility.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_InvalidUTF8Error"}
  InvalidUTF8Error)

JOKER TYPE go.std.encoding.json/InvalidUnmarshalError:
(def
  ^{:doc "An InvalidUnmarshalError describes an invalid argument passed to Unmarshal.\n(The argument to Unmarshal must be a non-nil pointer.)\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_InvalidUnmarshalError"}
  InvalidUnmarshalError)

JOKER TYPE go.std.encoding.json/Marshaler:
(def
  ^{:doc "Marshaler is the interface implemented by types that\ncan marshal themselves into valid JSON.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Marshaler"}
  Marshaler)

JOKER TYPE go.std.encoding.json/MarshalerError:
(def
  ^{:doc "A MarshalerError represents an error from calling a MarshalJSON or MarshalText method.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_MarshalerError"}
  MarshalerError)

JOKER TYPE go.std.encoding.json/Number:
(def
  ^{:doc "A Number represents a JSON number literal.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Number"}
  Number)

JOKER TYPE go.std.encoding.json/RawMessage:
(def
  ^{:doc "RawMessage is a raw encoded JSON value.\nIt implements Marshaler and Unmarshaler and can\nbe used to delay JSON decoding or precompute a JSON encoding.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RawMessage"}
  RawMessage)

JOKER TYPE go.std.encoding.json/SyntaxError:
(def
  ^{:doc "A SyntaxError is a description of a JSON syntax error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SyntaxError"}
  SyntaxError)

JOKER TYPE go.std.encoding.json/Token:
(def
  ^{:doc "A Token holds a value of one of these types:\n\n\tDelim, for the four JSON delimiters [ ] { }\n\tbool, for JSON booleans\n\tfloat64, for JSON numbers\n\tNumber, for JSON numbers\n\tstring, for JSON string literals\n\tnil, for JSON null\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Token"}
  Token)

JOKER TYPE go.std.encoding.json/UnmarshalFieldError:
(def
  ^{:doc "An UnmarshalFieldError describes a JSON object key that\nled to an unexported (and therefore unwritable) struct field.\n\nDeprecated: No longer used; kept for compatibility.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnmarshalFieldError"}
  UnmarshalFieldError)

JOKER TYPE go.std.encoding.json/UnmarshalTypeError:
(def
  ^{:doc "An UnmarshalTypeError describes a JSON value that was\nnot appropriate for a value of a specific Go type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnmarshalTypeError"}
  UnmarshalTypeError)

JOKER TYPE go.std.encoding.json/Unmarshaler:
(def
  ^{:doc "Unmarshaler is the interface implemented by types\nthat can unmarshal a JSON description of themselves.\nThe input can be assumed to be a valid encoding of\na JSON value. UnmarshalJSON must copy the JSON data\nif it wishes to retain the data after returning.\n\nBy convention, to approximate the behavior of Unmarshal itself,\nUnmarshalers implement UnmarshalJSON([]byte(\"null\")) as a no-op.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Unmarshaler"}
  Unmarshaler)

JOKER TYPE go.std.encoding.json/UnsupportedTypeError:
(def
  ^{:doc "An UnsupportedTypeError is returned by Marshal when attempting\nto encode an unsupported value type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnsupportedTypeError"}
  UnsupportedTypeError)

JOKER TYPE go.std.encoding.json/UnsupportedValueError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_UnsupportedValueError"}
  UnsupportedValueError)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the encoding/json package.\n\nPackage json implements encoding and decoding of JSON as defined in\nRFC 7159. The mapping between JSON and Go values is described\nin the documentation for the Marshal and Unmarshal functions.\n\nSee \"JSON and Go\" for an introduction to this package:\nhttps://golang.org/doc/articles/json_and_go.html\n"
    :empty false}
  go.std.encoding.json)
JOKER TYPE encoding/pem.Block from encoding/pem/pem.go:
;; (defn ^"GoObject" Block.
;;   "Constructor for pem.Block"
;;   {:added "1.0"
;;    :go "_ConstructBlock(_v)"}
;;   [^Object _v])

JOKER FUNC encoding/pem.Decode from encoding/pem/pem.go:
;; (defn Decode
;;   "Decode will find the next PEM formatted block (certificate, private key\netc) in the input. It returns that block and the remainder of the input. If\nno PEM data is found, p is nil and the whole of the input is returned in\nrest.\n\nGo input arguments: (data []byte)\n\nGo return type: (p *Block, rest []byte)\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: [(atom-of go.std.encoding.pem/Block) (vector-of Int)]"
;;   {:added "1.0"
;;    :go "__decode(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)))"}
;;   [^Object __data])

JOKER FUNC encoding/pem.Encode from encoding/pem/pem.go:
;; (defn ^"Error" Encode
;;   "Encode writes the PEM encoding of b to out.\n\nGo input arguments: (out io.Writer, b *Block)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer out, ^(atom-of go.std.encoding.pem/Block) b]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "pem.Encode(*__out, __b)"}
;;   [^io/Writer __out, ^pem/Block __b])

JOKER FUNC encoding/pem.EncodeToMemory from encoding/pem/pem.go:
(defn EncodeToMemory
  "EncodeToMemory returns the PEM encoding of b.\n\nIf b has invalid headers and cannot be encoded,\nEncodeToMemory returns nil. If it is important to\nreport details about this error case, use Encode instead.\n\nGo input arguments: (b *Block)\n\nGo return type: []byte\n\nJoker input arguments: [^(atom-of go.std.encoding.pem/Block) b]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__encodeToMemory(__b)"}
  [^pem/Block __b])

JOKER TYPE go.std.encoding.pem/Block:
(def
  ^{:doc "A Block represents a PEM encoded structure.\n\nThe encoded form is:\n   -----BEGIN Type-----\n   Headers\n   base64-encoded Bytes\n   -----END Type-----\nwhere Headers is a possibly empty sequence of Key: Value lines.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Block"}
  Block)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the encoding/pem package.\n\nPackage pem implements the PEM data encoding, which originated in Privacy\nEnhanced Mail. The most common use of PEM encoding today is in TLS keys and\ncertificates. See RFC 1421.\n"
    :empty false}
  go.std.encoding.pem)
JOKER CONSTANT Header from encoding/xml/marshal.go:
(def
  ^{:doc "Header is a generic XML header suitable for use with the output of Marshal.\nThis is not automatically added to any output of this package,\nit is provided as a convenience.\n"
    :added "1.0"
    :tag "String"
    :go "xml.Header"}
  Header)

JOKER VARIABLE HTMLAutoClose from encoding/xml/xml.go:
(def
  ^{:doc "HTMLAutoClose is the set of HTML elements that\nshould be considered to close automatically.\n\nSee the Decoder.Strict and Decoder.Entity fields' documentation.\n"
    :added "1.0"
    :tag "Var"
    :go "xml.HTMLAutoClose"}
  HTMLAutoClose)

JOKER VARIABLE HTMLEntity from encoding/xml/xml.go:
(def
  ^{:doc "HTMLEntity is an entity map containing translations for the\nstandard HTML entity characters.\n\nSee the Decoder.Strict and Decoder.Entity fields' documentation.\n"
    :added "1.0"
    :tag "Var"
    :go "xml.HTMLEntity"}
  HTMLEntity)

JOKER TYPE encoding/xml.Attr from encoding/xml/xml.go:
;; (defn ^"GoObject" Attr.
;;   "Constructor for xml.Attr"
;;   {:added "1.0"
;;    :go "_ConstructAttr(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.CharData from encoding/xml/xml.go:
;; (defn ^"GoObject" CharData.
;;   "Constructor for xml.CharData"
;;   {:added "1.0"
;;    :go "_ConstructCharData(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.Comment from encoding/xml/xml.go:
;; (defn ^"GoObject" Comment.
;;   "Constructor for xml.Comment"
;;   {:added "1.0"
;;    :go "_ConstructComment(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.Decoder from encoding/xml/xml.go:
;; (defn ^"GoObject" Decoder.
;;   "Constructor for xml.Decoder"
;;   {:added "1.0"
;;    :go "_ConstructDecoder(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.Directive from encoding/xml/xml.go:
;; (defn ^"GoObject" Directive.
;;   "Constructor for xml.Directive"
;;   {:added "1.0"
;;    :go "_ConstructDirective(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.Encoder from encoding/xml/marshal.go:
(defn ^"GoObject" Encoder.
  "Constructor for xml.Encoder"
  {:added "1.0"
   :go "_ConstructEncoder(_v)"}
  [^Object _v])

JOKER TYPE encoding/xml.EndElement from encoding/xml/xml.go:
;; (defn ^"GoObject" EndElement.
;;   "Constructor for xml.EndElement"
;;   {:added "1.0"
;;    :go "_ConstructEndElement(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.Marshaler from encoding/xml/marshal.go:
;; (defn ^"GoObject" Marshaler.
;;   "Constructor for xml.Marshaler"
;;   {:added "1.0"
;;    :go "_ConstructMarshaler(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.MarshalerAttr from encoding/xml/marshal.go:
;; (defn ^"GoObject" MarshalerAttr.
;;   "Constructor for xml.MarshalerAttr"
;;   {:added "1.0"
;;    :go "_ConstructMarshalerAttr(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.Name from encoding/xml/xml.go:
(defn ^"GoObject" Name.
  "Constructor for xml.Name"
  {:added "1.0"
   :go "_ConstructName(_v)"}
  [^Object _v])

JOKER TYPE encoding/xml.ProcInst from encoding/xml/xml.go:
;; (defn ^"GoObject" ProcInst.
;;   "Constructor for xml.ProcInst"
;;   {:added "1.0"
;;    :go "_ConstructProcInst(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.StartElement from encoding/xml/xml.go:
;; (defn ^"GoObject" StartElement.
;;   "Constructor for xml.StartElement"
;;   {:added "1.0"
;;    :go "_ConstructStartElement(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.SyntaxError from encoding/xml/xml.go:
(defn ^"GoObject" SyntaxError.
  "Constructor for xml.SyntaxError"
  {:added "1.0"
   :go "_ConstructSyntaxError(_v)"}
  [^Object _v])

JOKER TYPE encoding/xml.TagPathError from encoding/xml/typeinfo.go:
;; (defn ^"GoObject" TagPathError.
;;   "Constructor for xml.TagPathError"
;;   {:added "1.0"
;;    :go "_ConstructTagPathError(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.Token from encoding/xml/xml.go:
;; (defn ^"GoObject" Token.
;;   "Constructor for xml.Token"
;;   {:added "1.0"
;;    :go "_ConstructToken(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.TokenReader from encoding/xml/xml.go:
;; (defn ^"GoObject" TokenReader.
;;   "Constructor for xml.TokenReader"
;;   {:added "1.0"
;;    :go "_ConstructTokenReader(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.UnmarshalError from encoding/xml/read.go:
(defn ^"GoObject" UnmarshalError.
  "Constructor for xml.UnmarshalError"
  {:added "1.0"
   :go "_ConstructUnmarshalError(_v)"}
  [^Object _v])

JOKER TYPE encoding/xml.Unmarshaler from encoding/xml/read.go:
;; (defn ^"GoObject" Unmarshaler.
;;   "Constructor for xml.Unmarshaler"
;;   {:added "1.0"
;;    :go "_ConstructUnmarshaler(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.UnmarshalerAttr from encoding/xml/read.go:
;; (defn ^"GoObject" UnmarshalerAttr.
;;   "Constructor for xml.UnmarshalerAttr"
;;   {:added "1.0"
;;    :go "_ConstructUnmarshalerAttr(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.UnsupportedTypeError from encoding/xml/marshal.go:
;; (defn ^"GoObject" UnsupportedTypeError.
;;   "Constructor for xml.UnsupportedTypeError"
;;   {:added "1.0"
;;    :go "_ConstructUnsupportedTypeError(_v)"}
;;   [^Object _v])

JOKER FUNC encoding/xml.CopyToken from encoding/xml/xml.go:
(defn CopyToken
  "CopyToken returns a copy of a Token.\n\nGo input arguments: (t Token)\n\nGo return type: Token\n\nJoker input arguments: [^go.std.encoding.xml/Token t]\n\nJoker return type: go.std.encoding.xml/Token"
  {:added "1.0"
   :go "__copyToken(*__t)"}
  [^xml/Token __t])

JOKER FUNC encoding/xml.Escape from encoding/xml/xml.go:
;; (defn Escape
;;   "Escape is like EscapeText but omits the error return value.\nIt is provided for backwards compatibility with Go 1.0.\nCode targeting Go 1.1 or later should use EscapeText.\n\nGo input arguments: (w io.Writer, s []byte)\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Int) s]"
;;   {:added "1.0"
;;    :go "__escape(*__w, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)))"}
;;   [^io/Writer __w, ^Object __s])

JOKER FUNC encoding/xml.EscapeText from encoding/xml/xml.go:
;; (defn ^"Error" EscapeText
;;   "EscapeText writes to w the properly escaped XML equivalent\nof the plain text data s.\n\nGo input arguments: (w io.Writer, s []byte)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Int) s]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "xml.EscapeText(*__w, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__s)))"}
;;   [^io/Writer __w, ^Object __s])

JOKER FUNC encoding/xml.Marshal from encoding/xml/marshal.go:
;; (defn Marshal
;;   "Marshal returns the XML encoding of v.\n\nMarshal handles an array or slice by marshaling each of the elements.\nMarshal handles a pointer by marshaling the value it points at or, if the\npointer is nil, by writing nothing. Marshal handles an interface value by\nmarshaling the value it contains or, if the interface value is nil, by\nwriting nothing. Marshal handles all other data by writing one or more XML\nelements containing the data.\n\nThe name for the XML elements is taken from, in order of preference:\n    - the tag on the XMLName field, if the data is a struct\n    - the value of the XMLName field of type Name\n    - the tag of the struct field used to obtain the data\n    - the name of the struct field used to obtain the data\n    - the name of the marshaled type\n\nThe XML element for a struct contains marshaled elements for each of the\nexported fields of the struct, with these exceptions:\n    - the XMLName field, described above, is omitted.\n    - a field with tag \"-\" is omitted.\n    - a field with tag \"name,attr\" becomes an attribute with\n      the given name in the XML element.\n    - a field with tag \",attr\" becomes an attribute with the\n      field name in the XML element.\n    - a field with tag \",chardata\" is written as character data,\n      not as an XML element.\n    - a field with tag \",cdata\" is written as character data\n      wrapped in one or more <![CDATA[ ... ]]> tags, not as an XML element.\n    - a field with tag \",innerxml\" is written verbatim, not subject\n      to the usual marshaling procedure.\n    - a field with tag \",comment\" is written as an XML comment, not\n      subject to the usual marshaling procedure. It must not contain\n      the \"--\" string within it.\n    - a field with a tag including the \"omitempty\" option is omitted\n      if the field value is empty. The empty values are false, 0, any\n      nil pointer or interface value, and any array, slice, map, or\n      string of length zero.\n    - an anonymous struct field is handled as if the fields of its\n      value were part of the outer struct.\n    - a field implementing Marshaler is written by calling its MarshalXML\n      method.\n    - a field implementing encoding.TextMarshaler is written by encoding the\n      result of its MarshalText method as text.\n\nIf a field uses a tag \"a>b>c\", then the element c will be nested inside\nparent elements a and b. Fields that appear next to each other that name\nthe same parent will be enclosed in one XML element.\n\nIf the XML name for a struct field is defined by both the field tag and the\nstruct's XMLName field, the names must match.\n\nSee MarshalIndent for an example.\n\nMarshal will return an error if asked to marshal a channel, function, or map.\n\nGo input arguments: (v interface {})\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshal(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> __v])

JOKER FUNC encoding/xml.MarshalIndent from encoding/xml/marshal.go:
;; (defn MarshalIndent
;;   "MarshalIndent works like Marshal, but each XML element begins on a new\nindented line that starts with prefix and is followed by one or more\ncopies of indent according to the nesting depth.\n\nGo input arguments: (v interface {}, prefix string, indent string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> v, ^String prefix, ^String indent]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshalIndent(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), __prefix, __indent)"}
;;   [^<protocol-or-something> __v, ^String __prefix, ^String __indent])

JOKER FUNC encoding/xml.NewDecoder from encoding/xml/xml.go:
;; (defn NewDecoder
;;   "NewDecoder creates a new XML parser reading from r.\nIf r does not implement io.ByteReader, NewDecoder will\ndo its own buffering.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Decoder\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.encoding.xml/Decoder)"
;;   {:added "1.0"
;;    :go "__newDecoder(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC encoding/xml.NewEncoder from encoding/xml/marshal.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new encoder that writes to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Encoder\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.encoding.xml/Encoder)"
;;   {:added "1.0"
;;    :go "__newEncoder(*__w)"}
;;   [^io/Writer __w])

JOKER FUNC encoding/xml.NewTokenDecoder from encoding/xml/xml.go:
(defn NewTokenDecoder
  "NewTokenDecoder creates a new XML parser using an underlying token stream.\n\nGo input arguments: (t TokenReader)\n\nGo return type: *Decoder\n\nJoker input arguments: [^go.std.encoding.xml/TokenReader t]\n\nJoker return type: (atom-of go.std.encoding.xml/Decoder)"
  {:added "1.0"
   :go "__newTokenDecoder(*__t)"}
  [^xml/TokenReader __t])

JOKER FUNC encoding/xml.Unmarshal from encoding/xml/read.go:
;; (defn ^"Error" Unmarshal
;;   "Unmarshal parses the XML-encoded data and stores the result in\nthe value pointed to by v, which must be an arbitrary struct,\nslice, or string. Well-formed data that does not fit into v is\ndiscarded.\n\nBecause Unmarshal uses the reflect package, it can only assign\nto exported (upper case) fields. Unmarshal uses a case-sensitive\ncomparison to match XML element names to tag values and struct\nfield names.\n\nUnmarshal maps an XML element to a struct using the following rules.\nIn the rules, the tag of a field refers to the value associated with the\nkey 'xml' in the struct field's tag (see the example above).\n\n  * If the struct has a field of type []byte or string with tag\n     \",innerxml\", Unmarshal accumulates the raw XML nested inside the\n     element in that field. The rest of the rules still apply.\n\n  * If the struct has a field named XMLName of type Name,\n     Unmarshal records the element name in that field.\n\n  * If the XMLName field has an associated tag of the form\n     \"name\" or \"namespace-URL name\", the XML element must have\n     the given name (and, optionally, name space) or else Unmarshal\n     returns an error.\n\n  * If the XML element has an attribute whose name matches a\n     struct field name with an associated tag containing \",attr\" or\n     the explicit name in a struct field tag of the form \"name,attr\",\n     Unmarshal records the attribute value in that field.\n\n  * If the XML element has an attribute not handled by the previous\n     rule and the struct has a field with an associated tag containing\n     \",any,attr\", Unmarshal records the attribute value in the first\n     such field.\n\n  * If the XML element contains character data, that data is\n     accumulated in the first struct field that has tag \",chardata\".\n     The struct field may have type []byte or string.\n     If there is no such field, the character data is discarded.\n\n  * If the XML element contains comments, they are accumulated in\n     the first struct field that has tag \",comment\".  The struct\n     field may have type []byte or string. If there is no such\n     field, the comments are discarded.\n\n  * If the XML element contains a sub-element whose name matches\n     the prefix of a tag formatted as \"a\" or \"a>b>c\", unmarshal\n     will descend into the XML structure looking for elements with the\n     given names, and will map the innermost elements to that struct\n     field. A tag starting with \">\" is equivalent to one starting\n     with the field name followed by \">\".\n\n  * If the XML element contains a sub-element whose name matches\n     a struct field's XMLName tag and the struct field has no\n     explicit name tag as per the previous rule, unmarshal maps\n     the sub-element to that struct field.\n\n  * If the XML element contains a sub-element whose name matches a\n     field without any mode flags (\",attr\", \",chardata\", etc), Unmarshal\n     maps the sub-element to that struct field.\n\n  * If the XML element contains a sub-element that hasn't matched any\n     of the above rules and the struct has a field with tag \",any\",\n     unmarshal maps the sub-element to that struct field.\n\n  * An anonymous struct field is handled as if the fields of its\n     value were part of the outer struct.\n\n  * A struct field with tag \"-\" is never unmarshaled into.\n\nIf Unmarshal encounters a field type that implements the Unmarshaler\ninterface, Unmarshal calls its UnmarshalXML method to produce the value from\nthe XML element.  Otherwise, if the value implements\nencoding.TextUnmarshaler, Unmarshal calls that value's UnmarshalText method.\n\nUnmarshal maps an XML element to a string or []byte by saving the\nconcatenation of that element's character data in the string or\n[]byte. The saved []byte is never nil.\n\nUnmarshal maps an attribute value to a string or []byte by saving\nthe value in the string or slice.\n\nUnmarshal maps an attribute value to an Attr by saving the attribute,\nincluding its name, in the Attr.\n\nUnmarshal maps an XML element or attribute value to a slice by\nextending the length of the slice and mapping the element or attribute\nto the newly created value.\n\nUnmarshal maps an XML element or attribute value to a bool by\nsetting it to the boolean value represented by the string. Whitespace\nis trimmed and ignored.\n\nUnmarshal maps an XML element or attribute value to an integer or\nfloating-point field by setting the field to the result of\ninterpreting the string value in decimal. There is no check for\noverflow. Whitespace is trimmed and ignored.\n\nUnmarshal maps an XML element to a Name by recording the element\nname.\n\nUnmarshal maps an XML element to a pointer by setting the pointer\nto a freshly allocated value and then mapping the element to that value.\n\nA missing element or empty attribute value will be unmarshaled as a zero value.\nIf the field is a slice, a zero value will be appended to the field. Otherwise, the\nfield will be set to its zero value.\n\nGo input arguments: (data []byte, v interface {})\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) data, ^<protocol-or-something> v]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "xml.Unmarshal(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^Object __data, ^<protocol-or-something> __v])

JOKER TYPE go.std.encoding.xml/Attr:
(def
  ^{:doc "An Attr represents an attribute in an XML element (Name=Value).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Attr"}
  Attr)

JOKER TYPE go.std.encoding.xml/CharData:
(def
  ^{:doc "A CharData represents XML character data (raw text),\nin which XML escape sequences have been replaced by\nthe characters they represent.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CharData"}
  CharData)

JOKER TYPE go.std.encoding.xml/Comment:
(def
  ^{:doc "A Comment represents an XML comment of the form <!--comment-->.\nThe bytes do not include the <!-- and --> comment markers.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Comment"}
  Comment)

JOKER TYPE go.std.encoding.xml/Decoder:
(def
  ^{:doc "A Decoder represents an XML parser reading a particular input stream.\nThe parser assumes that its input is encoded in UTF-8.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Decoder"}
  Decoder)

JOKER TYPE go.std.encoding.xml/Directive:
(def
  ^{:doc "A Directive represents an XML directive of the form <!text>.\nThe bytes do not include the <! and > markers.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Directive"}
  Directive)

JOKER TYPE go.std.encoding.xml/Encoder:
(def
  ^{:doc "An Encoder writes XML data to an output stream.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Encoder"}
  Encoder)

JOKER TYPE go.std.encoding.xml/EndElement:
(def
  ^{:doc "An EndElement represents an XML end element.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_EndElement"}
  EndElement)

JOKER TYPE go.std.encoding.xml/Marshaler:
(def
  ^{:doc "Marshaler is the interface implemented by objects that can marshal\nthemselves into valid XML elements.\n\nMarshalXML encodes the receiver as zero or more XML elements.\nBy convention, arrays or slices are typically encoded as a sequence\nof elements, one per entry.\nUsing start as the element tag is not required, but doing so\nwill enable Unmarshal to match the XML elements to the correct\nstruct field.\nOne common implementation strategy is to construct a separate\nvalue with a layout corresponding to the desired XML and then\nto encode it using e.EncodeElement.\nAnother common strategy is to use repeated calls to e.EncodeToken\nto generate the XML output one token at a time.\nThe sequence of encoded tokens must make up zero or more valid\nXML elements.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Marshaler"}
  Marshaler)

JOKER TYPE go.std.encoding.xml/MarshalerAttr:
(def
  ^{:doc "MarshalerAttr is the interface implemented by objects that can marshal\nthemselves into valid XML attributes.\n\nMarshalXMLAttr returns an XML attribute with the encoded value of the receiver.\nUsing name as the attribute name is not required, but doing so\nwill enable Unmarshal to match the attribute to the correct\nstruct field.\nIf MarshalXMLAttr returns the zero attribute Attr{}, no attribute\nwill be generated in the output.\nMarshalXMLAttr is used only for struct fields with the\n\"attr\" option in the field tag.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_MarshalerAttr"}
  MarshalerAttr)

JOKER TYPE go.std.encoding.xml/Name:
(def
  ^{:doc "A Name represents an XML name (Local) annotated\nwith a name space identifier (Space).\nIn tokens returned by Decoder.Token, the Space identifier\nis given as a canonical URL, not the short prefix used\nin the document being parsed.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Name"}
  Name)

JOKER TYPE go.std.encoding.xml/ProcInst:
(def
  ^{:doc "A ProcInst represents an XML processing instruction of the form <?target inst?>\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ProcInst"}
  ProcInst)

JOKER TYPE go.std.encoding.xml/StartElement:
(def
  ^{:doc "A StartElement represents an XML start element.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_StartElement"}
  StartElement)

JOKER TYPE go.std.encoding.xml/SyntaxError:
(def
  ^{:doc "A SyntaxError represents a syntax error in the XML input stream.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SyntaxError"}
  SyntaxError)

JOKER TYPE go.std.encoding.xml/TagPathError:
(def
  ^{:doc "A TagPathError represents an error in the unmarshaling process\ncaused by the use of field tags with conflicting paths.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TagPathError"}
  TagPathError)

JOKER TYPE go.std.encoding.xml/Token:
(def
  ^{:doc "A Token is an interface holding one of the token types:\nStartElement, EndElement, CharData, Comment, ProcInst, or Directive.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Token"}
  Token)

JOKER TYPE go.std.encoding.xml/TokenReader:
(def
  ^{:doc "A TokenReader is anything that can decode a stream of XML tokens, including a\nDecoder.\n\nWhen Token encounters an error or end-of-file condition after successfully\nreading a token, it returns the token. It may return the (non-nil) error from\nthe same call or return the error (and a nil token) from a subsequent call.\nAn instance of this general case is that a TokenReader returning a non-nil\ntoken at the end of the token stream may return either io.EOF or a nil error.\nThe next Read should return nil, io.EOF.\n\nImplementations of Token are discouraged from returning a nil token with a\nnil error. Callers should treat a return of nil, nil as indicating that\nnothing happened; in particular it does not indicate EOF.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TokenReader"}
  TokenReader)

JOKER TYPE go.std.encoding.xml/UnmarshalError:
(def
  ^{:doc "An UnmarshalError represents an error in the unmarshaling process.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnmarshalError"}
  UnmarshalError)

JOKER TYPE go.std.encoding.xml/Unmarshaler:
(def
  ^{:doc "Unmarshaler is the interface implemented by objects that can unmarshal\nan XML element description of themselves.\n\nUnmarshalXML decodes a single XML element\nbeginning with the given start element.\nIf it returns an error, the outer call to Unmarshal stops and\nreturns that error.\nUnmarshalXML must consume exactly one XML element.\nOne common implementation strategy is to unmarshal into\na separate value with a layout matching the expected XML\nusing d.DecodeElement, and then to copy the data from\nthat value into the receiver.\nAnother common strategy is to use d.Token to process the\nXML object one token at a time.\nUnmarshalXML may not use d.RawToken.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Unmarshaler"}
  Unmarshaler)

JOKER TYPE go.std.encoding.xml/UnmarshalerAttr:
(def
  ^{:doc "UnmarshalerAttr is the interface implemented by objects that can unmarshal\nan XML attribute description of themselves.\n\nUnmarshalXMLAttr decodes a single XML attribute.\nIf it returns an error, the outer call to Unmarshal stops and\nreturns that error.\nUnmarshalXMLAttr is used only for struct fields with the\n\"attr\" option in the field tag.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnmarshalerAttr"}
  UnmarshalerAttr)

JOKER TYPE go.std.encoding.xml/UnsupportedTypeError:
(def
  ^{:doc "UnsupportedTypeError is returned when Marshal encounters a type\nthat cannot be converted into XML.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnsupportedTypeError"}
  UnsupportedTypeError)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["encoding/xml"]
    :doc "Provides a low-level interface to the encoding/xml package.\n\nPackage xml implements a simple XML 1.0 parser that\nunderstands XML name spaces.\n"
    :empty false}
  go.std.encoding.xml)
JOKER FUNC errors.New from errors/errors.go:
(defn ^"Error" New
  "New returns an error that formats as the given text.\n\nGo input arguments: (text string)\n\nGo return type: error\n\nJoker input arguments: [^String text]\n\nJoker return type: Error"
  {:added "1.0"
   :go "errors.New(__text)"}
  [^String __text])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["errors"]
    :doc "Provides a low-level interface to the errors package.\n\nPackage errors implements functions to manipulate errors.\n"
    :empty false}
  go.std.errors)
JOKER TYPE expvar.Float from expvar/expvar.go:
(defn ^"GoObject" Float.
  "Constructor for expvar.Float"
  {:added "1.0"
   :go "_ConstructFloat(_v)"}
  [^Object _v])

JOKER TYPE expvar.Func from expvar/expvar.go:
;; (defn ^"GoObject" Func.
;;   "Constructor for expvar.Func"
;;   {:added "1.0"
;;    :go "_ConstructFunc(_v)"}
;;   [^Object _v])

JOKER TYPE expvar.Int from expvar/expvar.go:
(defn ^"GoObject" Int.
  "Constructor for expvar.Int"
  {:added "1.0"
   :go "_ConstructInt(_v)"}
  [^Object _v])

JOKER TYPE expvar.KeyValue from expvar/expvar.go:
;; (defn ^"GoObject" KeyValue.
;;   "Constructor for expvar.KeyValue"
;;   {:added "1.0"
;;    :go "_ConstructKeyValue(_v)"}
;;   [^Object _v])

JOKER TYPE expvar.Map from expvar/expvar.go:
(defn ^"GoObject" Map.
  "Constructor for expvar.Map"
  {:added "1.0"
   :go "_ConstructMap(_v)"}
  [^Object _v])

JOKER TYPE expvar.String from expvar/expvar.go:
(defn ^"GoObject" String.
  "Constructor for expvar.String"
  {:added "1.0"
   :go "_ConstructString(_v)"}
  [^Object _v])

JOKER TYPE expvar.Var from expvar/expvar.go:
;; (defn ^"GoObject" Var.
;;   "Constructor for expvar.Var"
;;   {:added "1.0"
;;    :go "_ConstructVar(_v)"}
;;   [^Object _v])

JOKER FUNC expvar.Do from expvar/expvar.go:
;; (defn Do
;;   "Do calls f for each exported variable.\nThe global variable map is locked during the iteration,\nbut existing entries may be concurrently updated.\n\nGo input arguments: (f func)\n\nJoker input arguments: [^fn f]"
;;   {:added "1.0"
;;    :go "__do(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^fn __f])

JOKER FUNC expvar.Get from expvar/expvar.go:
(defn Get
  "Get retrieves a named exported variable. It returns nil if the name has\nnot been registered.\n\nGo input arguments: (name string)\n\nGo return type: Var\n\nJoker input arguments: [^String name]\n\nJoker return type: go.std.expvar/Var"
  {:added "1.0"
   :go "__get(__name)"}
  [^String __name])

JOKER FUNC expvar.Handler from expvar/expvar.go:
(defn Handler
  "Handler returns the expvar HTTP Handler.\n\nThis is only needed to install the handler in a non-standard location.\n\nGo return type: net/http.Handler\n\nJoker input arguments: []\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__handler()"}
  [])

JOKER FUNC expvar.NewFloat from expvar/expvar.go:
(defn NewFloat
  "Go input arguments: (name string)\n\nGo return type: *Float\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.expvar/Float)"
  {:added "1.0"
   :go "__newFloat(__name)"}
  [^String __name])

JOKER FUNC expvar.NewInt from expvar/expvar.go:
(defn NewInt
  "Go input arguments: (name string)\n\nGo return type: *Int\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.expvar/Int)"
  {:added "1.0"
   :go "__newInt(__name)"}
  [^String __name])

JOKER FUNC expvar.NewMap from expvar/expvar.go:
(defn NewMap
  "Go input arguments: (name string)\n\nGo return type: *Map\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.expvar/Map)"
  {:added "1.0"
   :go "__newMap(__name)"}
  [^String __name])

JOKER FUNC expvar.NewString from expvar/expvar.go:
(defn NewString
  "Go input arguments: (name string)\n\nGo return type: *String\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.expvar/String)"
  {:added "1.0"
   :go "__newString(__name)"}
  [^String __name])

JOKER FUNC expvar.Publish from expvar/expvar.go:
;; (defn Publish
;;   "Publish declares a named exported variable. This should be called from a\npackage's init function when it creates its Vars. If the name is already\nregistered then this will log.Panic.\n\nGo input arguments: (name string, v Var)\n\nJoker input arguments: [^String name, ^go.std.expvar/Var v]"
;;   {:added "1.0"
;;    :go "__publish(__name, *__v)"}
;;   [^String __name, ^expvar/Var __v])

JOKER TYPE go.std.expvar/Float:
(def
  ^{:doc "Float is a 64-bit float variable that satisfies the Var interface.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Float"}
  Float)

JOKER TYPE go.std.expvar/Func:
(def
  ^{:doc "Func implements Var by calling the function\nand formatting the returned value using JSON.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Func"}
  Func)

JOKER TYPE go.std.expvar/Int:
(def
  ^{:doc "Int is a 64-bit integer variable that satisfies the Var interface.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Int"}
  Int)

JOKER TYPE go.std.expvar/KeyValue:
(def
  ^{:doc "KeyValue represents a single entry in a Map.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_KeyValue"}
  KeyValue)

JOKER TYPE go.std.expvar/Map:
(def
  ^{:doc "Map is a string-to-Var map variable that satisfies the Var interface.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Map"}
  Map)

JOKER TYPE go.std.expvar/String:
(def
  ^{:doc "String is a string variable, and satisfies the Var interface.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_String"}
  String)

JOKER TYPE go.std.expvar/Var:
(def
  ^{:doc "Var is an abstract type for all exported variables.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Var"}
  Var)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the expvar package.\n\nPackage expvar provides a standardized interface to public variables, such\nas operation counters in servers. It exposes these variables via HTTP at\n/debug/vars in JSON format.\n\nOperations to set or modify these public variables are atomic.\n\nIn addition to adding the HTTP handler, this package registers the\nfollowing variables:\n\n\tcmdline   os.Args\n\tmemstats  runtime.Memstats\n\nThe package is sometimes only imported for the side effect of\nregistering its HTTP handler and the above variables. To use it\nthis way, link this package into your program:\n\timport _ \"expvar\"\n"
    :empty false}
  go.std.expvar)
JOKER CONSTANT ContinueOnError from flag/flag.go:
(def
  ^{:doc "Return a descriptive error.\n"
    :added "1.0"
    :tag "Int"
    :go "int(flag.ContinueOnError)"}
  ContinueOnError)

JOKER CONSTANT ExitOnError from flag/flag.go:
(def
  ^{:doc "Call os.Exit(2).\n"
    :added "1.0"
    :tag "Int"
    :go "int(flag.ExitOnError)"}
  ExitOnError)

JOKER CONSTANT PanicOnError from flag/flag.go:
(def
  ^{:doc "Call panic with a descriptive error.\n"
    :added "1.0"
    :tag "Int"
    :go "int(flag.PanicOnError)"}
  PanicOnError)

JOKER VARIABLE CommandLine from flag/flag.go:
(def
  ^{:doc "CommandLine is the default set of command-line flags, parsed from os.Args.\nThe top-level functions such as BoolVar, Arg, and so on are wrappers for the\nmethods of CommandLine.\n"
    :added "1.0"
    :tag "Var"
    :go "flag.CommandLine"}
  CommandLine)

JOKER VARIABLE ErrHelp from flag/flag.go:
(def
  ^{:doc "ErrHelp is the error returned if the -help or -h flag is invoked\nbut no such flag is defined.\n"
    :added "1.0"
    :tag "Var"
    :go "flag.ErrHelp"}
  ErrHelp)

JOKER VARIABLE Usage from flag/flag.go:
(def
  ^{:doc "Usage prints a usage message documenting all defined command-line flags\nto CommandLine's output, which by default is os.Stderr.\nIt is called when an error occurs while parsing flags.\nThe function is a variable that may be changed to point to a custom function.\nBy default it prints a simple header and calls PrintDefaults; for details about the\nformat of the output and how to control it, see the documentation for PrintDefaults.\nCustom usage functions may choose to exit the program; by default exiting\nhappens anyway as the command line's error handling strategy is set to\nExitOnError.\n"
    :added "1.0"
    :tag "Var"
    :go "flag.Usage"}
  Usage)

JOKER TYPE flag.ErrorHandling from flag/flag.go:
(defn ^"GoObject" ErrorHandling.
  "Constructor for flag.ErrorHandling"
  {:added "1.0"
   :go "_ConstructErrorHandling(_v)"}
  [^Object _v])

JOKER TYPE flag.Flag from flag/flag.go:
;; (defn ^"GoObject" Flag.
;;   "Constructor for flag.Flag"
;;   {:added "1.0"
;;    :go "_ConstructFlag(_v)"}
;;   [^Object _v])

JOKER TYPE flag.FlagSet from flag/flag.go:
;; (defn ^"GoObject" FlagSet.
;;   "Constructor for flag.FlagSet"
;;   {:added "1.0"
;;    :go "_ConstructFlagSet(_v)"}
;;   [^Object _v])

JOKER TYPE flag.Getter from flag/flag.go:
;; (defn ^"GoObject" Getter.
;;   "Constructor for flag.Getter"
;;   {:added "1.0"
;;    :go "_ConstructGetter(_v)"}
;;   [^Object _v])

JOKER TYPE flag.Value from flag/flag.go:
;; (defn ^"GoObject" Value.
;;   "Constructor for flag.Value"
;;   {:added "1.0"
;;    :go "_ConstructValue(_v)"}
;;   [^Object _v])

JOKER FUNC flag.Arg from flag/flag.go:
(defn ^"String" Arg
  "Arg returns the i'th command-line argument. Arg(0) is the first remaining argument\nafter flags have been processed. Arg returns an empty string if the\nrequested element does not exist.\n\nGo input arguments: (i int)\n\nGo return type: string\n\nJoker input arguments: [^Int i]\n\nJoker return type: String"
  {:added "1.0"
   :go "flag.Arg(__i)"}
  [^Int __i])

JOKER FUNC flag.Args from flag/flag.go:
(defn Args
  "Args returns the non-flag command-line arguments.\n\nGo return type: []string\n\nJoker input arguments: []\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__args()"}
  [])

JOKER FUNC flag.Bool from flag/flag.go:
(defn Bool
  "Bool defines a bool flag with specified name, default value, and usage string.\nThe return value is the address of a bool variable that stores the value of the flag.\n\nGo input arguments: (name string, value bool, usage string)\n\nGo return type: *bool\n\nJoker input arguments: [^String name, ^Boolean value, ^String usage]\n\nJoker return type: (atom-of Boolean)"
  {:added "1.0"
   :go "__bool(__name, __value, __usage)"}
  [^String __name, ^Boolean __value, ^String __usage])

JOKER FUNC flag.BoolVar from flag/flag.go:
;; (defn BoolVar
;;   "BoolVar defines a bool flag with specified name, default value, and usage string.\nThe argument p points to a bool variable in which to store the value of the flag.\n\nGo input arguments: (p *bool, name string, value bool, usage string)\n\nJoker input arguments: [^(atom-of Boolean) p, ^String name, ^Boolean value, ^String usage]"
;;   {:added "1.0"
;;    :go "__boolVar(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfbool(__p)), __name, __value, __usage)"}
;;   [^Object __p, ^String __name, ^Boolean __value, ^String __usage])

JOKER FUNC flag.Duration from flag/flag.go:
;; (defn Duration
;;   "Duration defines a time.Duration flag with specified name, default value, and usage string.\nThe return value is the address of a time.Duration variable that stores the value of the flag.\nThe flag accepts a value acceptable to time.ParseDuration.\n\nGo input arguments: (name string, value time.Duration, usage string)\n\nGo return type: *time.Duration\n\nJoker input arguments: [^String name, ^go.std.time/Duration value, ^String usage]\n\nJoker return type: (atom-of go.std.time/Duration)"
;;   {:added "1.0"
;;    :go "__duration(__name, *__value, __usage)"}
;;   [^String __name, ^time/Duration __value, ^String __usage])

JOKER FUNC flag.DurationVar from flag/flag.go:
;; (defn DurationVar
;;   "DurationVar defines a time.Duration flag with specified name, default value, and usage string.\nThe argument p points to a time.Duration variable in which to store the value of the flag.\nThe flag accepts a value acceptable to time.ParseDuration.\n\nGo input arguments: (p *time.Duration, name string, value time.Duration, usage string)\n\nJoker input arguments: [^(atom-of go.std.time/Duration) p, ^String name, ^go.std.time/Duration value, ^String usage]"
;;   {:added "1.0"
;;    :go "__durationVar(__p, __name, *__value, __usage)"}
;;   [^time/Duration __p, ^String __name, ^time/Duration __value, ^String __usage])

JOKER FUNC flag.Float64 from flag/flag.go:
;; (defn Float64
;;   "Float64 defines a float64 flag with specified name, default value, and usage string.\nThe return value is the address of a float64 variable that stores the value of the flag.\n\nGo input arguments: (name string, value float64, usage string)\n\nGo return type: *float64\n\nJoker input arguments: [^String name, ^Double value, ^String usage]\n\nJoker return type: (atom-of Double)"
;;   {:added "1.0"
;;    :go "__float64(__name, __value, __usage)"}
;;   [^String __name, ^ABEND007(find these) __value, ^String __usage])

JOKER FUNC flag.Float64Var from flag/flag.go:
;; (defn Float64Var
;;   "Float64Var defines a float64 flag with specified name, default value, and usage string.\nThe argument p points to a float64 variable in which to store the value of the flag.\n\nGo input arguments: (p *float64, name string, value float64, usage string)\n\nJoker input arguments: [^(atom-of Double) p, ^String name, ^Double value, ^String usage]"
;;   {:added "1.0"
;;    :go "__float64Var(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOffloat64(__p)), __name, __value, __usage)"}
;;   [^Object __p, ^String __name, ^ABEND007(find these) __value, ^String __usage])

JOKER FUNC flag.Int from flag/flag.go:
(defn Int
  "Int defines an int flag with specified name, default value, and usage string.\nThe return value is the address of an int variable that stores the value of the flag.\n\nGo input arguments: (name string, value int, usage string)\n\nGo return type: *int\n\nJoker input arguments: [^String name, ^Int value, ^String usage]\n\nJoker return type: (atom-of Int)"
  {:added "1.0"
   :go "__int(__name, __value, __usage)"}
  [^String __name, ^Int __value, ^String __usage])

JOKER FUNC flag.Int64 from flag/flag.go:
(defn Int64
  "Int64 defines an int64 flag with specified name, default value, and usage string.\nThe return value is the address of an int64 variable that stores the value of the flag.\n\nGo input arguments: (name string, value int64, usage string)\n\nGo return type: *int64\n\nJoker input arguments: [^String name, ^Number value, ^String usage]\n\nJoker return type: (atom-of Number)"
  {:added "1.0"
   :go "__int64(__name, __value, __usage)"}
  [^String __name, ^Int64 __value, ^String __usage])

JOKER FUNC flag.Int64Var from flag/flag.go:
;; (defn Int64Var
;;   "Int64Var defines an int64 flag with specified name, default value, and usage string.\nThe argument p points to an int64 variable in which to store the value of the flag.\n\nGo input arguments: (p *int64, name string, value int64, usage string)\n\nJoker input arguments: [^(atom-of Number) p, ^String name, ^Number value, ^String usage]"
;;   {:added "1.0"
;;    :go "__int64Var(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(__p)), __name, __value, __usage)"}
;;   [^Object __p, ^String __name, ^Int64 __value, ^String __usage])

JOKER FUNC flag.IntVar from flag/flag.go:
;; (defn IntVar
;;   "IntVar defines an int flag with specified name, default value, and usage string.\nThe argument p points to an int variable in which to store the value of the flag.\n\nGo input arguments: (p *int, name string, value int, usage string)\n\nJoker input arguments: [^(atom-of Int) p, ^String name, ^Int value, ^String usage]"
;;   {:added "1.0"
;;    :go "__intVar(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint(__p)), __name, __value, __usage)"}
;;   [^Object __p, ^String __name, ^Int __value, ^String __usage])

JOKER FUNC flag.Lookup from flag/flag.go:
(defn Lookup
  "Lookup returns the Flag structure of the named command-line flag,\nreturning nil if none exists.\n\nGo input arguments: (name string)\n\nGo return type: *Flag\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.flag/Flag)"
  {:added "1.0"
   :go "__lookup(__name)"}
  [^String __name])

JOKER FUNC flag.NArg from flag/flag.go:
(defn ^"Int" NArg
  "NArg is the number of arguments remaining after flags have been processed.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "flag.NArg()"}
  [])

JOKER FUNC flag.NFlag from flag/flag.go:
(defn ^"Int" NFlag
  "NFlag returns the number of command-line flags that have been set.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "flag.NFlag()"}
  [])

JOKER FUNC flag.NewFlagSet from flag/flag.go:
(defn NewFlagSet
  "NewFlagSet returns a new, empty flag set with the specified name and\nerror handling property. If the name is not empty, it will be printed\nin the default usage message and in error messages.\n\nGo input arguments: (name string, errorHandling ErrorHandling)\n\nGo return type: *FlagSet\n\nJoker input arguments: [^String name, ^go.std.flag/ErrorHandling errorHandling]\n\nJoker return type: (atom-of go.std.flag/FlagSet)"
  {:added "1.0"
   :go "__newFlagSet(__name, *__errorHandling)"}
  [^String __name, ^flag/ErrorHandling __errorHandling])

JOKER FUNC flag.Parse from flag/flag.go:
;; (defn Parse
;;   "Parse parses the command-line flags from os.Args[1:]. Must be called\nafter all flags are defined and before flags are accessed by the program.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__parse()"}
;;   [])

JOKER FUNC flag.Parsed from flag/flag.go:
(defn ^"Boolean" Parsed
  "Parsed reports whether the command-line flags have been parsed.\n\nGo return type: bool\n\nJoker input arguments: []\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "flag.Parsed()"}
  [])

JOKER FUNC flag.PrintDefaults from flag/flag.go:
;; (defn PrintDefaults
;;   "PrintDefaults prints, to standard error unless configured otherwise,\na usage message showing the default settings of all defined\ncommand-line flags.\nFor an integer valued flag x, the default output has the form\n\t-x int\n\t\tusage-message-for-x (default 7)\nThe usage message will appear on a separate line for anything but\na bool flag with a one-byte name. For bool flags, the type is\nomitted and if the flag name is one byte the usage message appears\non the same line. The parenthetical default is omitted if the\ndefault is the zero value for the type. The listed type, here int,\ncan be changed by placing a back-quoted name in the flag's usage\nstring; the first such item in the message is taken to be a parameter\nname to show in the message and the back quotes are stripped from\nthe message when displayed. For instance, given\n\tflag.String(\"I\", \"\", \"search `directory` for include files\")\nthe output will be\n\t-I directory\n\t\tsearch directory for include files.\n\nTo change the destination for flag messages, call CommandLine.SetOutput.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__printDefaults()"}
;;   [])

JOKER FUNC flag.Set from flag/flag.go:
(defn ^"Error" Set
  "Set sets the value of the named command-line flag.\n\nGo input arguments: (name string, value string)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^String value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "flag.Set(__name, __value)"}
  [^String __name, ^String __value])

JOKER FUNC flag.String from flag/flag.go:
(defn String
  "String defines a string flag with specified name, default value, and usage string.\nThe return value is the address of a string variable that stores the value of the flag.\n\nGo input arguments: (name string, value string, usage string)\n\nGo return type: *string\n\nJoker input arguments: [^String name, ^String value, ^String usage]\n\nJoker return type: (atom-of String)"
  {:added "1.0"
   :go "__string(__name, __value, __usage)"}
  [^String __name, ^String __value, ^String __usage])

JOKER FUNC flag.StringVar from flag/flag.go:
;; (defn StringVar
;;   "StringVar defines a string flag with specified name, default value, and usage string.\nThe argument p points to a string variable in which to store the value of the flag.\n\nGo input arguments: (p *string, name string, value string, usage string)\n\nJoker input arguments: [^(atom-of String) p, ^String name, ^String value, ^String usage]"
;;   {:added "1.0"
;;    :go "__stringVar(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfstring(__p)), __name, __value, __usage)"}
;;   [^Object __p, ^String __name, ^String __value, ^String __usage])

JOKER FUNC flag.Uint from flag/flag.go:
(defn Uint
  "Uint defines a uint flag with specified name, default value, and usage string.\nThe return value is the address of a uint variable that stores the value of the flag.\n\nGo input arguments: (name string, value uint, usage string)\n\nGo return type: *uint\n\nJoker input arguments: [^String name, ^Number value, ^String usage]\n\nJoker return type: (atom-of Number)"
  {:added "1.0"
   :go "__uint(__name, __value, __usage)"}
  [^String __name, ^UInt __value, ^String __usage])

JOKER FUNC flag.Uint64 from flag/flag.go:
(defn Uint64
  "Uint64 defines a uint64 flag with specified name, default value, and usage string.\nThe return value is the address of a uint64 variable that stores the value of the flag.\n\nGo input arguments: (name string, value uint64, usage string)\n\nGo return type: *uint64\n\nJoker input arguments: [^String name, ^Number value, ^String usage]\n\nJoker return type: (atom-of Number)"
  {:added "1.0"
   :go "__uint64(__name, __value, __usage)"}
  [^String __name, ^UInt64 __value, ^String __usage])

JOKER FUNC flag.Uint64Var from flag/flag.go:
;; (defn Uint64Var
;;   "Uint64Var defines a uint64 flag with specified name, default value, and usage string.\nThe argument p points to a uint64 variable in which to store the value of the flag.\n\nGo input arguments: (p *uint64, name string, value uint64, usage string)\n\nJoker input arguments: [^(atom-of Number) p, ^String name, ^Number value, ^String usage]"
;;   {:added "1.0"
;;    :go "__uint64Var(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint64(__p)), __name, __value, __usage)"}
;;   [^Object __p, ^String __name, ^UInt64 __value, ^String __usage])

JOKER FUNC flag.UintVar from flag/flag.go:
;; (defn UintVar
;;   "UintVar defines a uint flag with specified name, default value, and usage string.\nThe argument p points to a uint variable in which to store the value of the flag.\n\nGo input arguments: (p *uint, name string, value uint, usage string)\n\nJoker input arguments: [^(atom-of Number) p, ^String name, ^Number value, ^String usage]"
;;   {:added "1.0"
;;    :go "__uintVar(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint(__p)), __name, __value, __usage)"}
;;   [^Object __p, ^String __name, ^UInt __value, ^String __usage])

JOKER FUNC flag.UnquoteUsage from flag/flag.go:
(defn UnquoteUsage
  "UnquoteUsage extracts a back-quoted name from the usage\nstring for a flag and returns it and the un-quoted usage.\nGiven \"a `name` to show\" it returns (\"name\", \"a name to show\").\nIf there are no back quotes, the name is an educated guess of the\ntype of the flag's value, or the empty string if the flag is boolean.\n\nGo input arguments: (flag *Flag)\n\nGo return type: (name string, usage string)\n\nJoker input arguments: [^(atom-of go.std.flag/Flag) flag]\n\nJoker return type: [String String]"
  {:added "1.0"
   :go "__unquoteUsage(__flag)"}
  [^flag/Flag __flag])

JOKER FUNC flag.Var from flag/flag.go:
;; (defn Var
;;   "Var defines a flag with the specified name and usage string. The type and\nvalue of the flag are represented by the first argument, of type Value, which\ntypically holds a user-defined implementation of Value. For instance, the\ncaller could create a flag that turns a comma-separated string into a slice\nof strings by giving the slice the methods of Value; in particular, Set would\ndecompose the comma-separated string into the slice.\n\nGo input arguments: (value Value, name string, usage string)\n\nJoker input arguments: [^go.std.flag/Value value, ^String name, ^String usage]"
;;   {:added "1.0"
;;    :go "__var(*__value, __name, __usage)"}
;;   [^flag/Value __value, ^String __name, ^String __usage])

JOKER FUNC flag.Visit from flag/flag.go:
;; (defn Visit
;;   "Visit visits the command-line flags in lexicographical order, calling fn\nfor each. It visits only those flags that have been set.\n\nGo input arguments: (fn func)\n\nJoker input arguments: [^fn fn]"
;;   {:added "1.0"
;;    :go "__visit(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^fn __fn])

JOKER FUNC flag.VisitAll from flag/flag.go:
;; (defn VisitAll
;;   "VisitAll visits the command-line flags in lexicographical order, calling\nfn for each. It visits all flags, even those not set.\n\nGo input arguments: (fn func)\n\nJoker input arguments: [^fn fn]"
;;   {:added "1.0"
;;    :go "__visitAll(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^fn __fn])

JOKER TYPE go.std.flag/ErrorHandling:
(def
  ^{:doc "ErrorHandling defines how FlagSet.Parse behaves if the parse fails.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ErrorHandling"}
  ErrorHandling)

JOKER TYPE go.std.flag/Flag:
(def
  ^{:doc "A Flag represents the state of a flag.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Flag"}
  Flag)

JOKER TYPE go.std.flag/FlagSet:
(def
  ^{:doc "A FlagSet represents a set of defined flags. The zero value of a FlagSet\nhas no name and has ContinueOnError error handling.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FlagSet"}
  FlagSet)

JOKER TYPE go.std.flag/Getter:
(def
  ^{:doc "Getter is an interface that allows the contents of a Value to be retrieved.\nIt wraps the Value interface, rather than being part of it, because it\nappeared after Go 1 and its compatibility rules. All Value types provided\nby this package satisfy the Getter interface.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Getter"}
  Getter)

JOKER TYPE go.std.flag/Value:
(def
  ^{:doc "Value is the interface to the dynamic value stored in a flag.\n(The default value is represented as a string.)\n\nIf a Value has an IsBoolFlag() bool method returning true,\nthe command-line parser makes -name equivalent to -name=true\nrather than using the next command-line argument.\n\nSet is called once, in command line order, for each flag present.\nThe flag package may call the String method with a zero-valued receiver,\nsuch as a nil pointer.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Value"}
  Value)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["flag"]
    :doc "Provides a low-level interface to the flag package.\n\n\tPackage flag implements command-line flag parsing.\n\n\tUsage\n\n\tDefine flags using flag.String(), Bool(), Int(), etc.\n\n\tThis declares an integer flag, -flagname, stored in the pointer ip, with type *int.\n\t\timport \"flag\"\n\t\tvar ip = flag.Int(\"flagname\", 1234, \"help message for flagname\")\n\tIf you like, you can bind the flag to a variable using the Var() functions.\n\t\tvar flagvar int\n\t\tfunc init() {\n\t\t\tflag.IntVar(&flagvar, \"flagname\", 1234, \"help message for flagname\")\n\t\t}\n\tOr you can create custom flags that satisfy the Value interface (with\n\tpointer receivers) and couple them to flag parsing by\n\t\tflag.Var(&flagVal, \"name\", \"help message for flagname\")\n\tFor such flags, the default value is just the initial value of the variable.\n\n\tAfter all flags are defined, call\n\t\tflag.Parse()\n\tto parse the command line into the defined flags.\n\n\tFlags may then be used directly. If you're using the flags themselves,\n\tthey are all pointers; if you bind to variables, they're values.\n\t\tfmt.Println(\"ip has value \", *ip)\n\t\tfmt.Println(\"flagvar has value \", flagvar)\n\n\tAfter parsing, the arguments following the flags are available as the\n\tslice flag.Args() or individually as flag.Arg(i).\n\tThe arguments are indexed from 0 through flag.NArg()-1.\n\n\tCommand line flag syntax\n\n\tThe following forms are permitted:\n\n\t\t-flag\n\t\t-flag=x\n\t\t-flag x  // non-boolean flags only\n\tOne or two minus signs may be used; they are equivalent.\n\tThe last form is not permitted for boolean flags because the\n\tmeaning of the command\n\t\tcmd -x *\n\twhere * is a Unix shell wildcard, will change if there is a file\n\tcalled 0, false, etc. You must use the -flag=false form to turn\n\toff a boolean flag.\n\n\tFlag parsing stops just before the first non-flag argument\n\t(\"-\" is a non-flag argument) or after the terminator \"--\".\n\n\tInteger flags accept 1234, 0664, 0x1234 and may be negative.\n\tBoolean flags may be:\n\t\t1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False\n\tDuration flags accept any input valid for time.ParseDuration.\n\n\tThe default set of command-line flags is controlled by\n\ttop-level functions.  The FlagSet type allows one to define\n\tindependent sets of flags, such as to implement subcommands\n\tin a command-line interface. The methods of FlagSet are\n\tanalogous to the top-level functions for the command-line\n\tflag set.\n"
    :empty false}
  go.std.flag)
JOKER FUNC fmt.Errorf from fmt/print.go:
;; (defn ^"Error" Errorf
;;   "Errorf formats according to a format specifier and returns the string\nas a value that satisfies error.\n\nGo input arguments: (format string, a ...interface {})\n\nGo return type: error\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "fmt.Errorf(__format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String __format, ^<protocol-or-something> __a])

JOKER FUNC fmt.Fprint from fmt/print.go:
;; (defn Fprint
;;   "Fprint formats using the default formats for its operands and writes to w.\nSpaces are added between operands when neither is a string.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (w io.Writer, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Writer w, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__fprint(*__w, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io/Writer __w, ^<protocol-or-something> __a])

JOKER FUNC fmt.Fprintf from fmt/print.go:
;; (defn Fprintf
;;   "Fprintf formats according to a format specifier and writes to w.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (w io.Writer, format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Writer w, ^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__fprintf(*__w, __format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io/Writer __w, ^String __format, ^<protocol-or-something> __a])

JOKER FUNC fmt.Fprintln from fmt/print.go:
;; (defn Fprintln
;;   "Fprintln formats using the default formats for its operands and writes to w.\nSpaces are always added between operands and a newline is appended.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (w io.Writer, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Writer w, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__fprintln(*__w, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io/Writer __w, ^<protocol-or-something> __a])

JOKER FUNC fmt.Fscan from fmt/scan.go:
;; (defn Fscan
;;   "Fscan scans text read from r, storing successive space-separated\nvalues into successive arguments. Newlines count as space. It\nreturns the number of items successfully scanned. If that is less\nthan the number of arguments, err will report why.\n\nGo input arguments: (r io.Reader, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Reader r, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__fscan(*__r, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io/Reader __r, ^<protocol-or-something> __a])

JOKER FUNC fmt.Fscanf from fmt/scan.go:
;; (defn Fscanf
;;   "Fscanf scans text read from r, storing successive space-separated\nvalues into successive arguments as determined by the format. It\nreturns the number of items successfully parsed.\nNewlines in the input must match newlines in the format.\n\nGo input arguments: (r io.Reader, format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Reader r, ^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__fscanf(*__r, __format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io/Reader __r, ^String __format, ^<protocol-or-something> __a])

JOKER FUNC fmt.Fscanln from fmt/scan.go:
;; (defn Fscanln
;;   "Fscanln is similar to Fscan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\n\nGo input arguments: (r io.Reader, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Reader r, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__fscanln(*__r, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io/Reader __r, ^<protocol-or-something> __a])

JOKER FUNC fmt.Print from fmt/print.go:
;; (defn Print
;;   "Print formats using the default formats for its operands and writes to standard output.\nSpaces are added between operands when neither is a string.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__print(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> __a])

JOKER FUNC fmt.Printf from fmt/print.go:
;; (defn Printf
;;   "Printf formats according to a format specifier and writes to standard output.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__printf(__format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String __format, ^<protocol-or-something> __a])

JOKER FUNC fmt.Println from fmt/print.go:
;; (defn Println
;;   "Println formats using the default formats for its operands and writes to standard output.\nSpaces are always added between operands and a newline is appended.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__println(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> __a])

JOKER FUNC fmt.Scan from fmt/scan.go:
;; (defn Scan
;;   "Scan scans text read from standard input, storing successive\nspace-separated values into successive arguments. Newlines count\nas space. It returns the number of items successfully scanned.\nIf that is less than the number of arguments, err will report why.\n\nGo input arguments: (a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__scan(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> __a])

JOKER FUNC fmt.Scanf from fmt/scan.go:
;; (defn Scanf
;;   "Scanf scans text read from standard input, storing successive\nspace-separated values into successive arguments as determined by\nthe format. It returns the number of items successfully scanned.\nIf that is less than the number of arguments, err will report why.\nNewlines in the input must match newlines in the format.\nThe one exception: the verb %c always scans the next rune in the\ninput, even if it is a space (or tab etc.) or newline.\n\nGo input arguments: (format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__scanf(__format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String __format, ^<protocol-or-something> __a])

JOKER FUNC fmt.Scanln from fmt/scan.go:
;; (defn Scanln
;;   "Scanln is similar to Scan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\n\nGo input arguments: (a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__scanln(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> __a])

JOKER FUNC fmt.Sprint from fmt/print.go:
;; (defn ^"String" Sprint
;;   "Sprint formats using the default formats for its operands and returns the resulting string.\nSpaces are added between operands when neither is a string.\n\nGo input arguments: (a ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "fmt.Sprint(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> __a])

JOKER FUNC fmt.Sprintf from fmt/print.go:
;; (defn ^"String" Sprintf
;;   "Sprintf formats according to a format specifier and returns the resulting string.\n\nGo input arguments: (format string, a ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "fmt.Sprintf(__format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String __format, ^<protocol-or-something> __a])

JOKER FUNC fmt.Sprintln from fmt/print.go:
;; (defn ^"String" Sprintln
;;   "Sprintln formats using the default formats for its operands and returns the resulting string.\nSpaces are always added between operands and a newline is appended.\n\nGo input arguments: (a ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "fmt.Sprintln(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> __a])

JOKER FUNC fmt.Sscan from fmt/scan.go:
;; (defn Sscan
;;   "Sscan scans the argument string, storing successive space-separated\nvalues into successive arguments. Newlines count as space. It\nreturns the number of items successfully scanned. If that is less\nthan the number of arguments, err will report why.\n\nGo input arguments: (str string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String str, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__sscan(__str, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String __str, ^<protocol-or-something> __a])

JOKER FUNC fmt.Sscanf from fmt/scan.go:
;; (defn Sscanf
;;   "Sscanf scans the argument string, storing successive space-separated\nvalues into successive arguments as determined by the format. It\nreturns the number of items successfully parsed.\nNewlines in the input must match newlines in the format.\n\nGo input arguments: (str string, format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String str, ^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__sscanf(__str, __format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String __str, ^String __format, ^<protocol-or-something> __a])

JOKER FUNC fmt.Sscanln from fmt/scan.go:
;; (defn Sscanln
;;   "Sscanln is similar to Sscan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\n\nGo input arguments: (str string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String str, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__sscanln(__str, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String __str, ^<protocol-or-something> __a])

JOKER TYPE go.std.fmt/Formatter:
(def
  ^{:doc "Formatter is the interface implemented by values with a custom formatter.\nThe implementation of Format may call Sprint(f) or Fprint(f) etc.\nto generate its output.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Formatter"}
  Formatter)

JOKER TYPE go.std.fmt/GoStringer:
(def
  ^{:doc "GoStringer is implemented by any value that has a GoString method,\nwhich defines the Go syntax for that value.\nThe GoString method is used to print values passed as an operand\nto a %#v format.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_GoStringer"}
  GoStringer)

JOKER TYPE go.std.fmt/ScanState:
(def
  ^{:doc "ScanState represents the scanner state passed to custom scanners.\nScanners may do rune-at-a-time scanning or ask the ScanState\nto discover the next space-delimited token.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ScanState"}
  ScanState)

JOKER TYPE go.std.fmt/Scanner:
(def
  ^{:doc "Scanner is implemented by any value that has a Scan method, which scans\nthe input for the representation of a value and stores the result in the\nreceiver, which must be a pointer to be useful. The Scan method is called\nfor any argument to Scan, Scanf, or Scanln that implements it.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Scanner"}
  Scanner)

JOKER TYPE go.std.fmt/State:
(def
  ^{:doc "State represents the printer state passed to custom formatters.\nIt provides access to the io.Writer interface plus information about\nthe flags and options for the operand's format specifier.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_State"}
  State)

JOKER TYPE go.std.fmt/Stringer:
(def
  ^{:doc "Stringer is implemented by any value that has a String method,\nwhich defines the ``native'' format for that value.\nThe String method is used to print values passed as an operand\nto any format that accepts a string or to an unformatted printer\nsuch as Print.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Stringer"}
  Stringer)

JOKER CONSTANT Bad from go/ast/scope.go:
(def
  ^{:doc "for error handling\n"
    :added "1.0"
    :tag "Int"
    :go "int(ast.Bad)"}
  Bad)

JOKER CONSTANT Con from go/ast/scope.go:
(def
  ^{:doc "constant\n"
    :added "1.0"
    :tag "Int"
    :go "int(ast.Con)"}
  Con)

JOKER CONSTANT FilterFuncDuplicates from go/ast/filter.go:
(def
  ^{:doc "If set, duplicate function declarations are excluded.\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(ast.FilterFuncDuplicates))"}
  FilterFuncDuplicates)

JOKER CONSTANT FilterImportDuplicates from go/ast/filter.go:
(def
  ^{:doc "If set, duplicate import declarations are excluded.\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(ast.FilterImportDuplicates))"}
  FilterImportDuplicates)

JOKER CONSTANT FilterUnassociatedComments from go/ast/filter.go:
(def
  ^{:doc "If set, comments that are not associated with a specific\nAST node (as Doc or Comment) are excluded.\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(ast.FilterUnassociatedComments))"}
  FilterUnassociatedComments)

JOKER CONSTANT Fun from go/ast/scope.go:
(def
  ^{:doc "function or method\n"
    :added "1.0"
    :tag "Int"
    :go "int(ast.Fun)"}
  Fun)

JOKER CONSTANT Lbl from go/ast/scope.go:
(def
  ^{:doc "label\n"
    :added "1.0"
    :tag "Int"
    :go "int(ast.Lbl)"}
  Lbl)

JOKER CONSTANT Pkg from go/ast/scope.go:
(def
  ^{:doc "package\n"
    :added "1.0"
    :tag "Int"
    :go "int(ast.Pkg)"}
  Pkg)

JOKER CONSTANT RECV from go/ast/ast.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(ast.RECV)"}
  RECV)

JOKER CONSTANT SEND from go/ast/ast.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(ast.SEND)"}
  SEND)

JOKER CONSTANT Typ from go/ast/scope.go:
(def
  ^{:doc "type\n"
    :added "1.0"
    :tag "Int"
    :go "int(ast.Typ)"}
  Typ)

JOKER CONSTANT Var from go/ast/scope.go:
(def
  ^{:doc "variable\n"
    :added "1.0"
    :tag "Int"
    :go "int(ast.Var)"}
  Var)

JOKER TYPE go/ast.ArrayType from go/ast/ast.go:
;; (defn ^"GoObject" ArrayType.
;;   "Constructor for ast.ArrayType"
;;   {:added "1.0"
;;    :go "_ConstructArrayType(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.AssignStmt from go/ast/ast.go:
;; (defn ^"GoObject" AssignStmt.
;;   "Constructor for ast.AssignStmt"
;;   {:added "1.0"
;;    :go "_ConstructAssignStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.BadDecl from go/ast/ast.go:
;; (defn ^"GoObject" BadDecl.
;;   "Constructor for ast.BadDecl"
;;   {:added "1.0"
;;    :go "_ConstructBadDecl(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.BadExpr from go/ast/ast.go:
;; (defn ^"GoObject" BadExpr.
;;   "Constructor for ast.BadExpr"
;;   {:added "1.0"
;;    :go "_ConstructBadExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.BadStmt from go/ast/ast.go:
;; (defn ^"GoObject" BadStmt.
;;   "Constructor for ast.BadStmt"
;;   {:added "1.0"
;;    :go "_ConstructBadStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.BasicLit from go/ast/ast.go:
;; (defn ^"GoObject" BasicLit.
;;   "Constructor for ast.BasicLit"
;;   {:added "1.0"
;;    :go "_ConstructBasicLit(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.BinaryExpr from go/ast/ast.go:
;; (defn ^"GoObject" BinaryExpr.
;;   "Constructor for ast.BinaryExpr"
;;   {:added "1.0"
;;    :go "_ConstructBinaryExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.BlockStmt from go/ast/ast.go:
;; (defn ^"GoObject" BlockStmt.
;;   "Constructor for ast.BlockStmt"
;;   {:added "1.0"
;;    :go "_ConstructBlockStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.BranchStmt from go/ast/ast.go:
;; (defn ^"GoObject" BranchStmt.
;;   "Constructor for ast.BranchStmt"
;;   {:added "1.0"
;;    :go "_ConstructBranchStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.CallExpr from go/ast/ast.go:
;; (defn ^"GoObject" CallExpr.
;;   "Constructor for ast.CallExpr"
;;   {:added "1.0"
;;    :go "_ConstructCallExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.CaseClause from go/ast/ast.go:
;; (defn ^"GoObject" CaseClause.
;;   "Constructor for ast.CaseClause"
;;   {:added "1.0"
;;    :go "_ConstructCaseClause(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.ChanDir from go/ast/ast.go:
(defn ^"GoObject" ChanDir.
  "Constructor for ast.ChanDir"
  {:added "1.0"
   :go "_ConstructChanDir(_v)"}
  [^Object _v])

JOKER TYPE go/ast.ChanType from go/ast/ast.go:
;; (defn ^"GoObject" ChanType.
;;   "Constructor for ast.ChanType"
;;   {:added "1.0"
;;    :go "_ConstructChanType(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.CommClause from go/ast/ast.go:
;; (defn ^"GoObject" CommClause.
;;   "Constructor for ast.CommClause"
;;   {:added "1.0"
;;    :go "_ConstructCommClause(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Comment from go/ast/ast.go:
;; (defn ^"GoObject" Comment.
;;   "Constructor for ast.Comment"
;;   {:added "1.0"
;;    :go "_ConstructComment(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.CommentGroup from go/ast/ast.go:
;; (defn ^"GoObject" CommentGroup.
;;   "Constructor for ast.CommentGroup"
;;   {:added "1.0"
;;    :go "_ConstructCommentGroup(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.CommentMap from go/ast/commentmap.go:
;; (defn ^"GoObject" CommentMap.
;;   "Constructor for ast.CommentMap"
;;   {:added "1.0"
;;    :go "_ConstructCommentMap(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.CompositeLit from go/ast/ast.go:
;; (defn ^"GoObject" CompositeLit.
;;   "Constructor for ast.CompositeLit"
;;   {:added "1.0"
;;    :go "_ConstructCompositeLit(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Decl from go/ast/ast.go:
;; (defn ^"GoObject" Decl.
;;   "Constructor for ast.Decl"
;;   {:added "1.0"
;;    :go "_ConstructDecl(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.DeclStmt from go/ast/ast.go:
;; (defn ^"GoObject" DeclStmt.
;;   "Constructor for ast.DeclStmt"
;;   {:added "1.0"
;;    :go "_ConstructDeclStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.DeferStmt from go/ast/ast.go:
;; (defn ^"GoObject" DeferStmt.
;;   "Constructor for ast.DeferStmt"
;;   {:added "1.0"
;;    :go "_ConstructDeferStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Ellipsis from go/ast/ast.go:
;; (defn ^"GoObject" Ellipsis.
;;   "Constructor for ast.Ellipsis"
;;   {:added "1.0"
;;    :go "_ConstructEllipsis(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.EmptyStmt from go/ast/ast.go:
;; (defn ^"GoObject" EmptyStmt.
;;   "Constructor for ast.EmptyStmt"
;;   {:added "1.0"
;;    :go "_ConstructEmptyStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Expr from go/ast/ast.go:
;; (defn ^"GoObject" Expr.
;;   "Constructor for ast.Expr"
;;   {:added "1.0"
;;    :go "_ConstructExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.ExprStmt from go/ast/ast.go:
;; (defn ^"GoObject" ExprStmt.
;;   "Constructor for ast.ExprStmt"
;;   {:added "1.0"
;;    :go "_ConstructExprStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Field from go/ast/ast.go:
;; (defn ^"GoObject" Field.
;;   "Constructor for ast.Field"
;;   {:added "1.0"
;;    :go "_ConstructField(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.FieldFilter from go/ast/print.go:
;; (defn ^"GoObject" FieldFilter.
;;   "Constructor for ast.FieldFilter"
;;   {:added "1.0"
;;    :go "_ConstructFieldFilter(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.FieldList from go/ast/ast.go:
;; (defn ^"GoObject" FieldList.
;;   "Constructor for ast.FieldList"
;;   {:added "1.0"
;;    :go "_ConstructFieldList(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.File from go/ast/ast.go:
;; (defn ^"GoObject" File.
;;   "Constructor for ast.File"
;;   {:added "1.0"
;;    :go "_ConstructFile(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Filter from go/ast/filter.go:
;; (defn ^"GoObject" Filter.
;;   "Constructor for ast.Filter"
;;   {:added "1.0"
;;    :go "_ConstructFilter(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.ForStmt from go/ast/ast.go:
;; (defn ^"GoObject" ForStmt.
;;   "Constructor for ast.ForStmt"
;;   {:added "1.0"
;;    :go "_ConstructForStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.FuncDecl from go/ast/ast.go:
;; (defn ^"GoObject" FuncDecl.
;;   "Constructor for ast.FuncDecl"
;;   {:added "1.0"
;;    :go "_ConstructFuncDecl(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.FuncLit from go/ast/ast.go:
;; (defn ^"GoObject" FuncLit.
;;   "Constructor for ast.FuncLit"
;;   {:added "1.0"
;;    :go "_ConstructFuncLit(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.FuncType from go/ast/ast.go:
;; (defn ^"GoObject" FuncType.
;;   "Constructor for ast.FuncType"
;;   {:added "1.0"
;;    :go "_ConstructFuncType(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.GenDecl from go/ast/ast.go:
;; (defn ^"GoObject" GenDecl.
;;   "Constructor for ast.GenDecl"
;;   {:added "1.0"
;;    :go "_ConstructGenDecl(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.GoStmt from go/ast/ast.go:
;; (defn ^"GoObject" GoStmt.
;;   "Constructor for ast.GoStmt"
;;   {:added "1.0"
;;    :go "_ConstructGoStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Ident from go/ast/ast.go:
;; (defn ^"GoObject" Ident.
;;   "Constructor for ast.Ident"
;;   {:added "1.0"
;;    :go "_ConstructIdent(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.IfStmt from go/ast/ast.go:
;; (defn ^"GoObject" IfStmt.
;;   "Constructor for ast.IfStmt"
;;   {:added "1.0"
;;    :go "_ConstructIfStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.ImportSpec from go/ast/ast.go:
;; (defn ^"GoObject" ImportSpec.
;;   "Constructor for ast.ImportSpec"
;;   {:added "1.0"
;;    :go "_ConstructImportSpec(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Importer from go/ast/resolve.go:
;; (defn ^"GoObject" Importer.
;;   "Constructor for ast.Importer"
;;   {:added "1.0"
;;    :go "_ConstructImporter(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.IncDecStmt from go/ast/ast.go:
;; (defn ^"GoObject" IncDecStmt.
;;   "Constructor for ast.IncDecStmt"
;;   {:added "1.0"
;;    :go "_ConstructIncDecStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.IndexExpr from go/ast/ast.go:
;; (defn ^"GoObject" IndexExpr.
;;   "Constructor for ast.IndexExpr"
;;   {:added "1.0"
;;    :go "_ConstructIndexExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.InterfaceType from go/ast/ast.go:
;; (defn ^"GoObject" InterfaceType.
;;   "Constructor for ast.InterfaceType"
;;   {:added "1.0"
;;    :go "_ConstructInterfaceType(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.KeyValueExpr from go/ast/ast.go:
;; (defn ^"GoObject" KeyValueExpr.
;;   "Constructor for ast.KeyValueExpr"
;;   {:added "1.0"
;;    :go "_ConstructKeyValueExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.LabeledStmt from go/ast/ast.go:
;; (defn ^"GoObject" LabeledStmt.
;;   "Constructor for ast.LabeledStmt"
;;   {:added "1.0"
;;    :go "_ConstructLabeledStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.MapType from go/ast/ast.go:
;; (defn ^"GoObject" MapType.
;;   "Constructor for ast.MapType"
;;   {:added "1.0"
;;    :go "_ConstructMapType(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.MergeMode from go/ast/filter.go:
(defn ^"GoObject" MergeMode.
  "Constructor for ast.MergeMode"
  {:added "1.0"
   :go "_ConstructMergeMode(_v)"}
  [^Object _v])

JOKER TYPE go/ast.Node from go/ast/ast.go:
;; (defn ^"GoObject" Node.
;;   "Constructor for ast.Node"
;;   {:added "1.0"
;;    :go "_ConstructNode(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.ObjKind from go/ast/scope.go:
(defn ^"GoObject" ObjKind.
  "Constructor for ast.ObjKind"
  {:added "1.0"
   :go "_ConstructObjKind(_v)"}
  [^Object _v])

JOKER TYPE go/ast.Object from go/ast/scope.go:
;; (defn ^"GoObject" Object.
;;   "Constructor for ast.Object"
;;   {:added "1.0"
;;    :go "_ConstructObject(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Package from go/ast/ast.go:
;; (defn ^"GoObject" Package.
;;   "Constructor for ast.Package"
;;   {:added "1.0"
;;    :go "_ConstructPackage(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.ParenExpr from go/ast/ast.go:
;; (defn ^"GoObject" ParenExpr.
;;   "Constructor for ast.ParenExpr"
;;   {:added "1.0"
;;    :go "_ConstructParenExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.RangeStmt from go/ast/ast.go:
;; (defn ^"GoObject" RangeStmt.
;;   "Constructor for ast.RangeStmt"
;;   {:added "1.0"
;;    :go "_ConstructRangeStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.ReturnStmt from go/ast/ast.go:
;; (defn ^"GoObject" ReturnStmt.
;;   "Constructor for ast.ReturnStmt"
;;   {:added "1.0"
;;    :go "_ConstructReturnStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Scope from go/ast/scope.go:
;; (defn ^"GoObject" Scope.
;;   "Constructor for ast.Scope"
;;   {:added "1.0"
;;    :go "_ConstructScope(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.SelectStmt from go/ast/ast.go:
;; (defn ^"GoObject" SelectStmt.
;;   "Constructor for ast.SelectStmt"
;;   {:added "1.0"
;;    :go "_ConstructSelectStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.SelectorExpr from go/ast/ast.go:
;; (defn ^"GoObject" SelectorExpr.
;;   "Constructor for ast.SelectorExpr"
;;   {:added "1.0"
;;    :go "_ConstructSelectorExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.SendStmt from go/ast/ast.go:
;; (defn ^"GoObject" SendStmt.
;;   "Constructor for ast.SendStmt"
;;   {:added "1.0"
;;    :go "_ConstructSendStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.SliceExpr from go/ast/ast.go:
;; (defn ^"GoObject" SliceExpr.
;;   "Constructor for ast.SliceExpr"
;;   {:added "1.0"
;;    :go "_ConstructSliceExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Spec from go/ast/ast.go:
;; (defn ^"GoObject" Spec.
;;   "Constructor for ast.Spec"
;;   {:added "1.0"
;;    :go "_ConstructSpec(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.StarExpr from go/ast/ast.go:
;; (defn ^"GoObject" StarExpr.
;;   "Constructor for ast.StarExpr"
;;   {:added "1.0"
;;    :go "_ConstructStarExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Stmt from go/ast/ast.go:
;; (defn ^"GoObject" Stmt.
;;   "Constructor for ast.Stmt"
;;   {:added "1.0"
;;    :go "_ConstructStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.StructType from go/ast/ast.go:
;; (defn ^"GoObject" StructType.
;;   "Constructor for ast.StructType"
;;   {:added "1.0"
;;    :go "_ConstructStructType(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.SwitchStmt from go/ast/ast.go:
;; (defn ^"GoObject" SwitchStmt.
;;   "Constructor for ast.SwitchStmt"
;;   {:added "1.0"
;;    :go "_ConstructSwitchStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.TypeAssertExpr from go/ast/ast.go:
;; (defn ^"GoObject" TypeAssertExpr.
;;   "Constructor for ast.TypeAssertExpr"
;;   {:added "1.0"
;;    :go "_ConstructTypeAssertExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.TypeSpec from go/ast/ast.go:
;; (defn ^"GoObject" TypeSpec.
;;   "Constructor for ast.TypeSpec"
;;   {:added "1.0"
;;    :go "_ConstructTypeSpec(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.TypeSwitchStmt from go/ast/ast.go:
;; (defn ^"GoObject" TypeSwitchStmt.
;;   "Constructor for ast.TypeSwitchStmt"
;;   {:added "1.0"
;;    :go "_ConstructTypeSwitchStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.UnaryExpr from go/ast/ast.go:
;; (defn ^"GoObject" UnaryExpr.
;;   "Constructor for ast.UnaryExpr"
;;   {:added "1.0"
;;    :go "_ConstructUnaryExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.ValueSpec from go/ast/ast.go:
;; (defn ^"GoObject" ValueSpec.
;;   "Constructor for ast.ValueSpec"
;;   {:added "1.0"
;;    :go "_ConstructValueSpec(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Visitor from go/ast/walk.go:
;; (defn ^"GoObject" Visitor.
;;   "Constructor for ast.Visitor"
;;   {:added "1.0"
;;    :go "_ConstructVisitor(_v)"}
;;   [^Object _v])

JOKER FUNC go/ast.FileExports from go/ast/filter.go:
(defn ^"Boolean" FileExports
  "FileExports trims the AST for a Go source file in place such that\nonly exported nodes remain: all top-level identifiers which are not exported\nand their associated information (such as type, initial value, or function\nbody) are removed. Non-exported fields and methods of exported types are\nstripped. The File.Comments list is not changed.\n\nFileExports reports whether there are exported declarations.\n\nGo input arguments: (src *File)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.go.ast/File) src]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "ast.FileExports(__src)"}
  [^ast/File __src])

JOKER FUNC go/ast.FilterDecl from go/ast/filter.go:
(defn ^"Boolean" FilterDecl
  "FilterDecl trims the AST for a Go declaration in place by removing\nall names (including struct field and interface method names, but\nnot from parameter lists) that don't pass through the filter f.\n\nFilterDecl reports whether there are any declared names left after\nfiltering.\n\nGo input arguments: (decl Decl, f Filter)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.ast/Decl decl, ^go.std.go.ast/Filter f]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "ast.FilterDecl(*__decl, *__f)"}
  [^ast/Decl __decl, ^ast/Filter __f])

JOKER FUNC go/ast.FilterFile from go/ast/filter.go:
(defn ^"Boolean" FilterFile
  "FilterFile trims the AST for a Go file in place by removing all\nnames from top-level declarations (including struct field and\ninterface method names, but not from parameter lists) that don't\npass through the filter f. If the declaration is empty afterwards,\nthe declaration is removed from the AST. Import declarations are\nalways removed. The File.Comments list is not changed.\n\nFilterFile reports whether there are any top-level declarations\nleft after filtering.\n\nGo input arguments: (src *File, f Filter)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.go.ast/File) src, ^go.std.go.ast/Filter f]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "ast.FilterFile(__src, *__f)"}
  [^ast/File __src, ^ast/Filter __f])

JOKER FUNC go/ast.FilterPackage from go/ast/filter.go:
(defn ^"Boolean" FilterPackage
  "FilterPackage trims the AST for a Go package in place by removing\nall names from top-level declarations (including struct field and\ninterface method names, but not from parameter lists) that don't\npass through the filter f. If the declaration is empty afterwards,\nthe declaration is removed from the AST. The pkg.Files list is not\nchanged, so that file names and top-level package comments don't get\nlost.\n\nFilterPackage reports whether there are any top-level declarations\nleft after filtering.\n\nGo input arguments: (pkg *Package, f Filter)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.go.ast/Package) pkg, ^go.std.go.ast/Filter f]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "ast.FilterPackage(__pkg, *__f)"}
  [^ast/Package __pkg, ^ast/Filter __f])

JOKER FUNC go/ast.Fprint from go/ast/print.go:
;; (defn ^"Error" Fprint
;;   "Fprint prints the (sub-)tree starting at AST node x to w.\nIf fset != nil, position information is interpreted relative\nto that file set. Otherwise positions are printed as integer\nvalues (file set specific offsets).\n\nA non-nil FieldFilter f may be provided to control the output:\nstruct fields for which f(fieldname, fieldvalue) is true are\nprinted; all others are filtered from the output. Unexported\nstruct fields are never printed.\n\nGo input arguments: (w io.Writer, fset *token.FileSet, x interface {}, f FieldFilter)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^(atom-of go.std.go.token/FileSet) fset, ^<protocol-or-something> x, ^go.std.go.ast/FieldFilter f]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "ast.Fprint(*__w, __fset, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), *__f)"}
;;   [^io/Writer __w, ^token/FileSet __fset, ^<protocol-or-something> __x, ^ast/FieldFilter __f])

JOKER FUNC go/ast.Inspect from go/ast/walk.go:
;; (defn Inspect
;;   "Inspect traverses an AST in depth-first order: It starts by calling\nf(node); node must not be nil. If f returns true, Inspect invokes f\nrecursively for each of the non-nil children of node, followed by a\ncall of f(nil).\n\nGo input arguments: (node Node, f func)\n\nJoker input arguments: [^go.std.go.ast/Node node, ^fn f]"
;;   {:added "1.0"
;;    :go "__inspect(*__node, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^ast/Node __node, ^fn __f])

JOKER FUNC go/ast.IsExported from go/ast/ast.go:
(defn ^"Boolean" IsExported
  "IsExported reports whether name is an exported Go symbol\n(that is, whether it begins with an upper-case letter).\n\nGo input arguments: (name string)\n\nGo return type: bool\n\nJoker input arguments: [^String name]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "ast.IsExported(__name)"}
  [^String __name])

JOKER FUNC go/ast.MergePackageFiles from go/ast/filter.go:
(defn MergePackageFiles
  "MergePackageFiles creates a file AST by merging the ASTs of the\nfiles belonging to a package. The mode flags control merging behavior.\n\nGo input arguments: (pkg *Package, mode MergeMode)\n\nGo return type: *File\n\nJoker input arguments: [^(atom-of go.std.go.ast/Package) pkg, ^go.std.go.ast/MergeMode mode]\n\nJoker return type: (atom-of go.std.go.ast/File)"
  {:added "1.0"
   :go "__mergePackageFiles(__pkg, *__mode)"}
  [^ast/Package __pkg, ^ast/MergeMode __mode])

JOKER FUNC go/ast.NewCommentMap from go/ast/commentmap.go:
;; (defn NewCommentMap
;;   "NewCommentMap creates a new comment map by associating comment groups\nof the comments list with the nodes of the AST specified by node.\n\nA comment group g is associated with a node n if:\n\n  - g starts on the same line as n ends\n  - g starts on the line immediately following n, and there is\n    at least one empty line after g and before the next node\n  - g starts before n and is not associated to the node before n\n    via the previous rules\n\nNewCommentMap tries to associate a comment group to the \"largest\"\nnode possible: For instance, if the comment is a line comment\ntrailing an assignment, the comment is associated with the entire\nassignment rather than just the last operand in the assignment.\n\nGo input arguments: (fset *token.FileSet, node Node, comments []*CommentGroup)\n\nGo return type: CommentMap\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^go.std.go.ast/Node node, ^(vector-of (atom-of go.std.go.ast/CommentGroup)) comments]\n\nJoker return type: go.std.go.ast/CommentMap"
;;   {:added "1.0"
;;    :go "__newCommentMap(__fset, *__node, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_ast.CommentGroup(__comments)))"}
;;   [^token/FileSet __fset, ^ast/Node __node, ^Object __comments])

JOKER FUNC go/ast.NewIdent from go/ast/ast.go:
(defn NewIdent
  "NewIdent creates a new Ident without position.\nUseful for ASTs generated by code other than the Go parser.\n\nGo input arguments: (name string)\n\nGo return type: *Ident\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.go.ast/Ident)"
  {:added "1.0"
   :go "__newIdent(__name)"}
  [^String __name])

JOKER FUNC go/ast.NewObj from go/ast/scope.go:
(defn NewObj
  "NewObj creates a new object of a given kind and name.\n\nGo input arguments: (kind ObjKind, name string)\n\nGo return type: *Object\n\nJoker input arguments: [^go.std.go.ast/ObjKind kind, ^String name]\n\nJoker return type: (atom-of go.std.go.ast/Object)"
  {:added "1.0"
   :go "__newObj(*__kind, __name)"}
  [^ast/ObjKind __kind, ^String __name])

JOKER FUNC go/ast.NewPackage from go/ast/resolve.go:
;; (defn NewPackage
;;   "NewPackage creates a new Package node from a set of File nodes. It resolves\nunresolved identifiers across files and updates each file's Unresolved list\naccordingly. If a non-nil importer and universe scope are provided, they are\nused to resolve identifiers not declared in any of the package files. Any\nremaining unresolved identifiers are reported as undeclared. If the files\nbelong to different packages, one package name is selected and files with\ndifferent package names are reported and then ignored.\nThe result is a package node and a scanner.ErrorList if there were errors.\n\nGo input arguments: (fset *token.FileSet, files map[], importer Importer, universe *Scope)\n\nGo return type: (*Package, error)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^{} files, ^go.std.go.ast/Importer importer, ^(atom-of go.std.go.ast/Scope) universe]\n\nJoker return type: [(atom-of go.std.go.ast/Package) Error]"
;;   {:added "1.0"
;;    :go "__newPackage(__fset, ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa()), *__importer, __universe)"}
;;   [^token/FileSet __fset, ^{} __files, ^ast/Importer __importer, ^ast/Scope __universe])

JOKER FUNC go/ast.NewScope from go/ast/scope.go:
(defn NewScope
  "NewScope creates a new scope nested in the outer scope.\n\nGo input arguments: (outer *Scope)\n\nGo return type: *Scope\n\nJoker input arguments: [^(atom-of go.std.go.ast/Scope) outer]\n\nJoker return type: (atom-of go.std.go.ast/Scope)"
  {:added "1.0"
   :go "__newScope(__outer)"}
  [^ast/Scope __outer])

JOKER FUNC go/ast.NotNilFilter from go/ast/print.go:
;; (defn ^"Boolean" NotNilFilter
;;   "NotNilFilter returns true for field values that are not nil;\nit returns false otherwise.\n\nGo input arguments: (_ string, v reflect.Value)\n\nGo return type: bool\n\nJoker input arguments: [^String _, ^go.std.reflect/Value v]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "ast.NotNilFilter(___, *__v)"}
;;   [^String ___, ^reflect/Value __v])

JOKER FUNC go/ast.PackageExports from go/ast/filter.go:
(defn ^"Boolean" PackageExports
  "PackageExports trims the AST for a Go package in place such that\nonly exported nodes remain. The pkg.Files list is not changed, so that\nfile names and top-level package comments don't get lost.\n\nPackageExports reports whether there are exported declarations;\nit returns false otherwise.\n\nGo input arguments: (pkg *Package)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.go.ast/Package) pkg]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "ast.PackageExports(__pkg)"}
  [^ast/Package __pkg])

JOKER FUNC go/ast.Print from go/ast/print.go:
;; (defn ^"Error" Print
;;   "Print prints x to standard output, skipping nil fields.\nPrint(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter).\n\nGo input arguments: (fset *token.FileSet, x interface {})\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^<protocol-or-something> x]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "ast.Print(__fset, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^token/FileSet __fset, ^<protocol-or-something> __x])

JOKER FUNC go/ast.SortImports from go/ast/import.go:
;; (defn SortImports
;;   "SortImports sorts runs of consecutive import lines in import blocks in f.\nIt also removes duplicate imports when it is possible to do so without data loss.\n\nGo input arguments: (fset *token.FileSet, f *File)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^(atom-of go.std.go.ast/File) f]"
;;   {:added "1.0"
;;    :go "__sortImports(__fset, __f)"}
;;   [^token/FileSet __fset, ^ast/File __f])

JOKER FUNC go/ast.Walk from go/ast/walk.go:
;; (defn Walk
;;   "Walk traverses an AST in depth-first order: It starts by calling\nv.Visit(node); node must not be nil. If the visitor w returned by\nv.Visit(node) is not nil, Walk is invoked recursively with visitor\nw for each of the non-nil children of node, followed by a call of\nw.Visit(nil).\n\nGo input arguments: (v Visitor, node Node)\n\nJoker input arguments: [^go.std.go.ast/Visitor v, ^go.std.go.ast/Node node]"
;;   {:added "1.0"
;;    :go "__walk(*__v, *__node)"}
;;   [^ast/Visitor __v, ^ast/Node __node])

JOKER TYPE go.std.go.ast/ArrayType:
(def
  ^{:doc "An ArrayType node represents an array or slice type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayType"}
  ArrayType)

JOKER TYPE go.std.go.ast/AssignStmt:
(def
  ^{:doc "An AssignStmt node represents an assignment or\na short variable declaration.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_AssignStmt"}
  AssignStmt)

JOKER TYPE go.std.go.ast/BadDecl:
(def
  ^{:doc "A BadDecl node is a placeholder for declarations containing\nsyntax errors for which no correct declaration nodes can be\ncreated.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BadDecl"}
  BadDecl)

JOKER TYPE go.std.go.ast/BadExpr:
(def
  ^{:doc "A BadExpr node is a placeholder for expressions containing\nsyntax errors for which no correct expression nodes can be\ncreated.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BadExpr"}
  BadExpr)

JOKER TYPE go.std.go.ast/BadStmt:
(def
  ^{:doc "A BadStmt node is a placeholder for statements containing\nsyntax errors for which no correct statement nodes can be\ncreated.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BadStmt"}
  BadStmt)

JOKER TYPE go.std.go.ast/BasicLit:
(def
  ^{:doc "A BasicLit node represents a literal of basic type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BasicLit"}
  BasicLit)

JOKER TYPE go.std.go.ast/BinaryExpr:
(def
  ^{:doc "A BinaryExpr node represents a binary expression.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BinaryExpr"}
  BinaryExpr)

JOKER TYPE go.std.go.ast/BlockStmt:
(def
  ^{:doc "A BlockStmt node represents a braced statement list.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BlockStmt"}
  BlockStmt)

JOKER TYPE go.std.go.ast/BranchStmt:
(def
  ^{:doc "A BranchStmt node represents a break, continue, goto,\nor fallthrough statement.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BranchStmt"}
  BranchStmt)

JOKER TYPE go.std.go.ast/CallExpr:
(def
  ^{:doc "A CallExpr node represents an expression followed by an argument list.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CallExpr"}
  CallExpr)

JOKER TYPE go.std.go.ast/CaseClause:
(def
  ^{:doc "A CaseClause represents a case of an expression or type switch statement.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CaseClause"}
  CaseClause)

JOKER TYPE go.std.go.ast/ChanDir:
(def
  ^{:doc "The direction of a channel type is indicated by a bit\nmask including one or both of the following constants.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ChanDir"}
  ChanDir)

JOKER TYPE go.std.go.ast/ChanType:
(def
  ^{:doc "A ChanType node represents a channel type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ChanType"}
  ChanType)

JOKER TYPE go.std.go.ast/CommClause:
(def
  ^{:doc "A CommClause node represents a case of a select statement.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CommClause"}
  CommClause)

JOKER TYPE go.std.go.ast/Comment:
(def
  ^{:doc "A Comment node represents a single //-style or /*-style comment.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Comment"}
  Comment)

JOKER TYPE go.std.go.ast/CommentGroup:
(def
  ^{:doc "A CommentGroup represents a sequence of comments\nwith no other tokens and no empty lines between.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CommentGroup"}
  CommentGroup)

JOKER TYPE go.std.go.ast/CommentMap:
(def
  ^{:doc "A CommentMap maps an AST node to a list of comment groups\nassociated with it. See NewCommentMap for a description of\nthe association.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CommentMap"}
  CommentMap)

JOKER TYPE go.std.go.ast/CompositeLit:
(def
  ^{:doc "A CompositeLit node represents a composite literal.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CompositeLit"}
  CompositeLit)

JOKER TYPE go.std.go.ast/Decl:
(def
  ^{:doc "All declaration nodes implement the Decl interface.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Decl"}
  Decl)

JOKER TYPE go.std.go.ast/DeclStmt:
(def
  ^{:doc "A DeclStmt node represents a declaration in a statement list.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DeclStmt"}
  DeclStmt)

JOKER TYPE go.std.go.ast/DeferStmt:
(def
  ^{:doc "A DeferStmt node represents a defer statement.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DeferStmt"}
  DeferStmt)

JOKER TYPE go.std.go.ast/Ellipsis:
(def
  ^{:doc "An Ellipsis node stands for the \"...\" type in a\nparameter list or the \"...\" length in an array type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Ellipsis"}
  Ellipsis)

JOKER TYPE go.std.go.ast/EmptyStmt:
(def
  ^{:doc "An EmptyStmt node represents an empty statement.\nThe \"position\" of the empty statement is the position\nof the immediately following (explicit or implicit) semicolon.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_EmptyStmt"}
  EmptyStmt)

JOKER TYPE go.std.go.ast/Expr:
(def
  ^{:doc "All expression nodes implement the Expr interface.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Expr"}
  Expr)

JOKER TYPE go.std.go.ast/ExprStmt:
(def
  ^{:doc "An ExprStmt node represents a (stand-alone) expression\nin a statement list.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ExprStmt"}
  ExprStmt)

JOKER TYPE go.std.go.ast/Field:
(def
  ^{:doc "A Field represents a Field declaration list in a struct type,\na method list in an interface type, or a parameter/result declaration\nin a signature.\nField.Names is nil for unnamed parameters (parameter lists which only contain types)\nand embedded struct fields. In the latter case, the field name is the type name.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Field"}
  Field)

JOKER TYPE go.std.go.ast/FieldFilter:
(def
  ^{:doc "A FieldFilter may be provided to Fprint to control the output.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FieldFilter"}
  FieldFilter)

JOKER TYPE go.std.go.ast/FieldList:
(def
  ^{:doc "A FieldList represents a list of Fields, enclosed by parentheses or braces.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FieldList"}
  FieldList)

JOKER TYPE go.std.go.ast/File:
(def
  ^{:doc "A File node represents a Go source file.\n\nThe Comments list contains all comments in the source file in order of\nappearance, including the comments that are pointed to from other nodes\nvia Doc and Comment fields.\n\nFor correct printing of source code containing comments (using packages\ngo/format and go/printer), special care must be taken to update comments\nwhen a File's syntax tree is modified: For printing, comments are interspersed\nbetween tokens based on their position. If syntax tree nodes are\nremoved or moved, relevant comments in their vicinity must also be removed\n(from the File.Comments list) or moved accordingly (by updating their\npositions). A CommentMap may be used to facilitate some of these operations.\n\nWhether and how a comment is associated with a node depends on the\ninterpretation of the syntax tree by the manipulating program: Except for Doc\nand Comment comments directly associated with nodes, the remaining comments\nare \"free-floating\" (see also issues #18593, #20744).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_File"}
  File)

JOKER TYPE go.std.go.ast/Filter:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Filter"}
  Filter)

JOKER TYPE go.std.go.ast/ForStmt:
(def
  ^{:doc "A ForStmt represents a for statement.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ForStmt"}
  ForStmt)

JOKER TYPE go.std.go.ast/FuncDecl:
(def
  ^{:doc "A FuncDecl node represents a function declaration.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FuncDecl"}
  FuncDecl)

JOKER TYPE go.std.go.ast/FuncLit:
(def
  ^{:doc "A FuncLit node represents a function literal.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FuncLit"}
  FuncLit)

JOKER TYPE go.std.go.ast/FuncType:
(def
  ^{:doc "A FuncType node represents a function type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FuncType"}
  FuncType)

JOKER TYPE go.std.go.ast/GenDecl:
(def
  ^{:doc "A GenDecl node (generic declaration node) represents an import,\nconstant, type or variable declaration. A valid Lparen position\n(Lparen.IsValid()) indicates a parenthesized declaration.\n\nRelationship between Tok value and Specs element type:\n\n\ttoken.IMPORT  *ImportSpec\n\ttoken.CONST   *ValueSpec\n\ttoken.TYPE    *TypeSpec\n\ttoken.VAR     *ValueSpec\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_GenDecl"}
  GenDecl)

JOKER TYPE go.std.go.ast/GoStmt:
(def
  ^{:doc "A GoStmt node represents a go statement.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_GoStmt"}
  GoStmt)

JOKER TYPE go.std.go.ast/Ident:
(def
  ^{:doc "An Ident node represents an identifier.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Ident"}
  Ident)

JOKER TYPE go.std.go.ast/IfStmt:
(def
  ^{:doc "An IfStmt node represents an if statement.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IfStmt"}
  IfStmt)

JOKER TYPE go.std.go.ast/ImportSpec:
(def
  ^{:doc "An ImportSpec node represents a single package import.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ImportSpec"}
  ImportSpec)

JOKER TYPE go.std.go.ast/Importer:
(def
  ^{:doc "An Importer resolves import paths to package Objects.\nThe imports map records the packages already imported,\nindexed by package id (canonical import path).\nAn Importer must determine the canonical import path and\ncheck the map to see if it is already present in the imports map.\nIf so, the Importer can return the map entry. Otherwise, the\nImporter should load the package data for the given path into\na new *Object (pkg), record pkg in the imports map, and then\nreturn pkg.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Importer"}
  Importer)

JOKER TYPE go.std.go.ast/IncDecStmt:
(def
  ^{:doc "An IncDecStmt node represents an increment or decrement statement.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IncDecStmt"}
  IncDecStmt)

JOKER TYPE go.std.go.ast/IndexExpr:
(def
  ^{:doc "An IndexExpr node represents an expression followed by an index.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IndexExpr"}
  IndexExpr)

JOKER TYPE go.std.go.ast/InterfaceType:
(def
  ^{:doc "An InterfaceType node represents an interface type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_InterfaceType"}
  InterfaceType)

JOKER TYPE go.std.go.ast/KeyValueExpr:
(def
  ^{:doc "A KeyValueExpr node represents (key : value) pairs\nin composite literals.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_KeyValueExpr"}
  KeyValueExpr)

JOKER TYPE go.std.go.ast/LabeledStmt:
(def
  ^{:doc "A LabeledStmt node represents a labeled statement.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_LabeledStmt"}
  LabeledStmt)

JOKER TYPE go.std.go.ast/MapType:
(def
  ^{:doc "A MapType node represents a map type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_MapType"}
  MapType)

JOKER TYPE go.std.go.ast/MergeMode:
(def
  ^{:doc "The MergeMode flags control the behavior of MergePackageFiles.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_MergeMode"}
  MergeMode)

JOKER TYPE go.std.go.ast/Node:
(def
  ^{:doc "All node types implement the Node interface.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Node"}
  Node)

JOKER TYPE go.std.go.ast/ObjKind:
(def
  ^{:doc "ObjKind describes what an object represents.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ObjKind"}
  ObjKind)

JOKER TYPE go.std.go.ast/Object:
(def
  ^{:doc "An Object describes a named language entity such as a package,\nconstant, type, variable, function (incl. methods), or label.\n\nThe Data fields contains object-specific data:\n\n\tKind    Data type         Data value\n\tPkg     *Scope            package scope\n\tCon     int               iota for the respective declaration\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Object"}
  Object)

JOKER TYPE go.std.go.ast/Package:
(def
  ^{:doc "A Package node represents a set of source files\ncollectively building a Go package.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Package"}
  Package)

JOKER TYPE go.std.go.ast/ParenExpr:
(def
  ^{:doc "A ParenExpr node represents a parenthesized expression.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ParenExpr"}
  ParenExpr)

JOKER TYPE go.std.go.ast/RangeStmt:
(def
  ^{:doc "A RangeStmt represents a for statement with a range clause.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RangeStmt"}
  RangeStmt)

JOKER TYPE go.std.go.ast/ReturnStmt:
(def
  ^{:doc "A ReturnStmt node represents a return statement.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ReturnStmt"}
  ReturnStmt)

JOKER TYPE go.std.go.ast/Scope:
(def
  ^{:doc "A Scope maintains the set of named language entities declared\nin the scope and a link to the immediately surrounding (outer)\nscope.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Scope"}
  Scope)

JOKER TYPE go.std.go.ast/SelectStmt:
(def
  ^{:doc "An SelectStmt node represents a select statement.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SelectStmt"}
  SelectStmt)

JOKER TYPE go.std.go.ast/SelectorExpr:
(def
  ^{:doc "A SelectorExpr node represents an expression followed by a selector.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SelectorExpr"}
  SelectorExpr)

JOKER TYPE go.std.go.ast/SendStmt:
(def
  ^{:doc "A SendStmt node represents a send statement.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SendStmt"}
  SendStmt)

JOKER TYPE go.std.go.ast/SliceExpr:
(def
  ^{:doc "An SliceExpr node represents an expression followed by slice indices.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SliceExpr"}
  SliceExpr)

JOKER TYPE go.std.go.ast/Spec:
(def
  ^{:doc "The Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Spec"}
  Spec)

JOKER TYPE go.std.go.ast/StarExpr:
(def
  ^{:doc "A StarExpr node represents an expression of the form \"*\" Expression.\nSemantically it could be a unary \"*\" expression, or a pointer type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_StarExpr"}
  StarExpr)

JOKER TYPE go.std.go.ast/Stmt:
(def
  ^{:doc "All statement nodes implement the Stmt interface.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Stmt"}
  Stmt)

JOKER TYPE go.std.go.ast/StructType:
(def
  ^{:doc "A StructType node represents a struct type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_StructType"}
  StructType)

JOKER TYPE go.std.go.ast/SwitchStmt:
(def
  ^{:doc "A SwitchStmt node represents an expression switch statement.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SwitchStmt"}
  SwitchStmt)

JOKER TYPE go.std.go.ast/TypeAssertExpr:
(def
  ^{:doc "A TypeAssertExpr node represents an expression followed by a\ntype assertion.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TypeAssertExpr"}
  TypeAssertExpr)

JOKER TYPE go.std.go.ast/TypeSpec:
(def
  ^{:doc "A TypeSpec node represents a type declaration (TypeSpec production).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TypeSpec"}
  TypeSpec)

JOKER TYPE go.std.go.ast/TypeSwitchStmt:
(def
  ^{:doc "An TypeSwitchStmt node represents a type switch statement.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TypeSwitchStmt"}
  TypeSwitchStmt)

JOKER TYPE go.std.go.ast/UnaryExpr:
(def
  ^{:doc "A UnaryExpr node represents a unary expression.\nUnary \"*\" expressions are represented via StarExpr nodes.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnaryExpr"}
  UnaryExpr)

JOKER TYPE go.std.go.ast/ValueSpec:
(def
  ^{:doc "A ValueSpec node represents a constant or variable declaration\n(ConstSpec or VarSpec production).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ValueSpec"}
  ValueSpec)

JOKER TYPE go.std.go.ast/Visitor:
(def
  ^{:doc "A Visitor's Visit method is invoked for each node encountered by Walk.\nIf the result visitor w is not nil, Walk visits each of the children\nof node with the visitor w, followed by a call of w.Visit(nil).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Visitor"}
  Visitor)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/ast"]
    :doc "Provides a low-level interface to the go/ast package.\n\nPackage ast declares the types used to represent syntax trees for Go\npackages.\n"
    :empty false}
  go.std.go.ast)
JOKER CONSTANT AllowBinary from go/build/build.go:
(def
  ^{:doc "If AllowBinary is set, Import can be satisfied by a compiled\npackage object without corresponding sources.\n\nDeprecated:\nThe supported way to create a compiled-only package is to\nwrite source code containing a //go:binary-only-package comment at\nthe top of the file. Such a package will be recognized\nregardless of this flag setting (because it has source code)\nand will have BinaryOnly set to true in the returned Package.\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(build.AllowBinary))"}
  AllowBinary)

JOKER CONSTANT FindOnly from go/build/build.go:
(def
  ^{:doc "If FindOnly is set, Import stops after locating the directory\nthat should contain the sources for a package. It does not\nread any files in the directory.\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(build.FindOnly))"}
  FindOnly)

JOKER CONSTANT IgnoreVendor from go/build/build.go:
(def
  ^{:doc "By default, Import searches vendor directories\nthat apply in the given source directory before searching\nthe GOROOT and GOPATH roots.\nIf an Import finds and returns a package using a vendor\ndirectory, the resulting ImportPath is the complete path\nto the package, including the path elements leading up\nto and including \"vendor\".\nFor example, if Import(\"y\", \"x/subdir\", 0) finds\n\"x/vendor/y\", the returned package's ImportPath is \"x/vendor/y\",\nnot plain \"y\".\nSee golang.org/s/go15vendor for more information.\n\nSetting IgnoreVendor ignores vendor directories.\n\nIn contrast to the package's ImportPath,\nthe returned package's Imports, TestImports, and XTestImports\nare always the exact import paths from the source files:\nImport makes no attempt to resolve or check those paths.\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(build.IgnoreVendor))"}
  IgnoreVendor)

JOKER CONSTANT ImportComment from go/build/build.go:
(def
  ^{:doc "If ImportComment is set, parse import comments on package statements.\nImport returns an error if it finds a comment it cannot understand\nor finds conflicting comments in multiple source files.\nSee golang.org/s/go14customimport for more information.\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(build.ImportComment))"}
  ImportComment)

JOKER VARIABLE Default from go/build/build.go:
(def
  ^{:doc "Default is the default Context for builds.\nIt uses the GOARCH, GOOS, GOROOT, and GOPATH environment variables\nif set, or else the compiled code's GOARCH, GOOS, and GOROOT.\n"
    :added "1.0"
    :tag "Var"
    :go "build.Default"}
  Default)

JOKER VARIABLE ToolDir from go/build/build.go:
(def
  ^{:doc "ToolDir is the directory containing build tools.\n"
    :added "1.0"
    :tag "Var"
    :go "build.ToolDir"}
  ToolDir)

JOKER TYPE go/build.Context from go/build/build.go:
;; (defn ^"GoObject" Context.
;;   "Constructor for build.Context"
;;   {:added "1.0"
;;    :go "_ConstructContext(_v)"}
;;   [^Object _v])

JOKER TYPE go/build.ImportMode from go/build/build.go:
(defn ^"GoObject" ImportMode.
  "Constructor for build.ImportMode"
  {:added "1.0"
   :go "_ConstructImportMode(_v)"}
  [^Object _v])

JOKER TYPE go/build.MultiplePackageError from go/build/build.go:
;; (defn ^"GoObject" MultiplePackageError.
;;   "Constructor for build.MultiplePackageError"
;;   {:added "1.0"
;;    :go "_ConstructMultiplePackageError(_v)"}
;;   [^Object _v])

JOKER TYPE go/build.NoGoError from go/build/build.go:
(defn ^"GoObject" NoGoError.
  "Constructor for build.NoGoError"
  {:added "1.0"
   :go "_ConstructNoGoError(_v)"}
  [^Object _v])

JOKER TYPE go/build.Package from go/build/build.go:
;; (defn ^"GoObject" Package.
;;   "Constructor for build.Package"
;;   {:added "1.0"
;;    :go "_ConstructPackage(_v)"}
;;   [^Object _v])

JOKER FUNC go/build.ArchChar from go/build/build.go:
(defn ArchChar
  "ArchChar returns \"?\" and an error.\nIn earlier versions of Go, the returned string was used to derive\nthe compiler and linker tool names, the default object file suffix,\nand the default linker output name. As of Go 1.5, those strings\nno longer vary by architecture; they are compile, link, .o, and a.out, respectively.\n\nGo input arguments: (goarch string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String goarch]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__archChar(__goarch)"}
  [^String __goarch])

JOKER FUNC go/build.Import from go/build/build.go:
(defn Import
  "Import is shorthand for Default.Import.\n\nGo input arguments: (path string, srcDir string, mode ImportMode)\n\nGo return type: (*Package, error)\n\nJoker input arguments: [^String path, ^String srcDir, ^go.std.go.build/ImportMode mode]\n\nJoker return type: [(atom-of go.std.go.build/Package) Error]"
  {:added "1.0"
   :go "__import(__path, __srcDir, *__mode)"}
  [^String __path, ^String __srcDir, ^build/ImportMode __mode])

JOKER FUNC go/build.ImportDir from go/build/build.go:
(defn ImportDir
  "ImportDir is shorthand for Default.ImportDir.\n\nGo input arguments: (dir string, mode ImportMode)\n\nGo return type: (*Package, error)\n\nJoker input arguments: [^String dir, ^go.std.go.build/ImportMode mode]\n\nJoker return type: [(atom-of go.std.go.build/Package) Error]"
  {:added "1.0"
   :go "__importDir(__dir, *__mode)"}
  [^String __dir, ^build/ImportMode __mode])

JOKER FUNC go/build.IsLocalImport from go/build/build.go:
(defn ^"Boolean" IsLocalImport
  "IsLocalImport reports whether the import path is\na local import path, like \".\", \"..\", \"./foo\", or \"../foo\".\n\nGo input arguments: (path string)\n\nGo return type: bool\n\nJoker input arguments: [^String path]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "build.IsLocalImport(__path)"}
  [^String __path])

JOKER TYPE go.std.go.build/Context:
(def
  ^{:doc "A Context specifies the supporting context for a build.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Context"}
  Context)

JOKER TYPE go.std.go.build/ImportMode:
(def
  ^{:doc "An ImportMode controls the behavior of the Import method.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ImportMode"}
  ImportMode)

JOKER TYPE go.std.go.build/MultiplePackageError:
(def
  ^{:doc "MultiplePackageError describes a directory containing\nmultiple buildable Go source files for multiple packages.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_MultiplePackageError"}
  MultiplePackageError)

JOKER TYPE go.std.go.build/NoGoError:
(def
  ^{:doc "NoGoError is the error used by Import to describe a directory\ncontaining no buildable Go source files. (It may still contain\ntest files, files hidden by build tags, and so on.)\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NoGoError"}
  NoGoError)

JOKER TYPE go.std.go.build/Package:
(def
  ^{:doc "A Package describes the Go package found in a directory.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Package"}
  Package)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/build"]
    :doc "Provides a low-level interface to the go/build package.\n\nPackage build gathers information about Go packages.\n\nGo Path\n\nThe Go path is a list of directory trees containing Go source code.\nIt is consulted to resolve imports that cannot be found in the standard\nGo tree. The default path is the value of the GOPATH environment\nvariable, interpreted as a path list appropriate to the operating system\n(on Unix, the variable is a colon-separated string;\non Windows, a semicolon-separated string;\non Plan 9, a list).\n\nEach directory listed in the Go path must have a prescribed structure:\n\nThe src/ directory holds source code. The path below 'src' determines\nthe import path or executable name.\n\nThe pkg/ directory holds installed package objects.\nAs in the Go tree, each target operating system and\narchitecture pair has its own subdirectory of pkg\n(pkg/GOOS_GOARCH).\n\nIf DIR is a directory listed in the Go path, a package with\nsource in DIR/src/foo/bar can be imported as \"foo/bar\" and\nhas its compiled form installed to \"DIR/pkg/GOOS_GOARCH/foo/bar.a\"\n(or, for gccgo, \"DIR/pkg/gccgo/foo/libbar.a\").\n\nThe bin/ directory holds compiled commands.\nEach command is named for its source directory, but only\nusing the final element, not the entire path. That is, the\ncommand with source in DIR/src/foo/quux is installed into\nDIR/bin/quux, not DIR/bin/foo/quux. The foo/ is stripped\nso that you can add DIR/bin to your PATH to get at the\ninstalled commands.\n\nHere's an example directory layout:\n\n\tGOPATH=/home/user/gocode\n\n\t/home/user/gocode/\n\t    src/\n\t        foo/\n\t            bar/               (go code in package bar)\n\t                x.go\n\t            quux/              (go code in package main)\n\t                y.go\n\t    bin/\n\t        quux                   (installed command)\n\t    pkg/\n\t        linux_amd64/\n\t            foo/\n\t                bar.a          (installed package object)\n\nBuild Constraints\n\nA build constraint, also known as a build tag, is a line comment that begins\n\n\t// +build\n\nthat lists the conditions under which a file should be included in the package.\nConstraints may appear in any kind of source file (not just Go), but\nthey must appear near the top of the file, preceded\nonly by blank lines and other line comments. These rules mean that in Go\nfiles a build constraint must appear before the package clause.\n\nTo distinguish build constraints from package documentation, a series of\nbuild constraints must be followed by a blank line.\n\nA build constraint is evaluated as the OR of space-separated options;\neach option evaluates as the AND of its comma-separated terms;\nand each term is an alphanumeric word or, preceded by !, its negation.\nThat is, the build constraint:\n\n\t// +build linux,386 darwin,!cgo\n\ncorresponds to the boolean formula:\n\n\t(linux AND 386) OR (darwin AND (NOT cgo))\n\nA file may have multiple build constraints. The overall constraint is the AND\nof the individual constraints. That is, the build constraints:\n\n\t// +build linux darwin\n\t// +build 386\n\ncorresponds to the boolean formula:\n\n\t(linux OR darwin) AND 386\n\nDuring a particular build, the following words are satisfied:\n\n\t- the target operating system, as spelled by runtime.GOOS\n\t- the target architecture, as spelled by runtime.GOARCH\n\t- the compiler being used, either \"gc\" or \"gccgo\"\n\t- \"cgo\", if ctxt.CgoEnabled is true\n\t- \"go1.1\", from Go version 1.1 onward\n\t- \"go1.2\", from Go version 1.2 onward\n\t- \"go1.3\", from Go version 1.3 onward\n\t- \"go1.4\", from Go version 1.4 onward\n\t- \"go1.5\", from Go version 1.5 onward\n\t- \"go1.6\", from Go version 1.6 onward\n\t- \"go1.7\", from Go version 1.7 onward\n\t- \"go1.8\", from Go version 1.8 onward\n\t- \"go1.9\", from Go version 1.9 onward\n\t- \"go1.10\", from Go version 1.10 onward\n\t- \"go1.11\", from Go version 1.11 onward\n\t- \"go1.12\", from Go version 1.12 onward\n\t- any additional words listed in ctxt.BuildTags\n\nThere are no build tags for beta or minor releases.\n\nIf a file's name, after stripping the extension and a possible _test suffix,\nmatches any of the following patterns:\n\t*_GOOS\n\t*_GOARCH\n\t*_GOOS_GOARCH\n(example: source_windows_amd64.go) where GOOS and GOARCH represent\nany known operating system and architecture values respectively, then\nthe file is considered to have an implicit build constraint requiring\nthose terms (in addition to any explicit constraints in the file).\n\nTo keep a file from being considered for the build:\n\n\t// +build ignore\n\n(any other unsatisfied word will work as well, but ``ignore'' is conventional.)\n\nTo build a file only when using cgo, and only on Linux and OS X:\n\n\t// +build linux,cgo darwin,cgo\n\nSuch a file is usually paired with another file implementing the\ndefault functionality for other systems, which in this case would\ncarry the constraint:\n\n\t// +build !linux,!darwin !cgo\n\nNaming a file dns_windows.go will cause it to be included only when\nbuilding the package for Windows; similarly, math_386.s will be included\nonly when building the package for 32-bit x86.\n\nUsing GOOS=android matches build tags and files as for GOOS=linux\nin addition to android tags and files.\n\nBinary-Only Packages\n\nIt is possible to distribute packages in binary form without including the\nsource code used for compiling the package. To do this, the package must\nbe distributed with a source file not excluded by build constraints and\ncontaining a \"//go:binary-only-package\" comment.\nLike a build constraint, this comment must appear near the top of the file,\npreceded only by blank lines and other line comments and with a blank line\nfollowing the comment, to separate it from the package documentation.\nUnlike build constraints, this comment is only recognized in non-test\nGo source files.\n\nThe minimal source code for a binary-only package is therefore:\n\n\t//go:binary-only-package\n\n\tpackage mypkg\n\nThe source code may include additional Go code. That code is never compiled\nbut will be processed by tools like godoc and might be useful as end-user\ndocumentation.\n"
    :empty false}
  go.std.go.build)
JOKER CONSTANT Bool from go/constant/value.go:
(def
  ^{:doc "non-numeric values\n"
    :added "1.0"
    :tag "Int"
    :go "int(constant.Bool)"}
  Bool)

JOKER CONSTANT Complex from go/constant/value.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(constant.Complex)"}
  Complex)

JOKER CONSTANT Float from go/constant/value.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(constant.Float)"}
  Float)

JOKER CONSTANT Int from go/constant/value.go:
(def
  ^{:doc "numeric values\n"
    :added "1.0"
    :tag "Int"
    :go "int(constant.Int)"}
  Int-renamed)

JOKER CONSTANT String from go/constant/value.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(constant.String)"}
  String-renamed)

JOKER CONSTANT Unknown from go/constant/value.go:
(def
  ^{:doc "unknown values\n"
    :added "1.0"
    :tag "Int"
    :go "int(constant.Unknown)"}
  Unknown)

JOKER TYPE go/constant.Kind from go/constant/value.go:
(defn ^"GoObject" Kind.
  "Constructor for constant.Kind"
  {:added "1.0"
   :go "_ConstructKind(_v)"}
  [^Object _v])

JOKER TYPE go/constant.Value from go/constant/value.go:
;; (defn ^"GoObject" Value.
;;   "Constructor for constant.Value"
;;   {:added "1.0"
;;    :go "_ConstructValue(_v)"}
;;   [^Object _v])

JOKER FUNC go/constant.BinaryOp from go/constant/value.go:
;; (defn BinaryOp
;;   "BinaryOp returns the result of the binary expression x op y.\nThe operation must be defined for the operands. If one of the\noperands is Unknown, the result is Unknown.\nBinaryOp doesn't handle comparisons or shifts; use Compare\nor Shift instead.\n\nTo force integer division of Int operands, use op == token.QUO_ASSIGN\ninstead of token.QUO; the result is guaranteed to be Int in this case.\nDivision by zero leads to a run-time panic.\n\nGo input arguments: (x_ Value, op token.Token, y_ Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x_, ^go.std.go.token/Token op, ^go.std.go.constant/Value y_]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "__binaryOp(*__x_, *__op, *__y_)"}
;;   [^constant/Value __x_, ^token/Token __op, ^constant/Value __y_])

JOKER FUNC go/constant.BitLen from go/constant/value.go:
(defn ^"Int" BitLen
  "BitLen returns the number of bits required to represent\nthe absolute value x in binary representation; x must be an Int or an Unknown.\nIf x is Unknown, the result is 0.\n\nGo input arguments: (x Value)\n\nGo return type: int\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "constant.BitLen(*__x)"}
  [^constant/Value __x])

JOKER FUNC go/constant.BoolVal from go/constant/value.go:
(defn ^"Boolean" BoolVal
  "BoolVal returns the Go boolean value of x, which must be a Bool or an Unknown.\nIf x is Unknown, the result is false.\n\nGo input arguments: (x Value)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "constant.BoolVal(*__x)"}
  [^constant/Value __x])

JOKER FUNC go/constant.Bytes from go/constant/value.go:
(defn Bytes
  "Bytes returns the bytes for the absolute value of x in little-\nendian binary representation; x must be an Int.\n\nGo input arguments: (x Value)\n\nGo return type: []byte\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__bytes(*__x)"}
  [^constant/Value __x])

JOKER FUNC go/constant.Compare from go/constant/value.go:
;; (defn ^"Boolean" Compare
;;   "Compare returns the result of the comparison x op y.\nThe comparison must be defined for the operands.\nIf one of the operands is Unknown, the result is\nfalse.\n\nGo input arguments: (x_ Value, op token.Token, y_ Value)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.constant/Value x_, ^go.std.go.token/Token op, ^go.std.go.constant/Value y_]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "constant.Compare(*__x_, *__op, *__y_)"}
;;   [^constant/Value __x_, ^token/Token __op, ^constant/Value __y_])

JOKER FUNC go/constant.Denom from go/constant/value.go:
(defn Denom
  "Denom returns the denominator of x; x must be Int, Float, or Unknown.\nIf x is Unknown, or if it is too large or small to represent as a\nfraction, the result is Unknown. Otherwise the result is an Int >= 1.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__denom(*__x)"}
  [^constant/Value __x])

JOKER FUNC go/constant.Float32Val from go/constant/value.go:
;; (defn Float32Val
;;   "Float32Val is like Float64Val but for float32 instead of float64.\n\nGo input arguments: (x Value)\n\nGo return type: (float32, bool)\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: [Double Boolean]"
;;   {:added "1.0"
;;    :go "__float32Val(*__x)"}
;;   [^constant/Value __x])

JOKER FUNC go/constant.Float64Val from go/constant/value.go:
;; (defn Float64Val
;;   "Float64Val returns the nearest Go float64 value of x and whether the result is exact;\nx must be numeric or an Unknown, but not Complex. For values too small (too close to 0)\nto represent as float64, Float64Val silently underflows to 0. The result sign always\nmatches the sign of x, even for 0.\nIf x is Unknown, the result is (0, false).\n\nGo input arguments: (x Value)\n\nGo return type: (float64, bool)\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: [Double Boolean]"
;;   {:added "1.0"
;;    :go "__float64Val(*__x)"}
;;   [^constant/Value __x])

JOKER FUNC go/constant.Imag from go/constant/value.go:
(defn Imag
  "Imag returns the imaginary part of x, which must be a numeric or unknown value.\nIf x is Unknown, the result is Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__imag(*__x)"}
  [^constant/Value __x])

JOKER FUNC go/constant.Int64Val from go/constant/value.go:
(defn Int64Val
  "Int64Val returns the Go int64 value of x and whether the result is exact;\nx must be an Int or an Unknown. If the result is not exact, its value is undefined.\nIf x is Unknown, the result is (0, false).\n\nGo input arguments: (x Value)\n\nGo return type: (int64, bool)\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: [Number Boolean]"
  {:added "1.0"
   :go "__int64Val(*__x)"}
  [^constant/Value __x])

JOKER FUNC go/constant.MakeBool from go/constant/value.go:
(defn MakeBool
  "MakeBool returns the Bool value for b.\n\nGo input arguments: (b bool)\n\nGo return type: Value\n\nJoker input arguments: [^Boolean b]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__makeBool(__b)"}
  [^Boolean __b])

JOKER FUNC go/constant.MakeFloat64 from go/constant/value.go:
;; (defn MakeFloat64
;;   "MakeFloat64 returns the Float value for x.\nIf x is not finite, the result is an Unknown.\n\nGo input arguments: (x float64)\n\nGo return type: Value\n\nJoker input arguments: [^Double x]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "__makeFloat64(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC go/constant.MakeFromBytes from go/constant/value.go:
;; (defn MakeFromBytes
;;   "MakeFromBytes returns the Int value given the bytes of its little-endian\nbinary representation. An empty byte slice argument represents 0.\n\nGo input arguments: (bytes []byte)\n\nGo return type: Value\n\nJoker input arguments: [^(vector-of Int) bytes]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "__makeFromBytes(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__bytes)))"}
;;   [^Object __bytes])

JOKER FUNC go/constant.MakeFromLiteral from go/constant/value.go:
;; (defn MakeFromLiteral
;;   "MakeFromLiteral returns the corresponding integer, floating-point,\nimaginary, character, or string value for a Go literal string. The\ntok value must be one of token.INT, token.FLOAT, token.IMAG,\ntoken.CHAR, or token.STRING. The final argument must be zero.\nIf the literal string syntax is invalid, the result is an Unknown.\n\nGo input arguments: (lit string, tok token.Token, zero uint)\n\nGo return type: Value\n\nJoker input arguments: [^String lit, ^go.std.go.token/Token tok, ^Number zero]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "__makeFromLiteral(__lit, *__tok, __zero)"}
;;   [^String __lit, ^token/Token __tok, ^UInt __zero])

JOKER FUNC go/constant.MakeImag from go/constant/value.go:
(defn MakeImag
  "MakeImag returns the Complex value x*i;\nx must be Int, Float, or Unknown.\nIf x is Unknown, the result is Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__makeImag(*__x)"}
  [^constant/Value __x])

JOKER FUNC go/constant.MakeInt64 from go/constant/value.go:
(defn MakeInt64
  "MakeInt64 returns the Int value for x.\n\nGo input arguments: (x int64)\n\nGo return type: Value\n\nJoker input arguments: [^Number x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__makeInt64(__x)"}
  [^Int64 __x])

JOKER FUNC go/constant.MakeString from go/constant/value.go:
(defn MakeString
  "MakeString returns the String value for s.\n\nGo input arguments: (s string)\n\nGo return type: Value\n\nJoker input arguments: [^String s]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__makeString(__s)"}
  [^String __s])

JOKER FUNC go/constant.MakeUint64 from go/constant/value.go:
(defn MakeUint64
  "MakeUint64 returns the Int value for x.\n\nGo input arguments: (x uint64)\n\nGo return type: Value\n\nJoker input arguments: [^Number x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__makeUint64(__x)"}
  [^UInt64 __x])

JOKER FUNC go/constant.MakeUnknown from go/constant/value.go:
(defn MakeUnknown
  "MakeUnknown returns the Unknown value.\n\nGo return type: Value\n\nJoker input arguments: []\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__makeUnknown()"}
  [])

JOKER FUNC go/constant.Num from go/constant/value.go:
(defn Num
  "Num returns the numerator of x; x must be Int, Float, or Unknown.\nIf x is Unknown, or if it is too large or small to represent as a\nfraction, the result is Unknown. Otherwise the result is an Int\nwith the same sign as x.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__num(*__x)"}
  [^constant/Value __x])

JOKER FUNC go/constant.Real from go/constant/value.go:
(defn Real
  "Real returns the real part of x, which must be a numeric or unknown value.\nIf x is Unknown, the result is Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__real(*__x)"}
  [^constant/Value __x])

JOKER FUNC go/constant.Shift from go/constant/value.go:
;; (defn Shift
;;   "Shift returns the result of the shift expression x op s\nwith op == token.SHL or token.SHR (<< or >>). x must be\nan Int or an Unknown. If x is Unknown, the result is x.\n\nGo input arguments: (x Value, op token.Token, s uint)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x, ^go.std.go.token/Token op, ^Number s]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "__shift(*__x, *__op, __s)"}
;;   [^constant/Value __x, ^token/Token __op, ^UInt __s])

JOKER FUNC go/constant.Sign from go/constant/value.go:
(defn ^"Int" Sign
  "Sign returns -1, 0, or 1 depending on whether x < 0, x == 0, or x > 0;\nx must be numeric or Unknown. For complex values x, the sign is 0 if x == 0,\notherwise it is != 0. If x is Unknown, the result is 1.\n\nGo input arguments: (x Value)\n\nGo return type: int\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "constant.Sign(*__x)"}
  [^constant/Value __x])

JOKER FUNC go/constant.StringVal from go/constant/value.go:
(defn ^"String" StringVal
  "StringVal returns the Go string value of x, which must be a String or an Unknown.\nIf x is Unknown, the result is \"\".\n\nGo input arguments: (x Value)\n\nGo return type: string\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: String"
  {:added "1.0"
   :go "constant.StringVal(*__x)"}
  [^constant/Value __x])

JOKER FUNC go/constant.ToComplex from go/constant/value.go:
(defn ToComplex
  "ToComplex converts x to a Complex value if x is representable as a Complex.\nOtherwise it returns an Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__toComplex(*__x)"}
  [^constant/Value __x])

JOKER FUNC go/constant.ToFloat from go/constant/value.go:
(defn ToFloat
  "ToFloat converts x to a Float value if x is representable as a Float.\nOtherwise it returns an Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__toFloat(*__x)"}
  [^constant/Value __x])

JOKER FUNC go/constant.ToInt from go/constant/value.go:
(defn ToInt
  "ToInt converts x to an Int value if x is representable as an Int.\nOtherwise it returns an Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__toInt(*__x)"}
  [^constant/Value __x])

JOKER FUNC go/constant.Uint64Val from go/constant/value.go:
(defn Uint64Val
  "Uint64Val returns the Go uint64 value of x and whether the result is exact;\nx must be an Int or an Unknown. If the result is not exact, its value is undefined.\nIf x is Unknown, the result is (0, false).\n\nGo input arguments: (x Value)\n\nGo return type: (uint64, bool)\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: [Number Boolean]"
  {:added "1.0"
   :go "__uint64Val(*__x)"}
  [^constant/Value __x])

JOKER FUNC go/constant.UnaryOp from go/constant/value.go:
;; (defn UnaryOp
;;   "UnaryOp returns the result of the unary expression op y.\nThe operation must be defined for the operand.\nIf prec > 0 it specifies the ^ (xor) result size in bits.\nIf y is Unknown, the result is Unknown.\n\nGo input arguments: (op token.Token, y Value, prec uint)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.token/Token op, ^go.std.go.constant/Value y, ^Number prec]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "__unaryOp(*__op, *__y, __prec)"}
;;   [^token/Token __op, ^constant/Value __y, ^UInt __prec])

JOKER TYPE go.std.go.constant/Kind:
(def
  ^{:doc "Kind specifies the kind of value represented by a Value.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Kind"}
  Kind)

JOKER TYPE go.std.go.constant/Value:
(def
  ^{:doc "A Value represents the value of a Go constant.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Value"}
  Value)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/constant"]
    :doc "Provides a low-level interface to the go/constant package.\n\nPackage constant implements Values representing untyped\nGo constants and their corresponding operations.\n\nA special Unknown value may be used when a value\nis unknown due to an error. Operations on unknown\nvalues produce unknown values unless specified\notherwise.\n"
    :empty false}
  go.std.go.constant)
JOKER CONSTANT AllDecls from go/doc/doc.go:
(def
  ^{:doc "AllDecls says to extract documentation for all package-level\ndeclarations, not just exported ones.\n"
    :added "1.0"
    :tag "Int"
    :go "int(doc.AllDecls)"}
  AllDecls)

JOKER CONSTANT AllMethods from go/doc/doc.go:
(def
  ^{:doc "AllMethods says to show all embedded methods, not just the ones of\ninvisible (unexported) anonymous fields.\n"
    :added "1.0"
    :tag "Int"
    :go "int(doc.AllMethods)"}
  AllMethods)

JOKER CONSTANT PreserveAST from go/doc/doc.go:
(def
  ^{:doc "PreserveAST says to leave the AST unmodified. Originally, pieces of\nthe AST such as function bodies were nil-ed out to save memory in\ngodoc, but not all programs want that behavior.\n"
    :added "1.0"
    :tag "Int"
    :go "int(doc.PreserveAST)"}
  PreserveAST)

JOKER VARIABLE IllegalPrefixes from go/doc/synopsis.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "doc.IllegalPrefixes"}
  IllegalPrefixes)

JOKER TYPE go/doc.Example from go/doc/example.go:
;; (defn ^"GoObject" Example.
;;   "Constructor for doc.Example"
;;   {:added "1.0"
;;    :go "_ConstructExample(_v)"}
;;   [^Object _v])

JOKER TYPE go/doc.Filter from go/doc/filter.go:
;; (defn ^"GoObject" Filter.
;;   "Constructor for doc.Filter"
;;   {:added "1.0"
;;    :go "_ConstructFilter(_v)"}
;;   [^Object _v])

JOKER TYPE go/doc.Func from go/doc/doc.go:
;; (defn ^"GoObject" Func.
;;   "Constructor for doc.Func"
;;   {:added "1.0"
;;    :go "_ConstructFunc(_v)"}
;;   [^Object _v])

JOKER TYPE go/doc.Mode from go/doc/doc.go:
(defn ^"GoObject" Mode.
  "Constructor for doc.Mode"
  {:added "1.0"
   :go "_ConstructMode(_v)"}
  [^Object _v])

JOKER TYPE go/doc.Note from go/doc/doc.go:
;; (defn ^"GoObject" Note.
;;   "Constructor for doc.Note"
;;   {:added "1.0"
;;    :go "_ConstructNote(_v)"}
;;   [^Object _v])

JOKER TYPE go/doc.Package from go/doc/doc.go:
;; (defn ^"GoObject" Package.
;;   "Constructor for doc.Package"
;;   {:added "1.0"
;;    :go "_ConstructPackage(_v)"}
;;   [^Object _v])

JOKER TYPE go/doc.Type from go/doc/doc.go:
;; (defn ^"GoObject" Type.
;;   "Constructor for doc.Type"
;;   {:added "1.0"
;;    :go "_ConstructType(_v)"}
;;   [^Object _v])

JOKER TYPE go/doc.Value from go/doc/doc.go:
;; (defn ^"GoObject" Value.
;;   "Constructor for doc.Value"
;;   {:added "1.0"
;;    :go "_ConstructValue(_v)"}
;;   [^Object _v])

JOKER FUNC go/doc.Examples from go/doc/example.go:
;; (defn Examples
;;   "Examples returns the examples found in the files, sorted by Name field.\nThe Order fields record the order in which the examples were encountered.\n\nPlayable Examples must be in a package whose name ends in \"_test\".\nAn Example is \"playable\" (the Play field is non-nil) in either of these\ncircumstances:\n  - The example function is self-contained: the function references only\n    identifiers from other packages (or predeclared identifiers, such as\n    \"int\") and the test file does not include a dot import.\n  - The entire test file is the example: the file contains exactly one\n    example function, zero test or benchmark functions, and at least one\n    top-level function, type, variable, or constant declaration other\n    than the example function.\n\nGo input arguments: (files ...*ast.File)\n\nGo return type: []*Example\n\nJoker input arguments: [^(ellipsis-somehow ast/File) files]\n\nJoker return type: (vector-of (atom-of go.std.go.doc/Example))"
;;   {:added "1.0"
;;    :go "__examples(ConvertToEllipsisHaHa*ABEND987(genutils.go: imports not yet supported: ast.File)(__files))"}
;;   [^ast/File __files])

JOKER FUNC go/doc.IsPredeclared from go/doc/reader.go:
(defn ^"Boolean" IsPredeclared
  "IsPredeclared reports whether s is a predeclared identifier.\n\nGo input arguments: (s string)\n\nGo return type: bool\n\nJoker input arguments: [^String s]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "doc.IsPredeclared(__s)"}
  [^String __s])

JOKER FUNC go/doc.New from go/doc/doc.go:
;; (defn New
;;   "New computes the package documentation for the given package AST.\nNew takes ownership of the AST pkg and may edit or overwrite it.\n\nGo input arguments: (pkg *ast.Package, importPath string, mode Mode)\n\nGo return type: *Package\n\nJoker input arguments: [^(atom-of go.std.go.ast/Package) pkg, ^String importPath, ^go.std.go.doc/Mode mode]\n\nJoker return type: (atom-of go.std.go.doc/Package)"
;;   {:added "1.0"
;;    :go "__new(__pkg, __importPath, *__mode)"}
;;   [^ast/Package __pkg, ^String __importPath, ^doc/Mode __mode])

JOKER FUNC go/doc.Synopsis from go/doc/synopsis.go:
(defn ^"String" Synopsis
  "Synopsis returns a cleaned version of the first sentence in s.\nThat sentence ends after the first period followed by space and\nnot preceded by exactly one uppercase letter. The result string\nhas no \\n, \\r, or \\t characters and uses only single spaces between\nwords. If s starts with any of the IllegalPrefixes, the result\nis the empty string.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "doc.Synopsis(__s)"}
  [^String __s])

JOKER FUNC go/doc.ToHTML from go/doc/comment.go:
;; (defn ToHTML
;;   "ToHTML converts comment text to formatted HTML.\nThe comment was prepared by DocReader,\nso it is known not to have leading, trailing blank lines\nnor to have trailing spaces at the end of lines.\nThe comment markers have already been removed.\n\nEach span of unindented non-blank lines is converted into\na single paragraph. There is one exception to the rule: a span that\nconsists of a single line, is followed by another paragraph span,\nbegins with a capital letter, and contains no punctuation\nother than parentheses and commas is formatted as a heading.\n\nA span of indented lines is converted into a <pre> block,\nwith the common indent prefix removed.\n\nURLs in the comment text are converted into links; if the URL also appears\nin the words map, the link is taken from the map (if the corresponding map\nvalue is the empty string, the URL is not converted into a link).\n\nGo identifiers that appear in the words map are italicized; if the corresponding\nmap value is not the empty string, it is considered a URL and the word is converted\ninto a link.\n\nGo input arguments: (w io.Writer, text string, words map[])\n\nJoker input arguments: [^go.std.io/Writer w, ^String text, ^{} words]"
;;   {:added "1.0"
;;    :go "__toHTML(*__w, __text, ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa()))"}
;;   [^io/Writer __w, ^String __text, ^{} __words])

JOKER FUNC go/doc.ToText from go/doc/comment.go:
;; (defn ToText
;;   "ToText prepares comment text for presentation in textual output.\nIt wraps paragraphs of text to width or fewer Unicode code points\nand then prefixes each line with the indent. In preformatted sections\n(such as program text), it prefixes each non-blank line with preIndent.\n\nGo input arguments: (w io.Writer, text string, indent string, preIndent string, width int)\n\nJoker input arguments: [^go.std.io/Writer w, ^String text, ^String indent, ^String preIndent, ^Int width]"
;;   {:added "1.0"
;;    :go "__toText(*__w, __text, __indent, __preIndent, __width)"}
;;   [^io/Writer __w, ^String __text, ^String __indent, ^String __preIndent, ^Int __width])

JOKER TYPE go.std.go.doc/Example:
(def
  ^{:doc "An Example represents an example function found in a source files.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Example"}
  Example)

JOKER TYPE go.std.go.doc/Filter:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Filter"}
  Filter)

JOKER TYPE go.std.go.doc/Func:
(def
  ^{:doc "Func is the documentation for a func declaration.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Func"}
  Func)

JOKER TYPE go.std.go.doc/Mode:
(def
  ^{:doc "Mode values control the operation of New.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Mode"}
  Mode)

JOKER TYPE go.std.go.doc/Note:
(def
  ^{:doc "A Note represents a marked comment starting with \"MARKER(uid): note body\".\nAny note with a marker of 2 or more upper case [A-Z] letters and a uid of\nat least one character is recognized. The \":\" following the uid is optional.\nNotes are collected in the Package.Notes map indexed by the notes marker.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Note"}
  Note)

JOKER TYPE go.std.go.doc/Package:
(def
  ^{:doc "Package is the documentation for an entire package.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Package"}
  Package)

JOKER TYPE go.std.go.doc/Type:
(def
  ^{:doc "Type is the documentation for a type declaration.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Type"}
  Type)

JOKER TYPE go.std.go.doc/Value:
(def
  ^{:doc "Value is the documentation for a (possibly grouped) var or const declaration.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Value"}
  Value)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/doc"]
    :doc "Provides a low-level interface to the go/doc package.\n\nPackage doc extracts source code documentation from a Go AST.\n"
    :empty false}
  go.std.go.doc)
JOKER FUNC go/format.Node from go/format/format.go:
;; (defn ^"Error" Node
;;   "Node formats node in canonical gofmt style and writes the result to dst.\n\nThe node type must be *ast.File, *printer.CommentedNode, []ast.Decl,\n[]ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec,\nor ast.Stmt. Node does not modify node. Imports are not sorted for\nnodes representing partial source files (for instance, if the node is\nnot an *ast.File or a *printer.CommentedNode not wrapping an *ast.File).\n\nThe function may return early (before the entire result is written)\nand return a formatting error, for instance due to an incorrect AST.\n\nGo input arguments: (dst io.Writer, fset *token.FileSet, node interface {})\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer dst, ^(atom-of go.std.go.token/FileSet) fset, ^<protocol-or-something> node]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "format.Node(*__dst, __fset, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io/Writer __dst, ^token/FileSet __fset, ^<protocol-or-something> __node])

JOKER FUNC go/format.Source from go/format/format.go:
;; (defn Source
;;   "Source formats src in canonical gofmt style and returns the result\nor an (I/O or syntax) error. src is expected to be a syntactically\ncorrect Go source file, or a list of Go declarations or statements.\n\nIf src is a partial source file, the leading and trailing space of src\nis applied to the result (such that it has the same leading and trailing\nspace as src), and the result is indented by the same amount as the first\nline of src containing code. Imports are not sorted for partial source files.\n\nGo input arguments: (src []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(vector-of Int) src]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__source(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__src)))"}
;;   [^Object __src])

JOKER TYPE go/importer.Lookup from go/importer/importer.go:
;; (defn ^"GoObject" Lookup.
;;   "Constructor for importer.Lookup"
;;   {:added "1.0"
;;    :go "_ConstructLookup(_v)"}
;;   [^Object _v])

JOKER FUNC go/importer.Default from go/importer/importer.go:
(defn Default
  "Default returns an Importer for the compiler that built the running binary.\nIf available, the result implements types.ImporterFrom.\n\nGo return type: go/types.Importer\n\nJoker input arguments: []\n\nJoker return type: go.std.go.types/Importer"
  {:added "1.0"
   :go "__default()"}
  [])

JOKER FUNC go/importer.For from go/importer/importer.go:
(defn For
  "For calls ForCompiler with a new FileSet.\n\nDeprecated: use ForCompiler, which populates a FileSet\nwith the positions of objects created by the importer.\n\nGo input arguments: (compiler string, lookup Lookup)\n\nGo return type: go/types.Importer\n\nJoker input arguments: [^String compiler, ^go.std.go.importer/Lookup lookup]\n\nJoker return type: go.std.go.types/Importer"
  {:added "1.0"
   :go "__for(__compiler, *__lookup)"}
  [^String __compiler, ^importer/Lookup __lookup])

JOKER FUNC go/importer.ForCompiler from go/importer/importer.go:
;; (defn ForCompiler
;;   "ForCompiler returns an Importer for importing from installed packages\nfor the compilers \"gc\" and \"gccgo\", or for importing directly\nfrom the source if the compiler argument is \"source\". In this\nlatter case, importing may fail under circumstances where the\nexported API is not entirely defined in pure Go source code\n(if the package API depends on cgo-defined entities, the type\nchecker won't have access to those).\n\nIf lookup is nil, the default package lookup mechanism for the\ngiven compiler is used, and the resulting importer attempts\nto resolve relative and absolute import paths to canonical\nimport path IDs before finding the imported file.\n\nIf lookup is non-nil, then the returned importer calls lookup\neach time it needs to resolve an import path. In this mode\nthe importer can only be invoked with canonical import paths\n(not relative or absolute ones); it is assumed that the translation\nto canonical import paths is being done by the client of the\nimporter.\n\nGo input arguments: (fset *token.FileSet, compiler string, lookup Lookup)\n\nGo return type: go/types.Importer\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^String compiler, ^go.std.go.importer/Lookup lookup]\n\nJoker return type: go.std.go.types/Importer"
;;   {:added "1.0"
;;    :go "__forCompiler(__fset, __compiler, *__lookup)"}
;;   [^token/FileSet __fset, ^String __compiler, ^importer/Lookup __lookup])

JOKER TYPE go.std.go.importer/Lookup:
(def
  ^{:doc "A Lookup function returns a reader to access package data for\na given import path, or an error if no matching package is found.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Lookup"}
  Lookup)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the go/importer package.\n\nPackage importer provides access to export data importers.\n"
    :empty false}
  go.std.go.importer)
JOKER CONSTANT AllErrors from go/parser/interface.go:
(def
  ^{:doc "report all errors (not just the first 10 on different lines)\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(parser.AllErrors))"}
  AllErrors)

JOKER CONSTANT DeclarationErrors from go/parser/interface.go:
(def
  ^{:doc "report declaration errors\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(parser.DeclarationErrors))"}
  DeclarationErrors)

JOKER CONSTANT ImportsOnly from go/parser/interface.go:
(def
  ^{:doc "stop parsing after import declarations\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(parser.ImportsOnly))"}
  ImportsOnly)

JOKER CONSTANT PackageClauseOnly from go/parser/interface.go:
(def
  ^{:doc "stop parsing after package clause\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(parser.PackageClauseOnly))"}
  PackageClauseOnly)

JOKER CONSTANT ParseComments from go/parser/interface.go:
(def
  ^{:doc "parse comments and add them to AST\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(parser.ParseComments))"}
  ParseComments)

JOKER CONSTANT SpuriousErrors from go/parser/interface.go:
(def
  ^{:doc "same as AllErrors, for backward-compatibility\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(parser.SpuriousErrors))"}
  SpuriousErrors)

JOKER CONSTANT Trace from go/parser/interface.go:
(def
  ^{:doc "print a trace of parsed productions\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(parser.Trace))"}
  Trace)

JOKER TYPE go/parser.Mode from go/parser/interface.go:
(defn ^"GoObject" Mode.
  "Constructor for parser.Mode"
  {:added "1.0"
   :go "_ConstructMode(_v)"}
  [^Object _v])

JOKER FUNC go/parser.ParseDir from go/parser/interface.go:
;; (defn ParseDir
;;   "ParseDir calls ParseFile for all files with names ending in \".go\" in the\ndirectory specified by path and returns a map of package name -> package\nAST with all the packages found.\n\nIf filter != nil, only the files with os.FileInfo entries passing through\nthe filter (and ending in \".go\") are considered. The mode bits are passed\nto ParseFile unchanged. Position information is recorded in fset, which\nmust not be nil.\n\nIf the directory couldn't be read, a nil map and the respective error are\nreturned. If a parse error occurred, a non-nil but incomplete map and the\nfirst error encountered are returned.\n\nGo input arguments: (fset *token.FileSet, path string, filter func, mode Mode)\n\nGo return type: (pkgs ..., first error)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^String path, ^fn filter, ^go.std.go.parser/Mode mode]\n\nJoker return type: [ABEND883(post.go: unrecognized Expr type *ast.MapType at: /usr/local/go/src/go/parser/interface.go:135:97) Error]"
;;   {:added "1.0"
;;    :go "__parseDir(__fset, __path, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), *__mode)"}
;;   [^token/FileSet __fset, ^String __path, ^fn __filter, ^parser/Mode __mode])

JOKER FUNC go/parser.ParseExpr from go/parser/interface.go:
(defn ParseExpr
  "ParseExpr is a convenience function for obtaining the AST of an expression x.\nThe position information recorded in the AST is undefined. The filename used\nin error messages is the empty string.\n\nGo input arguments: (x string)\n\nGo return type: (go/ast.Expr, error)\n\nJoker input arguments: [^String x]\n\nJoker return type: [go.std.go.ast/Expr Error]"
  {:added "1.0"
   :go "__parseExpr(__x)"}
  [^String __x])

JOKER FUNC go/parser.ParseExprFrom from go/parser/interface.go:
;; (defn ParseExprFrom
;;   "ParseExprFrom is a convenience function for parsing an expression.\nThe arguments have the same meaning as for ParseFile, but the source must\nbe a valid Go (type or value) expression. Specifically, fset must not\nbe nil.\n\nGo input arguments: (fset *token.FileSet, filename string, src interface {}, mode Mode)\n\nGo return type: (go/ast.Expr, error)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^String filename, ^<protocol-or-something> src, ^go.std.go.parser/Mode mode]\n\nJoker return type: [go.std.go.ast/Expr Error]"
;;   {:added "1.0"
;;    :go "__parseExprFrom(__fset, __filename, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), *__mode)"}
;;   [^token/FileSet __fset, ^String __filename, ^<protocol-or-something> __src, ^parser/Mode __mode])

JOKER FUNC go/parser.ParseFile from go/parser/interface.go:
;; (defn ParseFile
;;   "ParseFile parses the source code of a single Go source file and returns\nthe corresponding ast.File node. The source code may be provided via\nthe filename of the source file, or via the src parameter.\n\nIf src != nil, ParseFile parses the source from src and the filename is\nonly used when recording position information. The type of the argument\nfor the src parameter must be string, []byte, or io.Reader.\nIf src == nil, ParseFile parses the file specified by filename.\n\nThe mode parameter controls the amount of source text parsed and other\noptional parser functionality. Position information is recorded in the\nfile set fset, which must not be nil.\n\nIf the source couldn't be read, the returned AST is nil and the error\nindicates the specific failure. If the source was read but syntax\nerrors were found, the result is a partial AST (with ast.Bad* nodes\nrepresenting the fragments of erroneous source code). Multiple errors\nare returned via a scanner.ErrorList which is sorted by file position.\n\nGo input arguments: (fset *token.FileSet, filename string, src interface {}, mode Mode)\n\nGo return type: (f *go/ast.File, err error)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^String filename, ^<protocol-or-something> src, ^go.std.go.parser/Mode mode]\n\nJoker return type: [(atom-of go.std.go.ast/File) Error]"
;;   {:added "1.0"
;;    :go "__parseFile(__fset, __filename, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), *__mode)"}
;;   [^token/FileSet __fset, ^String __filename, ^<protocol-or-something> __src, ^parser/Mode __mode])

JOKER TYPE go.std.go.parser/Mode:
(def
  ^{:doc "A Mode value is a set of flags (or 0).\nThey control the amount of source code parsed and other optional\nparser functionality.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Mode"}
  Mode)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/parser"]
    :doc "Provides a low-level interface to the go/parser package.\n\nPackage parser implements a parser for Go source files. Input may be\nprovided in a variety of forms (see the various Parse* functions); the\noutput is an abstract syntax tree (AST) representing the Go source. The\nparser is invoked through one of the Parse* functions.\n\nThe parser accepts a larger language than is syntactically permitted by\nthe Go spec, for simplicity, and for improved robustness in the presence\nof syntax errors. For instance, in method declarations, the receiver is\ntreated like an ordinary parameter list and thus may contain multiple\nentries where the spec permits exactly one. Consequently, the corresponding\nfield in the AST (ast.FuncDecl.Recv) field is not restricted to one entry.\n"
    :empty false}
  go.std.go.parser)
JOKER CONSTANT RawFormat from go/printer/printer.go:
(def
  ^{:doc "do not use a tabwriter; if set, UseSpaces is ignored\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(printer.RawFormat))"}
  RawFormat)

JOKER CONSTANT SourcePos from go/printer/printer.go:
(def
  ^{:doc "emit //line directives to preserve original source positions\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(printer.SourcePos))"}
  SourcePos)

JOKER CONSTANT TabIndent from go/printer/printer.go:
(def
  ^{:doc "use tabs for indentation independent of UseSpaces\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(printer.TabIndent))"}
  TabIndent)

JOKER CONSTANT UseSpaces from go/printer/printer.go:
(def
  ^{:doc "use spaces instead of tabs for alignment\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(printer.UseSpaces))"}
  UseSpaces)

JOKER TYPE go/printer.CommentedNode from go/printer/printer.go:
;; (defn ^"GoObject" CommentedNode.
;;   "Constructor for printer.CommentedNode"
;;   {:added "1.0"
;;    :go "_ConstructCommentedNode(_v)"}
;;   [^Object _v])

JOKER TYPE go/printer.Config from go/printer/printer.go:
(defn ^"GoObject" Config.
  "Constructor for printer.Config"
  {:added "1.0"
   :go "_ConstructConfig(_v)"}
  [^Object _v])

JOKER TYPE go/printer.Mode from go/printer/printer.go:
(defn ^"GoObject" Mode.
  "Constructor for printer.Mode"
  {:added "1.0"
   :go "_ConstructMode(_v)"}
  [^Object _v])

JOKER FUNC go/printer.Fprint from go/printer/printer.go:
;; (defn ^"Error" Fprint
;;   "Fprint \"pretty-prints\" an AST node to output.\nIt calls Config.Fprint with default settings.\nNote that gofmt uses tabs for indentation but spaces for alignment;\nuse format.Node (package go/format) for output that matches gofmt.\n\nGo input arguments: (output io.Writer, fset *token.FileSet, node interface {})\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer output, ^(atom-of go.std.go.token/FileSet) fset, ^<protocol-or-something> node]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "printer.Fprint(*__output, __fset, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io/Writer __output, ^token/FileSet __fset, ^<protocol-or-something> __node])

JOKER TYPE go.std.go.printer/CommentedNode:
(def
  ^{:doc "A CommentedNode bundles an AST node and corresponding comments.\nIt may be provided as argument to any of the Fprint functions.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CommentedNode"}
  CommentedNode)

JOKER TYPE go.std.go.printer/Config:
(def
  ^{:doc "A Config node controls the output of Fprint.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Config"}
  Config)

JOKER TYPE go.std.go.printer/Mode:
(def
  ^{:doc "A Mode value is a set of flags (or 0). They control printing.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Mode"}
  Mode)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/printer"]
    :doc "Provides a low-level interface to the go/printer package.\n\nPackage printer implements printing of AST nodes.\n"
    :empty false}
  go.std.go.printer)
JOKER CONSTANT ScanComments from go/scanner/scanner.go:
(def
  ^{:doc "return comments as COMMENT tokens\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(scanner.ScanComments))"}
  ScanComments)

JOKER TYPE go/scanner.Error from go/scanner/errors.go:
;; (defn ^"GoObject" Error.
;;   "Constructor for scanner.Error"
;;   {:added "1.0"
;;    :go "_ConstructError(_v)"}
;;   [^Object _v])

JOKER TYPE go/scanner.ErrorHandler from go/scanner/scanner.go:
;; (defn ^"GoObject" ErrorHandler.
;;   "Constructor for scanner.ErrorHandler"
;;   {:added "1.0"
;;    :go "_ConstructErrorHandler(_v)"}
;;   [^Object _v])

JOKER TYPE go/scanner.ErrorList from go/scanner/errors.go:
;; (defn ^"GoObject" ErrorList.
;;   "Constructor for scanner.ErrorList"
;;   {:added "1.0"
;;    :go "_ConstructErrorList(_v)"}
;;   [^Object _v])

JOKER TYPE go/scanner.Mode from go/scanner/scanner.go:
(defn ^"GoObject" Mode.
  "Constructor for scanner.Mode"
  {:added "1.0"
   :go "_ConstructMode(_v)"}
  [^Object _v])

JOKER TYPE go/scanner.Scanner from go/scanner/scanner.go:
(defn ^"GoObject" Scanner.
  "Constructor for scanner.Scanner"
  {:added "1.0"
   :go "_ConstructScanner(_v)"}
  [^Object _v])

JOKER FUNC go/scanner.PrintError from go/scanner/errors.go:
;; (defn PrintError
;;   "PrintError is a utility function that prints a list of errors to w,\none error per line, if the err parameter is an ErrorList. Otherwise\nit prints the err string.\n\nGo input arguments: (w io.Writer, err error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Error err]"
;;   {:added "1.0"
;;    :go "__printError(*__w, __err)"}
;;   [^io/Writer __w, ^Error __err])

JOKER TYPE go.std.go.scanner/Error:
(def
  ^{:doc "In an ErrorList, an error is represented by an *Error.\nThe position Pos, if valid, points to the beginning of\nthe offending token, and the error condition is described\nby Msg.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Error"}
  Error)

JOKER TYPE go.std.go.scanner/ErrorHandler:
(def
  ^{:doc "An ErrorHandler may be provided to Scanner.Init. If a syntax error is\nencountered and a handler was installed, the handler is called with a\nposition and an error message. The position points to the beginning of\nthe offending token.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ErrorHandler"}
  ErrorHandler)

JOKER TYPE go.std.go.scanner/ErrorList:
(def
  ^{:doc "ErrorList is a list of *Errors.\nThe zero value for an ErrorList is an empty ErrorList ready to use.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ErrorList"}
  ErrorList)

JOKER TYPE go.std.go.scanner/Mode:
(def
  ^{:doc "A mode value is a set of flags (or 0).\nThey control scanner behavior.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Mode"}
  Mode)

JOKER TYPE go.std.go.scanner/Scanner:
(def
  ^{:doc "A Scanner holds the scanner's internal state while processing\na given text. It can be allocated as part of another data\nstructure but must be initialized via Init before use.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Scanner"}
  Scanner)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/scanner"]
    :doc "Provides a low-level interface to the go/scanner package.\n\nPackage scanner implements a scanner for Go source text.\nIt takes a []byte as source which can then be tokenized\nthrough repeated calls to the Scan method.\n"
    :empty false}
  go.std.go.scanner)
JOKER CONSTANT ADD from go/token/token.go:
(def
  ^{:doc "Operators and delimiters\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.ADD)"}
  ADD)

JOKER CONSTANT ADD_ASSIGN from go/token/token.go:
(def
  ^{:doc "+=\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.ADD_ASSIGN)"}
  ADD_ASSIGN)

JOKER CONSTANT AND from go/token/token.go:
(def
  ^{:doc "&\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.AND)"}
  AND)

JOKER CONSTANT AND_ASSIGN from go/token/token.go:
(def
  ^{:doc "&=\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.AND_ASSIGN)"}
  AND_ASSIGN)

JOKER CONSTANT AND_NOT from go/token/token.go:
(def
  ^{:doc "&^\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.AND_NOT)"}
  AND_NOT)

JOKER CONSTANT AND_NOT_ASSIGN from go/token/token.go:
(def
  ^{:doc "&^=\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.AND_NOT_ASSIGN)"}
  AND_NOT_ASSIGN)

JOKER CONSTANT ARROW from go/token/token.go:
(def
  ^{:doc "<-\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.ARROW)"}
  ARROW)

JOKER CONSTANT ASSIGN from go/token/token.go:
(def
  ^{:doc "=\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.ASSIGN)"}
  ASSIGN)

JOKER CONSTANT BREAK from go/token/token.go:
(def
  ^{:doc "Keywords\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.BREAK)"}
  BREAK)

JOKER CONSTANT CASE from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.CASE)"}
  CASE)

JOKER CONSTANT CHAN from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.CHAN)"}
  CHAN)

JOKER CONSTANT CHAR from go/token/token.go:
(def
  ^{:doc "'a'\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.CHAR)"}
  CHAR)

JOKER CONSTANT COLON from go/token/token.go:
(def
  ^{:doc ":\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.COLON)"}
  COLON)

JOKER CONSTANT COMMA from go/token/token.go:
(def
  ^{:doc ",\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.COMMA)"}
  COMMA)

JOKER CONSTANT COMMENT from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.COMMENT)"}
  COMMENT)

JOKER CONSTANT CONST from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.CONST)"}
  CONST)

JOKER CONSTANT CONTINUE from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.CONTINUE)"}
  CONTINUE)

JOKER CONSTANT DEC from go/token/token.go:
(def
  ^{:doc "--\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.DEC)"}
  DEC)

JOKER CONSTANT DEFAULT from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.DEFAULT)"}
  DEFAULT)

JOKER CONSTANT DEFER from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.DEFER)"}
  DEFER)

JOKER CONSTANT DEFINE from go/token/token.go:
(def
  ^{:doc ":=\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.DEFINE)"}
  DEFINE)

JOKER CONSTANT ELLIPSIS from go/token/token.go:
(def
  ^{:doc "...\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.ELLIPSIS)"}
  ELLIPSIS)

JOKER CONSTANT ELSE from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.ELSE)"}
  ELSE)

JOKER CONSTANT EOF from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.EOF)"}
  EOF)

JOKER CONSTANT EQL from go/token/token.go:
(def
  ^{:doc "==\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.EQL)"}
  EQL)

JOKER CONSTANT FALLTHROUGH from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.FALLTHROUGH)"}
  FALLTHROUGH)

JOKER CONSTANT FLOAT from go/token/token.go:
(def
  ^{:doc "123.45\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.FLOAT)"}
  FLOAT)

JOKER CONSTANT FOR from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.FOR)"}
  FOR)

JOKER CONSTANT FUNC from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.FUNC)"}
  FUNC)

JOKER CONSTANT GEQ from go/token/token.go:
(def
  ^{:doc ">=\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.GEQ)"}
  GEQ)

JOKER CONSTANT GO from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.GO)"}
  GO)

JOKER CONSTANT GOTO from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.GOTO)"}
  GOTO)

JOKER CONSTANT GTR from go/token/token.go:
(def
  ^{:doc ">\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.GTR)"}
  GTR)

JOKER CONSTANT HighestPrec from go/token/token.go:
(def
  ^{:doc "A set of constants for precedence-based expression parsing.\nNon-operators have lowest precedence, followed by operators\nstarting with precedence 1 up to unary operators. The highest\nprecedence serves as \"catch-all\" precedence for selector,\nindexing, and other operator and delimiter tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "token.HighestPrec"}
  HighestPrec)

JOKER CONSTANT IDENT from go/token/token.go:
(def
  ^{:doc "Identifiers and basic type literals\n(these tokens stand for classes of literals)\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.IDENT)"}
  IDENT)

JOKER CONSTANT IF from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.IF)"}
  IF)

JOKER CONSTANT ILLEGAL from go/token/token.go:
(def
  ^{:doc "Special tokens\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.ILLEGAL)"}
  ILLEGAL)

JOKER CONSTANT IMAG from go/token/token.go:
(def
  ^{:doc "123.45i\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.IMAG)"}
  IMAG)

JOKER CONSTANT IMPORT from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.IMPORT)"}
  IMPORT)

JOKER CONSTANT INC from go/token/token.go:
(def
  ^{:doc "++\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.INC)"}
  INC)

JOKER CONSTANT INT from go/token/token.go:
(def
  ^{:doc "12345\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.INT)"}
  INT)

JOKER CONSTANT INTERFACE from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.INTERFACE)"}
  INTERFACE)

JOKER CONSTANT LAND from go/token/token.go:
(def
  ^{:doc "&&\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.LAND)"}
  LAND)

JOKER CONSTANT LBRACE from go/token/token.go:
(def
  ^{:doc "{\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.LBRACE)"}
  LBRACE)

JOKER CONSTANT LBRACK from go/token/token.go:
(def
  ^{:doc "[\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.LBRACK)"}
  LBRACK)

JOKER CONSTANT LEQ from go/token/token.go:
(def
  ^{:doc "<=\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.LEQ)"}
  LEQ)

JOKER CONSTANT LOR from go/token/token.go:
(def
  ^{:doc "||\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.LOR)"}
  LOR)

JOKER CONSTANT LPAREN from go/token/token.go:
(def
  ^{:doc "(\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.LPAREN)"}
  LPAREN)

JOKER CONSTANT LSS from go/token/token.go:
(def
  ^{:doc "<\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.LSS)"}
  LSS)

JOKER CONSTANT LowestPrec from go/token/token.go:
(def
  ^{:doc "non-operators\n"
    :added "1.0"
    :tag "Int"
    :go "token.LowestPrec"}
  LowestPrec)

JOKER CONSTANT MAP from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.MAP)"}
  MAP)

JOKER CONSTANT MUL from go/token/token.go:
(def
  ^{:doc "*\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.MUL)"}
  MUL)

JOKER CONSTANT MUL_ASSIGN from go/token/token.go:
(def
  ^{:doc "*=\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.MUL_ASSIGN)"}
  MUL_ASSIGN)

JOKER CONSTANT NEQ from go/token/token.go:
(def
  ^{:doc "!=\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.NEQ)"}
  NEQ)

JOKER CONSTANT NOT from go/token/token.go:
(def
  ^{:doc "!\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.NOT)"}
  NOT)

JOKER CONSTANT NoPos from go/token/position.go:
(def
  ^{:doc "The zero value for Pos is NoPos; there is no file and line information\nassociated with it, and NoPos.IsValid() is false. NoPos is always\nsmaller than any other Pos value. The corresponding Position value\nfor NoPos is the zero value for Position.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.NoPos)"}
  NoPos)

JOKER CONSTANT OR from go/token/token.go:
(def
  ^{:doc "|\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.OR)"}
  OR)

JOKER CONSTANT OR_ASSIGN from go/token/token.go:
(def
  ^{:doc "|=\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.OR_ASSIGN)"}
  OR_ASSIGN)

JOKER CONSTANT PACKAGE from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.PACKAGE)"}
  PACKAGE)

JOKER CONSTANT PERIOD from go/token/token.go:
(def
  ^{:doc ".\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.PERIOD)"}
  PERIOD)

JOKER CONSTANT QUO from go/token/token.go:
(def
  ^{:doc "/\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.QUO)"}
  QUO)

JOKER CONSTANT QUO_ASSIGN from go/token/token.go:
(def
  ^{:doc "/=\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.QUO_ASSIGN)"}
  QUO_ASSIGN)

JOKER CONSTANT RANGE from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.RANGE)"}
  RANGE)

JOKER CONSTANT RBRACE from go/token/token.go:
(def
  ^{:doc "}\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.RBRACE)"}
  RBRACE)

JOKER CONSTANT RBRACK from go/token/token.go:
(def
  ^{:doc "]\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.RBRACK)"}
  RBRACK)

JOKER CONSTANT REM from go/token/token.go:
(def
  ^{:doc "%\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.REM)"}
  REM)

JOKER CONSTANT REM_ASSIGN from go/token/token.go:
(def
  ^{:doc "%=\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.REM_ASSIGN)"}
  REM_ASSIGN)

JOKER CONSTANT RETURN from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.RETURN)"}
  RETURN)

JOKER CONSTANT RPAREN from go/token/token.go:
(def
  ^{:doc ")\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.RPAREN)"}
  RPAREN)

JOKER CONSTANT SELECT from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.SELECT)"}
  SELECT)

JOKER CONSTANT SEMICOLON from go/token/token.go:
(def
  ^{:doc ";\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.SEMICOLON)"}
  SEMICOLON)

JOKER CONSTANT SHL from go/token/token.go:
(def
  ^{:doc "<<\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.SHL)"}
  SHL)

JOKER CONSTANT SHL_ASSIGN from go/token/token.go:
(def
  ^{:doc "<<=\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.SHL_ASSIGN)"}
  SHL_ASSIGN)

JOKER CONSTANT SHR from go/token/token.go:
(def
  ^{:doc ">>\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.SHR)"}
  SHR)

JOKER CONSTANT SHR_ASSIGN from go/token/token.go:
(def
  ^{:doc ">>=\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.SHR_ASSIGN)"}
  SHR_ASSIGN)

JOKER CONSTANT STRING from go/token/token.go:
(def
  ^{:doc "\"abc\"\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.STRING)"}
  STRING)

JOKER CONSTANT STRUCT from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.STRUCT)"}
  STRUCT)

JOKER CONSTANT SUB from go/token/token.go:
(def
  ^{:doc "-\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.SUB)"}
  SUB)

JOKER CONSTANT SUB_ASSIGN from go/token/token.go:
(def
  ^{:doc "-=\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.SUB_ASSIGN)"}
  SUB_ASSIGN)

JOKER CONSTANT SWITCH from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.SWITCH)"}
  SWITCH)

JOKER CONSTANT TYPE from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.TYPE)"}
  TYPE)

JOKER CONSTANT UnaryPrec from go/token/token.go:
(def
  ^{:doc "A set of constants for precedence-based expression parsing.\nNon-operators have lowest precedence, followed by operators\nstarting with precedence 1 up to unary operators. The highest\nprecedence serves as \"catch-all\" precedence for selector,\nindexing, and other operator and delimiter tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "token.UnaryPrec"}
  UnaryPrec)

JOKER CONSTANT VAR from go/token/token.go:
(def
  ^{:doc "The list of tokens.\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.VAR)"}
  VAR)

JOKER CONSTANT XOR from go/token/token.go:
(def
  ^{:doc "^\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.XOR)"}
  XOR)

JOKER CONSTANT XOR_ASSIGN from go/token/token.go:
(def
  ^{:doc "^=\n"
    :added "1.0"
    :tag "Int"
    :go "int(token.XOR_ASSIGN)"}
  XOR_ASSIGN)

JOKER TYPE go/token.File from go/token/position.go:
(defn ^"GoObject" File.
  "Constructor for token.File"
  {:added "1.0"
   :go "_ConstructFile(_v)"}
  [^Object _v])

JOKER TYPE go/token.FileSet from go/token/position.go:
(defn ^"GoObject" FileSet.
  "Constructor for token.FileSet"
  {:added "1.0"
   :go "_ConstructFileSet(_v)"}
  [^Object _v])

JOKER TYPE go/token.Pos from go/token/position.go:
(defn ^"GoObject" Pos.
  "Constructor for token.Pos"
  {:added "1.0"
   :go "_ConstructPos(_v)"}
  [^Object _v])

JOKER TYPE go/token.Position from go/token/position.go:
(defn ^"GoObject" Position.
  "Constructor for token.Position"
  {:added "1.0"
   :go "_ConstructPosition(_v)"}
  [^Object _v])

JOKER TYPE go/token.Token from go/token/token.go:
(defn ^"GoObject" Token.
  "Constructor for token.Token"
  {:added "1.0"
   :go "_ConstructToken(_v)"}
  [^Object _v])

JOKER FUNC go/token.Lookup from go/token/token.go:
(defn Lookup
  "Lookup maps an identifier to its keyword token or IDENT (if not a keyword).\n\nGo input arguments: (ident string)\n\nGo return type: Token\n\nJoker input arguments: [^String ident]\n\nJoker return type: go.std.go.token/Token"
  {:added "1.0"
   :go "__lookup(__ident)"}
  [^String __ident])

JOKER FUNC go/token.NewFileSet from go/token/position.go:
(defn NewFileSet
  "NewFileSet creates a new file set.\n\nGo return type: *FileSet\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.go.token/FileSet)"
  {:added "1.0"
   :go "__newFileSet()"}
  [])

JOKER TYPE go.std.go.token/File:
(def
  ^{:doc "A File is a handle for a file belonging to a FileSet.\nA File has a name, size, and line offset table.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_File"}
  File)

JOKER TYPE go.std.go.token/FileSet:
(def
  ^{:doc "A FileSet represents a set of source files.\nMethods of file sets are synchronized; multiple goroutines\nmay invoke them concurrently.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FileSet"}
  FileSet)

JOKER TYPE go.std.go.token/Pos:
(def
  ^{:doc "Pos is a compact encoding of a source position within a file set.\nIt can be converted into a Position for a more convenient, but much\nlarger, representation.\n\nThe Pos value for a given file is a number in the range [base, base+size],\nwhere base and size are specified when adding the file to the file set via\nAddFile.\n\nTo create the Pos value for a specific source offset (measured in bytes),\nfirst add the respective file to the current file set using FileSet.AddFile\nand then call File.Pos(offset) for that file. Given a Pos value p\nfor a specific file set fset, the corresponding Position value is\nobtained by calling fset.Position(p).\n\nPos values can be compared directly with the usual comparison operators:\nIf two Pos values p and q are in the same file, comparing p and q is\nequivalent to comparing the respective source file offsets. If p and q\nare in different files, p < q is true if the file implied by p was added\nto the respective file set before the file implied by q.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Pos"}
  Pos)

JOKER TYPE go.std.go.token/Position:
(def
  ^{:doc "Position describes an arbitrary source position\nincluding the file, line, and column location.\nA Position is valid if the line number is > 0.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Position"}
  Position)

JOKER TYPE go.std.go.token/Token:
(def
  ^{:doc "Token is the set of lexical tokens of the Go programming language.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Token"}
  Token)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/token"]
    :doc "Provides a low-level interface to the go/token package.\n\nPackage token defines constants representing the lexical tokens of the Go\nprogramming language and basic operations on tokens (printing, predicates).\n"
    :empty false}
  go.std.go.token)
JOKER CONSTANT Bool from go/types/type.go:
(def
  ^{:doc "predeclared types\n"
    :added "1.0"
    :tag "Int"
    :go "int(types.Bool)"}
  Bool)

JOKER CONSTANT Byte from go/types/type.go:
(def
  ^{:doc "aliases\n"
    :added "1.0"
    :tag "Int"
    :go "int(types.Byte)"}
  Byte)

JOKER CONSTANT Complex128 from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.Complex128)"}
  Complex128)

JOKER CONSTANT Complex64 from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.Complex64)"}
  Complex64)

JOKER CONSTANT FieldVal from go/types/selection.go:
(def
  ^{:doc "x.f is a struct field selector\n"
    :added "1.0"
    :tag "Int"
    :go "int(types.FieldVal)"}
  FieldVal)

JOKER CONSTANT Float32 from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.Float32)"}
  Float32)

JOKER CONSTANT Float64 from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.Float64)"}
  Float64)

JOKER CONSTANT Int from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.Int)"}
  Int-renamed)

JOKER CONSTANT Int16 from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.Int16)"}
  Int16)

JOKER CONSTANT Int32 from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.Int32)"}
  Int32)

JOKER CONSTANT Int64 from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.Int64)"}
  Int64)

JOKER CONSTANT Int8 from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.Int8)"}
  Int8)

JOKER CONSTANT Invalid from go/types/type.go:
(def
  ^{:doc "type is invalid\n"
    :added "1.0"
    :tag "Int"
    :go "int(types.Invalid)"}
  Invalid)

JOKER CONSTANT IsBoolean from go/types/type.go:
(def
  ^{:doc "Properties of basic types.\n"
    :added "1.0"
    :tag "Int"
    :go "int(types.IsBoolean)"}
  IsBoolean)

JOKER CONSTANT IsComplex from go/types/type.go:
(def
  ^{:doc "Properties of basic types.\n"
    :added "1.0"
    :tag "Int"
    :go "int(types.IsComplex)"}
  IsComplex)

JOKER CONSTANT IsConstType from go/types/type.go:
(def
  ^{:doc "Properties of basic types.\n"
    :added "1.0"
    :tag "Int"
    :go "int(types.IsConstType)"}
  IsConstType)

JOKER CONSTANT IsFloat from go/types/type.go:
(def
  ^{:doc "Properties of basic types.\n"
    :added "1.0"
    :tag "Int"
    :go "int(types.IsFloat)"}
  IsFloat)

JOKER CONSTANT IsInteger from go/types/type.go:
(def
  ^{:doc "Properties of basic types.\n"
    :added "1.0"
    :tag "Int"
    :go "int(types.IsInteger)"}
  IsInteger)

JOKER CONSTANT IsNumeric from go/types/type.go:
(def
  ^{:doc "Properties of basic types.\n"
    :added "1.0"
    :tag "Int"
    :go "int(types.IsNumeric)"}
  IsNumeric)

JOKER CONSTANT IsOrdered from go/types/type.go:
(def
  ^{:doc "Properties of basic types.\n"
    :added "1.0"
    :tag "Int"
    :go "int(types.IsOrdered)"}
  IsOrdered)

JOKER CONSTANT IsString from go/types/type.go:
(def
  ^{:doc "Properties of basic types.\n"
    :added "1.0"
    :tag "Int"
    :go "int(types.IsString)"}
  IsString)

JOKER CONSTANT IsUnsigned from go/types/type.go:
(def
  ^{:doc "Properties of basic types.\n"
    :added "1.0"
    :tag "Int"
    :go "int(types.IsUnsigned)"}
  IsUnsigned)

JOKER CONSTANT IsUntyped from go/types/type.go:
(def
  ^{:doc "Properties of basic types.\n"
    :added "1.0"
    :tag "Int"
    :go "int(types.IsUntyped)"}
  IsUntyped)

JOKER CONSTANT MethodExpr from go/types/selection.go:
(def
  ^{:doc "x.f is a method expression\n"
    :added "1.0"
    :tag "Int"
    :go "int(types.MethodExpr)"}
  MethodExpr)

JOKER CONSTANT MethodVal from go/types/selection.go:
(def
  ^{:doc "x.f is a method selector\n"
    :added "1.0"
    :tag "Int"
    :go "int(types.MethodVal)"}
  MethodVal)

JOKER CONSTANT RecvOnly from go/types/type.go:
(def
  ^{:doc "The direction of a channel is indicated by one of these constants.\n"
    :added "1.0"
    :tag "Int"
    :go "int(types.RecvOnly)"}
  RecvOnly)

JOKER CONSTANT Rune from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.Rune)"}
  Rune)

JOKER CONSTANT SendOnly from go/types/type.go:
(def
  ^{:doc "The direction of a channel is indicated by one of these constants.\n"
    :added "1.0"
    :tag "Int"
    :go "int(types.SendOnly)"}
  SendOnly)

JOKER CONSTANT SendRecv from go/types/type.go:
(def
  ^{:doc "The direction of a channel is indicated by one of these constants.\n"
    :added "1.0"
    :tag "Int"
    :go "int(types.SendRecv)"}
  SendRecv)

JOKER CONSTANT String from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.String)"}
  String-renamed)

JOKER CONSTANT Uint from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.Uint)"}
  Uint)

JOKER CONSTANT Uint16 from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.Uint16)"}
  Uint16)

JOKER CONSTANT Uint32 from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.Uint32)"}
  Uint32)

JOKER CONSTANT Uint64 from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.Uint64)"}
  Uint64)

JOKER CONSTANT Uint8 from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.Uint8)"}
  Uint8)

JOKER CONSTANT Uintptr from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.Uintptr)"}
  Uintptr)

JOKER CONSTANT UnsafePointer from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.UnsafePointer)"}
  UnsafePointer)

JOKER CONSTANT UntypedBool from go/types/type.go:
(def
  ^{:doc "types for untyped values\n"
    :added "1.0"
    :tag "Int"
    :go "int(types.UntypedBool)"}
  UntypedBool)

JOKER CONSTANT UntypedComplex from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.UntypedComplex)"}
  UntypedComplex)

JOKER CONSTANT UntypedFloat from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.UntypedFloat)"}
  UntypedFloat)

JOKER CONSTANT UntypedInt from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.UntypedInt)"}
  UntypedInt)

JOKER CONSTANT UntypedNil from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.UntypedNil)"}
  UntypedNil)

JOKER CONSTANT UntypedRune from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.UntypedRune)"}
  UntypedRune)

JOKER CONSTANT UntypedString from go/types/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(types.UntypedString)"}
  UntypedString)

JOKER VARIABLE Typ from go/types/universe.go:
(def
  ^{:doc "Typ contains the predeclared *Basic types indexed by their\ncorresponding BasicKind.\n\nThe *Basic type for Typ[Byte] will have the name \"uint8\".\nUse Universe.Lookup(\"byte\").Type() to obtain the specific\nalias basic type named \"byte\" (and analogous for \"rune\").\n"
    :added "1.0"
    :tag "Var"
    :go "types.Typ"}
  Typ)

JOKER VARIABLE Universe from go/types/universe.go:
(def
  ^{:doc "The Universe scope contains all predeclared objects of Go.\nIt is the outermost scope of any chain of nested scopes.\n"
    :added "1.0"
    :tag "Var"
    :go "types.Universe"}
  Universe)

JOKER VARIABLE Unsafe from go/types/universe.go:
(def
  ^{:doc "The Unsafe package is the package returned by an importer\nfor the import path \"unsafe\".\n"
    :added "1.0"
    :tag "Var"
    :go "types.Unsafe"}
  Unsafe)

JOKER TYPE go/types.Array from go/types/type.go:
(defn ^"GoObject" Array.
  "Constructor for types.Array"
  {:added "1.0"
   :go "_ConstructArray(_v)"}
  [^Object _v])

JOKER TYPE go/types.Basic from go/types/type.go:
(defn ^"GoObject" Basic.
  "Constructor for types.Basic"
  {:added "1.0"
   :go "_ConstructBasic(_v)"}
  [^Object _v])

JOKER TYPE go/types.BasicInfo from go/types/type.go:
(defn ^"GoObject" BasicInfo.
  "Constructor for types.BasicInfo"
  {:added "1.0"
   :go "_ConstructBasicInfo(_v)"}
  [^Object _v])

JOKER TYPE go/types.BasicKind from go/types/type.go:
(defn ^"GoObject" BasicKind.
  "Constructor for types.BasicKind"
  {:added "1.0"
   :go "_ConstructBasicKind(_v)"}
  [^Object _v])

JOKER TYPE go/types.Builtin from go/types/object.go:
(defn ^"GoObject" Builtin.
  "Constructor for types.Builtin"
  {:added "1.0"
   :go "_ConstructBuiltin(_v)"}
  [^Object _v])

JOKER TYPE go/types.Chan from go/types/type.go:
(defn ^"GoObject" Chan.
  "Constructor for types.Chan"
  {:added "1.0"
   :go "_ConstructChan(_v)"}
  [^Object _v])

JOKER TYPE go/types.ChanDir from go/types/type.go:
(defn ^"GoObject" ChanDir.
  "Constructor for types.ChanDir"
  {:added "1.0"
   :go "_ConstructChanDir(_v)"}
  [^Object _v])

JOKER TYPE go/types.Checker from go/types/check.go:
(defn ^"GoObject" Checker.
  "Constructor for types.Checker"
  {:added "1.0"
   :go "_ConstructChecker(_v)"}
  [^Object _v])

JOKER TYPE go/types.Config from go/types/api.go:
;; (defn ^"GoObject" Config.
;;   "Constructor for types.Config"
;;   {:added "1.0"
;;    :go "_ConstructConfig(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.Const from go/types/object.go:
(defn ^"GoObject" Const.
  "Constructor for types.Const"
  {:added "1.0"
   :go "_ConstructConst(_v)"}
  [^Object _v])

JOKER TYPE go/types.Error from go/types/api.go:
;; (defn ^"GoObject" Error.
;;   "Constructor for types.Error"
;;   {:added "1.0"
;;    :go "_ConstructError(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.Func from go/types/object.go:
(defn ^"GoObject" Func.
  "Constructor for types.Func"
  {:added "1.0"
   :go "_ConstructFunc(_v)"}
  [^Object _v])

JOKER TYPE go/types.ImportMode from go/types/api.go:
(defn ^"GoObject" ImportMode.
  "Constructor for types.ImportMode"
  {:added "1.0"
   :go "_ConstructImportMode(_v)"}
  [^Object _v])

JOKER TYPE go/types.Importer from go/types/api.go:
;; (defn ^"GoObject" Importer.
;;   "Constructor for types.Importer"
;;   {:added "1.0"
;;    :go "_ConstructImporter(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.ImporterFrom from go/types/api.go:
;; (defn ^"GoObject" ImporterFrom.
;;   "Constructor for types.ImporterFrom"
;;   {:added "1.0"
;;    :go "_ConstructImporterFrom(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.Info from go/types/api.go:
;; (defn ^"GoObject" Info.
;;   "Constructor for types.Info"
;;   {:added "1.0"
;;    :go "_ConstructInfo(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.Initializer from go/types/api.go:
;; (defn ^"GoObject" Initializer.
;;   "Constructor for types.Initializer"
;;   {:added "1.0"
;;    :go "_ConstructInitializer(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.Interface from go/types/type.go:
(defn ^"GoObject" Interface.
  "Constructor for types.Interface"
  {:added "1.0"
   :go "_ConstructInterface(_v)"}
  [^Object _v])

JOKER TYPE go/types.Label from go/types/object.go:
(defn ^"GoObject" Label.
  "Constructor for types.Label"
  {:added "1.0"
   :go "_ConstructLabel(_v)"}
  [^Object _v])

JOKER TYPE go/types.Map from go/types/type.go:
(defn ^"GoObject" Map.
  "Constructor for types.Map"
  {:added "1.0"
   :go "_ConstructMap(_v)"}
  [^Object _v])

JOKER TYPE go/types.MethodSet from go/types/methodset.go:
(defn ^"GoObject" MethodSet.
  "Constructor for types.MethodSet"
  {:added "1.0"
   :go "_ConstructMethodSet(_v)"}
  [^Object _v])

JOKER TYPE go/types.Named from go/types/type.go:
(defn ^"GoObject" Named.
  "Constructor for types.Named"
  {:added "1.0"
   :go "_ConstructNamed(_v)"}
  [^Object _v])

JOKER TYPE go/types.Nil from go/types/object.go:
(defn ^"GoObject" Nil.
  "Constructor for types.Nil"
  {:added "1.0"
   :go "_ConstructNil(_v)"}
  [^Object _v])

JOKER TYPE go/types.Object from go/types/object.go:
;; (defn ^"GoObject" Object.
;;   "Constructor for types.Object"
;;   {:added "1.0"
;;    :go "_ConstructObject(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.Package from go/types/package.go:
(defn ^"GoObject" Package.
  "Constructor for types.Package"
  {:added "1.0"
   :go "_ConstructPackage(_v)"}
  [^Object _v])

JOKER TYPE go/types.PkgName from go/types/object.go:
(defn ^"GoObject" PkgName.
  "Constructor for types.PkgName"
  {:added "1.0"
   :go "_ConstructPkgName(_v)"}
  [^Object _v])

JOKER TYPE go/types.Pointer from go/types/type.go:
(defn ^"GoObject" Pointer.
  "Constructor for types.Pointer"
  {:added "1.0"
   :go "_ConstructPointer(_v)"}
  [^Object _v])

JOKER TYPE go/types.Qualifier from go/types/typestring.go:
;; (defn ^"GoObject" Qualifier.
;;   "Constructor for types.Qualifier"
;;   {:added "1.0"
;;    :go "_ConstructQualifier(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.Scope from go/types/scope.go:
(defn ^"GoObject" Scope.
  "Constructor for types.Scope"
  {:added "1.0"
   :go "_ConstructScope(_v)"}
  [^Object _v])

JOKER TYPE go/types.Selection from go/types/selection.go:
(defn ^"GoObject" Selection.
  "Constructor for types.Selection"
  {:added "1.0"
   :go "_ConstructSelection(_v)"}
  [^Object _v])

JOKER TYPE go/types.SelectionKind from go/types/selection.go:
(defn ^"GoObject" SelectionKind.
  "Constructor for types.SelectionKind"
  {:added "1.0"
   :go "_ConstructSelectionKind(_v)"}
  [^Object _v])

JOKER TYPE go/types.Signature from go/types/type.go:
(defn ^"GoObject" Signature.
  "Constructor for types.Signature"
  {:added "1.0"
   :go "_ConstructSignature(_v)"}
  [^Object _v])

JOKER TYPE go/types.Sizes from go/types/sizes.go:
;; (defn ^"GoObject" Sizes.
;;   "Constructor for types.Sizes"
;;   {:added "1.0"
;;    :go "_ConstructSizes(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.Slice from go/types/type.go:
(defn ^"GoObject" Slice.
  "Constructor for types.Slice"
  {:added "1.0"
   :go "_ConstructSlice(_v)"}
  [^Object _v])

JOKER TYPE go/types.StdSizes from go/types/sizes.go:
(defn ^"GoObject" StdSizes.
  "Constructor for types.StdSizes"
  {:added "1.0"
   :go "_ConstructStdSizes(_v)"}
  [^Object _v])

JOKER TYPE go/types.Struct from go/types/type.go:
(defn ^"GoObject" Struct.
  "Constructor for types.Struct"
  {:added "1.0"
   :go "_ConstructStruct(_v)"}
  [^Object _v])

JOKER TYPE go/types.Tuple from go/types/type.go:
(defn ^"GoObject" Tuple.
  "Constructor for types.Tuple"
  {:added "1.0"
   :go "_ConstructTuple(_v)"}
  [^Object _v])

JOKER TYPE go/types.Type from go/types/type.go:
;; (defn ^"GoObject" Type.
;;   "Constructor for types.Type"
;;   {:added "1.0"
;;    :go "_ConstructType(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.TypeAndValue from go/types/api.go:
;; (defn ^"GoObject" TypeAndValue.
;;   "Constructor for types.TypeAndValue"
;;   {:added "1.0"
;;    :go "_ConstructTypeAndValue(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.TypeName from go/types/object.go:
(defn ^"GoObject" TypeName.
  "Constructor for types.TypeName"
  {:added "1.0"
   :go "_ConstructTypeName(_v)"}
  [^Object _v])

JOKER TYPE go/types.Var from go/types/object.go:
(defn ^"GoObject" Var.
  "Constructor for types.Var"
  {:added "1.0"
   :go "_ConstructVar(_v)"}
  [^Object _v])

JOKER FUNC go/types.AssertableTo from go/types/api.go:
(defn ^"Boolean" AssertableTo
  "AssertableTo reports whether a value of type V can be asserted to have type T.\n\nGo input arguments: (V *Interface, T Type)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.go.types/Interface) V, ^go.std.go.types/Type T]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.AssertableTo(__V, *__T)"}
  [^types/Interface __V, ^types/Type __T])

JOKER FUNC go/types.AssignableTo from go/types/api.go:
(defn ^"Boolean" AssignableTo
  "AssignableTo reports whether a value of type V is assignable to a variable of type T.\n\nGo input arguments: (V Type, T Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type V, ^go.std.go.types/Type T]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.AssignableTo(*__V, *__T)"}
  [^types/Type __V, ^types/Type __T])

JOKER FUNC go/types.Comparable from go/types/predicates.go:
(defn ^"Boolean" Comparable
  "Comparable reports whether values of type T are comparable.\n\nGo input arguments: (T Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type T]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.Comparable(*__T)"}
  [^types/Type __T])

JOKER FUNC go/types.ConvertibleTo from go/types/api.go:
(defn ^"Boolean" ConvertibleTo
  "ConvertibleTo reports whether a value of type V is convertible to a value of type T.\n\nGo input arguments: (V Type, T Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type V, ^go.std.go.types/Type T]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.ConvertibleTo(*__V, *__T)"}
  [^types/Type __V, ^types/Type __T])

JOKER FUNC go/types.DefPredeclaredTestFuncs from go/types/universe.go:
;; (defn DefPredeclaredTestFuncs
;;   "DefPredeclaredTestFuncs defines the assert and trace built-ins.\nThese built-ins are intended for debugging and testing of this\npackage only.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__defPredeclaredTestFuncs()"}
;;   [])

JOKER FUNC go/types.Default from go/types/predicates.go:
(defn Default
  "Default returns the default \"typed\" type for an \"untyped\" type;\nit returns the incoming type for all other types. The default type\nfor untyped nil is untyped nil.\n\nGo input arguments: (typ Type)\n\nGo return type: Type\n\nJoker input arguments: [^go.std.go.types/Type typ]\n\nJoker return type: go.std.go.types/Type"
  {:added "1.0"
   :go "__default(*__typ)"}
  [^types/Type __typ])

JOKER FUNC go/types.Eval from go/types/eval.go:
;; (defn Eval
;;   "Eval returns the type and, if constant, the value for the\nexpression expr, evaluated at position pos of package pkg,\nwhich must have been derived from type-checking an AST with\ncomplete position information relative to the provided file\nset.\n\nIf pkg == nil, the Universe scope is used and the provided\nposition pos is ignored. If pkg != nil, and pos is invalid,\nthe package scope is used. Otherwise, pos must belong to the\npackage.\n\nAn error is returned if pos is not within the package or\nif the node cannot be evaluated.\n\nNote: Eval should not be used instead of running Check to compute\ntypes and values, but in addition to Check. Eval will re-evaluate\nits argument each time, and it also does not know about the context\nin which an expression is used (e.g., an assignment). Thus, top-\nlevel untyped constants will return an untyped type rather then the\nrespective context-specific type.\n\nGo input arguments: (fset *token.FileSet, pkg *Package, pos token.Pos, expr string)\n\nGo return type: (_ TypeAndValue, err error)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^(atom-of go.std.go.types/Package) pkg, ^go.std.go.token/Pos pos, ^String expr]\n\nJoker return type: [go.std.go.types/TypeAndValue Error]"
;;   {:added "1.0"
;;    :go "__eval(__fset, __pkg, *__pos, __expr)"}
;;   [^token/FileSet __fset, ^types/Package __pkg, ^token/Pos __pos, ^String __expr])

JOKER FUNC go/types.ExprString from go/types/exprstring.go:
;; (defn ^"String" ExprString
;;   "ExprString returns the (possibly shortened) string representation for x.\nShortened representations are suitable for user interfaces but may not\nnecessarily follow Go syntax.\n\nGo input arguments: (x ast.Expr)\n\nGo return type: string\n\nJoker input arguments: [^go.std.go.ast/Expr x]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "types.ExprString(*__x)"}
;;   [^ast/Expr __x])

JOKER FUNC go/types.Id from go/types/object.go:
(defn ^"String" Id
  "Id returns name if it is exported, otherwise it\nreturns the name qualified with the package path.\n\nGo input arguments: (pkg *Package, name string)\n\nGo return type: string\n\nJoker input arguments: [^(atom-of go.std.go.types/Package) pkg, ^String name]\n\nJoker return type: String"
  {:added "1.0"
   :go "types.Id(__pkg, __name)"}
  [^types/Package __pkg, ^String __name])

JOKER FUNC go/types.Identical from go/types/predicates.go:
(defn ^"Boolean" Identical
  "Identical reports whether x and y are identical types.\nReceivers of Signature types are ignored.\n\nGo input arguments: (x Type, y Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type x, ^go.std.go.types/Type y]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.Identical(*__x, *__y)"}
  [^types/Type __x, ^types/Type __y])

JOKER FUNC go/types.IdenticalIgnoreTags from go/types/predicates.go:
(defn ^"Boolean" IdenticalIgnoreTags
  "IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored.\nReceivers of Signature types are ignored.\n\nGo input arguments: (x Type, y Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type x, ^go.std.go.types/Type y]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.IdenticalIgnoreTags(*__x, *__y)"}
  [^types/Type __x, ^types/Type __y])

JOKER FUNC go/types.Implements from go/types/api.go:
(defn ^"Boolean" Implements
  "Implements reports whether type V implements interface T.\n\nGo input arguments: (V Type, T *Interface)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type V, ^(atom-of go.std.go.types/Interface) T]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.Implements(*__V, __T)"}
  [^types/Type __V, ^types/Interface __T])

JOKER FUNC go/types.IsInterface from go/types/predicates.go:
(defn ^"Boolean" IsInterface
  "IsInterface reports whether typ is an interface type.\n\nGo input arguments: (typ Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type typ]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.IsInterface(*__typ)"}
  [^types/Type __typ])

JOKER FUNC go/types.LookupFieldOrMethod from go/types/lookup.go:
(defn LookupFieldOrMethod
  "LookupFieldOrMethod looks up a field or method with given package and name\nin T and returns the corresponding *Var or *Func, an index sequence, and a\nbool indicating if there were any pointer indirections on the path to the\nfield or method. If addressable is set, T is the type of an addressable\nvariable (only matters for method lookups).\n\nThe last index entry is the field or method index in the (possibly embedded)\ntype where the entry was found, either:\n\n\t1) the list of declared methods of a named type; or\n\t2) the list of all methods (method set) of an interface type; or\n\t3) the list of fields of a struct type.\n\nThe earlier index entries are the indices of the embedded struct fields\ntraversed to get to the found entry, starting at depth 0.\n\nIf no entry is found, a nil object is returned. In this case, the returned\nindex and indirect values have the following meaning:\n\n\t- If index != nil, the index sequence points to an ambiguous entry\n\t(the same name appeared more than once at the same embedding level).\n\n\t- If indirect is set, a method with a pointer receiver type was found\n     but there was no pointer on the path from the actual receiver type to\n\tthe method's formal receiver base type, nor was the receiver addressable.\n\nGo input arguments: (T Type, addressable bool, pkg *Package, name string)\n\nGo return type: (obj Object, index []int, indirect bool)\n\nJoker input arguments: [^go.std.go.types/Type T, ^Boolean addressable, ^(atom-of go.std.go.types/Package) pkg, ^String name]\n\nJoker return type: [go.std.go.types/Object (vector-of Int) Boolean]"
  {:added "1.0"
   :go "__lookupFieldOrMethod(*__T, __addressable, __pkg, __name)"}
  [^types/Type __T, ^Boolean __addressable, ^types/Package __pkg, ^String __name])

JOKER FUNC go/types.MissingMethod from go/types/lookup.go:
(defn MissingMethod
  "MissingMethod returns (nil, false) if V implements T, otherwise it\nreturns a missing method required by T and whether it is missing or\njust has the wrong type.\n\nFor non-interface types V, or if static is set, V implements T if all\nmethods of T are present in V. Otherwise (V is an interface and static\nis not set), MissingMethod only checks that methods of T which are also\npresent in V have matching types (e.g., for a type assertion x.(T) where\nx is of interface type V).\n\nGo input arguments: (V Type, T *Interface, static bool)\n\nGo return type: (method *Func, wrongType bool)\n\nJoker input arguments: [^go.std.go.types/Type V, ^(atom-of go.std.go.types/Interface) T, ^Boolean static]\n\nJoker return type: [(atom-of go.std.go.types/Func) Boolean]"
  {:added "1.0"
   :go "__missingMethod(*__V, __T, __static)"}
  [^types/Type __V, ^types/Interface __T, ^Boolean __static])

JOKER FUNC go/types.NewArray from go/types/type.go:
(defn NewArray
  "NewArray returns a new array type for the given element type and length.\nA negative length indicates an unknown length.\n\nGo input arguments: (elem Type, len int64)\n\nGo return type: *Array\n\nJoker input arguments: [^go.std.go.types/Type elem, ^Number len]\n\nJoker return type: (atom-of go.std.go.types/Array)"
  {:added "1.0"
   :go "__newArray(*__elem, __len)"}
  [^types/Type __elem, ^Int64 __len])

JOKER FUNC go/types.NewChan from go/types/type.go:
(defn NewChan
  "NewChan returns a new channel type for the given direction and element type.\n\nGo input arguments: (dir ChanDir, elem Type)\n\nGo return type: *Chan\n\nJoker input arguments: [^go.std.go.types/ChanDir dir, ^go.std.go.types/Type elem]\n\nJoker return type: (atom-of go.std.go.types/Chan)"
  {:added "1.0"
   :go "__newChan(*__dir, *__elem)"}
  [^types/ChanDir __dir, ^types/Type __elem])

JOKER FUNC go/types.NewChecker from go/types/check.go:
;; (defn NewChecker
;;   "NewChecker returns a new Checker instance for a given package.\nPackage files may be added incrementally via checker.Files.\n\nGo input arguments: (conf *Config, fset *token.FileSet, pkg *Package, info *Info)\n\nGo return type: *Checker\n\nJoker input arguments: [^(atom-of go.std.go.types/Config) conf, ^(atom-of go.std.go.token/FileSet) fset, ^(atom-of go.std.go.types/Package) pkg, ^(atom-of go.std.go.types/Info) info]\n\nJoker return type: (atom-of go.std.go.types/Checker)"
;;   {:added "1.0"
;;    :go "__newChecker(__conf, __fset, __pkg, __info)"}
;;   [^types/Config __conf, ^token/FileSet __fset, ^types/Package __pkg, ^types/Info __info])

JOKER FUNC go/types.NewConst from go/types/object.go:
;; (defn NewConst
;;   "NewConst returns a new constant with value val.\nThe remaining arguments set the attributes found with all Objects.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, typ Type, val constant.Value)\n\nGo return type: *Const\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^go.std.go.types/Type typ, ^go.std.go.constant/Value val]\n\nJoker return type: (atom-of go.std.go.types/Const)"
;;   {:added "1.0"
;;    :go "__newConst(*__pos, __pkg, __name, *__typ, *__val)"}
;;   [^token/Pos __pos, ^types/Package __pkg, ^String __name, ^types/Type __typ, ^constant/Value __val])

JOKER FUNC go/types.NewField from go/types/object.go:
;; (defn NewField
;;   "NewField returns a new variable representing a struct field.\nFor embedded fields, the name is the unqualified type name\n/ under which the field is accessible.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, typ Type, embedded bool)\n\nGo return type: *Var\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^go.std.go.types/Type typ, ^Boolean embedded]\n\nJoker return type: (atom-of go.std.go.types/Var)"
;;   {:added "1.0"
;;    :go "__newField(*__pos, __pkg, __name, *__typ, __embedded)"}
;;   [^token/Pos __pos, ^types/Package __pkg, ^String __name, ^types/Type __typ, ^Boolean __embedded])

JOKER FUNC go/types.NewFunc from go/types/object.go:
;; (defn NewFunc
;;   "NewFunc returns a new function with the given signature, representing\nthe function's type.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, sig *Signature)\n\nGo return type: *Func\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^(atom-of go.std.go.types/Signature) sig]\n\nJoker return type: (atom-of go.std.go.types/Func)"
;;   {:added "1.0"
;;    :go "__newFunc(*__pos, __pkg, __name, __sig)"}
;;   [^token/Pos __pos, ^types/Package __pkg, ^String __name, ^types/Signature __sig])

JOKER FUNC go/types.NewInterface from go/types/type.go:
;; (defn NewInterface
;;   "NewInterface returns a new (incomplete) interface for the given methods and embedded types.\nEach embedded type must have an underlying type of interface type.\nNewInterface takes ownership of the provided methods and may modify their types by setting\nmissing receivers. To compute the method set of the interface, Complete must be called.\n\nDeprecated: Use NewInterfaceType instead which allows any (even non-defined) interface types\nto be embedded. This is necessary for interfaces that embed alias type names referring to\nnon-defined (literal) interface types.\n\nGo input arguments: (methods []*Func, embeddeds []*Named)\n\nGo return type: *Interface\n\nJoker input arguments: [^(vector-of (atom-of go.std.go.types/Func)) methods, ^(vector-of (atom-of go.std.go.types/Named)) embeddeds]\n\nJoker return type: (atom-of go.std.go.types/Interface)"
;;   {:added "1.0"
;;    :go "__newInterface(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_types.Func(__methods)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_types.Named(__embeddeds)))"}
;;   [^Object __methods, ^Object __embeddeds])

JOKER FUNC go/types.NewInterfaceType from go/types/type.go:
;; (defn NewInterfaceType
;;   "NewInterfaceType returns a new (incomplete) interface for the given methods and embedded types.\nEach embedded type must have an underlying type of interface type (this property is not\nverified for defined types, which may be in the process of being set up and which don't\nhave a valid underlying type yet).\nNewInterfaceType takes ownership of the provided methods and may modify their types by setting\nmissing receivers. To compute the method set of the interface, Complete must be called.\n\nGo input arguments: (methods []*Func, embeddeds []Type)\n\nGo return type: *Interface\n\nJoker input arguments: [^(vector-of (atom-of go.std.go.types/Func)) methods, ^(vector-of go.std.go.types/Type) embeddeds]\n\nJoker return type: (atom-of go.std.go.types/Interface)"
;;   {:added "1.0"
;;    :go "__newInterfaceType(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_types.Func(__methods)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_types.Type(*__embeddeds)))"}
;;   [^Object __methods, ^Object __embeddeds])

JOKER FUNC go/types.NewLabel from go/types/object.go:
;; (defn NewLabel
;;   "NewLabel returns a new label.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string)\n\nGo return type: *Label\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name]\n\nJoker return type: (atom-of go.std.go.types/Label)"
;;   {:added "1.0"
;;    :go "__newLabel(*__pos, __pkg, __name)"}
;;   [^token/Pos __pos, ^types/Package __pkg, ^String __name])

JOKER FUNC go/types.NewMap from go/types/type.go:
(defn NewMap
  "NewMap returns a new map for the given key and element types.\n\nGo input arguments: (key Type, elem Type)\n\nGo return type: *Map\n\nJoker input arguments: [^go.std.go.types/Type key, ^go.std.go.types/Type elem]\n\nJoker return type: (atom-of go.std.go.types/Map)"
  {:added "1.0"
   :go "__newMap(*__key, *__elem)"}
  [^types/Type __key, ^types/Type __elem])

JOKER FUNC go/types.NewMethodSet from go/types/methodset.go:
(defn NewMethodSet
  "NewMethodSet returns the method set for the given type T.\nIt always returns a non-nil method set, even if it is empty.\n\nGo input arguments: (T Type)\n\nGo return type: *MethodSet\n\nJoker input arguments: [^go.std.go.types/Type T]\n\nJoker return type: (atom-of go.std.go.types/MethodSet)"
  {:added "1.0"
   :go "__newMethodSet(*__T)"}
  [^types/Type __T])

JOKER FUNC go/types.NewNamed from go/types/type.go:
;; (defn NewNamed
;;   "NewNamed returns a new named type for the given type name, underlying type, and associated methods.\nIf the given type name obj doesn't have a type yet, its type is set to the returned named type.\nThe underlying type must not be a *Named.\n\nGo input arguments: (obj *TypeName, underlying Type, methods []*Func)\n\nGo return type: *Named\n\nJoker input arguments: [^(atom-of go.std.go.types/TypeName) obj, ^go.std.go.types/Type underlying, ^(vector-of (atom-of go.std.go.types/Func)) methods]\n\nJoker return type: (atom-of go.std.go.types/Named)"
;;   {:added "1.0"
;;    :go "__newNamed(__obj, *__underlying, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_types.Func(__methods)))"}
;;   [^types/TypeName __obj, ^types/Type __underlying, ^Object __methods])

JOKER FUNC go/types.NewPackage from go/types/package.go:
(defn NewPackage
  "NewPackage returns a new Package for the given package path and name.\nThe package is not complete and contains no explicit imports.\n\nGo input arguments: (path string, name string)\n\nGo return type: *Package\n\nJoker input arguments: [^String path, ^String name]\n\nJoker return type: (atom-of go.std.go.types/Package)"
  {:added "1.0"
   :go "__newPackage(__path, __name)"}
  [^String __path, ^String __name])

JOKER FUNC go/types.NewParam from go/types/object.go:
;; (defn NewParam
;;   "NewParam returns a new variable representing a function parameter.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, typ Type)\n\nGo return type: *Var\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^go.std.go.types/Type typ]\n\nJoker return type: (atom-of go.std.go.types/Var)"
;;   {:added "1.0"
;;    :go "__newParam(*__pos, __pkg, __name, *__typ)"}
;;   [^token/Pos __pos, ^types/Package __pkg, ^String __name, ^types/Type __typ])

JOKER FUNC go/types.NewPkgName from go/types/object.go:
;; (defn NewPkgName
;;   "NewPkgName returns a new PkgName object representing an imported package.\nThe remaining arguments set the attributes found with all Objects.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, imported *Package)\n\nGo return type: *PkgName\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^(atom-of go.std.go.types/Package) imported]\n\nJoker return type: (atom-of go.std.go.types/PkgName)"
;;   {:added "1.0"
;;    :go "__newPkgName(*__pos, __pkg, __name, __imported)"}
;;   [^token/Pos __pos, ^types/Package __pkg, ^String __name, ^types/Package __imported])

JOKER FUNC go/types.NewPointer from go/types/type.go:
(defn NewPointer
  "NewPointer returns a new pointer type for the given element (base) type.\n\nGo input arguments: (elem Type)\n\nGo return type: *Pointer\n\nJoker input arguments: [^go.std.go.types/Type elem]\n\nJoker return type: (atom-of go.std.go.types/Pointer)"
  {:added "1.0"
   :go "__newPointer(*__elem)"}
  [^types/Type __elem])

JOKER FUNC go/types.NewScope from go/types/scope.go:
;; (defn NewScope
;;   "NewScope returns a new, empty scope contained in the given parent\nscope, if any. The comment is for debugging only.\n\nGo input arguments: (parent *Scope, pos token.Pos, end token.Pos, comment string)\n\nGo return type: *Scope\n\nJoker input arguments: [^(atom-of go.std.go.types/Scope) parent, ^go.std.go.token/Pos pos, ^go.std.go.token/Pos end, ^String comment]\n\nJoker return type: (atom-of go.std.go.types/Scope)"
;;   {:added "1.0"
;;    :go "__newScope(__parent, *__pos, *__end, __comment)"}
;;   [^types/Scope __parent, ^token/Pos __pos, ^token/Pos __end, ^String __comment])

JOKER FUNC go/types.NewSignature from go/types/type.go:
(defn NewSignature
  "NewSignature returns a new function type for the given receiver, parameters,\nand results, either of which may be nil. If variadic is set, the function\nis variadic, it must have at least one parameter, and the last parameter\nmust be of unnamed slice type.\n\nGo input arguments: (recv *Var, params *Tuple, results *Tuple, variadic bool)\n\nGo return type: *Signature\n\nJoker input arguments: [^(atom-of go.std.go.types/Var) recv, ^(atom-of go.std.go.types/Tuple) params, ^(atom-of go.std.go.types/Tuple) results, ^Boolean variadic]\n\nJoker return type: (atom-of go.std.go.types/Signature)"
  {:added "1.0"
   :go "__newSignature(__recv, __params, __results, __variadic)"}
  [^types/Var __recv, ^types/Tuple __params, ^types/Tuple __results, ^Boolean __variadic])

JOKER FUNC go/types.NewSlice from go/types/type.go:
(defn NewSlice
  "NewSlice returns a new slice type for the given element type.\n\nGo input arguments: (elem Type)\n\nGo return type: *Slice\n\nJoker input arguments: [^go.std.go.types/Type elem]\n\nJoker return type: (atom-of go.std.go.types/Slice)"
  {:added "1.0"
   :go "__newSlice(*__elem)"}
  [^types/Type __elem])

JOKER FUNC go/types.NewStruct from go/types/type.go:
;; (defn NewStruct
;;   "NewStruct returns a new struct with the given fields and corresponding field tags.\nIf a field with index i has a tag, tags[i] must be that tag, but len(tags) may be\nonly as long as required to hold the tag with the largest index i. Consequently,\nif no field has a tag, tags may be nil.\n\nGo input arguments: (fields []*Var, tags []string)\n\nGo return type: *Struct\n\nJoker input arguments: [^(vector-of (atom-of go.std.go.types/Var)) fields, ^(vector-of String) tags]\n\nJoker return type: (atom-of go.std.go.types/Struct)"
;;   {:added "1.0"
;;    :go "__newStruct(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_types.Var(__fields)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(__tags)))"}
;;   [^Object __fields, ^Object __tags])

JOKER FUNC go/types.NewTuple from go/types/type.go:
;; (defn NewTuple
;;   "NewTuple returns a new tuple for the given variables.\n\nGo input arguments: (x ...*Var)\n\nGo return type: *Tuple\n\nJoker input arguments: [^(ellipsis-somehow types/Var) x]\n\nJoker return type: (atom-of go.std.go.types/Tuple)"
;;   {:added "1.0"
;;    :go "__newTuple(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHa*_types.Var(__x)))"}
;;   [^types/Var __x])

JOKER FUNC go/types.NewTypeName from go/types/object.go:
;; (defn NewTypeName
;;   "NewTypeName returns a new type name denoting the given typ.\nThe remaining arguments set the attributes found with all Objects.\n\nThe typ argument may be a defined (Named) type or an alias type.\nIt may also be nil such that the returned TypeName can be used as\nargument for NewNamed, which will set the TypeName's type as a side-\neffect.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, typ Type)\n\nGo return type: *TypeName\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^go.std.go.types/Type typ]\n\nJoker return type: (atom-of go.std.go.types/TypeName)"
;;   {:added "1.0"
;;    :go "__newTypeName(*__pos, __pkg, __name, *__typ)"}
;;   [^token/Pos __pos, ^types/Package __pkg, ^String __name, ^types/Type __typ])

JOKER FUNC go/types.NewVar from go/types/object.go:
;; (defn NewVar
;;   "NewVar returns a new variable.\nThe arguments set the attributes found with all Objects.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, typ Type)\n\nGo return type: *Var\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^go.std.go.types/Type typ]\n\nJoker return type: (atom-of go.std.go.types/Var)"
;;   {:added "1.0"
;;    :go "__newVar(*__pos, __pkg, __name, *__typ)"}
;;   [^token/Pos __pos, ^types/Package __pkg, ^String __name, ^types/Type __typ])

JOKER FUNC go/types.ObjectString from go/types/object.go:
(defn ^"String" ObjectString
  "ObjectString returns the string form of obj.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo input arguments: (obj Object, qf Qualifier)\n\nGo return type: string\n\nJoker input arguments: [^go.std.go.types/Object obj, ^go.std.go.types/Qualifier qf]\n\nJoker return type: String"
  {:added "1.0"
   :go "types.ObjectString(*__obj, *__qf)"}
  [^types/Object __obj, ^types/Qualifier __qf])

JOKER FUNC go/types.RelativeTo from go/types/typestring.go:
(defn RelativeTo
  "RelativeTo(pkg) returns a Qualifier that fully qualifies members of\nall packages other than pkg.\n\nGo input arguments: (pkg *Package)\n\nGo return type: Qualifier\n\nJoker input arguments: [^(atom-of go.std.go.types/Package) pkg]\n\nJoker return type: go.std.go.types/Qualifier"
  {:added "1.0"
   :go "__relativeTo(__pkg)"}
  [^types/Package __pkg])

JOKER FUNC go/types.SelectionString from go/types/selection.go:
(defn ^"String" SelectionString
  "SelectionString returns the string form of s.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nExamples:\n\t\"field (T) f int\"\n\t\"method (T) f(X) Y\"\n\t\"method expr (T) f(X) Y\"\n\nGo input arguments: (s *Selection, qf Qualifier)\n\nGo return type: string\n\nJoker input arguments: [^(atom-of go.std.go.types/Selection) s, ^go.std.go.types/Qualifier qf]\n\nJoker return type: String"
  {:added "1.0"
   :go "types.SelectionString(__s, *__qf)"}
  [^types/Selection __s, ^types/Qualifier __qf])

JOKER FUNC go/types.SizesFor from go/types/sizes.go:
(defn SizesFor
  "SizesFor returns the Sizes used by a compiler for an architecture.\nThe result is nil if a compiler/architecture pair is not known.\n\nSupported architectures for compiler \"gc\":\n\"386\", \"arm\", \"arm64\", \"amd64\", \"amd64p32\", \"mips\", \"mipsle\",\n\"mips64\", \"mips64le\", \"ppc64\", \"ppc64le\", \"riscv64\", \"s390x\", \"sparc64\", \"wasm\".\n\nGo input arguments: (compiler string, arch string)\n\nGo return type: Sizes\n\nJoker input arguments: [^String compiler, ^String arch]\n\nJoker return type: go.std.go.types/Sizes"
  {:added "1.0"
   :go "__sizesFor(__compiler, __arch)"}
  [^String __compiler, ^String __arch])

JOKER FUNC go/types.TypeString from go/types/typestring.go:
(defn ^"String" TypeString
  "TypeString returns the string representation of typ.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo input arguments: (typ Type, qf Qualifier)\n\nGo return type: string\n\nJoker input arguments: [^go.std.go.types/Type typ, ^go.std.go.types/Qualifier qf]\n\nJoker return type: String"
  {:added "1.0"
   :go "types.TypeString(*__typ, *__qf)"}
  [^types/Type __typ, ^types/Qualifier __qf])

JOKER FUNC go/types.WriteExpr from go/types/exprstring.go:
;; (defn WriteExpr
;;   "WriteExpr writes the (possibly shortened) string representation for x to buf.\nShortened representations are suitable for user interfaces but may not\nnecessarily follow Go syntax.\n\nGo input arguments: (buf *bytes.Buffer, x ast.Expr)\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) buf, ^go.std.go.ast/Expr x]"
;;   {:added "1.0"
;;    :go "__writeExpr(__buf, *__x)"}
;;   [^bytes/Buffer __buf, ^ast/Expr __x])

JOKER FUNC go/types.WriteSignature from go/types/typestring.go:
;; (defn WriteSignature
;;   "WriteSignature writes the representation of the signature sig to buf,\nwithout a leading \"func\" keyword.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo input arguments: (buf *bytes.Buffer, sig *Signature, qf Qualifier)\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) buf, ^(atom-of go.std.go.types/Signature) sig, ^go.std.go.types/Qualifier qf]"
;;   {:added "1.0"
;;    :go "__writeSignature(__buf, __sig, *__qf)"}
;;   [^bytes/Buffer __buf, ^types/Signature __sig, ^types/Qualifier __qf])

JOKER FUNC go/types.WriteType from go/types/typestring.go:
;; (defn WriteType
;;   "WriteType writes the string representation of typ to buf.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo input arguments: (buf *bytes.Buffer, typ Type, qf Qualifier)\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) buf, ^go.std.go.types/Type typ, ^go.std.go.types/Qualifier qf]"
;;   {:added "1.0"
;;    :go "__writeType(__buf, *__typ, *__qf)"}
;;   [^bytes/Buffer __buf, ^types/Type __typ, ^types/Qualifier __qf])

JOKER TYPE go.std.go.types/Array:
(def
  ^{:doc "An Array represents an array type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Array"}
  Array)

JOKER TYPE go.std.go.types/Basic:
(def
  ^{:doc "A Basic represents a basic type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Basic"}
  Basic)

JOKER TYPE go.std.go.types/BasicInfo:
(def
  ^{:doc "BasicInfo is a set of flags describing properties of a basic type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BasicInfo"}
  BasicInfo)

JOKER TYPE go.std.go.types/BasicKind:
(def
  ^{:doc "BasicKind describes the kind of basic type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BasicKind"}
  BasicKind)

JOKER TYPE go.std.go.types/Builtin:
(def
  ^{:doc "A Builtin represents a built-in function.\nBuiltins don't have a valid type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Builtin"}
  Builtin)

JOKER TYPE go.std.go.types/Chan:
(def
  ^{:doc "A Chan represents a channel type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Chan"}
  Chan)

JOKER TYPE go.std.go.types/ChanDir:
(def
  ^{:doc "A ChanDir value indicates a channel direction.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ChanDir"}
  ChanDir)

JOKER TYPE go.std.go.types/Checker:
(def
  ^{:doc "A Checker maintains the state of the type checker.\nIt must be created with NewChecker.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Checker"}
  Checker)

JOKER TYPE go.std.go.types/Config:
(def
  ^{:doc "A Config specifies the configuration for type checking.\nThe zero value for Config is a ready-to-use default configuration.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Config"}
  Config)

JOKER TYPE go.std.go.types/Const:
(def
  ^{:doc "A Const represents a declared constant.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Const"}
  Const)

JOKER TYPE go.std.go.types/Error:
(def
  ^{:doc "An Error describes a type-checking error; it implements the error interface.\nA \"soft\" error is an error that still permits a valid interpretation of a\npackage (such as \"unused variable\"); \"hard\" errors may lead to unpredictable\nbehavior if ignored.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Error"}
  Error)

JOKER TYPE go.std.go.types/Func:
(def
  ^{:doc "A Func represents a declared function, concrete method, or abstract\n(interface) method. Its Type() is always a *Signature.\nAn abstract method may belong to many interfaces due to embedding.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Func"}
  Func)

JOKER TYPE go.std.go.types/ImportMode:
(def
  ^{:doc "ImportMode is reserved for future use.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ImportMode"}
  ImportMode)

JOKER TYPE go.std.go.types/Importer:
(def
  ^{:doc "An Importer resolves import paths to Packages.\n\nCAUTION: This interface does not support the import of locally\nvendored packages. See https://golang.org/s/go15vendor.\nIf possible, external implementations should implement ImporterFrom.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Importer"}
  Importer)

JOKER TYPE go.std.go.types/ImporterFrom:
(def
  ^{:doc "An ImporterFrom resolves import paths to packages; it\nsupports vendoring per https://golang.org/s/go15vendor.\nUse go/importer to obtain an ImporterFrom implementation.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ImporterFrom"}
  ImporterFrom)

JOKER TYPE go.std.go.types/Info:
(def
  ^{:doc "Info holds result type information for a type-checked package.\nOnly the information for which a map is provided is collected.\nIf the package has type errors, the collected information may\nbe incomplete.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Info"}
  Info)

JOKER TYPE go.std.go.types/Initializer:
(def
  ^{:doc "An Initializer describes a package-level variable, or a list of variables in case\nof a multi-valued initialization expression, and the corresponding initialization\nexpression.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Initializer"}
  Initializer)

JOKER TYPE go.std.go.types/Interface:
(def
  ^{:doc "An Interface represents an interface type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Interface"}
  Interface)

JOKER TYPE go.std.go.types/Label:
(def
  ^{:doc "A Label represents a declared label.\nLabels don't have a type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Label"}
  Label)

JOKER TYPE go.std.go.types/Map:
(def
  ^{:doc "A Map represents a map type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Map"}
  Map)

JOKER TYPE go.std.go.types/MethodSet:
(def
  ^{:doc "A MethodSet is an ordered set of concrete or abstract (interface) methods;\na method is a MethodVal selection, and they are ordered by ascending m.Obj().Id().\nThe zero value for a MethodSet is a ready-to-use empty method set.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_MethodSet"}
  MethodSet)

JOKER TYPE go.std.go.types/Named:
(def
  ^{:doc "A Named represents a named type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Named"}
  Named)

JOKER TYPE go.std.go.types/Nil:
(def
  ^{:doc "Nil represents the predeclared value nil.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Nil"}
  Nil)

JOKER TYPE go.std.go.types/Object:
(def
  ^{:doc "An Object describes a named language entity such as a package,\nconstant, type, variable, function (incl. methods), or label.\nAll objects implement the Object interface.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Object"}
  Object)

JOKER TYPE go.std.go.types/Package:
(def
  ^{:doc "A Package describes a Go package.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Package"}
  Package)

JOKER TYPE go.std.go.types/PkgName:
(def
  ^{:doc "A PkgName represents an imported Go package.\nPkgNames don't have a type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PkgName"}
  PkgName)

JOKER TYPE go.std.go.types/Pointer:
(def
  ^{:doc "A Pointer represents a pointer type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Pointer"}
  Pointer)

JOKER TYPE go.std.go.types/Qualifier:
(def
  ^{:doc "A Qualifier controls how named package-level objects are printed in\ncalls to TypeString, ObjectString, and SelectionString.\n\nThese three formatting routines call the Qualifier for each\npackage-level object O, and if the Qualifier returns a non-empty\nstring p, the object is printed in the form p.O.\nIf it returns an empty string, only the object name O is printed.\n\nUsing a nil Qualifier is equivalent to using (*Package).Path: the\nobject is qualified by the import path, e.g., \"encoding/json.Marshal\".\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Qualifier"}
  Qualifier)

JOKER TYPE go.std.go.types/Scope:
(def
  ^{:doc "A Scope maintains a set of objects and links to its containing\n(parent) and contained (children) scopes. Objects may be inserted\nand looked up by name. The zero value for Scope is a ready-to-use\nempty scope.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Scope"}
  Scope)

JOKER TYPE go.std.go.types/Selection:
(def
  ^{:doc "A Selection describes a selector expression x.f.\nFor the declarations:\n\n\ttype T struct{ x int; E }\n\ttype E struct{}\n\tfunc (e E) m() {}\n\tvar p *T\n\nthe following relations exist:\n\n\tSelector    Kind          Recv    Obj    Type               Index     Indirect\n\n\tp.x         FieldVal      T       x      int                {0}       true\n\tp.m         MethodVal     *T      m      func (e *T) m()    {1, 0}    true\n\tT.m         MethodExpr    T       m      func m(_ T)        {1, 0}    false\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Selection"}
  Selection)

JOKER TYPE go.std.go.types/SelectionKind:
(def
  ^{:doc "SelectionKind describes the kind of a selector expression x.f\n(excluding qualified identifiers).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SelectionKind"}
  SelectionKind)

JOKER TYPE go.std.go.types/Signature:
(def
  ^{:doc "A Signature represents a (non-builtin) function or method type.\nThe receiver is ignored when comparing signatures for identity.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Signature"}
  Signature)

JOKER TYPE go.std.go.types/Sizes:
(def
  ^{:doc "Sizes defines the sizing functions for package unsafe.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Sizes"}
  Sizes)

JOKER TYPE go.std.go.types/Slice:
(def
  ^{:doc "A Slice represents a slice type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Slice"}
  Slice)

JOKER TYPE go.std.go.types/StdSizes:
(def
  ^{:doc "StdSizes is a convenience type for creating commonly used Sizes.\nIt makes the following simplifying assumptions:\n\n\t- The size of explicitly sized basic types (int16, etc.) is the\n\t  specified size.\n\t- The size of strings and interfaces is 2*WordSize.\n\t- The size of slices is 3*WordSize.\n\t- The size of an array of n elements corresponds to the size of\n\t  a struct of n consecutive fields of the array's element type.\n     - The size of a struct is the offset of the last field plus that\n\t  field's size. As with all element types, if the struct is used\n\t  in an array its size must first be aligned to a multiple of the\n\t  struct's alignment.\n\t- All other types have size WordSize.\n\t- Arrays and structs are aligned per spec definition; all other\n\t  types are naturally aligned with a maximum alignment MaxAlign.\n\n*StdSizes implements Sizes.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_StdSizes"}
  StdSizes)

JOKER TYPE go.std.go.types/Struct:
(def
  ^{:doc "A Struct represents a struct type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Struct"}
  Struct)

JOKER TYPE go.std.go.types/Tuple:
(def
  ^{:doc "A Tuple represents an ordered list of variables; a nil *Tuple is a valid (empty) tuple.\nTuples are used as components of signatures and to represent the type of multiple\nassignments; they are not first class types of Go.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Tuple"}
  Tuple)

JOKER TYPE go.std.go.types/Type:
(def
  ^{:doc "A Type represents a type of Go.\nAll types implement the Type interface.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Type"}
  Type)

JOKER TYPE go.std.go.types/TypeAndValue:
(def
  ^{:doc "TypeAndValue reports the type and value (for constants)\nof the corresponding expression.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TypeAndValue"}
  TypeAndValue)

JOKER TYPE go.std.go.types/TypeName:
(def
  ^{:doc "A TypeName represents a name for a (defined or alias) type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TypeName"}
  TypeName)

JOKER TYPE go.std.go.types/Var:
(def
  ^{:doc "A Variable represents a declared variable (including function parameters and results, and struct fields).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Var"}
  Var)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/types"]
    :doc "Provides a low-level interface to the go/types package.\n\nPackage types declares the data types and implements\nthe algorithms for type-checking of Go packages. Use\nConfig.Check to invoke the type checker for a package.\nAlternatively, create a new type checker with NewChecker\nand invoke it incrementally by calling Checker.Files.\n\nType-checking consists of several interdependent phases:\n\nName resolution maps each identifier (ast.Ident) in the program to the\nlanguage object (Object) it denotes.\nUse Info.{Defs,Uses,Implicits} for the results of name resolution.\n\nConstant folding computes the exact constant value (constant.Value)\nfor every expression (ast.Expr) that is a compile-time constant.\nUse Info.Types[expr].Value for the results of constant folding.\n\nType inference computes the type (Type) of every expression (ast.Expr)\nand checks for compliance with the language specification.\nUse Info.Types[expr].Type for the results of type inference.\n\nFor a tutorial, see https://golang.org/s/types-tutorial.\n"
    :empty false}
  go.std.go.types)
JOKER TYPE go.std.hash/Hash:
(def
  ^{:doc "Hash is the common interface implemented by all hash functions.\n\nHash implementations in the standard library (e.g. hash/crc32 and\ncrypto/sha256) implement the encoding.BinaryMarshaler and\nencoding.BinaryUnmarshaler interfaces. Marshaling a hash implementation\nallows its internal state to be saved and used for additional processing\nlater, without having to re-write the data previously written to the hash.\nThe hash state may contain portions of the input in its original form,\nwhich users are expected to handle for any possible security implications.\n\nCompatibility: Any future changes to hash or crypto packages will endeavor\nto maintain compatibility with state encoded using previous versions.\nThat is, any released versions of the packages should be able to\ndecode data written with any previously released version,\nsubject to issues such as security fixes.\nSee the Go compatibility document for background: https://golang.org/doc/go1compat\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Hash"}
  Hash)

JOKER TYPE go.std.hash/Hash32:
(def
  ^{:doc "Hash32 is the common interface implemented by all 32-bit hash functions.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Hash32"}
  Hash32)

JOKER TYPE go.std.hash/Hash64:
(def
  ^{:doc "Hash64 is the common interface implemented by all 64-bit hash functions.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Hash64"}
  Hash64)

JOKER CONSTANT Size from hash/adler32/adler32.go:
(def
  ^{:doc "The size of an Adler-32 checksum in bytes.\n"
    :added "1.0"
    :tag "Int"
    :go "adler32.Size"}
  Size)

JOKER FUNC hash/adler32.Checksum from hash/adler32/adler32.go:
;; (defn Checksum
;;   "Checksum returns the Adler-32 checksum of data.\n\nGo input arguments: (data []byte)\n\nGo return type: uint32\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__checksum(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)))"}
;;   [^Object __data])

JOKER FUNC hash/adler32.New from hash/adler32/adler32.go:
(defn New
  "New returns a new hash.Hash32 computing the Adler-32 checksum. Its\nSum method will lay the value out in big-endian byte order. The\nreturned Hash32 also implements encoding.BinaryMarshaler and\nencoding.BinaryUnmarshaler to marshal and unmarshal the internal\nstate of the hash.\n\nGo return type: hash.Hash32\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash32"
  {:added "1.0"
   :go "__new()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["hash/adler32"]
    :doc "Provides a low-level interface to the hash/adler32 package.\n\nPackage adler32 implements the Adler-32 checksum.\n\nIt is defined in RFC 1950:\n\tAdler-32 is composed of two sums accumulated per byte: s1 is\n\tthe sum of all bytes, s2 is the sum of all s1 values. Both sums\n\tare done modulo 65521. s1 is initialized to 1, s2 to zero.  The\n\tAdler-32 checksum is stored as s2*65536 + s1 in most-\n\tsignificant-byte first (network) order.\n"
    :empty false}
  go.std.hash.adler32)
JOKER CONSTANT Castagnoli from hash/crc32/crc32.go:
(def
  ^{:doc "Castagnoli's polynomial, used in iSCSI.\nHas better error detection characteristics than IEEE.\nhttps://dx.doi.org/10.1109/26.231911\n"
    :added "1.0"
    :tag "Number"
    :go "int64(crc32.Castagnoli)"}
  Castagnoli)

JOKER CONSTANT IEEE from hash/crc32/crc32.go:
(def
  ^{:doc "IEEE is by far and away the most common CRC-32 polynomial.\nUsed by ethernet (IEEE 802.3), v.42, fddi, gzip, zip, png, ...\n"
    :added "1.0"
    :tag "Number"
    :go "int64(crc32.IEEE)"}
  IEEE)

JOKER CONSTANT Koopman from hash/crc32/crc32.go:
(def
  ^{:doc "Koopman's polynomial.\nAlso has better error detection characteristics than IEEE.\nhttps://dx.doi.org/10.1109/DSN.2002.1028931\n"
    :added "1.0"
    :tag "Number"
    :go "int64(crc32.Koopman)"}
  Koopman)

JOKER CONSTANT Size from hash/crc32/crc32.go:
(def
  ^{:doc "The size of a CRC-32 checksum in bytes.\n"
    :added "1.0"
    :tag "Int"
    :go "crc32.Size"}
  Size)

JOKER VARIABLE IEEETable from hash/crc32/crc32.go:
(def
  ^{:doc "IEEETable is the table for the IEEE polynomial.\n"
    :added "1.0"
    :tag "Var"
    :go "crc32.IEEETable"}
  IEEETable)

JOKER TYPE hash/crc32.Table from hash/crc32/crc32.go:
;; (defn ^"GoObject" Table.
;;   "Constructor for crc32.Table"
;;   {:added "1.0"
;;    :go "_ConstructTable(_v)"}
;;   [^Object _v])

JOKER FUNC hash/crc32.Checksum from hash/crc32/crc32.go:
;; (defn Checksum
;;   "Checksum returns the CRC-32 checksum of data\nusing the polynomial represented by the Table.\n\nGo input arguments: (data []byte, tab *Table)\n\nGo return type: uint32\n\nJoker input arguments: [^(vector-of Int) data, ^(atom-of go.std.hash.crc32/Table) tab]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__checksum(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)), __tab)"}
;;   [^Object __data, ^crc32/Table __tab])

JOKER FUNC hash/crc32.ChecksumIEEE from hash/crc32/crc32.go:
;; (defn ChecksumIEEE
;;   "ChecksumIEEE returns the CRC-32 checksum of data\nusing the IEEE polynomial.\n\nGo input arguments: (data []byte)\n\nGo return type: uint32\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__checksumIEEE(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)))"}
;;   [^Object __data])

JOKER FUNC hash/crc32.MakeTable from hash/crc32/crc32.go:
(defn MakeTable
  "MakeTable returns a Table constructed from the specified polynomial.\nThe contents of this Table must not be modified.\n\nGo input arguments: (poly uint32)\n\nGo return type: *Table\n\nJoker input arguments: [^Number poly]\n\nJoker return type: (atom-of go.std.hash.crc32/Table)"
  {:added "1.0"
   :go "__makeTable(__poly)"}
  [^UInt32 __poly])

JOKER FUNC hash/crc32.New from hash/crc32/crc32.go:
(defn New
  "New creates a new hash.Hash32 computing the CRC-32 checksum using the\npolynomial represented by the Table. Its Sum method will lay the\nvalue out in big-endian byte order. The returned Hash32 also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo input arguments: (tab *Table)\n\nGo return type: hash.Hash32\n\nJoker input arguments: [^(atom-of go.std.hash.crc32/Table) tab]\n\nJoker return type: go.std.hash/Hash32"
  {:added "1.0"
   :go "__new(__tab)"}
  [^crc32/Table __tab])

JOKER FUNC hash/crc32.NewIEEE from hash/crc32/crc32.go:
(defn NewIEEE
  "NewIEEE creates a new hash.Hash32 computing the CRC-32 checksum using\nthe IEEE polynomial. Its Sum method will lay the value out in\nbig-endian byte order. The returned Hash32 also implements\nencoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal\nand unmarshal the internal state of the hash.\n\nGo return type: hash.Hash32\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash32"
  {:added "1.0"
   :go "__newIEEE()"}
  [])

JOKER FUNC hash/crc32.Update from hash/crc32/crc32.go:
;; (defn Update
;;   "Update returns the result of adding the bytes in p to the crc.\n\nGo input arguments: (crc uint32, tab *Table, p []byte)\n\nGo return type: uint32\n\nJoker input arguments: [^Number crc, ^(atom-of go.std.hash.crc32/Table) tab, ^(vector-of Int) p]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__update(__crc, __tab, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)))"}
;;   [^UInt32 __crc, ^crc32/Table __tab, ^Object __p])

JOKER TYPE go.std.hash.crc32/Table:
(def
  ^{:doc "Table is a 256-word table representing the polynomial for efficient processing.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Table"}
  Table)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["hash/crc32"]
    :doc "Provides a low-level interface to the hash/crc32 package.\n\nPackage crc32 implements the 32-bit cyclic redundancy check, or CRC-32,\nchecksum. See https://en.wikipedia.org/wiki/Cyclic_redundancy_check for\ninformation.\n\nPolynomials are represented in LSB-first form also known as reversed representation.\n\nSee https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Reversed_representations_and_reciprocal_polynomials\nfor information.\n"
    :empty false}
  go.std.hash.crc32)
JOKER CONSTANT ECMA from hash/crc64/crc64.go:
(def
  ^{:doc "The ECMA polynomial, defined in ECMA 182.\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(crc64.ECMA)"}
  ECMA)

JOKER CONSTANT ISO from hash/crc64/crc64.go:
(def
  ^{:doc "The ISO polynomial, defined in ISO 3309 and used in HDLC.\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(crc64.ISO)"}
  ISO)

JOKER CONSTANT Size from hash/crc64/crc64.go:
(def
  ^{:doc "The size of a CRC-64 checksum in bytes.\n"
    :added "1.0"
    :tag "Int"
    :go "crc64.Size"}
  Size)

JOKER TYPE hash/crc64.Table from hash/crc64/crc64.go:
;; (defn ^"GoObject" Table.
;;   "Constructor for crc64.Table"
;;   {:added "1.0"
;;    :go "_ConstructTable(_v)"}
;;   [^Object _v])

JOKER FUNC hash/crc64.Checksum from hash/crc64/crc64.go:
;; (defn Checksum
;;   "Checksum returns the CRC-64 checksum of data\nusing the polynomial represented by the Table.\n\nGo input arguments: (data []byte, tab *Table)\n\nGo return type: uint64\n\nJoker input arguments: [^(vector-of Int) data, ^(atom-of go.std.hash.crc64/Table) tab]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__checksum(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)), __tab)"}
;;   [^Object __data, ^crc64/Table __tab])

JOKER FUNC hash/crc64.MakeTable from hash/crc64/crc64.go:
(defn MakeTable
  "MakeTable returns a Table constructed from the specified polynomial.\nThe contents of this Table must not be modified.\n\nGo input arguments: (poly uint64)\n\nGo return type: *Table\n\nJoker input arguments: [^Number poly]\n\nJoker return type: (atom-of go.std.hash.crc64/Table)"
  {:added "1.0"
   :go "__makeTable(__poly)"}
  [^UInt64 __poly])

JOKER FUNC hash/crc64.New from hash/crc64/crc64.go:
(defn New
  "New creates a new hash.Hash64 computing the CRC-64 checksum using the\npolynomial represented by the Table. Its Sum method will lay the\nvalue out in big-endian byte order. The returned Hash64 also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo input arguments: (tab *Table)\n\nGo return type: hash.Hash64\n\nJoker input arguments: [^(atom-of go.std.hash.crc64/Table) tab]\n\nJoker return type: go.std.hash/Hash64"
  {:added "1.0"
   :go "__new(__tab)"}
  [^crc64/Table __tab])

JOKER FUNC hash/crc64.Update from hash/crc64/crc64.go:
;; (defn Update
;;   "Update returns the result of adding the bytes in p to the crc.\n\nGo input arguments: (crc uint64, tab *Table, p []byte)\n\nGo return type: uint64\n\nJoker input arguments: [^Number crc, ^(atom-of go.std.hash.crc64/Table) tab, ^(vector-of Int) p]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__update(__crc, __tab, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)))"}
;;   [^UInt64 __crc, ^crc64/Table __tab, ^Object __p])

JOKER TYPE go.std.hash.crc64/Table:
(def
  ^{:doc "Table is a 256-word table representing the polynomial for efficient processing.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Table"}
  Table)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["hash/crc64"]
    :doc "Provides a low-level interface to the hash/crc64 package.\n\nPackage crc64 implements the 64-bit cyclic redundancy check, or CRC-64,\nchecksum. See https://en.wikipedia.org/wiki/Cyclic_redundancy_check for\ninformation.\n"
    :empty false}
  go.std.hash.crc64)
JOKER FUNC hash/fnv.New128 from hash/fnv/fnv.go:
(defn New128
  "New128 returns a new 128-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new128()"}
  [])

JOKER FUNC hash/fnv.New128a from hash/fnv/fnv.go:
(defn New128a
  "New128a returns a new 128-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new128a()"}
  [])

JOKER FUNC hash/fnv.New32 from hash/fnv/fnv.go:
(defn New32
  "New32 returns a new 32-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash32\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash32"
  {:added "1.0"
   :go "__new32()"}
  [])

JOKER FUNC hash/fnv.New32a from hash/fnv/fnv.go:
(defn New32a
  "New32a returns a new 32-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash32\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash32"
  {:added "1.0"
   :go "__new32a()"}
  [])

JOKER FUNC hash/fnv.New64 from hash/fnv/fnv.go:
(defn New64
  "New64 returns a new 64-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash64\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash64"
  {:added "1.0"
   :go "__new64()"}
  [])

JOKER FUNC hash/fnv.New64a from hash/fnv/fnv.go:
(defn New64a
  "New64a returns a new 64-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash64\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash64"
  {:added "1.0"
   :go "__new64a()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the hash/fnv package.\n\nPackage fnv implements FNV-1 and FNV-1a, non-cryptographic hash functions\ncreated by Glenn Fowler, Landon Curt Noll, and Phong Vo.\nSee\nhttps://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function.\n\nAll the hash.Hash implementations returned by this package also\nimplement encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n"
    :empty false}
  go.std.hash.fnv)
JOKER FUNC html.EscapeString from html/escape.go:
(defn ^"String" EscapeString
  "EscapeString escapes special characters like \"<\" to become \"&lt;\". It\nescapes only five such characters: <, >, &, ' and \".\nUnescapeString(EscapeString(s)) == s always holds, but the converse isn't\nalways true.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "html.EscapeString(__s)"}
  [^String __s])

JOKER FUNC html.UnescapeString from html/escape.go:
(defn ^"String" UnescapeString
  "UnescapeString unescapes entities like \"&lt;\" to become \"<\". It unescapes a\nlarger range of entities than EscapeString escapes. For example, \"&aacute;\"\nunescapes to \"á\", as does \"&#225;\" and \"&#xE1;\".\nUnescapeString(EscapeString(s)) == s always holds, but the converse isn't\nalways true.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "html.UnescapeString(__s)"}
  [^String __s])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["html"]
    :doc "Provides a low-level interface to the html package.\n\nPackage html provides functions for escaping and unescaping HTML text.\n"
    :empty false}
  go.std.html)
JOKER CONSTANT ErrAmbigContext from html/template/error.go:
(def
  ^{:doc "ErrAmbigContext: \"... appears in an ambiguous context within a URL\"\nExample:\n  <a href=\"\n     {{if .C}}\n       /path/\n     {{else}}\n       /search?q=\n     {{end}}\n     {{.X}}\n  \">\nDiscussion:\n  {{.X}} is in an ambiguous URL context since, depending on {{.C}},\n it may be either a URL suffix or a query parameter.\n  Moving {{.X}} into the condition removes the ambiguity:\n  <a href=\"{{if .C}}/path/{{.X}}{{else}}/search?q={{.X}}\">\n"
    :added "1.0"
    :tag "Int"
    :go "int(template.ErrAmbigContext)"}
  ErrAmbigContext)

JOKER CONSTANT ErrBadHTML from html/template/error.go:
(def
  ^{:doc "ErrBadHTML: \"expected space, attr name, or end of tag, but got ...\",\n  \"... in unquoted attr\", \"... in attribute name\"\nExample:\n  <a href = /search?q=foo>\n  <href=foo>\n  <form na<e=...>\n  <option selected<\nDiscussion:\n  This is often due to a typo in an HTML element, but some runes\n  are banned in tag names, attribute names, and unquoted attribute\n  values because they can tickle parser ambiguities.\n  Quoting all attributes is the best policy.\n"
    :added "1.0"
    :tag "Int"
    :go "int(template.ErrBadHTML)"}
  ErrBadHTML)

JOKER CONSTANT ErrBranchEnd from html/template/error.go:
(def
  ^{:doc "ErrBranchEnd: \"{{if}} branches end in different contexts\"\nExample:\n  {{if .C}}<a href=\"{{end}}{{.X}}\nDiscussion:\n  Package html/template statically examines each path through an\n  {{if}}, {{range}}, or {{with}} to escape any following pipelines.\n  The example is ambiguous since {{.X}} might be an HTML text node,\n  or a URL prefix in an HTML attribute. The context of {{.X}} is\n  used to figure out how to escape it, but that context depends on\n  the run-time value of {{.C}} which is not statically known.\n\n  The problem is usually something like missing quotes or angle\n  brackets, or can be avoided by refactoring to put the two contexts\n  into different branches of an if, range or with. If the problem\n  is in a {{range}} over a collection that should never be empty,\n  adding a dummy {{else}} can help.\n"
    :added "1.0"
    :tag "Int"
    :go "int(template.ErrBranchEnd)"}
  ErrBranchEnd)

JOKER CONSTANT ErrEndContext from html/template/error.go:
(def
  ^{:doc "ErrEndContext: \"... ends in a non-text context: ...\"\nExamples:\n  <div\n  <div title=\"no close quote>\n  <script>f()\nDiscussion:\n  Executed templates should produce a DocumentFragment of HTML.\n  Templates that end without closing tags will trigger this error.\n  Templates that should not be used in an HTML context or that\n  produce incomplete Fragments should not be executed directly.\n\n  {{define \"main\"}} <script>{{template \"helper\"}}</script> {{end}}\n  {{define \"helper\"}} document.write(' <div title=\" ') {{end}}\n\n  \"helper\" does not produce a valid document fragment, so should\n  not be Executed directly.\n"
    :added "1.0"
    :tag "Int"
    :go "int(template.ErrEndContext)"}
  ErrEndContext)

JOKER CONSTANT ErrNoSuchTemplate from html/template/error.go:
(def
  ^{:doc "ErrNoSuchTemplate: \"no such template ...\"\nExamples:\n  {{define \"main\"}}<div {{template \"attrs\"}}>{{end}}\n  {{define \"attrs\"}}href=\"{{.URL}}\"{{end}}\nDiscussion:\n  Package html/template looks through template calls to compute the\n  context.\n  Here the {{.URL}} in \"attrs\" must be treated as a URL when called\n  from \"main\", but you will get this error if \"attrs\" is not defined\n  when \"main\" is parsed.\n"
    :added "1.0"
    :tag "Int"
    :go "int(template.ErrNoSuchTemplate)"}
  ErrNoSuchTemplate)

JOKER CONSTANT ErrOutputContext from html/template/error.go:
(def
  ^{:doc "ErrOutputContext: \"cannot compute output context for template ...\"\nExamples:\n  {{define \"t\"}}{{if .T}}{{template \"t\" .T}}{{end}}{{.H}}\",{{end}}\nDiscussion:\n  A recursive template does not end in the same context in which it\n  starts, and a reliable output context cannot be computed.\n  Look for typos in the named template.\n  If the template should not be called in the named start context,\n  look for calls to that template in unexpected contexts.\n  Maybe refactor recursive templates to not be recursive.\n"
    :added "1.0"
    :tag "Int"
    :go "int(template.ErrOutputContext)"}
  ErrOutputContext)

JOKER CONSTANT ErrPartialCharset from html/template/error.go:
(def
  ^{:doc "ErrPartialCharset: \"unfinished JS regexp charset in ...\"\nExample:\n    <script>var pattern = /foo[{{.Chars}}]/</script>\nDiscussion:\n  Package html/template does not support interpolation into regular\n  expression literal character sets.\n"
    :added "1.0"
    :tag "Int"
    :go "int(template.ErrPartialCharset)"}
  ErrPartialCharset)

JOKER CONSTANT ErrPartialEscape from html/template/error.go:
(def
  ^{:doc "ErrPartialEscape: \"unfinished escape sequence in ...\"\nExample:\n  <script>alert(\"\\{{.X}}\")</script>\nDiscussion:\n  Package html/template does not support actions following a\n  backslash.\n  This is usually an error and there are better solutions; for\n  example\n    <script>alert(\"{{.X}}\")</script>\n  should work, and if {{.X}} is a partial escape sequence such as\n  \"xA0\", mark the whole sequence as safe content: JSStr(`\\xA0`)\n"
    :added "1.0"
    :tag "Int"
    :go "int(template.ErrPartialEscape)"}
  ErrPartialEscape)

JOKER CONSTANT ErrPredefinedEscaper from html/template/error.go:
(def
  ^{:doc "ErrPredefinedEscaper: \"predefined escaper ... disallowed in template\"\nExample:\n  <div class={{. | html}}>Hello<div>\nDiscussion:\n  Package html/template already contextually escapes all pipelines to\n  produce HTML output safe against code injection. Manually escaping\n  pipeline output using the predefined escapers \"html\" or \"urlquery\" is\n  unnecessary, and may affect the correctness or safety of the escaped\n  pipeline output in Go 1.8 and earlier.\n\n  In most cases, such as the given example, this error can be resolved by\n  simply removing the predefined escaper from the pipeline and letting the\n  contextual autoescaper handle the escaping of the pipeline. In other\n  instances, where the predefined escaper occurs in the middle of a\n  pipeline where subsequent commands expect escaped input, e.g.\n    {{.X | html | makeALink}}\n  where makeALink does\n    return `<a href=\"`+input+`\">link</a>`\n  consider refactoring the surrounding template to make use of the\n  contextual autoescaper, i.e.\n    <a href=\"{{.X}}\">link</a>\n\n  To ease migration to Go 1.9 and beyond, \"html\" and \"urlquery\" will\n  continue to be allowed as the last command in a pipeline. However, if the\n  pipeline occurs in an unquoted attribute value context, \"html\" is\n  disallowed. Avoid using \"html\" and \"urlquery\" entirely in new templates.\n"
    :added "1.0"
    :tag "Int"
    :go "int(template.ErrPredefinedEscaper)"}
  ErrPredefinedEscaper)

JOKER CONSTANT ErrRangeLoopReentry from html/template/error.go:
(def
  ^{:doc "ErrRangeLoopReentry: \"on range loop re-entry: ...\"\nExample:\n  <script>var x = [{{range .}}'{{.}},{{end}}]</script>\nDiscussion:\n  If an iteration through a range would cause it to end in a\n  different context than an earlier pass, there is no single context.\n  In the example, there is missing a quote, so it is not clear\n  whether {{.}} is meant to be inside a JS string or in a JS value\n  context. The second iteration would produce something like\n\n    <script>var x = ['firstValue,'secondValue]</script>\n"
    :added "1.0"
    :tag "Int"
    :go "int(template.ErrRangeLoopReentry)"}
  ErrRangeLoopReentry)

JOKER CONSTANT ErrSlashAmbig from html/template/error.go:
(def
  ^{:doc "ErrSlashAmbig: '/' could start a division or regexp.\nExample:\n  <script>\n    {{if .C}}var x = 1{{end}}\n    /-{{.N}}/i.test(x) ? doThis : doThat();\n  </script>\nDiscussion:\n  The example above could produce `var x = 1/-2/i.test(s)...`\n  in which the first '/' is a mathematical division operator or it\n  could produce `/-2/i.test(s)` in which the first '/' starts a\n  regexp literal.\n  Look for missing semicolons inside branches, and maybe add\n  parentheses to make it clear which interpretation you intend.\n"
    :added "1.0"
    :tag "Int"
    :go "int(template.ErrSlashAmbig)"}
  ErrSlashAmbig)

JOKER CONSTANT OK from html/template/error.go:
(def
  ^{:doc "OK indicates the lack of an error.\n"
    :added "1.0"
    :tag "Int"
    :go "int(template.OK)"}
  OK)

JOKER TYPE html/template.CSS from html/template/content.go:
(defn ^"GoObject" CSS.
  "Constructor for template.CSS"
  {:added "1.0"
   :go "_ConstructCSS(_v)"}
  [^Object _v])

JOKER TYPE html/template.Error from html/template/error.go:
;; (defn ^"GoObject" Error.
;;   "Constructor for template.Error"
;;   {:added "1.0"
;;    :go "_ConstructError(_v)"}
;;   [^Object _v])

JOKER TYPE html/template.ErrorCode from html/template/error.go:
(defn ^"GoObject" ErrorCode.
  "Constructor for template.ErrorCode"
  {:added "1.0"
   :go "_ConstructErrorCode(_v)"}
  [^Object _v])

JOKER TYPE html/template.FuncMap from html/template/template.go:
;; (defn ^"GoObject" FuncMap.
;;   "Constructor for template.FuncMap"
;;   {:added "1.0"
;;    :go "_ConstructFuncMap(_v)"}
;;   [^Object _v])

JOKER TYPE html/template.HTML from html/template/content.go:
(defn ^"GoObject" HTML.
  "Constructor for template.HTML"
  {:added "1.0"
   :go "_ConstructHTML(_v)"}
  [^Object _v])

JOKER TYPE html/template.HTMLAttr from html/template/content.go:
(defn ^"GoObject" HTMLAttr.
  "Constructor for template.HTMLAttr"
  {:added "1.0"
   :go "_ConstructHTMLAttr(_v)"}
  [^Object _v])

JOKER TYPE html/template.JS from html/template/content.go:
(defn ^"GoObject" JS.
  "Constructor for template.JS"
  {:added "1.0"
   :go "_ConstructJS(_v)"}
  [^Object _v])

JOKER TYPE html/template.JSStr from html/template/content.go:
(defn ^"GoObject" JSStr.
  "Constructor for template.JSStr"
  {:added "1.0"
   :go "_ConstructJSStr(_v)"}
  [^Object _v])

JOKER TYPE html/template.Srcset from html/template/content.go:
(defn ^"GoObject" Srcset.
  "Constructor for template.Srcset"
  {:added "1.0"
   :go "_ConstructSrcset(_v)"}
  [^Object _v])

JOKER TYPE html/template.Template from html/template/template.go:
;; (defn ^"GoObject" Template.
;;   "Constructor for template.Template"
;;   {:added "1.0"
;;    :go "_ConstructTemplate(_v)"}
;;   [^Object _v])

JOKER TYPE html/template.URL from html/template/content.go:
(defn ^"GoObject" URL.
  "Constructor for template.URL"
  {:added "1.0"
   :go "_ConstructURL(_v)"}
  [^Object _v])

JOKER FUNC html/template.HTMLEscape from html/template/escape.go:
;; (defn HTMLEscape
;;   "HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.\n\nGo input arguments: (w io.Writer, b []byte)\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Int) b]"
;;   {:added "1.0"
;;    :go "__hTMLEscape(*__w, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))"}
;;   [^io/Writer __w, ^Object __b])

JOKER FUNC html/template.HTMLEscapeString from html/template/escape.go:
(defn ^"String" HTMLEscapeString
  "HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "template.HTMLEscapeString(__s)"}
  [^String __s])

JOKER FUNC html/template.HTMLEscaper from html/template/escape.go:
;; (defn ^"String" HTMLEscaper
;;   "HTMLEscaper returns the escaped HTML equivalent of the textual\nrepresentation of its arguments.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.HTMLEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> __args])

JOKER FUNC html/template.IsTrue from html/template/template.go:
;; (defn IsTrue
;;   "IsTrue reports whether the value is 'true', in the sense of not the zero of its type,\nand whether the value has a meaningful truth value. This is the definition of\ntruth used by if and other such actions.\n\nGo input arguments: (val interface {})\n\nGo return type: (truth bool, ok bool)\n\nJoker input arguments: [^<protocol-or-something> val]\n\nJoker return type: [Boolean Boolean]"
;;   {:added "1.0"
;;    :go "__isTrue(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> __val])

JOKER FUNC html/template.JSEscape from html/template/escape.go:
;; (defn JSEscape
;;   "JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.\n\nGo input arguments: (w io.Writer, b []byte)\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Int) b]"
;;   {:added "1.0"
;;    :go "__jSEscape(*__w, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))"}
;;   [^io/Writer __w, ^Object __b])

JOKER FUNC html/template.JSEscapeString from html/template/escape.go:
(defn ^"String" JSEscapeString
  "JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "template.JSEscapeString(__s)"}
  [^String __s])

JOKER FUNC html/template.JSEscaper from html/template/escape.go:
;; (defn ^"String" JSEscaper
;;   "JSEscaper returns the escaped JavaScript equivalent of the textual\nrepresentation of its arguments.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.JSEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> __args])

JOKER FUNC html/template.Must from html/template/template.go:
(defn Must
  "Must is a helper that wraps a call to a function returning (*Template, error)\nand panics if the error is non-nil. It is intended for use in variable initializations\nsuch as\n\tvar t = template.Must(template.New(\"name\").Parse(\"html\"))\n\nGo input arguments: (t *Template, err error)\n\nGo return type: *Template\n\nJoker input arguments: [^(atom-of go.std.html.template/Template) t, ^Error err]\n\nJoker return type: (atom-of go.std.html.template/Template)"
  {:added "1.0"
   :go "__must(__t, __err)"}
  [^template/Template __t, ^Error __err])

JOKER FUNC html/template.New from html/template/template.go:
(defn New
  "New allocates a new HTML template with the given name.\n\nGo input arguments: (name string)\n\nGo return type: *Template\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.html.template/Template)"
  {:added "1.0"
   :go "__new(__name)"}
  [^String __name])

JOKER FUNC html/template.ParseFiles from html/template/template.go:
;; (defn ParseFiles
;;   "ParseFiles creates a new Template and parses the template definitions from\nthe named files. The returned template's name will have the (base) name and\n(parsed) contents of the first file. There must be at least one file.\nIf an error occurs, parsing stops and the returned *Template is nil.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\nFor instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template\nnamed \"foo\", while \"a/foo\" is unavailable.\n\nGo input arguments: (filenames ...string)\n\nGo return type: (*Template, error)\n\nJoker input arguments: [^(ellipsis-somehow String) filenames]\n\nJoker return type: [(atom-of go.std.html.template/Template) Error]"
;;   {:added "1.0"
;;    :go "__parseFiles(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(__filenames)))"}
;;   [^String __filenames])

JOKER FUNC html/template.ParseGlob from html/template/template.go:
(defn ParseGlob
  "ParseGlob creates a new Template and parses the template definitions from the\nfiles identified by the pattern, which must match at least one file. The\nreturned template will have the (base) name and (parsed) contents of the\nfirst file matched by the pattern. ParseGlob is equivalent to calling\nParseFiles with the list of files matched by the pattern.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\n\nGo input arguments: (pattern string)\n\nGo return type: (*Template, error)\n\nJoker input arguments: [^String pattern]\n\nJoker return type: [(atom-of go.std.html.template/Template) Error]"
  {:added "1.0"
   :go "__parseGlob(__pattern)"}
  [^String __pattern])

JOKER FUNC html/template.URLQueryEscaper from html/template/escape.go:
;; (defn ^"String" URLQueryEscaper
;;   "URLQueryEscaper returns the escaped value of the textual representation of\nits arguments in a form suitable for embedding in a URL query.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.URLQueryEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> __args])

JOKER TYPE go.std.html.template/CSS:
(def
  ^{:doc "CSS encapsulates known safe content that matches any of:\n  1. The CSS3 stylesheet production, such as `p { color: purple }`.\n  2. The CSS3 rule production, such as `a[href=~\"https:\"].foo#bar`.\n  3. CSS3 declaration productions, such as `color: red; margin: 2px`.\n  4. The CSS3 value production, such as `rgba(0, 0, 255, 127)`.\nSee https://www.w3.org/TR/css3-syntax/#parsing and\nhttps://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style\n\nUse of this type presents a security risk:\nthe encapsulated content should come from a trusted source,\nas it will be included verbatim in the template output.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CSS"}
  CSS)

JOKER TYPE go.std.html.template/Error:
(def
  ^{:doc "Error describes a problem encountered during template Escaping.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Error"}
  Error)

JOKER TYPE go.std.html.template/ErrorCode:
(def
  ^{:doc "ErrorCode is a code for a kind of error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ErrorCode"}
  ErrorCode)

JOKER TYPE go.std.html.template/FuncMap:
(def
  ^{:doc "FuncMap is the type of the map defining the mapping from names to\nfunctions. Each function must have either a single return value, or two\nreturn values of which the second has type error. In that case, if the\nsecond (error) argument evaluates to non-nil during execution, execution\nterminates and Execute returns that error. FuncMap has the same base type\nas FuncMap in \"text/template\", copied here so clients need not import\n\"text/template\".\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FuncMap"}
  FuncMap)

JOKER TYPE go.std.html.template/HTML:
(def
  ^{:doc "HTML encapsulates a known safe HTML document fragment.\nIt should not be used for HTML from a third-party, or HTML with\nunclosed tags or comments. The outputs of a sound HTML sanitizer\nand a template escaped by this package are fine for use with HTML.\n\nUse of this type presents a security risk:\nthe encapsulated content should come from a trusted source,\nas it will be included verbatim in the template output.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_HTML"}
  HTML)

JOKER TYPE go.std.html.template/HTMLAttr:
(def
  ^{:doc "HTMLAttr encapsulates an HTML attribute from a trusted source,\nfor example, ` dir=\"ltr\"`.\n\nUse of this type presents a security risk:\nthe encapsulated content should come from a trusted source,\nas it will be included verbatim in the template output.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_HTMLAttr"}
  HTMLAttr)

JOKER TYPE go.std.html.template/JS:
(def
  ^{:doc "JS encapsulates a known safe EcmaScript5 Expression, for example,\n`(x + y * z())`.\nTemplate authors are responsible for ensuring that typed expressions\ndo not break the intended precedence and that there is no\nstatement/expression ambiguity as when passing an expression like\n\"{ foo: bar() }\\n['foo']()\", which is both a valid Expression and a\nvalid Program with a very different meaning.\n\nUse of this type presents a security risk:\nthe encapsulated content should come from a trusted source,\nas it will be included verbatim in the template output.\n\nUsing JS to include valid but untrusted JSON is not safe.\nA safe alternative is to parse the JSON with json.Unmarshal and then\npass the resultant object into the template, where it will be\nconverted to sanitized JSON when presented in a JavaScript context.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_JS"}
  JS)

JOKER TYPE go.std.html.template/JSStr:
(def
  ^{:doc "JSStr encapsulates a sequence of characters meant to be embedded\nbetween quotes in a JavaScript expression.\nThe string must match a series of StringCharacters:\n  StringCharacter :: SourceCharacter but not `\\` or LineTerminator\n                   | EscapeSequence\nNote that LineContinuations are not allowed.\nJSStr(\"foo\\\\nbar\") is fine, but JSStr(\"foo\\\\\\nbar\") is not.\n\nUse of this type presents a security risk:\nthe encapsulated content should come from a trusted source,\nas it will be included verbatim in the template output.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_JSStr"}
  JSStr)

JOKER TYPE go.std.html.template/Srcset:
(def
  ^{:doc "Srcset encapsulates a known safe srcset attribute\n(see https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset).\n\nUse of this type presents a security risk:\nthe encapsulated content should come from a trusted source,\nas it will be included verbatim in the template output.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Srcset"}
  Srcset)

JOKER TYPE go.std.html.template/Template:
(def
  ^{:doc "Template is a specialized Template from \"text/template\" that produces a safe\nHTML document fragment.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Template"}
  Template)

JOKER TYPE go.std.html.template/URL:
(def
  ^{:doc "URL encapsulates a known safe URL or URL substring (see RFC 3986).\nA URL like `javascript:checkThatFormNotEditedBeforeLeavingPage()`\nfrom a trusted source should go in the page, but by default dynamic\n`javascript:` URLs are filtered out since they are a frequently\nexploited injection vector.\n\nUse of this type presents a security risk:\nthe encapsulated content should come from a trusted source,\nas it will be included verbatim in the template output.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_URL"}
  URL)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["html/template"]
    :doc "Provides a low-level interface to the html/template package.\n\nPackage template (html/template) implements data-driven templates for\ngenerating HTML output safe against code injection. It provides the\nsame interface as package text/template and should be used instead of\ntext/template whenever the output is HTML.\n\nThe documentation here focuses on the security features of the package.\nFor information about how to program the templates themselves, see the\ndocumentation for text/template.\n\nIntroduction\n\nThis package wraps package text/template so you can share its template API\nto parse and execute HTML templates safely.\n\n  tmpl, err := template.New(\"name\").Parse(...)\n  // Error checking elided\n  err = tmpl.Execute(out, data)\n\nIf successful, tmpl will now be injection-safe. Otherwise, err is an error\ndefined in the docs for ErrorCode.\n\nHTML templates treat data values as plain text which should be encoded so they\ncan be safely embedded in an HTML document. The escaping is contextual, so\nactions can appear within JavaScript, CSS, and URI contexts.\n\nThe security model used by this package assumes that template authors are\ntrusted, while Execute's data parameter is not. More details are\nprovided below.\n\nExample\n\n  import \"text/template\"\n  ...\n  t, err := template.New(\"foo\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\n  err = t.ExecuteTemplate(out, \"T\", \"<script>alert('you have been pwned')</script>\")\n\nproduces\n\n  Hello, <script>alert('you have been pwned')</script>!\n\nbut the contextual autoescaping in html/template\n\n  import \"html/template\"\n  ...\n  t, err := template.New(\"foo\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`)\n  err = t.ExecuteTemplate(out, \"T\", \"<script>alert('you have been pwned')</script>\")\n\nproduces safe, escaped HTML output\n\n  Hello, &lt;script&gt;alert(&#39;you have been pwned&#39;)&lt;/script&gt;!\n\nContexts\n\nThis package understands HTML, CSS, JavaScript, and URIs. It adds sanitizing\nfunctions to each simple action pipeline, so given the excerpt\n\n  <a href=\"/search?q={{.}}\">{{.}}</a>\n\nAt parse time each {{.}} is overwritten to add escaping functions as necessary.\nIn this case it becomes\n\n  <a href=\"/search?q={{. | urlescaper | attrescaper}}\">{{. | htmlescaper}}</a>\n\nwhere urlescaper, attrescaper, and htmlescaper are aliases for internal escaping\nfunctions.\n\nFor these internal escaping functions, if an action pipeline evaluates to\na nil interface value, it is treated as though it were an empty string.\n\nErrors\n\nSee the documentation of ErrorCode for details.\n\nA fuller picture\n\nThe rest of this package comment may be skipped on first reading; it includes\ndetails necessary to understand escaping contexts and error messages. Most users\nwill not need to understand these details.\n\nContexts\n\nAssuming {{.}} is `O'Reilly: How are <i>you</i>?`, the table below shows\nhow {{.}} appears when used in the context to the left.\n\n  Context                          {{.}} After\n  {{.}}                            O'Reilly: How are &lt;i&gt;you&lt;/i&gt;?\n  <a title='{{.}}'>                O&#39;Reilly: How are you?\n  <a href=\"/{{.}}\">                O&#39;Reilly: How are %3ci%3eyou%3c/i%3e?\n  <a href=\"?q={{.}}\">              O&#39;Reilly%3a%20How%20are%3ci%3e...%3f\n  <a onx='f(\"{{.}}\")'>             O\\x27Reilly: How are \\x3ci\\x3eyou...?\n  <a onx='f({{.}})'>               \"O\\x27Reilly: How are \\x3ci\\x3eyou...?\"\n  <a onx='pattern = /{{.}}/;'>     O\\x27Reilly: How are \\x3ci\\x3eyou...\\x3f\n\nIf used in an unsafe context, then the value might be filtered out:\n\n  Context                          {{.}} After\n  <a href=\"{{.}}\">                 #ZgotmplZ\n\nsince \"O'Reilly:\" is not an allowed protocol like \"http:\".\n\nIf {{.}} is the innocuous word, `left`, then it can appear more widely,\n\n  Context                              {{.}} After\n  {{.}}                                left\n  <a title='{{.}}'>                    left\n  <a href='{{.}}'>                     left\n  <a href='/{{.}}'>                    left\n  <a href='?dir={{.}}'>                left\n  <a style=\"border-{{.}}: 4px\">        left\n  <a style=\"align: {{.}}\">             left\n  <a style=\"background: '{{.}}'>       left\n  <a style=\"background: url('{{.}}')>  left\n  <style>p.{{.}} {color:red}</style>   left\n\nNon-string values can be used in JavaScript contexts.\nIf {{.}} is\n\n  struct{A,B string}{ \"foo\", \"bar\" }\n\nin the escaped template\n\n  <script>var pair = {{.}};</script>\n\nthen the template output is\n\n  <script>var pair = {\"A\": \"foo\", \"B\": \"bar\"};</script>\n\nSee package json to understand how non-string content is marshaled for\nembedding in JavaScript contexts.\n\nTyped Strings\n\nBy default, this package assumes that all pipelines produce a plain text string.\nIt adds escaping pipeline stages necessary to correctly and safely embed that\nplain text string in the appropriate context.\n\nWhen a data value is not plain text, you can make sure it is not over-escaped\nby marking it with its type.\n\nTypes HTML, JS, URL, and others from content.go can carry safe content that is\nexempted from escaping.\n\nThe template\n\n  Hello, {{.}}!\n\ncan be invoked with\n\n  tmpl.Execute(out, template.HTML(`<b>World</b>`))\n\nto produce\n\n  Hello, <b>World</b>!\n\ninstead of the\n\n  Hello, &lt;b&gt;World&lt;b&gt;!\n\nthat would have been produced if {{.}} was a regular string.\n\nSecurity Model\n\nhttps://rawgit.com/mikesamuel/sanitized-jquery-templates/trunk/safetemplate.html#problem_definition defines \"safe\" as used by this package.\n\nThis package assumes that template authors are trusted, that Execute's data\nparameter is not, and seeks to preserve the properties below in the face\nof untrusted data:\n\nStructure Preservation Property:\n\"... when a template author writes an HTML tag in a safe templating language,\nthe browser will interpret the corresponding portion of the output as a tag\nregardless of the values of untrusted data, and similarly for other structures\nsuch as attribute boundaries and JS and CSS string boundaries.\"\n\nCode Effect Property:\n\"... only code specified by the template author should run as a result of\ninjecting the template output into a page and all code specified by the\ntemplate author should run as a result of the same.\"\n\nLeast Surprise Property:\n\"A developer (or code reviewer) familiar with HTML, CSS, and JavaScript, who\nknows that contextual autoescaping happens should be able to look at a {{.}}\nand correctly infer what sanitization happens.\"\n"
    :empty false}
  go.std.html.template)
JOKER CONSTANT YCbCrSubsampleRatio410 from image/ycbcr.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(image.YCbCrSubsampleRatio410)"}
  YCbCrSubsampleRatio410)

JOKER CONSTANT YCbCrSubsampleRatio411 from image/ycbcr.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(image.YCbCrSubsampleRatio411)"}
  YCbCrSubsampleRatio411)

JOKER CONSTANT YCbCrSubsampleRatio420 from image/ycbcr.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(image.YCbCrSubsampleRatio420)"}
  YCbCrSubsampleRatio420)

JOKER CONSTANT YCbCrSubsampleRatio422 from image/ycbcr.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(image.YCbCrSubsampleRatio422)"}
  YCbCrSubsampleRatio422)

JOKER CONSTANT YCbCrSubsampleRatio440 from image/ycbcr.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(image.YCbCrSubsampleRatio440)"}
  YCbCrSubsampleRatio440)

JOKER CONSTANT YCbCrSubsampleRatio444 from image/ycbcr.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(image.YCbCrSubsampleRatio444)"}
  YCbCrSubsampleRatio444)

JOKER VARIABLE Black from image/names.go:
(def
  ^{:doc "Black is an opaque black uniform image.\n"
    :added "1.0"
    :tag "Var"
    :go "image.Black"}
  Black)

JOKER VARIABLE ErrFormat from image/format.go:
(def
  ^{:doc "ErrFormat indicates that decoding encountered an unknown format.\n"
    :added "1.0"
    :tag "Var"
    :go "image.ErrFormat"}
  ErrFormat)

JOKER VARIABLE Opaque from image/names.go:
(def
  ^{:doc "Opaque is a fully opaque uniform image.\n"
    :added "1.0"
    :tag "Var"
    :go "image.Opaque"}
  Opaque)

JOKER VARIABLE Transparent from image/names.go:
(def
  ^{:doc "Transparent is a fully transparent uniform image.\n"
    :added "1.0"
    :tag "Var"
    :go "image.Transparent"}
  Transparent)

JOKER VARIABLE White from image/names.go:
(def
  ^{:doc "White is an opaque white uniform image.\n"
    :added "1.0"
    :tag "Var"
    :go "image.White"}
  White)

JOKER VARIABLE ZP from image/geom.go:
(def
  ^{:doc "ZP is the zero Point.\n"
    :added "1.0"
    :tag "Var"
    :go "image.ZP"}
  ZP)

JOKER VARIABLE ZR from image/geom.go:
(def
  ^{:doc "ZR is the zero Rectangle.\n"
    :added "1.0"
    :tag "Var"
    :go "image.ZR"}
  ZR)

JOKER TYPE image.Alpha from image/image.go:
;; (defn ^"GoObject" Alpha.
;;   "Constructor for image.Alpha"
;;   {:added "1.0"
;;    :go "_ConstructAlpha(_v)"}
;;   [^Object _v])

JOKER TYPE image.Alpha16 from image/image.go:
;; (defn ^"GoObject" Alpha16.
;;   "Constructor for image.Alpha16"
;;   {:added "1.0"
;;    :go "_ConstructAlpha16(_v)"}
;;   [^Object _v])

JOKER TYPE image.CMYK from image/image.go:
;; (defn ^"GoObject" CMYK.
;;   "Constructor for image.CMYK"
;;   {:added "1.0"
;;    :go "_ConstructCMYK(_v)"}
;;   [^Object _v])

JOKER TYPE image.Config from image/image.go:
;; (defn ^"GoObject" Config.
;;   "Constructor for image.Config"
;;   {:added "1.0"
;;    :go "_ConstructConfig(_v)"}
;;   [^Object _v])

JOKER TYPE image.Gray from image/image.go:
;; (defn ^"GoObject" Gray.
;;   "Constructor for image.Gray"
;;   {:added "1.0"
;;    :go "_ConstructGray(_v)"}
;;   [^Object _v])

JOKER TYPE image.Gray16 from image/image.go:
;; (defn ^"GoObject" Gray16.
;;   "Constructor for image.Gray16"
;;   {:added "1.0"
;;    :go "_ConstructGray16(_v)"}
;;   [^Object _v])

JOKER TYPE image.Image from image/image.go:
;; (defn ^"GoObject" Image.
;;   "Constructor for image.Image"
;;   {:added "1.0"
;;    :go "_ConstructImage(_v)"}
;;   [^Object _v])

JOKER TYPE image.NRGBA from image/image.go:
;; (defn ^"GoObject" NRGBA.
;;   "Constructor for image.NRGBA"
;;   {:added "1.0"
;;    :go "_ConstructNRGBA(_v)"}
;;   [^Object _v])

JOKER TYPE image.NRGBA64 from image/image.go:
;; (defn ^"GoObject" NRGBA64.
;;   "Constructor for image.NRGBA64"
;;   {:added "1.0"
;;    :go "_ConstructNRGBA64(_v)"}
;;   [^Object _v])

JOKER TYPE image.NYCbCrA from image/ycbcr.go:
;; (defn ^"GoObject" NYCbCrA.
;;   "Constructor for image.NYCbCrA"
;;   {:added "1.0"
;;    :go "_ConstructNYCbCrA(_v)"}
;;   [^Object _v])

JOKER TYPE image.Paletted from image/image.go:
;; (defn ^"GoObject" Paletted.
;;   "Constructor for image.Paletted"
;;   {:added "1.0"
;;    :go "_ConstructPaletted(_v)"}
;;   [^Object _v])

JOKER TYPE image.PalettedImage from image/image.go:
;; (defn ^"GoObject" PalettedImage.
;;   "Constructor for image.PalettedImage"
;;   {:added "1.0"
;;    :go "_ConstructPalettedImage(_v)"}
;;   [^Object _v])

JOKER TYPE image.Point from image/geom.go:
(defn ^"GoObject" Point.
  "Constructor for image.Point"
  {:added "1.0"
   :go "_ConstructPoint(_v)"}
  [^Object _v])

JOKER TYPE image.RGBA from image/image.go:
;; (defn ^"GoObject" RGBA.
;;   "Constructor for image.RGBA"
;;   {:added "1.0"
;;    :go "_ConstructRGBA(_v)"}
;;   [^Object _v])

JOKER TYPE image.RGBA64 from image/image.go:
;; (defn ^"GoObject" RGBA64.
;;   "Constructor for image.RGBA64"
;;   {:added "1.0"
;;    :go "_ConstructRGBA64(_v)"}
;;   [^Object _v])

JOKER TYPE image.Rectangle from image/geom.go:
;; (defn ^"GoObject" Rectangle.
;;   "Constructor for image.Rectangle"
;;   {:added "1.0"
;;    :go "_ConstructRectangle(_v)"}
;;   [^Object _v])

JOKER TYPE image.Uniform from image/names.go:
;; (defn ^"GoObject" Uniform.
;;   "Constructor for image.Uniform"
;;   {:added "1.0"
;;    :go "_ConstructUniform(_v)"}
;;   [^Object _v])

JOKER TYPE image.YCbCr from image/ycbcr.go:
;; (defn ^"GoObject" YCbCr.
;;   "Constructor for image.YCbCr"
;;   {:added "1.0"
;;    :go "_ConstructYCbCr(_v)"}
;;   [^Object _v])

JOKER TYPE image.YCbCrSubsampleRatio from image/ycbcr.go:
(defn ^"GoObject" YCbCrSubsampleRatio.
  "Constructor for image.YCbCrSubsampleRatio"
  {:added "1.0"
   :go "_ConstructYCbCrSubsampleRatio(_v)"}
  [^Object _v])

JOKER FUNC image.Decode from image/format.go:
;; (defn Decode
;;   "Decode decodes an image that has been encoded in a registered format.\nThe string returned is the format name used during format registration.\nFormat registration is typically done by an init function in the codec-\nspecific package.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (Image, string, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Image String Error]"
;;   {:added "1.0"
;;    :go "__decode(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC image.DecodeConfig from image/format.go:
;; (defn DecodeConfig
;;   "DecodeConfig decodes the color model and dimensions of an image that has\nbeen encoded in a registered format. The string returned is the format name\nused during format registration. Format registration is typically done by\nan init function in the codec-specific package.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (Config, string, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Config String Error]"
;;   {:added "1.0"
;;    :go "__decodeConfig(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC image.NewAlpha from image/image.go:
(defn NewAlpha
  "NewAlpha returns a new Alpha image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *Alpha\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/Alpha)"
  {:added "1.0"
   :go "__newAlpha(*__r)"}
  [^image/Rectangle __r])

JOKER FUNC image.NewAlpha16 from image/image.go:
(defn NewAlpha16
  "NewAlpha16 returns a new Alpha16 image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *Alpha16\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/Alpha16)"
  {:added "1.0"
   :go "__newAlpha16(*__r)"}
  [^image/Rectangle __r])

JOKER FUNC image.NewCMYK from image/image.go:
(defn NewCMYK
  "NewCMYK returns a new CMYK image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *CMYK\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/CMYK)"
  {:added "1.0"
   :go "__newCMYK(*__r)"}
  [^image/Rectangle __r])

JOKER FUNC image.NewGray from image/image.go:
(defn NewGray
  "NewGray returns a new Gray image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *Gray\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/Gray)"
  {:added "1.0"
   :go "__newGray(*__r)"}
  [^image/Rectangle __r])

JOKER FUNC image.NewGray16 from image/image.go:
(defn NewGray16
  "NewGray16 returns a new Gray16 image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *Gray16\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/Gray16)"
  {:added "1.0"
   :go "__newGray16(*__r)"}
  [^image/Rectangle __r])

JOKER FUNC image.NewNRGBA from image/image.go:
(defn NewNRGBA
  "NewNRGBA returns a new NRGBA image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *NRGBA\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/NRGBA)"
  {:added "1.0"
   :go "__newNRGBA(*__r)"}
  [^image/Rectangle __r])

JOKER FUNC image.NewNRGBA64 from image/image.go:
(defn NewNRGBA64
  "NewNRGBA64 returns a new NRGBA64 image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *NRGBA64\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/NRGBA64)"
  {:added "1.0"
   :go "__newNRGBA64(*__r)"}
  [^image/Rectangle __r])

JOKER FUNC image.NewNYCbCrA from image/ycbcr.go:
(defn NewNYCbCrA
  "NewNYCbCrA returns a new NYCbCrA image with the given bounds and subsample\nratio.\n\nGo input arguments: (r Rectangle, subsampleRatio YCbCrSubsampleRatio)\n\nGo return type: *NYCbCrA\n\nJoker input arguments: [^go.std.image/Rectangle r, ^go.std.image/YCbCrSubsampleRatio subsampleRatio]\n\nJoker return type: (atom-of go.std.image/NYCbCrA)"
  {:added "1.0"
   :go "__newNYCbCrA(*__r, *__subsampleRatio)"}
  [^image/Rectangle __r, ^image/YCbCrSubsampleRatio __subsampleRatio])

JOKER FUNC image.NewPaletted from image/image.go:
;; (defn NewPaletted
;;   "NewPaletted returns a new Paletted image with the given width, height and\npalette.\n\nGo input arguments: (r Rectangle, p color.Palette)\n\nGo return type: *Paletted\n\nJoker input arguments: [^go.std.image/Rectangle r, ^go.std.image.color/Palette p]\n\nJoker return type: (atom-of go.std.image/Paletted)"
;;   {:added "1.0"
;;    :go "__newPaletted(*__r, *__p)"}
;;   [^image/Rectangle __r, ^color/Palette __p])

JOKER FUNC image.NewRGBA from image/image.go:
(defn NewRGBA
  "NewRGBA returns a new RGBA image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *RGBA\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/RGBA)"
  {:added "1.0"
   :go "__newRGBA(*__r)"}
  [^image/Rectangle __r])

JOKER FUNC image.NewRGBA64 from image/image.go:
(defn NewRGBA64
  "NewRGBA64 returns a new RGBA64 image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *RGBA64\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/RGBA64)"
  {:added "1.0"
   :go "__newRGBA64(*__r)"}
  [^image/Rectangle __r])

JOKER FUNC image.NewUniform from image/names.go:
;; (defn NewUniform
;;   "Go input arguments: (c color.Color)\n\nGo return type: *Uniform\n\nJoker input arguments: [^go.std.image.color/Color c]\n\nJoker return type: (atom-of go.std.image/Uniform)"
;;   {:added "1.0"
;;    :go "__newUniform(*__c)"}
;;   [^color/Color __c])

JOKER FUNC image.NewYCbCr from image/ycbcr.go:
(defn NewYCbCr
  "NewYCbCr returns a new YCbCr image with the given bounds and subsample\nratio.\n\nGo input arguments: (r Rectangle, subsampleRatio YCbCrSubsampleRatio)\n\nGo return type: *YCbCr\n\nJoker input arguments: [^go.std.image/Rectangle r, ^go.std.image/YCbCrSubsampleRatio subsampleRatio]\n\nJoker return type: (atom-of go.std.image/YCbCr)"
  {:added "1.0"
   :go "__newYCbCr(*__r, *__subsampleRatio)"}
  [^image/Rectangle __r, ^image/YCbCrSubsampleRatio __subsampleRatio])

JOKER FUNC image.Pt from image/geom.go:
(defn Pt
  "Pt is shorthand for Point{X, Y}.\n\nGo input arguments: (X int, Y int)\n\nGo return type: Point\n\nJoker input arguments: [^Int X, ^Int Y]\n\nJoker return type: go.std.image/Point"
  {:added "1.0"
   :go "__pt(__X, __Y)"}
  [^Int __X, ^Int __Y])

JOKER FUNC image.Rect from image/geom.go:
(defn Rect
  "Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}. The returned\nrectangle has minimum and maximum coordinates swapped if necessary so that\nit is well-formed.\n\nGo input arguments: (x0 int, y0 int, x1 int, y1 int)\n\nGo return type: Rectangle\n\nJoker input arguments: [^Int x0, ^Int y0, ^Int x1, ^Int y1]\n\nJoker return type: go.std.image/Rectangle"
  {:added "1.0"
   :go "__rect(__x0, __y0, __x1, __y1)"}
  [^Int __x0, ^Int __y0, ^Int __x1, ^Int __y1])

JOKER FUNC image.RegisterFormat from image/format.go:
;; (defn RegisterFormat
;;   "RegisterFormat registers an image format for use by Decode.\nName is the name of the format, like \"jpeg\" or \"png\".\nMagic is the magic prefix that identifies the format's encoding. The magic\nstring can contain \"?\" wildcards that each match any one byte.\nDecode is the function that decodes the encoded image.\nDecodeConfig is the function that decodes just its configuration.\n\nGo input arguments: (name string, magic string, decode func, decodeConfig func)\n\nJoker input arguments: [^String name, ^String magic, ^fn decode, ^fn decodeConfig]"
;;   {:added "1.0"
;;    :go "__registerFormat(__name, __magic, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String __name, ^String __magic, ^fn __decode, ^fn __decodeConfig])

JOKER TYPE go.std.image/Alpha:
(def
  ^{:doc "Alpha is an in-memory image whose At method returns color.Alpha values.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Alpha"}
  Alpha)

JOKER TYPE go.std.image/Alpha16:
(def
  ^{:doc "Alpha16 is an in-memory image whose At method returns color.Alpha16 values.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Alpha16"}
  Alpha16)

JOKER TYPE go.std.image/CMYK:
(def
  ^{:doc "CMYK is an in-memory image whose At method returns color.CMYK values.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CMYK"}
  CMYK)

JOKER TYPE go.std.image/Config:
(def
  ^{:doc "Config holds an image's color model and dimensions.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Config"}
  Config)

JOKER TYPE go.std.image/Gray:
(def
  ^{:doc "Gray is an in-memory image whose At method returns color.Gray values.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Gray"}
  Gray)

JOKER TYPE go.std.image/Gray16:
(def
  ^{:doc "Gray16 is an in-memory image whose At method returns color.Gray16 values.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Gray16"}
  Gray16)

JOKER TYPE go.std.image/Image:
(def
  ^{:doc "Image is a finite rectangular grid of color.Color values taken from a color\nmodel.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Image"}
  Image)

JOKER TYPE go.std.image/NRGBA:
(def
  ^{:doc "NRGBA is an in-memory image whose At method returns color.NRGBA values.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NRGBA"}
  NRGBA)

JOKER TYPE go.std.image/NRGBA64:
(def
  ^{:doc "NRGBA64 is an in-memory image whose At method returns color.NRGBA64 values.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NRGBA64"}
  NRGBA64)

JOKER TYPE go.std.image/NYCbCrA:
(def
  ^{:doc "NYCbCrA is an in-memory image of non-alpha-premultiplied Y'CbCr-with-alpha\ncolors. A and AStride are analogous to the Y and YStride fields of the\nembedded YCbCr.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NYCbCrA"}
  NYCbCrA)

JOKER TYPE go.std.image/Paletted:
(def
  ^{:doc "Paletted is an in-memory image of uint8 indices into a given palette.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Paletted"}
  Paletted)

JOKER TYPE go.std.image/PalettedImage:
(def
  ^{:doc "PalettedImage is an image whose colors may come from a limited palette.\nIf m is a PalettedImage and m.ColorModel() returns a color.Palette p,\nthen m.At(x, y) should be equivalent to p[m.ColorIndexAt(x, y)]. If m's\ncolor model is not a color.Palette, then ColorIndexAt's behavior is\nundefined.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PalettedImage"}
  PalettedImage)

JOKER TYPE go.std.image/Point:
(def
  ^{:doc "A Point is an X, Y coordinate pair. The axes increase right and down.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Point"}
  Point)

JOKER TYPE go.std.image/RGBA:
(def
  ^{:doc "RGBA is an in-memory image whose At method returns color.RGBA values.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RGBA"}
  RGBA)

JOKER TYPE go.std.image/RGBA64:
(def
  ^{:doc "RGBA64 is an in-memory image whose At method returns color.RGBA64 values.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RGBA64"}
  RGBA64)

JOKER TYPE go.std.image/Rectangle:
(def
  ^{:doc "A Rectangle contains the points with Min.X <= X < Max.X, Min.Y <= Y < Max.Y.\nIt is well-formed if Min.X <= Max.X and likewise for Y. Points are always\nwell-formed. A rectangle's methods always return well-formed outputs for\nwell-formed inputs.\n\nA Rectangle is also an Image whose bounds are the rectangle itself. At\nreturns color.Opaque for points in the rectangle and color.Transparent\notherwise.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Rectangle"}
  Rectangle)

JOKER TYPE go.std.image/Uniform:
(def
  ^{:doc "Uniform is an infinite-sized Image of uniform color.\nIt implements the color.Color, color.Model, and Image interfaces.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Uniform"}
  Uniform)

JOKER TYPE go.std.image/YCbCr:
(def
  ^{:doc "YCbCr is an in-memory image of Y'CbCr colors. There is one Y sample per\npixel, but each Cb and Cr sample can span one or more pixels.\nYStride is the Y slice index delta between vertically adjacent pixels.\nCStride is the Cb and Cr slice index delta between vertically adjacent pixels\nthat map to separate chroma samples.\nIt is not an absolute requirement, but YStride and len(Y) are typically\nmultiples of 8, and:\n\tFor 4:4:4, CStride == YStride/1 && len(Cb) == len(Cr) == len(Y)/1.\n\tFor 4:2:2, CStride == YStride/2 && len(Cb) == len(Cr) == len(Y)/2.\n\tFor 4:2:0, CStride == YStride/2 && len(Cb) == len(Cr) == len(Y)/4.\n\tFor 4:4:0, CStride == YStride/1 && len(Cb) == len(Cr) == len(Y)/2.\n\tFor 4:1:1, CStride == YStride/4 && len(Cb) == len(Cr) == len(Y)/4.\n\tFor 4:1:0, CStride == YStride/4 && len(Cb) == len(Cr) == len(Y)/8.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_YCbCr"}
  YCbCr)

JOKER TYPE go.std.image/YCbCrSubsampleRatio:
(def
  ^{:doc "YCbCrSubsampleRatio is the chroma subsample ratio used in a YCbCr image.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_YCbCrSubsampleRatio"}
  YCbCrSubsampleRatio)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["image"]
    :doc "Provides a low-level interface to the image package.\n\nPackage image implements a basic 2-D image library.\n\nThe fundamental interface is called Image. An Image contains colors, which\nare described in the image/color package.\n\nValues of the Image interface are created either by calling functions such\nas NewRGBA and NewPaletted, or by calling Decode on an io.Reader containing\nimage data in a format such as GIF, JPEG or PNG. Decoding any particular\nimage format requires the prior registration of a decoder function.\nRegistration is typically automatic as a side effect of initializing that\nformat's package so that, to decode a PNG image, it suffices to have\n\timport _ \"image/png\"\nin a program's main package. The _ means to import a package purely for its\ninitialization side effects.\n\nSee \"The Go image package\" for more details:\nhttps://golang.org/doc/articles/image_package.html\n"
    :empty false}
  go.std.image)
JOKER VARIABLE Alpha16Model from image/color/color.go:
(def
  ^{:doc "Models for the standard color types.\n"
    :added "1.0"
    :tag "Var"
    :go "color.Alpha16Model"}
  Alpha16Model)

JOKER VARIABLE AlphaModel from image/color/color.go:
(def
  ^{:doc "Models for the standard color types.\n"
    :added "1.0"
    :tag "Var"
    :go "color.AlphaModel"}
  AlphaModel)

JOKER VARIABLE Black from image/color/color.go:
(def
  ^{:doc "Standard colors.\n"
    :added "1.0"
    :tag "Var"
    :go "color.Black"}
  Black)

JOKER VARIABLE CMYKModel from image/color/ycbcr.go:
(def
  ^{:doc "CMYKModel is the Model for CMYK colors.\n"
    :added "1.0"
    :tag "Var"
    :go "color.CMYKModel"}
  CMYKModel)

JOKER VARIABLE Gray16Model from image/color/color.go:
(def
  ^{:doc "Models for the standard color types.\n"
    :added "1.0"
    :tag "Var"
    :go "color.Gray16Model"}
  Gray16Model)

JOKER VARIABLE GrayModel from image/color/color.go:
(def
  ^{:doc "Models for the standard color types.\n"
    :added "1.0"
    :tag "Var"
    :go "color.GrayModel"}
  GrayModel)

JOKER VARIABLE NRGBA64Model from image/color/color.go:
(def
  ^{:doc "Models for the standard color types.\n"
    :added "1.0"
    :tag "Var"
    :go "color.NRGBA64Model"}
  NRGBA64Model)

JOKER VARIABLE NRGBAModel from image/color/color.go:
(def
  ^{:doc "Models for the standard color types.\n"
    :added "1.0"
    :tag "Var"
    :go "color.NRGBAModel"}
  NRGBAModel)

JOKER VARIABLE NYCbCrAModel from image/color/ycbcr.go:
(def
  ^{:doc "NYCbCrAModel is the Model for non-alpha-premultiplied Y'CbCr-with-alpha\ncolors.\n"
    :added "1.0"
    :tag "Var"
    :go "color.NYCbCrAModel"}
  NYCbCrAModel)

JOKER VARIABLE Opaque from image/color/color.go:
(def
  ^{:doc "Standard colors.\n"
    :added "1.0"
    :tag "Var"
    :go "color.Opaque"}
  Opaque)

JOKER VARIABLE RGBA64Model from image/color/color.go:
(def
  ^{:doc "Models for the standard color types.\n"
    :added "1.0"
    :tag "Var"
    :go "color.RGBA64Model"}
  RGBA64Model)

JOKER VARIABLE RGBAModel from image/color/color.go:
(def
  ^{:doc "Models for the standard color types.\n"
    :added "1.0"
    :tag "Var"
    :go "color.RGBAModel"}
  RGBAModel)

JOKER VARIABLE Transparent from image/color/color.go:
(def
  ^{:doc "Standard colors.\n"
    :added "1.0"
    :tag "Var"
    :go "color.Transparent"}
  Transparent)

JOKER VARIABLE White from image/color/color.go:
(def
  ^{:doc "Standard colors.\n"
    :added "1.0"
    :tag "Var"
    :go "color.White"}
  White)

JOKER VARIABLE YCbCrModel from image/color/ycbcr.go:
(def
  ^{:doc "YCbCrModel is the Model for Y'CbCr colors.\n"
    :added "1.0"
    :tag "Var"
    :go "color.YCbCrModel"}
  YCbCrModel)

JOKER TYPE image/color.Alpha from image/color/color.go:
(defn ^"GoObject" Alpha.
  "Constructor for color.Alpha"
  {:added "1.0"
   :go "_ConstructAlpha(_v)"}
  [^Object _v])

JOKER TYPE image/color.Alpha16 from image/color/color.go:
(defn ^"GoObject" Alpha16.
  "Constructor for color.Alpha16"
  {:added "1.0"
   :go "_ConstructAlpha16(_v)"}
  [^Object _v])

JOKER TYPE image/color.CMYK from image/color/ycbcr.go:
(defn ^"GoObject" CMYK.
  "Constructor for color.CMYK"
  {:added "1.0"
   :go "_ConstructCMYK(_v)"}
  [^Object _v])

JOKER TYPE image/color.Color from image/color/color.go:
;; (defn ^"GoObject" Color.
;;   "Constructor for color.Color"
;;   {:added "1.0"
;;    :go "_ConstructColor(_v)"}
;;   [^Object _v])

JOKER TYPE image/color.Gray from image/color/color.go:
(defn ^"GoObject" Gray.
  "Constructor for color.Gray"
  {:added "1.0"
   :go "_ConstructGray(_v)"}
  [^Object _v])

JOKER TYPE image/color.Gray16 from image/color/color.go:
(defn ^"GoObject" Gray16.
  "Constructor for color.Gray16"
  {:added "1.0"
   :go "_ConstructGray16(_v)"}
  [^Object _v])

JOKER TYPE image/color.Model from image/color/color.go:
;; (defn ^"GoObject" Model.
;;   "Constructor for color.Model"
;;   {:added "1.0"
;;    :go "_ConstructModel(_v)"}
;;   [^Object _v])

JOKER TYPE image/color.NRGBA from image/color/color.go:
(defn ^"GoObject" NRGBA.
  "Constructor for color.NRGBA"
  {:added "1.0"
   :go "_ConstructNRGBA(_v)"}
  [^Object _v])

JOKER TYPE image/color.NRGBA64 from image/color/color.go:
(defn ^"GoObject" NRGBA64.
  "Constructor for color.NRGBA64"
  {:added "1.0"
   :go "_ConstructNRGBA64(_v)"}
  [^Object _v])

JOKER TYPE image/color.NYCbCrA from image/color/ycbcr.go:
(defn ^"GoObject" NYCbCrA.
  "Constructor for color.NYCbCrA"
  {:added "1.0"
   :go "_ConstructNYCbCrA(_v)"}
  [^Object _v])

JOKER TYPE image/color.Palette from image/color/color.go:
;; (defn ^"GoObject" Palette.
;;   "Constructor for color.Palette"
;;   {:added "1.0"
;;    :go "_ConstructPalette(_v)"}
;;   [^Object _v])

JOKER TYPE image/color.RGBA from image/color/color.go:
(defn ^"GoObject" RGBA.
  "Constructor for color.RGBA"
  {:added "1.0"
   :go "_ConstructRGBA(_v)"}
  [^Object _v])

JOKER TYPE image/color.RGBA64 from image/color/color.go:
(defn ^"GoObject" RGBA64.
  "Constructor for color.RGBA64"
  {:added "1.0"
   :go "_ConstructRGBA64(_v)"}
  [^Object _v])

JOKER TYPE image/color.YCbCr from image/color/ycbcr.go:
(defn ^"GoObject" YCbCr.
  "Constructor for color.YCbCr"
  {:added "1.0"
   :go "_ConstructYCbCr(_v)"}
  [^Object _v])

JOKER FUNC image/color.CMYKToRGB from image/color/ycbcr.go:
(defn CMYKToRGB
  "CMYKToRGB converts a CMYK quadruple to an RGB triple.\n\nGo input arguments: (c uint8, m uint8, y uint8, k uint8)\n\nGo return type: (uint8, uint8, uint8)\n\nJoker input arguments: [^Int c, ^Int m, ^Int y, ^Int k]\n\nJoker return type: [Int Int Int]"
  {:added "1.0"
   :go "__cMYKToRGB(__c, __m, __y, __k)"}
  [^UInt8 __c, ^UInt8 __m, ^UInt8 __y, ^UInt8 __k])

JOKER FUNC image/color.ModelFunc from image/color/color.go:
;; (defn ModelFunc
;;   "ModelFunc returns a Model that invokes f to implement the conversion.\n\nGo input arguments: (f func)\n\nGo return type: Model\n\nJoker input arguments: [^fn f]\n\nJoker return type: go.std.image.color/Model"
;;   {:added "1.0"
;;    :go "__modelFunc(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^fn __f])

JOKER FUNC image/color.RGBToCMYK from image/color/ycbcr.go:
(defn RGBToCMYK
  "RGBToCMYK converts an RGB triple to a CMYK quadruple.\n\nGo input arguments: (r uint8, g uint8, b uint8)\n\nGo return type: (uint8, uint8, uint8, uint8)\n\nJoker input arguments: [^Int r, ^Int g, ^Int b]\n\nJoker return type: [Int Int Int Int]"
  {:added "1.0"
   :go "__rGBToCMYK(__r, __g, __b)"}
  [^UInt8 __r, ^UInt8 __g, ^UInt8 __b])

JOKER FUNC image/color.RGBToYCbCr from image/color/ycbcr.go:
(defn RGBToYCbCr
  "RGBToYCbCr converts an RGB triple to a Y'CbCr triple.\n\nGo input arguments: (r uint8, g uint8, b uint8)\n\nGo return type: (uint8, uint8, uint8)\n\nJoker input arguments: [^Int r, ^Int g, ^Int b]\n\nJoker return type: [Int Int Int]"
  {:added "1.0"
   :go "__rGBToYCbCr(__r, __g, __b)"}
  [^UInt8 __r, ^UInt8 __g, ^UInt8 __b])

JOKER FUNC image/color.YCbCrToRGB from image/color/ycbcr.go:
(defn YCbCrToRGB
  "YCbCrToRGB converts a Y'CbCr triple to an RGB triple.\n\nGo input arguments: (y uint8, cb uint8, cr uint8)\n\nGo return type: (uint8, uint8, uint8)\n\nJoker input arguments: [^Int y, ^Int cb, ^Int cr]\n\nJoker return type: [Int Int Int]"
  {:added "1.0"
   :go "__yCbCrToRGB(__y, __cb, __cr)"}
  [^UInt8 __y, ^UInt8 __cb, ^UInt8 __cr])

JOKER TYPE go.std.image.color/Alpha:
(def
  ^{:doc "Alpha represents an 8-bit alpha color.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Alpha"}
  Alpha)

JOKER TYPE go.std.image.color/Alpha16:
(def
  ^{:doc "Alpha16 represents a 16-bit alpha color.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Alpha16"}
  Alpha16)

JOKER TYPE go.std.image.color/CMYK:
(def
  ^{:doc "CMYK represents a fully opaque CMYK color, having 8 bits for each of cyan,\nmagenta, yellow and black.\n\nIt is not associated with any particular color profile.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CMYK"}
  CMYK)

JOKER TYPE go.std.image.color/Color:
(def
  ^{:doc "Color can convert itself to alpha-premultiplied 16-bits per channel RGBA.\nThe conversion may be lossy.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Color"}
  Color)

JOKER TYPE go.std.image.color/Gray:
(def
  ^{:doc "Gray represents an 8-bit grayscale color.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Gray"}
  Gray)

JOKER TYPE go.std.image.color/Gray16:
(def
  ^{:doc "Gray16 represents a 16-bit grayscale color.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Gray16"}
  Gray16)

JOKER TYPE go.std.image.color/Model:
(def
  ^{:doc "Model can convert any Color to one from its own color model. The conversion\nmay be lossy.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Model"}
  Model)

JOKER TYPE go.std.image.color/NRGBA:
(def
  ^{:doc "NRGBA represents a non-alpha-premultiplied 32-bit color.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NRGBA"}
  NRGBA)

JOKER TYPE go.std.image.color/NRGBA64:
(def
  ^{:doc "NRGBA64 represents a non-alpha-premultiplied 64-bit color,\nhaving 16 bits for each of red, green, blue and alpha.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NRGBA64"}
  NRGBA64)

JOKER TYPE go.std.image.color/NYCbCrA:
(def
  ^{:doc "NYCbCrA represents a non-alpha-premultiplied Y'CbCr-with-alpha color, having\n8 bits each for one luma, two chroma and one alpha component.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NYCbCrA"}
  NYCbCrA)

JOKER TYPE go.std.image.color/Palette:
(def
  ^{:doc "Palette is a palette of colors.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Palette"}
  Palette)

JOKER TYPE go.std.image.color/RGBA:
(def
  ^{:doc "RGBA represents a traditional 32-bit alpha-premultiplied color, having 8\nbits for each of red, green, blue and alpha.\n\nAn alpha-premultiplied color component C has been scaled by alpha (A), so\nhas valid values 0 <= C <= A.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RGBA"}
  RGBA)

JOKER TYPE go.std.image.color/RGBA64:
(def
  ^{:doc "RGBA64 represents a 64-bit alpha-premultiplied color, having 16 bits for\neach of red, green, blue and alpha.\n\nAn alpha-premultiplied color component C has been scaled by alpha (A), so\nhas valid values 0 <= C <= A.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RGBA64"}
  RGBA64)

JOKER TYPE go.std.image.color/YCbCr:
(def
  ^{:doc "YCbCr represents a fully opaque 24-bit Y'CbCr color, having 8 bits each for\none luma and two chroma components.\n\nJPEG, VP8, the MPEG family and other codecs use this color model. Such\ncodecs often use the terms YUV and Y'CbCr interchangeably, but strictly\nspeaking, the term YUV applies only to analog video signals, and Y' (luma)\nis Y (luminance) after applying gamma correction.\n\nConversion between RGB and Y'CbCr is lossy and there are multiple, slightly\ndifferent formulae for converting between the two. This package follows\nthe JFIF specification at https://www.w3.org/Graphics/JPEG/jfif3.pdf.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_YCbCr"}
  YCbCr)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["image/color"]
    :doc "Provides a low-level interface to the image/color package.\n\nPackage color implements a basic color library.\n"
    :empty false}
  go.std.image.color)
JOKER VARIABLE Plan9 from image/color/palette/palette.go:
(def
  ^{:doc "Plan9 is a 256-color palette that partitions the 24-bit RGB space\ninto 4×4×4 subdivision, with 4 shades in each subcube. Compared to the\nWebSafe, the idea is to reduce the color resolution by dicing the\ncolor cube into fewer cells, and to use the extra space to increase the\nintensity resolution. This results in 16 gray shades (4 gray subcubes with\n4 samples in each), 13 shades of each primary and secondary color (3\nsubcubes with 4 samples plus black) and a reasonable selection of colors\ncovering the rest of the color cube. The advantage is better representation\nof continuous tones.\n\nThis palette was used in the Plan 9 Operating System, described at\nhttps://9p.io/magic/man2html/6/color\n"
    :added "1.0"
    :tag "Var"
    :go "palette.Plan9"}
  Plan9)

JOKER VARIABLE WebSafe from image/color/palette/palette.go:
(def
  ^{:doc "WebSafe is a 216-color palette that was popularized by early versions\nof Netscape Navigator. It is also known as the Netscape Color Cube.\n\nSee https://en.wikipedia.org/wiki/Web_colors#Web-safe_colors for details.\n"
    :added "1.0"
    :tag "Var"
    :go "palette.WebSafe"}
  WebSafe)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["image/color/palette"]
    :doc "Provides a low-level interface to the image/color/palette package.\n\nPackage palette provides standard color palettes.\n"
    :empty false}
  go.std.image.color.palette)
JOKER CONSTANT Over from image/draw/draw.go:
(def
  ^{:doc "Over specifies ``(src in mask) over dst''.\n"
    :added "1.0"
    :tag "Int"
    :go "int(draw.Over)"}
  Over)

JOKER CONSTANT Src from image/draw/draw.go:
(def
  ^{:doc "Src specifies ``src in mask''.\n"
    :added "1.0"
    :tag "Int"
    :go "int(draw.Src)"}
  Src)

JOKER VARIABLE FloydSteinberg from image/draw/draw.go:
(def
  ^{:doc "FloydSteinberg is a Drawer that is the Src Op with Floyd-Steinberg error\ndiffusion.\n"
    :added "1.0"
    :tag "Var"
    :go "draw.FloydSteinberg"}
  FloydSteinberg)

JOKER TYPE image/draw.Drawer from image/draw/draw.go:
;; (defn ^"GoObject" Drawer.
;;   "Constructor for draw.Drawer"
;;   {:added "1.0"
;;    :go "_ConstructDrawer(_v)"}
;;   [^Object _v])

JOKER TYPE image/draw.Image from image/draw/draw.go:
;; (defn ^"GoObject" Image.
;;   "Constructor for draw.Image"
;;   {:added "1.0"
;;    :go "_ConstructImage(_v)"}
;;   [^Object _v])

JOKER TYPE image/draw.Op from image/draw/draw.go:
(defn ^"GoObject" Op.
  "Constructor for draw.Op"
  {:added "1.0"
   :go "_ConstructOp(_v)"}
  [^Object _v])

JOKER TYPE image/draw.Quantizer from image/draw/draw.go:
;; (defn ^"GoObject" Quantizer.
;;   "Constructor for draw.Quantizer"
;;   {:added "1.0"
;;    :go "_ConstructQuantizer(_v)"}
;;   [^Object _v])

JOKER FUNC image/draw.Draw from image/draw/draw.go:
;; (defn Draw
;;   "Draw calls DrawMask with a nil mask.\n\nGo input arguments: (dst Image, r image.Rectangle, src image.Image, sp image.Point, op Op)\n\nJoker input arguments: [^go.std.image.draw/Image dst, ^go.std.image/Rectangle r, ^go.std.image/Image src, ^go.std.image/Point sp, ^go.std.image.draw/Op op]"
;;   {:added "1.0"
;;    :go "__draw(*__dst, *__r, *__src, *__sp, *__op)"}
;;   [^draw/Image __dst, ^image/Rectangle __r, ^image/Image __src, ^image/Point __sp, ^draw/Op __op])

JOKER FUNC image/draw.DrawMask from image/draw/draw.go:
;; (defn DrawMask
;;   "DrawMask aligns r.Min in dst with sp in src and mp in mask and then replaces the rectangle r\nin dst with the result of a Porter-Duff composition. A nil mask is treated as opaque.\n\nGo input arguments: (dst Image, r image.Rectangle, src image.Image, sp image.Point, mask image.Image, mp image.Point, op Op)\n\nJoker input arguments: [^go.std.image.draw/Image dst, ^go.std.image/Rectangle r, ^go.std.image/Image src, ^go.std.image/Point sp, ^go.std.image/Image mask, ^go.std.image/Point mp, ^go.std.image.draw/Op op]"
;;   {:added "1.0"
;;    :go "__drawMask(*__dst, *__r, *__src, *__sp, *__mask, *__mp, *__op)"}
;;   [^draw/Image __dst, ^image/Rectangle __r, ^image/Image __src, ^image/Point __sp, ^image/Image __mask, ^image/Point __mp, ^draw/Op __op])

JOKER TYPE go.std.image.draw/Drawer:
(def
  ^{:doc "Drawer contains the Draw method.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Drawer"}
  Drawer)

JOKER TYPE go.std.image.draw/Image:
(def
  ^{:doc "Image is an image.Image with a Set method to change a single pixel.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Image"}
  Image)

JOKER TYPE go.std.image.draw/Op:
(def
  ^{:doc "Op is a Porter-Duff compositing operator.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Op"}
  Op)

JOKER TYPE go.std.image.draw/Quantizer:
(def
  ^{:doc "Quantizer produces a palette for an image.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Quantizer"}
  Quantizer)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["image/draw"]
    :doc "Provides a low-level interface to the image/draw package.\n\nPackage draw provides image composition functions.\n\nSee \"The Go image/draw package\" for an introduction to this package:\nhttps://golang.org/doc/articles/image_draw.html\n"
    :empty false}
  go.std.image.draw)
JOKER CONSTANT DisposalBackground from image/gif/reader.go:
(def
  ^{:doc "Disposal Methods.\n"
    :added "1.0"
    :tag "Int"
    :go "gif.DisposalBackground"}
  DisposalBackground)

JOKER CONSTANT DisposalNone from image/gif/reader.go:
(def
  ^{:doc "Disposal Methods.\n"
    :added "1.0"
    :tag "Int"
    :go "gif.DisposalNone"}
  DisposalNone)

JOKER CONSTANT DisposalPrevious from image/gif/reader.go:
(def
  ^{:doc "Disposal Methods.\n"
    :added "1.0"
    :tag "Int"
    :go "gif.DisposalPrevious"}
  DisposalPrevious)

JOKER TYPE image/gif.GIF from image/gif/reader.go:
;; (defn ^"GoObject" GIF.
;;   "Constructor for gif.GIF"
;;   {:added "1.0"
;;    :go "_ConstructGIF(_v)"}
;;   [^Object _v])

JOKER TYPE image/gif.Options from image/gif/writer.go:
;; (defn ^"GoObject" Options.
;;   "Constructor for gif.Options"
;;   {:added "1.0"
;;    :go "_ConstructOptions(_v)"}
;;   [^Object _v])

JOKER FUNC image/gif.Decode from image/gif/reader.go:
;; (defn Decode
;;   "Decode reads a GIF image from r and returns the first embedded\nimage as an image.Image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Image, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Image Error]"
;;   {:added "1.0"
;;    :go "__decode(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC image/gif.DecodeAll from image/gif/reader.go:
;; (defn DecodeAll
;;   "DecodeAll reads a GIF image from r and returns the sequential frames\nand timing information.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (*GIF, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [(atom-of go.std.image.gif/GIF) Error]"
;;   {:added "1.0"
;;    :go "__decodeAll(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC image/gif.DecodeConfig from image/gif/reader.go:
;; (defn DecodeConfig
;;   "DecodeConfig returns the global color model and dimensions of a GIF image\nwithout decoding the entire image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Config, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Config Error]"
;;   {:added "1.0"
;;    :go "__decodeConfig(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC image/gif.Encode from image/gif/writer.go:
;; (defn ^"Error" Encode
;;   "Encode writes the Image m to w in GIF format.\n\nGo input arguments: (w io.Writer, m image.Image, o *Options)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^go.std.image/Image m, ^(atom-of go.std.image.gif/Options) o]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "gif.Encode(*__w, *__m, __o)"}
;;   [^io/Writer __w, ^image/Image __m, ^gif/Options __o])

JOKER FUNC image/gif.EncodeAll from image/gif/writer.go:
;; (defn ^"Error" EncodeAll
;;   "EncodeAll writes the images in g to w in GIF format with the\ngiven loop count and delay between frames.\n\nGo input arguments: (w io.Writer, g *GIF)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^(atom-of go.std.image.gif/GIF) g]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "gif.EncodeAll(*__w, __g)"}
;;   [^io/Writer __w, ^gif/GIF __g])

JOKER TYPE go.std.image.gif/GIF:
(def
  ^{:doc "GIF represents the possibly multiple images stored in a GIF file.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_GIF"}
  GIF)

JOKER TYPE go.std.image.gif/Options:
(def
  ^{:doc "Options are the encoding parameters.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Options"}
  Options)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["image/gif"]
    :doc "Provides a low-level interface to the image/gif package.\n\nPackage gif implements a GIF image decoder and encoder.\n\nThe GIF specification is at https://www.w3.org/Graphics/GIF/spec-gif89a.txt.\n"
    :empty false}
  go.std.image.gif)
JOKER CONSTANT DefaultQuality from image/jpeg/writer.go:
(def
  ^{:doc "DefaultQuality is the default quality encoding parameter.\n"
    :added "1.0"
    :tag "Int"
    :go "jpeg.DefaultQuality"}
  DefaultQuality)

JOKER TYPE image/jpeg.FormatError from image/jpeg/reader.go:
(defn ^"GoObject" FormatError.
  "Constructor for jpeg.FormatError"
  {:added "1.0"
   :go "_ConstructFormatError(_v)"}
  [^Object _v])

JOKER TYPE image/jpeg.Options from image/jpeg/writer.go:
(defn ^"GoObject" Options.
  "Constructor for jpeg.Options"
  {:added "1.0"
   :go "_ConstructOptions(_v)"}
  [^Object _v])

JOKER TYPE image/jpeg.Reader from image/jpeg/reader.go:
;; (defn ^"GoObject" Reader.
;;   "Constructor for jpeg.Reader"
;;   {:added "1.0"
;;    :go "_ConstructReader(_v)"}
;;   [^Object _v])

JOKER TYPE image/jpeg.UnsupportedError from image/jpeg/reader.go:
(defn ^"GoObject" UnsupportedError.
  "Constructor for jpeg.UnsupportedError"
  {:added "1.0"
   :go "_ConstructUnsupportedError(_v)"}
  [^Object _v])

JOKER FUNC image/jpeg.Decode from image/jpeg/reader.go:
;; (defn Decode
;;   "Decode reads a JPEG image from r and returns it as an image.Image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Image, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Image Error]"
;;   {:added "1.0"
;;    :go "__decode(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC image/jpeg.DecodeConfig from image/jpeg/reader.go:
;; (defn DecodeConfig
;;   "DecodeConfig returns the color model and dimensions of a JPEG image without\ndecoding the entire image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Config, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Config Error]"
;;   {:added "1.0"
;;    :go "__decodeConfig(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC image/jpeg.Encode from image/jpeg/writer.go:
;; (defn ^"Error" Encode
;;   "Encode writes the Image m to w in JPEG 4:2:0 baseline format with the given\noptions. Default parameters are used if a nil *Options is passed.\n\nGo input arguments: (w io.Writer, m image.Image, o *Options)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^go.std.image/Image m, ^(atom-of go.std.image.jpeg/Options) o]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "jpeg.Encode(*__w, *__m, __o)"}
;;   [^io/Writer __w, ^image/Image __m, ^jpeg/Options __o])

JOKER TYPE go.std.image.jpeg/FormatError:
(def
  ^{:doc "A FormatError reports that the input is not a valid JPEG.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FormatError"}
  FormatError)

JOKER TYPE go.std.image.jpeg/Options:
(def
  ^{:doc "Options are the encoding parameters.\nQuality ranges from 1 to 100 inclusive, higher is better.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Options"}
  Options)

JOKER TYPE go.std.image.jpeg/Reader:
(def
  ^{:doc "Deprecated: Reader is not used by the image/jpeg package and should\nnot be used by others. It is kept for compatibility.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Reader"}
  Reader)

JOKER TYPE go.std.image.jpeg/UnsupportedError:
(def
  ^{:doc "An UnsupportedError reports that the input uses a valid but unimplemented JPEG feature.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnsupportedError"}
  UnsupportedError)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["image/jpeg"]
    :doc "Provides a low-level interface to the image/jpeg package.\n\nPackage jpeg implements a JPEG image decoder and encoder.\n\nJPEG is defined in ITU-T T.81: https://www.w3.org/Graphics/JPEG/itu-t81.pdf.\n"
    :empty false}
  go.std.image.jpeg)
JOKER CONSTANT BestCompression from image/png/writer.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(png.BestCompression)"}
  BestCompression)

JOKER CONSTANT BestSpeed from image/png/writer.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(png.BestSpeed)"}
  BestSpeed)

JOKER CONSTANT DefaultCompression from image/png/writer.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(png.DefaultCompression)"}
  DefaultCompression)

JOKER CONSTANT NoCompression from image/png/writer.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(png.NoCompression)"}
  NoCompression)

JOKER TYPE image/png.CompressionLevel from image/png/writer.go:
(defn ^"GoObject" CompressionLevel.
  "Constructor for png.CompressionLevel"
  {:added "1.0"
   :go "_ConstructCompressionLevel(_v)"}
  [^Object _v])

JOKER TYPE image/png.Encoder from image/png/writer.go:
;; (defn ^"GoObject" Encoder.
;;   "Constructor for png.Encoder"
;;   {:added "1.0"
;;    :go "_ConstructEncoder(_v)"}
;;   [^Object _v])

JOKER TYPE image/png.EncoderBuffer from image/png/writer.go:
;; (defn ^"GoObject" EncoderBuffer.
;;   "Constructor for png.EncoderBuffer"
;;   {:added "1.0"
;;    :go "_ConstructEncoderBuffer(_v)"}
;;   [^Object _v])

JOKER TYPE image/png.EncoderBufferPool from image/png/writer.go:
;; (defn ^"GoObject" EncoderBufferPool.
;;   "Constructor for png.EncoderBufferPool"
;;   {:added "1.0"
;;    :go "_ConstructEncoderBufferPool(_v)"}
;;   [^Object _v])

JOKER TYPE image/png.FormatError from image/png/reader.go:
(defn ^"GoObject" FormatError.
  "Constructor for png.FormatError"
  {:added "1.0"
   :go "_ConstructFormatError(_v)"}
  [^Object _v])

JOKER TYPE image/png.UnsupportedError from image/png/reader.go:
(defn ^"GoObject" UnsupportedError.
  "Constructor for png.UnsupportedError"
  {:added "1.0"
   :go "_ConstructUnsupportedError(_v)"}
  [^Object _v])

JOKER FUNC image/png.Decode from image/png/reader.go:
;; (defn Decode
;;   "Decode reads a PNG image from r and returns it as an image.Image.\nThe type of Image returned depends on the PNG contents.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Image, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Image Error]"
;;   {:added "1.0"
;;    :go "__decode(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC image/png.DecodeConfig from image/png/reader.go:
;; (defn DecodeConfig
;;   "DecodeConfig returns the color model and dimensions of a PNG image without\ndecoding the entire image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Config, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Config Error]"
;;   {:added "1.0"
;;    :go "__decodeConfig(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC image/png.Encode from image/png/writer.go:
;; (defn ^"Error" Encode
;;   "Encode writes the Image m to w in PNG format. Any Image may be\nencoded, but images that are not image.NRGBA might be encoded lossily.\n\nGo input arguments: (w io.Writer, m image.Image)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^go.std.image/Image m]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "png.Encode(*__w, *__m)"}
;;   [^io/Writer __w, ^image/Image __m])

JOKER TYPE go.std.image.png/CompressionLevel:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_CompressionLevel"}
  CompressionLevel)

JOKER TYPE go.std.image.png/Encoder:
(def
  ^{:doc "Encoder configures encoding PNG images.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Encoder"}
  Encoder)

JOKER TYPE go.std.image.png/EncoderBuffer:
(def
  ^{:doc "EncoderBuffer holds the buffers used for encoding PNG images.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_EncoderBuffer"}
  EncoderBuffer)

JOKER TYPE go.std.image.png/EncoderBufferPool:
(def
  ^{:doc "EncoderBufferPool is an interface for getting and returning temporary\ninstances of the EncoderBuffer struct. This can be used to reuse buffers\nwhen encoding multiple images.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_EncoderBufferPool"}
  EncoderBufferPool)

JOKER TYPE go.std.image.png/FormatError:
(def
  ^{:doc "A FormatError reports that the input is not a valid PNG.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FormatError"}
  FormatError)

JOKER TYPE go.std.image.png/UnsupportedError:
(def
  ^{:doc "An UnsupportedError reports that the input uses a valid but unimplemented PNG feature.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnsupportedError"}
  UnsupportedError)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["image/png"]
    :doc "Provides a low-level interface to the image/png package.\n\nPackage png implements a PNG image decoder and encoder.\n\nThe PNG specification is at https://www.w3.org/TR/PNG/.\n"
    :empty false}
  go.std.image.png)
JOKER TYPE index/suffixarray.Index from index/suffixarray/suffixarray.go:
(defn ^"GoObject" Index.
  "Constructor for suffixarray.Index"
  {:added "1.0"
   :go "_ConstructIndex(_v)"}
  [^Object _v])

JOKER FUNC index/suffixarray.New from index/suffixarray/suffixarray.go:
;; (defn New
;;   "New creates a new Index for data.\nIndex creation time is O(N*log(N)) for N = len(data).\n\nGo input arguments: (data []byte)\n\nGo return type: *Index\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: (atom-of go.std.index.suffixarray/Index)"
;;   {:added "1.0"
;;    :go "__new(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)))"}
;;   [^Object __data])

JOKER TYPE go.std.index.suffixarray/Index:
(def
  ^{:doc "Index implements a suffix array for fast substring search.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Index"}
  Index)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the index/suffixarray package.\n\nPackage suffixarray implements substring search in logarithmic time using\nan in-memory suffix array.\n\nExample use:\n\n\t// create index for some data\n\tindex := suffixarray.New(data)\n\n\t// lookup byte slice s\n\toffsets1 := index.Lookup(s, -1) // the list of all indices where s occurs in data\n\toffsets2 := index.Lookup(s, 3)  // the list of at most 3 indices where s occurs in data\n"
    :empty false}
  go.std.index.suffixarray)
JOKER CONSTANT SeekCurrent from io/io.go:
(def
  ^{:doc "seek relative to the current offset\n"
    :added "1.0"
    :tag "Int"
    :go "io.SeekCurrent"}
  SeekCurrent)

JOKER CONSTANT SeekEnd from io/io.go:
(def
  ^{:doc "seek relative to the end\n"
    :added "1.0"
    :tag "Int"
    :go "io.SeekEnd"}
  SeekEnd)

JOKER CONSTANT SeekStart from io/io.go:
(def
  ^{:doc "seek relative to the origin of the file\n"
    :added "1.0"
    :tag "Int"
    :go "io.SeekStart"}
  SeekStart)

JOKER VARIABLE EOF from io/io.go:
(def
  ^{:doc "EOF is the error returned by Read when no more input is available.\nFunctions should return EOF only to signal a graceful end of input.\nIf the EOF occurs unexpectedly in a structured data stream,\nthe appropriate error is either ErrUnexpectedEOF or some other error\ngiving more detail.\n"
    :added "1.0"
    :tag "Var"
    :go "io.EOF"}
  EOF)

JOKER VARIABLE ErrClosedPipe from io/pipe.go:
(def
  ^{:doc "ErrClosedPipe is the error used for read or write operations on a closed pipe.\n"
    :added "1.0"
    :tag "Var"
    :go "io.ErrClosedPipe"}
  ErrClosedPipe)

JOKER VARIABLE ErrNoProgress from io/io.go:
(def
  ^{:doc "ErrNoProgress is returned by some clients of an io.Reader when\nmany calls to Read have failed to return any data or error,\nusually the sign of a broken io.Reader implementation.\n"
    :added "1.0"
    :tag "Var"
    :go "io.ErrNoProgress"}
  ErrNoProgress)

JOKER VARIABLE ErrShortBuffer from io/io.go:
(def
  ^{:doc "ErrShortBuffer means that a read required a longer buffer than was provided.\n"
    :added "1.0"
    :tag "Var"
    :go "io.ErrShortBuffer"}
  ErrShortBuffer)

JOKER VARIABLE ErrShortWrite from io/io.go:
(def
  ^{:doc "ErrShortWrite means that a write accepted fewer bytes than requested\nbut failed to return an explicit error.\n"
    :added "1.0"
    :tag "Var"
    :go "io.ErrShortWrite"}
  ErrShortWrite)

JOKER VARIABLE ErrUnexpectedEOF from io/io.go:
(def
  ^{:doc "ErrUnexpectedEOF means that EOF was encountered in the\nmiddle of reading a fixed-size block or data structure.\n"
    :added "1.0"
    :tag "Var"
    :go "io.ErrUnexpectedEOF"}
  ErrUnexpectedEOF)

JOKER TYPE io.ByteReader from io/io.go:
;; (defn ^"GoObject" ByteReader.
;;   "Constructor for io.ByteReader"
;;   {:added "1.0"
;;    :go "_ConstructByteReader(_v)"}
;;   [^Object _v])

JOKER TYPE io.ByteScanner from io/io.go:
;; (defn ^"GoObject" ByteScanner.
;;   "Constructor for io.ByteScanner"
;;   {:added "1.0"
;;    :go "_ConstructByteScanner(_v)"}
;;   [^Object _v])

JOKER TYPE io.ByteWriter from io/io.go:
;; (defn ^"GoObject" ByteWriter.
;;   "Constructor for io.ByteWriter"
;;   {:added "1.0"
;;    :go "_ConstructByteWriter(_v)"}
;;   [^Object _v])

JOKER TYPE io.Closer from io/io.go:
;; (defn ^"GoObject" Closer.
;;   "Constructor for io.Closer"
;;   {:added "1.0"
;;    :go "_ConstructCloser(_v)"}
;;   [^Object _v])

JOKER TYPE io.LimitedReader from io/io.go:
;; (defn ^"GoObject" LimitedReader.
;;   "Constructor for io.LimitedReader"
;;   {:added "1.0"
;;    :go "_ConstructLimitedReader(_v)"}
;;   [^Object _v])

JOKER TYPE io.PipeReader from io/pipe.go:
(defn ^"GoObject" PipeReader.
  "Constructor for io.PipeReader"
  {:added "1.0"
   :go "_ConstructPipeReader(_v)"}
  [^Object _v])

JOKER TYPE io.PipeWriter from io/pipe.go:
(defn ^"GoObject" PipeWriter.
  "Constructor for io.PipeWriter"
  {:added "1.0"
   :go "_ConstructPipeWriter(_v)"}
  [^Object _v])

JOKER TYPE io.ReadCloser from io/io.go:
;; (defn ^"GoObject" ReadCloser.
;;   "Constructor for io.ReadCloser"
;;   {:added "1.0"
;;    :go "_ConstructReadCloser(_v)"}
;;   [^Object _v])

JOKER TYPE io.ReadSeeker from io/io.go:
;; (defn ^"GoObject" ReadSeeker.
;;   "Constructor for io.ReadSeeker"
;;   {:added "1.0"
;;    :go "_ConstructReadSeeker(_v)"}
;;   [^Object _v])

JOKER TYPE io.ReadWriteCloser from io/io.go:
;; (defn ^"GoObject" ReadWriteCloser.
;;   "Constructor for io.ReadWriteCloser"
;;   {:added "1.0"
;;    :go "_ConstructReadWriteCloser(_v)"}
;;   [^Object _v])

JOKER TYPE io.ReadWriteSeeker from io/io.go:
;; (defn ^"GoObject" ReadWriteSeeker.
;;   "Constructor for io.ReadWriteSeeker"
;;   {:added "1.0"
;;    :go "_ConstructReadWriteSeeker(_v)"}
;;   [^Object _v])

JOKER TYPE io.ReadWriter from io/io.go:
;; (defn ^"GoObject" ReadWriter.
;;   "Constructor for io.ReadWriter"
;;   {:added "1.0"
;;    :go "_ConstructReadWriter(_v)"}
;;   [^Object _v])

JOKER TYPE io.Reader from io/io.go:
;; (defn ^"GoObject" Reader.
;;   "Constructor for io.Reader"
;;   {:added "1.0"
;;    :go "_ConstructReader(_v)"}
;;   [^Object _v])

JOKER TYPE io.ReaderAt from io/io.go:
;; (defn ^"GoObject" ReaderAt.
;;   "Constructor for io.ReaderAt"
;;   {:added "1.0"
;;    :go "_ConstructReaderAt(_v)"}
;;   [^Object _v])

JOKER TYPE io.ReaderFrom from io/io.go:
;; (defn ^"GoObject" ReaderFrom.
;;   "Constructor for io.ReaderFrom"
;;   {:added "1.0"
;;    :go "_ConstructReaderFrom(_v)"}
;;   [^Object _v])

JOKER TYPE io.RuneReader from io/io.go:
;; (defn ^"GoObject" RuneReader.
;;   "Constructor for io.RuneReader"
;;   {:added "1.0"
;;    :go "_ConstructRuneReader(_v)"}
;;   [^Object _v])

JOKER TYPE io.RuneScanner from io/io.go:
;; (defn ^"GoObject" RuneScanner.
;;   "Constructor for io.RuneScanner"
;;   {:added "1.0"
;;    :go "_ConstructRuneScanner(_v)"}
;;   [^Object _v])

JOKER TYPE io.SectionReader from io/io.go:
(defn ^"GoObject" SectionReader.
  "Constructor for io.SectionReader"
  {:added "1.0"
   :go "_ConstructSectionReader(_v)"}
  [^Object _v])

JOKER TYPE io.Seeker from io/io.go:
;; (defn ^"GoObject" Seeker.
;;   "Constructor for io.Seeker"
;;   {:added "1.0"
;;    :go "_ConstructSeeker(_v)"}
;;   [^Object _v])

JOKER TYPE io.StringWriter from io/io.go:
;; (defn ^"GoObject" StringWriter.
;;   "Constructor for io.StringWriter"
;;   {:added "1.0"
;;    :go "_ConstructStringWriter(_v)"}
;;   [^Object _v])

JOKER TYPE io.WriteCloser from io/io.go:
;; (defn ^"GoObject" WriteCloser.
;;   "Constructor for io.WriteCloser"
;;   {:added "1.0"
;;    :go "_ConstructWriteCloser(_v)"}
;;   [^Object _v])

JOKER TYPE io.WriteSeeker from io/io.go:
;; (defn ^"GoObject" WriteSeeker.
;;   "Constructor for io.WriteSeeker"
;;   {:added "1.0"
;;    :go "_ConstructWriteSeeker(_v)"}
;;   [^Object _v])

JOKER TYPE io.Writer from io/io.go:
;; (defn ^"GoObject" Writer.
;;   "Constructor for io.Writer"
;;   {:added "1.0"
;;    :go "_ConstructWriter(_v)"}
;;   [^Object _v])

JOKER TYPE io.WriterAt from io/io.go:
;; (defn ^"GoObject" WriterAt.
;;   "Constructor for io.WriterAt"
;;   {:added "1.0"
;;    :go "_ConstructWriterAt(_v)"}
;;   [^Object _v])

JOKER TYPE io.WriterTo from io/io.go:
;; (defn ^"GoObject" WriterTo.
;;   "Constructor for io.WriterTo"
;;   {:added "1.0"
;;    :go "_ConstructWriterTo(_v)"}
;;   [^Object _v])

JOKER FUNC io.Copy from io/io.go:
(defn Copy
  "Copy copies from src to dst until either EOF is reached\non src or an error occurs. It returns the number of bytes\ncopied and the first error encountered while copying, if any.\n\nA successful Copy returns err == nil, not err == EOF.\nBecause Copy is defined to read from src until EOF, it does\nnot treat an EOF from Read as an error to be reported.\n\nIf src implements the WriterTo interface,\nthe copy is implemented by calling src.WriteTo(dst).\nOtherwise, if dst implements the ReaderFrom interface,\nthe copy is implemented by calling dst.ReadFrom(src).\n\nGo input arguments: (dst Writer, src Reader)\n\nGo return type: (written int64, err error)\n\nJoker input arguments: [^go.std.io/Writer dst, ^go.std.io/Reader src]\n\nJoker return type: [Number Error]"
  {:added "1.0"
   :go "__copy(*__dst, *__src)"}
  [^io/Writer __dst, ^io/Reader __src])

JOKER FUNC io.CopyBuffer from io/io.go:
;; (defn CopyBuffer
;;   "CopyBuffer is identical to Copy except that it stages through the\nprovided buffer (if one is required) rather than allocating a\ntemporary one. If buf is nil, one is allocated; otherwise if it has\nzero length, CopyBuffer panics.\n\nGo input arguments: (dst Writer, src Reader, buf []byte)\n\nGo return type: (written int64, err error)\n\nJoker input arguments: [^go.std.io/Writer dst, ^go.std.io/Reader src, ^(vector-of Int) buf]\n\nJoker return type: [Number Error]"
;;   {:added "1.0"
;;    :go "__copyBuffer(*__dst, *__src, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__buf)))"}
;;   [^io/Writer __dst, ^io/Reader __src, ^Object __buf])

JOKER FUNC io.CopyN from io/io.go:
(defn CopyN
  "CopyN copies n bytes (or until an error) from src to dst.\nIt returns the number of bytes copied and the earliest\nerror encountered while copying.\nOn return, written == n if and only if err == nil.\n\nIf dst implements the ReaderFrom interface,\nthe copy is implemented using it.\n\nGo input arguments: (dst Writer, src Reader, n int64)\n\nGo return type: (written int64, err error)\n\nJoker input arguments: [^go.std.io/Writer dst, ^go.std.io/Reader src, ^Number n]\n\nJoker return type: [Number Error]"
  {:added "1.0"
   :go "__copyN(*__dst, *__src, __n)"}
  [^io/Writer __dst, ^io/Reader __src, ^Int64 __n])

JOKER FUNC io.LimitReader from io/io.go:
(defn LimitReader
  "LimitReader returns a Reader that reads from r\nbut stops with EOF after n bytes.\nThe underlying implementation is a *LimitedReader.\n\nGo input arguments: (r Reader, n int64)\n\nGo return type: Reader\n\nJoker input arguments: [^go.std.io/Reader r, ^Number n]\n\nJoker return type: go.std.io/Reader"
  {:added "1.0"
   :go "__limitReader(*__r, __n)"}
  [^io/Reader __r, ^Int64 __n])

JOKER FUNC io.MultiReader from io/multi.go:
;; (defn MultiReader
;;   "MultiReader returns a Reader that's the logical concatenation of\nthe provided input readers. They're read sequentially. Once all\ninputs have returned EOF, Read will return EOF.  If any of the readers\nreturn a non-nil, non-EOF error, Read will return that error.\n\nGo input arguments: (readers ...Reader)\n\nGo return type: Reader\n\nJoker input arguments: [^(ellipsis-somehow io/Reader) readers]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__multiReader(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHa_io.Reader(*__readers)))"}
;;   [^io/Reader __readers])

JOKER FUNC io.MultiWriter from io/multi.go:
;; (defn MultiWriter
;;   "MultiWriter creates a writer that duplicates its writes to all the\nprovided writers, similar to the Unix tee(1) command.\n\nEach write is written to each listed writer, one at a time.\nIf a listed writer returns an error, that overall write operation\nstops and returns the error; it does not continue down the list.\n\nGo input arguments: (writers ...Writer)\n\nGo return type: Writer\n\nJoker input arguments: [^(ellipsis-somehow io/Writer) writers]\n\nJoker return type: go.std.io/Writer"
;;   {:added "1.0"
;;    :go "__multiWriter(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHa_io.Writer(*__writers)))"}
;;   [^io/Writer __writers])

JOKER FUNC io.NewSectionReader from io/io.go:
(defn NewSectionReader
  "NewSectionReader returns a SectionReader that reads from r\nstarting at offset off and stops with EOF after n bytes.\n\nGo input arguments: (r ReaderAt, off int64, n int64)\n\nGo return type: *SectionReader\n\nJoker input arguments: [^go.std.io/ReaderAt r, ^Number off, ^Number n]\n\nJoker return type: (atom-of go.std.io/SectionReader)"
  {:added "1.0"
   :go "__newSectionReader(*__r, __off, __n)"}
  [^io/ReaderAt __r, ^Int64 __off, ^Int64 __n])

JOKER FUNC io.Pipe from io/pipe.go:
(defn Pipe
  "Pipe creates a synchronous in-memory pipe.\nIt can be used to connect code expecting an io.Reader\nwith code expecting an io.Writer.\n\nReads and Writes on the pipe are matched one to one\nexcept when multiple Reads are needed to consume a single Write.\nThat is, each Write to the PipeWriter blocks until it has satisfied\none or more Reads from the PipeReader that fully consume\nthe written data.\nThe data is copied directly from the Write to the corresponding\nRead (or Reads); there is no internal buffering.\n\nIt is safe to call Read and Write in parallel with each other or with Close.\nParallel calls to Read and parallel calls to Write are also safe:\nthe individual calls will be gated sequentially.\n\nGo return type: (*PipeReader, *PipeWriter)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.io/PipeReader) (atom-of go.std.io/PipeWriter)]"
  {:added "1.0"
   :go "__pipe()"}
  [])

JOKER FUNC io.ReadAtLeast from io/io.go:
;; (defn ReadAtLeast
;;   "ReadAtLeast reads from r into buf until it has read at least min bytes.\nIt returns the number of bytes copied and an error if fewer bytes were read.\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading fewer than min bytes,\nReadAtLeast returns ErrUnexpectedEOF.\nIf min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer.\nOn return, n >= min if and only if err == nil.\nIf r returns an error having read at least min bytes, the error is dropped.\n\nGo input arguments: (r Reader, buf []byte, min int)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Reader r, ^(vector-of Int) buf, ^Int min]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__readAtLeast(*__r, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__buf)), __min)"}
;;   [^io/Reader __r, ^Object __buf, ^Int __min])

JOKER FUNC io.ReadFull from io/io.go:
;; (defn ReadFull
;;   "ReadFull reads exactly len(buf) bytes from r into buf.\nIt returns the number of bytes copied and an error if fewer bytes were read.\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading some but not all the bytes,\nReadFull returns ErrUnexpectedEOF.\nOn return, n == len(buf) if and only if err == nil.\nIf r returns an error having read at least len(buf) bytes, the error is dropped.\n\nGo input arguments: (r Reader, buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Reader r, ^(vector-of Int) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__readFull(*__r, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__buf)))"}
;;   [^io/Reader __r, ^Object __buf])

JOKER FUNC io.TeeReader from io/io.go:
(defn TeeReader
  "TeeReader returns a Reader that writes to w what it reads from r.\nAll reads from r performed through it are matched with\ncorresponding writes to w. There is no internal buffering -\nthe write must complete before the read completes.\nAny error encountered while writing is reported as a read error.\n\nGo input arguments: (r Reader, w Writer)\n\nGo return type: Reader\n\nJoker input arguments: [^go.std.io/Reader r, ^go.std.io/Writer w]\n\nJoker return type: go.std.io/Reader"
  {:added "1.0"
   :go "__teeReader(*__r, *__w)"}
  [^io/Reader __r, ^io/Writer __w])

JOKER FUNC io.WriteString from io/io.go:
(defn WriteString
  "WriteString writes the contents of the string s to w, which accepts a slice of bytes.\nIf w implements StringWriter, its WriteString method is invoked directly.\nOtherwise, w.Write is called exactly once.\n\nGo input arguments: (w Writer, s string)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Writer w, ^String s]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__writeString(*__w, __s)"}
  [^io/Writer __w, ^String __s])

JOKER TYPE go.std.io/ByteReader:
(def
  ^{:doc "ByteReader is the interface that wraps the ReadByte method.\n\nReadByte reads and returns the next byte from the input or\nany error encountered. If ReadByte returns an error, no input\nbyte was consumed, and the returned byte value is undefined.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ByteReader"}
  ByteReader)

JOKER TYPE go.std.io/ByteScanner:
(def
  ^{:doc "ByteScanner is the interface that adds the UnreadByte method to the\nbasic ReadByte method.\n\nUnreadByte causes the next call to ReadByte to return the same byte\nas the previous call to ReadByte.\nIt may be an error to call UnreadByte twice without an intervening\ncall to ReadByte.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ByteScanner"}
  ByteScanner)

JOKER TYPE go.std.io/ByteWriter:
(def
  ^{:doc "ByteWriter is the interface that wraps the WriteByte method.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ByteWriter"}
  ByteWriter)

JOKER TYPE go.std.io/Closer:
(def
  ^{:doc "Closer is the interface that wraps the basic Close method.\n\nThe behavior of Close after the first call is undefined.\nSpecific implementations may document their own behavior.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Closer"}
  Closer)

JOKER TYPE go.std.io/LimitedReader:
(def
  ^{:doc "A LimitedReader reads from R but limits the amount of\ndata returned to just N bytes. Each call to Read\nupdates N to reflect the new amount remaining.\nRead returns EOF when N <= 0 or when the underlying R returns EOF.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_LimitedReader"}
  LimitedReader)

JOKER TYPE go.std.io/PipeReader:
(def
  ^{:doc "A PipeReader is the read half of a pipe.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PipeReader"}
  PipeReader)

JOKER TYPE go.std.io/PipeWriter:
(def
  ^{:doc "A PipeWriter is the write half of a pipe.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PipeWriter"}
  PipeWriter)

JOKER TYPE go.std.io/ReadCloser:
(def
  ^{:doc "ReadCloser is the interface that groups the basic Read and Close methods.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ReadCloser"}
  ReadCloser)

JOKER TYPE go.std.io/ReadSeeker:
(def
  ^{:doc "ReadSeeker is the interface that groups the basic Read and Seek methods.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ReadSeeker"}
  ReadSeeker)

JOKER TYPE go.std.io/ReadWriteCloser:
(def
  ^{:doc "ReadWriteCloser is the interface that groups the basic Read, Write and Close methods.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ReadWriteCloser"}
  ReadWriteCloser)

JOKER TYPE go.std.io/ReadWriteSeeker:
(def
  ^{:doc "ReadWriteSeeker is the interface that groups the basic Read, Write and Seek methods.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ReadWriteSeeker"}
  ReadWriteSeeker)

JOKER TYPE go.std.io/ReadWriter:
(def
  ^{:doc "ReadWriter is the interface that groups the basic Read and Write methods.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ReadWriter"}
  ReadWriter)

JOKER TYPE go.std.io/Reader:
(def
  ^{:doc "Reader is the interface that wraps the basic Read method.\n\nRead reads up to len(p) bytes into p. It returns the number of bytes\nread (0 <= n <= len(p)) and any error encountered. Even if Read\nreturns n < len(p), it may use all of p as scratch space during the call.\nIf some data is available but not len(p) bytes, Read conventionally\nreturns what is available instead of waiting for more.\n\nWhen Read encounters an error or end-of-file condition after\nsuccessfully reading n > 0 bytes, it returns the number of\nbytes read. It may return the (non-nil) error from the same call\nor return the error (and n == 0) from a subsequent call.\nAn instance of this general case is that a Reader returning\na non-zero number of bytes at the end of the input stream may\nreturn either err == EOF or err == nil. The next Read should\nreturn 0, EOF.\n\nCallers should always process the n > 0 bytes returned before\nconsidering the error err. Doing so correctly handles I/O errors\nthat happen after reading some bytes and also both of the\nallowed EOF behaviors.\n\nImplementations of Read are discouraged from returning a\nzero byte count with a nil error, except when len(p) == 0.\nCallers should treat a return of 0 and nil as indicating that\nnothing happened; in particular it does not indicate EOF.\n\nImplementations must not retain p.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Reader"}
  Reader)

JOKER TYPE go.std.io/ReaderAt:
(def
  ^{:doc "ReaderAt is the interface that wraps the basic ReadAt method.\n\nReadAt reads len(p) bytes into p starting at offset off in the\nunderlying input source. It returns the number of bytes\nread (0 <= n <= len(p)) and any error encountered.\n\nWhen ReadAt returns n < len(p), it returns a non-nil error\nexplaining why more bytes were not returned. In this respect,\nReadAt is stricter than Read.\n\nEven if ReadAt returns n < len(p), it may use all of p as scratch\nspace during the call. If some data is available but not len(p) bytes,\nReadAt blocks until either all the data is available or an error occurs.\nIn this respect ReadAt is different from Read.\n\nIf the n = len(p) bytes returned by ReadAt are at the end of the\ninput source, ReadAt may return either err == EOF or err == nil.\n\nIf ReadAt is reading from an input source with a seek offset,\nReadAt should not affect nor be affected by the underlying\nseek offset.\n\nClients of ReadAt can execute parallel ReadAt calls on the\nsame input source.\n\nImplementations must not retain p.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ReaderAt"}
  ReaderAt)

JOKER TYPE go.std.io/ReaderFrom:
(def
  ^{:doc "ReaderFrom is the interface that wraps the ReadFrom method.\n\nReadFrom reads data from r until EOF or error.\nThe return value n is the number of bytes read.\nAny error except io.EOF encountered during the read is also returned.\n\nThe Copy function uses ReaderFrom if available.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ReaderFrom"}
  ReaderFrom)

JOKER TYPE go.std.io/RuneReader:
(def
  ^{:doc "RuneReader is the interface that wraps the ReadRune method.\n\nReadRune reads a single UTF-8 encoded Unicode character\nand returns the rune and its size in bytes. If no character is\navailable, err will be set.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RuneReader"}
  RuneReader)

JOKER TYPE go.std.io/RuneScanner:
(def
  ^{:doc "RuneScanner is the interface that adds the UnreadRune method to the\nbasic ReadRune method.\n\nUnreadRune causes the next call to ReadRune to return the same rune\nas the previous call to ReadRune.\nIt may be an error to call UnreadRune twice without an intervening\ncall to ReadRune.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RuneScanner"}
  RuneScanner)

JOKER TYPE go.std.io/SectionReader:
(def
  ^{:doc "SectionReader implements Read, Seek, and ReadAt on a section\nof an underlying ReaderAt.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SectionReader"}
  SectionReader)

JOKER TYPE go.std.io/Seeker:
(def
  ^{:doc "Seeker is the interface that wraps the basic Seek method.\n\nSeek sets the offset for the next Read or Write to offset,\ninterpreted according to whence:\nSeekStart means relative to the start of the file,\nSeekCurrent means relative to the current offset, and\nSeekEnd means relative to the end.\nSeek returns the new offset relative to the start of the\nfile and an error, if any.\n\nSeeking to an offset before the start of the file is an error.\nSeeking to any positive offset is legal, but the behavior of subsequent\nI/O operations on the underlying object is implementation-dependent.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Seeker"}
  Seeker)

JOKER TYPE go.std.io/StringWriter:
(def
  ^{:doc "StringWriter is the interface that wraps the WriteString method.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_StringWriter"}
  StringWriter)

JOKER TYPE go.std.io/WriteCloser:
(def
  ^{:doc "WriteCloser is the interface that groups the basic Write and Close methods.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_WriteCloser"}
  WriteCloser)

JOKER TYPE go.std.io/WriteSeeker:
(def
  ^{:doc "WriteSeeker is the interface that groups the basic Write and Seek methods.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_WriteSeeker"}
  WriteSeeker)

JOKER TYPE go.std.io/Writer:
(def
  ^{:doc "Writer is the interface that wraps the basic Write method.\n\nWrite writes len(p) bytes from p to the underlying data stream.\nIt returns the number of bytes written from p (0 <= n <= len(p))\nand any error encountered that caused the write to stop early.\nWrite must return a non-nil error if it returns n < len(p).\nWrite must not modify the slice data, even temporarily.\n\nImplementations must not retain p.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Writer"}
  Writer)

JOKER TYPE go.std.io/WriterAt:
(def
  ^{:doc "WriterAt is the interface that wraps the basic WriteAt method.\n\nWriteAt writes len(p) bytes from p to the underlying data stream\nat offset off. It returns the number of bytes written from p (0 <= n <= len(p))\nand any error encountered that caused the write to stop early.\nWriteAt must return a non-nil error if it returns n < len(p).\n\nIf WriteAt is writing to a destination with a seek offset,\nWriteAt should not affect nor be affected by the underlying\nseek offset.\n\nClients of WriteAt can execute parallel WriteAt calls on the same\ndestination if the ranges do not overlap.\n\nImplementations must not retain p.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_WriterAt"}
  WriterAt)

JOKER TYPE go.std.io/WriterTo:
(def
  ^{:doc "WriterTo is the interface that wraps the WriteTo method.\n\nWriteTo writes data to w until there's no more data to write or\nwhen an error occurs. The return value n is the number of bytes\nwritten. Any error encountered during the write is also returned.\n\nThe Copy function uses WriterTo if available.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_WriterTo"}
  WriterTo)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["io"]
    :doc "Provides a low-level interface to the io package.\n\nPackage io provides basic interfaces to I/O primitives.\nIts primary job is to wrap existing implementations of such primitives,\nsuch as those in package os, into shared public interfaces that\nabstract the functionality, plus some other related primitives.\n\nBecause these interfaces and primitives wrap lower-level operations with\nvarious implementations, unless otherwise informed clients should not\nassume they are safe for parallel execution.\n"
    :empty false}
  go.std.io)
JOKER VARIABLE Discard from io/ioutil/ioutil.go:
(def
  ^{:doc "Discard is an io.Writer on which all Write calls succeed\nwithout doing anything.\n"
    :added "1.0"
    :tag "Var"
    :go "ioutil.Discard"}
  Discard)

JOKER FUNC io/ioutil.NopCloser from io/ioutil/ioutil.go:
;; (defn NopCloser
;;   "NopCloser returns a ReadCloser with a no-op Close method wrapping\nthe provided Reader r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.ReadCloser\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "__nopCloser(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC io/ioutil.ReadAll from io/ioutil/ioutil.go:
;; (defn ReadAll
;;   "ReadAll reads from r until an error or EOF and returns the data it read.\nA successful call returns err == nil, not err == EOF. Because ReadAll is\ndefined to read from src until EOF, it does not treat an EOF from Read\nas an error to be reported.\n\nGo input arguments: (r io.Reader)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__readAll(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC io/ioutil.ReadDir from io/ioutil/ioutil.go:
(defn ReadDir
  "ReadDir reads the directory named by dirname and returns\na list of directory entries sorted by filename.\n\nGo input arguments: (dirname string)\n\nGo return type: ([]os.FileInfo, error)\n\nJoker input arguments: [^String dirname]\n\nJoker return type: [(vector-of go.std.os/FileInfo) Error]"
  {:added "1.0"
   :go "__readDir(__dirname)"}
  [^String __dirname])

JOKER FUNC io/ioutil.ReadFile from io/ioutil/ioutil.go:
(defn ReadFile
  "ReadFile reads the file named by filename and returns the contents.\nA successful call returns err == nil, not err == EOF. Because ReadFile\nreads the whole file, it does not treat an EOF from Read as an error\nto be reported.\n\nGo input arguments: (filename string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^String filename]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__readFile(__filename)"}
  [^String __filename])

JOKER FUNC io/ioutil.TempDir from io/ioutil/tempfile.go:
(defn TempDir
  "TempDir creates a new temporary directory in the directory dir\nwith a name beginning with prefix and returns the path of the\nnew directory. If dir is the empty string, TempDir uses the\ndefault directory for temporary files (see os.TempDir).\nMultiple programs calling TempDir simultaneously\nwill not choose the same directory. It is the caller's responsibility\nto remove the directory when no longer needed.\n\nGo input arguments: (dir string, prefix string)\n\nGo return type: (name string, err error)\n\nJoker input arguments: [^String dir, ^String prefix]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__tempDir(__dir, __prefix)"}
  [^String __dir, ^String __prefix])

JOKER FUNC io/ioutil.TempFile from io/ioutil/tempfile.go:
(defn TempFile
  "TempFile creates a new temporary file in the directory dir,\nopens the file for reading and writing, and returns the resulting *os.File.\nThe filename is generated by taking pattern and adding a random\nstring to the end. If pattern includes a \"*\", the random string\nreplaces the last \"*\".\nIf dir is the empty string, TempFile uses the default directory\nfor temporary files (see os.TempDir).\nMultiple programs calling TempFile simultaneously\nwill not choose the same file. The caller can use f.Name()\nto find the pathname of the file. It is the caller's responsibility\nto remove the file when no longer needed.\n\nGo input arguments: (dir string, pattern string)\n\nGo return type: (f *os.File, err error)\n\nJoker input arguments: [^String dir, ^String pattern]\n\nJoker return type: [(atom-of go.std.os/File) Error]"
  {:added "1.0"
   :go "__tempFile(__dir, __pattern)"}
  [^String __dir, ^String __pattern])

JOKER FUNC io/ioutil.WriteFile from io/ioutil/ioutil.go:
;; (defn ^"Error" WriteFile
;;   "WriteFile writes data to a file named by filename.\nIf the file does not exist, WriteFile creates it with permissions perm;\notherwise WriteFile truncates it before writing.\n\nGo input arguments: (filename string, data []byte, perm os.FileMode)\n\nGo return type: error\n\nJoker input arguments: [^String filename, ^(vector-of Int) data, ^go.std.os/FileMode perm]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "ioutil.WriteFile(__filename, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)), *__perm)"}
;;   [^String __filename, ^Object __data, ^os/FileMode __perm])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["io/ioutil"]
    :doc "Provides a low-level interface to the io/ioutil package.\n\nPackage ioutil implements some I/O utility functions.\n"
    :empty false}
  go.std.io.ioutil)
JOKER CONSTANT LUTC from log/log.go:
(def
  ^{:doc "if Ldate or Ltime is set, use UTC rather than the local time zone\n"
    :added "1.0"
    :tag "Number"
    :go "int64(log.LUTC)"}
  LUTC)

JOKER CONSTANT Ldate from log/log.go:
(def
  ^{:doc "the date in the local time zone: 2009/01/23\n"
    :added "1.0"
    :tag "Number"
    :go "int64(log.Ldate)"}
  Ldate)

JOKER CONSTANT Llongfile from log/log.go:
(def
  ^{:doc "full file name and line number: /a/b/c/d.go:23\n"
    :added "1.0"
    :tag "Number"
    :go "int64(log.Llongfile)"}
  Llongfile)

JOKER CONSTANT Lmicroseconds from log/log.go:
(def
  ^{:doc "microsecond resolution: 01:23:23.123123.  assumes Ltime.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(log.Lmicroseconds)"}
  Lmicroseconds)

JOKER CONSTANT Lshortfile from log/log.go:
(def
  ^{:doc "final file name element and line number: d.go:23. overrides Llongfile\n"
    :added "1.0"
    :tag "Number"
    :go "int64(log.Lshortfile)"}
  Lshortfile)

JOKER CONSTANT LstdFlags from log/log.go:
(def
  ^{:doc "initial values for the standard logger\n"
    :added "1.0"
    :tag "Number"
    :go "int64(log.LstdFlags)"}
  LstdFlags)

JOKER CONSTANT Ltime from log/log.go:
(def
  ^{:doc "the time in the local time zone: 01:23:23\n"
    :added "1.0"
    :tag "Number"
    :go "int64(log.Ltime)"}
  Ltime)

JOKER TYPE log.Logger from log/log.go:
(defn ^"GoObject" Logger.
  "Constructor for log.Logger"
  {:added "1.0"
   :go "_ConstructLogger(_v)"}
  [^Object _v])

JOKER FUNC log.Fatal from log/log.go:
;; (defn Fatal
;;   "Fatal is equivalent to Print() followed by a call to os.Exit(1).\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__fatal(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> __v])

JOKER FUNC log.Fatalf from log/log.go:
;; (defn Fatalf
;;   "Fatalf is equivalent to Printf() followed by a call to os.Exit(1).\n\nGo input arguments: (format string, v ...interface {})\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__fatalf(__format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String __format, ^<protocol-or-something> __v])

JOKER FUNC log.Fatalln from log/log.go:
;; (defn Fatalln
;;   "Fatalln is equivalent to Println() followed by a call to os.Exit(1).\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__fatalln(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> __v])

JOKER FUNC log.Flags from log/log.go:
(defn ^"Int" Flags
  "Flags returns the output flags for the standard logger.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "log.Flags()"}
  [])

JOKER FUNC log.New from log/log.go:
;; (defn New
;;   "New creates a new Logger. The out variable sets the\ndestination to which log data will be written.\nThe prefix appears at the beginning of each generated log line.\nThe flag argument defines the logging properties.\n\nGo input arguments: (out io.Writer, prefix string, flag int)\n\nGo return type: *Logger\n\nJoker input arguments: [^go.std.io/Writer out, ^String prefix, ^Int flag]\n\nJoker return type: (atom-of go.std.log/Logger)"
;;   {:added "1.0"
;;    :go "__new(*__out, __prefix, __flag)"}
;;   [^io/Writer __out, ^String __prefix, ^Int __flag])

JOKER FUNC log.Output from log/log.go:
(defn ^"Error" Output
  "Output writes the output for a logging event. The string s contains\nthe text to print after the prefix specified by the flags of the\nLogger. A newline is appended if the last character of s is not\nalready a newline. Calldepth is the count of the number of\nframes to skip when computing the file name and line number\nif Llongfile or Lshortfile is set; a value of 1 will print the details\nfor the caller of Output.\n\nGo input arguments: (calldepth int, s string)\n\nGo return type: error\n\nJoker input arguments: [^Int calldepth, ^String s]\n\nJoker return type: Error"
  {:added "1.0"
   :go "log.Output(__calldepth, __s)"}
  [^Int __calldepth, ^String __s])

JOKER FUNC log.Panic from log/log.go:
;; (defn Panic
;;   "Panic is equivalent to Print() followed by a call to panic().\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__panic(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> __v])

JOKER FUNC log.Panicf from log/log.go:
;; (defn Panicf
;;   "Panicf is equivalent to Printf() followed by a call to panic().\n\nGo input arguments: (format string, v ...interface {})\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__panicf(__format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String __format, ^<protocol-or-something> __v])

JOKER FUNC log.Panicln from log/log.go:
;; (defn Panicln
;;   "Panicln is equivalent to Println() followed by a call to panic().\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__panicln(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> __v])

JOKER FUNC log.Prefix from log/log.go:
(defn ^"String" Prefix
  "Prefix returns the output prefix for the standard logger.\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "log.Prefix()"}
  [])

JOKER FUNC log.Print from log/log.go:
;; (defn Print
;;   "Print calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Print.\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__print(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> __v])

JOKER FUNC log.Printf from log/log.go:
;; (defn Printf
;;   "Printf calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Printf.\n\nGo input arguments: (format string, v ...interface {})\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__printf(__format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String __format, ^<protocol-or-something> __v])

JOKER FUNC log.Println from log/log.go:
;; (defn Println
;;   "Println calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Println.\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__println(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> __v])

JOKER FUNC log.SetFlags from log/log.go:
;; (defn SetFlags
;;   "SetFlags sets the output flags for the standard logger.\n\nGo input arguments: (flag int)\n\nJoker input arguments: [^Int flag]"
;;   {:added "1.0"
;;    :go "__setFlags(__flag)"}
;;   [^Int __flag])

JOKER FUNC log.SetOutput from log/log.go:
;; (defn SetOutput
;;   "SetOutput sets the output destination for the standard logger.\n\nGo input arguments: (w io.Writer)\n\nJoker input arguments: [^go.std.io/Writer w]"
;;   {:added "1.0"
;;    :go "__setOutput(*__w)"}
;;   [^io/Writer __w])

JOKER FUNC log.SetPrefix from log/log.go:
;; (defn SetPrefix
;;   "SetPrefix sets the output prefix for the standard logger.\n\nGo input arguments: (prefix string)\n\nJoker input arguments: [^String prefix]"
;;   {:added "1.0"
;;    :go "__setPrefix(__prefix)"}
;;   [^String __prefix])

JOKER TYPE go.std.log/Logger:
(def
  ^{:doc "A Logger represents an active logging object that generates lines of\noutput to an io.Writer. Each logging operation makes a single call to\nthe Writer's Write method. A Logger can be used simultaneously from\nmultiple goroutines; it guarantees to serialize access to the Writer.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Logger"}
  Logger)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["log"]
    :doc "Provides a low-level interface to the log package.\n\nPackage log implements a simple logging package. It defines a type, Logger,\nwith methods for formatting output. It also has a predefined 'standard'\nLogger accessible through helper functions Print[f|ln], Fatal[f|ln], and\nPanic[f|ln], which are easier to use than creating a Logger manually.\nThat logger writes to standard error and prints the date and time\nof each logged message.\nEvery log message is output on a separate line: if the message being\nprinted does not end in a newline, the logger will add one.\nThe Fatal functions call os.Exit(1) after writing the log message.\nThe Panic functions call panic after writing the log message.\n"
    :empty false}
  go.std.log)
JOKER CONSTANT LOG_ALERT from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_ALERT)"}
  LOG_ALERT)

JOKER CONSTANT LOG_AUTH from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_AUTH)"}
  LOG_AUTH)

JOKER CONSTANT LOG_AUTHPRIV from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_AUTHPRIV)"}
  LOG_AUTHPRIV)

JOKER CONSTANT LOG_CRIT from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_CRIT)"}
  LOG_CRIT)

JOKER CONSTANT LOG_CRON from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_CRON)"}
  LOG_CRON)

JOKER CONSTANT LOG_DAEMON from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_DAEMON)"}
  LOG_DAEMON)

JOKER CONSTANT LOG_DEBUG from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_DEBUG)"}
  LOG_DEBUG)

JOKER CONSTANT LOG_EMERG from log/syslog/syslog.go:
(def
  ^{:doc "From /usr/include/sys/syslog.h.\nThese are the same on Linux, BSD, and OS X.\n"
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_EMERG)"}
  LOG_EMERG)

JOKER CONSTANT LOG_ERR from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_ERR)"}
  LOG_ERR)

JOKER CONSTANT LOG_FTP from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_FTP)"}
  LOG_FTP)

JOKER CONSTANT LOG_INFO from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_INFO)"}
  LOG_INFO)

JOKER CONSTANT LOG_KERN from log/syslog/syslog.go:
(def
  ^{:doc "From /usr/include/sys/syslog.h.\nThese are the same up to LOG_FTP on Linux, BSD, and OS X.\n"
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_KERN)"}
  LOG_KERN)

JOKER CONSTANT LOG_LOCAL0 from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_LOCAL0)"}
  LOG_LOCAL0)

JOKER CONSTANT LOG_LOCAL1 from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_LOCAL1)"}
  LOG_LOCAL1)

JOKER CONSTANT LOG_LOCAL2 from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_LOCAL2)"}
  LOG_LOCAL2)

JOKER CONSTANT LOG_LOCAL3 from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_LOCAL3)"}
  LOG_LOCAL3)

JOKER CONSTANT LOG_LOCAL4 from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_LOCAL4)"}
  LOG_LOCAL4)

JOKER CONSTANT LOG_LOCAL5 from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_LOCAL5)"}
  LOG_LOCAL5)

JOKER CONSTANT LOG_LOCAL6 from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_LOCAL6)"}
  LOG_LOCAL6)

JOKER CONSTANT LOG_LOCAL7 from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_LOCAL7)"}
  LOG_LOCAL7)

JOKER CONSTANT LOG_LPR from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_LPR)"}
  LOG_LPR)

JOKER CONSTANT LOG_MAIL from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_MAIL)"}
  LOG_MAIL)

JOKER CONSTANT LOG_NEWS from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_NEWS)"}
  LOG_NEWS)

JOKER CONSTANT LOG_NOTICE from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_NOTICE)"}
  LOG_NOTICE)

JOKER CONSTANT LOG_SYSLOG from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_SYSLOG)"}
  LOG_SYSLOG)

JOKER CONSTANT LOG_USER from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_USER)"}
  LOG_USER)

JOKER CONSTANT LOG_UUCP from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_UUCP)"}
  LOG_UUCP)

JOKER CONSTANT LOG_WARNING from log/syslog/syslog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(syslog.LOG_WARNING)"}
  LOG_WARNING)

JOKER TYPE log/syslog.Priority from log/syslog/syslog.go:
(defn ^"GoObject" Priority.
  "Constructor for syslog.Priority"
  {:added "1.0"
   :go "_ConstructPriority(_v)"}
  [^Object _v])

JOKER TYPE log/syslog.Writer from log/syslog/syslog.go:
(defn ^"GoObject" Writer.
  "Constructor for syslog.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC log/syslog.Dial from log/syslog/syslog.go:
(defn Dial
  "Dial establishes a connection to a log daemon by connecting to\naddress raddr on the specified network. Each write to the returned\nwriter sends a log message with the facility and severity\n(from priority) and tag. If tag is empty, the os.Args[0] is used.\nIf network is empty, Dial will connect to the local syslog server.\nOtherwise, see the documentation for net.Dial for valid values\nof network and raddr.\n\nGo input arguments: (network string, raddr string, priority Priority, tag string)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^String network, ^String raddr, ^go.std.log.syslog/Priority priority, ^String tag]\n\nJoker return type: [(atom-of go.std.log.syslog/Writer) Error]"
  {:added "1.0"
   :go "__dial(__network, __raddr, *__priority, __tag)"}
  [^String __network, ^String __raddr, ^syslog/Priority __priority, ^String __tag])

JOKER FUNC log/syslog.New from log/syslog/syslog.go:
(defn New
  "New establishes a new connection to the system log daemon. Each\nwrite to the returned writer sends a log message with the given\npriority (a combination of the syslog facility and severity) and\nprefix tag. If tag is empty, the os.Args[0] is used.\n\nGo input arguments: (priority Priority, tag string)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.log.syslog/Priority priority, ^String tag]\n\nJoker return type: [(atom-of go.std.log.syslog/Writer) Error]"
  {:added "1.0"
   :go "__new(*__priority, __tag)"}
  [^syslog/Priority __priority, ^String __tag])

JOKER FUNC log/syslog.NewLogger from log/syslog/syslog.go:
(defn NewLogger
  "NewLogger creates a log.Logger whose output is written to the\nsystem log service with the specified priority, a combination of\nthe syslog facility and severity. The logFlag argument is the flag\nset passed through to log.New to create the Logger.\n\nGo input arguments: (p Priority, logFlag int)\n\nGo return type: (*log.Logger, error)\n\nJoker input arguments: [^go.std.log.syslog/Priority p, ^Int logFlag]\n\nJoker return type: [(atom-of go.std.log/Logger) Error]"
  {:added "1.0"
   :go "__newLogger(*__p, __logFlag)"}
  [^syslog/Priority __p, ^Int __logFlag])

JOKER TYPE go.std.log.syslog/Priority:
(def
  ^{:doc "The Priority is a combination of the syslog facility and\nseverity. For example, LOG_ALERT | LOG_FTP sends an alert severity\nmessage from the FTP facility. The default severity is LOG_EMERG;\nthe default facility is LOG_KERN.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Priority"}
  Priority)

JOKER TYPE go.std.log.syslog/Writer:
(def
  ^{:doc "A Writer is a connection to a syslog server.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Writer"}
  Writer)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["log/syslog"]
    :doc "Provides a low-level interface to the log/syslog package.\n\nPackage syslog provides a simple interface to the system log\nservice. It can send messages to the syslog daemon using UNIX\ndomain sockets, UDP or TCP.\n\nOnly one call to Dial is necessary. On write failures,\nthe syslog client will attempt to reconnect to the server\nand write again.\n\nThe syslog package is frozen and is not accepting new features.\nSome external packages provide more functionality. See:\n\n  https://godoc.org/?q=syslog\n"
    :empty false}
  go.std.log.syslog)
JOKER CONSTANT E from math/const.go:
(def
  ^{:doc "https://oeis.org/A001113\n"
    :added "1.0"
    :tag "Double"
    :go "math.E"}
  E)

JOKER CONSTANT Ln10 from math/const.go:
(def
  ^{:doc "https://oeis.org/A002392\n"
    :added "1.0"
    :tag "Double"
    :go "math.Ln10"}
  Ln10)

JOKER CONSTANT Ln2 from math/const.go:
(def
  ^{:doc "https://oeis.org/A002162\n"
    :added "1.0"
    :tag "Double"
    :go "math.Ln2"}
  Ln2)

JOKER CONSTANT Log10E from math/const.go:
(def
  ^{:doc "Mathematical constants.\n"
    :added "1.0"
    :tag "Double"
    :go "math.Log10E"}
  Log10E)

JOKER CONSTANT Log2E from math/const.go:
(def
  ^{:doc "Mathematical constants.\n"
    :added "1.0"
    :tag "Double"
    :go "math.Log2E"}
  Log2E)

JOKER CONSTANT MaxFloat32 from math/const.go:
(def
  ^{:doc "2**127 * (2**24 - 1) / 2**23\n"
    :added "1.0"
    :tag "Double"
    :go "math.MaxFloat32"}
  MaxFloat32)

JOKER CONSTANT MaxFloat64 from math/const.go:
(def
  ^{:doc "2**1023 * (2**53 - 1) / 2**52\n"
    :added "1.0"
    :tag "Double"
    :go "math.MaxFloat64"}
  MaxFloat64)

JOKER CONSTANT MaxInt16 from math/const.go:
(def
  ^{:doc "Integer limit values.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(math.MaxInt16)"}
  MaxInt16)

JOKER CONSTANT MaxInt32 from math/const.go:
(def
  ^{:doc "Integer limit values.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(math.MaxInt32)"}
  MaxInt32)

JOKER CONSTANT MaxInt64 from math/const.go:
(def
  ^{:doc "Integer limit values.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(math.MaxInt64)"}
  MaxInt64)

JOKER CONSTANT MaxInt8 from math/const.go:
(def
  ^{:doc "Integer limit values.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(math.MaxInt8)"}
  MaxInt8)

JOKER CONSTANT MaxUint16 from math/const.go:
(def
  ^{:doc "Integer limit values.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(math.MaxUint16)"}
  MaxUint16)

JOKER CONSTANT MaxUint32 from math/const.go:
(def
  ^{:doc "Integer limit values.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(math.MaxUint32)"}
  MaxUint32)

JOKER CONSTANT MaxUint64 from math/const.go:
(def
  ^{:doc "Integer limit values.\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(math.MaxUint64)"}
  MaxUint64)

JOKER CONSTANT MaxUint8 from math/const.go:
(def
  ^{:doc "Integer limit values.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(math.MaxUint8)"}
  MaxUint8)

JOKER CONSTANT MinInt16 from math/const.go:
(def
  ^{:doc "Integer limit values.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(math.MinInt16)"}
  MinInt16)

JOKER CONSTANT MinInt32 from math/const.go:
(def
  ^{:doc "Integer limit values.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(math.MinInt32)"}
  MinInt32)

JOKER CONSTANT MinInt64 from math/const.go:
(def
  ^{:doc "Integer limit values.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(math.MinInt64)"}
  MinInt64)

JOKER CONSTANT MinInt8 from math/const.go:
(def
  ^{:doc "Integer limit values.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(math.MinInt8)"}
  MinInt8)

JOKER CONSTANT Phi from math/const.go:
(def
  ^{:doc "https://oeis.org/A001622\n"
    :added "1.0"
    :tag "Double"
    :go "math.Phi"}
  Phi)

JOKER CONSTANT Pi from math/const.go:
(def
  ^{:doc "https://oeis.org/A000796\n"
    :added "1.0"
    :tag "Double"
    :go "math.Pi"}
  Pi)

JOKER CONSTANT SmallestNonzeroFloat32 from math/const.go:
(def
  ^{:doc "1 / 2**(127 - 1 + 23)\n"
    :added "1.0"
    :tag "Double"
    :go "math.SmallestNonzeroFloat32"}
  SmallestNonzeroFloat32)

JOKER CONSTANT SmallestNonzeroFloat64 from math/const.go:
(def
  ^{:doc "1 / 2**(1023 - 1 + 52)\n"
    :added "1.0"
    :tag "Double"
    :go "math.SmallestNonzeroFloat64"}
  SmallestNonzeroFloat64)

JOKER CONSTANT Sqrt2 from math/const.go:
(def
  ^{:doc "https://oeis.org/A002193\n"
    :added "1.0"
    :tag "Double"
    :go "math.Sqrt2"}
  Sqrt2)

JOKER CONSTANT SqrtE from math/const.go:
(def
  ^{:doc "https://oeis.org/A019774\n"
    :added "1.0"
    :tag "Double"
    :go "math.SqrtE"}
  SqrtE)

JOKER CONSTANT SqrtPhi from math/const.go:
(def
  ^{:doc "https://oeis.org/A139339\n"
    :added "1.0"
    :tag "Double"
    :go "math.SqrtPhi"}
  SqrtPhi)

JOKER CONSTANT SqrtPi from math/const.go:
(def
  ^{:doc "https://oeis.org/A002161\n"
    :added "1.0"
    :tag "Double"
    :go "math.SqrtPi"}
  SqrtPi)

JOKER FUNC math.Abs from math/abs.go:
;; (defn Abs
;;   "Abs returns the absolute value of x.\n\nSpecial cases are:\n\tAbs(±Inf) = +Inf\n\tAbs(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__abs(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Acos from math/asin.go:
;; (defn Acos
;;   "Acos returns the arccosine, in radians, of x.\n\nSpecial case is:\n\tAcos(x) = NaN if x < -1 or x > 1\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__acos(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Acosh from math/acosh.go:
;; (defn Acosh
;;   "Acosh returns the inverse hyperbolic cosine of x.\n\nSpecial cases are:\n\tAcosh(+Inf) = +Inf\n\tAcosh(x) = NaN if x < 1\n\tAcosh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__acosh(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Asin from math/asin.go:
;; (defn Asin
;;   "Asin returns the arcsine, in radians, of x.\n\nSpecial cases are:\n\tAsin(±0) = ±0\n\tAsin(x) = NaN if x < -1 or x > 1\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__asin(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Asinh from math/asinh.go:
;; (defn Asinh
;;   "Asinh returns the inverse hyperbolic sine of x.\n\nSpecial cases are:\n\tAsinh(±0) = ±0\n\tAsinh(±Inf) = ±Inf\n\tAsinh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__asinh(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Atan from math/atan.go:
;; (defn Atan
;;   "Atan returns the arctangent, in radians, of x.\n\nSpecial cases are:\n     Atan(±0) = ±0\n     Atan(±Inf) = ±Pi/2\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__atan(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Atan2 from math/atan2.go:
;; (defn Atan2
;;   "Atan2 returns the arc tangent of y/x, using\nthe signs of the two to determine the quadrant\nof the return value.\n\nSpecial cases are (in order):\n\tAtan2(y, NaN) = NaN\n\tAtan2(NaN, x) = NaN\n\tAtan2(+0, x>=0) = +0\n\tAtan2(-0, x>=0) = -0\n\tAtan2(+0, x<=-0) = +Pi\n\tAtan2(-0, x<=-0) = -Pi\n\tAtan2(y>0, 0) = +Pi/2\n\tAtan2(y<0, 0) = -Pi/2\n\tAtan2(+Inf, +Inf) = +Pi/4\n\tAtan2(-Inf, +Inf) = -Pi/4\n\tAtan2(+Inf, -Inf) = 3Pi/4\n\tAtan2(-Inf, -Inf) = -3Pi/4\n\tAtan2(y, +Inf) = 0\n\tAtan2(y>0, -Inf) = +Pi\n\tAtan2(y<0, -Inf) = -Pi\n\tAtan2(+Inf, x) = +Pi/2\n\tAtan2(-Inf, x) = -Pi/2\n\nGo input arguments: (y float64, x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double y, ^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__atan2(__y, __x)"}
;;   [^ABEND007(find these) __y, ^ABEND007(find these) __x])

JOKER FUNC math.Atanh from math/atanh.go:
;; (defn Atanh
;;   "Atanh returns the inverse hyperbolic tangent of x.\n\nSpecial cases are:\n\tAtanh(1) = +Inf\n\tAtanh(±0) = ±0\n\tAtanh(-1) = -Inf\n\tAtanh(x) = NaN if x < -1 or x > 1\n\tAtanh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__atanh(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Cbrt from math/cbrt.go:
;; (defn Cbrt
;;   "Cbrt returns the cube root of x.\n\nSpecial cases are:\n\tCbrt(±0) = ±0\n\tCbrt(±Inf) = ±Inf\n\tCbrt(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__cbrt(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Ceil from math/floor.go:
;; (defn Ceil
;;   "Ceil returns the least integer value greater than or equal to x.\n\nSpecial cases are:\n\tCeil(±0) = ±0\n\tCeil(±Inf) = ±Inf\n\tCeil(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__ceil(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Copysign from math/copysign.go:
;; (defn Copysign
;;   "Copysign returns a value with the magnitude\nof x and the sign of y.\n\nGo input arguments: (x float64, y float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x, ^Double y]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__copysign(__x, __y)"}
;;   [^ABEND007(find these) __x, ^ABEND007(find these) __y])

JOKER FUNC math.Cos from math/sin.go:
;; (defn Cos
;;   "Cos returns the cosine of the radian argument x.\n\nSpecial cases are:\n\tCos(±Inf) = NaN\n\tCos(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__cos(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Cosh from math/sinh.go:
;; (defn Cosh
;;   "Cosh returns the hyperbolic cosine of x.\n\nSpecial cases are:\n\tCosh(±0) = 1\n\tCosh(±Inf) = +Inf\n\tCosh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__cosh(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Dim from math/dim.go:
;; (defn Dim
;;   "Dim returns the maximum of x-y or 0.\n\nSpecial cases are:\n\tDim(+Inf, +Inf) = NaN\n\tDim(-Inf, -Inf) = NaN\n\tDim(x, NaN) = Dim(NaN, x) = NaN\n\nGo input arguments: (x float64, y float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x, ^Double y]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__dim(__x, __y)"}
;;   [^ABEND007(find these) __x, ^ABEND007(find these) __y])

JOKER FUNC math.Erf from math/erf.go:
;; (defn Erf
;;   "Erf returns the error function of x.\n\nSpecial cases are:\n\tErf(+Inf) = 1\n\tErf(-Inf) = -1\n\tErf(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__erf(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Erfc from math/erf.go:
;; (defn Erfc
;;   "Erfc returns the complementary error function of x.\n\nSpecial cases are:\n\tErfc(+Inf) = 0\n\tErfc(-Inf) = 2\n\tErfc(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__erfc(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Erfcinv from math/erfinv.go:
;; (defn Erfcinv
;;   "Erfcinv returns the inverse of Erfc(x).\n\nSpecial cases are:\n\tErfcinv(0) = +Inf\n\tErfcinv(2) = -Inf\n\tErfcinv(x) = NaN if x < 0 or x > 2\n\tErfcinv(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__erfcinv(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Erfinv from math/erfinv.go:
;; (defn Erfinv
;;   "Erfinv returns the inverse error function of x.\n\nSpecial cases are:\n\tErfinv(1) = +Inf\n\tErfinv(-1) = -Inf\n\tErfinv(x) = NaN if x < -1 or x > 1\n\tErfinv(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__erfinv(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Exp from math/exp.go:
;; (defn Exp
;;   "Exp returns e**x, the base-e exponential of x.\n\nSpecial cases are:\n\tExp(+Inf) = +Inf\n\tExp(NaN) = NaN\nVery large values overflow to 0 or +Inf.\nVery small values underflow to 1.\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__exp(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Exp2 from math/exp.go:
;; (defn Exp2
;;   "Exp2 returns 2**x, the base-2 exponential of x.\n\nSpecial cases are the same as Exp.\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__exp2(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Expm1 from math/expm1.go:
;; (defn Expm1
;;   "Expm1 returns e**x - 1, the base-e exponential of x minus 1.\nIt is more accurate than Exp(x) - 1 when x is near zero.\n\nSpecial cases are:\n\tExpm1(+Inf) = +Inf\n\tExpm1(-Inf) = -1\n\tExpm1(NaN) = NaN\nVery large values overflow to -1 or +Inf.\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__expm1(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Float32bits from math/unsafe.go:
;; (defn Float32bits
;;   "Float32bits returns the IEEE 754 binary representation of f,\nwith the sign bit of f and the result in the same bit position.\nFloat32bits(Float32frombits(x)) == x.\n\nGo input arguments: (f float32)\n\nGo return type: uint32\n\nJoker input arguments: [^Double f]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__float32bits(__f)"}
;;   [^ABEND007(find these) __f])

JOKER FUNC math.Float32frombits from math/unsafe.go:
;; (defn Float32frombits
;;   "Float32frombits returns the floating-point number corresponding\nto the IEEE 754 binary representation b, with the sign bit of b\nand the result in the same bit position.\nFloat32frombits(Float32bits(x)) == x.\n\nGo input arguments: (b uint32)\n\nGo return type: float32\n\nJoker input arguments: [^Number b]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__float32frombits(__b)"}
;;   [^UInt32 __b])

JOKER FUNC math.Float64bits from math/unsafe.go:
;; (defn Float64bits
;;   "Float64bits returns the IEEE 754 binary representation of f,\nwith the sign bit of f and the result in the same bit position,\nand Float64bits(Float64frombits(x)) == x.\n\nGo input arguments: (f float64)\n\nGo return type: uint64\n\nJoker input arguments: [^Double f]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__float64bits(__f)"}
;;   [^ABEND007(find these) __f])

JOKER FUNC math.Float64frombits from math/unsafe.go:
;; (defn Float64frombits
;;   "Float64frombits returns the floating-point number corresponding\nto the IEEE 754 binary representation b, with the sign bit of b\nand the result in the same bit position.\nFloat64frombits(Float64bits(x)) == x.\n\nGo input arguments: (b uint64)\n\nGo return type: float64\n\nJoker input arguments: [^Number b]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__float64frombits(__b)"}
;;   [^UInt64 __b])

JOKER FUNC math.Floor from math/floor.go:
;; (defn Floor
;;   "Floor returns the greatest integer value less than or equal to x.\n\nSpecial cases are:\n\tFloor(±0) = ±0\n\tFloor(±Inf) = ±Inf\n\tFloor(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__floor(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Frexp from math/frexp.go:
;; (defn Frexp
;;   "Frexp breaks f into a normalized fraction\nand an integral power of two.\nIt returns frac and exp satisfying f == frac × 2**exp,\nwith the absolute value of frac in the interval [½, 1).\n\nSpecial cases are:\n\tFrexp(±0) = ±0, 0\n\tFrexp(±Inf) = ±Inf, 0\n\tFrexp(NaN) = NaN, 0\n\nGo input arguments: (f float64)\n\nGo return type: (frac float64, exp int)\n\nJoker input arguments: [^Double f]\n\nJoker return type: [Double Int]"
;;   {:added "1.0"
;;    :go "__frexp(__f)"}
;;   [^ABEND007(find these) __f])

JOKER FUNC math.Gamma from math/gamma.go:
;; (defn Gamma
;;   "Gamma returns the Gamma function of x.\n\nSpecial cases are:\n\tGamma(+Inf) = +Inf\n\tGamma(+0) = +Inf\n\tGamma(-0) = -Inf\n\tGamma(x) = NaN for integer x < 0\n\tGamma(-Inf) = NaN\n\tGamma(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__gamma(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Hypot from math/hypot.go:
;; (defn Hypot
;;   "Hypot returns Sqrt(p*p + q*q), taking care to avoid\nunnecessary overflow and underflow.\n\nSpecial cases are:\n\tHypot(±Inf, q) = +Inf\n\tHypot(p, ±Inf) = +Inf\n\tHypot(NaN, q) = NaN\n\tHypot(p, NaN) = NaN\n\nGo input arguments: (p float64, q float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double p, ^Double q]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__hypot(__p, __q)"}
;;   [^ABEND007(find these) __p, ^ABEND007(find these) __q])

JOKER FUNC math.Ilogb from math/logb.go:
;; (defn ^"Int" Ilogb
;;   "Ilogb returns the binary exponent of x as an integer.\n\nSpecial cases are:\n\tIlogb(±Inf) = MaxInt32\n\tIlogb(0) = MinInt32\n\tIlogb(NaN) = MaxInt32\n\nGo input arguments: (x float64)\n\nGo return type: int\n\nJoker input arguments: [^Double x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "math.Ilogb(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Inf from math/bits.go:
;; (defn Inf
;;   "Inf returns positive infinity if sign >= 0, negative infinity if sign < 0.\n\nGo input arguments: (sign int)\n\nGo return type: float64\n\nJoker input arguments: [^Int sign]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__inf(__sign)"}
;;   [^Int __sign])

JOKER FUNC math.IsInf from math/bits.go:
;; (defn ^"Boolean" IsInf
;;   "IsInf reports whether f is an infinity, according to sign.\nIf sign > 0, IsInf reports whether f is positive infinity.\nIf sign < 0, IsInf reports whether f is negative infinity.\nIf sign == 0, IsInf reports whether f is either infinity.\n\nGo input arguments: (f float64, sign int)\n\nGo return type: bool\n\nJoker input arguments: [^Double f, ^Int sign]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "math.IsInf(__f, __sign)"}
;;   [^ABEND007(find these) __f, ^Int __sign])

JOKER FUNC math.IsNaN from math/bits.go:
;; (defn ^"Boolean" IsNaN
;;   "IsNaN reports whether f is an IEEE 754 ``not-a-number'' value.\n\nGo input arguments: (f float64)\n\nGo return type: bool\n\nJoker input arguments: [^Double f]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "math.IsNaN(__f)"}
;;   [^ABEND007(find these) __f])

JOKER FUNC math.J0 from math/j0.go:
;; (defn J0
;;   "J0 returns the order-zero Bessel function of the first kind.\n\nSpecial cases are:\n\tJ0(±Inf) = 0\n\tJ0(0) = 1\n\tJ0(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__j0(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.J1 from math/j1.go:
;; (defn J1
;;   "J1 returns the order-one Bessel function of the first kind.\n\nSpecial cases are:\n\tJ1(±Inf) = 0\n\tJ1(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__j1(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Jn from math/jn.go:
;; (defn Jn
;;   "Jn returns the order-n Bessel function of the first kind.\n\nSpecial cases are:\n\tJn(n, ±Inf) = 0\n\tJn(n, NaN) = NaN\n\nGo input arguments: (n int, x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Int n, ^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__jn(__n, __x)"}
;;   [^Int __n, ^ABEND007(find these) __x])

JOKER FUNC math.Ldexp from math/ldexp.go:
;; (defn Ldexp
;;   "Ldexp is the inverse of Frexp.\nIt returns frac × 2**exp.\n\nSpecial cases are:\n\tLdexp(±0, exp) = ±0\n\tLdexp(±Inf, exp) = ±Inf\n\tLdexp(NaN, exp) = NaN\n\nGo input arguments: (frac float64, exp int)\n\nGo return type: float64\n\nJoker input arguments: [^Double frac, ^Int exp]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__ldexp(__frac, __exp)"}
;;   [^ABEND007(find these) __frac, ^Int __exp])

JOKER FUNC math.Lgamma from math/lgamma.go:
;; (defn Lgamma
;;   "Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).\n\nSpecial cases are:\n\tLgamma(+Inf) = +Inf\n\tLgamma(0) = +Inf\n\tLgamma(-integer) = +Inf\n\tLgamma(-Inf) = -Inf\n\tLgamma(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: (lgamma float64, sign int)\n\nJoker input arguments: [^Double x]\n\nJoker return type: [Double Int]"
;;   {:added "1.0"
;;    :go "__lgamma(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Log from math/log.go:
;; (defn Log
;;   "Log returns the natural logarithm of x.\n\nSpecial cases are:\n\tLog(+Inf) = +Inf\n\tLog(0) = -Inf\n\tLog(x < 0) = NaN\n\tLog(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__log(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Log10 from math/log10.go:
;; (defn Log10
;;   "Log10 returns the decimal logarithm of x.\nThe special cases are the same as for Log.\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__log10(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Log1p from math/log1p.go:
;; (defn Log1p
;;   "Log1p returns the natural logarithm of 1 plus its argument x.\nIt is more accurate than Log(1 + x) when x is near zero.\n\nSpecial cases are:\n\tLog1p(+Inf) = +Inf\n\tLog1p(±0) = ±0\n\tLog1p(-1) = -Inf\n\tLog1p(x < -1) = NaN\n\tLog1p(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__log1p(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Log2 from math/log10.go:
;; (defn Log2
;;   "Log2 returns the binary logarithm of x.\nThe special cases are the same as for Log.\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__log2(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Logb from math/logb.go:
;; (defn Logb
;;   "Logb returns the binary exponent of x.\n\nSpecial cases are:\n\tLogb(±Inf) = +Inf\n\tLogb(0) = -Inf\n\tLogb(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__logb(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Max from math/dim.go:
;; (defn Max
;;   "Max returns the larger of x or y.\n\nSpecial cases are:\n\tMax(x, +Inf) = Max(+Inf, x) = +Inf\n\tMax(x, NaN) = Max(NaN, x) = NaN\n\tMax(+0, ±0) = Max(±0, +0) = +0\n\tMax(-0, -0) = -0\n\nGo input arguments: (x float64, y float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x, ^Double y]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__max(__x, __y)"}
;;   [^ABEND007(find these) __x, ^ABEND007(find these) __y])

JOKER FUNC math.Min from math/dim.go:
;; (defn Min
;;   "Min returns the smaller of x or y.\n\nSpecial cases are:\n\tMin(x, -Inf) = Min(-Inf, x) = -Inf\n\tMin(x, NaN) = Min(NaN, x) = NaN\n\tMin(-0, ±0) = Min(±0, -0) = -0\n\nGo input arguments: (x float64, y float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x, ^Double y]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__min(__x, __y)"}
;;   [^ABEND007(find these) __x, ^ABEND007(find these) __y])

JOKER FUNC math.Mod from math/mod.go:
;; (defn Mod
;;   "Mod returns the floating-point remainder of x/y.\nThe magnitude of the result is less than y and its\nsign agrees with that of x.\n\nSpecial cases are:\n\tMod(±Inf, y) = NaN\n\tMod(NaN, y) = NaN\n\tMod(x, 0) = NaN\n\tMod(x, ±Inf) = x\n\tMod(x, NaN) = NaN\n\nGo input arguments: (x float64, y float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x, ^Double y]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__mod(__x, __y)"}
;;   [^ABEND007(find these) __x, ^ABEND007(find these) __y])

JOKER FUNC math.Modf from math/modf.go:
;; (defn Modf
;;   "Modf returns integer and fractional floating-point numbers\nthat sum to f. Both values have the same sign as f.\n\nSpecial cases are:\n\tModf(±Inf) = ±Inf, NaN\n\tModf(NaN) = NaN, NaN\n\nGo input arguments: (f float64)\n\nGo return type: (int float64, frac float64)\n\nJoker input arguments: [^Double f]\n\nJoker return type: [Double Double]"
;;   {:added "1.0"
;;    :go "__modf(__f)"}
;;   [^ABEND007(find these) __f])

JOKER FUNC math.NaN from math/bits.go:
;; (defn NaN
;;   "NaN returns an IEEE 754 ``not-a-number'' value.\n\nGo return type: float64\n\nJoker input arguments: []\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__naN()"}
;;   [])

JOKER FUNC math.Nextafter from math/nextafter.go:
;; (defn Nextafter
;;   "Nextafter returns the next representable float64 value after x towards y.\n\nSpecial cases are:\n\tNextafter(x, x)   = x\n\tNextafter(NaN, y) = NaN\n\tNextafter(x, NaN) = NaN\n\nGo input arguments: (x float64, y float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x, ^Double y]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__nextafter(__x, __y)"}
;;   [^ABEND007(find these) __x, ^ABEND007(find these) __y])

JOKER FUNC math.Nextafter32 from math/nextafter.go:
;; (defn Nextafter32
;;   "Nextafter32 returns the next representable float32 value after x towards y.\n\nSpecial cases are:\n\tNextafter32(x, x)   = x\n\tNextafter32(NaN, y) = NaN\n\tNextafter32(x, NaN) = NaN\n\nGo input arguments: (x float32, y float32)\n\nGo return type: float32\n\nJoker input arguments: [^Double x, ^Double y]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__nextafter32(__x, __y)"}
;;   [^ABEND007(find these) __x, ^ABEND007(find these) __y])

JOKER FUNC math.Pow from math/pow.go:
;; (defn Pow
;;   "Pow returns x**y, the base-x exponential of y.\n\nSpecial cases are (in order):\n\tPow(x, ±0) = 1 for any x\n\tPow(1, y) = 1 for any y\n\tPow(x, 1) = x for any x\n\tPow(NaN, y) = NaN\n\tPow(x, NaN) = NaN\n\tPow(±0, y) = ±Inf for y an odd integer < 0\n\tPow(±0, -Inf) = +Inf\n\tPow(±0, +Inf) = +0\n\tPow(±0, y) = +Inf for finite y < 0 and not an odd integer\n\tPow(±0, y) = ±0 for y an odd integer > 0\n\tPow(±0, y) = +0 for finite y > 0 and not an odd integer\n\tPow(-1, ±Inf) = 1\n\tPow(x, +Inf) = +Inf for |x| > 1\n\tPow(x, -Inf) = +0 for |x| > 1\n\tPow(x, +Inf) = +0 for |x| < 1\n\tPow(x, -Inf) = +Inf for |x| < 1\n\tPow(+Inf, y) = +Inf for y > 0\n\tPow(+Inf, y) = +0 for y < 0\n\tPow(-Inf, y) = Pow(-0, -y)\n\tPow(x, y) = NaN for finite x < 0 and finite non-integer y\n\nGo input arguments: (x float64, y float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x, ^Double y]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__pow(__x, __y)"}
;;   [^ABEND007(find these) __x, ^ABEND007(find these) __y])

JOKER FUNC math.Pow10 from math/pow10.go:
;; (defn Pow10
;;   "Pow10 returns 10**n, the base-10 exponential of n.\n\nSpecial cases are:\n\tPow10(n) =    0 for n < -323\n\tPow10(n) = +Inf for n > 308\n\nGo input arguments: (n int)\n\nGo return type: float64\n\nJoker input arguments: [^Int n]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__pow10(__n)"}
;;   [^Int __n])

JOKER FUNC math.Remainder from math/remainder.go:
;; (defn Remainder
;;   "Remainder returns the IEEE 754 floating-point remainder of x/y.\n\nSpecial cases are:\n\tRemainder(±Inf, y) = NaN\n\tRemainder(NaN, y) = NaN\n\tRemainder(x, 0) = NaN\n\tRemainder(x, ±Inf) = x\n\tRemainder(x, NaN) = NaN\n\nGo input arguments: (x float64, y float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x, ^Double y]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__remainder(__x, __y)"}
;;   [^ABEND007(find these) __x, ^ABEND007(find these) __y])

JOKER FUNC math.Round from math/floor.go:
;; (defn Round
;;   "Round returns the nearest integer, rounding half away from zero.\n\nSpecial cases are:\n\tRound(±0) = ±0\n\tRound(±Inf) = ±Inf\n\tRound(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__round(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.RoundToEven from math/floor.go:
;; (defn RoundToEven
;;   "RoundToEven returns the nearest integer, rounding ties to even.\n\nSpecial cases are:\n\tRoundToEven(±0) = ±0\n\tRoundToEven(±Inf) = ±Inf\n\tRoundToEven(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__roundToEven(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Signbit from math/signbit.go:
;; (defn ^"Boolean" Signbit
;;   "Signbit reports whether x is negative or negative zero.\n\nGo input arguments: (x float64)\n\nGo return type: bool\n\nJoker input arguments: [^Double x]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "math.Signbit(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Sin from math/sin.go:
;; (defn Sin
;;   "Sin returns the sine of the radian argument x.\n\nSpecial cases are:\n\tSin(±0) = ±0\n\tSin(±Inf) = NaN\n\tSin(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__sin(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Sincos from math/sincos.go:
;; (defn Sincos
;;   "Sincos returns Sin(x), Cos(x).\n\nSpecial cases are:\n\tSincos(±0) = ±0, 1\n\tSincos(±Inf) = NaN, NaN\n\tSincos(NaN) = NaN, NaN\n\nGo input arguments: (x float64)\n\nGo return type: (sin float64, cos float64)\n\nJoker input arguments: [^Double x]\n\nJoker return type: [Double Double]"
;;   {:added "1.0"
;;    :go "__sincos(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Sinh from math/sinh.go:
;; (defn Sinh
;;   "Sinh returns the hyperbolic sine of x.\n\nSpecial cases are:\n\tSinh(±0) = ±0\n\tSinh(±Inf) = ±Inf\n\tSinh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__sinh(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Sqrt from math/sqrt.go:
;; (defn Sqrt
;;   "Sqrt returns the square root of x.\n\nSpecial cases are:\n\tSqrt(+Inf) = +Inf\n\tSqrt(±0) = ±0\n\tSqrt(x < 0) = NaN\n\tSqrt(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__sqrt(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Tan from math/tan.go:
;; (defn Tan
;;   "Tan returns the tangent of the radian argument x.\n\nSpecial cases are:\n\tTan(±0) = ±0\n\tTan(±Inf) = NaN\n\tTan(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__tan(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Tanh from math/tanh.go:
;; (defn Tanh
;;   "Tanh returns the hyperbolic tangent of x.\n\nSpecial cases are:\n\tTanh(±0) = ±0\n\tTanh(±Inf) = ±1\n\tTanh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__tanh(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Trunc from math/floor.go:
;; (defn Trunc
;;   "Trunc returns the integer value of x.\n\nSpecial cases are:\n\tTrunc(±0) = ±0\n\tTrunc(±Inf) = ±Inf\n\tTrunc(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__trunc(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Y0 from math/j0.go:
;; (defn Y0
;;   "Y0 returns the order-zero Bessel function of the second kind.\n\nSpecial cases are:\n\tY0(+Inf) = 0\n\tY0(0) = -Inf\n\tY0(x < 0) = NaN\n\tY0(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__y0(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Y1 from math/j1.go:
;; (defn Y1
;;   "Y1 returns the order-one Bessel function of the second kind.\n\nSpecial cases are:\n\tY1(+Inf) = 0\n\tY1(0) = -Inf\n\tY1(x < 0) = NaN\n\tY1(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__y1(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math.Yn from math/jn.go:
;; (defn Yn
;;   "Yn returns the order-n Bessel function of the second kind.\n\nSpecial cases are:\n\tYn(n, +Inf) = 0\n\tYn(n ≥ 0, 0) = -Inf\n\tYn(n < 0, 0) = +Inf if n is odd, -Inf if n is even\n\tYn(n, x < 0) = NaN\n\tYn(n, NaN) = NaN\n\nGo input arguments: (n int, x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Int n, ^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__yn(__n, __x)"}
;;   [^Int __n, ^ABEND007(find these) __x])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["math"]
    :doc "Provides a low-level interface to the math package.\n\nPackage math provides basic constants and mathematical functions.\n\nThis package does not guarantee bit-identical results across architectures.\n"
    :empty false}
  go.std.math)
JOKER CONSTANT Above from math/big/float.go:
(def
  ^{:doc "Constants describing the Accuracy of a Float.\n"
    :added "1.0"
    :tag "Int"
    :go "int(int8(big.Above))"}
  Above)

JOKER CONSTANT AwayFromZero from math/big/float.go:
(def
  ^{:doc "no IEEE 754-2008 equivalent\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(big.AwayFromZero))"}
  AwayFromZero)

JOKER CONSTANT Below from math/big/float.go:
(def
  ^{:doc "Constants describing the Accuracy of a Float.\n"
    :added "1.0"
    :tag "Int"
    :go "int(int8(big.Below))"}
  Below)

JOKER CONSTANT Exact from math/big/float.go:
(def
  ^{:doc "Constants describing the Accuracy of a Float.\n"
    :added "1.0"
    :tag "Int"
    :go "int(int8(big.Exact))"}
  Exact)

JOKER CONSTANT MaxBase from math/big/natconv.go:
(def
  ^{:doc "MaxBase is the largest number base accepted for string conversions.\n"
    :added "1.0"
    :tag "Int"
    :go "big.MaxBase"}
  MaxBase)

JOKER CONSTANT ToNearestAway from math/big/float.go:
(def
  ^{:doc "== IEEE 754-2008 roundTiesToAway\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(big.ToNearestAway))"}
  ToNearestAway)

JOKER CONSTANT ToNearestEven from math/big/float.go:
(def
  ^{:doc "== IEEE 754-2008 roundTiesToEven\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(big.ToNearestEven))"}
  ToNearestEven)

JOKER CONSTANT ToNegativeInf from math/big/float.go:
(def
  ^{:doc "== IEEE 754-2008 roundTowardNegative\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(big.ToNegativeInf))"}
  ToNegativeInf)

JOKER CONSTANT ToPositiveInf from math/big/float.go:
(def
  ^{:doc "== IEEE 754-2008 roundTowardPositive\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(big.ToPositiveInf))"}
  ToPositiveInf)

JOKER CONSTANT ToZero from math/big/float.go:
(def
  ^{:doc "== IEEE 754-2008 roundTowardZero\n"
    :added "1.0"
    :tag "Int"
    :go "int(byte(big.ToZero))"}
  ToZero)

JOKER TYPE math/big.Accuracy from math/big/float.go:
(defn ^"GoObject" Accuracy.
  "Constructor for big.Accuracy"
  {:added "1.0"
   :go "_ConstructAccuracy(_v)"}
  [^Object _v])

JOKER TYPE math/big.ErrNaN from math/big/float.go:
(defn ^"GoObject" ErrNaN.
  "Constructor for big.ErrNaN"
  {:added "1.0"
   :go "_ConstructErrNaN(_v)"}
  [^Object _v])

JOKER TYPE math/big.Float from math/big/float.go:
(defn ^"GoObject" Float.
  "Constructor for big.Float"
  {:added "1.0"
   :go "_ConstructFloat(_v)"}
  [^Object _v])

JOKER TYPE math/big.Int from math/big/int.go:
(defn ^"GoObject" Int.
  "Constructor for big.Int"
  {:added "1.0"
   :go "_ConstructInt(_v)"}
  [^Object _v])

JOKER TYPE math/big.Rat from math/big/rat.go:
(defn ^"GoObject" Rat.
  "Constructor for big.Rat"
  {:added "1.0"
   :go "_ConstructRat(_v)"}
  [^Object _v])

JOKER TYPE math/big.RoundingMode from math/big/float.go:
(defn ^"GoObject" RoundingMode.
  "Constructor for big.RoundingMode"
  {:added "1.0"
   :go "_ConstructRoundingMode(_v)"}
  [^Object _v])

JOKER TYPE math/big.Word from math/big/arith.go:
(defn ^"GoObject" Word.
  "Constructor for big.Word"
  {:added "1.0"
   :go "_ConstructWord(_v)"}
  [^Object _v])

JOKER FUNC math/big.Jacobi from math/big/int.go:
(defn ^"Int" Jacobi
  "Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0.\nThe y argument must be an odd integer.\n\nGo input arguments: (x *Int, y *Int)\n\nGo return type: int\n\nJoker input arguments: [^(atom-of go.std.math.big/Int) x, ^(atom-of go.std.math.big/Int) y]\n\nJoker return type: Int"
  {:added "1.0"
   :go "big.Jacobi(__x, __y)"}
  [^big/Int __x, ^big/Int __y])

JOKER FUNC math/big.NewFloat from math/big/float.go:
;; (defn NewFloat
;;   "NewFloat allocates and returns a new Float set to x,\nwith precision 53 and rounding mode ToNearestEven.\nNewFloat panics with ErrNaN if x is a NaN.\n\nGo input arguments: (x float64)\n\nGo return type: *Float\n\nJoker input arguments: [^Double x]\n\nJoker return type: (atom-of go.std.math.big/Float)"
;;   {:added "1.0"
;;    :go "__newFloat(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/big.NewInt from math/big/int.go:
(defn NewInt
  "NewInt allocates and returns a new Int set to x.\n\nGo input arguments: (x int64)\n\nGo return type: *Int\n\nJoker input arguments: [^Number x]\n\nJoker return type: (atom-of go.std.math.big/Int)"
  {:added "1.0"
   :go "__newInt(__x)"}
  [^Int64 __x])

JOKER FUNC math/big.NewRat from math/big/rat.go:
(defn NewRat
  "NewRat creates a new Rat with numerator a and denominator b.\n\nGo input arguments: (a int64, b int64)\n\nGo return type: *Rat\n\nJoker input arguments: [^Number a, ^Number b]\n\nJoker return type: (atom-of go.std.math.big/Rat)"
  {:added "1.0"
   :go "__newRat(__a, __b)"}
  [^Int64 __a, ^Int64 __b])

JOKER FUNC math/big.ParseFloat from math/big/floatconv.go:
(defn ParseFloat
  "ParseFloat is like f.Parse(s, base) with f set to the given precision\nand rounding mode.\n\nGo input arguments: (s string, base int, prec uint, mode RoundingMode)\n\nGo return type: (f *Float, b int, err error)\n\nJoker input arguments: [^String s, ^Int base, ^Number prec, ^go.std.math.big/RoundingMode mode]\n\nJoker return type: [(atom-of go.std.math.big/Float) Int Error]"
  {:added "1.0"
   :go "__parseFloat(__s, __base, __prec, *__mode)"}
  [^String __s, ^Int __base, ^UInt __prec, ^big/RoundingMode __mode])

JOKER TYPE go.std.math.big/Accuracy:
(def
  ^{:doc "Accuracy describes the rounding error produced by the most recent\noperation that generated a Float value, relative to the exact value.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Accuracy"}
  Accuracy)

JOKER TYPE go.std.math.big/ErrNaN:
(def
  ^{:doc "An ErrNaN panic is raised by a Float operation that would lead to\na NaN under IEEE-754 rules. An ErrNaN implements the error interface.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ErrNaN"}
  ErrNaN)

JOKER TYPE go.std.math.big/Float:
(def
  ^{:doc "A nonzero finite Float represents a multi-precision floating point number\n\n  sign × mantissa × 2**exponent\n\nwith 0.5 <= mantissa < 1.0, and MinExp <= exponent <= MaxExp.\nA Float may also be zero (+0, -0) or infinite (+Inf, -Inf).\nAll Floats are ordered, and the ordering of two Floats x and y\nis defined by x.Cmp(y).\n\nEach Float value also has a precision, rounding mode, and accuracy.\nThe precision is the maximum number of mantissa bits available to\nrepresent the value. The rounding mode specifies how a result should\nbe rounded to fit into the mantissa bits, and accuracy describes the\nrounding error with respect to the exact result.\n\nUnless specified otherwise, all operations (including setters) that\nspecify a *Float variable for the result (usually via the receiver\nwith the exception of MantExp), round the numeric result according\nto the precision and rounding mode of the result variable.\n\nIf the provided result precision is 0 (see below), it is set to the\nprecision of the argument with the largest precision value before any\nrounding takes place, and the rounding mode remains unchanged. Thus,\nuninitialized Floats provided as result arguments will have their\nprecision set to a reasonable value determined by the operands, and\ntheir mode is the zero value for RoundingMode (ToNearestEven).\n\nBy setting the desired precision to 24 or 53 and using matching rounding\nmode (typically ToNearestEven), Float operations produce the same results\nas the corresponding float32 or float64 IEEE-754 arithmetic for operands\nthat correspond to normal (i.e., not denormal) float32 or float64 numbers.\nExponent underflow and overflow lead to a 0 or an Infinity for different\nvalues than IEEE-754 because Float exponents have a much larger range.\n\nThe zero (uninitialized) value for a Float is ready to use and represents\nthe number +0.0 exactly, with precision 0 and rounding mode ToNearestEven.\n\nOperations always take pointer arguments (*Float) rather\nthan Float values, and each unique Float value requires\nits own unique *Float pointer. To \"copy\" a Float value,\nan existing (or newly allocated) Float must be set to\na new value using the Float.Set method; shallow copies\nof Floats are not supported and may lead to errors.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Float"}
  Float)

JOKER TYPE go.std.math.big/Int:
(def
  ^{:doc "An Int represents a signed multi-precision integer.\nThe zero value for an Int represents the value 0.\n\nOperations always take pointer arguments (*Int) rather\nthan Int values, and each unique Int value requires\nits own unique *Int pointer. To \"copy\" an Int value,\nan existing (or newly allocated) Int must be set to\na new value using the Int.Set method; shallow copies\nof Ints are not supported and may lead to errors.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Int"}
  Int)

JOKER TYPE go.std.math.big/Rat:
(def
  ^{:doc "A Rat represents a quotient a/b of arbitrary precision.\nThe zero value for a Rat represents the value 0.\n\nOperations always take pointer arguments (*Rat) rather\nthan Rat values, and each unique Rat value requires\nits own unique *Rat pointer. To \"copy\" a Rat value,\nan existing (or newly allocated) Rat must be set to\na new value using the Rat.Set method; shallow copies\nof Rats are not supported and may lead to errors.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Rat"}
  Rat)

JOKER TYPE go.std.math.big/RoundingMode:
(def
  ^{:doc "RoundingMode determines how a Float value is rounded to the\ndesired precision. Rounding may change the Float value; the\nrounding error is described by the Float's Accuracy.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RoundingMode"}
  RoundingMode)

JOKER TYPE go.std.math.big/Word:
(def
  ^{:doc "A Word represents a single digit of a multi-precision unsigned integer.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Word"}
  Word)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["math/big"]
    :doc "Provides a low-level interface to the math/big package.\n\nPackage big implements arbitrary-precision arithmetic (big numbers).\nThe following numeric types are supported:\n\n\tInt    signed integers\n\tRat    rational numbers\n\tFloat  floating-point numbers\n\nThe zero value for an Int, Rat, or Float correspond to 0. Thus, new\nvalues can be declared in the usual ways and denote 0 without further\ninitialization:\n\n\tvar x Int        // &x is an *Int of value 0\n\tvar r = &Rat{}   // r is a *Rat of value 0\n\ty := new(Float)  // y is a *Float of value 0\n\nAlternatively, new values can be allocated and initialized with factory\nfunctions of the form:\n\n\tfunc NewT(v V) *T\n\nFor instance, NewInt(x) returns an *Int set to the value of the int64\nargument x, NewRat(a, b) returns a *Rat set to the fraction a/b where\na and b are int64 values, and NewFloat(f) returns a *Float initialized\nto the float64 argument f. More flexibility is provided with explicit\nsetters, for instance:\n\n\tvar z1 Int\n\tz1.SetUint64(123)                 // z1 := 123\n\tz2 := new(Rat).SetFloat64(1.25)   // z2 := 5/4\n\tz3 := new(Float).SetInt(z1)       // z3 := 123.0\n\nSetters, numeric operations and predicates are represented as methods of\nthe form:\n\n\tfunc (z *T) SetV(v V) *T          // z = v\n\tfunc (z *T) Unary(x *T) *T        // z = unary x\n\tfunc (z *T) Binary(x, y *T) *T    // z = x binary y\n\tfunc (x *T) Pred() P              // p = pred(x)\n\nwith T one of Int, Rat, or Float. For unary and binary operations, the\nresult is the receiver (usually named z in that case; see below); if it\nis one of the operands x or y it may be safely overwritten (and its memory\nreused).\n\nArithmetic expressions are typically written as a sequence of individual\nmethod calls, with each call corresponding to an operation. The receiver\ndenotes the result and the method arguments are the operation's operands.\nFor instance, given three *Int values a, b and c, the invocation\n\n\tc.Add(a, b)\n\ncomputes the sum a + b and stores the result in c, overwriting whatever\nvalue was held in c before. Unless specified otherwise, operations permit\naliasing of parameters, so it is perfectly ok to write\n\n\tsum.Add(sum, x)\n\nto accumulate values x in a sum.\n\n(By always passing in a result value via the receiver, memory use can be\nmuch better controlled. Instead of having to allocate new memory for each\nresult, an operation can reuse the space allocated for the result value,\nand overwrite that value with the new result in the process.)\n\nNotational convention: Incoming method parameters (including the receiver)\nare named consistently in the API to clarify their use. Incoming operands\nare usually named x, y, a, b, and so on, but never z. A parameter specifying\nthe result is named z (typically the receiver).\n\nFor instance, the arguments for (*Int).Add are named x and y, and because\nthe receiver specifies the result destination, it is called z:\n\n\tfunc (z *Int) Add(x, y *Int) *Int\n\nMethods of this form typically return the incoming receiver as well, to\nenable simple call chaining.\n\nMethods which don't require a result value to be passed in (for instance,\nInt.Sign), simply return the result. In this case, the receiver is typically\nthe first operand, named x:\n\n\tfunc (x *Int) Sign() int\n\nVarious methods support conversions between strings and corresponding\nnumeric values, and vice versa: *Int, *Rat, and *Float values implement\nthe Stringer interface for a (default) string representation of the value,\nbut also provide SetString methods to initialize a value from a string in\na variety of supported formats (see the respective SetString documentation).\n\nFinally, *Int, *Rat, and *Float satisfy the fmt package's Scanner interface\nfor scanning and (except for *Rat) the Formatter interface for formatted\nprinting.\n"
    :empty false}
  go.std.math.big)
JOKER CONSTANT UintSize from math/bits/bits.go:
(def
  ^{:doc "UintSize is the size of a uint in bits.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(bits.UintSize)"}
  UintSize)

JOKER FUNC math/bits.Add from math/bits/bits.go:
(defn Add
  "Add returns the sum with carry of x, y and carry: sum = x + y + carry.\nThe carry input must be 0 or 1; otherwise the behavior is undefined.\nThe carryOut output is guaranteed to be 0 or 1.\n\nGo input arguments: (x uint, y uint, carry uint)\n\nGo return type: (sum uint, carryOut uint)\n\nJoker input arguments: [^Number x, ^Number y, ^Number carry]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__add(__x, __y, __carry)"}
  [^UInt __x, ^UInt __y, ^UInt __carry])

JOKER FUNC math/bits.Add32 from math/bits/bits.go:
(defn Add32
  "Add32 returns the sum with carry of x, y and carry: sum = x + y + carry.\nThe carry input must be 0 or 1; otherwise the behavior is undefined.\nThe carryOut output is guaranteed to be 0 or 1.\n\nGo input arguments: (x uint32, y uint32, carry uint32)\n\nGo return type: (sum uint32, carryOut uint32)\n\nJoker input arguments: [^Number x, ^Number y, ^Number carry]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__add32(__x, __y, __carry)"}
  [^UInt32 __x, ^UInt32 __y, ^UInt32 __carry])

JOKER FUNC math/bits.Add64 from math/bits/bits.go:
(defn Add64
  "Add64 returns the sum with carry of x, y and carry: sum = x + y + carry.\nThe carry input must be 0 or 1; otherwise the behavior is undefined.\nThe carryOut output is guaranteed to be 0 or 1.\n\nGo input arguments: (x uint64, y uint64, carry uint64)\n\nGo return type: (sum uint64, carryOut uint64)\n\nJoker input arguments: [^Number x, ^Number y, ^Number carry]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__add64(__x, __y, __carry)"}
  [^UInt64 __x, ^UInt64 __y, ^UInt64 __carry])

JOKER FUNC math/bits.Div from math/bits/bits.go:
(defn Div
  "Div returns the quotient and remainder of (hi, lo) divided by y:\nquo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper\nhalf in parameter hi and the lower half in parameter lo.\nDiv panics for y == 0 (division by zero) or y <= hi (quotient overflow).\n\nGo input arguments: (hi uint, lo uint, y uint)\n\nGo return type: (quo uint, rem uint)\n\nJoker input arguments: [^Number hi, ^Number lo, ^Number y]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__div(__hi, __lo, __y)"}
  [^UInt __hi, ^UInt __lo, ^UInt __y])

JOKER FUNC math/bits.Div32 from math/bits/bits.go:
(defn Div32
  "Div32 returns the quotient and remainder of (hi, lo) divided by y:\nquo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper\nhalf in parameter hi and the lower half in parameter lo.\nDiv32 panics for y == 0 (division by zero) or y <= hi (quotient overflow).\n\nGo input arguments: (hi uint32, lo uint32, y uint32)\n\nGo return type: (quo uint32, rem uint32)\n\nJoker input arguments: [^Number hi, ^Number lo, ^Number y]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__div32(__hi, __lo, __y)"}
  [^UInt32 __hi, ^UInt32 __lo, ^UInt32 __y])

JOKER FUNC math/bits.Div64 from math/bits/bits.go:
(defn Div64
  "Div64 returns the quotient and remainder of (hi, lo) divided by y:\nquo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper\nhalf in parameter hi and the lower half in parameter lo.\nDiv64 panics for y == 0 (division by zero) or y <= hi (quotient overflow).\n\nGo input arguments: (hi uint64, lo uint64, y uint64)\n\nGo return type: (quo uint64, rem uint64)\n\nJoker input arguments: [^Number hi, ^Number lo, ^Number y]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__div64(__hi, __lo, __y)"}
  [^UInt64 __hi, ^UInt64 __lo, ^UInt64 __y])

JOKER FUNC math/bits.LeadingZeros from math/bits/bits.go:
(defn ^"Int" LeadingZeros
  "LeadingZeros returns the number of leading zero bits in x; the result is UintSize for x == 0.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros(__x)"}
  [^UInt __x])

JOKER FUNC math/bits.LeadingZeros16 from math/bits/bits.go:
(defn ^"Int" LeadingZeros16
  "LeadingZeros16 returns the number of leading zero bits in x; the result is 16 for x == 0.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros16(__x)"}
  [^UInt16 __x])

JOKER FUNC math/bits.LeadingZeros32 from math/bits/bits.go:
(defn ^"Int" LeadingZeros32
  "LeadingZeros32 returns the number of leading zero bits in x; the result is 32 for x == 0.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros32(__x)"}
  [^UInt32 __x])

JOKER FUNC math/bits.LeadingZeros64 from math/bits/bits.go:
(defn ^"Int" LeadingZeros64
  "LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0.\n\nGo input arguments: (x uint64)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros64(__x)"}
  [^UInt64 __x])

JOKER FUNC math/bits.LeadingZeros8 from math/bits/bits.go:
(defn ^"Int" LeadingZeros8
  "LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0.\n\nGo input arguments: (x uint8)\n\nGo return type: int\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros8(__x)"}
  [^UInt8 __x])

JOKER FUNC math/bits.Len from math/bits/bits.go:
(defn ^"Int" Len
  "Len returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len(__x)"}
  [^UInt __x])

JOKER FUNC math/bits.Len16 from math/bits/bits.go:
(defn ^"Int" Len16
  "Len16 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len16(__x)"}
  [^UInt16 __x])

JOKER FUNC math/bits.Len32 from math/bits/bits.go:
(defn ^"Int" Len32
  "Len32 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len32(__x)"}
  [^UInt32 __x])

JOKER FUNC math/bits.Len64 from math/bits/bits.go:
(defn ^"Int" Len64
  "Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint64)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len64(__x)"}
  [^UInt64 __x])

JOKER FUNC math/bits.Len8 from math/bits/bits.go:
(defn ^"Int" Len8
  "Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint8)\n\nGo return type: int\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len8(__x)"}
  [^UInt8 __x])

JOKER FUNC math/bits.Mul from math/bits/bits.go:
(defn Mul
  "Mul returns the full-width product of x and y: (hi, lo) = x * y\nwith the product bits' upper half returned in hi and the lower\nhalf returned in lo.\n\nGo input arguments: (x uint, y uint)\n\nGo return type: (hi uint, lo uint)\n\nJoker input arguments: [^Number x, ^Number y]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__mul(__x, __y)"}
  [^UInt __x, ^UInt __y])

JOKER FUNC math/bits.Mul32 from math/bits/bits.go:
(defn Mul32
  "Mul32 returns the 64-bit product of x and y: (hi, lo) = x * y\nwith the product bits' upper half returned in hi and the lower\nhalf returned in lo.\n\nGo input arguments: (x uint32, y uint32)\n\nGo return type: (hi uint32, lo uint32)\n\nJoker input arguments: [^Number x, ^Number y]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__mul32(__x, __y)"}
  [^UInt32 __x, ^UInt32 __y])

JOKER FUNC math/bits.Mul64 from math/bits/bits.go:
(defn Mul64
  "Mul64 returns the 128-bit product of x and y: (hi, lo) = x * y\nwith the product bits' upper half returned in hi and the lower\nhalf returned in lo.\n\nGo input arguments: (x uint64, y uint64)\n\nGo return type: (hi uint64, lo uint64)\n\nJoker input arguments: [^Number x, ^Number y]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__mul64(__x, __y)"}
  [^UInt64 __x, ^UInt64 __y])

JOKER FUNC math/bits.OnesCount from math/bits/bits.go:
(defn ^"Int" OnesCount
  "OnesCount returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount(__x)"}
  [^UInt __x])

JOKER FUNC math/bits.OnesCount16 from math/bits/bits.go:
(defn ^"Int" OnesCount16
  "OnesCount16 returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount16(__x)"}
  [^UInt16 __x])

JOKER FUNC math/bits.OnesCount32 from math/bits/bits.go:
(defn ^"Int" OnesCount32
  "OnesCount32 returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount32(__x)"}
  [^UInt32 __x])

JOKER FUNC math/bits.OnesCount64 from math/bits/bits.go:
(defn ^"Int" OnesCount64
  "OnesCount64 returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint64)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount64(__x)"}
  [^UInt64 __x])

JOKER FUNC math/bits.OnesCount8 from math/bits/bits.go:
(defn ^"Int" OnesCount8
  "OnesCount8 returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint8)\n\nGo return type: int\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount8(__x)"}
  [^UInt8 __x])

JOKER FUNC math/bits.Reverse from math/bits/bits.go:
(defn Reverse
  "Reverse returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint)\n\nGo return type: uint\n\nJoker input arguments: [^Number x]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__reverse(__x)"}
  [^UInt __x])

JOKER FUNC math/bits.Reverse16 from math/bits/bits.go:
(defn Reverse16
  "Reverse16 returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint16)\n\nGo return type: uint16\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__reverse16(__x)"}
  [^UInt16 __x])

JOKER FUNC math/bits.Reverse32 from math/bits/bits.go:
(defn Reverse32
  "Reverse32 returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^Number x]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__reverse32(__x)"}
  [^UInt32 __x])

JOKER FUNC math/bits.Reverse64 from math/bits/bits.go:
(defn Reverse64
  "Reverse64 returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint64)\n\nGo return type: uint64\n\nJoker input arguments: [^Number x]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__reverse64(__x)"}
  [^UInt64 __x])

JOKER FUNC math/bits.Reverse8 from math/bits/bits.go:
(defn Reverse8
  "Reverse8 returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint8)\n\nGo return type: uint8\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__reverse8(__x)"}
  [^UInt8 __x])

JOKER FUNC math/bits.ReverseBytes from math/bits/bits.go:
(defn ReverseBytes
  "ReverseBytes returns the value of x with its bytes in reversed order.\n\nGo input arguments: (x uint)\n\nGo return type: uint\n\nJoker input arguments: [^Number x]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__reverseBytes(__x)"}
  [^UInt __x])

JOKER FUNC math/bits.ReverseBytes16 from math/bits/bits.go:
(defn ReverseBytes16
  "ReverseBytes16 returns the value of x with its bytes in reversed order.\n\nGo input arguments: (x uint16)\n\nGo return type: uint16\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__reverseBytes16(__x)"}
  [^UInt16 __x])

JOKER FUNC math/bits.ReverseBytes32 from math/bits/bits.go:
(defn ReverseBytes32
  "ReverseBytes32 returns the value of x with its bytes in reversed order.\n\nGo input arguments: (x uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^Number x]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__reverseBytes32(__x)"}
  [^UInt32 __x])

JOKER FUNC math/bits.ReverseBytes64 from math/bits/bits.go:
(defn ReverseBytes64
  "ReverseBytes64 returns the value of x with its bytes in reversed order.\n\nGo input arguments: (x uint64)\n\nGo return type: uint64\n\nJoker input arguments: [^Number x]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__reverseBytes64(__x)"}
  [^UInt64 __x])

JOKER FUNC math/bits.RotateLeft from math/bits/bits.go:
(defn RotateLeft
  "RotateLeft returns the value of x rotated left by (k mod UintSize) bits.\nTo rotate x right by k bits, call RotateLeft(x, -k).\n\nGo input arguments: (x uint, k int)\n\nGo return type: uint\n\nJoker input arguments: [^Number x, ^Int k]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__rotateLeft(__x, __k)"}
  [^UInt __x, ^Int __k])

JOKER FUNC math/bits.RotateLeft16 from math/bits/bits.go:
(defn RotateLeft16
  "RotateLeft16 returns the value of x rotated left by (k mod 16) bits.\nTo rotate x right by k bits, call RotateLeft16(x, -k).\n\nGo input arguments: (x uint16, k int)\n\nGo return type: uint16\n\nJoker input arguments: [^Int x, ^Int k]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__rotateLeft16(__x, __k)"}
  [^UInt16 __x, ^Int __k])

JOKER FUNC math/bits.RotateLeft32 from math/bits/bits.go:
(defn RotateLeft32
  "RotateLeft32 returns the value of x rotated left by (k mod 32) bits.\nTo rotate x right by k bits, call RotateLeft32(x, -k).\n\nGo input arguments: (x uint32, k int)\n\nGo return type: uint32\n\nJoker input arguments: [^Number x, ^Int k]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__rotateLeft32(__x, __k)"}
  [^UInt32 __x, ^Int __k])

JOKER FUNC math/bits.RotateLeft64 from math/bits/bits.go:
(defn RotateLeft64
  "RotateLeft64 returns the value of x rotated left by (k mod 64) bits.\nTo rotate x right by k bits, call RotateLeft64(x, -k).\n\nGo input arguments: (x uint64, k int)\n\nGo return type: uint64\n\nJoker input arguments: [^Number x, ^Int k]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__rotateLeft64(__x, __k)"}
  [^UInt64 __x, ^Int __k])

JOKER FUNC math/bits.RotateLeft8 from math/bits/bits.go:
(defn RotateLeft8
  "RotateLeft8 returns the value of x rotated left by (k mod 8) bits.\nTo rotate x right by k bits, call RotateLeft8(x, -k).\n\nGo input arguments: (x uint8, k int)\n\nGo return type: uint8\n\nJoker input arguments: [^Int x, ^Int k]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__rotateLeft8(__x, __k)"}
  [^UInt8 __x, ^Int __k])

JOKER FUNC math/bits.Sub from math/bits/bits.go:
(defn Sub
  "Sub returns the difference of x, y and borrow: diff = x - y - borrow.\nThe borrow input must be 0 or 1; otherwise the behavior is undefined.\nThe borrowOut output is guaranteed to be 0 or 1.\n\nGo input arguments: (x uint, y uint, borrow uint)\n\nGo return type: (diff uint, borrowOut uint)\n\nJoker input arguments: [^Number x, ^Number y, ^Number borrow]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__sub(__x, __y, __borrow)"}
  [^UInt __x, ^UInt __y, ^UInt __borrow])

JOKER FUNC math/bits.Sub32 from math/bits/bits.go:
(defn Sub32
  "Sub32 returns the difference of x, y and borrow, diff = x - y - borrow.\nThe borrow input must be 0 or 1; otherwise the behavior is undefined.\nThe borrowOut output is guaranteed to be 0 or 1.\n\nGo input arguments: (x uint32, y uint32, borrow uint32)\n\nGo return type: (diff uint32, borrowOut uint32)\n\nJoker input arguments: [^Number x, ^Number y, ^Number borrow]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__sub32(__x, __y, __borrow)"}
  [^UInt32 __x, ^UInt32 __y, ^UInt32 __borrow])

JOKER FUNC math/bits.Sub64 from math/bits/bits.go:
(defn Sub64
  "Sub64 returns the difference of x, y and borrow: diff = x - y - borrow.\nThe borrow input must be 0 or 1; otherwise the behavior is undefined.\nThe borrowOut output is guaranteed to be 0 or 1.\n\nGo input arguments: (x uint64, y uint64, borrow uint64)\n\nGo return type: (diff uint64, borrowOut uint64)\n\nJoker input arguments: [^Number x, ^Number y, ^Number borrow]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__sub64(__x, __y, __borrow)"}
  [^UInt64 __x, ^UInt64 __y, ^UInt64 __borrow])

JOKER FUNC math/bits.TrailingZeros from math/bits/bits.go:
(defn ^"Int" TrailingZeros
  "TrailingZeros returns the number of trailing zero bits in x; the result is UintSize for x == 0.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros(__x)"}
  [^UInt __x])

JOKER FUNC math/bits.TrailingZeros16 from math/bits/bits.go:
(defn ^"Int" TrailingZeros16
  "TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros16(__x)"}
  [^UInt16 __x])

JOKER FUNC math/bits.TrailingZeros32 from math/bits/bits.go:
(defn ^"Int" TrailingZeros32
  "TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros32(__x)"}
  [^UInt32 __x])

JOKER FUNC math/bits.TrailingZeros64 from math/bits/bits.go:
(defn ^"Int" TrailingZeros64
  "TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.\n\nGo input arguments: (x uint64)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros64(__x)"}
  [^UInt64 __x])

JOKER FUNC math/bits.TrailingZeros8 from math/bits/bits.go:
(defn ^"Int" TrailingZeros8
  "TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.\n\nGo input arguments: (x uint8)\n\nGo return type: int\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros8(__x)"}
  [^UInt8 __x])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["math/bits"]
    :doc "Provides a low-level interface to the math/bits package.\n\nPackage bits implements bit counting and manipulation\nfunctions for the predeclared unsigned integer types.\n"
    :empty false}
  go.std.math.bits)
JOKER FUNC math/cmplx.Abs from math/cmplx/abs.go:
;; (defn Abs
;;   "Abs returns the absolute value (also called the modulus) of x.\n\nGo input arguments: (x complex128)\n\nGo return type: float64\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__abs(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.Acos from math/cmplx/asin.go:
;; (defn Acos
;;   "Acos returns the inverse cosine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__acos(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.Acosh from math/cmplx/asin.go:
;; (defn Acosh
;;   "Acosh returns the inverse hyperbolic cosine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__acosh(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.Asin from math/cmplx/asin.go:
;; (defn Asin
;;   "Asin returns the inverse sine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__asin(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.Asinh from math/cmplx/asin.go:
;; (defn Asinh
;;   "Asinh returns the inverse hyperbolic sine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__asinh(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.Atan from math/cmplx/asin.go:
;; (defn Atan
;;   "Atan returns the inverse tangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__atan(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.Atanh from math/cmplx/asin.go:
;; (defn Atanh
;;   "Atanh returns the inverse hyperbolic tangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__atanh(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.Conj from math/cmplx/conj.go:
;; (defn Conj
;;   "Conj returns the complex conjugate of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__conj(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.Cos from math/cmplx/sin.go:
;; (defn Cos
;;   "Cos returns the cosine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__cos(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.Cosh from math/cmplx/sin.go:
;; (defn Cosh
;;   "Cosh returns the hyperbolic cosine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__cosh(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.Cot from math/cmplx/tan.go:
;; (defn Cot
;;   "Cot returns the cotangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__cot(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.Exp from math/cmplx/exp.go:
;; (defn Exp
;;   "Exp returns e**x, the base-e exponential of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__exp(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.Inf from math/cmplx/isinf.go:
;; (defn Inf
;;   "Inf returns a complex infinity, complex(+Inf, +Inf).\n\nGo return type: complex128\n\nJoker input arguments: []\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__inf()"}
;;   [])

JOKER FUNC math/cmplx.IsInf from math/cmplx/isinf.go:
;; (defn ^"Boolean" IsInf
;;   "IsInf reports whether either real(x) or imag(x) is an infinity.\n\nGo input arguments: (x complex128)\n\nGo return type: bool\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "cmplx.IsInf(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.IsNaN from math/cmplx/isnan.go:
;; (defn ^"Boolean" IsNaN
;;   "IsNaN reports whether either real(x) or imag(x) is NaN\nand neither is an infinity.\n\nGo input arguments: (x complex128)\n\nGo return type: bool\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "cmplx.IsNaN(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.Log from math/cmplx/log.go:
;; (defn Log
;;   "Log returns the natural logarithm of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__log(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.Log10 from math/cmplx/log.go:
;; (defn Log10
;;   "Log10 returns the decimal logarithm of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__log10(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.NaN from math/cmplx/isnan.go:
;; (defn NaN
;;   "NaN returns a complex ``not-a-number'' value.\n\nGo return type: complex128\n\nJoker input arguments: []\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__naN()"}
;;   [])

JOKER FUNC math/cmplx.Phase from math/cmplx/phase.go:
;; (defn Phase
;;   "Phase returns the phase (also called the argument) of x.\nThe returned value is in the range [-Pi, Pi].\n\nGo input arguments: (x complex128)\n\nGo return type: float64\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__phase(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.Polar from math/cmplx/polar.go:
;; (defn Polar
;;   "Polar returns the absolute value r and phase θ of x,\nsuch that x = r * e**θi.\nThe phase is in the range [-Pi, Pi].\n\nGo input arguments: (x complex128)\n\nGo return type: (r float64, θ float64)\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: [Double Double]"
;;   {:added "1.0"
;;    :go "__polar(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.Pow from math/cmplx/pow.go:
;; (defn Pow
;;   "Pow returns x**y, the base-x exponential of y.\nFor generalized compatibility with math.Pow:\n\tPow(0, ±0) returns 1+0i\n\tPow(0, c) for real(c)<0 returns Inf+0i if imag(c) is zero, otherwise Inf+Inf i.\n\nGo input arguments: (x complex128, y complex128)\n\nGo return type: complex128\n\nJoker input arguments: [^ABEND007(find these) x, ^ABEND007(find these) y]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__pow(__x, __y)"}
;;   [^ABEND007(find these) __x, ^ABEND007(find these) __y])

JOKER FUNC math/cmplx.Rect from math/cmplx/rect.go:
;; (defn Rect
;;   "Rect returns the complex number x with polar coordinates r, θ.\n\nGo input arguments: (r float64, θ float64)\n\nGo return type: complex128\n\nJoker input arguments: [^Double r, ^Double θ]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__rect(__r, __θ)"}
;;   [^ABEND007(find these) __r, ^ABEND007(find these) __θ])

JOKER FUNC math/cmplx.Sin from math/cmplx/sin.go:
;; (defn Sin
;;   "Sin returns the sine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__sin(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.Sinh from math/cmplx/sin.go:
;; (defn Sinh
;;   "Sinh returns the hyperbolic sine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__sinh(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.Sqrt from math/cmplx/sqrt.go:
;; (defn Sqrt
;;   "Sqrt returns the square root of x.\nThe result r is chosen so that real(r) ≥ 0 and imag(r) has the same sign as imag(x).\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__sqrt(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.Tan from math/cmplx/tan.go:
;; (defn Tan
;;   "Tan returns the tangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__tan(__x)"}
;;   [^ABEND007(find these) __x])

JOKER FUNC math/cmplx.Tanh from math/cmplx/tan.go:
;; (defn Tanh
;;   "Tanh returns the hyperbolic tangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [^ABEND007(find these) x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__tanh(__x)"}
;;   [^ABEND007(find these) __x])

JOKER TYPE math/rand.Rand from math/rand/rand.go:
(defn ^"GoObject" Rand.
  "Constructor for rand.Rand"
  {:added "1.0"
   :go "_ConstructRand(_v)"}
  [^Object _v])

JOKER TYPE math/rand.Source from math/rand/rand.go:
;; (defn ^"GoObject" Source.
;;   "Constructor for rand.Source"
;;   {:added "1.0"
;;    :go "_ConstructSource(_v)"}
;;   [^Object _v])

JOKER TYPE math/rand.Source64 from math/rand/rand.go:
;; (defn ^"GoObject" Source64.
;;   "Constructor for rand.Source64"
;;   {:added "1.0"
;;    :go "_ConstructSource64(_v)"}
;;   [^Object _v])

JOKER TYPE math/rand.Zipf from math/rand/zipf.go:
(defn ^"GoObject" Zipf.
  "Constructor for rand.Zipf"
  {:added "1.0"
   :go "_ConstructZipf(_v)"}
  [^Object _v])

JOKER FUNC math/rand.ExpFloat64 from math/rand/rand.go:
;; (defn ExpFloat64
;;   "ExpFloat64 returns an exponentially distributed float64 in the range\n(0, +math.MaxFloat64] with an exponential distribution whose rate parameter\n(lambda) is 1 and whose mean is 1/lambda (1) from the default Source.\nTo produce a distribution with a different rate parameter,\ncallers can adjust the output using:\n\n sample = ExpFloat64() / desiredRateParameter\n\nGo return type: float64\n\nJoker input arguments: []\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__expFloat64()"}
;;   [])

JOKER FUNC math/rand.Float32 from math/rand/rand.go:
;; (defn Float32
;;   "Float32 returns, as a float32, a pseudo-random number in [0.0,1.0)\nfrom the default Source.\n\nGo return type: float32\n\nJoker input arguments: []\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__float32()"}
;;   [])

JOKER FUNC math/rand.Float64 from math/rand/rand.go:
;; (defn Float64
;;   "Float64 returns, as a float64, a pseudo-random number in [0.0,1.0)\nfrom the default Source.\n\nGo return type: float64\n\nJoker input arguments: []\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__float64()"}
;;   [])

JOKER FUNC math/rand.Int from math/rand/rand.go:
(defn ^"Int" Int
  "Int returns a non-negative pseudo-random int from the default Source.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "rand.Int()"}
  [])

JOKER FUNC math/rand.Int31 from math/rand/rand.go:
(defn Int31
  "Int31 returns a non-negative pseudo-random 31-bit integer as an int32\nfrom the default Source.\n\nGo return type: int32\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "__int31()"}
  [])

JOKER FUNC math/rand.Int31n from math/rand/rand.go:
(defn Int31n
  "Int31n returns, as an int32, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\n\nGo input arguments: (n int32)\n\nGo return type: int32\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__int31n(__n)"}
  [^Int32 __n])

JOKER FUNC math/rand.Int63 from math/rand/rand.go:
(defn Int63
  "Int63 returns a non-negative pseudo-random 63-bit integer as an int64\nfrom the default Source.\n\nGo return type: int64\n\nJoker input arguments: []\n\nJoker return type: Number"
  {:added "1.0"
   :go "__int63()"}
  [])

JOKER FUNC math/rand.Int63n from math/rand/rand.go:
(defn Int63n
  "Int63n returns, as an int64, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\n\nGo input arguments: (n int64)\n\nGo return type: int64\n\nJoker input arguments: [^Number n]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__int63n(__n)"}
  [^Int64 __n])

JOKER FUNC math/rand.Intn from math/rand/rand.go:
(defn ^"Int" Intn
  "Intn returns, as an int, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\n\nGo input arguments: (n int)\n\nGo return type: int\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "rand.Intn(__n)"}
  [^Int __n])

JOKER FUNC math/rand.New from math/rand/rand.go:
(defn New
  "New returns a new Rand that uses random values from src\nto generate other random values.\n\nGo input arguments: (src Source)\n\nGo return type: *Rand\n\nJoker input arguments: [^go.std.math.rand/Source src]\n\nJoker return type: (atom-of go.std.math.rand/Rand)"
  {:added "1.0"
   :go "__new(*__src)"}
  [^rand/Source __src])

JOKER FUNC math/rand.NewSource from math/rand/rand.go:
(defn NewSource
  "NewSource returns a new pseudo-random Source seeded with the given value.\nUnlike the default Source used by top-level functions, this source is not\nsafe for concurrent use by multiple goroutines.\n\nGo input arguments: (seed int64)\n\nGo return type: Source\n\nJoker input arguments: [^Number seed]\n\nJoker return type: go.std.math.rand/Source"
  {:added "1.0"
   :go "__newSource(__seed)"}
  [^Int64 __seed])

JOKER FUNC math/rand.NewZipf from math/rand/zipf.go:
;; (defn NewZipf
;;   "NewZipf returns a Zipf variate generator.\nThe generator generates values k ∈ [0, imax]\nsuch that P(k) is proportional to (v + k) ** (-s).\nRequirements: s > 1 and v >= 1.\n\nGo input arguments: (r *Rand, s float64, v float64, imax uint64)\n\nGo return type: *Zipf\n\nJoker input arguments: [^(atom-of go.std.math.rand/Rand) r, ^Double s, ^Double v, ^Number imax]\n\nJoker return type: (atom-of go.std.math.rand/Zipf)"
;;   {:added "1.0"
;;    :go "__newZipf(__r, __s, __v, __imax)"}
;;   [^rand/Rand __r, ^ABEND007(find these) __s, ^ABEND007(find these) __v, ^UInt64 __imax])

JOKER FUNC math/rand.NormFloat64 from math/rand/rand.go:
;; (defn NormFloat64
;;   "NormFloat64 returns a normally distributed float64 in the range\n[-math.MaxFloat64, +math.MaxFloat64] with\nstandard normal distribution (mean = 0, stddev = 1)\nfrom the default Source.\nTo produce a different normal distribution, callers can\nadjust the output using:\n\n sample = NormFloat64() * desiredStdDev + desiredMean\n\nGo return type: float64\n\nJoker input arguments: []\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__normFloat64()"}
;;   [])

JOKER FUNC math/rand.Perm from math/rand/rand.go:
(defn Perm
  "Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n)\nfrom the default Source.\n\nGo input arguments: (n int)\n\nGo return type: []int\n\nJoker input arguments: [^Int n]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__perm(__n)"}
  [^Int __n])

JOKER FUNC math/rand.Read from math/rand/rand.go:
;; (defn Read
;;   "Read generates len(p) random bytes from the default Source and\nwrites them into p. It always returns len(p) and a nil error.\nRead, unlike the Rand.Read method, is safe for concurrent use.\n\nGo input arguments: (p []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(vector-of Int) p]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__read(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)))"}
;;   [^Object __p])

JOKER FUNC math/rand.Seed from math/rand/rand.go:
;; (defn Seed
;;   "Seed uses the provided seed value to initialize the default Source to a\ndeterministic state. If Seed is not called, the generator behaves as\nif seeded by Seed(1). Seed values that have the same remainder when\ndivided by 2^31-1 generate the same pseudo-random sequence.\nSeed, unlike the Rand.Seed method, is safe for concurrent use.\n\nGo input arguments: (seed int64)\n\nJoker input arguments: [^Number seed]"
;;   {:added "1.0"
;;    :go "__seed(__seed)"}
;;   [^Int64 __seed])

JOKER FUNC math/rand.Shuffle from math/rand/rand.go:
;; (defn Shuffle
;;   "Shuffle pseudo-randomizes the order of elements using the default Source.\nn is the number of elements. Shuffle panics if n < 0.\nswap swaps the elements with indexes i and j.\n\nGo input arguments: (n int, swap func)\n\nJoker input arguments: [^Int n, ^fn swap]"
;;   {:added "1.0"
;;    :go "__shuffle(__n, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Int __n, ^fn __swap])

JOKER FUNC math/rand.Uint32 from math/rand/rand.go:
(defn Uint32
  "Uint32 returns a pseudo-random 32-bit value as a uint32\nfrom the default Source.\n\nGo return type: uint32\n\nJoker input arguments: []\n\nJoker return type: Number"
  {:added "1.0"
   :go "__uint32()"}
  [])

JOKER FUNC math/rand.Uint64 from math/rand/rand.go:
(defn Uint64
  "Uint64 returns a pseudo-random 64-bit value as a uint64\nfrom the default Source.\n\nGo return type: uint64\n\nJoker input arguments: []\n\nJoker return type: Number"
  {:added "1.0"
   :go "__uint64()"}
  [])

JOKER TYPE go.std.math.rand/Rand:
(def
  ^{:doc "A Rand is a source of random numbers.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Rand"}
  Rand)

JOKER TYPE go.std.math.rand/Source:
(def
  ^{:doc "A Source represents a source of uniformly-distributed\npseudo-random int64 values in the range [0, 1<<63).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Source"}
  Source)

JOKER TYPE go.std.math.rand/Source64:
(def
  ^{:doc "A Source64 is a Source that can also generate\nuniformly-distributed pseudo-random uint64 values in\nthe range [0, 1<<64) directly.\nIf a Rand r's underlying Source s implements Source64,\nthen r.Uint64 returns the result of one call to s.Uint64\ninstead of making two calls to s.Int63.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Source64"}
  Source64)

JOKER TYPE go.std.math.rand/Zipf:
(def
  ^{:doc "A Zipf generates Zipf distributed variates.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Zipf"}
  Zipf)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["math/rand"]
    :doc "Provides a low-level interface to the math/rand package.\n\nPackage rand implements pseudo-random number generators.\n\nRandom numbers are generated by a Source. Top-level functions, such as\nFloat64 and Int, use a default shared Source that produces a deterministic\nsequence of values each time a program is run. Use the Seed function to\ninitialize the default Source if different behavior is required for each run.\nThe default Source is safe for concurrent use by multiple goroutines, but\nSources created by NewSource are not.\n\nMathematical interval notation such as [0, n) is used throughout the\ndocumentation for this package.\n\nFor random numbers suitable for security-sensitive work, see the crypto/rand\npackage.\n"
    :empty false}
  go.std.math.rand)
JOKER CONSTANT BEncoding from mime/encodedword.go:
(def
  ^{:doc "BEncoding represents Base64 encoding scheme as defined by RFC 2045.\n"
    :added "1.0"
    :tag "Int"
    :go "int(mime.BEncoding)"}
  BEncoding)

JOKER CONSTANT QEncoding from mime/encodedword.go:
(def
  ^{:doc "QEncoding represents the Q-encoding scheme as defined by RFC 2047.\n"
    :added "1.0"
    :tag "Int"
    :go "int(mime.QEncoding)"}
  QEncoding)

JOKER VARIABLE ErrInvalidMediaParameter from mime/mediatype.go:
(def
  ^{:doc "ErrInvalidMediaParameter is returned by ParseMediaType if\nthe media type value was found but there was an error parsing\nthe optional parameters\n"
    :added "1.0"
    :tag "Var"
    :go "mime.ErrInvalidMediaParameter"}
  ErrInvalidMediaParameter)

JOKER TYPE mime.WordDecoder from mime/encodedword.go:
;; (defn ^"GoObject" WordDecoder.
;;   "Constructor for mime.WordDecoder"
;;   {:added "1.0"
;;    :go "_ConstructWordDecoder(_v)"}
;;   [^Object _v])

JOKER TYPE mime.WordEncoder from mime/encodedword.go:
(defn ^"GoObject" WordEncoder.
  "Constructor for mime.WordEncoder"
  {:added "1.0"
   :go "_ConstructWordEncoder(_v)"}
  [^Object _v])

JOKER FUNC mime.AddExtensionType from mime/type.go:
(defn ^"Error" AddExtensionType
  "AddExtensionType sets the MIME type associated with\nthe extension ext to typ. The extension should begin with\na leading dot, as in \".html\".\n\nGo input arguments: (ext string, typ string)\n\nGo return type: error\n\nJoker input arguments: [^String ext, ^String typ]\n\nJoker return type: Error"
  {:added "1.0"
   :go "mime.AddExtensionType(__ext, __typ)"}
  [^String __ext, ^String __typ])

JOKER FUNC mime.ExtensionsByType from mime/type.go:
(defn ExtensionsByType
  "ExtensionsByType returns the extensions known to be associated with the MIME\ntype typ. The returned extensions will each begin with a leading dot, as in\n\".html\". When typ has no associated extensions, ExtensionsByType returns an\nnil slice.\n\nGo input arguments: (typ string)\n\nGo return type: ([]string, error)\n\nJoker input arguments: [^String typ]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__extensionsByType(__typ)"}
  [^String __typ])

JOKER FUNC mime.FormatMediaType from mime/mediatype.go:
;; (defn ^"String" FormatMediaType
;;   "FormatMediaType serializes mediatype t and the parameters\nparam as a media type conforming to RFC 2045 and RFC 2616.\nThe type and parameter names are written in lower-case.\nWhen any of the arguments result in a standard violation then\nFormatMediaType returns the empty string.\n\nGo input arguments: (t string, param map[])\n\nGo return type: string\n\nJoker input arguments: [^String t, ^{} param]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "mime.FormatMediaType(__t, ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa()))"}
;;   [^String __t, ^{} __param])

JOKER FUNC mime.ParseMediaType from mime/mediatype.go:
;; (defn ParseMediaType
;;   "ParseMediaType parses a media type value and any optional\nparameters, per RFC 1521.  Media types are the values in\nContent-Type and Content-Disposition headers (RFC 2183).\nOn success, ParseMediaType returns the media type converted\nto lowercase and trimmed of white space and a non-nil map.\nIf there is an error parsing the optional parameter,\nthe media type will be returned along with the error\nErrInvalidMediaParameter.\nThe returned map, params, maps from the lowercase\nattribute to the attribute value with its case preserved.\n\nGo input arguments: (v string)\n\nGo return type: (mediatype string, params ..., err error)\n\nJoker input arguments: [^String v]\n\nJoker return type: [String ABEND883(post.go: unrecognized Expr type *ast.MapType at: /usr/local/go/src/mime/mediatype.go:112:57) Error]"
;;   {:added "1.0"
;;    :go "__parseMediaType(__v)"}
;;   [^String __v])

JOKER FUNC mime.TypeByExtension from mime/type.go:
(defn ^"String" TypeByExtension
  "TypeByExtension returns the MIME type associated with the file extension ext.\nThe extension ext should begin with a leading dot, as in \".html\".\nWhen ext has no associated type, TypeByExtension returns \"\".\n\nExtensions are looked up first case-sensitively, then case-insensitively.\n\nThe built-in table is small but on unix it is augmented by the local\nsystem's mime.types file(s) if available under one or more of these\nnames:\n\n  /etc/mime.types\n  /etc/apache2/mime.types\n  /etc/apache/mime.types\n\nOn Windows, MIME types are extracted from the registry.\n\nText types have the charset parameter set to \"utf-8\" by default.\n\nGo input arguments: (ext string)\n\nGo return type: string\n\nJoker input arguments: [^String ext]\n\nJoker return type: String"
  {:added "1.0"
   :go "mime.TypeByExtension(__ext)"}
  [^String __ext])

JOKER TYPE go.std.mime/WordDecoder:
(def
  ^{:doc "A WordDecoder decodes MIME headers containing RFC 2047 encoded-words.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_WordDecoder"}
  WordDecoder)

JOKER TYPE go.std.mime/WordEncoder:
(def
  ^{:doc "A WordEncoder is an RFC 2047 encoded-word encoder.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_WordEncoder"}
  WordEncoder)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["mime"]
    :doc "Provides a low-level interface to the mime package.\n\nPackage mime implements parts of the MIME spec.\n"
    :empty false}
  go.std.mime)
JOKER VARIABLE ErrMessageTooLarge from mime/multipart/formdata.go:
(def
  ^{:doc "ErrMessageTooLarge is returned by ReadForm if the message form\ndata is too large to be processed.\n"
    :added "1.0"
    :tag "Var"
    :go "multipart.ErrMessageTooLarge"}
  ErrMessageTooLarge)

JOKER TYPE mime/multipart.File from mime/multipart/formdata.go:
;; (defn ^"GoObject" File.
;;   "Constructor for multipart.File"
;;   {:added "1.0"
;;    :go "_ConstructFile(_v)"}
;;   [^Object _v])

JOKER TYPE mime/multipart.FileHeader from mime/multipart/formdata.go:
;; (defn ^"GoObject" FileHeader.
;;   "Constructor for multipart.FileHeader"
;;   {:added "1.0"
;;    :go "_ConstructFileHeader(_v)"}
;;   [^Object _v])

JOKER TYPE mime/multipart.Form from mime/multipart/formdata.go:
;; (defn ^"GoObject" Form.
;;   "Constructor for multipart.Form"
;;   {:added "1.0"
;;    :go "_ConstructForm(_v)"}
;;   [^Object _v])

JOKER TYPE mime/multipart.Part from mime/multipart/multipart.go:
;; (defn ^"GoObject" Part.
;;   "Constructor for multipart.Part"
;;   {:added "1.0"
;;    :go "_ConstructPart(_v)"}
;;   [^Object _v])

JOKER TYPE mime/multipart.Reader from mime/multipart/multipart.go:
(defn ^"GoObject" Reader.
  "Constructor for multipart.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER TYPE mime/multipart.Writer from mime/multipart/writer.go:
(defn ^"GoObject" Writer.
  "Constructor for multipart.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC mime/multipart.NewReader from mime/multipart/multipart.go:
;; (defn NewReader
;;   "NewReader creates a new multipart Reader reading from r using the\ngiven MIME boundary.\n\nThe boundary is usually obtained from the \"boundary\" parameter of\nthe message's \"Content-Type\" header. Use mime.ParseMediaType to\nparse such headers.\n\nGo input arguments: (r io.Reader, boundary string)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader r, ^String boundary]\n\nJoker return type: (atom-of go.std.mime.multipart/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(*__r, __boundary)"}
;;   [^io/Reader __r, ^String __boundary])

JOKER FUNC mime/multipart.NewWriter from mime/multipart/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new multipart Writer with a random boundary,\nwriting to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.mime.multipart/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*__w)"}
;;   [^io/Writer __w])

JOKER TYPE go.std.mime.multipart/File:
(def
  ^{:doc "File is an interface to access the file part of a multipart message.\nIts contents may be either stored in memory or on disk.\nIf stored on disk, the File's underlying concrete type will be an *os.File.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_File"}
  File)

JOKER TYPE go.std.mime.multipart/FileHeader:
(def
  ^{:doc "A FileHeader describes a file part of a multipart request.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FileHeader"}
  FileHeader)

JOKER TYPE go.std.mime.multipart/Form:
(def
  ^{:doc "Form is a parsed multipart form.\nIts File parts are stored either in memory or on disk,\nand are accessible via the *FileHeader's Open method.\nIts Value parts are stored as strings.\nBoth are keyed by field name.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Form"}
  Form)

JOKER TYPE go.std.mime.multipart/Part:
(def
  ^{:doc "A Part represents a single part in a multipart body.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Part"}
  Part)

JOKER TYPE go.std.mime.multipart/Reader:
(def
  ^{:doc "Reader is an iterator over parts in a MIME multipart body.\nReader's underlying parser consumes its input as needed. Seeking\nisn't supported.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Reader"}
  Reader)

JOKER TYPE go.std.mime.multipart/Writer:
(def
  ^{:doc "A Writer generates multipart messages.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Writer"}
  Writer)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["mime/multipart"]
    :doc "Provides a low-level interface to the mime/multipart package.\n\nPackage multipart implements MIME multipart parsing, as defined in RFC\n2046.\n\nThe implementation is sufficient for HTTP (RFC 2388) and the multipart\nbodies generated by popular browsers.\n"
    :empty false}
  go.std.mime.multipart)
JOKER TYPE mime/quotedprintable.Reader from mime/quotedprintable/reader.go:
(defn ^"GoObject" Reader.
  "Constructor for quotedprintable.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER TYPE mime/quotedprintable.Writer from mime/quotedprintable/writer.go:
(defn ^"GoObject" Writer.
  "Constructor for quotedprintable.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC mime/quotedprintable.NewReader from mime/quotedprintable/reader.go:
;; (defn NewReader
;;   "NewReader returns a quoted-printable reader, decoding from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.mime.quotedprintable/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC mime/quotedprintable.NewWriter from mime/quotedprintable/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer that writes to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.mime.quotedprintable/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*__w)"}
;;   [^io/Writer __w])

JOKER TYPE go.std.mime.quotedprintable/Reader:
(def
  ^{:doc "Reader is a quoted-printable decoder.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Reader"}
  Reader)

JOKER TYPE go.std.mime.quotedprintable/Writer:
(def
  ^{:doc "A Writer is a quoted-printable writer that implements io.WriteCloser.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Writer"}
  Writer)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the mime/quotedprintable package.\n\nPackage quotedprintable implements quoted-printable encoding as specified by\nRFC 2045.\n"
    :empty false}
  go.std.mime.quotedprintable)
JOKER CONSTANT FlagBroadcast from net/interface.go:
(def
  ^{:doc "interface supports broadcast access capability\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(net.FlagBroadcast))"}
  FlagBroadcast)

JOKER CONSTANT FlagLoopback from net/interface.go:
(def
  ^{:doc "interface is a loopback interface\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(net.FlagLoopback))"}
  FlagLoopback)

JOKER CONSTANT FlagMulticast from net/interface.go:
(def
  ^{:doc "interface supports multicast access capability\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(net.FlagMulticast))"}
  FlagMulticast)

JOKER CONSTANT FlagPointToPoint from net/interface.go:
(def
  ^{:doc "interface belongs to a point-to-point link\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(net.FlagPointToPoint))"}
  FlagPointToPoint)

JOKER CONSTANT FlagUp from net/interface.go:
(def
  ^{:doc "interface is up\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(net.FlagUp))"}
  FlagUp)

JOKER CONSTANT IPv4len from net/ip.go:
(def
  ^{:doc "IP address lengths (bytes).\n"
    :added "1.0"
    :tag "Int"
    :go "net.IPv4len"}
  IPv4len)

JOKER CONSTANT IPv6len from net/ip.go:
(def
  ^{:doc "IP address lengths (bytes).\n"
    :added "1.0"
    :tag "Int"
    :go "net.IPv6len"}
  IPv6len)

JOKER VARIABLE DefaultResolver from net/lookup.go:
(def
  ^{:doc "DefaultResolver is the resolver used by the package-level Lookup\nfunctions and by Dialers without a specified Resolver.\n"
    :added "1.0"
    :tag "Var"
    :go "net.DefaultResolver"}
  DefaultResolver)

JOKER VARIABLE ErrWriteToConnected from net/net.go:
(def
  ^{:doc "Various errors contained in OpError.\n"
    :added "1.0"
    :tag "Var"
    :go "net.ErrWriteToConnected"}
  ErrWriteToConnected)

JOKER VARIABLE IPv4allrouter from net/ip.go:
(def
  ^{:doc "all routers\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv4allrouter"}
  IPv4allrouter)

JOKER VARIABLE IPv4allsys from net/ip.go:
(def
  ^{:doc "all systems\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv4allsys"}
  IPv4allsys)

JOKER VARIABLE IPv4bcast from net/ip.go:
(def
  ^{:doc "limited broadcast\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv4bcast"}
  IPv4bcast)

JOKER VARIABLE IPv4zero from net/ip.go:
(def
  ^{:doc "all zeros\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv4zero"}
  IPv4zero)

JOKER VARIABLE IPv6interfacelocalallnodes from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6interfacelocalallnodes"}
  IPv6interfacelocalallnodes)

JOKER VARIABLE IPv6linklocalallnodes from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6linklocalallnodes"}
  IPv6linklocalallnodes)

JOKER VARIABLE IPv6linklocalallrouters from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6linklocalallrouters"}
  IPv6linklocalallrouters)

JOKER VARIABLE IPv6loopback from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6loopback"}
  IPv6loopback)

JOKER VARIABLE IPv6unspecified from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6unspecified"}
  IPv6unspecified)

JOKER VARIABLE IPv6zero from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6zero"}
  IPv6zero)

JOKER TYPE net.Addr from net/net.go:
;; (defn ^"GoObject" Addr.
;;   "Constructor for net.Addr"
;;   {:added "1.0"
;;    :go "_ConstructAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.AddrError from net/net.go:
(defn ^"GoObject" AddrError.
  "Constructor for net.AddrError"
  {:added "1.0"
   :go "_ConstructAddrError(_v)"}
  [^Object _v])

JOKER TYPE net.Buffers from net/net.go:
;; (defn ^"GoObject" Buffers.
;;   "Constructor for net.Buffers"
;;   {:added "1.0"
;;    :go "_ConstructBuffers(_v)"}
;;   [^Object _v])

JOKER TYPE net.Conn from net/net.go:
;; (defn ^"GoObject" Conn.
;;   "Constructor for net.Conn"
;;   {:added "1.0"
;;    :go "_ConstructConn(_v)"}
;;   [^Object _v])

JOKER TYPE net.DNSConfigError from net/net.go:
(defn ^"GoObject" DNSConfigError.
  "Constructor for net.DNSConfigError"
  {:added "1.0"
   :go "_ConstructDNSConfigError(_v)"}
  [^Object _v])

JOKER TYPE net.DNSError from net/net.go:
(defn ^"GoObject" DNSError.
  "Constructor for net.DNSError"
  {:added "1.0"
   :go "_ConstructDNSError(_v)"}
  [^Object _v])

JOKER TYPE net.Dialer from net/dial.go:
;; (defn ^"GoObject" Dialer.
;;   "Constructor for net.Dialer"
;;   {:added "1.0"
;;    :go "_ConstructDialer(_v)"}
;;   [^Object _v])

JOKER TYPE net.Error from net/net.go:
;; (defn ^"GoObject" Error.
;;   "Constructor for net.Error"
;;   {:added "1.0"
;;    :go "_ConstructError(_v)"}
;;   [^Object _v])

JOKER TYPE net.Flags from net/interface.go:
(defn ^"GoObject" Flags.
  "Constructor for net.Flags"
  {:added "1.0"
   :go "_ConstructFlags(_v)"}
  [^Object _v])

JOKER TYPE net.HardwareAddr from net/mac.go:
;; (defn ^"GoObject" HardwareAddr.
;;   "Constructor for net.HardwareAddr"
;;   {:added "1.0"
;;    :go "_ConstructHardwareAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.IP from net/ip.go:
;; (defn ^"GoObject" IP.
;;   "Constructor for net.IP"
;;   {:added "1.0"
;;    :go "_ConstructIP(_v)"}
;;   [^Object _v])

JOKER TYPE net.IPAddr from net/iprawsock.go:
;; (defn ^"GoObject" IPAddr.
;;   "Constructor for net.IPAddr"
;;   {:added "1.0"
;;    :go "_ConstructIPAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.IPConn from net/iprawsock.go:
(defn ^"GoObject" IPConn.
  "Constructor for net.IPConn"
  {:added "1.0"
   :go "_ConstructIPConn(_v)"}
  [^Object _v])

JOKER TYPE net.IPMask from net/ip.go:
;; (defn ^"GoObject" IPMask.
;;   "Constructor for net.IPMask"
;;   {:added "1.0"
;;    :go "_ConstructIPMask(_v)"}
;;   [^Object _v])

JOKER TYPE net.IPNet from net/ip.go:
;; (defn ^"GoObject" IPNet.
;;   "Constructor for net.IPNet"
;;   {:added "1.0"
;;    :go "_ConstructIPNet(_v)"}
;;   [^Object _v])

JOKER TYPE net.Interface from net/interface.go:
;; (defn ^"GoObject" Interface.
;;   "Constructor for net.Interface"
;;   {:added "1.0"
;;    :go "_ConstructInterface(_v)"}
;;   [^Object _v])

JOKER TYPE net.InvalidAddrError from net/net.go:
(defn ^"GoObject" InvalidAddrError.
  "Constructor for net.InvalidAddrError"
  {:added "1.0"
   :go "_ConstructInvalidAddrError(_v)"}
  [^Object _v])

JOKER TYPE net.ListenConfig from net/dial.go:
;; (defn ^"GoObject" ListenConfig.
;;   "Constructor for net.ListenConfig"
;;   {:added "1.0"
;;    :go "_ConstructListenConfig(_v)"}
;;   [^Object _v])

JOKER TYPE net.Listener from net/net.go:
;; (defn ^"GoObject" Listener.
;;   "Constructor for net.Listener"
;;   {:added "1.0"
;;    :go "_ConstructListener(_v)"}
;;   [^Object _v])

JOKER TYPE net.MX from net/dnsclient.go:
(defn ^"GoObject" MX.
  "Constructor for net.MX"
  {:added "1.0"
   :go "_ConstructMX(_v)"}
  [^Object _v])

JOKER TYPE net.NS from net/dnsclient.go:
(defn ^"GoObject" NS.
  "Constructor for net.NS"
  {:added "1.0"
   :go "_ConstructNS(_v)"}
  [^Object _v])

JOKER TYPE net.OpError from net/net.go:
;; (defn ^"GoObject" OpError.
;;   "Constructor for net.OpError"
;;   {:added "1.0"
;;    :go "_ConstructOpError(_v)"}
;;   [^Object _v])

JOKER TYPE net.PacketConn from net/net.go:
;; (defn ^"GoObject" PacketConn.
;;   "Constructor for net.PacketConn"
;;   {:added "1.0"
;;    :go "_ConstructPacketConn(_v)"}
;;   [^Object _v])

JOKER TYPE net.ParseError from net/net.go:
(defn ^"GoObject" ParseError.
  "Constructor for net.ParseError"
  {:added "1.0"
   :go "_ConstructParseError(_v)"}
  [^Object _v])

JOKER TYPE net.Resolver from net/lookup.go:
;; (defn ^"GoObject" Resolver.
;;   "Constructor for net.Resolver"
;;   {:added "1.0"
;;    :go "_ConstructResolver(_v)"}
;;   [^Object _v])

JOKER TYPE net.SRV from net/dnsclient.go:
(defn ^"GoObject" SRV.
  "Constructor for net.SRV"
  {:added "1.0"
   :go "_ConstructSRV(_v)"}
  [^Object _v])

JOKER TYPE net.TCPAddr from net/tcpsock.go:
;; (defn ^"GoObject" TCPAddr.
;;   "Constructor for net.TCPAddr"
;;   {:added "1.0"
;;    :go "_ConstructTCPAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.TCPConn from net/tcpsock.go:
(defn ^"GoObject" TCPConn.
  "Constructor for net.TCPConn"
  {:added "1.0"
   :go "_ConstructTCPConn(_v)"}
  [^Object _v])

JOKER TYPE net.TCPListener from net/tcpsock.go:
(defn ^"GoObject" TCPListener.
  "Constructor for net.TCPListener"
  {:added "1.0"
   :go "_ConstructTCPListener(_v)"}
  [^Object _v])

JOKER TYPE net.UDPAddr from net/udpsock.go:
;; (defn ^"GoObject" UDPAddr.
;;   "Constructor for net.UDPAddr"
;;   {:added "1.0"
;;    :go "_ConstructUDPAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.UDPConn from net/udpsock.go:
(defn ^"GoObject" UDPConn.
  "Constructor for net.UDPConn"
  {:added "1.0"
   :go "_ConstructUDPConn(_v)"}
  [^Object _v])

JOKER TYPE net.UnixAddr from net/unixsock.go:
(defn ^"GoObject" UnixAddr.
  "Constructor for net.UnixAddr"
  {:added "1.0"
   :go "_ConstructUnixAddr(_v)"}
  [^Object _v])

JOKER TYPE net.UnixConn from net/unixsock.go:
(defn ^"GoObject" UnixConn.
  "Constructor for net.UnixConn"
  {:added "1.0"
   :go "_ConstructUnixConn(_v)"}
  [^Object _v])

JOKER TYPE net.UnixListener from net/unixsock.go:
(defn ^"GoObject" UnixListener.
  "Constructor for net.UnixListener"
  {:added "1.0"
   :go "_ConstructUnixListener(_v)"}
  [^Object _v])

JOKER TYPE net.UnknownNetworkError from net/net.go:
(defn ^"GoObject" UnknownNetworkError.
  "Constructor for net.UnknownNetworkError"
  {:added "1.0"
   :go "_ConstructUnknownNetworkError(_v)"}
  [^Object _v])

JOKER FUNC net.CIDRMask from net/ip.go:
(defn CIDRMask
  "CIDRMask returns an IPMask consisting of `ones' 1 bits\nfollowed by 0s up to a total length of `bits' bits.\nFor a mask of this form, CIDRMask is the inverse of IPMask.Size.\n\nGo input arguments: (ones int, bits int)\n\nGo return type: IPMask\n\nJoker input arguments: [^Int ones, ^Int bits]\n\nJoker return type: go.std.net/IPMask"
  {:added "1.0"
   :go "__cIDRMask(__ones, __bits)"}
  [^Int __ones, ^Int __bits])

JOKER FUNC net.Dial from net/dial.go:
(defn Dial
  "Dial connects to the address on the named network.\n\nKnown networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only),\n\"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\"\n(IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and\n\"unixpacket\".\n\nFor TCP and UDP networks, the address has the form \"host:port\".\nThe host must be a literal IP address, or a host name that can be\nresolved to IP addresses.\nThe port must be a literal port number or a service name.\nIf the host is a literal IPv6 address it must be enclosed in square\nbrackets, as in \"[2001:db8::1]:80\" or \"[fe80::1%zone]:80\".\nThe zone specifies the scope of the literal IPv6 address as defined\nin RFC 4007.\nThe functions JoinHostPort and SplitHostPort manipulate a pair of\nhost and port in this form.\nWhen using TCP, and the host resolves to multiple IP addresses,\nDial will try each IP address in order until one succeeds.\n\nExamples:\n\tDial(\"tcp\", \"golang.org:http\")\n\tDial(\"tcp\", \"192.0.2.1:http\")\n\tDial(\"tcp\", \"198.51.100.1:80\")\n\tDial(\"udp\", \"[2001:db8::1]:domain\")\n\tDial(\"udp\", \"[fe80::1%lo0]:53\")\n\tDial(\"tcp\", \":80\")\n\nFor IP networks, the network must be \"ip\", \"ip4\" or \"ip6\" followed\nby a colon and a literal protocol number or a protocol name, and\nthe address has the form \"host\". The host must be a literal IP\naddress or a literal IPv6 address with zone.\nIt depends on each operating system how the operating system\nbehaves with a non-well known protocol number such as \"0\" or \"255\".\n\nExamples:\n\tDial(\"ip4:1\", \"192.0.2.1\")\n\tDial(\"ip6:ipv6-icmp\", \"2001:db8::1\")\n\tDial(\"ip6:58\", \"fe80::1%lo0\")\n\nFor TCP, UDP and IP networks, if the host is empty or a literal\nunspecified IP address, as in \":80\", \"0.0.0.0:80\" or \"[::]:80\" for\nTCP and UDP, \"\", \"0.0.0.0\" or \"::\" for IP, the local system is\nassumed.\n\nFor Unix networks, the address must be a file system path.\n\nGo input arguments: (network string, address string)\n\nGo return type: (Conn, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/Conn Error]"
  {:added "1.0"
   :go "__dial(__network, __address)"}
  [^String __network, ^String __address])

JOKER FUNC net.DialIP from net/iprawsock.go:
(defn DialIP
  "DialIP acts like Dial for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *IPAddr, raddr *IPAddr)\n\nGo return type: (*IPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/IPAddr) laddr, ^(atom-of go.std.net/IPAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/IPConn) Error]"
  {:added "1.0"
   :go "__dialIP(__network, __laddr, __raddr)"}
  [^String __network, ^net/IPAddr __laddr, ^net/IPAddr __raddr])

JOKER FUNC net.DialTCP from net/tcpsock.go:
(defn DialTCP
  "DialTCP acts like Dial for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *TCPAddr, raddr *TCPAddr)\n\nGo return type: (*TCPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/TCPAddr) laddr, ^(atom-of go.std.net/TCPAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/TCPConn) Error]"
  {:added "1.0"
   :go "__dialTCP(__network, __laddr, __raddr)"}
  [^String __network, ^net/TCPAddr __laddr, ^net/TCPAddr __raddr])

JOKER FUNC net.DialTimeout from net/dial.go:
;; (defn DialTimeout
;;   "DialTimeout acts like Dial but takes a timeout.\n\nThe timeout includes name resolution, if required.\nWhen using TCP, and the host in the address parameter resolves to\nmultiple IP addresses, the timeout is spread over each consecutive\ndial, such that each is given an appropriate fraction of the time\nto connect.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string, timeout time.Duration)\n\nGo return type: (Conn, error)\n\nJoker input arguments: [^String network, ^String address, ^go.std.time/Duration timeout]\n\nJoker return type: [go.std.net/Conn Error]"
;;   {:added "1.0"
;;    :go "__dialTimeout(__network, __address, *__timeout)"}
;;   [^String __network, ^String __address, ^time/Duration __timeout])

JOKER FUNC net.DialUDP from net/udpsock.go:
(defn DialUDP
  "DialUDP acts like Dial for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *UDPAddr, raddr *UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UDPAddr) laddr, ^(atom-of go.std.net/UDPAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/UDPConn) Error]"
  {:added "1.0"
   :go "__dialUDP(__network, __laddr, __raddr)"}
  [^String __network, ^net/UDPAddr __laddr, ^net/UDPAddr __raddr])

JOKER FUNC net.DialUnix from net/unixsock.go:
(defn DialUnix
  "DialUnix acts like Dial for Unix networks.\n\nThe network must be a Unix network name; see func Dial for details.\n\nIf laddr is non-nil, it is used as the local address for the\nconnection.\n\nGo input arguments: (network string, laddr *UnixAddr, raddr *UnixAddr)\n\nGo return type: (*UnixConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr, ^(atom-of go.std.net/UnixAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/UnixConn) Error]"
  {:added "1.0"
   :go "__dialUnix(__network, __laddr, __raddr)"}
  [^String __network, ^net/UnixAddr __laddr, ^net/UnixAddr __raddr])

JOKER FUNC net.FileConn from net/file.go:
;; (defn FileConn
;;   "FileConn returns a copy of the network connection corresponding to\nthe open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo input arguments: (f *os.File)\n\nGo return type: (c Conn, err error)\n\nJoker input arguments: [^(atom-of go.std.os/File) f]\n\nJoker return type: [go.std.net/Conn Error]"
;;   {:added "1.0"
;;    :go "__fileConn(__f)"}
;;   [^os/File __f])

JOKER FUNC net.FileListener from net/file.go:
;; (defn FileListener
;;   "FileListener returns a copy of the network listener corresponding\nto the open file f.\nIt is the caller's responsibility to close ln when finished.\nClosing ln does not affect f, and closing f does not affect ln.\n\nGo input arguments: (f *os.File)\n\nGo return type: (ln Listener, err error)\n\nJoker input arguments: [^(atom-of go.std.os/File) f]\n\nJoker return type: [go.std.net/Listener Error]"
;;   {:added "1.0"
;;    :go "__fileListener(__f)"}
;;   [^os/File __f])

JOKER FUNC net.FilePacketConn from net/file.go:
;; (defn FilePacketConn
;;   "FilePacketConn returns a copy of the packet network connection\ncorresponding to the open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo input arguments: (f *os.File)\n\nGo return type: (c PacketConn, err error)\n\nJoker input arguments: [^(atom-of go.std.os/File) f]\n\nJoker return type: [go.std.net/PacketConn Error]"
;;   {:added "1.0"
;;    :go "__filePacketConn(__f)"}
;;   [^os/File __f])

JOKER FUNC net.IPv4 from net/ip.go:
(defn IPv4
  "IPv4 returns the IP address (in 16-byte form) of the\nIPv4 address a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo return type: IP\n\nJoker input arguments: [^Int a, ^Int b, ^Int c, ^Int d]\n\nJoker return type: go.std.net/IP"
  {:added "1.0"
   :go "__iPv4(__a, __b, __c, __d)"}
  [^Byte __a, ^Byte __b, ^Byte __c, ^Byte __d])

JOKER FUNC net.IPv4Mask from net/ip.go:
(defn IPv4Mask
  "IPv4Mask returns the IP mask (in 4-byte form) of the\nIPv4 mask a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo return type: IPMask\n\nJoker input arguments: [^Int a, ^Int b, ^Int c, ^Int d]\n\nJoker return type: go.std.net/IPMask"
  {:added "1.0"
   :go "__iPv4Mask(__a, __b, __c, __d)"}
  [^Byte __a, ^Byte __b, ^Byte __c, ^Byte __d])

JOKER FUNC net.InterfaceAddrs from net/interface.go:
(defn InterfaceAddrs
  "InterfaceAddrs returns a list of the system's unicast interface\naddresses.\n\nThe returned list does not identify the associated interface; use\nInterfaces and Interface.Addrs for more detail.\n\nGo return type: ([]Addr, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of go.std.net/Addr) Error]"
  {:added "1.0"
   :go "__interfaceAddrs()"}
  [])

JOKER FUNC net.InterfaceByIndex from net/interface.go:
(defn InterfaceByIndex
  "InterfaceByIndex returns the interface specified by index.\n\nOn Solaris, it returns one of the logical network interfaces\nsharing the logical data link; for more precision use\nInterfaceByName.\n\nGo input arguments: (index int)\n\nGo return type: (*Interface, error)\n\nJoker input arguments: [^Int index]\n\nJoker return type: [(atom-of go.std.net/Interface) Error]"
  {:added "1.0"
   :go "__interfaceByIndex(__index)"}
  [^Int __index])

JOKER FUNC net.InterfaceByName from net/interface.go:
(defn InterfaceByName
  "InterfaceByName returns the interface specified by name.\n\nGo input arguments: (name string)\n\nGo return type: (*Interface, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.net/Interface) Error]"
  {:added "1.0"
   :go "__interfaceByName(__name)"}
  [^String __name])

JOKER FUNC net.Interfaces from net/interface.go:
(defn Interfaces
  "Interfaces returns a list of the system's network interfaces.\n\nGo return type: ([]Interface, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of go.std.net/Interface) Error]"
  {:added "1.0"
   :go "__interfaces()"}
  [])

JOKER FUNC net.JoinHostPort from net/ipsock.go:
(defn ^"String" JoinHostPort
  "JoinHostPort combines host and port into a network address of the\nform \"host:port\". If host contains a colon, as found in literal\nIPv6 addresses, then JoinHostPort returns \"[host]:port\".\n\nSee func Dial for a description of the host and port parameters.\n\nGo input arguments: (host string, port string)\n\nGo return type: string\n\nJoker input arguments: [^String host, ^String port]\n\nJoker return type: String"
  {:added "1.0"
   :go "net.JoinHostPort(__host, __port)"}
  [^String __host, ^String __port])

JOKER FUNC net.Listen from net/dial.go:
(defn Listen
  "Listen announces on the local network address.\n\nThe network must be \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\".\n\nFor TCP networks, if the host in the address parameter is empty or\na literal unspecified IP address, Listen listens on all available\nunicast and anycast IP addresses of the local system.\nTo only use IPv4, use network \"tcp4\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe Addr method of Listener can be used to discover the chosen\nport.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (Listener, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/Listener Error]"
  {:added "1.0"
   :go "__listen(__network, __address)"}
  [^String __network, ^String __address])

JOKER FUNC net.ListenIP from net/iprawsock.go:
(defn ListenIP
  "ListenIP acts like ListenPacket for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenIP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\n\nGo input arguments: (network string, laddr *IPAddr)\n\nGo return type: (*IPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/IPAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/IPConn) Error]"
  {:added "1.0"
   :go "__listenIP(__network, __laddr)"}
  [^String __network, ^net/IPAddr __laddr])

JOKER FUNC net.ListenMulticastUDP from net/udpsock.go:
(defn ListenMulticastUDP
  "ListenMulticastUDP acts like ListenPacket for UDP networks but\ntakes a group address on a specific network interface.\n\nThe network must be a UDP network name; see func Dial for details.\n\nListenMulticastUDP listens on all available IP addresses of the\nlocal system including the group, multicast IP address.\nIf ifi is nil, ListenMulticastUDP uses the system-assigned\nmulticast interface, although this is not recommended because the\nassignment depends on platforms and sometimes it might require\nrouting configuration.\nIf the Port field of gaddr is 0, a port number is automatically\nchosen.\n\nListenMulticastUDP is just for convenience of simple, small\napplications. There are golang.org/x/net/ipv4 and\ngolang.org/x/net/ipv6 packages for general purpose uses.\n\nGo input arguments: (network string, ifi *Interface, gaddr *UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/Interface) ifi, ^(atom-of go.std.net/UDPAddr) gaddr]\n\nJoker return type: [(atom-of go.std.net/UDPConn) Error]"
  {:added "1.0"
   :go "__listenMulticastUDP(__network, __ifi, __gaddr)"}
  [^String __network, ^net/Interface __ifi, ^net/UDPAddr __gaddr])

JOKER FUNC net.ListenPacket from net/dial.go:
(defn ListenPacket
  "ListenPacket announces on the local network address.\n\nThe network must be \"udp\", \"udp4\", \"udp6\", \"unixgram\", or an IP\ntransport. The IP transports are \"ip\", \"ip4\", or \"ip6\" followed by\na colon and a literal protocol number or a protocol name, as in\n\"ip:1\" or \"ip:icmp\".\n\nFor UDP and IP networks, if the host in the address parameter is\nempty or a literal unspecified IP address, ListenPacket listens on\nall available IP addresses of the local system except multicast IP\naddresses.\nTo only use IPv4, use network \"udp4\" or \"ip4:proto\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe LocalAddr method of PacketConn can be used to discover the\nchosen port.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (PacketConn, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/PacketConn Error]"
  {:added "1.0"
   :go "__listenPacket(__network, __address)"}
  [^String __network, ^String __address])

JOKER FUNC net.ListenTCP from net/tcpsock.go:
(defn ListenTCP
  "ListenTCP acts like Listen for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenTCP listens on all available unicast and anycast IP addresses\nof the local system.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo input arguments: (network string, laddr *TCPAddr)\n\nGo return type: (*TCPListener, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/TCPAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/TCPListener) Error]"
  {:added "1.0"
   :go "__listenTCP(__network, __laddr)"}
  [^String __network, ^net/TCPAddr __laddr])

JOKER FUNC net.ListenUDP from net/udpsock.go:
(defn ListenUDP
  "ListenUDP acts like ListenPacket for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenUDP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo input arguments: (network string, laddr *UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UDPAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/UDPConn) Error]"
  {:added "1.0"
   :go "__listenUDP(__network, __laddr)"}
  [^String __network, ^net/UDPAddr __laddr])

JOKER FUNC net.ListenUnix from net/unixsock.go:
(defn ListenUnix
  "ListenUnix acts like Listen for Unix networks.\n\nThe network must be \"unix\" or \"unixpacket\".\n\nGo input arguments: (network string, laddr *UnixAddr)\n\nGo return type: (*UnixListener, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/UnixListener) Error]"
  {:added "1.0"
   :go "__listenUnix(__network, __laddr)"}
  [^String __network, ^net/UnixAddr __laddr])

JOKER FUNC net.ListenUnixgram from net/unixsock.go:
(defn ListenUnixgram
  "ListenUnixgram acts like ListenPacket for Unix networks.\n\nThe network must be \"unixgram\".\n\nGo input arguments: (network string, laddr *UnixAddr)\n\nGo return type: (*UnixConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/UnixConn) Error]"
  {:added "1.0"
   :go "__listenUnixgram(__network, __laddr)"}
  [^String __network, ^net/UnixAddr __laddr])

JOKER FUNC net.LookupAddr from net/lookup.go:
(defn LookupAddr
  "LookupAddr performs a reverse lookup for the given address, returning a list\nof names mapping to that address.\n\nWhen using the host C library resolver, at most one result will be\nreturned. To bypass the host resolver, use a custom Resolver.\n\nGo input arguments: (addr string)\n\nGo return type: (names []string, err error)\n\nJoker input arguments: [^String addr]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__lookupAddr(__addr)"}
  [^String __addr])

JOKER FUNC net.LookupCNAME from net/lookup.go:
(defn LookupCNAME
  "LookupCNAME returns the canonical name for the given host.\nCallers that do not care about the canonical name can call\nLookupHost or LookupIP directly; both take care of resolving\nthe canonical name as part of the lookup.\n\nA canonical name is the final name after following zero\nor more CNAME records.\nLookupCNAME does not return an error if host does not\ncontain DNS \"CNAME\" records, as long as host resolves to\naddress records.\n\nGo input arguments: (host string)\n\nGo return type: (cname string, err error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__lookupCNAME(__host)"}
  [^String __host])

JOKER FUNC net.LookupHost from net/lookup.go:
(defn LookupHost
  "LookupHost looks up the given host using the local resolver.\nIt returns a slice of that host's addresses.\n\nGo input arguments: (host string)\n\nGo return type: (addrs []string, err error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__lookupHost(__host)"}
  [^String __host])

JOKER FUNC net.LookupIP from net/lookup.go:
(defn LookupIP
  "LookupIP looks up host using the local resolver.\nIt returns a slice of that host's IPv4 and IPv6 addresses.\n\nGo input arguments: (host string)\n\nGo return type: ([]IP, error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [(vector-of go.std.net/IP) Error]"
  {:added "1.0"
   :go "__lookupIP(__host)"}
  [^String __host])

JOKER FUNC net.LookupMX from net/lookup.go:
(defn LookupMX
  "LookupMX returns the DNS MX records for the given domain name sorted by preference.\n\nGo input arguments: (name string)\n\nGo return type: ([]*MX, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of (atom-of go.std.net/MX)) Error]"
  {:added "1.0"
   :go "__lookupMX(__name)"}
  [^String __name])

JOKER FUNC net.LookupNS from net/lookup.go:
(defn LookupNS
  "LookupNS returns the DNS NS records for the given domain name.\n\nGo input arguments: (name string)\n\nGo return type: ([]*NS, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of (atom-of go.std.net/NS)) Error]"
  {:added "1.0"
   :go "__lookupNS(__name)"}
  [^String __name])

JOKER FUNC net.LookupPort from net/lookup.go:
(defn LookupPort
  "LookupPort looks up the port for the given network and service.\n\nGo input arguments: (network string, service string)\n\nGo return type: (port int, err error)\n\nJoker input arguments: [^String network, ^String service]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__lookupPort(__network, __service)"}
  [^String __network, ^String __service])

JOKER FUNC net.LookupSRV from net/lookup.go:
(defn LookupSRV
  "LookupSRV tries to resolve an SRV query of the given service,\nprotocol, and domain name. The proto is \"tcp\" or \"udp\".\nThe returned records are sorted by priority and randomized\nby weight within a priority.\n\nLookupSRV constructs the DNS name to look up following RFC 2782.\nThat is, it looks up _service._proto.name. To accommodate services\npublishing SRV records under non-standard names, if both service\nand proto are empty strings, LookupSRV looks up name directly.\n\nGo input arguments: (service string, proto string, name string)\n\nGo return type: (cname string, addrs []*SRV, err error)\n\nJoker input arguments: [^String service, ^String proto, ^String name]\n\nJoker return type: [String (vector-of (atom-of go.std.net/SRV)) Error]"
  {:added "1.0"
   :go "__lookupSRV(__service, __proto, __name)"}
  [^String __service, ^String __proto, ^String __name])

JOKER FUNC net.LookupTXT from net/lookup.go:
(defn LookupTXT
  "LookupTXT returns the DNS TXT records for the given domain name.\n\nGo input arguments: (name string)\n\nGo return type: ([]string, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__lookupTXT(__name)"}
  [^String __name])

JOKER FUNC net.ParseCIDR from net/ip.go:
(defn ParseCIDR
  "ParseCIDR parses s as a CIDR notation IP address and prefix length,\nlike \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in\nRFC 4632 and RFC 4291.\n\nIt returns the IP address and the network implied by the IP and\nprefix length.\nFor example, ParseCIDR(\"192.0.2.1/24\") returns the IP address\n192.0.2.1 and the network 192.0.2.0/24.\n\nGo input arguments: (s string)\n\nGo return type: (IP, *IPNet, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [go.std.net/IP (atom-of go.std.net/IPNet) Error]"
  {:added "1.0"
   :go "__parseCIDR(__s)"}
  [^String __s])

JOKER FUNC net.ParseIP from net/ip.go:
(defn ParseIP
  "ParseIP parses s as an IP address, returning the result.\nThe string s can be in dotted decimal (\"192.0.2.1\")\nor IPv6 (\"2001:db8::68\") form.\nIf s is not a valid textual representation of an IP address,\nParseIP returns nil.\n\nGo input arguments: (s string)\n\nGo return type: IP\n\nJoker input arguments: [^String s]\n\nJoker return type: go.std.net/IP"
  {:added "1.0"
   :go "__parseIP(__s)"}
  [^String __s])

JOKER FUNC net.ParseMAC from net/mac.go:
(defn ParseMAC
  "ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet\nIP over InfiniBand link-layer address using one of the following formats:\n  01:23:45:67:89:ab\n  01:23:45:67:89:ab:cd:ef\n  01:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00\n  01-23-45-67-89-ab\n  01-23-45-67-89-ab-cd-ef\n  01-23-45-67-89-ab-cd-ef-00-00-01-23-45-67-89-ab-cd-ef-00-00\n  0123.4567.89ab\n  0123.4567.89ab.cdef\n  0123.4567.89ab.cdef.0000.0123.4567.89ab.cdef.0000\n\nGo input arguments: (s string)\n\nGo return type: (hw HardwareAddr, err error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [go.std.net/HardwareAddr Error]"
  {:added "1.0"
   :go "__parseMAC(__s)"}
  [^String __s])

JOKER FUNC net.Pipe from net/pipe.go:
(defn Pipe
  "Pipe creates a synchronous, in-memory, full duplex\nnetwork connection; both ends implement the Conn interface.\nReads on one end are matched with writes on the other,\ncopying data directly between the two; there is no internal\nbuffering.\n\nGo return type: (Conn, Conn)\n\nJoker input arguments: []\n\nJoker return type: [go.std.net/Conn go.std.net/Conn]"
  {:added "1.0"
   :go "__pipe()"}
  [])

JOKER FUNC net.ResolveIPAddr from net/iprawsock.go:
(defn ResolveIPAddr
  "ResolveIPAddr returns an address of IP end point.\n\nThe network must be an IP network name.\n\nIf the host in the address parameter is not a literal IP address,\nResolveIPAddr resolves the address to an address of IP end point.\nOtherwise, it parses the address as a literal IP address.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*IPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/IPAddr) Error]"
  {:added "1.0"
   :go "__resolveIPAddr(__network, __address)"}
  [^String __network, ^String __address])

JOKER FUNC net.ResolveTCPAddr from net/tcpsock.go:
(defn ResolveTCPAddr
  "ResolveTCPAddr returns an address of TCP end point.\n\nThe network must be a TCP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveTCPAddr resolves the\naddress to an address of TCP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*TCPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/TCPAddr) Error]"
  {:added "1.0"
   :go "__resolveTCPAddr(__network, __address)"}
  [^String __network, ^String __address])

JOKER FUNC net.ResolveUDPAddr from net/udpsock.go:
(defn ResolveUDPAddr
  "ResolveUDPAddr returns an address of UDP end point.\n\nThe network must be a UDP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveUDPAddr resolves the\naddress to an address of UDP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*UDPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/UDPAddr) Error]"
  {:added "1.0"
   :go "__resolveUDPAddr(__network, __address)"}
  [^String __network, ^String __address])

JOKER FUNC net.ResolveUnixAddr from net/unixsock.go:
(defn ResolveUnixAddr
  "ResolveUnixAddr returns an address of Unix domain socket end point.\n\nThe network must be a Unix network name.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*UnixAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/UnixAddr) Error]"
  {:added "1.0"
   :go "__resolveUnixAddr(__network, __address)"}
  [^String __network, ^String __address])

JOKER FUNC net.SplitHostPort from net/ipsock.go:
(defn SplitHostPort
  "SplitHostPort splits a network address of the form \"host:port\",\n\"host%zone:port\", \"[host]:port\" or \"[host%zone]:port\" into host or\nhost%zone and port.\n\nA literal IPv6 address in hostport must be enclosed in square\nbrackets, as in \"[::1]:80\", \"[::1%lo0]:80\".\n\nSee func Dial for a description of the hostport parameter, and host\nand port results.\n\nGo input arguments: (hostport string)\n\nGo return type: (host string, port string, err error)\n\nJoker input arguments: [^String hostport]\n\nJoker return type: [String String Error]"
  {:added "1.0"
   :go "__splitHostPort(__hostport)"}
  [^String __hostport])

JOKER TYPE go.std.net/Addr:
(def
  ^{:doc "Addr represents a network end point address.\n\nThe two methods Network and String conventionally return strings\nthat can be passed as the arguments to Dial, but the exact form\nand meaning of the strings is up to the implementation.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Addr"}
  Addr)

JOKER TYPE go.std.net/AddrError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_AddrError"}
  AddrError)

JOKER TYPE go.std.net/Buffers:
(def
  ^{:doc "Buffers contains zero or more runs of bytes to write.\n\nOn certain machines, for certain types of connections, this is\noptimized into an OS-specific batch write operation (such as\n\"writev\").\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Buffers"}
  Buffers)

JOKER TYPE go.std.net/Conn:
(def
  ^{:doc "Conn is a generic stream-oriented network connection.\n\nMultiple goroutines may invoke methods on a Conn simultaneously.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Conn"}
  Conn)

JOKER TYPE go.std.net/DNSConfigError:
(def
  ^{:doc "DNSConfigError represents an error reading the machine's DNS configuration.\n(No longer used; kept for compatibility.)\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DNSConfigError"}
  DNSConfigError)

JOKER TYPE go.std.net/DNSError:
(def
  ^{:doc "DNSError represents a DNS lookup error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DNSError"}
  DNSError)

JOKER TYPE go.std.net/Dialer:
(def
  ^{:doc "A Dialer contains options for connecting to an address.\n\nThe zero value for each field is equivalent to dialing\nwithout that option. Dialing with the zero value of Dialer\nis therefore equivalent to just calling the Dial function.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Dialer"}
  Dialer)

JOKER TYPE go.std.net/Error:
(def
  ^{:doc "An Error represents a network error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Error"}
  Error)

JOKER TYPE go.std.net/Flags:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Flags"}
  Flags)

JOKER TYPE go.std.net/HardwareAddr:
(def
  ^{:doc "A HardwareAddr represents a physical hardware address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_HardwareAddr"}
  HardwareAddr)

JOKER TYPE go.std.net/IP:
(def
  ^{:doc "An IP is a single IP address, a slice of bytes.\nFunctions in this package accept either 4-byte (IPv4)\nor 16-byte (IPv6) slices as input.\n\nNote that in this documentation, referring to an\nIP address as an IPv4 address or an IPv6 address\nis a semantic property of the address, not just the\nlength of the byte slice: a 16-byte slice can still\nbe an IPv4 address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IP"}
  IP)

JOKER TYPE go.std.net/IPAddr:
(def
  ^{:doc "IPAddr represents the address of an IP end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IPAddr"}
  IPAddr)

JOKER TYPE go.std.net/IPConn:
(def
  ^{:doc "IPConn is the implementation of the Conn and PacketConn interfaces\nfor IP network connections.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IPConn"}
  IPConn)

JOKER TYPE go.std.net/IPMask:
(def
  ^{:doc "An IP mask is an IP address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IPMask"}
  IPMask)

JOKER TYPE go.std.net/IPNet:
(def
  ^{:doc "An IPNet represents an IP network.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IPNet"}
  IPNet)

JOKER TYPE go.std.net/Interface:
(def
  ^{:doc "Interface represents a mapping between network interface name\nand index. It also represents network interface facility\ninformation.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Interface"}
  Interface)

JOKER TYPE go.std.net/InvalidAddrError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_InvalidAddrError"}
  InvalidAddrError)

JOKER TYPE go.std.net/ListenConfig:
(def
  ^{:doc "ListenConfig contains options for listening to an address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ListenConfig"}
  ListenConfig)

JOKER TYPE go.std.net/Listener:
(def
  ^{:doc "A Listener is a generic network listener for stream-oriented protocols.\n\nMultiple goroutines may invoke methods on a Listener simultaneously.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Listener"}
  Listener)

JOKER TYPE go.std.net/MX:
(def
  ^{:doc "An MX represents a single DNS MX record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_MX"}
  MX)

JOKER TYPE go.std.net/NS:
(def
  ^{:doc "An NS represents a single DNS NS record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NS"}
  NS)

JOKER TYPE go.std.net/OpError:
(def
  ^{:doc "OpError is the error type usually returned by functions in the net\npackage. It describes the operation, network type, and address of\nan error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_OpError"}
  OpError)

JOKER TYPE go.std.net/PacketConn:
(def
  ^{:doc "PacketConn is a generic packet-oriented network connection.\n\nMultiple goroutines may invoke methods on a PacketConn simultaneously.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PacketConn"}
  PacketConn)

JOKER TYPE go.std.net/ParseError:
(def
  ^{:doc "A ParseError is the error type of literal network address parsers.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ParseError"}
  ParseError)

JOKER TYPE go.std.net/Resolver:
(def
  ^{:doc "A Resolver looks up names and numbers.\n\nA nil *Resolver is equivalent to a zero Resolver.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Resolver"}
  Resolver)

JOKER TYPE go.std.net/SRV:
(def
  ^{:doc "An SRV represents a single DNS SRV record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SRV"}
  SRV)

JOKER TYPE go.std.net/TCPAddr:
(def
  ^{:doc "TCPAddr represents the address of a TCP end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TCPAddr"}
  TCPAddr)

JOKER TYPE go.std.net/TCPConn:
(def
  ^{:doc "TCPConn is an implementation of the Conn interface for TCP network\nconnections.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TCPConn"}
  TCPConn)

JOKER TYPE go.std.net/TCPListener:
(def
  ^{:doc "TCPListener is a TCP network listener. Clients should typically\nuse variables of type Listener instead of assuming TCP.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TCPListener"}
  TCPListener)

JOKER TYPE go.std.net/UDPAddr:
(def
  ^{:doc "UDPAddr represents the address of a UDP end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UDPAddr"}
  UDPAddr)

JOKER TYPE go.std.net/UDPConn:
(def
  ^{:doc "UDPConn is the implementation of the Conn and PacketConn interfaces\nfor UDP network connections.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UDPConn"}
  UDPConn)

JOKER TYPE go.std.net/UnixAddr:
(def
  ^{:doc "UnixAddr represents the address of a Unix domain socket end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnixAddr"}
  UnixAddr)

JOKER TYPE go.std.net/UnixConn:
(def
  ^{:doc "UnixConn is an implementation of the Conn interface for connections\nto Unix domain sockets.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnixConn"}
  UnixConn)

JOKER TYPE go.std.net/UnixListener:
(def
  ^{:doc "UnixListener is a Unix domain socket listener. Clients should\ntypically use variables of type Listener instead of assuming Unix\ndomain sockets.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnixListener"}
  UnixListener)

JOKER TYPE go.std.net/UnknownNetworkError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_UnknownNetworkError"}
  UnknownNetworkError)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net"]
    :doc "Provides a low-level interface to the net package.\n\nPackage net provides a portable interface for network I/O, including\nTCP/IP, UDP, domain name resolution, and Unix domain sockets.\n\nAlthough the package provides access to low-level networking\nprimitives, most clients will need only the basic interface provided\nby the Dial, Listen, and Accept functions and the associated\nConn and Listener interfaces. The crypto/tls package uses\nthe same interfaces and similar Dial and Listen functions.\n\nThe Dial function connects to a server:\n\n\tconn, err := net.Dial(\"tcp\", \"golang.org:80\")\n\tif err != nil {\n\t\t// handle error\n\t}\n\tfmt.Fprintf(conn, \"GET / HTTP/1.0\\r\\n\\r\\n\")\n\tstatus, err := bufio.NewReader(conn).ReadString('\\n')\n\t// ...\n\nThe Listen function creates servers:\n\n\tln, err := net.Listen(\"tcp\", \":8080\")\n\tif err != nil {\n\t\t// handle error\n\t}\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\t// handle error\n\t\t}\n\t\tgo handleConnection(conn)\n\t}\n\nName Resolution\n\nThe method for resolving domain names, whether indirectly with functions like Dial\nor directly with functions like LookupHost and LookupAddr, varies by operating system.\n\nOn Unix systems, the resolver has two options for resolving names.\nIt can use a pure Go resolver that sends DNS requests directly to the servers\nlisted in /etc/resolv.conf, or it can use a cgo-based resolver that calls C\nlibrary routines such as getaddrinfo and getnameinfo.\n\nBy default the pure Go resolver is used, because a blocked DNS request consumes\nonly a goroutine, while a blocked C call consumes an operating system thread.\nWhen cgo is available, the cgo-based resolver is used instead under a variety of\nconditions: on systems that do not let programs make direct DNS requests (OS X),\nwhen the LOCALDOMAIN environment variable is present (even if empty),\nwhen the RES_OPTIONS or HOSTALIASES environment variable is non-empty,\nwhen the ASR_CONFIG environment variable is non-empty (OpenBSD only),\nwhen /etc/resolv.conf or /etc/nsswitch.conf specify the use of features that the\nGo resolver does not implement, and when the name being looked up ends in .local\nor is an mDNS name.\n\nThe resolver decision can be overridden by setting the netdns value of the\nGODEBUG environment variable (see package runtime) to go or cgo, as in:\n\n\texport GODEBUG=netdns=go    # force pure Go resolver\n\texport GODEBUG=netdns=cgo   # force cgo resolver\n\nThe decision can also be forced while building the Go source tree\nby setting the netgo or netcgo build tag.\n\nA numeric netdns setting, as in GODEBUG=netdns=1, causes the resolver\nto print debugging information about its decisions.\nTo force a particular resolver while also printing debugging information,\njoin the two settings by a plus sign, as in GODEBUG=netdns=go+1.\n\nOn Plan 9, the resolver always accesses /net/cs and /net/dns.\n\nOn Windows, the resolver always uses C library functions, such as GetAddrInfo and DnsQuery.\n"
    :empty false}
  go.std.net)
JOKER CONSTANT DefaultMaxHeaderBytes from net/http/server.go:
(def
  ^{:doc "1 MB\n"
    :added "1.0"
    :tag "Number"
    :go "int64(http.DefaultMaxHeaderBytes)"}
  DefaultMaxHeaderBytes)

JOKER CONSTANT DefaultMaxIdleConnsPerHost from net/http/transport.go:
(def
  ^{:doc "DefaultMaxIdleConnsPerHost is the default value of Transport's\nMaxIdleConnsPerHost.\n"
    :added "1.0"
    :tag "Int"
    :go "http.DefaultMaxIdleConnsPerHost"}
  DefaultMaxIdleConnsPerHost)

JOKER CONSTANT MethodConnect from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :go "http.MethodConnect"}
  MethodConnect)

JOKER CONSTANT MethodDelete from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :go "http.MethodDelete"}
  MethodDelete)

JOKER CONSTANT MethodGet from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :go "http.MethodGet"}
  MethodGet)

JOKER CONSTANT MethodHead from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :go "http.MethodHead"}
  MethodHead)

JOKER CONSTANT MethodOptions from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :go "http.MethodOptions"}
  MethodOptions)

JOKER CONSTANT MethodPatch from net/http/method.go:
(def
  ^{:doc "RFC 5789\n"
    :added "1.0"
    :tag "String"
    :go "http.MethodPatch"}
  MethodPatch)

JOKER CONSTANT MethodPost from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :go "http.MethodPost"}
  MethodPost)

JOKER CONSTANT MethodPut from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :go "http.MethodPut"}
  MethodPut)

JOKER CONSTANT MethodTrace from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :go "http.MethodTrace"}
  MethodTrace)

JOKER CONSTANT SameSiteDefaultMode from net/http/cookie.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(http.SameSiteDefaultMode)"}
  SameSiteDefaultMode)

JOKER CONSTANT SameSiteLaxMode from net/http/cookie.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(http.SameSiteLaxMode)"}
  SameSiteLaxMode)

JOKER CONSTANT SameSiteStrictMode from net/http/cookie.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(http.SameSiteStrictMode)"}
  SameSiteStrictMode)

JOKER CONSTANT StateActive from net/http/server.go:
(def
  ^{:doc "StateActive represents a connection that has read 1 or more\nbytes of a request. The Server.ConnState hook for\nStateActive fires before the request has entered a handler\nand doesn't fire again until the request has been\nhandled. After the request is handled, the state\ntransitions to StateClosed, StateHijacked, or StateIdle.\nFor HTTP/2, StateActive fires on the transition from zero\nto one active request, and only transitions away once all\nactive requests are complete. That means that ConnState\ncannot be used to do per-request work; ConnState only notes\nthe overall state of the connection.\n"
    :added "1.0"
    :tag "Int"
    :go "int(http.StateActive)"}
  StateActive)

JOKER CONSTANT StateClosed from net/http/server.go:
(def
  ^{:doc "StateClosed represents a closed connection.\nThis is a terminal state. Hijacked connections do not\ntransition to StateClosed.\n"
    :added "1.0"
    :tag "Int"
    :go "int(http.StateClosed)"}
  StateClosed)

JOKER CONSTANT StateHijacked from net/http/server.go:
(def
  ^{:doc "StateHijacked represents a hijacked connection.\nThis is a terminal state. It does not transition to StateClosed.\n"
    :added "1.0"
    :tag "Int"
    :go "int(http.StateHijacked)"}
  StateHijacked)

JOKER CONSTANT StateIdle from net/http/server.go:
(def
  ^{:doc "StateIdle represents a connection that has finished\nhandling a request and is in the keep-alive state, waiting\nfor a new request. Connections transition from StateIdle\nto either StateActive or StateClosed.\n"
    :added "1.0"
    :tag "Int"
    :go "int(http.StateIdle)"}
  StateIdle)

JOKER CONSTANT StateNew from net/http/server.go:
(def
  ^{:doc "StateNew represents a new connection that is expected to\nsend a request immediately. Connections begin at this\nstate and then transition to either StateActive or\nStateClosed.\n"
    :added "1.0"
    :tag "Int"
    :go "int(http.StateNew)"}
  StateNew)

JOKER CONSTANT StatusAccepted from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.3.3\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusAccepted"}
  StatusAccepted)

JOKER CONSTANT StatusAlreadyReported from net/http/status.go:
(def
  ^{:doc "RFC 5842, 7.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusAlreadyReported"}
  StatusAlreadyReported)

JOKER CONSTANT StatusBadGateway from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.6.3\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusBadGateway"}
  StatusBadGateway)

JOKER CONSTANT StatusBadRequest from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusBadRequest"}
  StatusBadRequest)

JOKER CONSTANT StatusConflict from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.8\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusConflict"}
  StatusConflict)

JOKER CONSTANT StatusContinue from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.2.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusContinue"}
  StatusContinue)

JOKER CONSTANT StatusCreated from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.3.2\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusCreated"}
  StatusCreated)

JOKER CONSTANT StatusExpectationFailed from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.14\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusExpectationFailed"}
  StatusExpectationFailed)

JOKER CONSTANT StatusFailedDependency from net/http/status.go:
(def
  ^{:doc "RFC 4918, 11.4\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusFailedDependency"}
  StatusFailedDependency)

JOKER CONSTANT StatusForbidden from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.3\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusForbidden"}
  StatusForbidden)

JOKER CONSTANT StatusFound from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.4.3\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusFound"}
  StatusFound)

JOKER CONSTANT StatusGatewayTimeout from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.6.5\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusGatewayTimeout"}
  StatusGatewayTimeout)

JOKER CONSTANT StatusGone from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.9\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusGone"}
  StatusGone)

JOKER CONSTANT StatusHTTPVersionNotSupported from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.6.6\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusHTTPVersionNotSupported"}
  StatusHTTPVersionNotSupported)

JOKER CONSTANT StatusIMUsed from net/http/status.go:
(def
  ^{:doc "RFC 3229, 10.4.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusIMUsed"}
  StatusIMUsed)

JOKER CONSTANT StatusInsufficientStorage from net/http/status.go:
(def
  ^{:doc "RFC 4918, 11.5\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusInsufficientStorage"}
  StatusInsufficientStorage)

JOKER CONSTANT StatusInternalServerError from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.6.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusInternalServerError"}
  StatusInternalServerError)

JOKER CONSTANT StatusLengthRequired from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.10\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusLengthRequired"}
  StatusLengthRequired)

JOKER CONSTANT StatusLocked from net/http/status.go:
(def
  ^{:doc "RFC 4918, 11.3\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusLocked"}
  StatusLocked)

JOKER CONSTANT StatusLoopDetected from net/http/status.go:
(def
  ^{:doc "RFC 5842, 7.2\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusLoopDetected"}
  StatusLoopDetected)

JOKER CONSTANT StatusMethodNotAllowed from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.5\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusMethodNotAllowed"}
  StatusMethodNotAllowed)

JOKER CONSTANT StatusMisdirectedRequest from net/http/status.go:
(def
  ^{:doc "RFC 7540, 9.1.2\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusMisdirectedRequest"}
  StatusMisdirectedRequest)

JOKER CONSTANT StatusMovedPermanently from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.4.2\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusMovedPermanently"}
  StatusMovedPermanently)

JOKER CONSTANT StatusMultiStatus from net/http/status.go:
(def
  ^{:doc "RFC 4918, 11.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusMultiStatus"}
  StatusMultiStatus)

JOKER CONSTANT StatusMultipleChoices from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.4.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusMultipleChoices"}
  StatusMultipleChoices)

JOKER CONSTANT StatusNetworkAuthenticationRequired from net/http/status.go:
(def
  ^{:doc "RFC 6585, 6\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusNetworkAuthenticationRequired"}
  StatusNetworkAuthenticationRequired)

JOKER CONSTANT StatusNoContent from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.3.5\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusNoContent"}
  StatusNoContent)

JOKER CONSTANT StatusNonAuthoritativeInfo from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.3.4\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusNonAuthoritativeInfo"}
  StatusNonAuthoritativeInfo)

JOKER CONSTANT StatusNotAcceptable from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.6\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusNotAcceptable"}
  StatusNotAcceptable)

JOKER CONSTANT StatusNotExtended from net/http/status.go:
(def
  ^{:doc "RFC 2774, 7\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusNotExtended"}
  StatusNotExtended)

JOKER CONSTANT StatusNotFound from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.4\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusNotFound"}
  StatusNotFound)

JOKER CONSTANT StatusNotImplemented from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.6.2\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusNotImplemented"}
  StatusNotImplemented)

JOKER CONSTANT StatusNotModified from net/http/status.go:
(def
  ^{:doc "RFC 7232, 4.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusNotModified"}
  StatusNotModified)

JOKER CONSTANT StatusOK from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.3.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusOK"}
  StatusOK)

JOKER CONSTANT StatusPartialContent from net/http/status.go:
(def
  ^{:doc "RFC 7233, 4.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusPartialContent"}
  StatusPartialContent)

JOKER CONSTANT StatusPaymentRequired from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.2\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusPaymentRequired"}
  StatusPaymentRequired)

JOKER CONSTANT StatusPermanentRedirect from net/http/status.go:
(def
  ^{:doc "RFC 7538, 3\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusPermanentRedirect"}
  StatusPermanentRedirect)

JOKER CONSTANT StatusPreconditionFailed from net/http/status.go:
(def
  ^{:doc "RFC 7232, 4.2\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusPreconditionFailed"}
  StatusPreconditionFailed)

JOKER CONSTANT StatusPreconditionRequired from net/http/status.go:
(def
  ^{:doc "RFC 6585, 3\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusPreconditionRequired"}
  StatusPreconditionRequired)

JOKER CONSTANT StatusProcessing from net/http/status.go:
(def
  ^{:doc "RFC 2518, 10.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusProcessing"}
  StatusProcessing)

JOKER CONSTANT StatusProxyAuthRequired from net/http/status.go:
(def
  ^{:doc "RFC 7235, 3.2\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusProxyAuthRequired"}
  StatusProxyAuthRequired)

JOKER CONSTANT StatusRequestEntityTooLarge from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.11\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusRequestEntityTooLarge"}
  StatusRequestEntityTooLarge)

JOKER CONSTANT StatusRequestHeaderFieldsTooLarge from net/http/status.go:
(def
  ^{:doc "RFC 6585, 5\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusRequestHeaderFieldsTooLarge"}
  StatusRequestHeaderFieldsTooLarge)

JOKER CONSTANT StatusRequestTimeout from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.7\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusRequestTimeout"}
  StatusRequestTimeout)

JOKER CONSTANT StatusRequestURITooLong from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.12\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusRequestURITooLong"}
  StatusRequestURITooLong)

JOKER CONSTANT StatusRequestedRangeNotSatisfiable from net/http/status.go:
(def
  ^{:doc "RFC 7233, 4.4\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusRequestedRangeNotSatisfiable"}
  StatusRequestedRangeNotSatisfiable)

JOKER CONSTANT StatusResetContent from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.3.6\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusResetContent"}
  StatusResetContent)

JOKER CONSTANT StatusSeeOther from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.4.4\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusSeeOther"}
  StatusSeeOther)

JOKER CONSTANT StatusServiceUnavailable from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.6.4\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusServiceUnavailable"}
  StatusServiceUnavailable)

JOKER CONSTANT StatusSwitchingProtocols from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.2.2\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusSwitchingProtocols"}
  StatusSwitchingProtocols)

JOKER CONSTANT StatusTeapot from net/http/status.go:
(def
  ^{:doc "RFC 7168, 2.3.3\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusTeapot"}
  StatusTeapot)

JOKER CONSTANT StatusTemporaryRedirect from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.4.7\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusTemporaryRedirect"}
  StatusTemporaryRedirect)

JOKER CONSTANT StatusTooEarly from net/http/status.go:
(def
  ^{:doc "RFC 8470, 5.2.\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusTooEarly"}
  StatusTooEarly)

JOKER CONSTANT StatusTooManyRequests from net/http/status.go:
(def
  ^{:doc "RFC 6585, 4\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusTooManyRequests"}
  StatusTooManyRequests)

JOKER CONSTANT StatusUnauthorized from net/http/status.go:
(def
  ^{:doc "RFC 7235, 3.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusUnauthorized"}
  StatusUnauthorized)

JOKER CONSTANT StatusUnavailableForLegalReasons from net/http/status.go:
(def
  ^{:doc "RFC 7725, 3\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusUnavailableForLegalReasons"}
  StatusUnavailableForLegalReasons)

JOKER CONSTANT StatusUnprocessableEntity from net/http/status.go:
(def
  ^{:doc "RFC 4918, 11.2\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusUnprocessableEntity"}
  StatusUnprocessableEntity)

JOKER CONSTANT StatusUnsupportedMediaType from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.13\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusUnsupportedMediaType"}
  StatusUnsupportedMediaType)

JOKER CONSTANT StatusUpgradeRequired from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.15\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusUpgradeRequired"}
  StatusUpgradeRequired)

JOKER CONSTANT StatusUseProxy from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.4.5\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusUseProxy"}
  StatusUseProxy)

JOKER CONSTANT StatusVariantAlsoNegotiates from net/http/status.go:
(def
  ^{:doc "RFC 2295, 8.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusVariantAlsoNegotiates"}
  StatusVariantAlsoNegotiates)

JOKER CONSTANT TimeFormat from net/http/server.go:
(def
  ^{:doc "TimeFormat is the time format to use when generating times in HTTP\nheaders. It is like time.RFC1123 but hard-codes GMT as the time\nzone. The time being formatted must be in UTC for Format to\ngenerate the correct format.\n\nFor parsing this time format, see ParseTime.\n"
    :added "1.0"
    :tag "String"
    :go "http.TimeFormat"}
  TimeFormat)

JOKER CONSTANT TrailerPrefix from net/http/server.go:
(def
  ^{:doc "TrailerPrefix is a magic prefix for ResponseWriter.Header map keys\nthat, if present, signals that the map entry is actually for\nthe response trailers, and not the response headers. The prefix\nis stripped after the ServeHTTP call finishes and the values are\nsent in the trailers.\n\nThis mechanism is intended only for trailers that are not known\nprior to the headers being written. If the set of trailers is fixed\nor known before the header is written, the normal Go trailers mechanism\nis preferred:\n   https://golang.org/pkg/net/http/#ResponseWriter\n   https://golang.org/pkg/net/http/#example_ResponseWriter_trailers\n"
    :added "1.0"
    :tag "String"
    :go "http.TrailerPrefix"}
  TrailerPrefix)

JOKER VARIABLE DefaultClient from net/http/client.go:
(def
  ^{:doc "DefaultClient is the default Client and is used by Get, Head, and Post.\n"
    :added "1.0"
    :tag "Var"
    :go "http.DefaultClient"}
  DefaultClient)

JOKER VARIABLE DefaultServeMux from net/http/server.go:
(def
  ^{:doc "DefaultServeMux is the default ServeMux used by Serve.\n"
    :added "1.0"
    :tag "Var"
    :go "http.DefaultServeMux"}
  DefaultServeMux)

JOKER VARIABLE DefaultTransport from net/http/transport.go:
(def
  ^{:doc "DefaultTransport is the default implementation of Transport and is\nused by DefaultClient. It establishes network connections as needed\nand caches them for reuse by subsequent calls. It uses HTTP proxies\nas directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and\n$no_proxy) environment variables.\n"
    :added "1.0"
    :tag "Var"
    :go "http.DefaultTransport"}
  DefaultTransport)

JOKER VARIABLE ErrAbortHandler from net/http/server.go:
(def
  ^{:doc "ErrAbortHandler is a sentinel panic value to abort a handler.\nWhile any panic from ServeHTTP aborts the response to the client,\npanicking with ErrAbortHandler also suppresses logging of a stack\ntrace to the server's error log.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrAbortHandler"}
  ErrAbortHandler)

JOKER VARIABLE ErrBodyNotAllowed from net/http/server.go:
(def
  ^{:doc "ErrBodyNotAllowed is returned by ResponseWriter.Write calls\nwhen the HTTP method or response code does not permit a\nbody.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrBodyNotAllowed"}
  ErrBodyNotAllowed)

JOKER VARIABLE ErrBodyReadAfterClose from net/http/transfer.go:
(def
  ^{:doc "ErrBodyReadAfterClose is returned when reading a Request or Response\nBody after the body has been closed. This typically happens when the body is\nread after an HTTP Handler calls WriteHeader or Write on its\nResponseWriter.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrBodyReadAfterClose"}
  ErrBodyReadAfterClose)

JOKER VARIABLE ErrContentLength from net/http/server.go:
(def
  ^{:doc "ErrContentLength is returned by ResponseWriter.Write calls\nwhen a Handler set a Content-Length response header with a\ndeclared size and then attempted to write more bytes than\ndeclared.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrContentLength"}
  ErrContentLength)

JOKER VARIABLE ErrHandlerTimeout from net/http/server.go:
(def
  ^{:doc "ErrHandlerTimeout is returned on ResponseWriter Write calls\nin handlers which have timed out.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrHandlerTimeout"}
  ErrHandlerTimeout)

JOKER VARIABLE ErrHeaderTooLong from net/http/request.go:
(def
  ^{:doc "Deprecated: ErrHeaderTooLong is no longer returned by\nanything in the net/http package. Callers should not\ncompare errors against this variable.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrHeaderTooLong"}
  ErrHeaderTooLong)

JOKER VARIABLE ErrHijacked from net/http/server.go:
(def
  ^{:doc "ErrHijacked is returned by ResponseWriter.Write calls when\nthe underlying connection has been hijacked using the\nHijacker interface. A zero-byte write on a hijacked\nconnection will return ErrHijacked without any other side\neffects.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrHijacked"}
  ErrHijacked)

JOKER VARIABLE ErrLineTooLong from net/http/transfer.go:
(def
  ^{:doc "ErrLineTooLong is returned when reading request or response bodies\nwith malformed chunked encoding.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrLineTooLong"}
  ErrLineTooLong)

JOKER VARIABLE ErrMissingBoundary from net/http/request.go:
(def
  ^{:doc "ErrMissingBoundary is returned by Request.MultipartReader when the\nrequest's Content-Type does not include a \"boundary\" parameter.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrMissingBoundary"}
  ErrMissingBoundary)

JOKER VARIABLE ErrMissingContentLength from net/http/request.go:
(def
  ^{:doc "Deprecated: ErrMissingContentLength is no longer returned by\nanything in the net/http package. Callers should not\ncompare errors against this variable.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrMissingContentLength"}
  ErrMissingContentLength)

JOKER VARIABLE ErrMissingFile from net/http/request.go:
(def
  ^{:doc "ErrMissingFile is returned by FormFile when the provided file field name\nis either not present in the request or not a file field.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrMissingFile"}
  ErrMissingFile)

JOKER VARIABLE ErrNoCookie from net/http/request.go:
(def
  ^{:doc "ErrNoCookie is returned by Request's Cookie method when a cookie is not found.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrNoCookie"}
  ErrNoCookie)

JOKER VARIABLE ErrNoLocation from net/http/response.go:
(def
  ^{:doc "ErrNoLocation is returned by Response's Location method\nwhen no Location header is present.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrNoLocation"}
  ErrNoLocation)

JOKER VARIABLE ErrNotMultipart from net/http/request.go:
(def
  ^{:doc "ErrNotMultipart is returned by Request.MultipartReader when the\nrequest's Content-Type is not multipart/form-data.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrNotMultipart"}
  ErrNotMultipart)

JOKER VARIABLE ErrNotSupported from net/http/request.go:
(def
  ^{:doc "ErrNotSupported is returned by the Push method of Pusher\nimplementations to indicate that HTTP/2 Push support is not\navailable.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrNotSupported"}
  ErrNotSupported)

JOKER VARIABLE ErrServerClosed from net/http/server.go:
(def
  ^{:doc "ErrServerClosed is returned by the Server's Serve, ServeTLS, ListenAndServe,\nand ListenAndServeTLS methods after a call to Shutdown or Close.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrServerClosed"}
  ErrServerClosed)

JOKER VARIABLE ErrShortBody from net/http/request.go:
(def
  ^{:doc "Deprecated: ErrShortBody is no longer returned by\nanything in the net/http package. Callers should not\ncompare errors against this variable.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrShortBody"}
  ErrShortBody)

JOKER VARIABLE ErrSkipAltProtocol from net/http/transport.go:
(def
  ^{:doc "ErrSkipAltProtocol is a sentinel error value defined by Transport.RegisterProtocol.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrSkipAltProtocol"}
  ErrSkipAltProtocol)

JOKER VARIABLE ErrUnexpectedTrailer from net/http/request.go:
(def
  ^{:doc "Deprecated: ErrUnexpectedTrailer is no longer returned by\nanything in the net/http package. Callers should not\ncompare errors against this variable.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrUnexpectedTrailer"}
  ErrUnexpectedTrailer)

JOKER VARIABLE ErrUseLastResponse from net/http/client.go:
(def
  ^{:doc "ErrUseLastResponse can be returned by Client.CheckRedirect hooks to\ncontrol how redirects are processed. If returned, the next request\nis not sent and the most recent response is returned with its body\nunclosed.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrUseLastResponse"}
  ErrUseLastResponse)

JOKER VARIABLE ErrWriteAfterFlush from net/http/server.go:
(def
  ^{:doc "Deprecated: ErrWriteAfterFlush is no longer returned by\nanything in the net/http package. Callers should not\ncompare errors against this variable.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrWriteAfterFlush"}
  ErrWriteAfterFlush)

JOKER VARIABLE LocalAddrContextKey from net/http/server.go:
(def
  ^{:doc "LocalAddrContextKey is a context key. It can be used in\nHTTP handlers with context.WithValue to access the local\naddress the connection arrived on.\nThe associated value will be of type net.Addr.\n"
    :added "1.0"
    :tag "Var"
    :go "http.LocalAddrContextKey"}
  LocalAddrContextKey)

JOKER VARIABLE NoBody from net/http/http.go:
(def
  ^{:doc "NoBody is an io.ReadCloser with no bytes. Read always returns EOF\nand Close always returns nil. It can be used in an outgoing client\nrequest to explicitly signal that a request has zero bytes.\nAn alternative, however, is to simply set Request.Body to nil.\n"
    :added "1.0"
    :tag "Var"
    :go "http.NoBody"}
  NoBody)

JOKER VARIABLE ServerContextKey from net/http/server.go:
(def
  ^{:doc "ServerContextKey is a context key. It can be used in HTTP\nhandlers with context.WithValue to access the server that\nstarted the handler. The associated value will be of\ntype *Server.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ServerContextKey"}
  ServerContextKey)

JOKER TYPE net/http.Client from net/http/client.go:
;; (defn ^"GoObject" Client.
;;   "Constructor for http.Client"
;;   {:added "1.0"
;;    :go "_ConstructClient(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.CloseNotifier from net/http/server.go:
;; (defn ^"GoObject" CloseNotifier.
;;   "Constructor for http.CloseNotifier"
;;   {:added "1.0"
;;    :go "_ConstructCloseNotifier(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.ConnState from net/http/server.go:
(defn ^"GoObject" ConnState.
  "Constructor for http.ConnState"
  {:added "1.0"
   :go "_ConstructConnState(_v)"}
  [^Object _v])

JOKER TYPE net/http.Cookie from net/http/cookie.go:
;; (defn ^"GoObject" Cookie.
;;   "Constructor for http.Cookie"
;;   {:added "1.0"
;;    :go "_ConstructCookie(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.CookieJar from net/http/jar.go:
;; (defn ^"GoObject" CookieJar.
;;   "Constructor for http.CookieJar"
;;   {:added "1.0"
;;    :go "_ConstructCookieJar(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Dir from net/http/fs.go:
(defn ^"GoObject" Dir.
  "Constructor for http.Dir"
  {:added "1.0"
   :go "_ConstructDir(_v)"}
  [^Object _v])

JOKER TYPE net/http.File from net/http/fs.go:
;; (defn ^"GoObject" File.
;;   "Constructor for http.File"
;;   {:added "1.0"
;;    :go "_ConstructFile(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.FileSystem from net/http/fs.go:
;; (defn ^"GoObject" FileSystem.
;;   "Constructor for http.FileSystem"
;;   {:added "1.0"
;;    :go "_ConstructFileSystem(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Flusher from net/http/server.go:
;; (defn ^"GoObject" Flusher.
;;   "Constructor for http.Flusher"
;;   {:added "1.0"
;;    :go "_ConstructFlusher(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Handler from net/http/server.go:
;; (defn ^"GoObject" Handler.
;;   "Constructor for http.Handler"
;;   {:added "1.0"
;;    :go "_ConstructHandler(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.HandlerFunc from net/http/server.go:
;; (defn ^"GoObject" HandlerFunc.
;;   "Constructor for http.HandlerFunc"
;;   {:added "1.0"
;;    :go "_ConstructHandlerFunc(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Header from net/http/header.go:
;; (defn ^"GoObject" Header.
;;   "Constructor for http.Header"
;;   {:added "1.0"
;;    :go "_ConstructHeader(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Hijacker from net/http/server.go:
;; (defn ^"GoObject" Hijacker.
;;   "Constructor for http.Hijacker"
;;   {:added "1.0"
;;    :go "_ConstructHijacker(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.ProtocolError from net/http/request.go:
(defn ^"GoObject" ProtocolError.
  "Constructor for http.ProtocolError"
  {:added "1.0"
   :go "_ConstructProtocolError(_v)"}
  [^Object _v])

JOKER TYPE net/http.PushOptions from net/http/http.go:
;; (defn ^"GoObject" PushOptions.
;;   "Constructor for http.PushOptions"
;;   {:added "1.0"
;;    :go "_ConstructPushOptions(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Pusher from net/http/http.go:
;; (defn ^"GoObject" Pusher.
;;   "Constructor for http.Pusher"
;;   {:added "1.0"
;;    :go "_ConstructPusher(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Request from net/http/request.go:
;; (defn ^"GoObject" Request.
;;   "Constructor for http.Request"
;;   {:added "1.0"
;;    :go "_ConstructRequest(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Response from net/http/response.go:
;; (defn ^"GoObject" Response.
;;   "Constructor for http.Response"
;;   {:added "1.0"
;;    :go "_ConstructResponse(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.ResponseWriter from net/http/server.go:
;; (defn ^"GoObject" ResponseWriter.
;;   "Constructor for http.ResponseWriter"
;;   {:added "1.0"
;;    :go "_ConstructResponseWriter(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.RoundTripper from net/http/client.go:
;; (defn ^"GoObject" RoundTripper.
;;   "Constructor for http.RoundTripper"
;;   {:added "1.0"
;;    :go "_ConstructRoundTripper(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.SameSite from net/http/cookie.go:
(defn ^"GoObject" SameSite.
  "Constructor for http.SameSite"
  {:added "1.0"
   :go "_ConstructSameSite(_v)"}
  [^Object _v])

JOKER TYPE net/http.ServeMux from net/http/server.go:
(defn ^"GoObject" ServeMux.
  "Constructor for http.ServeMux"
  {:added "1.0"
   :go "_ConstructServeMux(_v)"}
  [^Object _v])

JOKER TYPE net/http.Server from net/http/server.go:
;; (defn ^"GoObject" Server.
;;   "Constructor for http.Server"
;;   {:added "1.0"
;;    :go "_ConstructServer(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Transport from net/http/transport.go:
;; (defn ^"GoObject" Transport.
;;   "Constructor for http.Transport"
;;   {:added "1.0"
;;    :go "_ConstructTransport(_v)"}
;;   [^Object _v])

JOKER FUNC net/http.CanonicalHeaderKey from net/http/header.go:
(defn ^"String" CanonicalHeaderKey
  "CanonicalHeaderKey returns the canonical format of the\nheader key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.CanonicalHeaderKey(__s)"}
  [^String __s])

JOKER FUNC net/http.DetectContentType from net/http/sniff.go:
;; (defn ^"String" DetectContentType
;;   "DetectContentType implements the algorithm described\nat https://mimesniff.spec.whatwg.org/ to determine the\nContent-Type of the given data. It considers at most the\nfirst 512 bytes of data. DetectContentType always returns\na valid MIME type: if it cannot determine a more specific one, it\nreturns \"application/octet-stream\".\n\nGo input arguments: (data []byte)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "http.DetectContentType(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)))"}
;;   [^Object __data])

JOKER FUNC net/http.Error from net/http/server.go:
;; (defn Error
;;   "Error replies to the request with the specified error message and HTTP code.\nIt does not otherwise end the request; the caller should ensure no further\nwrites are done to w.\nThe error message should be plain text.\n\nGo input arguments: (w ResponseWriter, error string, code int)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^String error, ^Int code]"
;;   {:added "1.0"
;;    :go "__error(*__w, __error, __code)"}
;;   [^http/ResponseWriter __w, ^String __error, ^Int __code])

JOKER FUNC net/http.FileServer from net/http/fs.go:
(defn FileServer
  "FileServer returns a handler that serves HTTP requests\nwith the contents of the file system rooted at root.\n\nTo use the operating system's file system implementation,\nuse http.Dir:\n\n    http.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))\n\nAs a special case, the returned file server redirects any request\nending in \"/index.html\" to the same path, without the final\n\"index.html\".\n\nGo input arguments: (root FileSystem)\n\nGo return type: Handler\n\nJoker input arguments: [^go.std.net.http/FileSystem root]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__fileServer(*__root)"}
  [^http/FileSystem __root])

JOKER FUNC net/http.Get from net/http/client.go:
(defn Get
  "Get issues a GET to the specified URL. If the response is one of\nthe following redirect codes, Get follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nAn error is returned if there were too many redirects or if there\nwas an HTTP protocol error. A non-2xx response doesn't cause an\nerror. Any returned error will be of type *url.Error. The url.Error\nvalue's Timeout method will report true if request timed out or was\ncanceled.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nGet is a wrapper around DefaultClient.Get.\n\nTo make a request with custom headers, use NewRequest and\nDefaultClient.Do.\n\nGo input arguments: (url string)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
  {:added "1.0"
   :go "__get(__url)"}
  [^String __url])

JOKER FUNC net/http.Handle from net/http/server.go:
;; (defn Handle
;;   "Handle registers the handler for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler Handler)\n\nJoker input arguments: [^String pattern, ^go.std.net.http/Handler handler]"
;;   {:added "1.0"
;;    :go "__handle(__pattern, *__handler)"}
;;   [^String __pattern, ^http/Handler __handler])

JOKER FUNC net/http.HandleFunc from net/http/server.go:
;; (defn HandleFunc
;;   "HandleFunc registers the handler function for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler func)\n\nJoker input arguments: [^String pattern, ^fn handler]"
;;   {:added "1.0"
;;    :go "__handleFunc(__pattern, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String __pattern, ^fn __handler])

JOKER FUNC net/http.Head from net/http/client.go:
(defn Head
  "Head issues a HEAD to the specified URL. If the response is one of\nthe following redirect codes, Head follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nHead is a wrapper around DefaultClient.Head\n\nGo input arguments: (url string)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
  {:added "1.0"
   :go "__head(__url)"}
  [^String __url])

JOKER FUNC net/http.ListenAndServe from net/http/server.go:
(defn ^"Error" ListenAndServe
  "ListenAndServe listens on the TCP network address addr and then calls\nServe with handler to handle requests on incoming connections.\nAccepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error.\n\nGo input arguments: (addr string, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
  {:added "1.0"
   :go "http.ListenAndServe(__addr, *__handler)"}
  [^String __addr, ^http/Handler __handler])

JOKER FUNC net/http.ListenAndServeTLS from net/http/server.go:
(defn ^"Error" ListenAndServeTLS
  "ListenAndServeTLS acts identically to ListenAndServe, except that it\nexpects HTTPS connections. Additionally, files containing a certificate and\nmatching private key for the server must be provided. If the certificate\nis signed by a certificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nGo input arguments: (addr string, certFile string, keyFile string, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^String certFile, ^String keyFile, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
  {:added "1.0"
   :go "http.ListenAndServeTLS(__addr, __certFile, __keyFile, *__handler)"}
  [^String __addr, ^String __certFile, ^String __keyFile, ^http/Handler __handler])

JOKER FUNC net/http.MaxBytesReader from net/http/request.go:
;; (defn MaxBytesReader
;;   "MaxBytesReader is similar to io.LimitReader but is intended for\nlimiting the size of incoming request bodies. In contrast to\nio.LimitReader, MaxBytesReader's result is a ReadCloser, returns a\nnon-EOF error for a Read beyond the limit, and closes the\nunderlying reader when its Close method is called.\n\nMaxBytesReader prevents clients from accidentally or maliciously\nsending a large request and wasting server resources.\n\nGo input arguments: (w ResponseWriter, r io.ReadCloser, n int64)\n\nGo return type: io.ReadCloser\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^go.std.io/ReadCloser r, ^Number n]\n\nJoker return type: go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "__maxBytesReader(*__w, *__r, __n)"}
;;   [^http/ResponseWriter __w, ^io/ReadCloser __r, ^Int64 __n])

JOKER FUNC net/http.NewFileTransport from net/http/filetransport.go:
(defn NewFileTransport
  "NewFileTransport returns a new RoundTripper, serving the provided\nFileSystem. The returned RoundTripper ignores the URL host in its\nincoming requests, as well as most other properties of the\nrequest.\n\nThe typical use case for NewFileTransport is to register the \"file\"\nprotocol with a Transport, as in:\n\n  t := &http.Transport{}\n  t.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))\n  c := &http.Client{Transport: t}\n  res, err := c.Get(\"file:///etc/passwd\")\n  ...\n\nGo input arguments: (fs FileSystem)\n\nGo return type: RoundTripper\n\nJoker input arguments: [^go.std.net.http/FileSystem fs]\n\nJoker return type: go.std.net.http/RoundTripper"
  {:added "1.0"
   :go "__newFileTransport(*__fs)"}
  [^http/FileSystem __fs])

JOKER FUNC net/http.NewRequest from net/http/request.go:
;; (defn NewRequest
;;   "NewRequest returns a new Request given a method, URL, and optional body.\n\nIf the provided body is also an io.Closer, the returned\nRequest.Body is set to body and will be closed by the Client\nmethods Do, Post, and PostForm, and Transport.RoundTrip.\n\nNewRequest returns a Request suitable for use with Client.Do or\nTransport.RoundTrip. To create a request for use with testing a\nServer Handler, either use the NewRequest function in the\nnet/http/httptest package, use ReadRequest, or manually update the\nRequest fields. See the Request type's documentation for the\ndifference between inbound and outbound request fields.\n\nIf body is of type *bytes.Buffer, *bytes.Reader, or\n*strings.Reader, the returned request's ContentLength is set to its\nexact value (instead of -1), GetBody is populated (so 307 and 308\nredirects can replay the body), and Body is set to NoBody if the\nContentLength is 0.\n\nGo input arguments: (method string, url string, body io.Reader)\n\nGo return type: (*Request, error)\n\nJoker input arguments: [^String method, ^String url, ^go.std.io/Reader body]\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
;;   {:added "1.0"
;;    :go "__newRequest(__method, __url, *__body)"}
;;   [^String __method, ^String __url, ^io/Reader __body])

JOKER FUNC net/http.NewServeMux from net/http/server.go:
(defn NewServeMux
  "NewServeMux allocates and returns a new ServeMux.\n\nGo return type: *ServeMux\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.net.http/ServeMux)"
  {:added "1.0"
   :go "__newServeMux()"}
  [])

JOKER FUNC net/http.NotFound from net/http/server.go:
;; (defn NotFound
;;   "NotFound replies to the request with an HTTP 404 not found error.\n\nGo input arguments: (w ResponseWriter, r *Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__notFound(*__w, __r)"}
;;   [^http/ResponseWriter __w, ^http/Request __r])

JOKER FUNC net/http.NotFoundHandler from net/http/server.go:
(defn NotFoundHandler
  "NotFoundHandler returns a simple request handler\nthat replies to each request with a ``404 page not found'' reply.\n\nGo return type: Handler\n\nJoker input arguments: []\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__notFoundHandler()"}
  [])

JOKER FUNC net/http.ParseHTTPVersion from net/http/request.go:
(defn ParseHTTPVersion
  "ParseHTTPVersion parses a HTTP version string.\n\"HTTP/1.0\" returns (1, 0, true).\n\nGo input arguments: (vers string)\n\nGo return type: (major int, minor int, ok bool)\n\nJoker input arguments: [^String vers]\n\nJoker return type: [Int Int Boolean]"
  {:added "1.0"
   :go "__parseHTTPVersion(__vers)"}
  [^String __vers])

JOKER FUNC net/http.ParseTime from net/http/header.go:
(defn ParseTime
  "ParseTime parses a time header (such as the Date: header),\ntrying each of the three formats allowed by HTTP/1.1:\nTimeFormat, time.RFC850, and time.ANSIC.\n\nGo input arguments: (text string)\n\nGo return type: (t time.Time, err error)\n\nJoker input arguments: [^String text]\n\nJoker return type: [go.std.time/Time Error]"
  {:added "1.0"
   :go "__parseTime(__text)"}
  [^String __text])

JOKER FUNC net/http.Post from net/http/client.go:
;; (defn Post
;;   "Post issues a POST to the specified URL.\n\nCaller should close resp.Body when done reading from it.\n\nIf the provided body is an io.Closer, it is closed after the\nrequest.\n\nPost is a wrapper around DefaultClient.Post.\n\nTo set custom headers, use NewRequest and DefaultClient.Do.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, contentType string, body io.Reader)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^String contentType, ^go.std.io/Reader body]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
;;   {:added "1.0"
;;    :go "__post(__url, __contentType, *__body)"}
;;   [^String __url, ^String __contentType, ^io/Reader __body])

JOKER FUNC net/http.PostForm from net/http/client.go:
;; (defn PostForm
;;   "PostForm issues a POST to the specified URL, with data's keys and\nvalues URL-encoded as the request body.\n\nThe Content-Type header is set to application/x-www-form-urlencoded.\nTo set other headers, use NewRequest and DefaultClient.Do.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nPostForm is a wrapper around DefaultClient.PostForm.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, data url.Values)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^go.std.net.url/Values data]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
;;   {:added "1.0"
;;    :go "__postForm(__url, *__data)"}
;;   [^String __url, ^url/Values __data])

JOKER FUNC net/http.ProxyFromEnvironment from net/http/transport.go:
(defn ProxyFromEnvironment
  "ProxyFromEnvironment returns the URL of the proxy to use for a\ngiven request, as indicated by the environment variables\nHTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions\nthereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https\nrequests.\n\nThe environment values may be either a complete URL or a\n\"host[:port]\", in which case the \"http\" scheme is assumed.\nAn error is returned if the value is a different form.\n\nA nil URL and nil error are returned if no proxy is defined in the\nenvironment, or a proxy should not be used for the given request,\nas defined by NO_PROXY.\n\nAs a special case, if req.URL.Host is \"localhost\" (with or without\na port number), then a nil URL and nil error will be returned.\n\nGo input arguments: (req *Request)\n\nGo return type: (*net/url.URL, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req]\n\nJoker return type: [(atom-of go.std.net.url/URL) Error]"
  {:added "1.0"
   :go "__proxyFromEnvironment(__req)"}
  [^http/Request __req])

JOKER FUNC net/http.ProxyURL from net/http/transport.go:
;; (defn ProxyURL
;;   "ProxyURL returns a proxy function (for use in a Transport)\nthat always returns the same URL.\n\nGo input arguments: (fixedURL *url.URL)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of go.std.net.url/URL) fixedURL]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.FuncType at: /usr/local/go/src/net/http/transport.go:352:34)"
;;   {:added "1.0"
;;    :go "__proxyURL(__fixedURL)"}
;;   [^url/URL __fixedURL])

JOKER FUNC net/http.ReadRequest from net/http/request.go:
;; (defn ReadRequest
;;   "ReadRequest reads and parses an incoming request from b.\n\nReadRequest is a low-level function and should only be used for\nspecialized applications; most code should use the Server to read\nrequests and handle them via the Handler interface. ReadRequest\nonly supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.\n\nGo input arguments: (b *bufio.Reader)\n\nGo return type: (*Request, error)\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) b]\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
;;   {:added "1.0"
;;    :go "__readRequest(__b)"}
;;   [^bufio/Reader __b])

JOKER FUNC net/http.ReadResponse from net/http/response.go:
;; (defn ReadResponse
;;   "ReadResponse reads and returns an HTTP response from r.\nThe req parameter optionally specifies the Request that corresponds\nto this Response. If nil, a GET request is assumed.\nClients must call resp.Body.Close when finished reading resp.Body.\nAfter that call, clients can inspect resp.Trailer to find key/value\npairs included in the response trailer.\n\nGo input arguments: (r *bufio.Reader, req *Request)\n\nGo return type: (*Response, error)\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) r, ^(atom-of go.std.net.http/Request) req]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
;;   {:added "1.0"
;;    :go "__readResponse(__r, __req)"}
;;   [^bufio/Reader __r, ^http/Request __req])

JOKER FUNC net/http.Redirect from net/http/server.go:
;; (defn Redirect
;;   "Redirect replies to the request with a redirect to url,\nwhich may be a path relative to the request path.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nIf the Content-Type header has not been set, Redirect sets it\nto \"text/html; charset=utf-8\" and writes a small HTML body.\nSetting the Content-Type header to any value, including nil,\ndisables that behavior.\n\nGo input arguments: (w ResponseWriter, r *Request, url string, code int)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r, ^String url, ^Int code]"
;;   {:added "1.0"
;;    :go "__redirect(*__w, __r, __url, __code)"}
;;   [^http/ResponseWriter __w, ^http/Request __r, ^String __url, ^Int __code])

JOKER FUNC net/http.RedirectHandler from net/http/server.go:
(defn RedirectHandler
  "RedirectHandler returns a request handler that redirects\neach request it receives to the given url using the given\nstatus code.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nGo input arguments: (url string, code int)\n\nGo return type: Handler\n\nJoker input arguments: [^String url, ^Int code]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__redirectHandler(__url, __code)"}
  [^String __url, ^Int __code])

JOKER FUNC net/http.Serve from net/http/server.go:
;; (defn ^"Error" Serve
;;   "Serve accepts incoming HTTP connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nHTTP/2 support is only enabled if the Listener returns *tls.Conn\nconnections and they were configured with \"h2\" in the TLS\nConfig.NextProtos.\n\nServe always returns a non-nil error.\n\nGo input arguments: (l net.Listener, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.Serve(*__l, *__handler)"}
;;   [^net/Listener __l, ^http/Handler __handler])

JOKER FUNC net/http.ServeContent from net/http/fs.go:
;; (defn ServeContent
;;   "ServeContent replies to the request using the content in the\nprovided ReadSeeker. The main benefit of ServeContent over io.Copy\nis that it handles Range requests properly, sets the MIME type, and\nhandles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,\nand If-Range requests.\n\nIf the response's Content-Type header is not set, ServeContent\nfirst tries to deduce the type from name's file extension and,\nif that fails, falls back to reading the first block of the content\nand passing it to DetectContentType.\nThe name is otherwise unused; in particular it can be empty and is\nnever sent in the response.\n\nIf modtime is not the zero time or Unix epoch, ServeContent\nincludes it in a Last-Modified header in the response. If the\nrequest includes an If-Modified-Since header, ServeContent uses\nmodtime to decide whether the content needs to be sent at all.\n\nThe content's Seek method must work: ServeContent uses\na seek to the end of the content to determine its size.\n\nIf the caller has set w's ETag header formatted per RFC 7232, section 2.3,\nServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.\n\nNote that *os.File implements the io.ReadSeeker interface.\n\nGo input arguments: (w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) req, ^String name, ^go.std.time/Time modtime, ^go.std.io/ReadSeeker content]"
;;   {:added "1.0"
;;    :go "__serveContent(*__w, __req, __name, *__modtime, *__content)"}
;;   [^http/ResponseWriter __w, ^http/Request __req, ^String __name, ^time/Time __modtime, ^io/ReadSeeker __content])

JOKER FUNC net/http.ServeFile from net/http/fs.go:
;; (defn ServeFile
;;   "ServeFile replies to the request with the contents of the named\nfile or directory.\n\nIf the provided file or directory name is a relative path, it is\ninterpreted relative to the current directory and may ascend to\nparent directories. If the provided name is constructed from user\ninput, it should be sanitized before calling ServeFile.\n\nAs a precaution, ServeFile will reject requests where r.URL.Path\ncontains a \"..\" path element; this protects against callers who\nmight unsafely use filepath.Join on r.URL.Path without sanitizing\nit and then use that filepath.Join result as the name argument.\n\nAs another special case, ServeFile redirects any request where r.URL.Path\nends in \"/index.html\" to the same path, without the final\n\"index.html\". To avoid such redirects either modify the path or\nuse ServeContent.\n\nOutside of those two special cases, ServeFile does not use\nr.URL.Path for selecting the file or directory to serve; only the\nfile or directory provided in the name argument is used.\n\nGo input arguments: (w ResponseWriter, r *Request, name string)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r, ^String name]"
;;   {:added "1.0"
;;    :go "__serveFile(*__w, __r, __name)"}
;;   [^http/ResponseWriter __w, ^http/Request __r, ^String __name])

JOKER FUNC net/http.ServeTLS from net/http/server.go:
;; (defn ^"Error" ServeTLS
;;   "ServeTLS accepts incoming HTTPS connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nAdditionally, files containing a certificate and matching private key\nfor the server must be provided. If the certificate is signed by a\ncertificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nServeTLS always returns a non-nil error.\n\nGo input arguments: (l net.Listener, handler Handler, certFile string, keyFile string)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler, ^String certFile, ^String keyFile]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.ServeTLS(*__l, *__handler, __certFile, __keyFile)"}
;;   [^net/Listener __l, ^http/Handler __handler, ^String __certFile, ^String __keyFile])

JOKER FUNC net/http.SetCookie from net/http/cookie.go:
;; (defn SetCookie
;;   "SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.\nThe provided cookie must have a valid Name. Invalid cookies may be\nsilently dropped.\n\nGo input arguments: (w ResponseWriter, cookie *Cookie)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Cookie) cookie]"
;;   {:added "1.0"
;;    :go "__setCookie(*__w, __cookie)"}
;;   [^http/ResponseWriter __w, ^http/Cookie __cookie])

JOKER FUNC net/http.StatusText from net/http/status.go:
(defn ^"String" StatusText
  "StatusText returns a text for the HTTP status code. It returns the empty\nstring if the code is unknown.\n\nGo input arguments: (code int)\n\nGo return type: string\n\nJoker input arguments: [^Int code]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.StatusText(__code)"}
  [^Int __code])

JOKER FUNC net/http.StripPrefix from net/http/server.go:
(defn StripPrefix
  "StripPrefix returns a handler that serves HTTP requests\nby removing the given prefix from the request URL's Path\nand invoking the handler h. StripPrefix handles a\nrequest for a path that doesn't begin with prefix by\nreplying with an HTTP 404 not found error.\n\nGo input arguments: (prefix string, h Handler)\n\nGo return type: Handler\n\nJoker input arguments: [^String prefix, ^go.std.net.http/Handler h]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__stripPrefix(__prefix, *__h)"}
  [^String __prefix, ^http/Handler __h])

JOKER FUNC net/http.TimeoutHandler from net/http/server.go:
;; (defn TimeoutHandler
;;   "TimeoutHandler returns a Handler that runs h with the given time limit.\n\nThe new Handler calls h.ServeHTTP to handle each request, but if a\ncall runs for longer than its time limit, the handler responds with\na 503 Service Unavailable error and the given message in its body.\n(If msg is empty, a suitable default message will be sent.)\nAfter such a timeout, writes by h to its ResponseWriter will return\nErrHandlerTimeout.\n\nTimeoutHandler buffers all Handler writes to memory and does not\nsupport the Hijacker or Flusher interfaces.\n\nGo input arguments: (h Handler, dt time.Duration, msg string)\n\nGo return type: Handler\n\nJoker input arguments: [^go.std.net.http/Handler h, ^go.std.time/Duration dt, ^String msg]\n\nJoker return type: go.std.net.http/Handler"
;;   {:added "1.0"
;;    :go "__timeoutHandler(*__h, *__dt, __msg)"}
;;   [^http/Handler __h, ^time/Duration __dt, ^String __msg])

JOKER TYPE go.std.net.http/Client:
(def
  ^{:doc "A Client is an HTTP client. Its zero value (DefaultClient) is a\nusable client that uses DefaultTransport.\n\nThe Client's Transport typically has internal state (cached TCP\nconnections), so Clients should be reused instead of created as\nneeded. Clients are safe for concurrent use by multiple goroutines.\n\nA Client is higher-level than a RoundTripper (such as Transport)\nand additionally handles HTTP details such as cookies and\nredirects.\n\nWhen following redirects, the Client will forward all headers set on the\ninitial Request except:\n\n• when forwarding sensitive headers like \"Authorization\",\n\"WWW-Authenticate\", and \"Cookie\" to untrusted targets.\nThese headers will be ignored when following a redirect to a domain\nthat is not a subdomain match or exact match of the initial domain.\nFor example, a redirect from \"foo.com\" to either \"foo.com\" or \"sub.foo.com\"\nwill forward the sensitive headers, but a redirect to \"bar.com\" will not.\n\n• when forwarding the \"Cookie\" header with a non-nil cookie Jar.\nSince each redirect may mutate the state of the cookie jar,\na redirect may possibly alter a cookie set in the initial request.\nWhen forwarding the \"Cookie\" header, any mutated cookies will be omitted,\nwith the expectation that the Jar will insert those mutated cookies\nwith the updated values (assuming the origin matches).\nIf Jar is nil, the initial cookies are forwarded without change.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Client"}
  Client)

JOKER TYPE go.std.net.http/CloseNotifier:
(def
  ^{:doc "The CloseNotifier interface is implemented by ResponseWriters which\nallow detecting when the underlying connection has gone away.\n\nThis mechanism can be used to cancel long operations on the server\nif the client has disconnected before the response is ready.\n\nDeprecated: the CloseNotifier interface predates Go's context package.\nNew code should use Request.Context instead.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CloseNotifier"}
  CloseNotifier)

JOKER TYPE go.std.net.http/ConnState:
(def
  ^{:doc "A ConnState represents the state of a client connection to a server.\nIt's used by the optional Server.ConnState hook.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ConnState"}
  ConnState)

JOKER TYPE go.std.net.http/Cookie:
(def
  ^{:doc "A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an\nHTTP response or the Cookie header of an HTTP request.\n\nSee https://tools.ietf.org/html/rfc6265 for details.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Cookie"}
  Cookie)

JOKER TYPE go.std.net.http/CookieJar:
(def
  ^{:doc "A CookieJar manages storage and use of cookies in HTTP requests.\n\nImplementations of CookieJar must be safe for concurrent use by multiple\ngoroutines.\n\nThe net/http/cookiejar package provides a CookieJar implementation.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CookieJar"}
  CookieJar)

JOKER TYPE go.std.net.http/Dir:
(def
  ^{:doc "A Dir implements FileSystem using the native file system restricted to a\nspecific directory tree.\n\nWhile the FileSystem.Open method takes '/'-separated paths, a Dir's string\nvalue is a filename on the native file system, not a URL, so it is separated\nby filepath.Separator, which isn't necessarily '/'.\n\nNote that Dir will allow access to files and directories starting with a\nperiod, which could expose sensitive directories like a .git directory or\nsensitive files like .htpasswd. To exclude files with a leading period,\nremove the files/directories from the server or create a custom FileSystem\nimplementation.\n\nAn empty Dir is treated as \".\".\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Dir"}
  Dir)

JOKER TYPE go.std.net.http/File:
(def
  ^{:doc "A File is returned by a FileSystem's Open method and can be\nserved by the FileServer implementation.\n\nThe methods should behave the same as those on an *os.File.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_File"}
  File)

JOKER TYPE go.std.net.http/FileSystem:
(def
  ^{:doc "A FileSystem implements access to a collection of named files.\nThe elements in a file path are separated by slash ('/', U+002F)\ncharacters, regardless of host operating system convention.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FileSystem"}
  FileSystem)

JOKER TYPE go.std.net.http/Flusher:
(def
  ^{:doc "The Flusher interface is implemented by ResponseWriters that allow\nan HTTP handler to flush buffered data to the client.\n\nThe default HTTP/1.x and HTTP/2 ResponseWriter implementations\nsupport Flusher, but ResponseWriter wrappers may not. Handlers\nshould always test for this ability at runtime.\n\nNote that even for ResponseWriters that support Flush,\nif the client is connected through an HTTP proxy,\nthe buffered data may not reach the client until the response\ncompletes.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Flusher"}
  Flusher)

JOKER TYPE go.std.net.http/Handler:
(def
  ^{:doc "A Handler responds to an HTTP request.\n\nServeHTTP should write reply headers and data to the ResponseWriter\nand then return. Returning signals that the request is finished; it\nis not valid to use the ResponseWriter or read from the\nRequest.Body after or concurrently with the completion of the\nServeHTTP call.\n\nDepending on the HTTP client software, HTTP protocol version, and\nany intermediaries between the client and the Go server, it may not\nbe possible to read from the Request.Body after writing to the\nResponseWriter. Cautious handlers should read the Request.Body\nfirst, and then reply.\n\nExcept for reading the body, handlers should not modify the\nprovided Request.\n\nIf ServeHTTP panics, the server (the caller of ServeHTTP) assumes\nthat the effect of the panic was isolated to the active request.\nIt recovers the panic, logs a stack trace to the server error log,\nand either closes the network connection or sends an HTTP/2\nRST_STREAM, depending on the HTTP protocol. To abort a handler so\nthe client sees an interrupted response but the server doesn't log\nan error, panic with the value ErrAbortHandler.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Handler"}
  Handler)

JOKER TYPE go.std.net.http/HandlerFunc:
(def
  ^{:doc "The HandlerFunc type is an adapter to allow the use of\nordinary functions as HTTP handlers. If f is a function\nwith the appropriate signature, HandlerFunc(f) is a\nHandler that calls f.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_HandlerFunc"}
  HandlerFunc)

JOKER TYPE go.std.net.http/Header:
(def
  ^{:doc "A Header represents the key-value pairs in an HTTP header.\n\nThe keys should be in canonical form, as returned by\nCanonicalHeaderKey.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Header"}
  Header)

JOKER TYPE go.std.net.http/Hijacker:
(def
  ^{:doc "The Hijacker interface is implemented by ResponseWriters that allow\nan HTTP handler to take over the connection.\n\nThe default ResponseWriter for HTTP/1.x connections supports\nHijacker, but HTTP/2 connections intentionally do not.\nResponseWriter wrappers may also not support Hijacker. Handlers\nshould always test for this ability at runtime.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Hijacker"}
  Hijacker)

JOKER TYPE go.std.net.http/ProtocolError:
(def
  ^{:doc "ProtocolError represents an HTTP protocol error.\n\nDeprecated: Not all errors in the http package related to protocol errors\nare of type ProtocolError.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ProtocolError"}
  ProtocolError)

JOKER TYPE go.std.net.http/PushOptions:
(def
  ^{:doc "PushOptions describes options for Pusher.Push.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PushOptions"}
  PushOptions)

JOKER TYPE go.std.net.http/Pusher:
(def
  ^{:doc "Pusher is the interface implemented by ResponseWriters that support\nHTTP/2 server push. For more background, see\nhttps://tools.ietf.org/html/rfc7540#section-8.2.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Pusher"}
  Pusher)

JOKER TYPE go.std.net.http/Request:
(def
  ^{:doc "A Request represents an HTTP request received by a server\nor to be sent by a client.\n\nThe field semantics differ slightly between client and server\nusage. In addition to the notes on the fields below, see the\ndocumentation for Request.Write and RoundTripper.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Request"}
  Request)

JOKER TYPE go.std.net.http/Response:
(def
  ^{:doc "Response represents the response from an HTTP request.\n\nThe Client and Transport return Responses from servers once\nthe response headers have been received. The response body\nis streamed on demand as the Body field is read.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Response"}
  Response)

JOKER TYPE go.std.net.http/ResponseWriter:
(def
  ^{:doc "A ResponseWriter interface is used by an HTTP handler to\nconstruct an HTTP response.\n\nA ResponseWriter may not be used after the Handler.ServeHTTP method\nhas returned.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ResponseWriter"}
  ResponseWriter)

JOKER TYPE go.std.net.http/RoundTripper:
(def
  ^{:doc "RoundTripper is an interface representing the ability to execute a\nsingle HTTP transaction, obtaining the Response for a given Request.\n\nA RoundTripper must be safe for concurrent use by multiple\ngoroutines.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RoundTripper"}
  RoundTripper)

JOKER TYPE go.std.net.http/SameSite:
(def
  ^{:doc "SameSite allows a server to define a cookie attribute making it impossible for\nthe browser to send this cookie along with cross-site requests. The main\ngoal is to mitigate the risk of cross-origin information leakage, and provide\nsome protection against cross-site request forgery attacks.\n\nSee https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00 for details.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SameSite"}
  SameSite)

JOKER TYPE go.std.net.http/ServeMux:
(def
  ^{:doc "ServeMux is an HTTP request multiplexer.\nIt matches the URL of each incoming request against a list of registered\npatterns and calls the handler for the pattern that\nmost closely matches the URL.\n\nPatterns name fixed, rooted paths, like \"/favicon.ico\",\nor rooted subtrees, like \"/images/\" (note the trailing slash).\nLonger patterns take precedence over shorter ones, so that\nif there are handlers registered for both \"/images/\"\nand \"/images/thumbnails/\", the latter handler will be\ncalled for paths beginning \"/images/thumbnails/\" and the\nformer will receive requests for any other paths in the\n\"/images/\" subtree.\n\nNote that since a pattern ending in a slash names a rooted subtree,\nthe pattern \"/\" matches all paths not matched by other registered\npatterns, not just the URL with Path == \"/\".\n\nIf a subtree has been registered and a request is received naming the\nsubtree root without its trailing slash, ServeMux redirects that\nrequest to the subtree root (adding the trailing slash). This behavior can\nbe overridden with a separate registration for the path without\nthe trailing slash. For example, registering \"/images/\" causes ServeMux\nto redirect a request for \"/images\" to \"/images/\", unless \"/images\" has\nbeen registered separately.\n\nPatterns may optionally begin with a host name, restricting matches to\nURLs on that host only. Host-specific patterns take precedence over\ngeneral patterns, so that a handler might register for the two patterns\n\"/codesearch\" and \"codesearch.google.com/\" without also taking over\nrequests for \"http://www.google.com/\".\n\nServeMux also takes care of sanitizing the URL request path and the Host\nheader, stripping the port number and redirecting any request containing . or\n.. elements or repeated slashes to an equivalent, cleaner URL.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ServeMux"}
  ServeMux)

JOKER TYPE go.std.net.http/Server:
(def
  ^{:doc "A Server defines parameters for running an HTTP server.\nThe zero value for Server is a valid configuration.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Server"}
  Server)

JOKER TYPE go.std.net.http/Transport:
(def
  ^{:doc "Transport is an implementation of RoundTripper that supports HTTP,\nHTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).\n\nBy default, Transport caches connections for future re-use.\nThis may leave many open connections when accessing many hosts.\nThis behavior can be managed using Transport's CloseIdleConnections method\nand the MaxIdleConnsPerHost and DisableKeepAlives fields.\n\nTransports should be reused instead of created as needed.\nTransports are safe for concurrent use by multiple goroutines.\n\nA Transport is a low-level primitive for making HTTP and HTTPS requests.\nFor high-level functionality, such as cookies and redirects, see Client.\n\nTransport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2\nfor HTTPS URLs, depending on whether the server supports HTTP/2,\nand how the Transport is configured. The DefaultTransport supports HTTP/2.\nTo explicitly enable HTTP/2 on a transport, use golang.org/x/net/http2\nand call ConfigureTransport. See the package docs for more about HTTP/2.\n\nResponses with status codes in the 1xx range are either handled\nautomatically (100 expect-continue) or ignored. The one\nexception is HTTP status code 101 (Switching Protocols), which is\nconsidered a terminal status and returned by RoundTrip. To see the\nignored 1xx responses, use the httptrace trace package's\nClientTrace.Got1xxResponse.\n\nTransport only retries a request upon encountering a network error\nif the request is idempotent and either has no body or has its\nRequest.GetBody defined. HTTP requests are considered idempotent if\nthey have HTTP methods GET, HEAD, OPTIONS, or TRACE; or if their\nHeader map contains an \"Idempotency-Key\" or \"X-Idempotency-Key\"\nentry. If the idempotency key value is an zero-length slice, the\nrequest is treated as idempotent but the header is not sent on the\nwire.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Transport"}
  Transport)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net/http"]
    :doc "Provides a low-level interface to the net/http package.\n\nPackage http provides HTTP client and server implementations.\n\nGet, Head, Post, and PostForm make HTTP (or HTTPS) requests:\n\n\tresp, err := http.Get(\"http://example.com/\")\n\t...\n\tresp, err := http.Post(\"http://example.com/upload\", \"image/jpeg\", &buf)\n\t...\n\tresp, err := http.PostForm(\"http://example.com/form\",\n\t\turl.Values{\"key\": {\"Value\"}, \"id\": {\"123\"}})\n\nThe client must close the response body when finished with it:\n\n\tresp, err := http.Get(\"http://example.com/\")\n\tif err != nil {\n\t\t// handle error\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\t// ...\n\nFor control over HTTP client headers, redirect policy, and other\nsettings, create a Client:\n\n\tclient := &http.Client{\n\t\tCheckRedirect: redirectPolicyFunc,\n\t}\n\n\tresp, err := client.Get(\"http://example.com\")\n\t// ...\n\n\treq, err := http.NewRequest(\"GET\", \"http://example.com\", nil)\n\t// ...\n\treq.Header.Add(\"If-None-Match\", `W/\"wyzzy\"`)\n\tresp, err := client.Do(req)\n\t// ...\n\nFor control over proxies, TLS configuration, keep-alives,\ncompression, and other settings, create a Transport:\n\n\ttr := &http.Transport{\n\t\tMaxIdleConns:       10,\n\t\tIdleConnTimeout:    30 * time.Second,\n\t\tDisableCompression: true,\n\t}\n\tclient := &http.Client{Transport: tr}\n\tresp, err := client.Get(\"https://example.com\")\n\nClients and Transports are safe for concurrent use by multiple\ngoroutines and for efficiency should only be created once and re-used.\n\nListenAndServe starts an HTTP server with a given address and handler.\nThe handler is usually nil, which means to use DefaultServeMux.\nHandle and HandleFunc add handlers to DefaultServeMux:\n\n\thttp.Handle(\"/foo\", fooHandler)\n\n\thttp.HandleFunc(\"/bar\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, %q\", html.EscapeString(r.URL.Path))\n\t})\n\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n\nMore control over the server's behavior is available by creating a\ncustom Server:\n\n\ts := &http.Server{\n\t\tAddr:           \":8080\",\n\t\tHandler:        myHandler,\n\t\tReadTimeout:    10 * time.Second,\n\t\tWriteTimeout:   10 * time.Second,\n\t\tMaxHeaderBytes: 1 << 20,\n\t}\n\tlog.Fatal(s.ListenAndServe())\n\nStarting with Go 1.6, the http package has transparent support for the\nHTTP/2 protocol when using HTTPS. Programs that must disable HTTP/2\ncan do so by setting Transport.TLSNextProto (for clients) or\nServer.TLSNextProto (for servers) to a non-nil, empty\nmap. Alternatively, the following GODEBUG environment variables are\ncurrently supported:\n\n\tGODEBUG=http2client=0  # disable HTTP/2 client support\n\tGODEBUG=http2server=0  # disable HTTP/2 server support\n\tGODEBUG=http2debug=1   # enable verbose HTTP/2 debug logs\n\tGODEBUG=http2debug=2   # ... even more verbose, with frame dumps\n\nThe GODEBUG variables are not covered by Go's API compatibility\npromise. Please report any issues before disabling HTTP/2\nsupport: https://golang.org/s/http2bug\n\nThe http package's Transport and Server both automatically enable\nHTTP/2 support for simple configurations. To enable HTTP/2 for more\ncomplex configurations, to use lower-level HTTP/2 features, or to use\na newer version of Go's http2 package, import \"golang.org/x/net/http2\"\ndirectly and use its ConfigureTransport and/or ConfigureServer\nfunctions. Manually configuring HTTP/2 via the golang.org/x/net/http2\npackage takes precedence over the net/http package's built-in HTTP/2\nsupport.\n"
    :empty false}
  go.std.net.http)
JOKER TYPE net/http/cgi.Handler from net/http/cgi/host.go:
;; (defn ^"GoObject" Handler.
;;   "Constructor for cgi.Handler"
;;   {:added "1.0"
;;    :go "_ConstructHandler(_v)"}
;;   [^Object _v])

JOKER FUNC net/http/cgi.Request from net/http/cgi/child.go:
(defn Request
  "Request returns the HTTP request as represented in the current\nenvironment. This assumes the current program is being run\nby a web server in a CGI environment.\nThe returned Request's Body is populated, if applicable.\n\nGo return type: (*net/http.Request, error)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
  {:added "1.0"
   :go "__request()"}
  [])

JOKER FUNC net/http/cgi.RequestFromMap from net/http/cgi/child.go:
;; (defn RequestFromMap
;;   "RequestFromMap creates an http.Request from CGI variables.\nThe returned Request's Body field is not populated.\n\nGo input arguments: (params map[])\n\nGo return type: (*net/http.Request, error)\n\nJoker input arguments: [^{} params]\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
;;   {:added "1.0"
;;    :go "__requestFromMap(ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa()))"}
;;   [^{} __params])

JOKER FUNC net/http/cgi.Serve from net/http/cgi/child.go:
;; (defn ^"Error" Serve
;;   "Serve executes the provided Handler on the currently active CGI\nrequest, if any. If there's no current CGI environment\nan error is returned. The provided handler may be nil to use\nhttp.DefaultServeMux.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "cgi.Serve(*__handler)"}
;;   [^http/Handler __handler])

JOKER TYPE go.std.net.http.cgi/Handler:
(def
  ^{:doc "Handler runs an executable in a subprocess with a CGI environment.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Handler"}
  Handler)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/http/cgi package.\n\nPackage cgi implements CGI (Common Gateway Interface) as specified\nin RFC 3875.\n\nNote that using CGI means starting a new process to handle each\nrequest, which is typically less efficient than using a\nlong-running server. This package is intended primarily for\ncompatibility with existing systems.\n"
    :empty false}
  go.std.net.http.cgi)
JOKER TYPE net/http/cookiejar.Jar from net/http/cookiejar/jar.go:
(defn ^"GoObject" Jar.
  "Constructor for cookiejar.Jar"
  {:added "1.0"
   :go "_ConstructJar(_v)"}
  [^Object _v])

JOKER TYPE net/http/cookiejar.Options from net/http/cookiejar/jar.go:
;; (defn ^"GoObject" Options.
;;   "Constructor for cookiejar.Options"
;;   {:added "1.0"
;;    :go "_ConstructOptions(_v)"}
;;   [^Object _v])

JOKER TYPE net/http/cookiejar.PublicSuffixList from net/http/cookiejar/jar.go:
;; (defn ^"GoObject" PublicSuffixList.
;;   "Constructor for cookiejar.PublicSuffixList"
;;   {:added "1.0"
;;    :go "_ConstructPublicSuffixList(_v)"}
;;   [^Object _v])

JOKER FUNC net/http/cookiejar.New from net/http/cookiejar/jar.go:
(defn New
  "New returns a new cookie jar. A nil *Options is equivalent to a zero\nOptions.\n\nGo input arguments: (o *Options)\n\nGo return type: (*Jar, error)\n\nJoker input arguments: [^(atom-of go.std.net.http.cookiejar/Options) o]\n\nJoker return type: [(atom-of go.std.net.http.cookiejar/Jar) Error]"
  {:added "1.0"
   :go "__new(__o)"}
  [^cookiejar/Options __o])

JOKER TYPE go.std.net.http.cookiejar/Jar:
(def
  ^{:doc "Jar implements the http.CookieJar interface from the net/http package.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Jar"}
  Jar)

JOKER TYPE go.std.net.http.cookiejar/Options:
(def
  ^{:doc "Options are the options for creating a new Jar.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Options"}
  Options)

JOKER TYPE go.std.net.http.cookiejar/PublicSuffixList:
(def
  ^{:doc "PublicSuffixList provides the public suffix of a domain. For example:\n     - the public suffix of \"example.com\" is \"com\",\n     - the public suffix of \"foo1.foo2.foo3.co.uk\" is \"co.uk\", and\n     - the public suffix of \"bar.pvt.k12.ma.us\" is \"pvt.k12.ma.us\".\n\nImplementations of PublicSuffixList must be safe for concurrent use by\nmultiple goroutines.\n\nAn implementation that always returns \"\" is valid and may be useful for\ntesting but it is not secure: it means that the HTTP server for foo.com can\nset a cookie for bar.com.\n\nA public suffix list implementation is in the package\ngolang.org/x/net/publicsuffix.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PublicSuffixList"}
  PublicSuffixList)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/http/cookiejar package.\n\nPackage cookiejar implements an in-memory RFC 6265-compliant http.CookieJar.\n"
    :empty false}
  go.std.net.http.cookiejar)
JOKER VARIABLE ErrConnClosed from net/http/fcgi/child.go:
(def
  ^{:doc "ErrConnClosed is returned by Read when a handler attempts to read the body of\na request after the connection to the web server has been closed.\n"
    :added "1.0"
    :tag "Var"
    :go "fcgi.ErrConnClosed"}
  ErrConnClosed)

JOKER VARIABLE ErrRequestAborted from net/http/fcgi/child.go:
(def
  ^{:doc "ErrRequestAborted is returned by Read when a handler attempts to read the\nbody of a request that has been aborted by the web server.\n"
    :added "1.0"
    :tag "Var"
    :go "fcgi.ErrRequestAborted"}
  ErrRequestAborted)

JOKER FUNC net/http/fcgi.ProcessEnv from net/http/fcgi/child.go:
;; (defn ProcessEnv
;;   "ProcessEnv returns FastCGI environment variables associated with the request r\nfor which no effort was made to be included in the request itself - the data\nis hidden in the request's context. As an example, if REMOTE_USER is set for a\nrequest, it will not be found anywhere in r, but it will be included in\nProcessEnv's response (via r's context).\n\nGo input arguments: (r *http.Request)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) r]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.MapType at: /usr/local/go/src/net/http/fcgi/child.go:358:34)"
;;   {:added "1.0"
;;    :go "__processEnv(__r)"}
;;   [^http/Request __r])

JOKER FUNC net/http/fcgi.Serve from net/http/fcgi/child.go:
;; (defn ^"Error" Serve
;;   "Serve accepts incoming FastCGI connections on the listener l, creating a new\ngoroutine for each. The goroutine reads requests and then calls handler\nto reply to them.\nIf l is nil, Serve accepts connections from os.Stdin.\nIf handler is nil, http.DefaultServeMux is used.\n\nGo input arguments: (l net.Listener, handler http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "fcgi.Serve(*__l, *__handler)"}
;;   [^net/Listener __l, ^http/Handler __handler])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net/http/fcgi"]
    :doc "Provides a low-level interface to the net/http/fcgi package.\n\nPackage fcgi implements the FastCGI protocol.\n\nSee https://fast-cgi.github.io/ for an unofficial mirror of the\noriginal documentation.\n\nCurrently only the responder role is supported.\n"
    :empty false}
  go.std.net.http.fcgi)
JOKER CONSTANT DefaultRemoteAddr from net/http/httptest/recorder.go:
(def
  ^{:doc "DefaultRemoteAddr is the default remote address to return in RemoteAddr if\nan explicit DefaultRemoteAddr isn't set on ResponseRecorder.\n"
    :added "1.0"
    :tag "String"
    :go "httptest.DefaultRemoteAddr"}
  DefaultRemoteAddr)

JOKER TYPE net/http/httptest.ResponseRecorder from net/http/httptest/recorder.go:
;; (defn ^"GoObject" ResponseRecorder.
;;   "Constructor for httptest.ResponseRecorder"
;;   {:added "1.0"
;;    :go "_ConstructResponseRecorder(_v)"}
;;   [^Object _v])

JOKER TYPE net/http/httptest.Server from net/http/httptest/server.go:
;; (defn ^"GoObject" Server.
;;   "Constructor for httptest.Server"
;;   {:added "1.0"
;;    :go "_ConstructServer(_v)"}
;;   [^Object _v])

JOKER FUNC net/http/httptest.NewRecorder from net/http/httptest/recorder.go:
(defn NewRecorder
  "NewRecorder returns an initialized ResponseRecorder.\n\nGo return type: *ResponseRecorder\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.net.http.httptest/ResponseRecorder)"
  {:added "1.0"
   :go "__newRecorder()"}
  [])

JOKER FUNC net/http/httptest.NewRequest from net/http/httptest/httptest.go:
;; (defn NewRequest
;;   "NewRequest returns a new incoming server Request, suitable\nfor passing to an http.Handler for testing.\n\nThe target is the RFC 7230 \"request-target\": it may be either a\npath or an absolute URL. If target is an absolute URL, the host name\nfrom the URL is used. Otherwise, \"example.com\" is used.\n\nThe TLS field is set to a non-nil dummy value if target has scheme\n\"https\".\n\nThe Request.Proto is always HTTP/1.1.\n\nAn empty method means \"GET\".\n\nThe provided body may be nil. If the body is of type *bytes.Reader,\n*strings.Reader, or *bytes.Buffer, the Request.ContentLength is\nset.\n\nNewRequest panics on error for ease of use in testing, where a\npanic is acceptable.\n\nTo generate a client HTTP request instead of a server request, see\nthe NewRequest function in the net/http package.\n\nGo input arguments: (method string, target string, body io.Reader)\n\nGo return type: *net/http.Request\n\nJoker input arguments: [^String method, ^String target, ^go.std.io/Reader body]\n\nJoker return type: (atom-of go.std.net.http/Request)"
;;   {:added "1.0"
;;    :go "__newRequest(__method, __target, *__body)"}
;;   [^String __method, ^String __target, ^io/Reader __body])

JOKER FUNC net/http/httptest.NewServer from net/http/httptest/server.go:
;; (defn NewServer
;;   "NewServer starts and returns a new Server.\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: (atom-of go.std.net.http.httptest/Server)"
;;   {:added "1.0"
;;    :go "__newServer(*__handler)"}
;;   [^http/Handler __handler])

JOKER FUNC net/http/httptest.NewTLSServer from net/http/httptest/server.go:
;; (defn NewTLSServer
;;   "NewTLSServer starts and returns a new Server using TLS.\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: (atom-of go.std.net.http.httptest/Server)"
;;   {:added "1.0"
;;    :go "__newTLSServer(*__handler)"}
;;   [^http/Handler __handler])

JOKER FUNC net/http/httptest.NewUnstartedServer from net/http/httptest/server.go:
;; (defn NewUnstartedServer
;;   "NewUnstartedServer returns a new Server but doesn't start it.\n\nAfter changing its configuration, the caller should call Start or\nStartTLS.\n\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: (atom-of go.std.net.http.httptest/Server)"
;;   {:added "1.0"
;;    :go "__newUnstartedServer(*__handler)"}
;;   [^http/Handler __handler])

JOKER TYPE go.std.net.http.httptest/ResponseRecorder:
(def
  ^{:doc "ResponseRecorder is an implementation of http.ResponseWriter that\nrecords its mutations for later inspection in tests.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ResponseRecorder"}
  ResponseRecorder)

JOKER TYPE go.std.net.http.httptest/Server:
(def
  ^{:doc "A Server is an HTTP server listening on a system-chosen port on the\nlocal loopback interface, for use in end-to-end HTTP tests.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Server"}
  Server)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net/http/httptest"]
    :doc "Provides a low-level interface to the net/http/httptest package.\n\nPackage httptest provides utilities for HTTP testing.\n"
    :empty false}
  go.std.net.http.httptest)
JOKER FUNC net/http/httptrace.ContextClientTrace from net/http/httptrace/trace.go:
;; (defn ContextClientTrace
;;   "ContextClientTrace returns the ClientTrace associated with the\nprovided context. If none, it returns nil.\n\nGo input arguments: (ctx context.Context)\n\nGo return type: *ClientTrace\n\nJoker input arguments: [^go.std.context/Context ctx]\n\nJoker return type: (atom-of go.std.net.http.httptrace/ClientTrace)"
;;   {:added "1.0"
;;    :go "__contextClientTrace(*__ctx)"}
;;   [^context/Context __ctx])

JOKER FUNC net/http/httptrace.WithClientTrace from net/http/httptrace/trace.go:
;; (defn WithClientTrace
;;   "WithClientTrace returns a new context based on the provided parent\nctx. HTTP client requests made with the returned context will use\nthe provided trace hooks, in addition to any previous hooks\nregistered with ctx. Any hooks defined in the provided trace will\nbe called first.\n\nGo input arguments: (ctx context.Context, trace *ClientTrace)\n\nGo return type: context.Context\n\nJoker input arguments: [^go.std.context/Context ctx, ^(atom-of go.std.net.http.httptrace/ClientTrace) trace]\n\nJoker return type: go.std.context/Context"
;;   {:added "1.0"
;;    :go "__withClientTrace(*__ctx, __trace)"}
;;   [^context/Context __ctx, ^httptrace/ClientTrace __trace])

JOKER TYPE go.std.net.http.httptrace/ClientTrace:
(def
  ^{:doc "ClientTrace is a set of hooks to run at various stages of an outgoing\nHTTP request. Any particular hook may be nil. Functions may be\ncalled concurrently from different goroutines and some may be called\nafter the request has completed or failed.\n\nClientTrace currently traces a single HTTP request & response\nduring a single round trip and has no hooks that span a series\nof redirected requests.\n\nSee https://blog.golang.org/http-tracing for more.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ClientTrace"}
  ClientTrace)

JOKER TYPE go.std.net.http.httptrace/DNSDoneInfo:
(def
  ^{:doc "DNSDoneInfo contains information about the results of a DNS lookup.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DNSDoneInfo"}
  DNSDoneInfo)

JOKER TYPE go.std.net.http.httptrace/DNSStartInfo:
(def
  ^{:doc "DNSStartInfo contains information about a DNS request.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DNSStartInfo"}
  DNSStartInfo)

JOKER TYPE go.std.net.http.httptrace/GotConnInfo:
(def
  ^{:doc "GotConnInfo is the argument to the ClientTrace.GotConn function and\ncontains information about the obtained connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_GotConnInfo"}
  GotConnInfo)

JOKER TYPE go.std.net.http.httptrace/WroteRequestInfo:
(def
  ^{:doc "WroteRequestInfo contains information provided to the WroteRequest\nhook.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_WroteRequestInfo"}
  WroteRequestInfo)

JOKER VARIABLE ErrClosed from net/http/httputil/persist.go:
(def
  ^{:doc "Deprecated: No longer used.\n"
    :added "1.0"
    :tag "Var"
    :go "httputil.ErrClosed"}
  ErrClosed)

JOKER VARIABLE ErrLineTooLong from net/http/httputil/httputil.go:
(def
  ^{:doc "ErrLineTooLong is returned when reading malformed chunked data\nwith lines that are too long.\n"
    :added "1.0"
    :tag "Var"
    :go "httputil.ErrLineTooLong"}
  ErrLineTooLong)

JOKER VARIABLE ErrPersistEOF from net/http/httputil/persist.go:
(def
  ^{:doc "Deprecated: No longer used.\n"
    :added "1.0"
    :tag "Var"
    :go "httputil.ErrPersistEOF"}
  ErrPersistEOF)

JOKER VARIABLE ErrPipeline from net/http/httputil/persist.go:
(def
  ^{:doc "Deprecated: No longer used.\n"
    :added "1.0"
    :tag "Var"
    :go "httputil.ErrPipeline"}
  ErrPipeline)

JOKER TYPE net/http/httputil.BufferPool from net/http/httputil/reverseproxy.go:
;; (defn ^"GoObject" BufferPool.
;;   "Constructor for httputil.BufferPool"
;;   {:added "1.0"
;;    :go "_ConstructBufferPool(_v)"}
;;   [^Object _v])

JOKER TYPE net/http/httputil.ClientConn from net/http/httputil/persist.go:
(defn ^"GoObject" ClientConn.
  "Constructor for httputil.ClientConn"
  {:added "1.0"
   :go "_ConstructClientConn(_v)"}
  [^Object _v])

JOKER TYPE net/http/httputil.ReverseProxy from net/http/httputil/reverseproxy.go:
;; (defn ^"GoObject" ReverseProxy.
;;   "Constructor for httputil.ReverseProxy"
;;   {:added "1.0"
;;    :go "_ConstructReverseProxy(_v)"}
;;   [^Object _v])

JOKER TYPE net/http/httputil.ServerConn from net/http/httputil/persist.go:
(defn ^"GoObject" ServerConn.
  "Constructor for httputil.ServerConn"
  {:added "1.0"
   :go "_ConstructServerConn(_v)"}
  [^Object _v])

JOKER FUNC net/http/httputil.DumpRequest from net/http/httputil/dump.go:
;; (defn DumpRequest
;;   "DumpRequest returns the given request in its HTTP/1.x wire\nrepresentation. It should only be used by servers to debug client\nrequests. The returned representation is an approximation only;\nsome details of the initial request are lost while parsing it into\nan http.Request. In particular, the order and case of header field\nnames are lost. The order of values in multi-valued headers is kept\nintact. HTTP/2 requests are dumped in HTTP/1.x form, not in their\noriginal binary representations.\n\nIf body is true, DumpRequest also returns the body. To do so, it\nconsumes req.Body and then replaces it with a new io.ReadCloser\nthat yields the same bytes. If DumpRequest returns an error,\nthe state of req is undefined.\n\nThe documentation for http.Request.Write details which fields\nof req are included in the dump.\n\nGo input arguments: (req *http.Request, body bool)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req, ^Boolean body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__dumpRequest(__req, __body)"}
;;   [^http/Request __req, ^Boolean __body])

JOKER FUNC net/http/httputil.DumpRequestOut from net/http/httputil/dump.go:
;; (defn DumpRequestOut
;;   "DumpRequestOut is like DumpRequest but for outgoing client requests. It\nincludes any headers that the standard http.Transport adds, such as\nUser-Agent.\n\nGo input arguments: (req *http.Request, body bool)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req, ^Boolean body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__dumpRequestOut(__req, __body)"}
;;   [^http/Request __req, ^Boolean __body])

JOKER FUNC net/http/httputil.DumpResponse from net/http/httputil/dump.go:
;; (defn DumpResponse
;;   "DumpResponse is like DumpRequest but dumps a response.\n\nGo input arguments: (resp *http.Response, body bool)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Response) resp, ^Boolean body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__dumpResponse(__resp, __body)"}
;;   [^http/Response __resp, ^Boolean __body])

JOKER FUNC net/http/httputil.NewChunkedReader from net/http/httputil/httputil.go:
;; (defn NewChunkedReader
;;   "NewChunkedReader returns a new chunkedReader that translates the data read from r\nout of HTTP \"chunked\" format before returning it.\nThe chunkedReader returns io.EOF when the final 0-length chunk is read.\n\nNewChunkedReader is not needed by normal applications. The http package\nautomatically decodes chunking when reading response bodies.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__newChunkedReader(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC net/http/httputil.NewChunkedWriter from net/http/httputil/httputil.go:
;; (defn NewChunkedWriter
;;   "NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP\n\"chunked\" format before writing them to w. Closing the returned chunkedWriter\nsends the final 0-length chunk that marks the end of the stream but does\nnot send the final CRLF that appears after trailers; trailers and the last\nCRLF must be written separately.\n\nNewChunkedWriter is not needed by normal applications. The http\npackage adds chunking automatically if handlers don't set a\nContent-Length header. Using NewChunkedWriter inside a handler\nwould result in double chunking or chunking with a Content-Length\nlength, both of which are wrong.\n\nGo input arguments: (w io.Writer)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "__newChunkedWriter(*__w)"}
;;   [^io/Writer __w])

JOKER FUNC net/http/httputil.NewClientConn from net/http/httputil/persist.go:
;; (defn NewClientConn
;;   "NewClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo input arguments: (c net.Conn, r *bufio.Reader)\n\nGo return type: *ClientConn\n\nJoker input arguments: [^go.std.net/Conn c, ^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.http.httputil/ClientConn)"
;;   {:added "1.0"
;;    :go "__newClientConn(*__c, __r)"}
;;   [^net/Conn __c, ^bufio/Reader __r])

JOKER FUNC net/http/httputil.NewProxyClientConn from net/http/httputil/persist.go:
;; (defn NewProxyClientConn
;;   "NewProxyClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo input arguments: (c net.Conn, r *bufio.Reader)\n\nGo return type: *ClientConn\n\nJoker input arguments: [^go.std.net/Conn c, ^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.http.httputil/ClientConn)"
;;   {:added "1.0"
;;    :go "__newProxyClientConn(*__c, __r)"}
;;   [^net/Conn __c, ^bufio/Reader __r])

JOKER FUNC net/http/httputil.NewServerConn from net/http/httputil/persist.go:
;; (defn NewServerConn
;;   "NewServerConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Server in package net/http instead.\n\nGo input arguments: (c net.Conn, r *bufio.Reader)\n\nGo return type: *ServerConn\n\nJoker input arguments: [^go.std.net/Conn c, ^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.http.httputil/ServerConn)"
;;   {:added "1.0"
;;    :go "__newServerConn(*__c, __r)"}
;;   [^net/Conn __c, ^bufio/Reader __r])

JOKER FUNC net/http/httputil.NewSingleHostReverseProxy from net/http/httputil/reverseproxy.go:
;; (defn NewSingleHostReverseProxy
;;   "NewSingleHostReverseProxy returns a new ReverseProxy that routes\nURLs to the scheme, host, and base path provided in target. If the\ntarget's path is \"/base\" and the incoming request was for \"/dir\",\nthe target request will be for /base/dir.\nNewSingleHostReverseProxy does not rewrite the Host header.\nTo rewrite Host headers, use ReverseProxy directly with a custom\nDirector policy.\n\nGo input arguments: (target *url.URL)\n\nGo return type: *ReverseProxy\n\nJoker input arguments: [^(atom-of go.std.net.url/URL) target]\n\nJoker return type: (atom-of go.std.net.http.httputil/ReverseProxy)"
;;   {:added "1.0"
;;    :go "__newSingleHostReverseProxy(__target)"}
;;   [^url/URL __target])

JOKER TYPE go.std.net.http.httputil/BufferPool:
(def
  ^{:doc "A BufferPool is an interface for getting and returning temporary\nbyte slices for use by io.CopyBuffer.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BufferPool"}
  BufferPool)

JOKER TYPE go.std.net.http.httputil/ClientConn:
(def
  ^{:doc "ClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use Client or Transport in package net/http instead.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ClientConn"}
  ClientConn)

JOKER TYPE go.std.net.http.httputil/ReverseProxy:
(def
  ^{:doc "ReverseProxy is an HTTP Handler that takes an incoming request and\nsends it to another server, proxying the response back to the\nclient.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ReverseProxy"}
  ReverseProxy)

JOKER TYPE go.std.net.http.httputil/ServerConn:
(def
  ^{:doc "ServerConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Server in package net/http instead.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ServerConn"}
  ServerConn)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net/http/httputil"]
    :doc "Provides a low-level interface to the net/http/httputil package.\n\nPackage httputil provides HTTP utility functions, complementing the\nmore common ones in the net/http package.\n"
    :empty false}
  go.std.net.http.httputil)
JOKER FUNC net/http/pprof.Cmdline from net/http/pprof/pprof.go:
;; (defn Cmdline
;;   "Cmdline responds with the running program's\ncommand line, with arguments separated by NUL bytes.\nThe package initialization registers it as /debug/pprof/cmdline.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__cmdline(*__w, __r)"}
;;   [^http/ResponseWriter __w, ^http/Request __r])

JOKER FUNC net/http/pprof.Handler from net/http/pprof/pprof.go:
(defn Handler
  "Handler returns an HTTP handler that serves the named profile.\n\nGo input arguments: (name string)\n\nGo return type: net/http.Handler\n\nJoker input arguments: [^String name]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__handler(__name)"}
  [^String __name])

JOKER FUNC net/http/pprof.Index from net/http/pprof/pprof.go:
;; (defn Index
;;   "Index responds with the pprof-formatted profile named by the request.\nFor example, \"/debug/pprof/heap\" serves the \"heap\" profile.\nIndex responds to a request for \"/debug/pprof/\" with an HTML page\nlisting the available profiles.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__index(*__w, __r)"}
;;   [^http/ResponseWriter __w, ^http/Request __r])

JOKER FUNC net/http/pprof.Profile from net/http/pprof/pprof.go:
;; (defn Profile
;;   "Profile responds with the pprof-formatted cpu profile.\nProfiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.\nThe package initialization registers it as /debug/pprof/profile.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__profile(*__w, __r)"}
;;   [^http/ResponseWriter __w, ^http/Request __r])

JOKER FUNC net/http/pprof.Symbol from net/http/pprof/pprof.go:
;; (defn Symbol
;;   "Symbol looks up the program counters listed in the request,\nresponding with a table mapping program counters to function names.\nThe package initialization registers it as /debug/pprof/symbol.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__symbol(*__w, __r)"}
;;   [^http/ResponseWriter __w, ^http/Request __r])

JOKER FUNC net/http/pprof.Trace from net/http/pprof/pprof.go:
;; (defn Trace
;;   "Trace responds with the execution trace in binary form.\nTracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.\nThe package initialization registers it as /debug/pprof/trace.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__trace(*__w, __r)"}
;;   [^http/ResponseWriter __w, ^http/Request __r])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/http/pprof package.\n\nPackage pprof serves via its HTTP server runtime profiling data\nin the format expected by the pprof visualization tool.\n\nThe package is typically only imported for the side effect of\nregistering its HTTP handlers.\nThe handled paths all begin with /debug/pprof/.\n\nTo use pprof, link this package into your program:\n\timport _ \"net/http/pprof\"\n\nIf your application is not already running an http server, you\nneed to start one. Add \"net/http\" and \"log\" to your imports and\nthe following code to your main function:\n\n\tgo func() {\n\t\tlog.Println(http.ListenAndServe(\"localhost:6060\", nil))\n\t}()\n\nThen use the pprof tool to look at the heap profile:\n\n\tgo tool pprof http://localhost:6060/debug/pprof/heap\n\nOr to look at a 30-second CPU profile:\n\n\tgo tool pprof http://localhost:6060/debug/pprof/profile?seconds=30\n\nOr to look at the goroutine blocking profile, after calling\nruntime.SetBlockProfileRate in your program:\n\n\tgo tool pprof http://localhost:6060/debug/pprof/block\n\nOr to collect a 5-second execution trace:\n\n\twget http://localhost:6060/debug/pprof/trace?seconds=5\n\nOr to look at the holders of contended mutexes, after calling\nruntime.SetMutexProfileFraction in your program:\n\n\tgo tool pprof http://localhost:6060/debug/pprof/mutex\n\nTo view all available profiles, open http://localhost:6060/debug/pprof/\nin your browser.\n\nFor a study of the facility in action, visit\n\n\thttps://blog.golang.org/2011/06/profiling-go-programs.html\n"
    :empty false}
  go.std.net.http.pprof)
JOKER VARIABLE ErrHeaderNotPresent from net/mail/message.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "mail.ErrHeaderNotPresent"}
  ErrHeaderNotPresent)

JOKER TYPE net/mail.Address from net/mail/message.go:
(defn ^"GoObject" Address.
  "Constructor for mail.Address"
  {:added "1.0"
   :go "_ConstructAddress(_v)"}
  [^Object _v])

JOKER TYPE net/mail.AddressParser from net/mail/message.go:
;; (defn ^"GoObject" AddressParser.
;;   "Constructor for mail.AddressParser"
;;   {:added "1.0"
;;    :go "_ConstructAddressParser(_v)"}
;;   [^Object _v])

JOKER TYPE net/mail.Header from net/mail/message.go:
;; (defn ^"GoObject" Header.
;;   "Constructor for mail.Header"
;;   {:added "1.0"
;;    :go "_ConstructHeader(_v)"}
;;   [^Object _v])

JOKER TYPE net/mail.Message from net/mail/message.go:
;; (defn ^"GoObject" Message.
;;   "Constructor for mail.Message"
;;   {:added "1.0"
;;    :go "_ConstructMessage(_v)"}
;;   [^Object _v])

JOKER FUNC net/mail.ParseAddress from net/mail/message.go:
(defn ParseAddress
  "Parses a single RFC 5322 address, e.g. \"Barry Gibbs <bg@example.com>\"\n\nGo input arguments: (address string)\n\nGo return type: (*Address, error)\n\nJoker input arguments: [^String address]\n\nJoker return type: [(atom-of go.std.net.mail/Address) Error]"
  {:added "1.0"
   :go "__parseAddress(__address)"}
  [^String __address])

JOKER FUNC net/mail.ParseAddressList from net/mail/message.go:
(defn ParseAddressList
  "ParseAddressList parses the given string as a list of addresses.\n\nGo input arguments: (list string)\n\nGo return type: ([]*Address, error)\n\nJoker input arguments: [^String list]\n\nJoker return type: [(vector-of (atom-of go.std.net.mail/Address)) Error]"
  {:added "1.0"
   :go "__parseAddressList(__list)"}
  [^String __list])

JOKER FUNC net/mail.ParseDate from net/mail/message.go:
(defn ParseDate
  "ParseDate parses an RFC 5322 date string.\n\nGo input arguments: (date string)\n\nGo return type: (time.Time, error)\n\nJoker input arguments: [^String date]\n\nJoker return type: [go.std.time/Time Error]"
  {:added "1.0"
   :go "__parseDate(__date)"}
  [^String __date])

JOKER FUNC net/mail.ReadMessage from net/mail/message.go:
;; (defn ReadMessage
;;   "ReadMessage reads a message from r.\nThe headers are parsed, and the body of the message will be available\nfor reading from msg.Body.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (msg *Message, err error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [(atom-of go.std.net.mail/Message) Error]"
;;   {:added "1.0"
;;    :go "__readMessage(*__r)"}
;;   [^io/Reader __r])

JOKER TYPE go.std.net.mail/Address:
(def
  ^{:doc "Address represents a single mail address.\nAn address such as \"Barry Gibbs <bg@example.com>\" is represented\nas Address{Name: \"Barry Gibbs\", Address: \"bg@example.com\"}.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Address"}
  Address)

JOKER TYPE go.std.net.mail/AddressParser:
(def
  ^{:doc "An AddressParser is an RFC 5322 address parser.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_AddressParser"}
  AddressParser)

JOKER TYPE go.std.net.mail/Header:
(def
  ^{:doc "A Header represents the key-value pairs in a mail message header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Header"}
  Header)

JOKER TYPE go.std.net.mail/Message:
(def
  ^{:doc "A Message represents a parsed mail message.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Message"}
  Message)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net/mail"]
    :doc "Provides a low-level interface to the net/mail package.\n\nPackage mail implements parsing of mail messages.\n\nFor the most part, this package follows the syntax as specified by RFC 5322 and\nextended by RFC 6532.\nNotable divergences:\n\t* Obsolete address formats are not parsed, including addresses with\n\t  embedded route information.\n\t* The full range of spacing (the CFWS syntax element) is not supported,\n\t  such as breaking addresses across lines.\n\t* No unicode normalization is performed.\n\t* The special characters ()[]:;@\\, are allowed to appear unquoted in names.\n"
    :empty false}
  go.std.net.mail)
JOKER CONSTANT DefaultDebugPath from net/rpc/server.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "String"
    :go "rpc.DefaultDebugPath"}
  DefaultDebugPath)

JOKER CONSTANT DefaultRPCPath from net/rpc/server.go:
(def
  ^{:doc "Defaults used by HandleHTTP\n"
    :added "1.0"
    :tag "String"
    :go "rpc.DefaultRPCPath"}
  DefaultRPCPath)

JOKER VARIABLE DefaultServer from net/rpc/server.go:
(def
  ^{:doc "DefaultServer is the default instance of *Server.\n"
    :added "1.0"
    :tag "Var"
    :go "rpc.DefaultServer"}
  DefaultServer)

JOKER VARIABLE ErrShutdown from net/rpc/client.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "rpc.ErrShutdown"}
  ErrShutdown)

JOKER TYPE net/rpc.Call from net/rpc/client.go:
;; (defn ^"GoObject" Call.
;;   "Constructor for rpc.Call"
;;   {:added "1.0"
;;    :go "_ConstructCall(_v)"}
;;   [^Object _v])

JOKER TYPE net/rpc.Client from net/rpc/client.go:
(defn ^"GoObject" Client.
  "Constructor for rpc.Client"
  {:added "1.0"
   :go "_ConstructClient(_v)"}
  [^Object _v])

JOKER TYPE net/rpc.ClientCodec from net/rpc/client.go:
;; (defn ^"GoObject" ClientCodec.
;;   "Constructor for rpc.ClientCodec"
;;   {:added "1.0"
;;    :go "_ConstructClientCodec(_v)"}
;;   [^Object _v])

JOKER TYPE net/rpc.Request from net/rpc/server.go:
(defn ^"GoObject" Request.
  "Constructor for rpc.Request"
  {:added "1.0"
   :go "_ConstructRequest(_v)"}
  [^Object _v])

JOKER TYPE net/rpc.Response from net/rpc/server.go:
(defn ^"GoObject" Response.
  "Constructor for rpc.Response"
  {:added "1.0"
   :go "_ConstructResponse(_v)"}
  [^Object _v])

JOKER TYPE net/rpc.Server from net/rpc/server.go:
(defn ^"GoObject" Server.
  "Constructor for rpc.Server"
  {:added "1.0"
   :go "_ConstructServer(_v)"}
  [^Object _v])

JOKER TYPE net/rpc.ServerCodec from net/rpc/server.go:
;; (defn ^"GoObject" ServerCodec.
;;   "Constructor for rpc.ServerCodec"
;;   {:added "1.0"
;;    :go "_ConstructServerCodec(_v)"}
;;   [^Object _v])

JOKER TYPE net/rpc.ServerError from net/rpc/client.go:
(defn ^"GoObject" ServerError.
  "Constructor for rpc.ServerError"
  {:added "1.0"
   :go "_ConstructServerError(_v)"}
  [^Object _v])

JOKER FUNC net/rpc.Accept from net/rpc/server.go:
;; (defn Accept
;;   "Accept accepts connections on the listener and serves requests\nto DefaultServer for each incoming connection.\nAccept blocks; the caller typically invokes it in a go statement.\n\nGo input arguments: (lis net.Listener)\n\nJoker input arguments: [^go.std.net/Listener lis]"
;;   {:added "1.0"
;;    :go "__accept(*__lis)"}
;;   [^net/Listener __lis])

JOKER FUNC net/rpc.Dial from net/rpc/client.go:
(defn Dial
  "Dial connects to an RPC server at the specified network address.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dial(__network, __address)"}
  [^String __network, ^String __address])

JOKER FUNC net/rpc.DialHTTP from net/rpc/client.go:
(defn DialHTTP
  "DialHTTP connects to an HTTP RPC server at the specified network address\nlistening on the default HTTP RPC path.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dialHTTP(__network, __address)"}
  [^String __network, ^String __address])

JOKER FUNC net/rpc.DialHTTPPath from net/rpc/client.go:
(defn DialHTTPPath
  "DialHTTPPath connects to an HTTP RPC server\nat the specified network address and path.\n\nGo input arguments: (network string, address string, path string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address, ^String path]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dialHTTPPath(__network, __address, __path)"}
  [^String __network, ^String __address, ^String __path])

JOKER FUNC net/rpc.HandleHTTP from net/rpc/server.go:
;; (defn HandleHTTP
;;   "HandleHTTP registers an HTTP handler for RPC messages to DefaultServer\non DefaultRPCPath and a debugging handler on DefaultDebugPath.\nIt is still necessary to invoke http.Serve(), typically in a go statement.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__handleHTTP()"}
;;   [])

JOKER FUNC net/rpc.NewClient from net/rpc/client.go:
;; (defn NewClient
;;   "NewClient returns a new Client to handle requests to the\nset of services at the other end of the connection.\nIt adds a buffer to the write side of the connection so\nthe header and payload are sent as a unit.\n\nThe read and write halves of the connection are serialized independently,\nso no interlocking is required. However each half may be accessed\nconcurrently so the implementation of conn should protect against\nconcurrent reads or concurrent writes.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *Client\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: (atom-of go.std.net.rpc/Client)"
;;   {:added "1.0"
;;    :go "__newClient(*__conn)"}
;;   [^io/ReadWriteCloser __conn])

JOKER FUNC net/rpc.NewClientWithCodec from net/rpc/client.go:
(defn NewClientWithCodec
  "NewClientWithCodec is like NewClient but uses the specified\ncodec to encode requests and decode responses.\n\nGo input arguments: (codec ClientCodec)\n\nGo return type: *Client\n\nJoker input arguments: [^go.std.net.rpc/ClientCodec codec]\n\nJoker return type: (atom-of go.std.net.rpc/Client)"
  {:added "1.0"
   :go "__newClientWithCodec(*__codec)"}
  [^rpc/ClientCodec __codec])

JOKER FUNC net/rpc.NewServer from net/rpc/server.go:
(defn NewServer
  "NewServer returns a new Server.\n\nGo return type: *Server\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.net.rpc/Server)"
  {:added "1.0"
   :go "__newServer()"}
  [])

JOKER FUNC net/rpc.Register from net/rpc/server.go:
;; (defn ^"Error" Register
;;   "Register publishes the receiver's methods in the DefaultServer.\n\nGo input arguments: (rcvr interface {})\n\nGo return type: error\n\nJoker input arguments: [^<protocol-or-something> rcvr]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.Register(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> __rcvr])

JOKER FUNC net/rpc.RegisterName from net/rpc/server.go:
;; (defn ^"Error" RegisterName
;;   "RegisterName is like Register but uses the provided name for the type\ninstead of the receiver's concrete type.\n\nGo input arguments: (name string, rcvr interface {})\n\nGo return type: error\n\nJoker input arguments: [^String name, ^<protocol-or-something> rcvr]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.RegisterName(__name, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^String __name, ^<protocol-or-something> __rcvr])

JOKER FUNC net/rpc.ServeCodec from net/rpc/server.go:
;; (defn ServeCodec
;;   "ServeCodec is like ServeConn but uses the specified codec to\ndecode requests and encode responses.\n\nGo input arguments: (codec ServerCodec)\n\nJoker input arguments: [^go.std.net.rpc/ServerCodec codec]"
;;   {:added "1.0"
;;    :go "__serveCodec(*__codec)"}
;;   [^rpc/ServerCodec __codec])

JOKER FUNC net/rpc.ServeConn from net/rpc/server.go:
;; (defn ServeConn
;;   "ServeConn runs the DefaultServer on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\nServeConn uses the gob wire format (see package gob) on the\nconnection. To use an alternate codec, use ServeCodec.\nSee NewClient's comment for information about concurrent access.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]"
;;   {:added "1.0"
;;    :go "__serveConn(*__conn)"}
;;   [^io/ReadWriteCloser __conn])

JOKER FUNC net/rpc.ServeRequest from net/rpc/server.go:
(defn ^"Error" ServeRequest
  "ServeRequest is like ServeCodec but synchronously serves a single request.\nIt does not close the codec upon completion.\n\nGo input arguments: (codec ServerCodec)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net.rpc/ServerCodec codec]\n\nJoker return type: Error"
  {:added "1.0"
   :go "rpc.ServeRequest(*__codec)"}
  [^rpc/ServerCodec __codec])

JOKER TYPE go.std.net.rpc/Call:
(def
  ^{:doc "Call represents an active RPC.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Call"}
  Call)

JOKER TYPE go.std.net.rpc/Client:
(def
  ^{:doc "Client represents an RPC Client.\nThere may be multiple outstanding Calls associated\nwith a single Client, and a Client may be used by\nmultiple goroutines simultaneously.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Client"}
  Client)

JOKER TYPE go.std.net.rpc/ClientCodec:
(def
  ^{:doc "A ClientCodec implements writing of RPC requests and\nreading of RPC responses for the client side of an RPC session.\nThe client calls WriteRequest to write a request to the connection\nand calls ReadResponseHeader and ReadResponseBody in pairs\nto read responses. The client calls Close when finished with the\nconnection. ReadResponseBody may be called with a nil\nargument to force the body of the response to be read and then\ndiscarded.\nSee NewClient's comment for information about concurrent access.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ClientCodec"}
  ClientCodec)

JOKER TYPE go.std.net.rpc/Request:
(def
  ^{:doc "Request is a header written before every RPC call. It is used internally\nbut documented here as an aid to debugging, such as when analyzing\nnetwork traffic.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Request"}
  Request)

JOKER TYPE go.std.net.rpc/Response:
(def
  ^{:doc "Response is a header written before every RPC return. It is used internally\nbut documented here as an aid to debugging, such as when analyzing\nnetwork traffic.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Response"}
  Response)

JOKER TYPE go.std.net.rpc/Server:
(def
  ^{:doc "Server represents an RPC Server.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Server"}
  Server)

JOKER TYPE go.std.net.rpc/ServerCodec:
(def
  ^{:doc "A ServerCodec implements reading of RPC requests and writing of\nRPC responses for the server side of an RPC session.\nThe server calls ReadRequestHeader and ReadRequestBody in pairs\nto read requests from the connection, and it calls WriteResponse to\nwrite a response back. The server calls Close when finished with the\nconnection. ReadRequestBody may be called with a nil\nargument to force the body of the request to be read and discarded.\nSee NewClient's comment for information about concurrent access.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ServerCodec"}
  ServerCodec)

JOKER TYPE go.std.net.rpc/ServerError:
(def
  ^{:doc "ServerError represents an error that has been returned from\nthe remote side of the RPC connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ServerError"}
  ServerError)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net/rpc"]
    :doc "Provides a low-level interface to the net/rpc package.\n\n\tPackage rpc provides access to the exported methods of an object across a\n\tnetwork or other I/O connection.  A server registers an object, making it visible\n\tas a service with the name of the type of the object.  After registration, exported\n\tmethods of the object will be accessible remotely.  A server may register multiple\n\tobjects (services) of different types but it is an error to register multiple\n\tobjects of the same type.\n\n\tOnly methods that satisfy these criteria will be made available for remote access;\n\tother methods will be ignored:\n\n\t\t- the method's type is exported.\n\t\t- the method is exported.\n\t\t- the method has two arguments, both exported (or builtin) types.\n\t\t- the method's second argument is a pointer.\n\t\t- the method has return type error.\n\n\tIn effect, the method must look schematically like\n\n\t\tfunc (t *T) MethodName(argType T1, replyType *T2) error\n\n\twhere T1 and T2 can be marshaled by encoding/gob.\n\tThese requirements apply even if a different codec is used.\n\t(In the future, these requirements may soften for custom codecs.)\n\n\tThe method's first argument represents the arguments provided by the caller; the\n\tsecond argument represents the result parameters to be returned to the caller.\n\tThe method's return value, if non-nil, is passed back as a string that the client\n\tsees as if created by errors.New.  If an error is returned, the reply parameter\n\twill not be sent back to the client.\n\n\tThe server may handle requests on a single connection by calling ServeConn.  More\n\ttypically it will create a network listener and call Accept or, for an HTTP\n\tlistener, HandleHTTP and http.Serve.\n\n\tA client wishing to use the service establishes a connection and then invokes\n\tNewClient on the connection.  The convenience function Dial (DialHTTP) performs\n\tboth steps for a raw network connection (an HTTP connection).  The resulting\n\tClient object has two methods, Call and Go, that specify the service and method to\n\tcall, a pointer containing the arguments, and a pointer to receive the result\n\tparameters.\n\n\tThe Call method waits for the remote call to complete while the Go method\n\tlaunches the call asynchronously and signals completion using the Call\n\tstructure's Done channel.\n\n\tUnless an explicit codec is set up, package encoding/gob is used to\n\ttransport the data.\n\n\tHere is a simple example.  A server wishes to export an object of type Arith:\n\n\t\tpackage server\n\n\t\timport \"errors\"\n\n\t\ttype Args struct {\n\t\t\tA, B int\n\t\t}\n\n\t\ttype Quotient struct {\n\t\t\tQuo, Rem int\n\t\t}\n\n\t\ttype Arith int\n\n\t\tfunc (t *Arith) Multiply(args *Args, reply *int) error {\n\t\t\t*reply = args.A * args.B\n\t\t\treturn nil\n\t\t}\n\n\t\tfunc (t *Arith) Divide(args *Args, quo *Quotient) error {\n\t\t\tif args.B == 0 {\n\t\t\t\treturn errors.New(\"divide by zero\")\n\t\t\t}\n\t\t\tquo.Quo = args.A / args.B\n\t\t\tquo.Rem = args.A % args.B\n\t\t\treturn nil\n\t\t}\n\n\tThe server calls (for HTTP service):\n\n\t\tarith := new(Arith)\n\t\trpc.Register(arith)\n\t\trpc.HandleHTTP()\n\t\tl, e := net.Listen(\"tcp\", \":1234\")\n\t\tif e != nil {\n\t\t\tlog.Fatal(\"listen error:\", e)\n\t\t}\n\t\tgo http.Serve(l, nil)\n\n\tAt this point, clients can see a service \"Arith\" with methods \"Arith.Multiply\" and\n\t\"Arith.Divide\".  To invoke one, a client first dials the server:\n\n\t\tclient, err := rpc.DialHTTP(\"tcp\", serverAddress + \":1234\")\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"dialing:\", err)\n\t\t}\n\n\tThen it can make a remote call:\n\n\t\t// Synchronous call\n\t\targs := &server.Args{7,8}\n\t\tvar reply int\n\t\terr = client.Call(\"Arith.Multiply\", args, &reply)\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"arith error:\", err)\n\t\t}\n\t\tfmt.Printf(\"Arith: %d*%d=%d\", args.A, args.B, reply)\n\n\tor\n\n\t\t// Asynchronous call\n\t\tquotient := new(Quotient)\n\t\tdivCall := client.Go(\"Arith.Divide\", args, quotient, nil)\n\t\treplyCall := <-divCall.Done\t// will be equal to divCall\n\t\t// check errors, print, etc.\n\n\tA server implementation will often provide a simple, type-safe wrapper for the\n\tclient.\n\n\tThe net/rpc package is frozen and is not accepting new features.\n"
    :empty false}
  go.std.net.rpc)
JOKER FUNC net/rpc/jsonrpc.Dial from net/rpc/jsonrpc/client.go:
(defn Dial
  "Dial connects to a JSON-RPC server at the specified network address.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*net/rpc.Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dial(__network, __address)"}
  [^String __network, ^String __address])

JOKER FUNC net/rpc/jsonrpc.NewClient from net/rpc/jsonrpc/client.go:
;; (defn NewClient
;;   "NewClient returns a new rpc.Client to handle requests to the\nset of services at the other end of the connection.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *net/rpc.Client\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: (atom-of go.std.net.rpc/Client)"
;;   {:added "1.0"
;;    :go "__newClient(*__conn)"}
;;   [^io/ReadWriteCloser __conn])

JOKER FUNC net/rpc/jsonrpc.NewClientCodec from net/rpc/jsonrpc/client.go:
;; (defn NewClientCodec
;;   "NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: net/rpc.ClientCodec\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: go.std.net.rpc/ClientCodec"
;;   {:added "1.0"
;;    :go "__newClientCodec(*__conn)"}
;;   [^io/ReadWriteCloser __conn])

JOKER FUNC net/rpc/jsonrpc.NewServerCodec from net/rpc/jsonrpc/server.go:
;; (defn NewServerCodec
;;   "NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: net/rpc.ServerCodec\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: go.std.net.rpc/ServerCodec"
;;   {:added "1.0"
;;    :go "__newServerCodec(*__conn)"}
;;   [^io/ReadWriteCloser __conn])

JOKER FUNC net/rpc/jsonrpc.ServeConn from net/rpc/jsonrpc/server.go:
;; (defn ServeConn
;;   "ServeConn runs the JSON-RPC server on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]"
;;   {:added "1.0"
;;    :go "__serveConn(*__conn)"}
;;   [^io/ReadWriteCloser __conn])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/rpc/jsonrpc package.\n\nPackage jsonrpc implements a JSON-RPC 1.0 ClientCodec and ServerCodec\nfor the rpc package.\nFor JSON-RPC 2.0 support, see https://godoc.org/?q=json-rpc+2.0\n"
    :empty false}
  go.std.net.rpc.jsonrpc)
JOKER TYPE net/smtp.Auth from net/smtp/auth.go:
;; (defn ^"GoObject" Auth.
;;   "Constructor for smtp.Auth"
;;   {:added "1.0"
;;    :go "_ConstructAuth(_v)"}
;;   [^Object _v])

JOKER TYPE net/smtp.Client from net/smtp/smtp.go:
;; (defn ^"GoObject" Client.
;;   "Constructor for smtp.Client"
;;   {:added "1.0"
;;    :go "_ConstructClient(_v)"}
;;   [^Object _v])

JOKER TYPE net/smtp.ServerInfo from net/smtp/auth.go:
;; (defn ^"GoObject" ServerInfo.
;;   "Constructor for smtp.ServerInfo"
;;   {:added "1.0"
;;    :go "_ConstructServerInfo(_v)"}
;;   [^Object _v])

JOKER FUNC net/smtp.CRAMMD5Auth from net/smtp/auth.go:
(defn CRAMMD5Auth
  "CRAMMD5Auth returns an Auth that implements the CRAM-MD5 authentication\nmechanism as defined in RFC 2195.\nThe returned Auth uses the given username and secret to authenticate\nto the server using the challenge-response mechanism.\n\nGo input arguments: (username string, secret string)\n\nGo return type: Auth\n\nJoker input arguments: [^String username, ^String secret]\n\nJoker return type: go.std.net.smtp/Auth"
  {:added "1.0"
   :go "__cRAMMD5Auth(__username, __secret)"}
  [^String __username, ^String __secret])

JOKER FUNC net/smtp.Dial from net/smtp/smtp.go:
(defn Dial
  "Dial returns a new Client connected to an SMTP server at addr.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nGo input arguments: (addr string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String addr]\n\nJoker return type: [(atom-of go.std.net.smtp/Client) Error]"
  {:added "1.0"
   :go "__dial(__addr)"}
  [^String __addr])

JOKER FUNC net/smtp.NewClient from net/smtp/smtp.go:
;; (defn NewClient
;;   "NewClient returns a new Client using an existing connection and host as a\nserver name to be used when authenticating.\n\nGo input arguments: (conn net.Conn, host string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^go.std.net/Conn conn, ^String host]\n\nJoker return type: [(atom-of go.std.net.smtp/Client) Error]"
;;   {:added "1.0"
;;    :go "__newClient(*__conn, __host)"}
;;   [^net/Conn __conn, ^String __host])

JOKER FUNC net/smtp.PlainAuth from net/smtp/auth.go:
(defn PlainAuth
  "PlainAuth returns an Auth that implements the PLAIN authentication\nmechanism as defined in RFC 4616. The returned Auth uses the given\nusername and password to authenticate to host and act as identity.\nUsually identity should be the empty string, to act as username.\n\nPlainAuth will only send the credentials if the connection is using TLS\nor is connected to localhost. Otherwise authentication will fail with an\nerror, without sending the credentials.\n\nGo input arguments: (identity string, username string, password string, host string)\n\nGo return type: Auth\n\nJoker input arguments: [^String identity, ^String username, ^String password, ^String host]\n\nJoker return type: go.std.net.smtp/Auth"
  {:added "1.0"
   :go "__plainAuth(__identity, __username, __password, __host)"}
  [^String __identity, ^String __username, ^String __password, ^String __host])

JOKER FUNC net/smtp.SendMail from net/smtp/smtp.go:
;; (defn ^"Error" SendMail
;;   "SendMail connects to the server at addr, switches to TLS if\npossible, authenticates with the optional mechanism a if possible,\nand then sends an email from address from, to addresses to, with\nmessage msg.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nThe addresses in the to parameter are the SMTP RCPT addresses.\n\nThe msg parameter should be an RFC 822-style email with headers\nfirst, a blank line, and then the message body. The lines of msg\nshould be CRLF terminated. The msg headers should usually include\nfields such as \"From\", \"To\", \"Subject\", and \"Cc\".  Sending \"Bcc\"\nmessages is accomplished by including an email address in the to\nparameter but not including it in the msg headers.\n\nThe SendMail function and the net/smtp package are low-level\nmechanisms and provide no support for DKIM signing, MIME\nattachments (see the mime/multipart package), or other mail\nfunctionality. Higher-level packages exist outside of the standard\nlibrary.\n\nGo input arguments: (addr string, a Auth, from string, to []string, msg []byte)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^go.std.net.smtp/Auth a, ^String from, ^(vector-of String) to, ^(vector-of Int) msg]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "smtp.SendMail(__addr, *__a, __from, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(__to)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__msg)))"}
;;   [^String __addr, ^smtp/Auth __a, ^String __from, ^Object __to, ^Object __msg])

JOKER TYPE go.std.net.smtp/Auth:
(def
  ^{:doc "Auth is implemented by an SMTP authentication mechanism.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Auth"}
  Auth)

JOKER TYPE go.std.net.smtp/Client:
(def
  ^{:doc "A Client represents a client connection to an SMTP server.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Client"}
  Client)

JOKER TYPE go.std.net.smtp/ServerInfo:
(def
  ^{:doc "ServerInfo records information about an SMTP server.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ServerInfo"}
  ServerInfo)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/smtp package.\n\nPackage smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321.\nIt also implements the following extensions:\n\t8BITMIME  RFC 1652\n\tAUTH      RFC 2554\n\tSTARTTLS  RFC 3207\nAdditional extensions may be handled by clients.\n\nThe smtp package is frozen and is not accepting new features.\nSome external packages provide more functionality. See:\n\n  https://godoc.org/?q=smtp\n"
    :empty false}
  go.std.net.smtp)
JOKER TYPE net/textproto.Conn from net/textproto/textproto.go:
(defn ^"GoObject" Conn.
  "Constructor for textproto.Conn"
  {:added "1.0"
   :go "_ConstructConn(_v)"}
  [^Object _v])

JOKER TYPE net/textproto.Error from net/textproto/textproto.go:
(defn ^"GoObject" Error.
  "Constructor for textproto.Error"
  {:added "1.0"
   :go "_ConstructError(_v)"}
  [^Object _v])

JOKER TYPE net/textproto.MIMEHeader from net/textproto/header.go:
;; (defn ^"GoObject" MIMEHeader.
;;   "Constructor for textproto.MIMEHeader"
;;   {:added "1.0"
;;    :go "_ConstructMIMEHeader(_v)"}
;;   [^Object _v])

JOKER TYPE net/textproto.Pipeline from net/textproto/pipeline.go:
(defn ^"GoObject" Pipeline.
  "Constructor for textproto.Pipeline"
  {:added "1.0"
   :go "_ConstructPipeline(_v)"}
  [^Object _v])

JOKER TYPE net/textproto.ProtocolError from net/textproto/textproto.go:
(defn ^"GoObject" ProtocolError.
  "Constructor for textproto.ProtocolError"
  {:added "1.0"
   :go "_ConstructProtocolError(_v)"}
  [^Object _v])

JOKER TYPE net/textproto.Reader from net/textproto/reader.go:
;; (defn ^"GoObject" Reader.
;;   "Constructor for textproto.Reader"
;;   {:added "1.0"
;;    :go "_ConstructReader(_v)"}
;;   [^Object _v])

JOKER TYPE net/textproto.Writer from net/textproto/writer.go:
;; (defn ^"GoObject" Writer.
;;   "Constructor for textproto.Writer"
;;   {:added "1.0"
;;    :go "_ConstructWriter(_v)"}
;;   [^Object _v])

JOKER FUNC net/textproto.CanonicalMIMEHeaderKey from net/textproto/reader.go:
(defn ^"String" CanonicalMIMEHeaderKey
  "CanonicalMIMEHeaderKey returns the canonical format of the\nMIME header key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nMIME header keys are assumed to be ASCII only.\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "textproto.CanonicalMIMEHeaderKey(__s)"}
  [^String __s])

JOKER FUNC net/textproto.Dial from net/textproto/textproto.go:
(defn Dial
  "Dial connects to the given address on the given network using net.Dial\nand then returns a new Conn for the connection.\n\nGo input arguments: (network string, addr string)\n\nGo return type: (*Conn, error)\n\nJoker input arguments: [^String network, ^String addr]\n\nJoker return type: [(atom-of go.std.net.textproto/Conn) Error]"
  {:added "1.0"
   :go "__dial(__network, __addr)"}
  [^String __network, ^String __addr])

JOKER FUNC net/textproto.NewConn from net/textproto/textproto.go:
;; (defn NewConn
;;   "NewConn returns a new Conn using conn for I/O.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *Conn\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: (atom-of go.std.net.textproto/Conn)"
;;   {:added "1.0"
;;    :go "__newConn(*__conn)"}
;;   [^io/ReadWriteCloser __conn])

JOKER FUNC net/textproto.NewReader from net/textproto/reader.go:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from r.\n\nTo avoid denial of service attacks, the provided bufio.Reader\nshould be reading from an io.LimitReader or similar Reader to bound\nthe size of responses.\n\nGo input arguments: (r *bufio.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.textproto/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(__r)"}
;;   [^bufio/Reader __r])

JOKER FUNC net/textproto.NewWriter from net/textproto/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer writing to w.\n\nGo input arguments: (w *bufio.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^(atom-of go.std.bufio/Writer) w]\n\nJoker return type: (atom-of go.std.net.textproto/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(__w)"}
;;   [^bufio/Writer __w])

JOKER FUNC net/textproto.TrimBytes from net/textproto/textproto.go:
;; (defn TrimBytes
;;   "TrimBytes returns b without leading and trailing ASCII space.\n\nGo input arguments: (b []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) b]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimBytes(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))"}
;;   [^Object __b])

JOKER FUNC net/textproto.TrimString from net/textproto/textproto.go:
(defn ^"String" TrimString
  "TrimString returns s without leading and trailing ASCII space.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "textproto.TrimString(__s)"}
  [^String __s])

JOKER TYPE go.std.net.textproto/Conn:
(def
  ^{:doc "A Conn represents a textual network protocol connection.\nIt consists of a Reader and Writer to manage I/O\nand a Pipeline to sequence concurrent requests on the connection.\nThese embedded types carry methods with them;\nsee the documentation of those types for details.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Conn"}
  Conn)

JOKER TYPE go.std.net.textproto/Error:
(def
  ^{:doc "An Error represents a numeric error response from a server.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Error"}
  Error)

JOKER TYPE go.std.net.textproto/MIMEHeader:
(def
  ^{:doc "A MIMEHeader represents a MIME-style header mapping\nkeys to sets of values.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_MIMEHeader"}
  MIMEHeader)

JOKER TYPE go.std.net.textproto/Pipeline:
(def
  ^{:doc "A Pipeline manages a pipelined in-order request/response sequence.\n\nTo use a Pipeline p to manage multiple clients on a connection,\neach client should run:\n\n\tid := p.Next()\t// take a number\n\n\tp.StartRequest(id)\t// wait for turn to send request\n\t«send request»\n\tp.EndRequest(id)\t// notify Pipeline that request is sent\n\n\tp.StartResponse(id)\t// wait for turn to read response\n\t«read response»\n\tp.EndResponse(id)\t// notify Pipeline that response is read\n\nA pipelined server can use the same calls to ensure that\nresponses computed in parallel are written in the correct order.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Pipeline"}
  Pipeline)

JOKER TYPE go.std.net.textproto/ProtocolError:
(def
  ^{:doc "A ProtocolError describes a protocol violation such\nas an invalid response or a hung-up connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ProtocolError"}
  ProtocolError)

JOKER TYPE go.std.net.textproto/Reader:
(def
  ^{:doc "A Reader implements convenience methods for reading requests\nor responses from a text protocol network connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Reader"}
  Reader)

JOKER TYPE go.std.net.textproto/Writer:
(def
  ^{:doc "A Writer implements convenience methods for writing\nrequests or responses to a text protocol network connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Writer"}
  Writer)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net/textproto"]
    :doc "Provides a low-level interface to the net/textproto package.\n\nPackage textproto implements generic support for text-based request/response\nprotocols in the style of HTTP, NNTP, and SMTP.\n\nThe package provides:\n\nError, which represents a numeric error response from\na server.\n\nPipeline, to manage pipelined requests and responses\nin a client.\n\nReader, to read numeric response code lines,\nkey: value headers, lines wrapped with leading spaces\non continuation lines, and whole text blocks ending\nwith a dot on a line by itself.\n\nWriter, to write dot-encoded text blocks.\n\nConn, a convenient packaging of Reader, Writer, and Pipeline for use\nwith a single network connection.\n"
    :empty false}
  go.std.net.textproto)
JOKER TYPE net/url.Error from net/url/url.go:
(defn ^"GoObject" Error.
  "Constructor for url.Error"
  {:added "1.0"
   :go "_ConstructError(_v)"}
  [^Object _v])

JOKER TYPE net/url.EscapeError from net/url/url.go:
(defn ^"GoObject" EscapeError.
  "Constructor for url.EscapeError"
  {:added "1.0"
   :go "_ConstructEscapeError(_v)"}
  [^Object _v])

JOKER TYPE net/url.InvalidHostError from net/url/url.go:
(defn ^"GoObject" InvalidHostError.
  "Constructor for url.InvalidHostError"
  {:added "1.0"
   :go "_ConstructInvalidHostError(_v)"}
  [^Object _v])

JOKER TYPE net/url.URL from net/url/url.go:
;; (defn ^"GoObject" URL.
;;   "Constructor for url.URL"
;;   {:added "1.0"
;;    :go "_ConstructURL(_v)"}
;;   [^Object _v])

JOKER TYPE net/url.Userinfo from net/url/url.go:
(defn ^"GoObject" Userinfo.
  "Constructor for url.Userinfo"
  {:added "1.0"
   :go "_ConstructUserinfo(_v)"}
  [^Object _v])

JOKER TYPE net/url.Values from net/url/url.go:
;; (defn ^"GoObject" Values.
;;   "Constructor for url.Values"
;;   {:added "1.0"
;;    :go "_ConstructValues(_v)"}
;;   [^Object _v])

JOKER FUNC net/url.Parse from net/url/url.go:
(defn Parse
  "Parse parses rawurl into a URL structure.\n\nThe rawurl may be relative (a path, without a host) or absolute\n(starting with a scheme). Trying to parse a hostname and path\nwithout a scheme is invalid but may not necessarily return an\nerror, due to parsing ambiguities.\n\nGo input arguments: (rawurl string)\n\nGo return type: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker return type: [(atom-of go.std.net.url/URL) Error]"
  {:added "1.0"
   :go "__parse(__rawurl)"}
  [^String __rawurl])

JOKER FUNC net/url.ParseQuery from net/url/url.go:
(defn ParseQuery
  "ParseQuery parses the URL-encoded query string and returns\na map listing the values specified for each key.\nParseQuery always returns a non-nil map containing all the\nvalid query parameters found; err describes the first decoding error\nencountered, if any.\n\nQuery is expected to be a list of key=value settings separated by\nampersands or semicolons. A setting without an equals sign is\ninterpreted as a key set to an empty value.\n\nGo input arguments: (query string)\n\nGo return type: (Values, error)\n\nJoker input arguments: [^String query]\n\nJoker return type: [go.std.net.url/Values Error]"
  {:added "1.0"
   :go "__parseQuery(__query)"}
  [^String __query])

JOKER FUNC net/url.ParseRequestURI from net/url/url.go:
(defn ParseRequestURI
  "ParseRequestURI parses rawurl into a URL structure. It assumes that\nrawurl was received in an HTTP request, so the rawurl is interpreted\nonly as an absolute URI or an absolute path.\nThe string rawurl is assumed not to have a #fragment suffix.\n(Web browsers strip #fragment before sending the URL to a web server.)\n\nGo input arguments: (rawurl string)\n\nGo return type: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker return type: [(atom-of go.std.net.url/URL) Error]"
  {:added "1.0"
   :go "__parseRequestURI(__rawurl)"}
  [^String __rawurl])

JOKER FUNC net/url.PathEscape from net/url/url.go:
(defn ^"String" PathEscape
  "PathEscape escapes the string so it can be safely placed\ninside a URL path segment.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "url.PathEscape(__s)"}
  [^String __s])

JOKER FUNC net/url.PathUnescape from net/url/url.go:
(defn PathUnescape
  "PathUnescape does the inverse transformation of PathEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB. It returns an error if any % is not followed\nby two hexadecimal digits.\n\nPathUnescape is identical to QueryUnescape except that it does not\nunescape '+' to ' ' (space).\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__pathUnescape(__s)"}
  [^String __s])

JOKER FUNC net/url.QueryEscape from net/url/url.go:
(defn ^"String" QueryEscape
  "QueryEscape escapes the string so it can be safely placed\ninside a URL query.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "url.QueryEscape(__s)"}
  [^String __s])

JOKER FUNC net/url.QueryUnescape from net/url/url.go:
(defn QueryUnescape
  "QueryUnescape does the inverse transformation of QueryEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB.\nIt returns an error if any % is not followed by two hexadecimal\ndigits.\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__queryUnescape(__s)"}
  [^String __s])

JOKER FUNC net/url.User from net/url/url.go:
(defn User
  "User returns a Userinfo containing the provided username\nand no password set.\n\nGo input arguments: (username string)\n\nGo return type: *Userinfo\n\nJoker input arguments: [^String username]\n\nJoker return type: (atom-of go.std.net.url/Userinfo)"
  {:added "1.0"
   :go "__user(__username)"}
  [^String __username])

JOKER FUNC net/url.UserPassword from net/url/url.go:
(defn UserPassword
  "UserPassword returns a Userinfo containing the provided username\nand password.\n\nThis functionality should only be used with legacy web sites.\nRFC 2396 warns that interpreting Userinfo this way\n``is NOT RECOMMENDED, because the passing of authentication\ninformation in clear text (such as URI) has proven to be a\nsecurity risk in almost every case where it has been used.''\n\nGo input arguments: (username string, password string)\n\nGo return type: *Userinfo\n\nJoker input arguments: [^String username, ^String password]\n\nJoker return type: (atom-of go.std.net.url/Userinfo)"
  {:added "1.0"
   :go "__userPassword(__username, __password)"}
  [^String __username, ^String __password])

JOKER TYPE go.std.net.url/Error:
(def
  ^{:doc "Error reports an error and the operation and URL that caused it.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Error"}
  Error)

JOKER TYPE go.std.net.url/EscapeError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_EscapeError"}
  EscapeError)

JOKER TYPE go.std.net.url/InvalidHostError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_InvalidHostError"}
  InvalidHostError)

JOKER TYPE go.std.net.url/URL:
(def
  ^{:doc "A URL represents a parsed URL (technically, a URI reference).\n\nThe general form represented is:\n\n\t[scheme:][//[userinfo@]host][/]path[?query][#fragment]\n\nURLs that do not start with a slash after the scheme are interpreted as:\n\n\tscheme:opaque[?query][#fragment]\n\nNote that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.\nA consequence is that it is impossible to tell which slashes in the Path were\nslashes in the raw URL and which were %2f. This distinction is rarely important,\nbut when it is, code must not use Path directly.\nThe Parse function sets both Path and RawPath in the URL it returns,\nand URL's String method uses RawPath if it is a valid encoding of Path,\nby calling the EscapedPath method.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_URL"}
  URL)

JOKER TYPE go.std.net.url/Userinfo:
(def
  ^{:doc "The Userinfo type is an immutable encapsulation of username and\npassword details for a URL. An existing Userinfo value is guaranteed\nto have a username set (potentially empty, as allowed by RFC 2396),\nand optionally a password.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Userinfo"}
  Userinfo)

JOKER TYPE go.std.net.url/Values:
(def
  ^{:doc "Values maps a string key to a list of values.\nIt is typically used for query parameters and form values.\nUnlike in the http.Header map, the keys in a Values map\nare case-sensitive.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Values"}
  Values)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net/url"]
    :doc "Provides a low-level interface to the net/url package.\n\nPackage url parses URLs and implements query escaping.\n"
    :empty false}
  go.std.net.url)
JOKER CONSTANT DevNull from os/file_unix.go:
(def
  ^{:doc "DevNull is the name of the operating system's ``null device.''\nOn Unix-like systems, it is \"/dev/null\"; on Windows, \"NUL\".\n"
    :added "1.0"
    :tag "String"
    :go "os.DevNull"}
  DevNull)

JOKER CONSTANT ModeAppend from os/types.go:
(def
  ^{:doc "a: append-only\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(os.ModeAppend))"}
  ModeAppend)

JOKER CONSTANT ModeCharDevice from os/types.go:
(def
  ^{:doc "c: Unix character device, when ModeDevice is set\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(os.ModeCharDevice))"}
  ModeCharDevice)

JOKER CONSTANT ModeDevice from os/types.go:
(def
  ^{:doc "D: device file\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(os.ModeDevice))"}
  ModeDevice)

JOKER CONSTANT ModeDir from os/types.go:
(def
  ^{:doc "The single letters are the abbreviations\nused by the String method's formatting.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(os.ModeDir))"}
  ModeDir)

JOKER CONSTANT ModeExclusive from os/types.go:
(def
  ^{:doc "l: exclusive use\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(os.ModeExclusive))"}
  ModeExclusive)

JOKER CONSTANT ModeIrregular from os/types.go:
(def
  ^{:doc "?: non-regular file; nothing else is known about this file\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(os.ModeIrregular))"}
  ModeIrregular)

JOKER CONSTANT ModeNamedPipe from os/types.go:
(def
  ^{:doc "p: named pipe (FIFO)\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(os.ModeNamedPipe))"}
  ModeNamedPipe)

JOKER CONSTANT ModePerm from os/types.go:
(def
  ^{:doc "Unix permission bits\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(os.ModePerm))"}
  ModePerm)

JOKER CONSTANT ModeSetgid from os/types.go:
(def
  ^{:doc "g: setgid\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(os.ModeSetgid))"}
  ModeSetgid)

JOKER CONSTANT ModeSetuid from os/types.go:
(def
  ^{:doc "u: setuid\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(os.ModeSetuid))"}
  ModeSetuid)

JOKER CONSTANT ModeSocket from os/types.go:
(def
  ^{:doc "S: Unix domain socket\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(os.ModeSocket))"}
  ModeSocket)

JOKER CONSTANT ModeSticky from os/types.go:
(def
  ^{:doc "t: sticky\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(os.ModeSticky))"}
  ModeSticky)

JOKER CONSTANT ModeSymlink from os/types.go:
(def
  ^{:doc "L: symbolic link\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(os.ModeSymlink))"}
  ModeSymlink)

JOKER CONSTANT ModeTemporary from os/types.go:
(def
  ^{:doc "T: temporary file; Plan 9 only\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(os.ModeTemporary))"}
  ModeTemporary)

JOKER CONSTANT ModeType from os/types.go:
(def
  ^{:doc "Mask for the type bits. For regular files, none will be set.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(uint32(os.ModeType))"}
  ModeType)

JOKER CONSTANT O_APPEND from os/file.go:
(def
  ^{:doc "The remaining values may be or'ed in to control behavior.\n"
    :added "1.0"
    :tag "Int"
    :go "os.O_APPEND"}
  O_APPEND)

JOKER CONSTANT O_CREATE from os/file.go:
(def
  ^{:doc "create a new file if none exists.\n"
    :added "1.0"
    :tag "Int"
    :go "os.O_CREATE"}
  O_CREATE)

JOKER CONSTANT O_EXCL from os/file.go:
(def
  ^{:doc "used with O_CREATE, file must not exist.\n"
    :added "1.0"
    :tag "Int"
    :go "os.O_EXCL"}
  O_EXCL)

JOKER CONSTANT O_RDONLY from os/file.go:
(def
  ^{:doc "Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.\n"
    :added "1.0"
    :tag "Int"
    :go "os.O_RDONLY"}
  O_RDONLY)

JOKER CONSTANT O_RDWR from os/file.go:
(def
  ^{:doc "open the file read-write.\n"
    :added "1.0"
    :tag "Int"
    :go "os.O_RDWR"}
  O_RDWR)

JOKER CONSTANT O_SYNC from os/file.go:
(def
  ^{:doc "open for synchronous I/O.\n"
    :added "1.0"
    :tag "Int"
    :go "os.O_SYNC"}
  O_SYNC)

JOKER CONSTANT O_TRUNC from os/file.go:
(def
  ^{:doc "truncate regular writable file when opened.\n"
    :added "1.0"
    :tag "Int"
    :go "os.O_TRUNC"}
  O_TRUNC)

JOKER CONSTANT O_WRONLY from os/file.go:
(def
  ^{:doc "open the file write-only.\n"
    :added "1.0"
    :tag "Int"
    :go "os.O_WRONLY"}
  O_WRONLY)

JOKER CONSTANT PathListSeparator from os/path_unix.go:
(def
  ^{:doc "OS-specific path list separator\n"
    :added "1.0"
    :tag "Char"
    :go "os.PathListSeparator"}
  PathListSeparator)

JOKER CONSTANT PathSeparator from os/path_unix.go:
(def
  ^{:doc "OS-specific path separator\n"
    :added "1.0"
    :tag "Char"
    :go "os.PathSeparator"}
  PathSeparator)

JOKER CONSTANT SEEK_CUR from os/file.go:
(def
  ^{:doc "seek relative to the current offset\n"
    :added "1.0"
    :tag "Int"
    :go "os.SEEK_CUR"}
  SEEK_CUR)

JOKER CONSTANT SEEK_END from os/file.go:
(def
  ^{:doc "seek relative to the end\n"
    :added "1.0"
    :tag "Int"
    :go "os.SEEK_END"}
  SEEK_END)

JOKER CONSTANT SEEK_SET from os/file.go:
(def
  ^{:doc "seek relative to the origin of the file\n"
    :added "1.0"
    :tag "Int"
    :go "os.SEEK_SET"}
  SEEK_SET)

JOKER VARIABLE Args from os/proc.go:
(def
  ^{:doc "Args hold the command-line arguments, starting with the program name.\n"
    :added "1.0"
    :tag "Var"
    :go "os.Args"}
  Args)

JOKER VARIABLE ErrClosed from os/error.go:
(def
  ^{:doc "Portable analogs of some common system call errors.\n"
    :added "1.0"
    :tag "Var"
    :go "os.ErrClosed"}
  ErrClosed)

JOKER VARIABLE ErrExist from os/error.go:
(def
  ^{:doc "Portable analogs of some common system call errors.\n"
    :added "1.0"
    :tag "Var"
    :go "os.ErrExist"}
  ErrExist)

JOKER VARIABLE ErrInvalid from os/error.go:
(def
  ^{:doc "methods on File will return this error when the receiver is nil\n"
    :added "1.0"
    :tag "Var"
    :go "os.ErrInvalid"}
  ErrInvalid)

JOKER VARIABLE ErrNoDeadline from os/error.go:
(def
  ^{:doc "Portable analogs of some common system call errors.\n"
    :added "1.0"
    :tag "Var"
    :go "os.ErrNoDeadline"}
  ErrNoDeadline)

JOKER VARIABLE ErrNotExist from os/error.go:
(def
  ^{:doc "Portable analogs of some common system call errors.\n"
    :added "1.0"
    :tag "Var"
    :go "os.ErrNotExist"}
  ErrNotExist)

JOKER VARIABLE ErrPermission from os/error.go:
(def
  ^{:doc "Portable analogs of some common system call errors.\n"
    :added "1.0"
    :tag "Var"
    :go "os.ErrPermission"}
  ErrPermission)

JOKER VARIABLE Interrupt from os/exec_posix.go:
(def
  ^{:doc "The only signal values guaranteed to be present in the os package on all\nsystems are os.Interrupt (send the process an interrupt) and os.Kill (force\nthe process to exit). On Windows, sending os.Interrupt to a process with\nos.Process.Signal is not implemented; it will return an error instead of\nsending a signal.\n"
    :added "1.0"
    :tag "Var"
    :go "os.Interrupt"}
  Interrupt)

JOKER VARIABLE Kill from os/exec_posix.go:
(def
  ^{:doc "The only signal values guaranteed to be present in the os package on all\nsystems are os.Interrupt (send the process an interrupt) and os.Kill (force\nthe process to exit). On Windows, sending os.Interrupt to a process with\nos.Process.Signal is not implemented; it will return an error instead of\nsending a signal.\n"
    :added "1.0"
    :tag "Var"
    :go "os.Kill"}
  Kill)

JOKER VARIABLE Stderr from os/file.go:
(def
  ^{:doc "Stdin, Stdout, and Stderr are open Files pointing to the standard input,\nstandard output, and standard error file descriptors.\n\nNote that the Go runtime writes to standard error for panics and crashes;\nclosing Stderr may cause those messages to go elsewhere, perhaps\nto a file opened later.\n"
    :added "1.0"
    :tag "Var"
    :go "os.Stderr"}
  Stderr)

JOKER VARIABLE Stdin from os/file.go:
(def
  ^{:doc "Stdin, Stdout, and Stderr are open Files pointing to the standard input,\nstandard output, and standard error file descriptors.\n\nNote that the Go runtime writes to standard error for panics and crashes;\nclosing Stderr may cause those messages to go elsewhere, perhaps\nto a file opened later.\n"
    :added "1.0"
    :tag "Var"
    :go "os.Stdin"}
  Stdin)

JOKER VARIABLE Stdout from os/file.go:
(def
  ^{:doc "Stdin, Stdout, and Stderr are open Files pointing to the standard input,\nstandard output, and standard error file descriptors.\n\nNote that the Go runtime writes to standard error for panics and crashes;\nclosing Stderr may cause those messages to go elsewhere, perhaps\nto a file opened later.\n"
    :added "1.0"
    :tag "Var"
    :go "os.Stdout"}
  Stdout)

JOKER TYPE os.File from os/types.go:
(defn ^"GoObject" File.
  "Constructor for os.File"
  {:added "1.0"
   :go "_ConstructFile(_v)"}
  [^Object _v])

JOKER TYPE os.FileInfo from os/types.go:
;; (defn ^"GoObject" FileInfo.
;;   "Constructor for os.FileInfo"
;;   {:added "1.0"
;;    :go "_ConstructFileInfo(_v)"}
;;   [^Object _v])

JOKER TYPE os.FileMode from os/types.go:
(defn ^"GoObject" FileMode.
  "Constructor for os.FileMode"
  {:added "1.0"
   :go "_ConstructFileMode(_v)"}
  [^Object _v])

JOKER TYPE os.LinkError from os/file.go:
(defn ^"GoObject" LinkError.
  "Constructor for os.LinkError"
  {:added "1.0"
   :go "_ConstructLinkError(_v)"}
  [^Object _v])

JOKER TYPE os.PathError from os/error.go:
(defn ^"GoObject" PathError.
  "Constructor for os.PathError"
  {:added "1.0"
   :go "_ConstructPathError(_v)"}
  [^Object _v])

JOKER TYPE os.ProcAttr from os/exec.go:
;; (defn ^"GoObject" ProcAttr.
;;   "Constructor for os.ProcAttr"
;;   {:added "1.0"
;;    :go "_ConstructProcAttr(_v)"}
;;   [^Object _v])

JOKER TYPE os.Process from os/exec.go:
(defn ^"GoObject" Process.
  "Constructor for os.Process"
  {:added "1.0"
   :go "_ConstructProcess(_v)"}
  [^Object _v])

JOKER TYPE os.ProcessState from os/exec_posix.go:
(defn ^"GoObject" ProcessState.
  "Constructor for os.ProcessState"
  {:added "1.0"
   :go "_ConstructProcessState(_v)"}
  [^Object _v])

JOKER TYPE os.Signal from os/exec.go:
;; (defn ^"GoObject" Signal.
;;   "Constructor for os.Signal"
;;   {:added "1.0"
;;    :go "_ConstructSignal(_v)"}
;;   [^Object _v])

JOKER TYPE os.SyscallError from os/error.go:
(defn ^"GoObject" SyscallError.
  "Constructor for os.SyscallError"
  {:added "1.0"
   :go "_ConstructSyscallError(_v)"}
  [^Object _v])

JOKER FUNC os.Chdir from os/file.go:
(defn ^"Error" Chdir
  "Chdir changes the current working directory to the named directory.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (dir string)\n\nGo return type: error\n\nJoker input arguments: [^String dir]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Chdir(__dir)"}
  [^String __dir])

JOKER FUNC os.Chmod from os/file.go:
(defn ^"Error" Chmod
  "Chmod changes the mode of the named file to mode.\nIf the file is a symbolic link, it changes the mode of the link's target.\nIf there is an error, it will be of type *PathError.\n\nA different subset of the mode bits are used, depending on the\noperating system.\n\nOn Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and\nModeSticky are used.\n\nOn Windows, the mode must be non-zero but otherwise only the 0200\nbit (owner writable) of mode is used; it controls whether the\nfile's read-only attribute is set or cleared. attribute. The other\nbits are currently unused. Use mode 0400 for a read-only file and\n0600 for a readable+writable file.\n\nOn Plan 9, the mode's permission bits, ModeAppend, ModeExclusive,\nand ModeTemporary are used.\n\nGo input arguments: (name string, mode FileMode)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^go.std.os/FileMode mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Chmod(__name, *__mode)"}
  [^String __name, ^os/FileMode __mode])

JOKER FUNC os.Chown from os/file_posix.go:
(defn ^"Error" Chown
  "Chown changes the numeric uid and gid of the named file.\nIf the file is a symbolic link, it changes the uid and gid of the link's target.\nA uid or gid of -1 means to not change that value.\nIf there is an error, it will be of type *PathError.\n\nOn Windows or Plan 9, Chown always returns the syscall.EWINDOWS or\nEPLAN9 error, wrapped in *PathError.\n\nGo input arguments: (name string, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Chown(__name, __uid, __gid)"}
  [^String __name, ^Int __uid, ^Int __gid])

JOKER FUNC os.Chtimes from os/file_posix.go:
;; (defn ^"Error" Chtimes
;;   "Chtimes changes the access and modification times of the named\nfile, similar to the Unix utime() or utimes() functions.\n\nThe underlying filesystem may truncate or round the values to a\nless precise time unit.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, atime time.Time, mtime time.Time)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^go.std.time/Time atime, ^go.std.time/Time mtime]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "os.Chtimes(__name, *__atime, *__mtime)"}
;;   [^String __name, ^time/Time __atime, ^time/Time __mtime])

JOKER FUNC os.Clearenv from os/env.go:
;; (defn Clearenv
;;   "Clearenv deletes all environment variables.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__clearenv()"}
;;   [])

JOKER FUNC os.Create from os/file.go:
(defn Create
  "Create creates the named file with mode 0666 (before umask), truncating\nit if it already exists. If successful, methods on the returned\nFile can be used for I/O; the associated file descriptor has mode\nO_RDWR.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.os/File) Error]"
  {:added "1.0"
   :go "__create(__name)"}
  [^String __name])

JOKER FUNC os.Environ from os/env.go:
(defn Environ
  "Environ returns a copy of strings representing the environment,\nin the form \"key=value\".\n\nGo return type: []string\n\nJoker input arguments: []\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__environ()"}
  [])

JOKER FUNC os.Executable from os/executable.go:
(defn Executable
  "Executable returns the path name for the executable that started\nthe current process. There is no guarantee that the path is still\npointing to the correct executable. If a symlink was used to start\nthe process, depending on the operating system, the result might\nbe the symlink or the path it pointed to. If a stable result is\nneeded, path/filepath.EvalSymlinks might help.\n\nExecutable returns an absolute path unless an error occurred.\n\nThe main use case is finding resources located relative to an\nexecutable.\n\nExecutable is not supported on nacl.\n\nGo return type: (string, error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__executable()"}
  [])

JOKER FUNC os.Exit from os/proc.go:
;; (defn Exit
;;   "Exit causes the current program to exit with the given status code.\nConventionally, code zero indicates success, non-zero an error.\nThe program terminates immediately; deferred functions are not run.\n\nGo input arguments: (code int)\n\nJoker input arguments: [^Int code]"
;;   {:added "1.0"
;;    :go "__exit(__code)"}
;;   [^Int __code])

JOKER FUNC os.Expand from os/env.go:
;; (defn ^"String" Expand
;;   "Expand replaces ${var} or $var in the string based on the mapping function.\nFor example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv).\n\nGo input arguments: (s string, mapping func)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^fn mapping]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "os.Expand(__s, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String __s, ^fn __mapping])

JOKER FUNC os.ExpandEnv from os/env.go:
(defn ^"String" ExpandEnv
  "ExpandEnv replaces ${var} or $var in the string according to the values\nof the current environment variables. References to undefined\nvariables are replaced by the empty string.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "os.ExpandEnv(__s)"}
  [^String __s])

JOKER FUNC os.FindProcess from os/exec.go:
(defn FindProcess
  "FindProcess looks for a running process by its pid.\n\nThe Process it returns can be used to obtain information\nabout the underlying operating system process.\n\nOn Unix systems, FindProcess always succeeds and returns a Process\nfor the given pid, regardless of whether the process exists.\n\nGo input arguments: (pid int)\n\nGo return type: (*Process, error)\n\nJoker input arguments: [^Int pid]\n\nJoker return type: [(atom-of go.std.os/Process) Error]"
  {:added "1.0"
   :go "__findProcess(__pid)"}
  [^Int __pid])

JOKER FUNC os.Getegid from os/proc.go:
(defn ^"Int" Getegid
  "Getegid returns the numeric effective group id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getegid()"}
  [])

JOKER FUNC os.Getenv from os/env.go:
(defn ^"String" Getenv
  "Getenv retrieves the value of the environment variable named by the key.\nIt returns the value, which will be empty if the variable is not present.\nTo distinguish between an empty value and an unset value, use LookupEnv.\n\nGo input arguments: (key string)\n\nGo return type: string\n\nJoker input arguments: [^String key]\n\nJoker return type: String"
  {:added "1.0"
   :go "os.Getenv(__key)"}
  [^String __key])

JOKER FUNC os.Geteuid from os/proc.go:
(defn ^"Int" Geteuid
  "Geteuid returns the numeric effective user id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Geteuid()"}
  [])

JOKER FUNC os.Getgid from os/proc.go:
(defn ^"Int" Getgid
  "Getgid returns the numeric group id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getgid()"}
  [])

JOKER FUNC os.Getgroups from os/proc.go:
(defn Getgroups
  "Getgroups returns a list of the numeric ids of groups that the caller belongs to.\n\nOn Windows, it returns syscall.EWINDOWS. See the os/user package\nfor a possible alternative.\n\nGo return type: ([]int, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__getgroups()"}
  [])

JOKER FUNC os.Getpagesize from os/types.go:
(defn ^"Int" Getpagesize
  "Getpagesize returns the underlying system's memory page size.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getpagesize()"}
  [])

JOKER FUNC os.Getpid from os/exec.go:
(defn ^"Int" Getpid
  "Getpid returns the process id of the caller.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getpid()"}
  [])

JOKER FUNC os.Getppid from os/exec.go:
(defn ^"Int" Getppid
  "Getppid returns the process id of the caller's parent.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getppid()"}
  [])

JOKER FUNC os.Getuid from os/proc.go:
(defn ^"Int" Getuid
  "Getuid returns the numeric user id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getuid()"}
  [])

JOKER FUNC os.Getwd from os/getwd.go:
(defn Getwd
  "Getwd returns a rooted path name corresponding to the\ncurrent directory. If the current directory can be\nreached via multiple paths (due to symbolic links),\nGetwd may return any one of them.\n\nGo return type: (dir string, err error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__getwd()"}
  [])

JOKER FUNC os.Hostname from os/sys.go:
(defn Hostname
  "Hostname returns the host name reported by the kernel.\n\nGo return type: (name string, err error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__hostname()"}
  [])

JOKER FUNC os.IsExist from os/error.go:
(defn ^"Boolean" IsExist
  "IsExist returns a boolean indicating whether the error is known to report\nthat a file or directory already exists. It is satisfied by ErrExist as\nwell as some syscall errors.\n\nGo input arguments: (err error)\n\nGo return type: bool\n\nJoker input arguments: [^Error err]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "os.IsExist(__err)"}
  [^Error __err])

JOKER FUNC os.IsNotExist from os/error.go:
(defn ^"Boolean" IsNotExist
  "IsNotExist returns a boolean indicating whether the error is known to\nreport that a file or directory does not exist. It is satisfied by\nErrNotExist as well as some syscall errors.\n\nGo input arguments: (err error)\n\nGo return type: bool\n\nJoker input arguments: [^Error err]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "os.IsNotExist(__err)"}
  [^Error __err])

JOKER FUNC os.IsPathSeparator from os/path_unix.go:
(defn ^"Boolean" IsPathSeparator
  "IsPathSeparator reports whether c is a directory separator character.\n\nGo input arguments: (c uint8)\n\nGo return type: bool\n\nJoker input arguments: [^Int c]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "os.IsPathSeparator(__c)"}
  [^UInt8 __c])

JOKER FUNC os.IsPermission from os/error.go:
(defn ^"Boolean" IsPermission
  "IsPermission returns a boolean indicating whether the error is known to\nreport that permission is denied. It is satisfied by ErrPermission as well\nas some syscall errors.\n\nGo input arguments: (err error)\n\nGo return type: bool\n\nJoker input arguments: [^Error err]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "os.IsPermission(__err)"}
  [^Error __err])

JOKER FUNC os.IsTimeout from os/error.go:
(defn ^"Boolean" IsTimeout
  "IsTimeout returns a boolean indicating whether the error is known\nto report that a timeout occurred.\n\nGo input arguments: (err error)\n\nGo return type: bool\n\nJoker input arguments: [^Error err]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "os.IsTimeout(__err)"}
  [^Error __err])

JOKER FUNC os.Lchown from os/file_posix.go:
(defn ^"Error" Lchown
  "Lchown changes the numeric uid and gid of the named file.\nIf the file is a symbolic link, it changes the uid and gid of the link itself.\nIf there is an error, it will be of type *PathError.\n\nOn Windows, it always returns the syscall.EWINDOWS error, wrapped\nin *PathError.\n\nGo input arguments: (name string, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Lchown(__name, __uid, __gid)"}
  [^String __name, ^Int __uid, ^Int __gid])

JOKER FUNC os.Link from os/file_unix.go:
(defn ^"Error" Link
  "Link creates newname as a hard link to the oldname file.\nIf there is an error, it will be of type *LinkError.\n\nGo input arguments: (oldname string, newname string)\n\nGo return type: error\n\nJoker input arguments: [^String oldname, ^String newname]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Link(__oldname, __newname)"}
  [^String __oldname, ^String __newname])

JOKER FUNC os.LookupEnv from os/env.go:
(defn LookupEnv
  "LookupEnv retrieves the value of the environment variable named\nby the key. If the variable is present in the environment the\nvalue (which may be empty) is returned and the boolean is true.\nOtherwise the returned value will be empty and the boolean will\nbe false.\n\nGo input arguments: (key string)\n\nGo return type: (string, bool)\n\nJoker input arguments: [^String key]\n\nJoker return type: [String Boolean]"
  {:added "1.0"
   :go "__lookupEnv(__key)"}
  [^String __key])

JOKER FUNC os.Lstat from os/stat.go:
(defn Lstat
  "Lstat returns a FileInfo describing the named file.\nIf the file is a symbolic link, the returned FileInfo\ndescribes the symbolic link. Lstat makes no attempt to follow the link.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (FileInfo, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [go.std.os/FileInfo Error]"
  {:added "1.0"
   :go "__lstat(__name)"}
  [^String __name])

JOKER FUNC os.Mkdir from os/file.go:
(defn ^"Error" Mkdir
  "Mkdir creates a new directory with the specified name and permission\nbits (before umask).\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, perm FileMode)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^go.std.os/FileMode perm]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Mkdir(__name, *__perm)"}
  [^String __name, ^os/FileMode __perm])

JOKER FUNC os.MkdirAll from os/path.go:
(defn ^"Error" MkdirAll
  "MkdirAll creates a directory named path,\nalong with any necessary parents, and returns nil,\nor else returns an error.\nThe permission bits perm (before umask) are used for all\ndirectories that MkdirAll creates.\nIf path is already a directory, MkdirAll does nothing\nand returns nil.\n\nGo input arguments: (path string, perm FileMode)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^go.std.os/FileMode perm]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.MkdirAll(__path, *__perm)"}
  [^String __path, ^os/FileMode __perm])

JOKER FUNC os.NewFile from os/file_unix.go:
(defn NewFile
  "NewFile returns a new File with the given file descriptor and\nname. The returned value will be nil if fd is not a valid file\ndescriptor. On Unix systems, if the file descriptor is in\nnon-blocking mode, NewFile will attempt to return a pollable File\n(one for which the SetDeadline methods work).\n\nGo input arguments: (fd uintptr, name string)\n\nGo return type: *File\n\nJoker input arguments: [^Number fd, ^String name]\n\nJoker return type: (atom-of go.std.os/File)"
  {:added "1.0"
   :go "__newFile(__fd, __name)"}
  [^UIntPtr __fd, ^String __name])

JOKER FUNC os.NewSyscallError from os/error.go:
(defn ^"Error" NewSyscallError
  "NewSyscallError returns, as an error, a new SyscallError\nwith the given system call name and error details.\nAs a convenience, if err is nil, NewSyscallError returns nil.\n\nGo input arguments: (syscall string, err error)\n\nGo return type: error\n\nJoker input arguments: [^String syscall, ^Error err]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.NewSyscallError(__syscall, __err)"}
  [^String __syscall, ^Error __err])

JOKER FUNC os.Open from os/file.go:
(defn Open
  "Open opens the named file for reading. If successful, methods on\nthe returned file can be used for reading; the associated file\ndescriptor has mode O_RDONLY.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.os/File) Error]"
  {:added "1.0"
   :go "__open(__name)"}
  [^String __name])

JOKER FUNC os.OpenFile from os/file.go:
(defn OpenFile
  "OpenFile is the generalized open call; most users will use Open\nor Create instead. It opens the named file with specified flag\n(O_RDONLY etc.) and perm (before umask), if applicable. If successful,\nmethods on the returned File can be used for I/O.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, flag int, perm FileMode)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name, ^Int flag, ^go.std.os/FileMode perm]\n\nJoker return type: [(atom-of go.std.os/File) Error]"
  {:added "1.0"
   :go "__openFile(__name, __flag, *__perm)"}
  [^String __name, ^Int __flag, ^os/FileMode __perm])

JOKER FUNC os.Pipe from os/pipe_linux.go:
(defn Pipe
  "Pipe returns a connected pair of Files; reads from r return bytes written to w.\nIt returns the files and an error, if any.\n\nGo return type: (r *File, w *File, err error)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.os/File) (atom-of go.std.os/File) Error]"
  {:added "1.0"
   :go "__pipe()"}
  [])

JOKER FUNC os.Readlink from os/file_posix.go:
(defn Readlink
  "Readlink returns the destination of the named symbolic link.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__readlink(__name)"}
  [^String __name])

JOKER FUNC os.Remove from os/file_unix.go:
(defn ^"Error" Remove
  "Remove removes the named file or (empty) directory.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: error\n\nJoker input arguments: [^String name]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Remove(__name)"}
  [^String __name])

JOKER FUNC os.RemoveAll from os/path.go:
(defn ^"Error" RemoveAll
  "RemoveAll removes path and any children it contains.\nIt removes everything it can but returns the first error\nit encounters. If the path does not exist, RemoveAll\nreturns nil (no error).\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.RemoveAll(__path)"}
  [^String __path])

JOKER FUNC os.Rename from os/file.go:
(defn ^"Error" Rename
  "Rename renames (moves) oldpath to newpath.\nIf newpath already exists and is not a directory, Rename replaces it.\nOS-specific restrictions may apply when oldpath and newpath are in different directories.\nIf there is an error, it will be of type *LinkError.\n\nGo input arguments: (oldpath string, newpath string)\n\nGo return type: error\n\nJoker input arguments: [^String oldpath, ^String newpath]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Rename(__oldpath, __newpath)"}
  [^String __oldpath, ^String __newpath])

JOKER FUNC os.SameFile from os/types.go:
(defn ^"Boolean" SameFile
  "SameFile reports whether fi1 and fi2 describe the same file.\nFor example, on Unix this means that the device and inode fields\nof the two underlying structures are identical; on other systems\nthe decision may be based on the path names.\nSameFile only applies to results returned by this package's Stat.\nIt returns false in other cases.\n\nGo input arguments: (fi1 FileInfo, fi2 FileInfo)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.os/FileInfo fi1, ^go.std.os/FileInfo fi2]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "os.SameFile(*__fi1, *__fi2)"}
  [^os/FileInfo __fi1, ^os/FileInfo __fi2])

JOKER FUNC os.Setenv from os/env.go:
(defn ^"Error" Setenv
  "Setenv sets the value of the environment variable named by the key.\nIt returns an error, if any.\n\nGo input arguments: (key string, value string)\n\nGo return type: error\n\nJoker input arguments: [^String key, ^String value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Setenv(__key, __value)"}
  [^String __key, ^String __value])

JOKER FUNC os.StartProcess from os/exec.go:
;; (defn StartProcess
;;   "StartProcess starts a new process with the program, arguments and attributes\nspecified by name, argv and attr. The argv slice will become os.Args in the\nnew process, so it normally starts with the program name.\n\nIf the calling goroutine has locked the operating system thread\nwith runtime.LockOSThread and modified any inheritable OS-level\nthread state (for example, Linux or Plan 9 name spaces), the new\nprocess will inherit the caller's thread state.\n\nStartProcess is a low-level interface. The os/exec package provides\nhigher-level interfaces.\n\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, argv []string, attr *ProcAttr)\n\nGo return type: (*Process, error)\n\nJoker input arguments: [^String name, ^(vector-of String) argv, ^(atom-of go.std.os/ProcAttr) attr]\n\nJoker return type: [(atom-of go.std.os/Process) Error]"
;;   {:added "1.0"
;;    :go "__startProcess(__name, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(__argv)), __attr)"}
;;   [^String __name, ^Object __argv, ^os/ProcAttr __attr])

JOKER FUNC os.Stat from os/stat.go:
(defn Stat
  "Stat returns a FileInfo describing the named file.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (FileInfo, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [go.std.os/FileInfo Error]"
  {:added "1.0"
   :go "__stat(__name)"}
  [^String __name])

JOKER FUNC os.Symlink from os/file_unix.go:
(defn ^"Error" Symlink
  "Symlink creates newname as a symbolic link to oldname.\nIf there is an error, it will be of type *LinkError.\n\nGo input arguments: (oldname string, newname string)\n\nGo return type: error\n\nJoker input arguments: [^String oldname, ^String newname]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Symlink(__oldname, __newname)"}
  [^String __oldname, ^String __newname])

JOKER FUNC os.TempDir from os/file.go:
(defn ^"String" TempDir
  "TempDir returns the default directory to use for temporary files.\n\nOn Unix systems, it returns $TMPDIR if non-empty, else /tmp.\nOn Windows, it uses GetTempPath, returning the first non-empty\nvalue from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory.\nOn Plan 9, it returns /tmp.\n\nThe directory is neither guaranteed to exist nor have accessible\npermissions.\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "os.TempDir()"}
  [])

JOKER FUNC os.Truncate from os/file_unix.go:
(defn ^"Error" Truncate
  "Truncate changes the size of the named file.\nIf the file is a symbolic link, it changes the size of the link's target.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, size int64)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^Number size]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Truncate(__name, __size)"}
  [^String __name, ^Int64 __size])

JOKER FUNC os.Unsetenv from os/env.go:
(defn ^"Error" Unsetenv
  "Unsetenv unsets a single environment variable.\n\nGo input arguments: (key string)\n\nGo return type: error\n\nJoker input arguments: [^String key]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Unsetenv(__key)"}
  [^String __key])

JOKER FUNC os.UserCacheDir from os/file.go:
(defn UserCacheDir
  "UserCacheDir returns the default root directory to use for user-specific\ncached data. Users should create their own application-specific subdirectory\nwithin this one and use that.\n\nOn Unix systems, it returns $XDG_CACHE_HOME as specified by\nhttps://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html if\nnon-empty, else $HOME/.cache.\nOn Darwin, it returns $HOME/Library/Caches.\nOn Windows, it returns %LocalAppData%.\nOn Plan 9, it returns $home/lib/cache.\n\nIf the location cannot be determined (for example, $HOME is not defined),\nthen it will return an error.\n\nGo return type: (string, error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__userCacheDir()"}
  [])

JOKER FUNC os.UserHomeDir from os/file.go:
(defn UserHomeDir
  "UserHomeDir returns the current user's home directory.\n\nOn Unix, including macOS, it returns the $HOME environment variable.\nOn Windows, it returns %USERPROFILE%.\nOn Plan 9, it returns the $home environment variable.\n\nGo return type: (string, error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__userHomeDir()"}
  [])

JOKER TYPE go.std.os/File:
(def
  ^{:doc "File represents an open file descriptor.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_File"}
  File)

JOKER TYPE go.std.os/FileInfo:
(def
  ^{:doc "A FileInfo describes a file and is returned by Stat and Lstat.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FileInfo"}
  FileInfo)

JOKER TYPE go.std.os/FileMode:
(def
  ^{:doc "A FileMode represents a file's mode and permission bits.\nThe bits have the same definition on all systems, so that\ninformation about files can be moved from one system\nto another portably. Not all bits apply to all systems.\nThe only required bit is ModeDir for directories.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FileMode"}
  FileMode)

JOKER TYPE go.std.os/LinkError:
(def
  ^{:doc "LinkError records an error during a link or symlink or rename\nsystem call and the paths that caused it.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_LinkError"}
  LinkError)

JOKER TYPE go.std.os/PathError:
(def
  ^{:doc "PathError records an error and the operation and file path that caused it.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PathError"}
  PathError)

JOKER TYPE go.std.os/ProcAttr:
(def
  ^{:doc "ProcAttr holds the attributes that will be applied to a new process\nstarted by StartProcess.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ProcAttr"}
  ProcAttr)

JOKER TYPE go.std.os/Process:
(def
  ^{:doc "Process stores the information about a process created by StartProcess.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Process"}
  Process)

JOKER TYPE go.std.os/ProcessState:
(def
  ^{:doc "ProcessState stores information about a process, as reported by Wait.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ProcessState"}
  ProcessState)

JOKER TYPE go.std.os/Signal:
(def
  ^{:doc "A Signal represents an operating system signal.\nThe usual underlying implementation is operating system-dependent:\non Unix it is syscall.Signal.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Signal"}
  Signal)

JOKER TYPE go.std.os/SyscallError:
(def
  ^{:doc "SyscallError records an error from a specific system call.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SyscallError"}
  SyscallError)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["os"]
    :doc "Provides a low-level interface to the os package.\n\nPackage os provides a platform-independent interface to operating system\nfunctionality. The design is Unix-like, although the error handling is\nGo-like; failing calls return values of type error rather than error numbers.\nOften, more information is available within the error. For example,\nif a call that takes a file name fails, such as Open or Stat, the error\nwill include the failing file name when printed and will be of type\n*PathError, which may be unpacked for more information.\n\nThe os interface is intended to be uniform across all operating systems.\nFeatures not generally available appear in the system-specific package syscall.\n\nHere is a simple example, opening a file and reading some of it.\n\n\tfile, err := os.Open(\"file.go\") // For read access.\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\nIf the open fails, the error string will be self-explanatory, like\n\n\topen file.go: no such file or directory\n\nThe file's data can then be read into a slice of bytes. Read and\nWrite take their byte counts from the length of the argument slice.\n\n\tdata := make([]byte, 100)\n\tcount, err := file.Read(data)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Printf(\"read %d bytes: %q\\n\", count, data[:count])\n"
    :empty false}
  go.std.os)
JOKER VARIABLE ErrNotFound from os/exec/lp_unix.go:
(def
  ^{:doc "ErrNotFound is the error resulting if a path search failed to find an executable file.\n"
    :added "1.0"
    :tag "Var"
    :go "exec.ErrNotFound"}
  ErrNotFound)

JOKER TYPE os/exec.Cmd from os/exec/exec.go:
;; (defn ^"GoObject" Cmd.
;;   "Constructor for exec.Cmd"
;;   {:added "1.0"
;;    :go "_ConstructCmd(_v)"}
;;   [^Object _v])

JOKER TYPE os/exec.Error from os/exec/exec.go:
(defn ^"GoObject" Error.
  "Constructor for exec.Error"
  {:added "1.0"
   :go "_ConstructError(_v)"}
  [^Object _v])

JOKER TYPE os/exec.ExitError from os/exec/exec.go:
;; (defn ^"GoObject" ExitError.
;;   "Constructor for exec.ExitError"
;;   {:added "1.0"
;;    :go "_ConstructExitError(_v)"}
;;   [^Object _v])

JOKER FUNC os/exec.Command from os/exec/exec.go:
;; (defn Command
;;   "Command returns the Cmd struct to execute the named program with\nthe given arguments.\n\nIt sets only the Path and Args in the returned structure.\n\nIf name contains no path separators, Command uses LookPath to\nresolve name to a complete path if possible. Otherwise it uses name\ndirectly as Path.\n\nThe returned Cmd's Args field is constructed from the command name\nfollowed by the elements of arg, so arg should not include the\ncommand name itself. For example, Command(\"echo\", \"hello\").\nArgs[0] is always name, not the possibly resolved Path.\n\nOn Windows, processes receive the whole command line as a single string\nand do their own parsing. Command combines and quotes Args into a command\nline string with an algorithm compatible with applications using\nCommandLineToArgvW (which is the most common way). Notable exceptions are\nmsiexec.exe and cmd.exe (and thus, all batch files), which have a different\nunquoting algorithm. In these or other similar cases, you can do the\nquoting yourself and provide the full command line in SysProcAttr.CmdLine,\nleaving Args empty.\n\nGo input arguments: (name string, arg ...string)\n\nGo return type: *Cmd\n\nJoker input arguments: [^String name, ^(ellipsis-somehow String) arg]\n\nJoker return type: (atom-of go.std.os.exec/Cmd)"
;;   {:added "1.0"
;;    :go "__command(__name, ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(__arg)))"}
;;   [^String __name, ^String __arg])

JOKER FUNC os/exec.CommandContext from os/exec/exec.go:
;; (defn CommandContext
;;   "CommandContext is like Command but includes a context.\n\nThe provided context is used to kill the process (by calling\nos.Process.Kill) if the context becomes done before the command\ncompletes on its own.\n\nGo input arguments: (ctx context.Context, name string, arg ...string)\n\nGo return type: *Cmd\n\nJoker input arguments: [^go.std.context/Context ctx, ^String name, ^(ellipsis-somehow String) arg]\n\nJoker return type: (atom-of go.std.os.exec/Cmd)"
;;   {:added "1.0"
;;    :go "__commandContext(*__ctx, __name, ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(__arg)))"}
;;   [^context/Context __ctx, ^String __name, ^String __arg])

JOKER FUNC os/exec.LookPath from os/exec/lp_unix.go:
(defn LookPath
  "LookPath searches for an executable named file in the\ndirectories named by the PATH environment variable.\nIf file contains a slash, it is tried directly and the PATH is not consulted.\nThe result may be an absolute path or a path relative to the current directory.\n\nGo input arguments: (file string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String file]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__lookPath(__file)"}
  [^String __file])

JOKER TYPE go.std.os.exec/Cmd:
(def
  ^{:doc "Cmd represents an external command being prepared or run.\n\nA Cmd cannot be reused after calling its Run, Output or CombinedOutput\nmethods.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Cmd"}
  Cmd)

JOKER TYPE go.std.os.exec/Error:
(def
  ^{:doc "Error is returned by LookPath when it fails to classify a file as an\nexecutable.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Error"}
  Error)

JOKER TYPE go.std.os.exec/ExitError:
(def
  ^{:doc "An ExitError reports an unsuccessful exit by a command.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ExitError"}
  ExitError)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["os/exec"]
    :doc "Provides a low-level interface to the os/exec package.\n\nPackage exec runs external commands. It wraps os.StartProcess to make it\neasier to remap stdin and stdout, connect I/O with pipes, and do other\nadjustments.\n\nUnlike the \"system\" library call from C and other languages, the\nos/exec package intentionally does not invoke the system shell and\ndoes not expand any glob patterns or handle other expansions,\npipelines, or redirections typically done by shells. The package\nbehaves more like C's \"exec\" family of functions. To expand glob\npatterns, either call the shell directly, taking care to escape any\ndangerous input, or use the path/filepath package's Glob function.\nTo expand environment variables, use package os's ExpandEnv.\n\nNote that the examples in this package assume a Unix system.\nThey may not run on Windows, and they do not run in the Go Playground\nused by golang.org and godoc.org.\n"
    :empty false}
  go.std.os.exec)
JOKER FUNC os/signal.Ignore from os/signal/signal.go:
;; (defn Ignore
;;   "Ignore causes the provided signals to be ignored. If they are received by\nthe program, nothing will happen. Ignore undoes the effect of any prior\ncalls to Notify for the provided signals.\nIf no signals are provided, all incoming signals will be ignored.\n\nGo input arguments: (sig ...os.Signal)\n\nJoker input arguments: [^(ellipsis-somehow os/Signal) sig]"
;;   {:added "1.0"
;;    :go "__ignore(ConvertToEllipsisHaHaABEND987(genutils.go: imports not yet supported: os.Signal)(*__sig))"}
;;   [^os/Signal __sig])

JOKER FUNC os/signal.Ignored from os/signal/signal.go:
;; (defn ^"Boolean" Ignored
;;   "Ignored reports whether sig is currently ignored.\n\nGo input arguments: (sig os.Signal)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.os/Signal sig]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "signal.Ignored(*__sig)"}
;;   [^os/Signal __sig])

JOKER FUNC os/signal.Notify from os/signal/signal.go:
;; (defn Notify
;;   "Notify causes package signal to relay incoming signals to c.\nIf no signals are provided, all incoming signals will be relayed to c.\nOtherwise, just the provided signals will.\n\nPackage signal will not block sending to c: the caller must ensure\nthat c has sufficient buffer space to keep up with the expected\nsignal rate. For a channel used for notification of just one signal value,\na buffer of size 1 is sufficient.\n\nIt is allowed to call Notify multiple times with the same channel:\neach call expands the set of signals sent to that channel.\nThe only way to remove signals from the set is to call Stop.\n\nIt is allowed to call Notify multiple times with different channels\nand the same signals: each channel receives copies of incoming\nsignals independently.\n\nGo input arguments: (c <-chan, sig ...os.Signal)\n\nJoker input arguments: [^<no-idea-about-chan-yet> c, ^(ellipsis-somehow os/Signal) sig]"
;;   {:added "1.0"
;;    :go "__notify(ABEND909(pre.go: custom-runtime routine not implemented: ConvertToChanTypeHaHa()), ConvertToEllipsisHaHaABEND987(genutils.go: imports not yet supported: os.Signal)(*__sig))"}
;;   [^<no-idea-about-chan-yet> __c, ^os/Signal __sig])

JOKER FUNC os/signal.Reset from os/signal/signal.go:
;; (defn Reset
;;   "Reset undoes the effect of any prior calls to Notify for the provided\nsignals.\nIf no signals are provided, all signal handlers will be reset.\n\nGo input arguments: (sig ...os.Signal)\n\nJoker input arguments: [^(ellipsis-somehow os/Signal) sig]"
;;   {:added "1.0"
;;    :go "__reset(ConvertToEllipsisHaHaABEND987(genutils.go: imports not yet supported: os.Signal)(*__sig))"}
;;   [^os/Signal __sig])

JOKER FUNC os/signal.Stop from os/signal/signal.go:
;; (defn Stop
;;   "Stop causes package signal to stop relaying incoming signals to c.\nIt undoes the effect of all prior calls to Notify using c.\nWhen Stop returns, it is guaranteed that c will receive no more signals.\n\nGo input arguments: (c <-chan)\n\nJoker input arguments: [^<no-idea-about-chan-yet> c]"
;;   {:added "1.0"
;;    :go "__stop(ABEND909(pre.go: custom-runtime routine not implemented: ConvertToChanTypeHaHa()))"}
;;   [^<no-idea-about-chan-yet> __c])

JOKER TYPE os/user.Group from os/user/user.go:
(defn ^"GoObject" Group.
  "Constructor for user.Group"
  {:added "1.0"
   :go "_ConstructGroup(_v)"}
  [^Object _v])

JOKER TYPE os/user.UnknownGroupError from os/user/user.go:
(defn ^"GoObject" UnknownGroupError.
  "Constructor for user.UnknownGroupError"
  {:added "1.0"
   :go "_ConstructUnknownGroupError(_v)"}
  [^Object _v])

JOKER TYPE os/user.UnknownGroupIdError from os/user/user.go:
(defn ^"GoObject" UnknownGroupIdError.
  "Constructor for user.UnknownGroupIdError"
  {:added "1.0"
   :go "_ConstructUnknownGroupIdError(_v)"}
  [^Object _v])

JOKER TYPE os/user.UnknownUserError from os/user/user.go:
(defn ^"GoObject" UnknownUserError.
  "Constructor for user.UnknownUserError"
  {:added "1.0"
   :go "_ConstructUnknownUserError(_v)"}
  [^Object _v])

JOKER TYPE os/user.UnknownUserIdError from os/user/user.go:
(defn ^"GoObject" UnknownUserIdError.
  "Constructor for user.UnknownUserIdError"
  {:added "1.0"
   :go "_ConstructUnknownUserIdError(_v)"}
  [^Object _v])

JOKER TYPE os/user.User from os/user/user.go:
(defn ^"GoObject" User.
  "Constructor for user.User"
  {:added "1.0"
   :go "_ConstructUser(_v)"}
  [^Object _v])

JOKER FUNC os/user.Current from os/user/lookup.go:
(defn Current
  "Current returns the current user.\n\nThe first call will cache the current user information.\nSubsequent calls will return the cached value and will not reflect\nchanges to the current user.\n\nGo return type: (*User, error)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.os.user/User) Error]"
  {:added "1.0"
   :go "__current()"}
  [])

JOKER FUNC os/user.Lookup from os/user/lookup.go:
(defn Lookup
  "Lookup looks up a user by username. If the user cannot be found, the\nreturned error is of type UnknownUserError.\n\nGo input arguments: (username string)\n\nGo return type: (*User, error)\n\nJoker input arguments: [^String username]\n\nJoker return type: [(atom-of go.std.os.user/User) Error]"
  {:added "1.0"
   :go "__lookup(__username)"}
  [^String __username])

JOKER FUNC os/user.LookupGroup from os/user/lookup.go:
(defn LookupGroup
  "LookupGroup looks up a group by name. If the group cannot be found, the\nreturned error is of type UnknownGroupError.\n\nGo input arguments: (name string)\n\nGo return type: (*Group, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.os.user/Group) Error]"
  {:added "1.0"
   :go "__lookupGroup(__name)"}
  [^String __name])

JOKER FUNC os/user.LookupGroupId from os/user/lookup.go:
(defn LookupGroupId
  "LookupGroupId looks up a group by groupid. If the group cannot be found, the\nreturned error is of type UnknownGroupIdError.\n\nGo input arguments: (gid string)\n\nGo return type: (*Group, error)\n\nJoker input arguments: [^String gid]\n\nJoker return type: [(atom-of go.std.os.user/Group) Error]"
  {:added "1.0"
   :go "__lookupGroupId(__gid)"}
  [^String __gid])

JOKER FUNC os/user.LookupId from os/user/lookup.go:
(defn LookupId
  "LookupId looks up a user by userid. If the user cannot be found, the\nreturned error is of type UnknownUserIdError.\n\nGo input arguments: (uid string)\n\nGo return type: (*User, error)\n\nJoker input arguments: [^String uid]\n\nJoker return type: [(atom-of go.std.os.user/User) Error]"
  {:added "1.0"
   :go "__lookupId(__uid)"}
  [^String __uid])

JOKER TYPE go.std.os.user/Group:
(def
  ^{:doc "Group represents a grouping of users.\n\nOn POSIX systems Gid contains a decimal number representing the group ID.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Group"}
  Group)

JOKER TYPE go.std.os.user/UnknownGroupError:
(def
  ^{:doc "UnknownGroupError is returned by LookupGroup when\na group cannot be found.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnknownGroupError"}
  UnknownGroupError)

JOKER TYPE go.std.os.user/UnknownGroupIdError:
(def
  ^{:doc "UnknownGroupIdError is returned by LookupGroupId when\na group cannot be found.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnknownGroupIdError"}
  UnknownGroupIdError)

JOKER TYPE go.std.os.user/UnknownUserError:
(def
  ^{:doc "UnknownUserError is returned by Lookup when\na user cannot be found.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnknownUserError"}
  UnknownUserError)

JOKER TYPE go.std.os.user/UnknownUserIdError:
(def
  ^{:doc "UnknownUserIdError is returned by LookupId when a user cannot be found.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnknownUserIdError"}
  UnknownUserIdError)

JOKER TYPE go.std.os.user/User:
(def
  ^{:doc "User represents a user account.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_User"}
  User)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the os/user package.\n\nPackage user allows user account lookups by name or id.\n\nFor most Unix systems, this package has two internal implementations of\nresolving user and group ids to names. One is written in pure Go and\nparses /etc/passwd and /etc/group. The other is cgo-based and relies on\nthe standard C library (libc) routines such as getpwuid_r and getgrnam_r.\n\nWhen cgo is available, cgo-based (libc-backed) code is used by default.\nThis can be overridden by using osusergo build tag, which enforces\nthe pure Go implementation.\n"
    :empty false}
  go.std.os.user)
JOKER VARIABLE ErrBadPattern from path/match.go:
(def
  ^{:doc "ErrBadPattern indicates a pattern was malformed.\n"
    :added "1.0"
    :tag "Var"
    :go "path.ErrBadPattern"}
  ErrBadPattern)

JOKER FUNC path.Base from path/path.go:
(defn ^"String" Base
  "Base returns the last element of path.\nTrailing slashes are removed before extracting the last element.\nIf the path is empty, Base returns \".\".\nIf the path consists entirely of slashes, Base returns \"/\".\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Base(__path)"}
  [^String __path])

JOKER FUNC path.Clean from path/path.go:
(defn ^"String" Clean
  "Clean returns the shortest path name equivalent to path\nby purely lexical processing. It applies the following rules\niteratively until no further processing can be done:\n\n\t1. Replace multiple slashes with a single slash.\n\t2. Eliminate each . path name element (the current directory).\n\t3. Eliminate each inner .. path name element (the parent directory)\n\t   along with the non-.. element that precedes it.\n\t4. Eliminate .. elements that begin a rooted path:\n\t   that is, replace \"/..\" by \"/\" at the beginning of a path.\n\nThe returned path ends in a slash only if it is the root \"/\".\n\nIf the result of this process is an empty string, Clean\nreturns the string \".\".\n\nSee also Rob Pike, ``Lexical File Names in Plan 9 or\nGetting Dot-Dot Right,''\nhttps://9p.io/sys/doc/lexnames.html\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Clean(__path)"}
  [^String __path])

JOKER FUNC path.Dir from path/path.go:
(defn ^"String" Dir
  "Dir returns all but the last element of path, typically the path's directory.\nAfter dropping the final element using Split, the path is Cleaned and trailing\nslashes are removed.\nIf the path is empty, Dir returns \".\".\nIf the path consists entirely of slashes followed by non-slash bytes, Dir\nreturns a single slash. In any other case, the returned path does not end in a\nslash.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Dir(__path)"}
  [^String __path])

JOKER FUNC path.Ext from path/path.go:
(defn ^"String" Ext
  "Ext returns the file name extension used by path.\nThe extension is the suffix beginning at the final dot\nin the final slash-separated element of path;\nit is empty if there is no dot.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Ext(__path)"}
  [^String __path])

JOKER FUNC path.IsAbs from path/path.go:
(defn ^"Boolean" IsAbs
  "IsAbs reports whether the path is absolute.\n\nGo input arguments: (path string)\n\nGo return type: bool\n\nJoker input arguments: [^String path]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "path.IsAbs(__path)"}
  [^String __path])

JOKER FUNC path.Join from path/path.go:
;; (defn ^"String" Join
;;   "Join joins any number of path elements into a single path, adding a\nseparating slash if necessary. The result is Cleaned; in particular,\nall empty strings are ignored.\n\nGo input arguments: (elem ...string)\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow String) elem]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "path.Join(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(__elem)))"}
;;   [^String __elem])

JOKER FUNC path.Match from path/match.go:
(defn Match
  "Match reports whether name matches the shell pattern.\nThe pattern syntax is:\n\n\tpattern:\n\t\t{ term }\n\tterm:\n\t\t'*'         matches any sequence of non-/ characters\n\t\t'?'         matches any single non-/ character\n\t\t'[' [ '^' ] { character-range } ']'\n\t\t            character class (must be non-empty)\n\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n\t\t'\\\\' c      matches character c\n\n\tcharacter-range:\n\t\tc           matches character c (c != '\\\\', '-', ']')\n\t\t'\\\\' c      matches character c\n\t\tlo '-' hi   matches character c for lo <= c <= hi\n\nMatch requires pattern to match all of name, not just a substring.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n\nGo input arguments: (pattern string, name string)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^String name]\n\nJoker return type: [Boolean Error]"
  {:added "1.0"
   :go "__match(__pattern, __name)"}
  [^String __pattern, ^String __name])

JOKER FUNC path.Split from path/path.go:
(defn Split
  "Split splits path immediately following the final slash,\nseparating it into a directory and file name component.\nIf there is no slash in path, Split returns an empty dir and\nfile set to path.\nThe returned values have the property that path = dir+file.\n\nGo input arguments: (path string)\n\nGo return type: (dir string, file string)\n\nJoker input arguments: [^String path]\n\nJoker return type: [String String]"
  {:added "1.0"
   :go "__split(__path)"}
  [^String __path])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["path"]
    :doc "Provides a low-level interface to the path package.\n\nPackage path implements utility routines for manipulating slash-separated\npaths.\n\nThe path package should only be used for paths separated by forward\nslashes, such as the paths in URLs. This package does not deal with\nWindows paths with drive letters or backslashes; to manipulate\noperating system paths, use the path/filepath package.\n"
    :empty false}
  go.std.path)
JOKER VARIABLE ErrBadPattern from path/filepath/match.go:
(def
  ^{:doc "ErrBadPattern indicates a pattern was malformed.\n"
    :added "1.0"
    :tag "Var"
    :go "filepath.ErrBadPattern"}
  ErrBadPattern)

JOKER VARIABLE SkipDir from path/filepath/path.go:
(def
  ^{:doc "SkipDir is used as a return value from WalkFuncs to indicate that\nthe directory named in the call is to be skipped. It is not returned\nas an error by any function.\n"
    :added "1.0"
    :tag "Var"
    :go "filepath.SkipDir"}
  SkipDir)

JOKER TYPE path/filepath.WalkFunc from path/filepath/path.go:
;; (defn ^"GoObject" WalkFunc.
;;   "Constructor for filepath.WalkFunc"
;;   {:added "1.0"
;;    :go "_ConstructWalkFunc(_v)"}
;;   [^Object _v])

JOKER FUNC path/filepath.Abs from path/filepath/path.go:
(defn Abs
  "Abs returns an absolute representation of path.\nIf the path is not absolute it will be joined with the current\nworking directory to turn it into an absolute path. The absolute\npath name for a given file is not guaranteed to be unique.\nAbs calls Clean on the result.\n\nGo input arguments: (path string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String path]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__abs(__path)"}
  [^String __path])

JOKER FUNC path/filepath.Base from path/filepath/path.go:
(defn ^"String" Base
  "Base returns the last element of path.\nTrailing path separators are removed before extracting the last element.\nIf the path is empty, Base returns \".\".\nIf the path consists entirely of separators, Base returns a single separator.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Base(__path)"}
  [^String __path])

JOKER FUNC path/filepath.Clean from path/filepath/path.go:
(defn ^"String" Clean
  "Clean returns the shortest path name equivalent to path\nby purely lexical processing. It applies the following rules\niteratively until no further processing can be done:\n\n\t1. Replace multiple Separator elements with a single one.\n\t2. Eliminate each . path name element (the current directory).\n\t3. Eliminate each inner .. path name element (the parent directory)\n\t   along with the non-.. element that precedes it.\n\t4. Eliminate .. elements that begin a rooted path:\n\t   that is, replace \"/..\" by \"/\" at the beginning of a path,\n\t   assuming Separator is '/'.\n\nThe returned path ends in a slash only if it represents a root directory,\nsuch as \"/\" on Unix or `C:\\` on Windows.\n\nFinally, any occurrences of slash are replaced by Separator.\n\nIf the result of this process is an empty string, Clean\nreturns the string \".\".\n\nSee also Rob Pike, ``Lexical File Names in Plan 9 or\nGetting Dot-Dot Right,''\nhttps://9p.io/sys/doc/lexnames.html\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Clean(__path)"}
  [^String __path])

JOKER FUNC path/filepath.Dir from path/filepath/path.go:
(defn ^"String" Dir
  "Dir returns all but the last element of path, typically the path's directory.\nAfter dropping the final element, Dir calls Clean on the path and trailing\nslashes are removed.\nIf the path is empty, Dir returns \".\".\nIf the path consists entirely of separators, Dir returns a single separator.\nThe returned path does not end in a separator unless it is the root directory.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Dir(__path)"}
  [^String __path])

JOKER FUNC path/filepath.EvalSymlinks from path/filepath/path.go:
(defn EvalSymlinks
  "EvalSymlinks returns the path name after the evaluation of any symbolic\nlinks.\nIf path is relative the result will be relative to the current directory,\nunless one of the components is an absolute symbolic link.\nEvalSymlinks calls Clean on the result.\n\nGo input arguments: (path string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String path]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__evalSymlinks(__path)"}
  [^String __path])

JOKER FUNC path/filepath.Ext from path/filepath/path.go:
(defn ^"String" Ext
  "Ext returns the file name extension used by path.\nThe extension is the suffix beginning at the final dot\nin the final element of path; it is empty if there is\nno dot.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Ext(__path)"}
  [^String __path])

JOKER FUNC path/filepath.FromSlash from path/filepath/path.go:
(defn ^"String" FromSlash
  "FromSlash returns the result of replacing each slash ('/') character\nin path with a separator character. Multiple slashes are replaced\nby multiple separators.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.FromSlash(__path)"}
  [^String __path])

JOKER FUNC path/filepath.Glob from path/filepath/match.go:
(defn Glob
  "Glob returns the names of all files matching pattern or nil\nif there is no matching file. The syntax of patterns is the same\nas in Match. The pattern may describe hierarchical names such as\n/usr/*/bin/ed (assuming the Separator is '/').\n\nGlob ignores file system errors such as I/O errors reading directories.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n\nGo input arguments: (pattern string)\n\nGo return type: (matches []string, err error)\n\nJoker input arguments: [^String pattern]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__glob(__pattern)"}
  [^String __pattern])

JOKER FUNC path/filepath.HasPrefix from path/filepath/path_unix.go:
(defn ^"Boolean" HasPrefix
  "HasPrefix exists for historical compatibility and should not be used.\n\nDeprecated: HasPrefix does not respect path boundaries and\ndoes not ignore case when required.\n\nGo input arguments: (p string, prefix string)\n\nGo return type: bool\n\nJoker input arguments: [^String p, ^String prefix]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "filepath.HasPrefix(__p, __prefix)"}
  [^String __p, ^String __prefix])

JOKER FUNC path/filepath.IsAbs from path/filepath/path_unix.go:
(defn ^"Boolean" IsAbs
  "IsAbs reports whether the path is absolute.\n\nGo input arguments: (path string)\n\nGo return type: bool\n\nJoker input arguments: [^String path]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "filepath.IsAbs(__path)"}
  [^String __path])

JOKER FUNC path/filepath.Join from path/filepath/path.go:
;; (defn ^"String" Join
;;   "Join joins any number of path elements into a single path, adding\na Separator if necessary. Join calls Clean on the result; in particular,\nall empty strings are ignored.\nOn Windows, the result is a UNC path if and only if the first path\nelement is a UNC path.\n\nGo input arguments: (elem ...string)\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow String) elem]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "filepath.Join(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(__elem)))"}
;;   [^String __elem])

JOKER FUNC path/filepath.Match from path/filepath/match.go:
(defn Match
  "Match reports whether name matches the shell file name pattern.\nThe pattern syntax is:\n\n\tpattern:\n\t\t{ term }\n\tterm:\n\t\t'*'         matches any sequence of non-Separator characters\n\t\t'?'         matches any single non-Separator character\n\t\t'[' [ '^' ] { character-range } ']'\n\t\t            character class (must be non-empty)\n\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n\t\t'\\\\' c      matches character c\n\n\tcharacter-range:\n\t\tc           matches character c (c != '\\\\', '-', ']')\n\t\t'\\\\' c      matches character c\n\t\tlo '-' hi   matches character c for lo <= c <= hi\n\nMatch requires pattern to match all of name, not just a substring.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n\nOn Windows, escaping is disabled. Instead, '\\\\' is treated as\npath separator.\n\nGo input arguments: (pattern string, name string)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^String name]\n\nJoker return type: [Boolean Error]"
  {:added "1.0"
   :go "__match(__pattern, __name)"}
  [^String __pattern, ^String __name])

JOKER FUNC path/filepath.Rel from path/filepath/path.go:
(defn Rel
  "Rel returns a relative path that is lexically equivalent to targpath when\njoined to basepath with an intervening separator. That is,\nJoin(basepath, Rel(basepath, targpath)) is equivalent to targpath itself.\nOn success, the returned path will always be relative to basepath,\neven if basepath and targpath share no elements.\nAn error is returned if targpath can't be made relative to basepath or if\nknowing the current working directory would be necessary to compute it.\nRel calls Clean on the result.\n\nGo input arguments: (basepath string, targpath string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String basepath, ^String targpath]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__rel(__basepath, __targpath)"}
  [^String __basepath, ^String __targpath])

JOKER FUNC path/filepath.Split from path/filepath/path.go:
(defn Split
  "Split splits path immediately following the final Separator,\nseparating it into a directory and file name component.\nIf there is no Separator in path, Split returns an empty dir\nand file set to path.\nThe returned values have the property that path = dir+file.\n\nGo input arguments: (path string)\n\nGo return type: (dir string, file string)\n\nJoker input arguments: [^String path]\n\nJoker return type: [String String]"
  {:added "1.0"
   :go "__split(__path)"}
  [^String __path])

JOKER FUNC path/filepath.SplitList from path/filepath/path.go:
(defn SplitList
  "SplitList splits a list of paths joined by the OS-specific ListSeparator,\nusually found in PATH or GOPATH environment variables.\nUnlike strings.Split, SplitList returns an empty slice when passed an empty\nstring.\n\nGo input arguments: (path string)\n\nGo return type: []string\n\nJoker input arguments: [^String path]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__splitList(__path)"}
  [^String __path])

JOKER FUNC path/filepath.ToSlash from path/filepath/path.go:
(defn ^"String" ToSlash
  "ToSlash returns the result of replacing each separator character\nin path with a slash ('/') character. Multiple separators are\nreplaced by multiple slashes.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.ToSlash(__path)"}
  [^String __path])

JOKER FUNC path/filepath.VolumeName from path/filepath/path.go:
(defn ^"String" VolumeName
  "VolumeName returns leading volume name.\nGiven \"C:\\foo\\bar\" it returns \"C:\" on Windows.\nGiven \"\\\\host\\share\\foo\" it returns \"\\\\host\\share\".\nOn other platforms it returns \"\".\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.VolumeName(__path)"}
  [^String __path])

JOKER FUNC path/filepath.Walk from path/filepath/path.go:
(defn ^"Error" Walk
  "Walk walks the file tree rooted at root, calling walkFn for each file or\ndirectory in the tree, including root. All errors that arise visiting files\nand directories are filtered by walkFn. The files are walked in lexical\norder, which makes the output deterministic but means that for very\nlarge directories Walk can be inefficient.\nWalk does not follow symbolic links.\n\nGo input arguments: (root string, walkFn WalkFunc)\n\nGo return type: error\n\nJoker input arguments: [^String root, ^go.std.path.filepath/WalkFunc walkFn]\n\nJoker return type: Error"
  {:added "1.0"
   :go "filepath.Walk(__root, *__walkFn)"}
  [^String __root, ^filepath/WalkFunc __walkFn])

JOKER TYPE go.std.path.filepath/WalkFunc:
(def
  ^{:doc "WalkFunc is the type of the function called for each file or directory\nvisited by Walk. The path argument contains the argument to Walk as a\nprefix; that is, if Walk is called with \"dir\", which is a directory\ncontaining the file \"a\", the walk function will be called with argument\n\"dir/a\". The info argument is the os.FileInfo for the named path.\n\nIf there was a problem walking to the file or directory named by path, the\nincoming error will describe the problem and the function can decide how\nto handle that error (and Walk will not descend into that directory). In the\ncase of an error, the info argument will be nil. If an error is returned,\nprocessing stops. The sole exception is when the function returns the special\nvalue SkipDir. If the function returns SkipDir when invoked on a directory,\nWalk skips the directory's contents entirely. If the function returns SkipDir\nwhen invoked on a non-directory file, Walk skips the remaining files in the\ncontaining directory.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_WalkFunc"}
  WalkFunc)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["path/filepath"]
    :doc "Provides a low-level interface to the path/filepath package.\n\nPackage filepath implements utility routines for manipulating filename paths\nin a way compatible with the target operating system-defined file paths.\n\nThe filepath package uses either forward slashes or backslashes,\ndepending on the operating system. To process paths such as URLs\nthat always use forward slashes regardless of the operating\nsystem, see the path package.\n"
    :empty false}
  go.std.path.filepath)
JOKER TYPE plugin.Plugin from plugin/plugin.go:
(defn ^"GoObject" Plugin.
  "Constructor for plugin.Plugin"
  {:added "1.0"
   :go "_ConstructPlugin(_v)"}
  [^Object _v])

JOKER TYPE plugin.Symbol from plugin/plugin.go:
;; (defn ^"GoObject" Symbol.
;;   "Constructor for plugin.Symbol"
;;   {:added "1.0"
;;    :go "_ConstructSymbol(_v)"}
;;   [^Object _v])

JOKER FUNC plugin.Open from plugin/plugin.go:
(defn Open
  "Open opens a Go plugin.\nIf a path has already been opened, then the existing *Plugin is returned.\nIt is safe for concurrent use by multiple goroutines.\n\nGo input arguments: (path string)\n\nGo return type: (*Plugin, error)\n\nJoker input arguments: [^String path]\n\nJoker return type: [(atom-of go.std.plugin/Plugin) Error]"
  {:added "1.0"
   :go "__open(__path)"}
  [^String __path])

JOKER TYPE go.std.plugin/Plugin:
(def
  ^{:doc "Plugin is a loaded Go plugin.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Plugin"}
  Plugin)

JOKER TYPE go.std.plugin/Symbol:
(def
  ^{:doc "A Symbol is a pointer to a variable or function.\n\nFor example, a plugin defined as\n\n\tpackage main\n\n\timport \"fmt\"\n\n\tvar V int\n\n\tfunc F() { fmt.Printf(\"Hello, number %d\\n\", V) }\n\nmay be loaded with the Open function and then the exported package\nsymbols V and F can be accessed\n\n\tp, err := plugin.Open(\"plugin_name.so\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tv, err := p.Lookup(\"V\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tf, err := p.Lookup(\"F\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t*v.(*int) = 7\n\tf.(func())() // prints \"Hello, number 7\"\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Symbol"}
  Symbol)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the plugin package.\n\nPackage plugin implements loading and symbol resolution of Go plugins.\n\nA plugin is a Go main package with exported functions and variables that\nhas been built with:\n\n\tgo build -buildmode=plugin\n\nWhen a plugin is first opened, the init functions of all packages not\nalready part of the program are called. The main function is not run.\nA plugin is only initialized once, and cannot be closed.\n\nCurrently plugins are only supported on Linux and macOS.\nPlease report any issues.\n"
    :empty false}
  go.std.plugin)
JOKER CONSTANT Array from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Array))"}
  Array)

JOKER CONSTANT Bool from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Bool))"}
  Bool)

JOKER CONSTANT BothDir from reflect/type.go:
(def
  ^{:doc "chan\n"
    :added "1.0"
    :tag "Int"
    :go "int(reflect.BothDir)"}
  BothDir)

JOKER CONSTANT Chan from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Chan))"}
  Chan)

JOKER CONSTANT Complex128 from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Complex128))"}
  Complex128)

JOKER CONSTANT Complex64 from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Complex64))"}
  Complex64)

JOKER CONSTANT Float32 from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Float32))"}
  Float32)

JOKER CONSTANT Float64 from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Float64))"}
  Float64)

JOKER CONSTANT Func from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Func))"}
  Func)

JOKER CONSTANT Int from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Int))"}
  Int-renamed)

JOKER CONSTANT Int16 from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Int16))"}
  Int16)

JOKER CONSTANT Int32 from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Int32))"}
  Int32)

JOKER CONSTANT Int64 from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Int64))"}
  Int64)

JOKER CONSTANT Int8 from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Int8))"}
  Int8)

JOKER CONSTANT Interface from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Interface))"}
  Interface)

JOKER CONSTANT Invalid from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Invalid))"}
  Invalid)

JOKER CONSTANT Map from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Map))"}
  Map)

JOKER CONSTANT Ptr from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Ptr))"}
  Ptr)

JOKER CONSTANT RecvDir from reflect/type.go:
(def
  ^{:doc "<-chan\n"
    :added "1.0"
    :tag "Int"
    :go "int(reflect.RecvDir)"}
  RecvDir)

JOKER CONSTANT SelectDefault from reflect/value.go:
(def
  ^{:doc "default\n"
    :added "1.0"
    :tag "Int"
    :go "int(reflect.SelectDefault)"}
  SelectDefault)

JOKER CONSTANT SelectRecv from reflect/value.go:
(def
  ^{:doc "case <-Chan:\n"
    :added "1.0"
    :tag "Int"
    :go "int(reflect.SelectRecv)"}
  SelectRecv)

JOKER CONSTANT SelectSend from reflect/value.go:
(def
  ^{:doc "case Chan <- Send\n"
    :added "1.0"
    :tag "Int"
    :go "int(reflect.SelectSend)"}
  SelectSend)

JOKER CONSTANT SendDir from reflect/type.go:
(def
  ^{:doc "chan<-\n"
    :added "1.0"
    :tag "Int"
    :go "int(reflect.SendDir)"}
  SendDir)

JOKER CONSTANT Slice from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Slice))"}
  Slice)

JOKER CONSTANT String from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.String))"}
  String-renamed)

JOKER CONSTANT Struct from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Struct))"}
  Struct)

JOKER CONSTANT Uint from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Uint))"}
  Uint)

JOKER CONSTANT Uint16 from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Uint16))"}
  Uint16)

JOKER CONSTANT Uint32 from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Uint32))"}
  Uint32)

JOKER CONSTANT Uint64 from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Uint64))"}
  Uint64)

JOKER CONSTANT Uint8 from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Uint8))"}
  Uint8)

JOKER CONSTANT Uintptr from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.Uintptr))"}
  Uintptr)

JOKER CONSTANT UnsafePointer from reflect/type.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(reflect.UnsafePointer))"}
  UnsafePointer)

JOKER TYPE reflect.ChanDir from reflect/type.go:
(defn ^"GoObject" ChanDir.
  "Constructor for reflect.ChanDir"
  {:added "1.0"
   :go "_ConstructChanDir(_v)"}
  [^Object _v])

JOKER TYPE reflect.Kind from reflect/type.go:
(defn ^"GoObject" Kind.
  "Constructor for reflect.Kind"
  {:added "1.0"
   :go "_ConstructKind(_v)"}
  [^Object _v])

JOKER TYPE reflect.MapIter from reflect/value.go:
(defn ^"GoObject" MapIter.
  "Constructor for reflect.MapIter"
  {:added "1.0"
   :go "_ConstructMapIter(_v)"}
  [^Object _v])

JOKER TYPE reflect.Method from reflect/type.go:
;; (defn ^"GoObject" Method.
;;   "Constructor for reflect.Method"
;;   {:added "1.0"
;;    :go "_ConstructMethod(_v)"}
;;   [^Object _v])

JOKER TYPE reflect.SelectCase from reflect/value.go:
;; (defn ^"GoObject" SelectCase.
;;   "Constructor for reflect.SelectCase"
;;   {:added "1.0"
;;    :go "_ConstructSelectCase(_v)"}
;;   [^Object _v])

JOKER TYPE reflect.SelectDir from reflect/value.go:
(defn ^"GoObject" SelectDir.
  "Constructor for reflect.SelectDir"
  {:added "1.0"
   :go "_ConstructSelectDir(_v)"}
  [^Object _v])

JOKER TYPE reflect.SliceHeader from reflect/value.go:
(defn ^"GoObject" SliceHeader.
  "Constructor for reflect.SliceHeader"
  {:added "1.0"
   :go "_ConstructSliceHeader(_v)"}
  [^Object _v])

JOKER TYPE reflect.StringHeader from reflect/value.go:
(defn ^"GoObject" StringHeader.
  "Constructor for reflect.StringHeader"
  {:added "1.0"
   :go "_ConstructStringHeader(_v)"}
  [^Object _v])

JOKER TYPE reflect.StructField from reflect/type.go:
;; (defn ^"GoObject" StructField.
;;   "Constructor for reflect.StructField"
;;   {:added "1.0"
;;    :go "_ConstructStructField(_v)"}
;;   [^Object _v])

JOKER TYPE reflect.StructTag from reflect/type.go:
(defn ^"GoObject" StructTag.
  "Constructor for reflect.StructTag"
  {:added "1.0"
   :go "_ConstructStructTag(_v)"}
  [^Object _v])

JOKER TYPE reflect.Type from reflect/type.go:
;; (defn ^"GoObject" Type.
;;   "Constructor for reflect.Type"
;;   {:added "1.0"
;;    :go "_ConstructType(_v)"}
;;   [^Object _v])

JOKER TYPE reflect.Value from reflect/value.go:
(defn ^"GoObject" Value.
  "Constructor for reflect.Value"
  {:added "1.0"
   :go "_ConstructValue(_v)"}
  [^Object _v])

JOKER TYPE reflect.ValueError from reflect/value.go:
(defn ^"GoObject" ValueError.
  "Constructor for reflect.ValueError"
  {:added "1.0"
   :go "_ConstructValueError(_v)"}
  [^Object _v])

JOKER FUNC reflect.Append from reflect/value.go:
;; (defn Append
;;   "Append appends the values x to a slice s and returns the resulting slice.\nAs in Go, each x's value must be assignable to the slice's element type.\n\nGo input arguments: (s Value, x ...Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Value s, ^(ellipsis-somehow reflect/Value) x]\n\nJoker return type: go.std.reflect/Value"
;;   {:added "1.0"
;;    :go "__append(*__s, ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHa_reflect.Value(*__x)))"}
;;   [^reflect/Value __s, ^reflect/Value __x])

JOKER FUNC reflect.AppendSlice from reflect/value.go:
(defn AppendSlice
  "AppendSlice appends a slice t to a slice s and returns the resulting slice.\nThe slices s and t must have the same element type.\n\nGo input arguments: (s Value, t Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Value s, ^go.std.reflect/Value t]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__appendSlice(*__s, *__t)"}
  [^reflect/Value __s, ^reflect/Value __t])

JOKER FUNC reflect.ArrayOf from reflect/type.go:
(defn ArrayOf
  "ArrayOf returns the array type with the given count and element type.\nFor example, if t represents int, ArrayOf(5, t) represents [5]int.\n\nIf the resulting type would be larger than the available address space,\nArrayOf panics.\n\nGo input arguments: (count int, elem Type)\n\nGo return type: Type\n\nJoker input arguments: [^Int count, ^go.std.reflect/Type elem]\n\nJoker return type: go.std.reflect/Type"
  {:added "1.0"
   :go "__arrayOf(__count, *__elem)"}
  [^Int __count, ^reflect/Type __elem])

JOKER FUNC reflect.ChanOf from reflect/type.go:
(defn ChanOf
  "ChanOf returns the channel type with the given direction and element type.\nFor example, if t represents int, ChanOf(RecvDir, t) represents <-chan int.\n\nThe gc runtime imposes a limit of 64 kB on channel element types.\nIf t's size is equal to or exceeds this limit, ChanOf panics.\n\nGo input arguments: (dir ChanDir, t Type)\n\nGo return type: Type\n\nJoker input arguments: [^go.std.reflect/ChanDir dir, ^go.std.reflect/Type t]\n\nJoker return type: go.std.reflect/Type"
  {:added "1.0"
   :go "__chanOf(*__dir, *__t)"}
  [^reflect/ChanDir __dir, ^reflect/Type __t])

JOKER FUNC reflect.Copy from reflect/value.go:
(defn ^"Int" Copy
  "Copy copies the contents of src into dst until either\ndst has been filled or src has been exhausted.\nIt returns the number of elements copied.\nDst and src each must have kind Slice or Array, and\ndst and src must have the same element type.\n\nAs a special case, src can have kind String if the element type of dst is kind Uint8.\n\nGo input arguments: (dst Value, src Value)\n\nGo return type: int\n\nJoker input arguments: [^go.std.reflect/Value dst, ^go.std.reflect/Value src]\n\nJoker return type: Int"
  {:added "1.0"
   :go "reflect.Copy(*__dst, *__src)"}
  [^reflect/Value __dst, ^reflect/Value __src])

JOKER FUNC reflect.DeepEqual from reflect/deepequal.go:
;; (defn ^"Boolean" DeepEqual
;;   "DeepEqual reports whether x and y are ``deeply equal,'' defined as follows.\nTwo values of identical type are deeply equal if one of the following cases applies.\nValues of distinct types are never deeply equal.\n\nArray values are deeply equal when their corresponding elements are deeply equal.\n\nStruct values are deeply equal if their corresponding fields,\nboth exported and unexported, are deeply equal.\n\nFunc values are deeply equal if both are nil; otherwise they are not deeply equal.\n\nInterface values are deeply equal if they hold deeply equal concrete values.\n\nMap values are deeply equal when all of the following are true:\nthey are both nil or both non-nil, they have the same length,\nand either they are the same map object or their corresponding keys\n(matched using Go equality) map to deeply equal values.\n\nPointer values are deeply equal if they are equal using Go's == operator\nor if they point to deeply equal values.\n\nSlice values are deeply equal when all of the following are true:\nthey are both nil or both non-nil, they have the same length,\nand either they point to the same initial entry of the same underlying array\n(that is, &x[0] == &y[0]) or their corresponding elements (up to length) are deeply equal.\nNote that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil))\nare not deeply equal.\n\nOther values - numbers, bools, strings, and channels - are deeply equal\nif they are equal using Go's == operator.\n\nIn general DeepEqual is a recursive relaxation of Go's == operator.\nHowever, this idea is impossible to implement without some inconsistency.\nSpecifically, it is possible for a value to be unequal to itself,\neither because it is of func type (uncomparable in general)\nor because it is a floating-point NaN value (not equal to itself in floating-point comparison),\nor because it is an array, struct, or interface containing\nsuch a value.\nOn the other hand, pointer values are always equal to themselves,\neven if they point at or contain such problematic values,\nbecause they compare equal using Go's == operator, and that\nis a sufficient condition to be deeply equal, regardless of content.\nDeepEqual has been defined so that the same short-cut applies\nto slices and maps: if x and y are the same slice or the same map,\nthey are deeply equal regardless of content.\n\nAs DeepEqual traverses the data values it may find a cycle. The\nsecond and subsequent times that DeepEqual compares two pointer\nvalues that have been compared before, it treats the values as\nequal rather than examining the values to which they point.\nThis ensures that DeepEqual terminates.\n\nGo input arguments: (x interface {}, y interface {})\n\nGo return type: bool\n\nJoker input arguments: [^<protocol-or-something> x, ^<protocol-or-something> y]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "reflect.DeepEqual(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> __x, ^<protocol-or-something> __y])

JOKER FUNC reflect.FuncOf from reflect/type.go:
;; (defn FuncOf
;;   "FuncOf returns the function type with the given argument and result types.\nFor example if k represents int and e represents string,\nFuncOf([]Type{k}, []Type{e}, false) represents func(int) string.\n\nThe variadic argument controls whether the function is variadic. FuncOf\npanics if the in[len(in)-1] does not represent a slice and variadic is\ntrue.\n\nGo input arguments: (in []Type, out []Type, variadic bool)\n\nGo return type: Type\n\nJoker input arguments: [^(vector-of go.std.reflect/Type) in, ^(vector-of go.std.reflect/Type) out, ^Boolean variadic]\n\nJoker return type: go.std.reflect/Type"
;;   {:added "1.0"
;;    :go "__funcOf(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_reflect.Type(*__in)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_reflect.Type(*__out)), __variadic)"}
;;   [^Object __in, ^Object __out, ^Boolean __variadic])

JOKER FUNC reflect.Indirect from reflect/value.go:
(defn Indirect
  "Indirect returns the value that v points to.\nIf v is a nil pointer, Indirect returns a zero Value.\nIf v is not a pointer, Indirect returns v.\n\nGo input arguments: (v Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Value v]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__indirect(*__v)"}
  [^reflect/Value __v])

JOKER FUNC reflect.MakeChan from reflect/value.go:
(defn MakeChan
  "MakeChan creates a new channel with the specified type and buffer size.\n\nGo input arguments: (typ Type, buffer int)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ, ^Int buffer]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__makeChan(*__typ, __buffer)"}
  [^reflect/Type __typ, ^Int __buffer])

JOKER FUNC reflect.MakeFunc from reflect/makefunc.go:
;; (defn MakeFunc
;;   "MakeFunc returns a new function of the given Type\nthat wraps the function fn. When called, that new function\ndoes the following:\n\n\t- converts its arguments to a slice of Values.\n\t- runs results := fn(args).\n\t- returns the results as a slice of Values, one per formal result.\n\nThe implementation fn can assume that the argument Value slice\nhas the number and type of arguments given by typ.\nIf typ describes a variadic function, the final Value is itself\na slice representing the variadic arguments, as in the\nbody of a variadic function. The result Value slice returned by fn\nmust have the number and type of results given by typ.\n\nThe Value.Call method allows the caller to invoke a typed function\nin terms of Values; in contrast, MakeFunc allows the caller to implement\na typed function in terms of Values.\n\nThe Examples section of the documentation includes an illustration\nof how to use MakeFunc to build a swap function for different types.\n\nGo input arguments: (typ Type, fn func)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ, ^fn fn]\n\nJoker return type: go.std.reflect/Value"
;;   {:added "1.0"
;;    :go "__makeFunc(*__typ, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^reflect/Type __typ, ^fn __fn])

JOKER FUNC reflect.MakeMap from reflect/value.go:
(defn MakeMap
  "MakeMap creates a new map with the specified type.\n\nGo input arguments: (typ Type)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__makeMap(*__typ)"}
  [^reflect/Type __typ])

JOKER FUNC reflect.MakeMapWithSize from reflect/value.go:
(defn MakeMapWithSize
  "MakeMapWithSize creates a new map with the specified type\nand initial space for approximately n elements.\n\nGo input arguments: (typ Type, n int)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ, ^Int n]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__makeMapWithSize(*__typ, __n)"}
  [^reflect/Type __typ, ^Int __n])

JOKER FUNC reflect.MakeSlice from reflect/value.go:
(defn MakeSlice
  "MakeSlice creates a new zero-initialized slice value\nfor the specified slice type, length, and capacity.\n\nGo input arguments: (typ Type, len int, cap int)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ, ^Int len, ^Int cap]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__makeSlice(*__typ, __len, __cap)"}
  [^reflect/Type __typ, ^Int __len, ^Int __cap])

JOKER FUNC reflect.MapOf from reflect/type.go:
(defn MapOf
  "MapOf returns the map type with the given key and element types.\nFor example, if k represents int and e represents string,\nMapOf(k, e) represents map[int]string.\n\nIf the key type is not a valid map key type (that is, if it does\nnot implement Go's == operator), MapOf panics.\n\nGo input arguments: (key Type, elem Type)\n\nGo return type: Type\n\nJoker input arguments: [^go.std.reflect/Type key, ^go.std.reflect/Type elem]\n\nJoker return type: go.std.reflect/Type"
  {:added "1.0"
   :go "__mapOf(*__key, *__elem)"}
  [^reflect/Type __key, ^reflect/Type __elem])

JOKER FUNC reflect.New from reflect/value.go:
(defn New
  "New returns a Value representing a pointer to a new zero value\nfor the specified type. That is, the returned Value's Type is PtrTo(typ).\n\nGo input arguments: (typ Type)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__new(*__typ)"}
  [^reflect/Type __typ])

JOKER FUNC reflect.NewAt from reflect/value.go:
;; (defn NewAt
;;   "NewAt returns a Value representing a pointer to a value of the\nspecified type, using p as that pointer.\n\nGo input arguments: (typ Type, p unsafe.Pointer)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ, ^go.std.unsafe/Pointer p]\n\nJoker return type: go.std.reflect/Value"
;;   {:added "1.0"
;;    :go "__newAt(*__typ, *__p)"}
;;   [^reflect/Type __typ, ^unsafe/Pointer __p])

JOKER FUNC reflect.PtrTo from reflect/type.go:
(defn PtrTo
  "PtrTo returns the pointer type with element t.\nFor example, if t represents type Foo, PtrTo(t) represents *Foo.\n\nGo input arguments: (t Type)\n\nGo return type: Type\n\nJoker input arguments: [^go.std.reflect/Type t]\n\nJoker return type: go.std.reflect/Type"
  {:added "1.0"
   :go "__ptrTo(*__t)"}
  [^reflect/Type __t])

JOKER FUNC reflect.Select from reflect/value.go:
;; (defn Select
;;   "Select executes a select operation described by the list of cases.\nLike the Go select statement, it blocks until at least one of the cases\ncan proceed, makes a uniform pseudo-random choice,\nand then executes that case. It returns the index of the chosen case\nand, if that case was a receive operation, the value received and a\nboolean indicating whether the value corresponds to a send on the channel\n(as opposed to a zero value received because the channel is closed).\n\nGo input arguments: (cases []SelectCase)\n\nGo return type: (chosen int, recv Value, recvOK bool)\n\nJoker input arguments: [^(vector-of go.std.reflect/SelectCase) cases]\n\nJoker return type: [Int go.std.reflect/Value Boolean]"
;;   {:added "1.0"
;;    :go "__select(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_reflect.SelectCase(*__cases)))"}
;;   [^Object __cases])

JOKER FUNC reflect.SliceOf from reflect/type.go:
(defn SliceOf
  "SliceOf returns the slice type with element type t.\nFor example, if t represents int, SliceOf(t) represents []int.\n\nGo input arguments: (t Type)\n\nGo return type: Type\n\nJoker input arguments: [^go.std.reflect/Type t]\n\nJoker return type: go.std.reflect/Type"
  {:added "1.0"
   :go "__sliceOf(*__t)"}
  [^reflect/Type __t])

JOKER FUNC reflect.StructOf from reflect/type.go:
;; (defn StructOf
;;   "StructOf returns the struct type containing fields.\nThe Offset and Index fields are ignored and computed as they would be\nby the compiler.\n\nStructOf currently does not generate wrapper methods for embedded\nfields and panics if passed unexported StructFields.\nThese limitations may be lifted in a future version.\n\nGo input arguments: (fields []StructField)\n\nGo return type: Type\n\nJoker input arguments: [^(vector-of go.std.reflect/StructField) fields]\n\nJoker return type: go.std.reflect/Type"
;;   {:added "1.0"
;;    :go "__structOf(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_reflect.StructField(*__fields)))"}
;;   [^Object __fields])

JOKER FUNC reflect.Swapper from reflect/swapper.go:
;; (defn Swapper
;;   "Swapper returns a function that swaps the elements in the provided\nslice.\n\nSwapper panics if the provided interface is not a slice.\n\nGo input arguments: (slice interface {})\n\nGo return type: ...\n\nJoker input arguments: [^<protocol-or-something> slice]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.FuncType at: /usr/local/go/src/reflect/swapper.go:13:33)"
;;   {:added "1.0"
;;    :go "__swapper(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> __slice])

JOKER FUNC reflect.TypeOf from reflect/type.go:
;; (defn TypeOf
;;   "TypeOf returns the reflection Type that represents the dynamic type of i.\nIf i is a nil interface value, TypeOf returns nil.\n\nGo input arguments: (i interface {})\n\nGo return type: Type\n\nJoker input arguments: [^<protocol-or-something> i]\n\nJoker return type: go.std.reflect/Type"
;;   {:added "1.0"
;;    :go "__typeOf(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> __i])

JOKER FUNC reflect.ValueOf from reflect/value.go:
;; (defn ValueOf
;;   "ValueOf returns a new Value initialized to the concrete value\nstored in the interface i. ValueOf(nil) returns the zero Value.\n\nGo input arguments: (i interface {})\n\nGo return type: Value\n\nJoker input arguments: [^<protocol-or-something> i]\n\nJoker return type: go.std.reflect/Value"
;;   {:added "1.0"
;;    :go "__valueOf(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> __i])

JOKER FUNC reflect.Zero from reflect/value.go:
(defn Zero
  "Zero returns a Value representing the zero value for the specified type.\nThe result is different from the zero value of the Value struct,\nwhich represents no value at all.\nFor example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0.\nThe returned value is neither addressable nor settable.\n\nGo input arguments: (typ Type)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__zero(*__typ)"}
  [^reflect/Type __typ])

JOKER TYPE go.std.reflect/ChanDir:
(def
  ^{:doc "ChanDir represents a channel type's direction.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ChanDir"}
  ChanDir)

JOKER TYPE go.std.reflect/Kind:
(def
  ^{:doc "A Kind represents the specific kind of type that a Type represents.\nThe zero Kind is not a valid kind.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Kind"}
  Kind)

JOKER TYPE go.std.reflect/MapIter:
(def
  ^{:doc "A MapIter is an iterator for ranging over a map.\nSee Value.MapRange.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_MapIter"}
  MapIter)

JOKER TYPE go.std.reflect/Method:
(def
  ^{:doc "Method represents a single method.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Method"}
  Method)

JOKER TYPE go.std.reflect/SelectCase:
(def
  ^{:doc "A SelectCase describes a single case in a select operation.\nThe kind of case depends on Dir, the communication direction.\n\nIf Dir is SelectDefault, the case represents a default case.\nChan and Send must be zero Values.\n\nIf Dir is SelectSend, the case represents a send operation.\nNormally Chan's underlying value must be a channel, and Send's underlying value must be\nassignable to the channel's element type. As a special case, if Chan is a zero Value,\nthen the case is ignored, and the field Send will also be ignored and may be either zero\nor non-zero.\n\nIf Dir is SelectRecv, the case represents a receive operation.\nNormally Chan's underlying value must be a channel and Send must be a zero Value.\nIf Chan is a zero Value, then the case is ignored, but Send must still be a zero Value.\nWhen a receive operation is selected, the received Value is returned by Select.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SelectCase"}
  SelectCase)

JOKER TYPE go.std.reflect/SelectDir:
(def
  ^{:doc "A SelectDir describes the communication direction of a select case.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SelectDir"}
  SelectDir)

JOKER TYPE go.std.reflect/SliceHeader:
(def
  ^{:doc "SliceHeader is the runtime representation of a slice.\nIt cannot be used safely or portably and its representation may\nchange in a later release.\nMoreover, the Data field is not sufficient to guarantee the data\nit references will not be garbage collected, so programs must keep\na separate, correctly typed pointer to the underlying data.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SliceHeader"}
  SliceHeader)

JOKER TYPE go.std.reflect/StringHeader:
(def
  ^{:doc "StringHeader is the runtime representation of a string.\nIt cannot be used safely or portably and its representation may\nchange in a later release.\nMoreover, the Data field is not sufficient to guarantee the data\nit references will not be garbage collected, so programs must keep\na separate, correctly typed pointer to the underlying data.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_StringHeader"}
  StringHeader)

JOKER TYPE go.std.reflect/StructField:
(def
  ^{:doc "A StructField describes a single field in a struct.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_StructField"}
  StructField)

JOKER TYPE go.std.reflect/StructTag:
(def
  ^{:doc "A StructTag is the tag string in a struct field.\n\nBy convention, tag strings are a concatenation of\noptionally space-separated key:\"value\" pairs.\nEach key is a non-empty string consisting of non-control\ncharacters other than space (U+0020 ' '), quote (U+0022 '\"'),\nand colon (U+003A ':').  Each value is quoted using U+0022 '\"'\ncharacters and Go string literal syntax.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_StructTag"}
  StructTag)

JOKER TYPE go.std.reflect/Type:
(def
  ^{:doc "Type is the representation of a Go type.\n\nNot all methods apply to all kinds of types. Restrictions,\nif any, are noted in the documentation for each method.\nUse the Kind method to find out the kind of type before\ncalling kind-specific methods. Calling a method\ninappropriate to the kind of type causes a run-time panic.\n\nType values are comparable, such as with the == operator,\nso they can be used as map keys.\nTwo Type values are equal if they represent identical types.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Type"}
  Type)

JOKER TYPE go.std.reflect/Value:
(def
  ^{:doc "Value is the reflection interface to a Go value.\n\nNot all methods apply to all kinds of values. Restrictions,\nif any, are noted in the documentation for each method.\nUse the Kind method to find out the kind of value before\ncalling kind-specific methods. Calling a method\ninappropriate to the kind of type causes a run time panic.\n\nThe zero Value represents no value.\nIts IsValid method returns false, its Kind method returns Invalid,\nits String method returns \"<invalid Value>\", and all other methods panic.\nMost functions and methods never return an invalid value.\nIf one does, its documentation states the conditions explicitly.\n\nA Value can be used concurrently by multiple goroutines provided that\nthe underlying Go value can be used concurrently for the equivalent\ndirect operations.\n\nTo compare two Values, compare the results of the Interface method.\nUsing == on two Values does not compare the underlying values\nthey represent.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Value"}
  Value)

JOKER TYPE go.std.reflect/ValueError:
(def
  ^{:doc "A ValueError occurs when a Value method is invoked on\na Value that does not support it. Such cases are documented\nin the description of each method.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ValueError"}
  ValueError)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["reflect"]
    :doc "Provides a low-level interface to the reflect package.\n\nPackage reflect implements run-time reflection, allowing a program to\nmanipulate objects with arbitrary types. The typical use is to take a value\nwith static type interface{} and extract its dynamic type information by\ncalling TypeOf, which returns a Type.\n\nA call to ValueOf returns a Value representing the run-time data.\nZero takes a Type and returns a Value representing a zero value\nfor that type.\n\nSee \"The Laws of Reflection\" for an introduction to reflection in Go:\nhttps://golang.org/doc/articles/laws_of_reflection.html\n"
    :empty false}
  go.std.reflect)
JOKER TYPE regexp.Regexp from regexp/regexp.go:
(defn ^"GoObject" Regexp.
  "Constructor for regexp.Regexp"
  {:added "1.0"
   :go "_ConstructRegexp(_v)"}
  [^Object _v])

JOKER FUNC regexp.Compile from regexp/regexp.go:
(defn Compile
  "Compile parses a regular expression and returns, if successful,\na Regexp object that can be used to match against text.\n\nWhen matching against text, the regexp returns a match that\nbegins as early as possible in the input (leftmost), and among those\nit chooses the one that a backtracking search would have found first.\nThis so-called leftmost-first matching is the same semantics\nthat Perl, Python, and other implementations use, although this\npackage implements it without the expense of backtracking.\nFor POSIX leftmost-longest matching, see CompilePOSIX.\n\nGo input arguments: (expr string)\n\nGo return type: (*Regexp, error)\n\nJoker input arguments: [^String expr]\n\nJoker return type: [(atom-of go.std.regexp/Regexp) Error]"
  {:added "1.0"
   :go "__compile(__expr)"}
  [^String __expr])

JOKER FUNC regexp.CompilePOSIX from regexp/regexp.go:
(defn CompilePOSIX
  "CompilePOSIX is like Compile but restricts the regular expression\nto POSIX ERE (egrep) syntax and changes the match semantics to\nleftmost-longest.\n\nThat is, when matching against text, the regexp returns a match that\nbegins as early as possible in the input (leftmost), and among those\nit chooses a match that is as long as possible.\nThis so-called leftmost-longest matching is the same semantics\nthat early regular expression implementations used and that POSIX\nspecifies.\n\nHowever, there can be multiple leftmost-longest matches, with different\nsubmatch choices, and here this package diverges from POSIX.\nAmong the possible leftmost-longest matches, this package chooses\nthe one that a backtracking search would have found first, while POSIX\nspecifies that the match be chosen to maximize the length of the first\nsubexpression, then the second, and so on from left to right.\nThe POSIX rule is computationally prohibitive and not even well-defined.\nSee https://swtch.com/~rsc/regexp/regexp2.html#posix for details.\n\nGo input arguments: (expr string)\n\nGo return type: (*Regexp, error)\n\nJoker input arguments: [^String expr]\n\nJoker return type: [(atom-of go.std.regexp/Regexp) Error]"
  {:added "1.0"
   :go "__compilePOSIX(__expr)"}
  [^String __expr])

JOKER FUNC regexp.Match from regexp/regexp.go:
;; (defn Match
;;   "Match reports whether the byte slice b\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\n\nGo input arguments: (pattern string, b []byte)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^(vector-of Int) b]\n\nJoker return type: [Boolean Error]"
;;   {:added "1.0"
;;    :go "__match(__pattern, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))"}
;;   [^String __pattern, ^Object __b])

JOKER FUNC regexp.MatchReader from regexp/regexp.go:
;; (defn MatchReader
;;   "MatchReader reports whether the text returned by the RuneReader\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\n\nGo input arguments: (pattern string, r io.RuneReader)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^go.std.io/RuneReader r]\n\nJoker return type: [Boolean Error]"
;;   {:added "1.0"
;;    :go "__matchReader(__pattern, *__r)"}
;;   [^String __pattern, ^io/RuneReader __r])

JOKER FUNC regexp.MatchString from regexp/regexp.go:
(defn MatchString
  "MatchString reports whether the string s\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\n\nGo input arguments: (pattern string, s string)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^String s]\n\nJoker return type: [Boolean Error]"
  {:added "1.0"
   :go "__matchString(__pattern, __s)"}
  [^String __pattern, ^String __s])

JOKER FUNC regexp.MustCompile from regexp/regexp.go:
(defn MustCompile
  "MustCompile is like Compile but panics if the expression cannot be parsed.\nIt simplifies safe initialization of global variables holding compiled regular\nexpressions.\n\nGo input arguments: (str string)\n\nGo return type: *Regexp\n\nJoker input arguments: [^String str]\n\nJoker return type: (atom-of go.std.regexp/Regexp)"
  {:added "1.0"
   :go "__mustCompile(__str)"}
  [^String __str])

JOKER FUNC regexp.MustCompilePOSIX from regexp/regexp.go:
(defn MustCompilePOSIX
  "MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed.\nIt simplifies safe initialization of global variables holding compiled regular\nexpressions.\n\nGo input arguments: (str string)\n\nGo return type: *Regexp\n\nJoker input arguments: [^String str]\n\nJoker return type: (atom-of go.std.regexp/Regexp)"
  {:added "1.0"
   :go "__mustCompilePOSIX(__str)"}
  [^String __str])

JOKER FUNC regexp.QuoteMeta from regexp/regexp.go:
(defn ^"String" QuoteMeta
  "QuoteMeta returns a string that escapes all regular expression metacharacters\ninside the argument text; the returned string is a regular expression matching\nthe literal text.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "regexp.QuoteMeta(__s)"}
  [^String __s])

JOKER TYPE go.std.regexp/Regexp:
(def
  ^{:doc "Regexp is the representation of a compiled regular expression.\nA Regexp is safe for concurrent use by multiple goroutines,\nexcept for configuration methods, such as Longest.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Regexp"}
  Regexp)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["regexp"]
    :doc "Provides a low-level interface to the regexp package.\n\nPackage regexp implements regular expression search.\n\nThe syntax of the regular expressions accepted is the same\ngeneral syntax used by Perl, Python, and other languages.\nMore precisely, it is the syntax accepted by RE2 and described at\nhttps://golang.org/s/re2syntax, except for \\C.\nFor an overview of the syntax, run\n  go doc regexp/syntax\n\nThe regexp implementation provided by this package is\nguaranteed to run in time linear in the size of the input.\n(This is a property not guaranteed by most open source\nimplementations of regular expressions.) For more information\nabout this property, see\n\thttps://swtch.com/~rsc/regexp/regexp1.html\nor any book about automata theory.\n\nAll characters are UTF-8-encoded code points.\n\nThere are 16 methods of Regexp that match a regular expression and identify\nthe matched text. Their names are matched by this regular expression:\n\n\tFind(All)?(String)?(Submatch)?(Index)?\n\nIf 'All' is present, the routine matches successive non-overlapping\nmatches of the entire expression. Empty matches abutting a preceding\nmatch are ignored. The return value is a slice containing the successive\nreturn values of the corresponding non-'All' routine. These routines take\nan extra integer argument, n. If n >= 0, the function returns at most n\nmatches/submatches; otherwise, it returns all of them.\n\nIf 'String' is present, the argument is a string; otherwise it is a slice\nof bytes; return values are adjusted as appropriate.\n\nIf 'Submatch' is present, the return value is a slice identifying the\nsuccessive submatches of the expression. Submatches are matches of\nparenthesized subexpressions (also known as capturing groups) within the\nregular expression, numbered from left to right in order of opening\nparenthesis. Submatch 0 is the match of the entire expression, submatch 1\nthe match of the first parenthesized subexpression, and so on.\n\nIf 'Index' is present, matches and submatches are identified by byte index\npairs within the input string: result[2*n:2*n+1] identifies the indexes of\nthe nth submatch. The pair for n==0 identifies the match of the entire\nexpression. If 'Index' is not present, the match is identified by the\ntext of the match/submatch. If an index is negative, it means that\nsubexpression did not match any string in the input.\n\nThere is also a subset of the methods that can be applied to text read\nfrom a RuneReader:\n\n\tMatchReader, FindReaderIndex, FindReaderSubmatchIndex\n\nThis set may grow. Note that regular expression matches may need to\nexamine text beyond the text returned by a match, so the methods that\nmatch text from a RuneReader may read arbitrarily far into the input\nbefore returning.\n\n(There are a few other methods that do not match this pattern.)\n"
    :empty false}
  go.std.regexp)
JOKER CONSTANT ClassNL from regexp/syntax/parse.go:
(def
  ^{:doc "allow character classes like [^a-z] and [[:space:]] to match newline\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(syntax.ClassNL))"}
  ClassNL)

JOKER CONSTANT DotNL from regexp/syntax/parse.go:
(def
  ^{:doc "allow . to match newline\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(syntax.DotNL))"}
  DotNL)

JOKER CONSTANT EmptyBeginLine from regexp/syntax/prog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.EmptyBeginLine))"}
  EmptyBeginLine)

JOKER CONSTANT EmptyBeginText from regexp/syntax/prog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.EmptyBeginText))"}
  EmptyBeginText)

JOKER CONSTANT EmptyEndLine from regexp/syntax/prog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.EmptyEndLine))"}
  EmptyEndLine)

JOKER CONSTANT EmptyEndText from regexp/syntax/prog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.EmptyEndText))"}
  EmptyEndText)

JOKER CONSTANT EmptyNoWordBoundary from regexp/syntax/prog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.EmptyNoWordBoundary))"}
  EmptyNoWordBoundary)

JOKER CONSTANT EmptyWordBoundary from regexp/syntax/prog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.EmptyWordBoundary))"}
  EmptyWordBoundary)

JOKER CONSTANT ErrInternalError from regexp/syntax/parse.go:
(def
  ^{:doc "Unexpected error\n"
    :added "1.0"
    :tag "String"
    :go "string(syntax.ErrInternalError)"}
  ErrInternalError)

JOKER CONSTANT ErrInvalidCharClass from regexp/syntax/parse.go:
(def
  ^{:doc "Parse errors\n"
    :added "1.0"
    :tag "String"
    :go "string(syntax.ErrInvalidCharClass)"}
  ErrInvalidCharClass)

JOKER CONSTANT ErrInvalidCharRange from regexp/syntax/parse.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "String"
    :go "string(syntax.ErrInvalidCharRange)"}
  ErrInvalidCharRange)

JOKER CONSTANT ErrInvalidEscape from regexp/syntax/parse.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "String"
    :go "string(syntax.ErrInvalidEscape)"}
  ErrInvalidEscape)

JOKER CONSTANT ErrInvalidNamedCapture from regexp/syntax/parse.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "String"
    :go "string(syntax.ErrInvalidNamedCapture)"}
  ErrInvalidNamedCapture)

JOKER CONSTANT ErrInvalidPerlOp from regexp/syntax/parse.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "String"
    :go "string(syntax.ErrInvalidPerlOp)"}
  ErrInvalidPerlOp)

JOKER CONSTANT ErrInvalidRepeatOp from regexp/syntax/parse.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "String"
    :go "string(syntax.ErrInvalidRepeatOp)"}
  ErrInvalidRepeatOp)

JOKER CONSTANT ErrInvalidRepeatSize from regexp/syntax/parse.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "String"
    :go "string(syntax.ErrInvalidRepeatSize)"}
  ErrInvalidRepeatSize)

JOKER CONSTANT ErrInvalidUTF8 from regexp/syntax/parse.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "String"
    :go "string(syntax.ErrInvalidUTF8)"}
  ErrInvalidUTF8)

JOKER CONSTANT ErrMissingBracket from regexp/syntax/parse.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "String"
    :go "string(syntax.ErrMissingBracket)"}
  ErrMissingBracket)

JOKER CONSTANT ErrMissingParen from regexp/syntax/parse.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "String"
    :go "string(syntax.ErrMissingParen)"}
  ErrMissingParen)

JOKER CONSTANT ErrMissingRepeatArgument from regexp/syntax/parse.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "String"
    :go "string(syntax.ErrMissingRepeatArgument)"}
  ErrMissingRepeatArgument)

JOKER CONSTANT ErrTrailingBackslash from regexp/syntax/parse.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "String"
    :go "string(syntax.ErrTrailingBackslash)"}
  ErrTrailingBackslash)

JOKER CONSTANT ErrUnexpectedParen from regexp/syntax/parse.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "String"
    :go "string(syntax.ErrUnexpectedParen)"}
  ErrUnexpectedParen)

JOKER CONSTANT FoldCase from regexp/syntax/parse.go:
(def
  ^{:doc "case-insensitive match\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(syntax.FoldCase))"}
  FoldCase)

JOKER CONSTANT InstAlt from regexp/syntax/prog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.InstAlt))"}
  InstAlt)

JOKER CONSTANT InstAltMatch from regexp/syntax/prog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.InstAltMatch))"}
  InstAltMatch)

JOKER CONSTANT InstCapture from regexp/syntax/prog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.InstCapture))"}
  InstCapture)

JOKER CONSTANT InstEmptyWidth from regexp/syntax/prog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.InstEmptyWidth))"}
  InstEmptyWidth)

JOKER CONSTANT InstFail from regexp/syntax/prog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.InstFail))"}
  InstFail)

JOKER CONSTANT InstMatch from regexp/syntax/prog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.InstMatch))"}
  InstMatch)

JOKER CONSTANT InstNop from regexp/syntax/prog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.InstNop))"}
  InstNop)

JOKER CONSTANT InstRune from regexp/syntax/prog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.InstRune))"}
  InstRune)

JOKER CONSTANT InstRune1 from regexp/syntax/prog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.InstRune1))"}
  InstRune1)

JOKER CONSTANT InstRuneAny from regexp/syntax/prog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.InstRuneAny))"}
  InstRuneAny)

JOKER CONSTANT InstRuneAnyNotNL from regexp/syntax/prog.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.InstRuneAnyNotNL))"}
  InstRuneAnyNotNL)

JOKER CONSTANT Literal from regexp/syntax/parse.go:
(def
  ^{:doc "treat pattern as literal string\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(syntax.Literal))"}
  Literal)

JOKER CONSTANT MatchNL from regexp/syntax/parse.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(uint16(syntax.MatchNL))"}
  MatchNL)

JOKER CONSTANT NonGreedy from regexp/syntax/parse.go:
(def
  ^{:doc "make repetition operators default to non-greedy\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(syntax.NonGreedy))"}
  NonGreedy)

JOKER CONSTANT OneLine from regexp/syntax/parse.go:
(def
  ^{:doc "treat ^ and $ as only matching at beginning and end of text\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(syntax.OneLine))"}
  OneLine)

JOKER CONSTANT OpAlternate from regexp/syntax/regexp.go:
(def
  ^{:doc "matches alternation of Subs\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.OpAlternate))"}
  OpAlternate)

JOKER CONSTANT OpAnyChar from regexp/syntax/regexp.go:
(def
  ^{:doc "matches any character\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.OpAnyChar))"}
  OpAnyChar)

JOKER CONSTANT OpAnyCharNotNL from regexp/syntax/regexp.go:
(def
  ^{:doc "matches any character except newline\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.OpAnyCharNotNL))"}
  OpAnyCharNotNL)

JOKER CONSTANT OpBeginLine from regexp/syntax/regexp.go:
(def
  ^{:doc "matches empty string at beginning of line\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.OpBeginLine))"}
  OpBeginLine)

JOKER CONSTANT OpBeginText from regexp/syntax/regexp.go:
(def
  ^{:doc "matches empty string at beginning of text\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.OpBeginText))"}
  OpBeginText)

JOKER CONSTANT OpCapture from regexp/syntax/regexp.go:
(def
  ^{:doc "capturing subexpression with index Cap, optional name Name\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.OpCapture))"}
  OpCapture)

JOKER CONSTANT OpCharClass from regexp/syntax/regexp.go:
(def
  ^{:doc "matches Runes interpreted as range pair list\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.OpCharClass))"}
  OpCharClass)

JOKER CONSTANT OpConcat from regexp/syntax/regexp.go:
(def
  ^{:doc "matches concatenation of Subs\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.OpConcat))"}
  OpConcat)

JOKER CONSTANT OpEmptyMatch from regexp/syntax/regexp.go:
(def
  ^{:doc "matches empty string\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.OpEmptyMatch))"}
  OpEmptyMatch)

JOKER CONSTANT OpEndLine from regexp/syntax/regexp.go:
(def
  ^{:doc "matches empty string at end of line\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.OpEndLine))"}
  OpEndLine)

JOKER CONSTANT OpEndText from regexp/syntax/regexp.go:
(def
  ^{:doc "matches empty string at end of text\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.OpEndText))"}
  OpEndText)

JOKER CONSTANT OpLiteral from regexp/syntax/regexp.go:
(def
  ^{:doc "matches Runes sequence\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.OpLiteral))"}
  OpLiteral)

JOKER CONSTANT OpNoMatch from regexp/syntax/regexp.go:
(def
  ^{:doc "matches no strings\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.OpNoMatch))"}
  OpNoMatch)

JOKER CONSTANT OpNoWordBoundary from regexp/syntax/regexp.go:
(def
  ^{:doc "matches word non-boundary `\\B`\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.OpNoWordBoundary))"}
  OpNoWordBoundary)

JOKER CONSTANT OpPlus from regexp/syntax/regexp.go:
(def
  ^{:doc "matches Sub[0] one or more times\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.OpPlus))"}
  OpPlus)

JOKER CONSTANT OpQuest from regexp/syntax/regexp.go:
(def
  ^{:doc "matches Sub[0] zero or one times\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.OpQuest))"}
  OpQuest)

JOKER CONSTANT OpRepeat from regexp/syntax/regexp.go:
(def
  ^{:doc "matches Sub[0] at least Min times, at most Max (Max == -1 is no limit)\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.OpRepeat))"}
  OpRepeat)

JOKER CONSTANT OpStar from regexp/syntax/regexp.go:
(def
  ^{:doc "matches Sub[0] zero or more times\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.OpStar))"}
  OpStar)

JOKER CONSTANT OpWordBoundary from regexp/syntax/regexp.go:
(def
  ^{:doc "matches word boundary `\\b`\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint8(syntax.OpWordBoundary))"}
  OpWordBoundary)

JOKER CONSTANT POSIX from regexp/syntax/parse.go:
(def
  ^{:doc "POSIX syntax\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(syntax.POSIX))"}
  POSIX)

JOKER CONSTANT Perl from regexp/syntax/parse.go:
(def
  ^{:doc "as close to Perl as possible\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(syntax.Perl))"}
  Perl)

JOKER CONSTANT PerlX from regexp/syntax/parse.go:
(def
  ^{:doc "allow Perl extensions\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(syntax.PerlX))"}
  PerlX)

JOKER CONSTANT Simple from regexp/syntax/parse.go:
(def
  ^{:doc "regexp contains no counted repetition\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(syntax.Simple))"}
  Simple)

JOKER CONSTANT UnicodeGroups from regexp/syntax/parse.go:
(def
  ^{:doc "allow \\p{Han}, \\P{Han} for Unicode group and negation\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(syntax.UnicodeGroups))"}
  UnicodeGroups)

JOKER CONSTANT WasDollar from regexp/syntax/parse.go:
(def
  ^{:doc "regexp OpEndText was $, not \\z\n"
    :added "1.0"
    :tag "Int"
    :go "int(uint16(syntax.WasDollar))"}
  WasDollar)

JOKER TYPE regexp/syntax.EmptyOp from regexp/syntax/prog.go:
(defn ^"GoObject" EmptyOp.
  "Constructor for syntax.EmptyOp"
  {:added "1.0"
   :go "_ConstructEmptyOp(_v)"}
  [^Object _v])

JOKER TYPE regexp/syntax.Error from regexp/syntax/parse.go:
(defn ^"GoObject" Error.
  "Constructor for syntax.Error"
  {:added "1.0"
   :go "_ConstructError(_v)"}
  [^Object _v])

JOKER TYPE regexp/syntax.ErrorCode from regexp/syntax/parse.go:
(defn ^"GoObject" ErrorCode.
  "Constructor for syntax.ErrorCode"
  {:added "1.0"
   :go "_ConstructErrorCode(_v)"}
  [^Object _v])

JOKER TYPE regexp/syntax.Flags from regexp/syntax/parse.go:
(defn ^"GoObject" Flags.
  "Constructor for syntax.Flags"
  {:added "1.0"
   :go "_ConstructFlags(_v)"}
  [^Object _v])

JOKER TYPE regexp/syntax.Inst from regexp/syntax/prog.go:
;; (defn ^"GoObject" Inst.
;;   "Constructor for syntax.Inst"
;;   {:added "1.0"
;;    :go "_ConstructInst(_v)"}
;;   [^Object _v])

JOKER TYPE regexp/syntax.InstOp from regexp/syntax/prog.go:
(defn ^"GoObject" InstOp.
  "Constructor for syntax.InstOp"
  {:added "1.0"
   :go "_ConstructInstOp(_v)"}
  [^Object _v])

JOKER TYPE regexp/syntax.Op from regexp/syntax/regexp.go:
(defn ^"GoObject" Op.
  "Constructor for syntax.Op"
  {:added "1.0"
   :go "_ConstructOp(_v)"}
  [^Object _v])

JOKER TYPE regexp/syntax.Prog from regexp/syntax/prog.go:
;; (defn ^"GoObject" Prog.
;;   "Constructor for syntax.Prog"
;;   {:added "1.0"
;;    :go "_ConstructProg(_v)"}
;;   [^Object _v])

JOKER TYPE regexp/syntax.Regexp from regexp/syntax/regexp.go:
;; (defn ^"GoObject" Regexp.
;;   "Constructor for syntax.Regexp"
;;   {:added "1.0"
;;    :go "_ConstructRegexp(_v)"}
;;   [^Object _v])

JOKER FUNC regexp/syntax.Compile from regexp/syntax/compile.go:
(defn Compile
  "Compile compiles the regexp into a program to be executed.\nThe regexp should have been simplified already (returned from re.Simplify).\n\nGo input arguments: (re *Regexp)\n\nGo return type: (*Prog, error)\n\nJoker input arguments: [^(atom-of go.std.regexp.syntax/Regexp) re]\n\nJoker return type: [(atom-of go.std.regexp.syntax/Prog) Error]"
  {:added "1.0"
   :go "__compile(__re)"}
  [^syntax/Regexp __re])

JOKER FUNC regexp/syntax.EmptyOpContext from regexp/syntax/prog.go:
(defn EmptyOpContext
  "EmptyOpContext returns the zero-width assertions\nsatisfied at the position between the runes r1 and r2.\nPassing r1 == -1 indicates that the position is\nat the beginning of the text.\nPassing r2 == -1 indicates that the position is\nat the end of the text.\n\nGo input arguments: (r1 rune, r2 rune)\n\nGo return type: EmptyOp\n\nJoker input arguments: [^Char r1, ^Char r2]\n\nJoker return type: go.std.regexp.syntax/EmptyOp"
  {:added "1.0"
   :go "__emptyOpContext(__r1, __r2)"}
  [^Char __r1, ^Char __r2])

JOKER FUNC regexp/syntax.IsWordChar from regexp/syntax/prog.go:
(defn ^"Boolean" IsWordChar
  "IsWordChar reports whether r is consider a ``word character''\nduring the evaluation of the \\b and \\B zero-width assertions.\nThese assertions are ASCII-only: the word characters are [A-Za-z0-9_].\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "syntax.IsWordChar(__r)"}
  [^Char __r])

JOKER FUNC regexp/syntax.Parse from regexp/syntax/parse.go:
(defn Parse
  "Parse parses a regular expression string s, controlled by the specified\nFlags, and returns a regular expression parse tree. The syntax is\ndescribed in the top-level comment.\n\nGo input arguments: (s string, flags Flags)\n\nGo return type: (*Regexp, error)\n\nJoker input arguments: [^String s, ^go.std.regexp.syntax/Flags flags]\n\nJoker return type: [(atom-of go.std.regexp.syntax/Regexp) Error]"
  {:added "1.0"
   :go "__parse(__s, *__flags)"}
  [^String __s, ^syntax/Flags __flags])

JOKER TYPE go.std.regexp.syntax/EmptyOp:
(def
  ^{:doc "An EmptyOp specifies a kind or mixture of zero-width assertions.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_EmptyOp"}
  EmptyOp)

JOKER TYPE go.std.regexp.syntax/Error:
(def
  ^{:doc "An Error describes a failure to parse a regular expression\nand gives the offending expression.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Error"}
  Error)

JOKER TYPE go.std.regexp.syntax/ErrorCode:
(def
  ^{:doc "An ErrorCode describes a failure to parse a regular expression.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ErrorCode"}
  ErrorCode)

JOKER TYPE go.std.regexp.syntax/Flags:
(def
  ^{:doc "Flags control the behavior of the parser and record information about regexp context.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Flags"}
  Flags)

JOKER TYPE go.std.regexp.syntax/Inst:
(def
  ^{:doc "An Inst is a single instruction in a regular expression program.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Inst"}
  Inst)

JOKER TYPE go.std.regexp.syntax/InstOp:
(def
  ^{:doc "An InstOp is an instruction opcode.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_InstOp"}
  InstOp)

JOKER TYPE go.std.regexp.syntax/Op:
(def
  ^{:doc "An Op is a single regular expression operator.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Op"}
  Op)

JOKER TYPE go.std.regexp.syntax/Prog:
(def
  ^{:doc "A Prog is a compiled regular expression program.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Prog"}
  Prog)

JOKER TYPE go.std.regexp.syntax/Regexp:
(def
  ^{:doc "A Regexp is a node in a regular expression syntax tree.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Regexp"}
  Regexp)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["regexp/syntax"]
    :doc "Provides a low-level interface to the regexp/syntax package.\n\nPackage syntax parses regular expressions into parse trees and compiles\nparse trees into programs. Most clients of regular expressions will use the\nfacilities of package regexp (such as Compile and Match) instead of this package.\n\nSyntax\n\nThe regular expression syntax understood by this package when parsing with the Perl flag is as follows.\nParts of the syntax can be disabled by passing alternate flags to Parse.\n\nSingle characters:\n  .              any character, possibly including newline (flag s=true)\n  [xyz]          character class\n  [^xyz]         negated character class\n  \\d             Perl character class\n  \\D             negated Perl character class\n  [[:alpha:]]    ASCII character class\n  [[:^alpha:]]   negated ASCII character class\n  \\pN            Unicode character class (one-letter name)\n  \\p{Greek}      Unicode character class\n  \\PN            negated Unicode character class (one-letter name)\n  \\P{Greek}      negated Unicode character class\n\nComposites:\n  xy             x followed by y\n  x|y            x or y (prefer x)\n\nRepetitions:\n  x*             zero or more x, prefer more\n  x+             one or more x, prefer more\n  x?             zero or one x, prefer one\n  x{n,m}         n or n+1 or ... or m x, prefer more\n  x{n,}          n or more x, prefer more\n  x{n}           exactly n x\n  x*?            zero or more x, prefer fewer\n  x+?            one or more x, prefer fewer\n  x??            zero or one x, prefer zero\n  x{n,m}?        n or n+1 or ... or m x, prefer fewer\n  x{n,}?         n or more x, prefer fewer\n  x{n}?          exactly n x\n\nImplementation restriction: The counting forms x{n,m}, x{n,}, and x{n}\nreject forms that create a minimum or maximum repetition count above 1000.\nUnlimited repetitions are not subject to this restriction.\n\nGrouping:\n  (re)           numbered capturing group (submatch)\n  (?P<name>re)   named & numbered capturing group (submatch)\n  (?:re)         non-capturing group\n  (?flags)       set flags within current group; non-capturing\n  (?flags:re)    set flags during re; non-capturing\n\n  Flag syntax is xyz (set) or -xyz (clear) or xy-z (set xy, clear z). The flags are:\n\n  i              case-insensitive (default false)\n  m              multi-line mode: ^ and $ match begin/end line in addition to begin/end text (default false)\n  s              let . match \\n (default false)\n  U              ungreedy: swap meaning of x* and x*?, x+ and x+?, etc (default false)\n\nEmpty strings:\n  ^              at beginning of text or line (flag m=true)\n  $              at end of text (like \\z not Perl's \\Z) or line (flag m=true)\n  \\A             at beginning of text\n  \\b             at ASCII word boundary (\\w on one side and \\W, \\A, or \\z on the other)\n  \\B             not at ASCII word boundary\n  \\z             at end of text\n\nEscape sequences:\n  \\a             bell (== \\007)\n  \\f             form feed (== \\014)\n  \\t             horizontal tab (== \\011)\n  \\n             newline (== \\012)\n  \\r             carriage return (== \\015)\n  \\v             vertical tab character (== \\013)\n  \\*             literal *, for any punctuation character *\n  \\123           octal character code (up to three digits)\n  \\x7F           hex character code (exactly two digits)\n  \\x{10FFFF}     hex character code\n  \\Q...\\E        literal text ... even if ... has punctuation\n\nCharacter class elements:\n  x              single character\n  A-Z            character range (inclusive)\n  \\d             Perl character class\n  [:foo:]        ASCII character class foo\n  \\p{Foo}        Unicode character class Foo\n  \\pF            Unicode character class F (one-letter name)\n\nNamed character classes as character class elements:\n  [\\d]           digits (== \\d)\n  [^\\d]          not digits (== \\D)\n  [\\D]           not digits (== \\D)\n  [^\\D]          not not digits (== \\d)\n  [[:name:]]     named ASCII class inside character class (== [:name:])\n  [^[:name:]]    named ASCII class inside negated character class (== [:^name:])\n  [\\p{Name}]     named Unicode property inside character class (== \\p{Name})\n  [^\\p{Name}]    named Unicode property inside negated character class (== \\P{Name})\n\nPerl character classes (all ASCII-only):\n  \\d             digits (== [0-9])\n  \\D             not digits (== [^0-9])\n  \\s             whitespace (== [\\t\\n\\f\\r ])\n  \\S             not whitespace (== [^\\t\\n\\f\\r ])\n  \\w             word characters (== [0-9A-Za-z_])\n  \\W             not word characters (== [^0-9A-Za-z_])\n\nASCII character classes:\n  [[:alnum:]]    alphanumeric (== [0-9A-Za-z])\n  [[:alpha:]]    alphabetic (== [A-Za-z])\n  [[:ascii:]]    ASCII (== [\\x00-\\x7F])\n  [[:blank:]]    blank (== [\\t ])\n  [[:cntrl:]]    control (== [\\x00-\\x1F\\x7F])\n  [[:digit:]]    digits (== [0-9])\n  [[:graph:]]    graphical (== [!-~] == [A-Za-z0-9!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~])\n  [[:lower:]]    lower case (== [a-z])\n  [[:print:]]    printable (== [ -~] == [ [:graph:]])\n  [[:punct:]]    punctuation (== [!-/:-@[-`{-~])\n  [[:space:]]    whitespace (== [\\t\\n\\v\\f\\r ])\n  [[:upper:]]    upper case (== [A-Z])\n  [[:word:]]     word characters (== [0-9A-Za-z_])\n  [[:xdigit:]]   hex digit (== [0-9A-Fa-f])\n"
    :empty false}
  go.std.regexp.syntax)
JOKER CONSTANT Compiler from runtime/compiler.go:
(def
  ^{:doc "Compiler is the name of the compiler toolchain that built the\nrunning binary. Known toolchains are:\n\n\tgc      Also known as cmd/compile.\n\tgccgo   The gccgo front end, part of the GCC compiler suite.\n"
    :added "1.0"
    :tag "String"
    :go "runtime.Compiler"}
  Compiler)

JOKER CONSTANT GOARCH from runtime/extern.go:
(def
  ^{:doc "GOARCH is the running program's architecture target:\none of 386, amd64, arm, s390x, and so on.\n"
    :added "1.0"
    :tag "String"
    :go "runtime.GOARCH"}
  GOARCH)

JOKER CONSTANT GOOS from runtime/extern.go:
(def
  ^{:doc "GOOS is the running program's operating system target:\none of darwin, freebsd, linux, and so on.\nTo view possible combinations of GOOS and GOARCH, run \"go tool dist list\".\n"
    :added "1.0"
    :tag "String"
    :go "runtime.GOOS"}
  GOOS)

JOKER VARIABLE MemProfileRate from runtime/mprof.go:
(def
  ^{:doc "MemProfileRate controls the fraction of memory allocations\nthat are recorded and reported in the memory profile.\nThe profiler aims to sample an average of\none allocation per MemProfileRate bytes allocated.\n\nTo include every allocated block in the profile, set MemProfileRate to 1.\nTo turn off profiling entirely, set MemProfileRate to 0.\n\nThe tools that process the memory profiles assume that the\nprofile rate is constant across the lifetime of the program\nand equal to the current value. Programs that change the\nmemory profiling rate should do so just once, as early as\npossible in the execution of the program (for example,\nat the beginning of main).\n"
    :added "1.0"
    :tag "Var"
    :go "runtime.MemProfileRate"}
  MemProfileRate)

JOKER TYPE runtime.BlockProfileRecord from runtime/mprof.go:
(defn ^"GoObject" BlockProfileRecord.
  "Constructor for runtime.BlockProfileRecord"
  {:added "1.0"
   :go "_ConstructBlockProfileRecord(_v)"}
  [^Object _v])

JOKER TYPE runtime.Error from runtime/error.go:
;; (defn ^"GoObject" Error.
;;   "Constructor for runtime.Error"
;;   {:added "1.0"
;;    :go "_ConstructError(_v)"}
;;   [^Object _v])

JOKER TYPE runtime.Frame from runtime/symtab.go:
;; (defn ^"GoObject" Frame.
;;   "Constructor for runtime.Frame"
;;   {:added "1.0"
;;    :go "_ConstructFrame(_v)"}
;;   [^Object _v])

JOKER TYPE runtime.Frames from runtime/symtab.go:
(defn ^"GoObject" Frames.
  "Constructor for runtime.Frames"
  {:added "1.0"
   :go "_ConstructFrames(_v)"}
  [^Object _v])

JOKER TYPE runtime.Func from runtime/symtab.go:
(defn ^"GoObject" Func.
  "Constructor for runtime.Func"
  {:added "1.0"
   :go "_ConstructFunc(_v)"}
  [^Object _v])

JOKER TYPE runtime.MemProfileRecord from runtime/mprof.go:
;; (defn ^"GoObject" MemProfileRecord.
;;   "Constructor for runtime.MemProfileRecord"
;;   {:added "1.0"
;;    :go "_ConstructMemProfileRecord(_v)"}
;;   [^Object _v])

JOKER TYPE runtime.MemStats from runtime/mstats.go:
;; (defn ^"GoObject" MemStats.
;;   "Constructor for runtime.MemStats"
;;   {:added "1.0"
;;    :go "_ConstructMemStats(_v)"}
;;   [^Object _v])

JOKER TYPE runtime.StackRecord from runtime/mprof.go:
;; (defn ^"GoObject" StackRecord.
;;   "Constructor for runtime.StackRecord"
;;   {:added "1.0"
;;    :go "_ConstructStackRecord(_v)"}
;;   [^Object _v])

JOKER TYPE runtime.TypeAssertionError from runtime/error.go:
(defn ^"GoObject" TypeAssertionError.
  "Constructor for runtime.TypeAssertionError"
  {:added "1.0"
   :go "_ConstructTypeAssertionError(_v)"}
  [^Object _v])

JOKER FUNC runtime.BlockProfile from runtime/mprof.go:
;; (defn BlockProfile
;;   "BlockProfile returns n, the number of records in the current blocking profile.\nIf len(p) >= n, BlockProfile copies the profile into p and returns n, true.\nIf len(p) < n, BlockProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.blockprofile flag instead\nof calling BlockProfile directly.\n\nGo input arguments: (p []BlockProfileRecord)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of go.std.runtime/BlockProfileRecord) p]\n\nJoker return type: [Int Boolean]"
;;   {:added "1.0"
;;    :go "__blockProfile(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_runtime.BlockProfileRecord(*__p)))"}
;;   [^Object __p])

JOKER FUNC runtime.Breakpoint from runtime/proc.go:
;; (defn Breakpoint
;;   "Breakpoint executes a breakpoint trap.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__breakpoint()"}
;;   [])

JOKER FUNC runtime.CPUProfile from runtime/cpuprof.go:
(defn CPUProfile
  "CPUProfile panics.\nIt formerly provided raw access to chunks of\na pprof-format profile generated by the runtime.\nThe details of generating that format have changed,\nso this functionality has been removed.\n\nDeprecated: use the runtime/pprof package,\nor the handlers in the net/http/pprof package,\nor the testing package's -test.cpuprofile flag instead.\n\nGo return type: []byte\n\nJoker input arguments: []\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__cPUProfile()"}
  [])

JOKER FUNC runtime.Caller from runtime/extern.go:
;; (defn Caller
;;   "Caller reports file and line number information about function invocations on\nthe calling goroutine's stack. The argument skip is the number of stack frames\nto ascend, with 0 identifying the caller of Caller.  (For historical reasons the\nmeaning of skip differs between Caller and Callers.) The return values report the\nprogram counter, file name, and line number within the file of the corresponding\ncall. The boolean ok is false if it was not possible to recover the information.\n\nGo input arguments: (skip int)\n\nGo return type: (pc uintptr, file string, line int, ok bool)\n\nJoker input arguments: [^Int skip]\n\nJoker return type: [Number String Int Boolean]"
;;   {:added "1.0"
;;    :go "__caller(__skip)"}
;;   [^Int __skip])

JOKER FUNC runtime.Callers from runtime/extern.go:
;; (defn ^"Int" Callers
;;   "Callers fills the slice pc with the return program counters of function invocations\non the calling goroutine's stack. The argument skip is the number of stack frames\nto skip before recording in pc, with 0 identifying the frame for Callers itself and\n1 identifying the caller of Callers.\nIt returns the number of entries written to pc.\n\nTo translate these PCs into symbolic information such as function\nnames and line numbers, use CallersFrames. CallersFrames accounts\nfor inlined functions and adjusts the return program counters into\ncall program counters. Iterating over the returned slice of PCs\ndirectly is discouraged, as is using FuncForPC on any of the\nreturned PCs, since these cannot account for inlining or return\nprogram counter adjustment.\ngo:noinline\n\nGo input arguments: (skip int, pc []uintptr)\n\nGo return type: int\n\nJoker input arguments: [^Int skip, ^(vector-of Number) pc]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "runtime.Callers(__skip, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfuintptr(__pc)))"}
;;   [^Int __skip, ^Object __pc])

JOKER FUNC runtime.CallersFrames from runtime/symtab.go:
;; (defn CallersFrames
;;   "CallersFrames takes a slice of PC values returned by Callers and\nprepares to return function/file/line information.\nDo not change the slice until you are done with the Frames.\n\nGo input arguments: (callers []uintptr)\n\nGo return type: *Frames\n\nJoker input arguments: [^(vector-of Number) callers]\n\nJoker return type: (atom-of go.std.runtime/Frames)"
;;   {:added "1.0"
;;    :go "__callersFrames(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfuintptr(__callers)))"}
;;   [^Object __callers])

JOKER FUNC runtime.FuncForPC from runtime/symtab.go:
(defn FuncForPC
  "FuncForPC returns a *Func describing the function that contains the\ngiven program counter address, or else nil.\n\nIf pc represents multiple functions because of inlining, it returns\nthe a *Func describing the innermost function, but with an entry\nof the outermost function.\n\nGo input arguments: (pc uintptr)\n\nGo return type: *Func\n\nJoker input arguments: [^Number pc]\n\nJoker return type: (atom-of go.std.runtime/Func)"
  {:added "1.0"
   :go "__funcForPC(__pc)"}
  [^UIntPtr __pc])

JOKER FUNC runtime.GC from runtime/mgc.go:
;; (defn GC
;;   "GC runs a garbage collection and blocks the caller until the\ngarbage collection is complete. It may also block the entire\nprogram.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__gC()"}
;;   [])

JOKER FUNC runtime.GOMAXPROCS from runtime/debug.go:
(defn ^"Int" GOMAXPROCS
  "GOMAXPROCS sets the maximum number of CPUs that can be executing\nsimultaneously and returns the previous setting. If n < 1, it does not\nchange the current setting.\nThe number of logical CPUs on the local machine can be queried with NumCPU.\nThis call will go away when the scheduler improves.\n\nGo input arguments: (n int)\n\nGo return type: int\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.GOMAXPROCS(__n)"}
  [^Int __n])

JOKER FUNC runtime.GOROOT from runtime/extern.go:
(defn ^"String" GOROOT
  "GOROOT returns the root of the Go tree. It uses the\nGOROOT environment variable, if set at process start,\nor else the root used during the Go build.\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "runtime.GOROOT()"}
  [])

JOKER FUNC runtime.Goexit from runtime/panic.go:
;; (defn Goexit
;;   "Goexit terminates the goroutine that calls it. No other goroutine is affected.\nGoexit runs all deferred calls before terminating the goroutine. Because Goexit\nis not a panic, any recover calls in those deferred functions will return nil.\n\nCalling Goexit from the main goroutine terminates that goroutine\nwithout func main returning. Since func main has not returned,\nthe program continues execution of other goroutines.\nIf all other goroutines exit, the program crashes.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__goexit()"}
;;   [])

JOKER FUNC runtime.GoroutineProfile from runtime/mprof.go:
;; (defn GoroutineProfile
;;   "GoroutineProfile returns n, the number of records in the active goroutine stack profile.\nIf len(p) >= n, GoroutineProfile copies the profile into p and returns n, true.\nIf len(p) < n, GoroutineProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package instead\nof calling GoroutineProfile directly.\n\nGo input arguments: (p []StackRecord)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of go.std.runtime/StackRecord) p]\n\nJoker return type: [Int Boolean]"
;;   {:added "1.0"
;;    :go "__goroutineProfile(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_runtime.StackRecord(*__p)))"}
;;   [^Object __p])

JOKER FUNC runtime.Gosched from runtime/proc.go:
;; (defn Gosched
;;   "Gosched yields the processor, allowing other goroutines to run. It does not\nsuspend the current goroutine, so execution resumes automatically.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__gosched()"}
;;   [])

JOKER FUNC runtime.KeepAlive from runtime/mfinal.go:
;; (defn KeepAlive
;;   "KeepAlive marks its argument as currently reachable.\nThis ensures that the object is not freed, and its finalizer is not run,\nbefore the point in the program where KeepAlive is called.\n\nA very simplified example showing where KeepAlive is required:\n\ttype File struct { d int }\n\td, err := syscall.Open(\"/file/path\", syscall.O_RDONLY, 0)\n\t// ... do something if err != nil ...\n\tp := &File{d}\n\truntime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })\n\tvar buf [10]byte\n\tn, err := syscall.Read(p.d, buf[:])\n\t// Ensure p is not finalized until Read returns.\n\truntime.KeepAlive(p)\n\t// No more uses of p after this point.\n\nWithout the KeepAlive call, the finalizer could run at the start of\nsyscall.Read, closing the file descriptor before syscall.Read makes\nthe actual system call.\n\nGo input arguments: (x interface {})\n\nJoker input arguments: [^<protocol-or-something> x]"
;;   {:added "1.0"
;;    :go "__keepAlive(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> __x])

JOKER FUNC runtime.LockOSThread from runtime/proc.go:
;; (defn LockOSThread
;;   "LockOSThread wires the calling goroutine to its current operating system thread.\nThe calling goroutine will always execute in that thread,\nand no other goroutine will execute in it,\nuntil the calling goroutine has made as many calls to\nUnlockOSThread as to LockOSThread.\nIf the calling goroutine exits without unlocking the thread,\nthe thread will be terminated.\n\nAll init functions are run on the startup thread. Calling LockOSThread\nfrom an init function will cause the main function to be invoked on\nthat thread.\n\nA goroutine should call LockOSThread before calling OS services or\nnon-Go library functions that depend on per-thread state.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__lockOSThread()"}
;;   [])

JOKER FUNC runtime.MemProfile from runtime/mprof.go:
;; (defn MemProfile
;;   "MemProfile returns a profile of memory allocated and freed per allocation\nsite.\n\nMemProfile returns n, the number of records in the current memory profile.\nIf len(p) >= n, MemProfile copies the profile into p and returns n, true.\nIf len(p) < n, MemProfile does not change p and returns n, false.\n\nIf inuseZero is true, the profile includes allocation records\nwhere r.AllocBytes > 0 but r.AllocBytes == r.FreeBytes.\nThese are sites where memory was allocated, but it has all\nbeen released back to the runtime.\n\nThe returned profile may be up to two garbage collection cycles old.\nThis is to avoid skewing the profile toward allocations; because\nallocations happen in real time but frees are delayed until the garbage\ncollector performs sweeping, the profile only accounts for allocations\nthat have had a chance to be freed by the garbage collector.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.memprofile flag instead\nof calling MemProfile directly.\n\nGo input arguments: (p []MemProfileRecord, inuseZero bool)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of go.std.runtime/MemProfileRecord) p, ^Boolean inuseZero]\n\nJoker return type: [Int Boolean]"
;;   {:added "1.0"
;;    :go "__memProfile(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_runtime.MemProfileRecord(*__p)), __inuseZero)"}
;;   [^Object __p, ^Boolean __inuseZero])

JOKER FUNC runtime.MutexProfile from runtime/mprof.go:
;; (defn MutexProfile
;;   "MutexProfile returns n, the number of records in the current mutex profile.\nIf len(p) >= n, MutexProfile copies the profile into p and returns n, true.\nOtherwise, MutexProfile does not change p, and returns n, false.\n\nMost clients should use the runtime/pprof package\ninstead of calling MutexProfile directly.\n\nGo input arguments: (p []BlockProfileRecord)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of go.std.runtime/BlockProfileRecord) p]\n\nJoker return type: [Int Boolean]"
;;   {:added "1.0"
;;    :go "__mutexProfile(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_runtime.BlockProfileRecord(*__p)))"}
;;   [^Object __p])

JOKER FUNC runtime.NumCPU from runtime/debug.go:
(defn ^"Int" NumCPU
  "NumCPU returns the number of logical CPUs usable by the current process.\n\nThe set of available CPUs is checked by querying the operating system\nat process startup. Changes to operating system CPU allocation after\nprocess startup are not reflected.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.NumCPU()"}
  [])

JOKER FUNC runtime.NumCgoCall from runtime/debug.go:
(defn NumCgoCall
  "NumCgoCall returns the number of cgo calls made by the current process.\n\nGo return type: int64\n\nJoker input arguments: []\n\nJoker return type: Number"
  {:added "1.0"
   :go "__numCgoCall()"}
  [])

JOKER FUNC runtime.NumGoroutine from runtime/debug.go:
(defn ^"Int" NumGoroutine
  "NumGoroutine returns the number of goroutines that currently exist.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.NumGoroutine()"}
  [])

JOKER FUNC runtime.ReadMemStats from runtime/mstats.go:
;; (defn ReadMemStats
;;   "ReadMemStats populates m with memory allocator statistics.\n\nThe returned memory allocator statistics are up to date as of the\ncall to ReadMemStats. This is in contrast with a heap profile,\nwhich is a snapshot as of the most recently completed garbage\ncollection cycle.\n\nGo input arguments: (m *MemStats)\n\nJoker input arguments: [^(atom-of go.std.runtime/MemStats) m]"
;;   {:added "1.0"
;;    :go "__readMemStats(__m)"}
;;   [^runtime/MemStats __m])

JOKER FUNC runtime.ReadTrace from runtime/trace.go:
(defn ReadTrace
  "ReadTrace returns the next chunk of binary tracing data, blocking until data\nis available. If tracing is turned off and all the data accumulated while it\nwas on has been returned, ReadTrace returns nil. The caller must copy the\nreturned data before calling ReadTrace again.\nReadTrace must be called from one goroutine at a time.\n\nGo return type: []byte\n\nJoker input arguments: []\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__readTrace()"}
  [])

JOKER FUNC runtime.SetBlockProfileRate from runtime/mprof.go:
;; (defn SetBlockProfileRate
;;   "SetBlockProfileRate controls the fraction of goroutine blocking events\nthat are reported in the blocking profile. The profiler aims to sample\nan average of one blocking event per rate nanoseconds spent blocked.\n\nTo include every blocking event in the profile, pass rate = 1.\nTo turn off profiling entirely, pass rate <= 0.\n\nGo input arguments: (rate int)\n\nJoker input arguments: [^Int rate]"
;;   {:added "1.0"
;;    :go "__setBlockProfileRate(__rate)"}
;;   [^Int __rate])

JOKER FUNC runtime.SetCPUProfileRate from runtime/cpuprof.go:
;; (defn SetCPUProfileRate
;;   "SetCPUProfileRate sets the CPU profiling rate to hz samples per second.\nIf hz <= 0, SetCPUProfileRate turns off profiling.\nIf the profiler is on, the rate cannot be changed without first turning it off.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.cpuprofile flag instead of calling\nSetCPUProfileRate directly.\n\nGo input arguments: (hz int)\n\nJoker input arguments: [^Int hz]"
;;   {:added "1.0"
;;    :go "__setCPUProfileRate(__hz)"}
;;   [^Int __hz])

JOKER FUNC runtime.SetCgoTraceback from runtime/traceback.go:
;; (defn SetCgoTraceback
;;   "SetCgoTraceback records three C functions to use to gather\ntraceback information from C code and to convert that traceback\ninformation into symbolic information. These are used when printing\nstack traces for a program that uses cgo.\n\nThe traceback and context functions may be called from a signal\nhandler, and must therefore use only async-signal safe functions.\nThe symbolizer function may be called while the program is\ncrashing, and so must be cautious about using memory.  None of the\nfunctions may call back into Go.\n\nThe context function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tContext uintptr\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t Context;\n\t};\n\nIf the Context field is 0, the context function is being called to\nrecord the current traceback context. It should record in the\nContext field whatever information is needed about the current\npoint of execution to later produce a stack trace, probably the\nstack pointer and PC. In this case the context function will be\ncalled from C code.\n\nIf the Context field is not 0, then it is a value returned by a\nprevious call to the context function. This case is called when the\ncontext is no longer needed; that is, when the Go code is returning\nto its C code caller. This permits the context function to release\nany associated resources.\n\nWhile it would be correct for the context function to record a\ncomplete a stack trace whenever it is called, and simply copy that\nout in the traceback function, in a typical program the context\nfunction will be called many times without ever recording a\ntraceback for that context. Recording a complete stack trace in a\ncall to the context function is likely to be inefficient.\n\nThe traceback function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tContext    uintptr\n\t\tSigContext uintptr\n\t\tBuf        *uintptr\n\t\tMax        uintptr\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t  Context;\n\t\tuintptr_t  SigContext;\n\t\tuintptr_t* Buf;\n\t\tuintptr_t  Max;\n\t};\n\nThe Context field will be zero to gather a traceback from the\ncurrent program execution point. In this case, the traceback\nfunction will be called from C code.\n\nOtherwise Context will be a value previously returned by a call to\nthe context function. The traceback function should gather a stack\ntrace from that saved point in the program execution. The traceback\nfunction may be called from an execution thread other than the one\nthat recorded the context, but only when the context is known to be\nvalid and unchanging. The traceback function may also be called\ndeeper in the call stack on the same thread that recorded the\ncontext. The traceback function may be called multiple times with\nthe same Context value; it will usually be appropriate to cache the\nresult, if possible, the first time this is called for a specific\ncontext value.\n\nIf the traceback function is called from a signal handler on a Unix\nsystem, SigContext will be the signal context argument passed to\nthe signal handler (a C ucontext_t* cast to uintptr_t). This may be\nused to start tracing at the point where the signal occurred. If\nthe traceback function is not called from a signal handler,\nSigContext will be zero.\n\nBuf is where the traceback information should be stored. It should\nbe PC values, such that Buf[0] is the PC of the caller, Buf[1] is\nthe PC of that function's caller, and so on.  Max is the maximum\nnumber of entries to store.  The function should store a zero to\nindicate the top of the stack, or that the caller is on a different\nstack, presumably a Go stack.\n\nUnlike runtime.Callers, the PC values returned should, when passed\nto the symbolizer function, return the file/line of the call\ninstruction.  No additional subtraction is required or appropriate.\n\nOn all platforms, the traceback function is invoked when a call from\nGo to C to Go requests a stack trace. On linux/amd64, linux/ppc64le,\nand freebsd/amd64, the traceback function is also invoked when a\nsignal is received by a thread that is executing a cgo call. The\ntraceback function should not make assumptions about when it is\ncalled, as future versions of Go may make additional calls.\n\nThe symbolizer function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tPC      uintptr // program counter to fetch information for\n\t\tFile    *byte   // file name (NUL terminated)\n\t\tLineno  uintptr // line number\n\t\tFunc    *byte   // function name (NUL terminated)\n\t\tEntry   uintptr // function entry point\n\t\tMore    uintptr // set non-zero if more info for this PC\n\t\tData    uintptr // unused by runtime, available for function\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t PC;\n\t\tchar*     File;\n\t\tuintptr_t Lineno;\n\t\tchar*     Func;\n\t\tuintptr_t Entry;\n\t\tuintptr_t More;\n\t\tuintptr_t Data;\n\t};\n\nThe PC field will be a value returned by a call to the traceback\nfunction.\n\nThe first time the function is called for a particular traceback,\nall the fields except PC will be 0. The function should fill in the\nother fields if possible, setting them to 0/nil if the information\nis not available. The Data field may be used to store any useful\ninformation across calls. The More field should be set to non-zero\nif there is more information for this PC, zero otherwise. If More\nis set non-zero, the function will be called again with the same\nPC, and may return different information (this is intended for use\nwith inlined functions). If More is zero, the function will be\ncalled with the next PC value in the traceback. When the traceback\nis complete, the function will be called once more with PC set to\nzero; this may be used to free any information. Each call will\nleave the fields of the struct set to the same values they had upon\nreturn, except for the PC field when the More field is zero. The\nfunction must not keep a copy of the struct pointer between calls.\n\nWhen calling SetCgoTraceback, the version argument is the version\nnumber of the structs that the functions expect to receive.\nCurrently this must be zero.\n\nThe symbolizer function may be nil, in which case the results of\nthe traceback function will be displayed as numbers. If the\ntraceback function is nil, the symbolizer function will never be\ncalled. The context function may be nil, in which case the\ntraceback function will only be called with the context field set\nto zero.  If the context function is nil, then calls from Go to C\nto Go will not show a traceback for the C portion of the call stack.\n\nSetCgoTraceback should be called only once, ideally from an init function.\n\nGo input arguments: (version int, traceback unsafe.Pointer, context unsafe.Pointer, symbolizer unsafe.Pointer)\n\nJoker input arguments: [^Int version, ^go.std.unsafe/Pointer traceback, ^go.std.unsafe/Pointer context, ^go.std.unsafe/Pointer symbolizer]"
;;   {:added "1.0"
;;    :go "__setCgoTraceback(__version, *__traceback, *__context, *__symbolizer)"}
;;   [^Int __version, ^unsafe/Pointer __traceback, ^unsafe/Pointer __context, ^unsafe/Pointer __symbolizer])

JOKER FUNC runtime.SetFinalizer from runtime/mfinal.go:
;; (defn SetFinalizer
;;   "SetFinalizer sets the finalizer associated with obj to the provided\nfinalizer function. When the garbage collector finds an unreachable block\nwith an associated finalizer, it clears the association and runs\nfinalizer(obj) in a separate goroutine. This makes obj reachable again,\nbut now without an associated finalizer. Assuming that SetFinalizer\nis not called again, the next time the garbage collector sees\nthat obj is unreachable, it will free obj.\n\nSetFinalizer(obj, nil) clears any finalizer associated with obj.\n\nThe argument obj must be a pointer to an object allocated by calling\nnew, by taking the address of a composite literal, or by taking the\naddress of a local variable.\nThe argument finalizer must be a function that takes a single argument\nto which obj's type can be assigned, and can have arbitrary ignored return\nvalues. If either of these is not true, SetFinalizer may abort the\nprogram.\n\nFinalizers are run in dependency order: if A points at B, both have\nfinalizers, and they are otherwise unreachable, only the finalizer\nfor A runs; once A is freed, the finalizer for B can run.\nIf a cyclic structure includes a block with a finalizer, that\ncycle is not guaranteed to be garbage collected and the finalizer\nis not guaranteed to run, because there is no ordering that\nrespects the dependencies.\n\nThe finalizer is scheduled to run at some arbitrary time after the\nprogram can no longer reach the object to which obj points.\nThere is no guarantee that finalizers will run before a program exits,\nso typically they are useful only for releasing non-memory resources\nassociated with an object during a long-running program.\nFor example, an os.File object could use a finalizer to close the\nassociated operating system file descriptor when a program discards\nan os.File without calling Close, but it would be a mistake\nto depend on a finalizer to flush an in-memory I/O buffer such as a\nbufio.Writer, because the buffer would not be flushed at program exit.\n\nIt is not guaranteed that a finalizer will run if the size of *obj is\nzero bytes.\n\nIt is not guaranteed that a finalizer will run for objects allocated\nin initializers for package-level variables. Such objects may be\nlinker-allocated, not heap-allocated.\n\nA finalizer may run as soon as an object becomes unreachable.\nIn order to use finalizers correctly, the program must ensure that\nthe object is reachable until it is no longer required.\nObjects stored in global variables, or that can be found by tracing\npointers from a global variable, are reachable. For other objects,\npass the object to a call of the KeepAlive function to mark the\nlast point in the function where the object must be reachable.\n\nFor example, if p points to a struct that contains a file descriptor d,\nand p has a finalizer that closes that file descriptor, and if the last\nuse of p in a function is a call to syscall.Write(p.d, buf, size), then\np may be unreachable as soon as the program enters syscall.Write. The\nfinalizer may run at that moment, closing p.d, causing syscall.Write\nto fail because it is writing to a closed file descriptor (or, worse,\nto an entirely different file descriptor opened by a different goroutine).\nTo avoid this problem, call runtime.KeepAlive(p) after the call to\nsyscall.Write.\n\nA single goroutine runs all finalizers for a program, sequentially.\nIf a finalizer must run for a long time, it should do so by starting\na new goroutine.\n\nGo input arguments: (obj interface {}, finalizer interface {})\n\nJoker input arguments: [^<protocol-or-something> obj, ^<protocol-or-something> finalizer]"
;;   {:added "1.0"
;;    :go "__setFinalizer(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> __obj, ^<protocol-or-something> __finalizer])

JOKER FUNC runtime.SetMutexProfileFraction from runtime/mprof.go:
(defn ^"Int" SetMutexProfileFraction
  "SetMutexProfileFraction controls the fraction of mutex contention events\nthat are reported in the mutex profile. On average 1/rate events are\nreported. The previous rate is returned.\n\nTo turn off profiling entirely, pass rate 0.\nTo just read the current rate, pass rate < 0.\n(For n>1 the details of sampling may change.)\n\nGo input arguments: (rate int)\n\nGo return type: int\n\nJoker input arguments: [^Int rate]\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.SetMutexProfileFraction(__rate)"}
  [^Int __rate])

JOKER FUNC runtime.Stack from runtime/mprof.go:
;; (defn ^"Int" Stack
;;   "Stack formats a stack trace of the calling goroutine into buf\nand returns the number of bytes written to buf.\nIf all is true, Stack formats stack traces of all other goroutines\ninto buf after the trace for the current goroutine.\n\nGo input arguments: (buf []byte, all bool)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) buf, ^Boolean all]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "runtime.Stack(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__buf)), __all)"}
;;   [^Object __buf, ^Boolean __all])

JOKER FUNC runtime.StartTrace from runtime/trace.go:
(defn ^"Error" StartTrace
  "StartTrace enables tracing for the current process.\nWhile tracing, the data will be buffered and available via ReadTrace.\nStartTrace returns an error if tracing is already enabled.\nMost clients should use the runtime/trace package or the testing package's\n-test.trace flag instead of calling StartTrace directly.\n\nGo return type: error\n\nJoker input arguments: []\n\nJoker return type: Error"
  {:added "1.0"
   :go "runtime.StartTrace()"}
  [])

JOKER FUNC runtime.StopTrace from runtime/trace.go:
;; (defn StopTrace
;;   "StopTrace stops tracing, if it was previously enabled.\nStopTrace only returns after all the reads for the trace have completed.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__stopTrace()"}
;;   [])

JOKER FUNC runtime.ThreadCreateProfile from runtime/mprof.go:
;; (defn ThreadCreateProfile
;;   "ThreadCreateProfile returns n, the number of records in the thread creation profile.\nIf len(p) >= n, ThreadCreateProfile copies the profile into p and returns n, true.\nIf len(p) < n, ThreadCreateProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package instead\nof calling ThreadCreateProfile directly.\n\nGo input arguments: (p []StackRecord)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of go.std.runtime/StackRecord) p]\n\nJoker return type: [Int Boolean]"
;;   {:added "1.0"
;;    :go "__threadCreateProfile(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_runtime.StackRecord(*__p)))"}
;;   [^Object __p])

JOKER FUNC runtime.UnlockOSThread from runtime/proc.go:
;; (defn UnlockOSThread
;;   "UnlockOSThread undoes an earlier call to LockOSThread.\nIf this drops the number of active LockOSThread calls on the\ncalling goroutine to zero, it unwires the calling goroutine from\nits fixed operating system thread.\nIf there are no active LockOSThread calls, this is a no-op.\n\nBefore calling UnlockOSThread, the caller must ensure that the OS\nthread is suitable for running other goroutines. If the caller made\nany permanent changes to the state of the thread that would affect\nother goroutines, it should not call this function and thus leave\nthe goroutine locked to the OS thread until the goroutine (and\nhence the thread) exits.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__unlockOSThread()"}
;;   [])

JOKER FUNC runtime.Version from runtime/extern.go:
(defn ^"String" Version
  "Version returns the Go tree's version string.\nIt is either the commit hash and date at the time of the build or,\nwhen possible, a release tag like \"go1.3\".\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "runtime.Version()"}
  [])

JOKER TYPE go.std.runtime/BlockProfileRecord:
(def
  ^{:doc "BlockProfileRecord describes blocking events originated\nat a particular call sequence (stack trace).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BlockProfileRecord"}
  BlockProfileRecord)

JOKER TYPE go.std.runtime/Error:
(def
  ^{:doc "The Error interface identifies a run time error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Error"}
  Error)

JOKER TYPE go.std.runtime/Frame:
(def
  ^{:doc "Frame is the information returned by Frames for each call frame.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Frame"}
  Frame)

JOKER TYPE go.std.runtime/Frames:
(def
  ^{:doc "Frames may be used to get function/file/line information for a\nslice of PC values returned by Callers.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Frames"}
  Frames)

JOKER TYPE go.std.runtime/Func:
(def
  ^{:doc "A Func represents a Go function in the running binary.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Func"}
  Func)

JOKER TYPE go.std.runtime/MemProfileRecord:
(def
  ^{:doc "A MemProfileRecord describes the live objects allocated\nby a particular call sequence (stack trace).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_MemProfileRecord"}
  MemProfileRecord)

JOKER TYPE go.std.runtime/MemStats:
(def
  ^{:doc "A MemStats records statistics about the memory allocator.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_MemStats"}
  MemStats)

JOKER TYPE go.std.runtime/StackRecord:
(def
  ^{:doc "A StackRecord describes a single execution stack.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_StackRecord"}
  StackRecord)

JOKER TYPE go.std.runtime/TypeAssertionError:
(def
  ^{:doc "A TypeAssertionError explains a failed type assertion.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TypeAssertionError"}
  TypeAssertionError)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["runtime"]
    :doc "Provides a low-level interface to the runtime package.\n\nPackage runtime contains operations that interact with Go's runtime system,\nsuch as functions to control goroutines. It also includes the low-level type information\nused by the reflect package; see reflect's documentation for the programmable\ninterface to the run-time type system.\n\nEnvironment Variables\n\nThe following environment variables ($name or %name%, depending on the host\noperating system) control the run-time behavior of Go programs. The meanings\nand use may change from release to release.\n\nThe GOGC variable sets the initial garbage collection target percentage.\nA collection is triggered when the ratio of freshly allocated data to live data\nremaining after the previous collection reaches this percentage. The default\nis GOGC=100. Setting GOGC=off disables the garbage collector entirely.\nThe runtime/debug package's SetGCPercent function allows changing this\npercentage at run time. See https://golang.org/pkg/runtime/debug/#SetGCPercent.\n\nThe GODEBUG variable controls debugging variables within the runtime.\nIt is a comma-separated list of name=val pairs setting these named variables:\n\n\tallocfreetrace: setting allocfreetrace=1 causes every allocation to be\n\tprofiled and a stack trace printed on each object's allocation and free.\n\n\tclobberfree: setting clobberfree=1 causes the garbage collector to\n\tclobber the memory content of an object with bad content when it frees\n\tthe object.\n\n\tcgocheck: setting cgocheck=0 disables all checks for packages\n\tusing cgo to incorrectly pass Go pointers to non-Go code.\n\tSetting cgocheck=1 (the default) enables relatively cheap\n\tchecks that may miss some errors.  Setting cgocheck=2 enables\n\texpensive checks that should not miss any errors, but will\n\tcause your program to run slower.\n\n\tefence: setting efence=1 causes the allocator to run in a mode\n\twhere each object is allocated on a unique page and addresses are\n\tnever recycled.\n\n\tgccheckmark: setting gccheckmark=1 enables verification of the\n\tgarbage collector's concurrent mark phase by performing a\n\tsecond mark pass while the world is stopped.  If the second\n\tpass finds a reachable object that was not found by concurrent\n\tmark, the garbage collector will panic.\n\n\tgcpacertrace: setting gcpacertrace=1 causes the garbage collector to\n\tprint information about the internal state of the concurrent pacer.\n\n\tgcshrinkstackoff: setting gcshrinkstackoff=1 disables moving goroutines\n\tonto smaller stacks. In this mode, a goroutine's stack can only grow.\n\n\tgcstoptheworld: setting gcstoptheworld=1 disables concurrent garbage collection,\n\tmaking every garbage collection a stop-the-world event. Setting gcstoptheworld=2\n\talso disables concurrent sweeping after the garbage collection finishes.\n\n\tgctrace: setting gctrace=1 causes the garbage collector to emit a single line to standard\n\terror at each collection, summarizing the amount of memory collected and the\n\tlength of the pause. The format of this line is subject to change.\n\tCurrently, it is:\n\t\tgc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #->#-># MB, # MB goal, # P\n\twhere the fields are as follows:\n\t\tgc #        the GC number, incremented at each GC\n\t\t@#s         time in seconds since program start\n\t\t#%          percentage of time spent in GC since program start\n\t\t#+...+#     wall-clock/CPU times for the phases of the GC\n\t\t#->#-># MB  heap size at GC start, at GC end, and live heap\n\t\t# MB goal   goal heap size\n\t\t# P         number of processors used\n\tThe phases are stop-the-world (STW) sweep termination, concurrent\n\tmark and scan, and STW mark termination. The CPU times\n\tfor mark/scan are broken down in to assist time (GC performed in\n\tline with allocation), background GC time, and idle GC time.\n\tIf the line ends with \"(forced)\", this GC was forced by a\n\truntime.GC() call.\n\n\tSetting gctrace to any value > 0 also causes the garbage collector\n\tto emit a summary when memory is released back to the system.\n\tThis process of returning memory to the system is called scavenging.\n\tThe format of this summary is subject to change.\n\tCurrently it is:\n\t\tscvg#: # MB released  printed only if non-zero\n\t\tscvg#: inuse: # idle: # sys: # released: # consumed: # (MB)\n\twhere the fields are as follows:\n\t\tscvg#        the scavenge cycle number, incremented at each scavenge\n\t\tinuse: #     MB used or partially used spans\n\t\tidle: #      MB spans pending scavenging\n\t\tsys: #       MB mapped from the system\n\t\treleased: #  MB released to the system\n\t\tconsumed: #  MB allocated from the system\n\n\tmadvdontneed: setting madvdontneed=1 will use MADV_DONTNEED\n\tinstead of MADV_FREE on Linux when returning memory to the\n\tkernel. This is less efficient, but causes RSS numbers to drop\n\tmore quickly.\n\n\tmemprofilerate: setting memprofilerate=X will update the value of runtime.MemProfileRate.\n\tWhen set to 0 memory profiling is disabled.  Refer to the description of\n\tMemProfileRate for the default value.\n\n\tinvalidptr: defaults to invalidptr=1, causing the garbage collector and stack\n\tcopier to crash the program if an invalid pointer value (for example, 1)\n\tis found in a pointer-typed location. Setting invalidptr=0 disables this check.\n\tThis should only be used as a temporary workaround to diagnose buggy code.\n\tThe real fix is to not store integers in pointer-typed locations.\n\n\tsbrk: setting sbrk=1 replaces the memory allocator and garbage collector\n\twith a trivial allocator that obtains memory from the operating system and\n\tnever reclaims any memory.\n\n\tscavenge: scavenge=1 enables debugging mode of heap scavenger.\n\n\tscheddetail: setting schedtrace=X and scheddetail=1 causes the scheduler to emit\n\tdetailed multiline info every X milliseconds, describing state of the scheduler,\n\tprocessors, threads and goroutines.\n\n\tschedtrace: setting schedtrace=X causes the scheduler to emit a single line to standard\n\terror every X milliseconds, summarizing the scheduler state.\n\n\ttracebackancestors: setting tracebackancestors=N extends tracebacks with the stacks at\n\twhich goroutines were created, where N limits the number of ancestor goroutines to\n\treport. This also extends the information returned by runtime.Stack. Ancestor's goroutine\n\tIDs will refer to the ID of the goroutine at the time of creation; it's possible for this\n\tID to be reused for another goroutine. Setting N to 0 will report no ancestry information.\n\nThe net, net/http, and crypto/tls packages also refer to debugging variables in GODEBUG.\nSee the documentation for those packages for details.\n\nThe GOMAXPROCS variable limits the number of operating system threads that\ncan execute user-level Go code simultaneously. There is no limit to the number of threads\nthat can be blocked in system calls on behalf of Go code; those do not count against\nthe GOMAXPROCS limit. This package's GOMAXPROCS function queries and changes\nthe limit.\n\nThe GOTRACEBACK variable controls the amount of output generated when a Go\nprogram fails due to an unrecovered panic or an unexpected runtime condition.\nBy default, a failure prints a stack trace for the current goroutine,\neliding functions internal to the run-time system, and then exits with exit code 2.\nThe failure prints stack traces for all goroutines if there is no current goroutine\nor the failure is internal to the run-time.\nGOTRACEBACK=none omits the goroutine stack traces entirely.\nGOTRACEBACK=single (the default) behaves as described above.\nGOTRACEBACK=all adds stack traces for all user-created goroutines.\nGOTRACEBACK=system is like ``all'' but adds stack frames for run-time functions\nand shows goroutines created internally by the run-time.\nGOTRACEBACK=crash is like ``system'' but crashes in an operating system-specific\nmanner instead of exiting. For example, on Unix systems, the crash raises\nSIGABRT to trigger a core dump.\nFor historical reasons, the GOTRACEBACK settings 0, 1, and 2 are synonyms for\nnone, all, and system, respectively.\nThe runtime/debug package's SetTraceback function allows increasing the\namount of output at run time, but it cannot reduce the amount below that\nspecified by the environment variable.\nSee https://golang.org/pkg/runtime/debug/#SetTraceback.\n\nThe GOARCH, GOOS, GOPATH, and GOROOT environment variables complete\nthe set of Go environment variables. They influence the building of Go programs\n(see https://golang.org/cmd/go and https://golang.org/pkg/go/build).\nGOARCH, GOOS, and GOROOT are recorded at compile time and made available by\nconstants or functions in this package, but they do not influence the execution\nof the run-time system.\n"
    :empty false}
  go.std.runtime)
JOKER TYPE runtime/debug.BuildInfo from runtime/debug/mod.go:
;; (defn ^"GoObject" BuildInfo.
;;   "Constructor for debug.BuildInfo"
;;   {:added "1.0"
;;    :go "_ConstructBuildInfo(_v)"}
;;   [^Object _v])

JOKER TYPE runtime/debug.GCStats from runtime/debug/garbage.go:
;; (defn ^"GoObject" GCStats.
;;   "Constructor for debug.GCStats"
;;   {:added "1.0"
;;    :go "_ConstructGCStats(_v)"}
;;   [^Object _v])

JOKER TYPE runtime/debug.Module from runtime/debug/mod.go:
;; (defn ^"GoObject" Module.
;;   "Constructor for debug.Module"
;;   {:added "1.0"
;;    :go "_ConstructModule(_v)"}
;;   [^Object _v])

JOKER FUNC runtime/debug.FreeOSMemory from runtime/debug/garbage.go:
;; (defn FreeOSMemory
;;   "FreeOSMemory forces a garbage collection followed by an\nattempt to return as much memory to the operating system\nas possible. (Even if this is not called, the runtime gradually\nreturns memory to the operating system in a background task.)\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__freeOSMemory()"}
;;   [])

JOKER FUNC runtime/debug.PrintStack from runtime/debug/stack.go:
;; (defn PrintStack
;;   "PrintStack prints to standard error the stack trace returned by runtime.Stack.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__printStack()"}
;;   [])

JOKER FUNC runtime/debug.ReadBuildInfo from runtime/debug/mod.go:
(defn ReadBuildInfo
  "ReadBuildInfo returns the build information embedded\nin the running binary. The information is available only\nin binaries built with module support.\n\nGo return type: (info *BuildInfo, ok bool)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.runtime.debug/BuildInfo) Boolean]"
  {:added "1.0"
   :go "__readBuildInfo()"}
  [])

JOKER FUNC runtime/debug.ReadGCStats from runtime/debug/garbage.go:
;; (defn ReadGCStats
;;   "ReadGCStats reads statistics about garbage collection into stats.\nThe number of entries in the pause history is system-dependent;\nstats.Pause slice will be reused if large enough, reallocated otherwise.\nReadGCStats may use the full capacity of the stats.Pause slice.\nIf stats.PauseQuantiles is non-empty, ReadGCStats fills it with quantiles\nsummarizing the distribution of pause time. For example, if\nlen(stats.PauseQuantiles) is 5, it will be filled with the minimum,\n25%, 50%, 75%, and maximum pause times.\n\nGo input arguments: (stats *GCStats)\n\nJoker input arguments: [^(atom-of go.std.runtime.debug/GCStats) stats]"
;;   {:added "1.0"
;;    :go "__readGCStats(__stats)"}
;;   [^debug/GCStats __stats])

JOKER FUNC runtime/debug.SetGCPercent from runtime/debug/garbage.go:
(defn ^"Int" SetGCPercent
  "SetGCPercent sets the garbage collection target percentage:\na collection is triggered when the ratio of freshly allocated data\nto live data remaining after the previous collection reaches this percentage.\nSetGCPercent returns the previous setting.\nThe initial setting is the value of the GOGC environment variable\nat startup, or 100 if the variable is not set.\nA negative percentage disables garbage collection.\n\nGo input arguments: (percent int)\n\nGo return type: int\n\nJoker input arguments: [^Int percent]\n\nJoker return type: Int"
  {:added "1.0"
   :go "debug.SetGCPercent(__percent)"}
  [^Int __percent])

JOKER FUNC runtime/debug.SetMaxStack from runtime/debug/garbage.go:
(defn ^"Int" SetMaxStack
  "SetMaxStack sets the maximum amount of memory that\ncan be used by a single goroutine stack.\nIf any goroutine exceeds this limit while growing its stack,\nthe program crashes.\nSetMaxStack returns the previous setting.\nThe initial setting is 1 GB on 64-bit systems, 250 MB on 32-bit systems.\n\nSetMaxStack is useful mainly for limiting the damage done by\ngoroutines that enter an infinite recursion. It only limits future\nstack growth.\n\nGo input arguments: (bytes int)\n\nGo return type: int\n\nJoker input arguments: [^Int bytes]\n\nJoker return type: Int"
  {:added "1.0"
   :go "debug.SetMaxStack(__bytes)"}
  [^Int __bytes])

JOKER FUNC runtime/debug.SetMaxThreads from runtime/debug/garbage.go:
(defn ^"Int" SetMaxThreads
  "SetMaxThreads sets the maximum number of operating system\nthreads that the Go program can use. If it attempts to use more than\nthis many, the program crashes.\nSetMaxThreads returns the previous setting.\nThe initial setting is 10,000 threads.\n\nThe limit controls the number of operating system threads, not the number\nof goroutines. A Go program creates a new thread only when a goroutine\nis ready to run but all the existing threads are blocked in system calls, cgo calls,\nor are locked to other goroutines due to use of runtime.LockOSThread.\n\nSetMaxThreads is useful mainly for limiting the damage done by\nprograms that create an unbounded number of threads. The idea is\nto take down the program before it takes down the operating system.\n\nGo input arguments: (threads int)\n\nGo return type: int\n\nJoker input arguments: [^Int threads]\n\nJoker return type: Int"
  {:added "1.0"
   :go "debug.SetMaxThreads(__threads)"}
  [^Int __threads])

JOKER FUNC runtime/debug.SetPanicOnFault from runtime/debug/garbage.go:
(defn ^"Boolean" SetPanicOnFault
  "SetPanicOnFault controls the runtime's behavior when a program faults\nat an unexpected (non-nil) address. Such faults are typically caused by\nbugs such as runtime memory corruption, so the default response is to crash\nthe program. Programs working with memory-mapped files or unsafe\nmanipulation of memory may cause faults at non-nil addresses in less\ndramatic situations; SetPanicOnFault allows such programs to request\nthat the runtime trigger only a panic, not a crash.\nSetPanicOnFault applies only to the current goroutine.\nIt returns the previous setting.\n\nGo input arguments: (enabled bool)\n\nGo return type: bool\n\nJoker input arguments: [^Boolean enabled]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "debug.SetPanicOnFault(__enabled)"}
  [^Boolean __enabled])

JOKER FUNC runtime/debug.SetTraceback from runtime/debug/garbage.go:
;; (defn SetTraceback
;;   "SetTraceback sets the amount of detail printed by the runtime in\nthe traceback it prints before exiting due to an unrecovered panic\nor an internal runtime error.\nThe level argument takes the same values as the GOTRACEBACK\nenvironment variable. For example, SetTraceback(\"all\") ensure\nthat the program prints all goroutines when it crashes.\nSee the package runtime documentation for details.\nIf SetTraceback is called with a level lower than that of the\nenvironment variable, the call is ignored.\n\nGo input arguments: (level string)\n\nJoker input arguments: [^String level]"
;;   {:added "1.0"
;;    :go "__setTraceback(__level)"}
;;   [^String __level])

JOKER FUNC runtime/debug.Stack from runtime/debug/stack.go:
(defn Stack
  "Stack returns a formatted stack trace of the goroutine that calls it.\nIt calls runtime.Stack with a large enough buffer to capture the entire trace.\n\nGo return type: []byte\n\nJoker input arguments: []\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__stack()"}
  [])

JOKER FUNC runtime/debug.WriteHeapDump from runtime/debug/garbage.go:
;; (defn WriteHeapDump
;;   "WriteHeapDump writes a description of the heap and the objects in\nit to the given file descriptor.\n\nWriteHeapDump suspends the execution of all goroutines until the heap\ndump is completely written.  Thus, the file descriptor must not be\nconnected to a pipe or socket whose other end is in the same Go\nprocess; instead, use a temporary file or network socket.\n\nThe heap dump format is defined at https://golang.org/s/go15heapdump.\n\nGo input arguments: (fd uintptr)\n\nJoker input arguments: [^Number fd]"
;;   {:added "1.0"
;;    :go "__writeHeapDump(__fd)"}
;;   [^UIntPtr __fd])

JOKER TYPE go.std.runtime.debug/BuildInfo:
(def
  ^{:doc "BuildInfo represents the build information read from\nthe running binary.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BuildInfo"}
  BuildInfo)

JOKER TYPE go.std.runtime.debug/GCStats:
(def
  ^{:doc "GCStats collect information about recent garbage collections.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_GCStats"}
  GCStats)

JOKER TYPE go.std.runtime.debug/Module:
(def
  ^{:doc "Module represents a module.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Module"}
  Module)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["runtime/debug"]
    :doc "Provides a low-level interface to the runtime/debug package.\n\nPackage debug contains facilities for programs to debug themselves while\nthey are running.\n"
    :empty false}
  go.std.runtime.debug)
JOKER TYPE runtime/pprof.LabelSet from runtime/pprof/label.go:
(defn ^"GoObject" LabelSet.
  "Constructor for pprof.LabelSet"
  {:added "1.0"
   :go "_ConstructLabelSet(_v)"}
  [^Object _v])

JOKER TYPE runtime/pprof.Profile from runtime/pprof/pprof.go:
(defn ^"GoObject" Profile.
  "Constructor for pprof.Profile"
  {:added "1.0"
   :go "_ConstructProfile(_v)"}
  [^Object _v])

JOKER FUNC runtime/pprof.Do from runtime/pprof/runtime.go:
;; (defn Do
;;   "Do calls f with a copy of the parent context with the\ngiven labels added to the parent's label map.\nEach key/value pair in labels is inserted into the label map in the\norder provided, overriding any previous value for the same key.\nThe augmented label map will be set for the duration of the call to f\nand restored once f returns.\n\nGo input arguments: (ctx context.Context, labels LabelSet, f func)\n\nJoker input arguments: [^go.std.context/Context ctx, ^go.std.runtime.pprof/LabelSet labels, ^fn f]"
;;   {:added "1.0"
;;    :go "__do(*__ctx, *__labels, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^context/Context __ctx, ^pprof/LabelSet __labels, ^fn __f])

JOKER FUNC runtime/pprof.ForLabels from runtime/pprof/label.go:
;; (defn ForLabels
;;   "ForLabels invokes f with each label set on the context.\nThe function f should return true to continue iteration or false to stop iteration early.\n\nGo input arguments: (ctx context.Context, f func)\n\nJoker input arguments: [^go.std.context/Context ctx, ^fn f]"
;;   {:added "1.0"
;;    :go "__forLabels(*__ctx, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^context/Context __ctx, ^fn __f])

JOKER FUNC runtime/pprof.Label from runtime/pprof/label.go:
;; (defn Label
;;   "Label returns the value of the label with the given key on ctx, and a boolean indicating\nwhether that label exists.\n\nGo input arguments: (ctx context.Context, key string)\n\nGo return type: (string, bool)\n\nJoker input arguments: [^go.std.context/Context ctx, ^String key]\n\nJoker return type: [String Boolean]"
;;   {:added "1.0"
;;    :go "__label(*__ctx, __key)"}
;;   [^context/Context __ctx, ^String __key])

JOKER FUNC runtime/pprof.Labels from runtime/pprof/label.go:
;; (defn Labels
;;   "Labels takes an even number of strings representing key-value pairs\nand makes a LabelSet containing them.\nA label overwrites a prior label with the same key.\n\nGo input arguments: (args ...string)\n\nGo return type: LabelSet\n\nJoker input arguments: [^(ellipsis-somehow String) args]\n\nJoker return type: go.std.runtime.pprof/LabelSet"
;;   {:added "1.0"
;;    :go "__labels(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(__args)))"}
;;   [^String __args])

JOKER FUNC runtime/pprof.Lookup from runtime/pprof/pprof.go:
(defn Lookup
  "Lookup returns the profile with the given name, or nil if no such profile exists.\n\nGo input arguments: (name string)\n\nGo return type: *Profile\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.runtime.pprof/Profile)"
  {:added "1.0"
   :go "__lookup(__name)"}
  [^String __name])

JOKER FUNC runtime/pprof.NewProfile from runtime/pprof/pprof.go:
(defn NewProfile
  "NewProfile creates a new profile with the given name.\nIf a profile with that name already exists, NewProfile panics.\nThe convention is to use a 'import/path.' prefix to create\nseparate name spaces for each package.\nFor compatibility with various tools that read pprof data,\nprofile names should not contain spaces.\n\nGo input arguments: (name string)\n\nGo return type: *Profile\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.runtime.pprof/Profile)"
  {:added "1.0"
   :go "__newProfile(__name)"}
  [^String __name])

JOKER FUNC runtime/pprof.Profiles from runtime/pprof/pprof.go:
(defn Profiles
  "Profiles returns a slice of all the known profiles, sorted by name.\n\nGo return type: []*Profile\n\nJoker input arguments: []\n\nJoker return type: (vector-of (atom-of go.std.runtime.pprof/Profile))"
  {:added "1.0"
   :go "__profiles()"}
  [])

JOKER FUNC runtime/pprof.SetGoroutineLabels from runtime/pprof/runtime.go:
;; (defn SetGoroutineLabels
;;   "SetGoroutineLabels sets the current goroutine's labels to match ctx.\nThis is a lower-level API than Do, which should be used instead when possible.\n\nGo input arguments: (ctx context.Context)\n\nJoker input arguments: [^go.std.context/Context ctx]"
;;   {:added "1.0"
;;    :go "__setGoroutineLabels(*__ctx)"}
;;   [^context/Context __ctx])

JOKER FUNC runtime/pprof.StartCPUProfile from runtime/pprof/pprof.go:
;; (defn ^"Error" StartCPUProfile
;;   "StartCPUProfile enables CPU profiling for the current process.\nWhile profiling, the profile will be buffered and written to w.\nStartCPUProfile returns an error if profiling is already enabled.\n\nOn Unix-like systems, StartCPUProfile does not work by default for\nGo code built with -buildmode=c-archive or -buildmode=c-shared.\nStartCPUProfile relies on the SIGPROF signal, but that signal will\nbe delivered to the main program's SIGPROF signal handler (if any)\nnot to the one used by Go. To make it work, call os/signal.Notify\nfor syscall.SIGPROF, but note that doing so may break any profiling\nbeing done by the main program.\n\nGo input arguments: (w io.Writer)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "pprof.StartCPUProfile(*__w)"}
;;   [^io/Writer __w])

JOKER FUNC runtime/pprof.StopCPUProfile from runtime/pprof/pprof.go:
;; (defn StopCPUProfile
;;   "StopCPUProfile stops the current CPU profile, if any.\nStopCPUProfile only returns after all the writes for the\nprofile have completed.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__stopCPUProfile()"}
;;   [])

JOKER FUNC runtime/pprof.WithLabels from runtime/pprof/label.go:
;; (defn WithLabels
;;   "WithLabels returns a new context.Context with the given labels added.\nA label overwrites a prior label with the same key.\n\nGo input arguments: (ctx context.Context, labels LabelSet)\n\nGo return type: context.Context\n\nJoker input arguments: [^go.std.context/Context ctx, ^go.std.runtime.pprof/LabelSet labels]\n\nJoker return type: go.std.context/Context"
;;   {:added "1.0"
;;    :go "__withLabels(*__ctx, *__labels)"}
;;   [^context/Context __ctx, ^pprof/LabelSet __labels])

JOKER FUNC runtime/pprof.WriteHeapProfile from runtime/pprof/pprof.go:
;; (defn ^"Error" WriteHeapProfile
;;   "WriteHeapProfile is shorthand for Lookup(\"heap\").WriteTo(w, 0).\nIt is preserved for backwards compatibility.\n\nGo input arguments: (w io.Writer)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "pprof.WriteHeapProfile(*__w)"}
;;   [^io/Writer __w])

JOKER TYPE go.std.runtime.pprof/LabelSet:
(def
  ^{:doc "LabelSet is a set of labels.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_LabelSet"}
  LabelSet)

JOKER TYPE go.std.runtime.pprof/Profile:
(def
  ^{:doc "A Profile is a collection of stack traces showing the call sequences\nthat led to instances of a particular event, such as allocation.\nPackages can create and maintain their own profiles; the most common\nuse is for tracking resources that must be explicitly closed, such as files\nor network connections.\n\nA Profile's methods can be called from multiple goroutines simultaneously.\n\nEach Profile has a unique name. A few profiles are predefined:\n\n\tgoroutine    - stack traces of all current goroutines\n\theap         - a sampling of memory allocations of live objects\n\tallocs       - a sampling of all past memory allocations\n\tthreadcreate - stack traces that led to the creation of new OS threads\n\tblock        - stack traces that led to blocking on synchronization primitives\n\tmutex        - stack traces of holders of contended mutexes\n\nThese predefined profiles maintain themselves and panic on an explicit\nAdd or Remove method call.\n\nThe heap profile reports statistics as of the most recently completed\ngarbage collection; it elides more recent allocation to avoid skewing\nthe profile away from live data and toward garbage.\nIf there has been no garbage collection at all, the heap profile reports\nall known allocations. This exception helps mainly in programs running\nwithout garbage collection enabled, usually for debugging purposes.\n\nThe heap profile tracks both the allocation sites for all live objects in\nthe application memory and for all objects allocated since the program start.\nPprof's -inuse_space, -inuse_objects, -alloc_space, and -alloc_objects\nflags select which to display, defaulting to -inuse_space (live objects,\nscaled by size).\n\nThe allocs profile is the same as the heap profile but changes the default\npprof display to -alloc_space, the total number of bytes allocated since\nthe program began (including garbage-collected bytes).\n\nThe CPU profile is not available as a Profile. It has a special API,\nthe StartCPUProfile and StopCPUProfile functions, because it streams\noutput to a writer during profiling.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Profile"}
  Profile)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the runtime/pprof package.\n\nPackage pprof writes runtime profiling data in the format expected\nby the pprof visualization tool.\n\nProfiling a Go program\n\nThe first step to profiling a Go program is to enable profiling.\nSupport for profiling benchmarks built with the standard testing\npackage is built into go test. For example, the following command\nruns benchmarks in the current directory and writes the CPU and\nmemory profiles to cpu.prof and mem.prof:\n\n    go test -cpuprofile cpu.prof -memprofile mem.prof -bench .\n\nTo add equivalent profiling support to a standalone program, add\ncode like the following to your main function:\n\n   var cpuprofile = flag.String(\"cpuprofile\", \"\", \"write cpu profile to `file`\")\n   var memprofile = flag.String(\"memprofile\", \"\", \"write memory profile to `file`\")\n\n   func main() {\n       flag.Parse()\n       if *cpuprofile != \"\" {\n           f, err := os.Create(*cpuprofile)\n           if err != nil {\n               log.Fatal(\"could not create CPU profile: \", err)\n           }\n           defer f.Close()\n           if err := pprof.StartCPUProfile(f); err != nil {\n               log.Fatal(\"could not start CPU profile: \", err)\n           }\n           defer pprof.StopCPUProfile()\n       }\n\n       // ... rest of the program ...\n\n       if *memprofile != \"\" {\n           f, err := os.Create(*memprofile)\n           if err != nil {\n               log.Fatal(\"could not create memory profile: \", err)\n           }\n           defer f.Close()\n           runtime.GC() // get up-to-date statistics\n           if err := pprof.WriteHeapProfile(f); err != nil {\n               log.Fatal(\"could not write memory profile: \", err)\n           }\n       }\n   }\n\nThere is also a standard HTTP interface to profiling data. Adding\nthe following line will install handlers under the /debug/pprof/\nURL to download live profiles:\n\n   import _ \"net/http/pprof\"\n\nSee the net/http/pprof package for more details.\n\nProfiles can then be visualized with the pprof tool:\n\n   go tool pprof cpu.prof\n\nThere are many commands available from the pprof command line.\nCommonly used commands include \"top\", which prints a summary of the\ntop program hot-spots, and \"web\", which opens an interactive graph\nof hot-spots and their call graphs. Use \"help\" for information on\nall pprof commands.\n\nFor more information about pprof, see\nhttps://github.com/google/pprof/blob/master/doc/README.md.\n"
    :empty false}
  go.std.runtime.pprof)
JOKER TYPE runtime/trace.Region from runtime/trace/annotation.go:
(defn ^"GoObject" Region.
  "Constructor for trace.Region"
  {:added "1.0"
   :go "_ConstructRegion(_v)"}
  [^Object _v])

JOKER TYPE runtime/trace.Task from runtime/trace/annotation.go:
(defn ^"GoObject" Task.
  "Constructor for trace.Task"
  {:added "1.0"
   :go "_ConstructTask(_v)"}
  [^Object _v])

JOKER FUNC runtime/trace.IsEnabled from runtime/trace/annotation.go:
(defn ^"Boolean" IsEnabled
  "IsEnabled reports whether tracing is enabled.\nThe information is advisory only. The tracing status\nmay have changed by the time this function returns.\n\nGo return type: bool\n\nJoker input arguments: []\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "trace.IsEnabled()"}
  [])

JOKER FUNC runtime/trace.Log from runtime/trace/annotation.go:
;; (defn Log
;;   "Log emits a one-off event with the given category and message.\nCategory can be empty and the API assumes there are only a handful of\nunique categories in the system.\n\nGo input arguments: (ctx context.Context, category string, message string)\n\nJoker input arguments: [^go.std.context/Context ctx, ^String category, ^String message]"
;;   {:added "1.0"
;;    :go "__log(*__ctx, __category, __message)"}
;;   [^context/Context __ctx, ^String __category, ^String __message])

JOKER FUNC runtime/trace.Logf from runtime/trace/annotation.go:
;; (defn Logf
;;   "Logf is like Log, but the value is formatted using the specified format spec.\n\nGo input arguments: (ctx context.Context, category string, format string, args ...interface {})\n\nJoker input arguments: [^go.std.context/Context ctx, ^String category, ^String format, ^(ellipsis-somehow <protocol-or-something>) args]"
;;   {:added "1.0"
;;    :go "__logf(*__ctx, __category, __format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^context/Context __ctx, ^String __category, ^String __format, ^<protocol-or-something> __args])

JOKER FUNC runtime/trace.NewTask from runtime/trace/annotation.go:
;; (defn NewTask
;;   "NewTask creates a task instance with the type taskType and returns\nit along with a Context that carries the task.\nIf the input context contains a task, the new task is its subtask.\n\nThe taskType is used to classify task instances. Analysis tools\nlike the Go execution tracer may assume there are only a bounded\nnumber of unique task types in the system.\n\nThe returned end function is used to mark the task's end.\nThe trace tool measures task latency as the time between task creation\nand when the end function is called, and provides the latency\ndistribution per task type.\nIf the end function is called multiple times, only the first\ncall is used in the latency measurement.\n\n  ctx, task := trace.NewTask(ctx, \"awesomeTask\")\n  trace.WithRegion(ctx, \"preparation\", prepWork)\n  // preparation of the task\n  go func() {  // continue processing the task in a separate goroutine.\n      defer task.End()\n      trace.WithRegion(ctx, \"remainingWork\", remainingWork)\n  }()\n\nGo input arguments: (pctx context.Context, taskType string)\n\nGo return type: (ctx context.Context, task *Task)\n\nJoker input arguments: [^go.std.context/Context pctx, ^String taskType]\n\nJoker return type: [go.std.context/Context (atom-of go.std.runtime.trace/Task)]"
;;   {:added "1.0"
;;    :go "__newTask(*__pctx, __taskType)"}
;;   [^context/Context __pctx, ^String __taskType])

JOKER FUNC runtime/trace.Start from runtime/trace/trace.go:
;; (defn ^"Error" Start
;;   "Start enables tracing for the current program.\nWhile tracing, the trace will be buffered and written to w.\nStart returns an error if tracing is already enabled.\n\nGo input arguments: (w io.Writer)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "trace.Start(*__w)"}
;;   [^io/Writer __w])

JOKER FUNC runtime/trace.StartRegion from runtime/trace/annotation.go:
;; (defn StartRegion
;;   "StartRegion starts a region and returns a function for marking the\nend of the region. The returned Region's End function must be called\nfrom the same goroutine where the region was started.\nWithin each goroutine, regions must nest. That is, regions started\nafter this region must be ended before this region can be ended.\nRecommended usage is\n\n    defer trace.StartRegion(ctx, \"myTracedRegion\").End()\n\nGo input arguments: (ctx context.Context, regionType string)\n\nGo return type: *Region\n\nJoker input arguments: [^go.std.context/Context ctx, ^String regionType]\n\nJoker return type: (atom-of go.std.runtime.trace/Region)"
;;   {:added "1.0"
;;    :go "__startRegion(*__ctx, __regionType)"}
;;   [^context/Context __ctx, ^String __regionType])

JOKER FUNC runtime/trace.Stop from runtime/trace/trace.go:
;; (defn Stop
;;   "Stop stops the current tracing, if any.\nStop only returns after all the writes for the trace have completed.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__stop()"}
;;   [])

JOKER FUNC runtime/trace.WithRegion from runtime/trace/annotation.go:
;; (defn WithRegion
;;   "WithRegion starts a region associated with its calling goroutine, runs fn,\nand then ends the region. If the context carries a task, the region is\nassociated with the task. Otherwise, the region is attached to the background\ntask.\n\nThe regionType is used to classify regions, so there should be only a\nhandful of unique region types.\n\nGo input arguments: (ctx context.Context, regionType string, fn func)\n\nJoker input arguments: [^go.std.context/Context ctx, ^String regionType, ^fn fn]"
;;   {:added "1.0"
;;    :go "__withRegion(*__ctx, __regionType, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^context/Context __ctx, ^String __regionType, ^fn __fn])

JOKER TYPE go.std.runtime.trace/Region:
(def
  ^{:doc "Region is a region of code whose execution time interval is traced.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Region"}
  Region)

JOKER TYPE go.std.runtime.trace/Task:
(def
  ^{:doc "Task is a data type for tracing a user-defined, logical operation.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Task"}
  Task)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["runtime/trace"]
    :doc "Provides a low-level interface to the runtime/trace package.\n\nPackage trace contains facilities for programs to generate traces\nfor the Go execution tracer.\n\nTracing runtime activities\n\nThe execution trace captures a wide range of execution events such as\ngoroutine creation/blocking/unblocking, syscall enter/exit/block,\nGC-related events, changes of heap size, processor start/stop, etc.\nA precise nanosecond-precision timestamp and a stack trace is\ncaptured for most events. The generated trace can be interpreted\nusing `go tool trace`.\n\nSupport for tracing tests and benchmarks built with the standard\ntesting package is built into `go test`. For example, the following\ncommand runs the test in the current directory and writes the trace\nfile (trace.out).\n\n   go test -trace=test.out\n\nThis runtime/trace package provides APIs to add equivalent tracing\nsupport to a standalone program. See the Example that demonstrates\nhow to use this API to enable tracing.\n\nThere is also a standard HTTP interface to trace data. Adding the\nfollowing line will install a handler under the /debug/pprof/trace URL\nto download a live trace:\n\n    import _ \"net/http/pprof\"\n\nSee the net/http/pprof package for more details about all of the\ndebug endpoints installed by this import.\n\nUser annotation\n\nPackage trace provides user annotation APIs that can be used to\nlog interesting events during execution.\n\nThere are three types of user annotations: log messages, regions,\nand tasks.\n\nLog emits a timestamped message to the execution trace along with\nadditional information such as the category of the message and\nwhich goroutine called Log. The execution tracer provides UIs to filter\nand group goroutines using the log category and the message supplied\nin Log.\n\nA region is for logging a time interval during a goroutine's execution.\nBy definition, a region starts and ends in the same goroutine.\nRegions can be nested to represent subintervals.\nFor example, the following code records four regions in the execution\ntrace to trace the durations of sequential steps in a cappuccino making\noperation.\n\n  trace.WithRegion(ctx, \"makeCappuccino\", func() {\n\n     // orderID allows to identify a specific order\n     // among many cappuccino order region records.\n     trace.Log(ctx, \"orderID\", orderID)\n\n     trace.WithRegion(ctx, \"steamMilk\", steamMilk)\n     trace.WithRegion(ctx, \"extractCoffee\", extractCoffee)\n     trace.WithRegion(ctx, \"mixMilkCoffee\", mixMilkCoffee)\n  })\n\nA task is a higher-level component that aids tracing of logical\noperations such as an RPC request, an HTTP request, or an\ninteresting local operation which may require multiple goroutines\nworking together. Since tasks can involve multiple goroutines,\nthey are tracked via a context.Context object. NewTask creates\na new task and embeds it in the returned context.Context object.\nLog messages and regions are attached to the task, if any, in the\nContext passed to Log and WithRegion.\n\nFor example, assume that we decided to froth milk, extract coffee,\nand mix milk and coffee in separate goroutines. With a task,\nthe trace tool can identify the goroutines involved in a specific\ncappuccino order.\n\n     ctx, task := trace.NewTask(ctx, \"makeCappuccino\")\n     trace.Log(ctx, \"orderID\", orderID)\n\n     milk := make(chan bool)\n     espresso := make(chan bool)\n\n     go func() {\n             trace.WithRegion(ctx, \"steamMilk\", steamMilk)\n             milk <- true\n     }()\n     go func() {\n             trace.WithRegion(ctx, \"extractCoffee\", extractCoffee)\n             espresso <- true\n     }()\n     go func() {\n             defer task.End() // When assemble is done, the order is complete.\n             <-espresso\n             <-milk\n             trace.WithRegion(ctx, \"mixMilkCoffee\", mixMilkCoffee)\n     }()\n\nThe trace tool computes the latency of a task by measuring the\ntime between the task creation and the task end and provides\nlatency distributions for each task type found in the trace.\n"
    :empty false}
  go.std.runtime.trace)
JOKER TYPE sort.Float64Slice from sort/sort.go:
;; (defn ^"GoObject" Float64Slice.
;;   "Constructor for sort.Float64Slice"
;;   {:added "1.0"
;;    :go "_ConstructFloat64Slice(_v)"}
;;   [^Object _v])

JOKER TYPE sort.IntSlice from sort/sort.go:
;; (defn ^"GoObject" IntSlice.
;;   "Constructor for sort.IntSlice"
;;   {:added "1.0"
;;    :go "_ConstructIntSlice(_v)"}
;;   [^Object _v])

JOKER TYPE sort.Interface from sort/sort.go:
;; (defn ^"GoObject" Interface.
;;   "Constructor for sort.Interface"
;;   {:added "1.0"
;;    :go "_ConstructInterface(_v)"}
;;   [^Object _v])

JOKER TYPE sort.StringSlice from sort/sort.go:
;; (defn ^"GoObject" StringSlice.
;;   "Constructor for sort.StringSlice"
;;   {:added "1.0"
;;    :go "_ConstructStringSlice(_v)"}
;;   [^Object _v])

JOKER FUNC sort.Float64s from sort/sort.go:
;; (defn Float64s
;;   "Float64s sorts a slice of float64s in increasing order\n(not-a-number values are treated as less than other values).\n\nGo input arguments: (a []float64)\n\nJoker input arguments: [^(vector-of Double) a]"
;;   {:added "1.0"
;;    :go "__float64s(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOffloat64(__a)))"}
;;   [^Object __a])

JOKER FUNC sort.Float64sAreSorted from sort/sort.go:
;; (defn ^"Boolean" Float64sAreSorted
;;   "Float64sAreSorted tests whether a slice of float64s is sorted in increasing order\n(not-a-number values are treated as less than other values).\n\nGo input arguments: (a []float64)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Double) a]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "sort.Float64sAreSorted(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOffloat64(__a)))"}
;;   [^Object __a])

JOKER FUNC sort.Ints from sort/sort.go:
;; (defn Ints
;;   "Ints sorts a slice of ints in increasing order.\n\nGo input arguments: (a []int)\n\nJoker input arguments: [^(vector-of Int) a]"
;;   {:added "1.0"
;;    :go "__ints(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfint(__a)))"}
;;   [^Object __a])

JOKER FUNC sort.IntsAreSorted from sort/sort.go:
;; (defn ^"Boolean" IntsAreSorted
;;   "IntsAreSorted tests whether a slice of ints is sorted in increasing order.\n\nGo input arguments: (a []int)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) a]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "sort.IntsAreSorted(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfint(__a)))"}
;;   [^Object __a])

JOKER FUNC sort.IsSorted from sort/sort.go:
(defn ^"Boolean" IsSorted
  "IsSorted reports whether data is sorted.\n\nGo input arguments: (data Interface)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.sort/Interface data]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "sort.IsSorted(*__data)"}
  [^sort/Interface __data])

JOKER FUNC sort.Reverse from sort/sort.go:
(defn Reverse
  "Reverse returns the reverse order for data.\n\nGo input arguments: (data Interface)\n\nGo return type: Interface\n\nJoker input arguments: [^go.std.sort/Interface data]\n\nJoker return type: go.std.sort/Interface"
  {:added "1.0"
   :go "__reverse(*__data)"}
  [^sort/Interface __data])

JOKER FUNC sort.Search from sort/search.go:
;; (defn ^"Int" Search
;;   "Search uses binary search to find and return the smallest index i\nin [0, n) at which f(i) is true, assuming that on the range [0, n),\nf(i) == true implies f(i+1) == true. That is, Search requires that\nf is false for some (possibly empty) prefix of the input range [0, n)\nand then true for the (possibly empty) remainder; Search returns\nthe first true index. If there is no such index, Search returns n.\n(Note that the \"not found\" return value is not -1 as in, for instance,\nstrings.Index.)\nSearch calls f(i) only for i in the range [0, n).\n\nA common use of Search is to find the index i for a value x in\na sorted, indexable data structure such as an array or slice.\nIn this case, the argument f, typically a closure, captures the value\nto be searched for, and how the data structure is indexed and\nordered.\n\nFor instance, given a slice data sorted in ascending order,\nthe call Search(len(data), func(i int) bool { return data[i] >= 23 })\nreturns the smallest index i such that data[i] >= 23. If the caller\nwants to find whether 23 is in the slice, it must test data[i] == 23\nseparately.\n\nSearching data sorted in descending order would use the <=\noperator instead of the >= operator.\n\nTo complete the example above, the following code tries to find the value\nx in an integer slice data sorted in ascending order:\n\n\tx := 23\n\ti := sort.Search(len(data), func(i int) bool { return data[i] >= x })\n\tif i < len(data) && data[i] == x {\n\t\t// x is present at data[i]\n\t} else {\n\t\t// x is not present in data,\n\t\t// but i is the index where it would be inserted.\n\t}\n\nAs a more whimsical example, this program guesses your number:\n\n\tfunc GuessingGame() {\n\t\tvar s string\n\t\tfmt.Printf(\"Pick an integer from 0 to 100.\\n\")\n\t\tanswer := sort.Search(100, func(i int) bool {\n\t\t\tfmt.Printf(\"Is your number <= %d? \", i)\n\t\t\tfmt.Scanf(\"%s\", &s)\n\t\t\treturn s != \"\" && s[0] == 'y'\n\t\t})\n\t\tfmt.Printf(\"Your number is %d.\\n\", answer)\n\t}\n\nGo input arguments: (n int, f func)\n\nGo return type: int\n\nJoker input arguments: [^Int n, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.Search(__n, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Int __n, ^fn __f])

JOKER FUNC sort.SearchFloat64s from sort/search.go:
;; (defn ^"Int" SearchFloat64s
;;   "SearchFloat64s searches for x in a sorted slice of float64s and returns the index\nas specified by Search. The return value is the index to insert x if x is not\npresent (it could be len(a)).\nThe slice must be sorted in ascending order.\n\nGo input arguments: (a []float64, x float64)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Double) a, ^Double x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.SearchFloat64s(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOffloat64(__a)), __x)"}
;;   [^Object __a, ^ABEND007(find these) __x])

JOKER FUNC sort.SearchInts from sort/search.go:
;; (defn ^"Int" SearchInts
;;   "SearchInts searches for x in a sorted slice of ints and returns the index\nas specified by Search. The return value is the index to insert x if x is\nnot present (it could be len(a)).\nThe slice must be sorted in ascending order.\n\nGo input arguments: (a []int, x int)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) a, ^Int x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.SearchInts(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfint(__a)), __x)"}
;;   [^Object __a, ^Int __x])

JOKER FUNC sort.SearchStrings from sort/search.go:
;; (defn ^"Int" SearchStrings
;;   "SearchStrings searches for x in a sorted slice of strings and returns the index\nas specified by Search. The return value is the index to insert x if x is not\npresent (it could be len(a)).\nThe slice must be sorted in ascending order.\n\nGo input arguments: (a []string, x string)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of String) a, ^String x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.SearchStrings(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(__a)), __x)"}
;;   [^Object __a, ^String __x])

JOKER FUNC sort.Slice from sort/slice.go:
;; (defn Slice
;;   "Slice sorts the provided slice given the provided less function.\n\nThe sort is not guaranteed to be stable. For a stable sort, use\nSliceStable.\n\nThe function panics if the provided interface is not a slice.\n\nGo input arguments: (slice interface {}, less func)\n\nJoker input arguments: [^<protocol-or-something> slice, ^fn less]"
;;   {:added "1.0"
;;    :go "__slice(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^<protocol-or-something> __slice, ^fn __less])

JOKER FUNC sort.SliceIsSorted from sort/slice.go:
;; (defn ^"Boolean" SliceIsSorted
;;   "SliceIsSorted tests whether a slice is sorted.\n\nThe function panics if the provided interface is not a slice.\n\nGo input arguments: (slice interface {}, less func)\n\nGo return type: bool\n\nJoker input arguments: [^<protocol-or-something> slice, ^fn less]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "sort.SliceIsSorted(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^<protocol-or-something> __slice, ^fn __less])

JOKER FUNC sort.SliceStable from sort/slice.go:
;; (defn SliceStable
;;   "SliceStable sorts the provided slice given the provided less\nfunction while keeping the original order of equal elements.\n\nThe function panics if the provided interface is not a slice.\n\nGo input arguments: (slice interface {}, less func)\n\nJoker input arguments: [^<protocol-or-something> slice, ^fn less]"
;;   {:added "1.0"
;;    :go "__sliceStable(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^<protocol-or-something> __slice, ^fn __less])

JOKER FUNC sort.Sort from sort/sort.go:
;; (defn Sort
;;   "Sort sorts data.\nIt makes one call to data.Len to determine n, and O(n*log(n)) calls to\ndata.Less and data.Swap. The sort is not guaranteed to be stable.\n\nGo input arguments: (data Interface)\n\nJoker input arguments: [^go.std.sort/Interface data]"
;;   {:added "1.0"
;;    :go "__sort(*__data)"}
;;   [^sort/Interface __data])

JOKER FUNC sort.Stable from sort/sort.go:
;; (defn Stable
;;   "Stable sorts data while keeping the original order of equal elements.\n\nIt makes one call to data.Len to determine n, O(n*log(n)) calls to\ndata.Less and O(n*log(n)*log(n)) calls to data.Swap.\n\nGo input arguments: (data Interface)\n\nJoker input arguments: [^go.std.sort/Interface data]"
;;   {:added "1.0"
;;    :go "__stable(*__data)"}
;;   [^sort/Interface __data])

JOKER FUNC sort.Strings from sort/sort.go:
;; (defn Strings
;;   "Strings sorts a slice of strings in increasing order.\n\nGo input arguments: (a []string)\n\nJoker input arguments: [^(vector-of String) a]"
;;   {:added "1.0"
;;    :go "__strings(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(__a)))"}
;;   [^Object __a])

JOKER FUNC sort.StringsAreSorted from sort/sort.go:
;; (defn ^"Boolean" StringsAreSorted
;;   "StringsAreSorted tests whether a slice of strings is sorted in increasing order.\n\nGo input arguments: (a []string)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of String) a]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "sort.StringsAreSorted(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(__a)))"}
;;   [^Object __a])

JOKER TYPE go.std.sort/Float64Slice:
(def
  ^{:doc "Float64Slice attaches the methods of Interface to []float64, sorting in increasing order\n(not-a-number values are treated as less than other values).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Float64Slice"}
  Float64Slice)

JOKER TYPE go.std.sort/IntSlice:
(def
  ^{:doc "IntSlice attaches the methods of Interface to []int, sorting in increasing order.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IntSlice"}
  IntSlice)

JOKER TYPE go.std.sort/Interface:
(def
  ^{:doc "A type, typically a collection, that satisfies sort.Interface can be\nsorted by the routines in this package. The methods require that the\nelements of the collection be enumerated by an integer index.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Interface"}
  Interface)

JOKER TYPE go.std.sort/StringSlice:
(def
  ^{:doc "StringSlice attaches the methods of Interface to []string, sorting in increasing order.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_StringSlice"}
  StringSlice)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["sort"]
    :doc "Provides a low-level interface to the sort package.\n\nPackage sort provides primitives for sorting slices and user-defined\ncollections.\n"
    :empty false}
  go.std.sort)
JOKER CONSTANT IntSize from strconv/atoi.go:
(def
  ^{:doc "IntSize is the size in bits of an int or uint value.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(strconv.IntSize)"}
  IntSize)

JOKER VARIABLE ErrRange from strconv/atoi.go:
(def
  ^{:doc "ErrRange indicates that a value is out of range for the target type.\n"
    :added "1.0"
    :tag "Var"
    :go "strconv.ErrRange"}
  ErrRange)

JOKER VARIABLE ErrSyntax from strconv/atoi.go:
(def
  ^{:doc "ErrSyntax indicates that a value does not have the right syntax for the target type.\n"
    :added "1.0"
    :tag "Var"
    :go "strconv.ErrSyntax"}
  ErrSyntax)

JOKER TYPE strconv.NumError from strconv/atoi.go:
(defn ^"GoObject" NumError.
  "Constructor for strconv.NumError"
  {:added "1.0"
   :go "_ConstructNumError(_v)"}
  [^Object _v])

JOKER FUNC strconv.AppendBool from strconv/atob.go:
;; (defn AppendBool
;;   "AppendBool appends \"true\" or \"false\", according to the value of b,\nto dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, b bool)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) dst, ^Boolean b]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendBool(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__dst)), __b)"}
;;   [^Object __dst, ^Boolean __b])

JOKER FUNC strconv.AppendFloat from strconv/ftoa.go:
;; (defn AppendFloat
;;   "AppendFloat appends the string form of the floating-point number f,\nas generated by FormatFloat, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, f float64, fmt byte, prec int, bitSize int)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) dst, ^Double f, ^Int fmt, ^Int prec, ^Int bitSize]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendFloat(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__dst)), __f, __fmt, __prec, __bitSize)"}
;;   [^Object __dst, ^ABEND007(find these) __f, ^Byte __fmt, ^Int __prec, ^Int __bitSize])

JOKER FUNC strconv.AppendInt from strconv/itoa.go:
;; (defn AppendInt
;;   "AppendInt appends the string form of the integer i,\nas generated by FormatInt, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, i int64, base int)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) dst, ^Number i, ^Int base]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendInt(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__dst)), __i, __base)"}
;;   [^Object __dst, ^Int64 __i, ^Int __base])

JOKER FUNC strconv.AppendQuote from strconv/quote.go:
;; (defn AppendQuote
;;   "AppendQuote appends a double-quoted Go string literal representing s,\nas generated by Quote, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, s string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) dst, ^String s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendQuote(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__dst)), __s)"}
;;   [^Object __dst, ^String __s])

JOKER FUNC strconv.AppendQuoteRune from strconv/quote.go:
;; (defn AppendQuoteRune
;;   "AppendQuoteRune appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRune, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, r rune)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) dst, ^Char r]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendQuoteRune(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__dst)), __r)"}
;;   [^Object __dst, ^Char __r])

JOKER FUNC strconv.AppendQuoteRuneToASCII from strconv/quote.go:
;; (defn AppendQuoteRuneToASCII
;;   "AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRuneToASCII, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, r rune)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) dst, ^Char r]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendQuoteRuneToASCII(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__dst)), __r)"}
;;   [^Object __dst, ^Char __r])

JOKER FUNC strconv.AppendQuoteRuneToGraphic from strconv/quote.go:
;; (defn AppendQuoteRuneToGraphic
;;   "AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRuneToGraphic, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, r rune)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) dst, ^Char r]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendQuoteRuneToGraphic(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__dst)), __r)"}
;;   [^Object __dst, ^Char __r])

JOKER FUNC strconv.AppendQuoteToASCII from strconv/quote.go:
;; (defn AppendQuoteToASCII
;;   "AppendQuoteToASCII appends a double-quoted Go string literal representing s,\nas generated by QuoteToASCII, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, s string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) dst, ^String s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendQuoteToASCII(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__dst)), __s)"}
;;   [^Object __dst, ^String __s])

JOKER FUNC strconv.AppendQuoteToGraphic from strconv/quote.go:
;; (defn AppendQuoteToGraphic
;;   "AppendQuoteToGraphic appends a double-quoted Go string literal representing s,\nas generated by QuoteToGraphic, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, s string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) dst, ^String s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendQuoteToGraphic(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__dst)), __s)"}
;;   [^Object __dst, ^String __s])

JOKER FUNC strconv.AppendUint from strconv/itoa.go:
;; (defn AppendUint
;;   "AppendUint appends the string form of the unsigned integer i,\nas generated by FormatUint, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, i uint64, base int)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) dst, ^Number i, ^Int base]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendUint(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__dst)), __i, __base)"}
;;   [^Object __dst, ^UInt64 __i, ^Int __base])

JOKER FUNC strconv.Atoi from strconv/atoi.go:
(defn Atoi
  "Atoi is equivalent to ParseInt(s, 10, 0), converted to type int.\n\nGo input arguments: (s string)\n\nGo return type: (int, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__atoi(__s)"}
  [^String __s])

JOKER FUNC strconv.CanBackquote from strconv/quote.go:
(defn ^"Boolean" CanBackquote
  "CanBackquote reports whether the string s can be represented\nunchanged as a single-line backquoted string without control\ncharacters other than tab.\n\nGo input arguments: (s string)\n\nGo return type: bool\n\nJoker input arguments: [^String s]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strconv.CanBackquote(__s)"}
  [^String __s])

JOKER FUNC strconv.FormatBool from strconv/atob.go:
(defn ^"String" FormatBool
  "FormatBool returns \"true\" or \"false\" according to the value of b.\n\nGo input arguments: (b bool)\n\nGo return type: string\n\nJoker input arguments: [^Boolean b]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.FormatBool(__b)"}
  [^Boolean __b])

JOKER FUNC strconv.FormatFloat from strconv/ftoa.go:
;; (defn ^"String" FormatFloat
;;   "FormatFloat converts the floating-point number f to a string,\naccording to the format fmt and precision prec. It rounds the\nresult assuming that the original was obtained from a floating-point\nvalue of bitSize bits (32 for float32, 64 for float64).\n\nThe format fmt is one of\n'b' (-ddddp±ddd, a binary exponent),\n'e' (-d.dddde±dd, a decimal exponent),\n'E' (-d.ddddE±dd, a decimal exponent),\n'f' (-ddd.dddd, no exponent),\n'g' ('e' for large exponents, 'f' otherwise), or\n'G' ('E' for large exponents, 'f' otherwise).\n\nThe precision prec controls the number of digits (excluding the exponent)\nprinted by the 'e', 'E', 'f', 'g', and 'G' formats.\nFor 'e', 'E', and 'f' it is the number of digits after the decimal point.\nFor 'g' and 'G' it is the maximum number of significant digits (trailing\nzeros are removed).\nThe special precision -1 uses the smallest number of digits\nnecessary such that ParseFloat will return f exactly.\n\nGo input arguments: (f float64, fmt byte, prec int, bitSize int)\n\nGo return type: string\n\nJoker input arguments: [^Double f, ^Int fmt, ^Int prec, ^Int bitSize]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strconv.FormatFloat(__f, __fmt, __prec, __bitSize)"}
;;   [^ABEND007(find these) __f, ^Byte __fmt, ^Int __prec, ^Int __bitSize])

JOKER FUNC strconv.FormatInt from strconv/itoa.go:
(defn ^"String" FormatInt
  "FormatInt returns the string representation of i in the given base,\nfor 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'\nfor digit values >= 10.\n\nGo input arguments: (i int64, base int)\n\nGo return type: string\n\nJoker input arguments: [^Number i, ^Int base]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.FormatInt(__i, __base)"}
  [^Int64 __i, ^Int __base])

JOKER FUNC strconv.FormatUint from strconv/itoa.go:
(defn ^"String" FormatUint
  "FormatUint returns the string representation of i in the given base,\nfor 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'\nfor digit values >= 10.\n\nGo input arguments: (i uint64, base int)\n\nGo return type: string\n\nJoker input arguments: [^Number i, ^Int base]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.FormatUint(__i, __base)"}
  [^UInt64 __i, ^Int __base])

JOKER FUNC strconv.IsGraphic from strconv/quote.go:
(defn ^"Boolean" IsGraphic
  "IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such\ncharacters include letters, marks, numbers, punctuation, symbols, and\nspaces, from categories L, M, N, P, S, and Zs.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strconv.IsGraphic(__r)"}
  [^Char __r])

JOKER FUNC strconv.IsPrint from strconv/quote.go:
(defn ^"Boolean" IsPrint
  "IsPrint reports whether the rune is defined as printable by Go, with\nthe same definition as unicode.IsPrint: letters, numbers, punctuation,\nsymbols and ASCII space.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strconv.IsPrint(__r)"}
  [^Char __r])

JOKER FUNC strconv.Itoa from strconv/itoa.go:
(defn ^"String" Itoa
  "Itoa is equivalent to FormatInt(int64(i), 10).\n\nGo input arguments: (i int)\n\nGo return type: string\n\nJoker input arguments: [^Int i]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.Itoa(__i)"}
  [^Int __i])

JOKER FUNC strconv.ParseBool from strconv/atob.go:
(defn ParseBool
  "ParseBool returns the boolean value represented by the string.\nIt accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False.\nAny other value returns an error.\n\nGo input arguments: (str string)\n\nGo return type: (bool, error)\n\nJoker input arguments: [^String str]\n\nJoker return type: [Boolean Error]"
  {:added "1.0"
   :go "__parseBool(__str)"}
  [^String __str])

JOKER FUNC strconv.ParseFloat from strconv/atof.go:
;; (defn ParseFloat
;;   "ParseFloat converts the string s to a floating-point number\nwith the precision specified by bitSize: 32 for float32, or 64 for float64.\nWhen bitSize=32, the result still has type float64, but it will be\nconvertible to float32 without changing its value.\n\nIf s is well-formed and near a valid floating point number,\nParseFloat returns the nearest floating point number rounded\nusing IEEE754 unbiased rounding.\n\nThe errors that ParseFloat returns have concrete type *NumError\nand include err.Num = s.\n\nIf s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.\n\nIf s is syntactically well-formed but is more than 1/2 ULP\naway from the largest floating point number of the given size,\nParseFloat returns f = ±Inf, err.Err = ErrRange.\n\nGo input arguments: (s string, bitSize int)\n\nGo return type: (float64, error)\n\nJoker input arguments: [^String s, ^Int bitSize]\n\nJoker return type: [Double Error]"
;;   {:added "1.0"
;;    :go "__parseFloat(__s, __bitSize)"}
;;   [^String __s, ^Int __bitSize])

JOKER FUNC strconv.ParseInt from strconv/atoi.go:
(defn ParseInt
  "ParseInt interprets a string s in the given base (0, 2 to 36) and\nbit size (0 to 64) and returns the corresponding value i.\n\nIf base == 0, the base is implied by the string's prefix:\nbase 16 for \"0x\", base 8 for \"0\", and base 10 otherwise.\nFor bases 1, below 0 or above 36 an error is returned.\n\nThe bitSize argument specifies the integer type\nthat the result must fit into. Bit sizes 0, 8, 16, 32, and 64\ncorrespond to int, int8, int16, int32, and int64.\nFor a bitSize below 0 or above 64 an error is returned.\n\nThe errors that ParseInt returns have concrete type *NumError\nand include err.Num = s. If s is empty or contains invalid\ndigits, err.Err = ErrSyntax and the returned value is 0;\nif the value corresponding to s cannot be represented by a\nsigned integer of the given size, err.Err = ErrRange and the\nreturned value is the maximum magnitude integer of the\nappropriate bitSize and sign.\n\nGo input arguments: (s string, base int, bitSize int)\n\nGo return type: (i int64, err error)\n\nJoker input arguments: [^String s, ^Int base, ^Int bitSize]\n\nJoker return type: [Number Error]"
  {:added "1.0"
   :go "__parseInt(__s, __base, __bitSize)"}
  [^String __s, ^Int __base, ^Int __bitSize])

JOKER FUNC strconv.ParseUint from strconv/atoi.go:
(defn ParseUint
  "ParseUint is like ParseInt but for unsigned numbers.\n\nGo input arguments: (s string, base int, bitSize int)\n\nGo return type: (uint64, error)\n\nJoker input arguments: [^String s, ^Int base, ^Int bitSize]\n\nJoker return type: [Number Error]"
  {:added "1.0"
   :go "__parseUint(__s, __base, __bitSize)"}
  [^String __s, ^Int __base, ^Int __bitSize])

JOKER FUNC strconv.Quote from strconv/quote.go:
(defn ^"String" Quote
  "Quote returns a double-quoted Go string literal representing s. The\nreturned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\ncontrol characters and non-printable characters as defined by\nIsPrint.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.Quote(__s)"}
  [^String __s])

JOKER FUNC strconv.QuoteRune from strconv/quote.go:
(defn ^"String" QuoteRune
  "QuoteRune returns a single-quoted Go character literal representing the\nrune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100)\nfor control characters and non-printable characters as defined by IsPrint.\n\nGo input arguments: (r rune)\n\nGo return type: string\n\nJoker input arguments: [^Char r]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.QuoteRune(__r)"}
  [^Char __r])

JOKER FUNC strconv.QuoteRuneToASCII from strconv/quote.go:
(defn ^"String" QuoteRuneToASCII
  "QuoteRuneToASCII returns a single-quoted Go character literal representing\nthe rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n\\u0100) for non-ASCII characters and non-printable characters as defined\nby IsPrint.\n\nGo input arguments: (r rune)\n\nGo return type: string\n\nJoker input arguments: [^Char r]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.QuoteRuneToASCII(__r)"}
  [^Char __r])

JOKER FUNC strconv.QuoteRuneToGraphic from strconv/quote.go:
(defn ^"String" QuoteRuneToGraphic
  "QuoteRuneToGraphic returns a single-quoted Go character literal representing\nthe rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n\\u0100) for non-ASCII characters and non-printable characters as defined\nby IsGraphic.\n\nGo input arguments: (r rune)\n\nGo return type: string\n\nJoker input arguments: [^Char r]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.QuoteRuneToGraphic(__r)"}
  [^Char __r])

JOKER FUNC strconv.QuoteToASCII from strconv/quote.go:
(defn ^"String" QuoteToASCII
  "QuoteToASCII returns a double-quoted Go string literal representing s.\nThe returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\nnon-ASCII characters and non-printable characters as defined by IsPrint.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.QuoteToASCII(__s)"}
  [^String __s])

JOKER FUNC strconv.QuoteToGraphic from strconv/quote.go:
(defn ^"String" QuoteToGraphic
  "QuoteToGraphic returns a double-quoted Go string literal representing s.\nThe returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\nnon-ASCII characters and non-printable characters as defined by IsGraphic.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.QuoteToGraphic(__s)"}
  [^String __s])

JOKER FUNC strconv.Unquote from strconv/quote.go:
(defn Unquote
  "Unquote interprets s as a single-quoted, double-quoted,\nor backquoted Go string literal, returning the string value\nthat s quotes.  (If s is single-quoted, it would be a Go\ncharacter literal; Unquote returns the corresponding\none-character string.)\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__unquote(__s)"}
  [^String __s])

JOKER FUNC strconv.UnquoteChar from strconv/quote.go:
(defn UnquoteChar
  "UnquoteChar decodes the first character or byte in the escaped string\nor character literal represented by the string s.\nIt returns four values:\n\n\t1) value, the decoded Unicode code point or byte value;\n\t2) multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;\n\t3) tail, the remainder of the string after the character; and\n\t4) an error that will be nil if the character is syntactically valid.\n\nThe second argument, quote, specifies the type of literal being parsed\nand therefore which escaped quote character is permitted.\nIf set to a single quote, it permits the sequence \\' and disallows unescaped '.\nIf set to a double quote, it permits \\\" and disallows unescaped \".\nIf set to zero, it does not permit either escape and allows both quote characters to appear unescaped.\n\nGo input arguments: (s string, quote byte)\n\nGo return type: (value rune, multibyte bool, tail string, err error)\n\nJoker input arguments: [^String s, ^Int quote]\n\nJoker return type: [Char Boolean String Error]"
  {:added "1.0"
   :go "__unquoteChar(__s, __quote)"}
  [^String __s, ^Byte __quote])

JOKER TYPE go.std.strconv/NumError:
(def
  ^{:doc "A NumError records a failed conversion.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NumError"}
  NumError)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["strconv"]
    :doc "Provides a low-level interface to the strconv package.\n\nPackage strconv implements conversions to and from string representations\nof basic data types.\n\nNumeric Conversions\n\nThe most common numeric conversions are Atoi (string to int) and Itoa (int to string).\n\n\ti, err := strconv.Atoi(\"-42\")\n\ts := strconv.Itoa(-42)\n\nThese assume decimal and the Go int type.\n\nParseBool, ParseFloat, ParseInt, and ParseUint convert strings to values:\n\n\tb, err := strconv.ParseBool(\"true\")\n\tf, err := strconv.ParseFloat(\"3.1415\", 64)\n\ti, err := strconv.ParseInt(\"-42\", 10, 64)\n\tu, err := strconv.ParseUint(\"42\", 10, 64)\n\nThe parse functions return the widest type (float64, int64, and uint64),\nbut if the size argument specifies a narrower width the result can be\nconverted to that narrower type without data loss:\n\n\ts := \"2147483647\" // biggest int32\n\ti64, err := strconv.ParseInt(s, 10, 32)\n\t...\n\ti := int32(i64)\n\nFormatBool, FormatFloat, FormatInt, and FormatUint convert values to strings:\n\n\ts := strconv.FormatBool(true)\n\ts := strconv.FormatFloat(3.1415, 'E', -1, 64)\n\ts := strconv.FormatInt(-42, 16)\n\ts := strconv.FormatUint(42, 16)\n\nAppendBool, AppendFloat, AppendInt, and AppendUint are similar but\nappend the formatted value to a destination slice.\n\nString Conversions\n\nQuote and QuoteToASCII convert strings to quoted Go string literals.\nThe latter guarantees that the result is an ASCII string, by escaping\nany non-ASCII Unicode with \\u:\n\n\tq := strconv.Quote(\"Hello, 世界\")\n\tq := strconv.QuoteToASCII(\"Hello, 世界\")\n\nQuoteRune and QuoteRuneToASCII are similar but accept runes and\nreturn quoted Go rune literals.\n\nUnquote and UnquoteChar unquote Go string and rune literals.\n"
    :empty false}
  go.std.strconv)
JOKER TYPE strings.Builder from strings/builder.go:
(defn ^"GoObject" Builder.
  "Constructor for strings.Builder"
  {:added "1.0"
   :go "_ConstructBuilder(_v)"}
  [^Object _v])

JOKER TYPE strings.Reader from strings/reader.go:
(defn ^"GoObject" Reader.
  "Constructor for strings.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER TYPE strings.Replacer from strings/replace.go:
(defn ^"GoObject" Replacer.
  "Constructor for strings.Replacer"
  {:added "1.0"
   :go "_ConstructReplacer(_v)"}
  [^Object _v])

JOKER FUNC strings.Compare from strings/compare.go:
(defn ^"Int" Compare
  "Compare returns an integer comparing two strings lexicographically.\nThe result will be 0 if a==b, -1 if a < b, and +1 if a > b.\n\nCompare is included only for symmetry with package bytes.\nIt is usually clearer and always faster to use the built-in\nstring comparison operators ==, <, >, and so on.\n\nGo input arguments: (a string, b string)\n\nGo return type: int\n\nJoker input arguments: [^String a, ^String b]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.Compare(__a, __b)"}
  [^String __a, ^String __b])

JOKER FUNC strings.Contains from strings/strings.go:
(defn ^"Boolean" Contains
  "Contains reports whether substr is within s.\n\nGo input arguments: (s string, substr string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String substr]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strings.Contains(__s, __substr)"}
  [^String __s, ^String __substr])

JOKER FUNC strings.ContainsAny from strings/strings.go:
(defn ^"Boolean" ContainsAny
  "ContainsAny reports whether any Unicode code points in chars are within s.\n\nGo input arguments: (s string, chars string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String chars]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strings.ContainsAny(__s, __chars)"}
  [^String __s, ^String __chars])

JOKER FUNC strings.ContainsRune from strings/strings.go:
(defn ^"Boolean" ContainsRune
  "ContainsRune reports whether the Unicode code point r is within s.\n\nGo input arguments: (s string, r rune)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strings.ContainsRune(__s, __r)"}
  [^String __s, ^Char __r])

JOKER FUNC strings.Count from strings/strings.go:
(defn ^"Int" Count
  "Count counts the number of non-overlapping instances of substr in s.\nIf substr is an empty string, Count returns 1 + the number of Unicode code points in s.\n\nGo input arguments: (s string, substr string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String substr]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.Count(__s, __substr)"}
  [^String __s, ^String __substr])

JOKER FUNC strings.EqualFold from strings/strings.go:
(defn ^"Boolean" EqualFold
  "EqualFold reports whether s and t, interpreted as UTF-8 strings,\nare equal under Unicode case-folding.\n\nGo input arguments: (s string, t string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String t]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strings.EqualFold(__s, __t)"}
  [^String __s, ^String __t])

JOKER FUNC strings.Fields from strings/strings.go:
(defn Fields
  "Fields splits the string s around each instance of one or more consecutive white space\ncharacters, as defined by unicode.IsSpace, returning a slice of substrings of s or an\nempty slice if s contains only white space.\n\nGo input arguments: (s string)\n\nGo return type: []string\n\nJoker input arguments: [^String s]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__fields(__s)"}
  [^String __s])

JOKER FUNC strings.FieldsFunc from strings/strings.go:
;; (defn FieldsFunc
;;   "FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c)\nand returns an array of slices of s. If all code points in s satisfy f(c) or the\nstring is empty, an empty slice is returned.\nFieldsFunc makes no guarantees about the order in which it calls f(c).\nIf f does not return consistent results for a given c, FieldsFunc may crash.\n\nGo input arguments: (s string, f func)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: (vector-of String)"
;;   {:added "1.0"
;;    :go "__fieldsFunc(__s, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String __s, ^fn __f])

JOKER FUNC strings.HasPrefix from strings/strings.go:
(defn ^"Boolean" HasPrefix
  "HasPrefix tests whether the string s begins with prefix.\n\nGo input arguments: (s string, prefix string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String prefix]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strings.HasPrefix(__s, __prefix)"}
  [^String __s, ^String __prefix])

JOKER FUNC strings.HasSuffix from strings/strings.go:
(defn ^"Boolean" HasSuffix
  "HasSuffix tests whether the string s ends with suffix.\n\nGo input arguments: (s string, suffix string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String suffix]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strings.HasSuffix(__s, __suffix)"}
  [^String __s, ^String __suffix])

JOKER FUNC strings.Index from strings/strings.go:
(defn ^"Int" Index
  "Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.\n\nGo input arguments: (s string, substr string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String substr]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.Index(__s, __substr)"}
  [^String __s, ^String __substr])

JOKER FUNC strings.IndexAny from strings/strings.go:
(defn ^"Int" IndexAny
  "IndexAny returns the index of the first instance of any Unicode code point\nfrom chars in s, or -1 if no Unicode code point from chars is present in s.\n\nGo input arguments: (s string, chars string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String chars]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.IndexAny(__s, __chars)"}
  [^String __s, ^String __chars])

JOKER FUNC strings.IndexByte from strings/strings.go:
(defn ^"Int" IndexByte
  "IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.\n\nGo input arguments: (s string, c byte)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^Int c]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.IndexByte(__s, __c)"}
  [^String __s, ^Byte __c])

JOKER FUNC strings.IndexFunc from strings/strings.go:
;; (defn ^"Int" IndexFunc
;;   "IndexFunc returns the index into s of the first Unicode\ncode point satisfying f(c), or -1 if none do.\n\nGo input arguments: (s string, f func)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "strings.IndexFunc(__s, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String __s, ^fn __f])

JOKER FUNC strings.IndexRune from strings/strings.go:
(defn ^"Int" IndexRune
  "IndexRune returns the index of the first instance of the Unicode code point\nr, or -1 if rune is not present in s.\nIf r is utf8.RuneError, it returns the first instance of any\ninvalid UTF-8 byte sequence.\n\nGo input arguments: (s string, r rune)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^Char r]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.IndexRune(__s, __r)"}
  [^String __s, ^Char __r])

JOKER FUNC strings.Join from strings/strings.go:
;; (defn ^"String" Join
;;   "Join concatenates the elements of a to create a single string. The separator string\nsep is placed between elements in the resulting string.\n\nGo input arguments: (a []string, sep string)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of String) a, ^String sep]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.Join(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(__a)), __sep)"}
;;   [^Object __a, ^String __sep])

JOKER FUNC strings.LastIndex from strings/strings.go:
(defn ^"Int" LastIndex
  "LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.\n\nGo input arguments: (s string, substr string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String substr]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.LastIndex(__s, __substr)"}
  [^String __s, ^String __substr])

JOKER FUNC strings.LastIndexAny from strings/strings.go:
(defn ^"Int" LastIndexAny
  "LastIndexAny returns the index of the last instance of any Unicode code\npoint from chars in s, or -1 if no Unicode code point from chars is\npresent in s.\n\nGo input arguments: (s string, chars string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String chars]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.LastIndexAny(__s, __chars)"}
  [^String __s, ^String __chars])

JOKER FUNC strings.LastIndexByte from strings/strings.go:
(defn ^"Int" LastIndexByte
  "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.\n\nGo input arguments: (s string, c byte)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^Int c]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.LastIndexByte(__s, __c)"}
  [^String __s, ^Byte __c])

JOKER FUNC strings.LastIndexFunc from strings/strings.go:
;; (defn ^"Int" LastIndexFunc
;;   "LastIndexFunc returns the index into s of the last\nUnicode code point satisfying f(c), or -1 if none do.\n\nGo input arguments: (s string, f func)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "strings.LastIndexFunc(__s, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String __s, ^fn __f])

JOKER FUNC strings.Map from strings/strings.go:
;; (defn ^"String" Map
;;   "Map returns a copy of the string s with all its characters modified\naccording to the mapping function. If mapping returns a negative value, the character is\ndropped from the string with no replacement.\n\nGo input arguments: (mapping func, s string)\n\nGo return type: string\n\nJoker input arguments: [^fn mapping, ^String s]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.Map(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), __s)"}
;;   [^fn __mapping, ^String __s])

JOKER FUNC strings.NewReader from strings/reader.go:
(defn NewReader
  "NewReader returns a new Reader reading from s.\nIt is similar to bytes.NewBufferString but more efficient and read-only.\n\nGo input arguments: (s string)\n\nGo return type: *Reader\n\nJoker input arguments: [^String s]\n\nJoker return type: (atom-of go.std.strings/Reader)"
  {:added "1.0"
   :go "__newReader(__s)"}
  [^String __s])

JOKER FUNC strings.NewReplacer from strings/replace.go:
;; (defn NewReplacer
;;   "NewReplacer returns a new Replacer from a list of old, new string\npairs. Replacements are performed in the order they appear in the\ntarget string, without overlapping matches.\n\nGo input arguments: (oldnew ...string)\n\nGo return type: *Replacer\n\nJoker input arguments: [^(ellipsis-somehow String) oldnew]\n\nJoker return type: (atom-of go.std.strings/Replacer)"
;;   {:added "1.0"
;;    :go "__newReplacer(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(__oldnew)))"}
;;   [^String __oldnew])

JOKER FUNC strings.Repeat from strings/strings.go:
(defn ^"String" Repeat
  "Repeat returns a new string consisting of count copies of the string s.\n\nIt panics if count is negative or if\nthe result of (len(s) * count) overflows.\n\nGo input arguments: (s string, count int)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^Int count]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Repeat(__s, __count)"}
  [^String __s, ^Int __count])

JOKER FUNC strings.Replace from strings/strings.go:
(defn ^"String" Replace
  "Replace returns a copy of the string s with the first n\nnon-overlapping instances of old replaced by new.\nIf old is empty, it matches at the beginning of the string\nand after each UTF-8 sequence, yielding up to k+1 replacements\nfor a k-rune string.\nIf n < 0, there is no limit on the number of replacements.\n\nGo input arguments: (s string, old string, new string, n int)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String old, ^String new, ^Int n]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Replace(__s, __old, __new, __n)"}
  [^String __s, ^String __old, ^String __new, ^Int __n])

JOKER FUNC strings.ReplaceAll from strings/strings.go:
(defn ^"String" ReplaceAll
  "ReplaceAll returns a copy of the string s with all\nnon-overlapping instances of old replaced by new.\nIf old is empty, it matches at the beginning of the string\nand after each UTF-8 sequence, yielding up to k+1 replacements\nfor a k-rune string.\n\nGo input arguments: (s string, old string, new string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String old, ^String new]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.ReplaceAll(__s, __old, __new)"}
  [^String __s, ^String __old, ^String __new])

JOKER FUNC strings.Split from strings/strings.go:
(defn Split
  "Split slices s into all substrings separated by sep and returns a slice of\nthe substrings between those separators.\n\nIf s does not contain sep and sep is not empty, Split returns a\nslice of length 1 whose only element is s.\n\nIf sep is empty, Split splits after each UTF-8 sequence. If both s\nand sep are empty, Split returns an empty slice.\n\nIt is equivalent to SplitN with a count of -1.\n\nGo input arguments: (s string, sep string)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^String sep]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__split(__s, __sep)"}
  [^String __s, ^String __sep])

JOKER FUNC strings.SplitAfter from strings/strings.go:
(defn SplitAfter
  "SplitAfter slices s into all substrings after each instance of sep and\nreturns a slice of those substrings.\n\nIf s does not contain sep and sep is not empty, SplitAfter returns\na slice of length 1 whose only element is s.\n\nIf sep is empty, SplitAfter splits after each UTF-8 sequence. If\nboth s and sep are empty, SplitAfter returns an empty slice.\n\nIt is equivalent to SplitAfterN with a count of -1.\n\nGo input arguments: (s string, sep string)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^String sep]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__splitAfter(__s, __sep)"}
  [^String __s, ^String __sep])

JOKER FUNC strings.SplitAfterN from strings/strings.go:
(defn SplitAfterN
  "SplitAfterN slices s into substrings after each instance of sep and\nreturns a slice of those substrings.\n\nThe count determines the number of substrings to return:\n  n > 0: at most n substrings; the last substring will be the unsplit remainder.\n  n == 0: the result is nil (zero substrings)\n  n < 0: all substrings\n\nEdge cases for s and sep (for example, empty strings) are handled\nas described in the documentation for SplitAfter.\n\nGo input arguments: (s string, sep string, n int)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^String sep, ^Int n]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__splitAfterN(__s, __sep, __n)"}
  [^String __s, ^String __sep, ^Int __n])

JOKER FUNC strings.SplitN from strings/strings.go:
(defn SplitN
  "SplitN slices s into substrings separated by sep and returns a slice of\nthe substrings between those separators.\n\nThe count determines the number of substrings to return:\n  n > 0: at most n substrings; the last substring will be the unsplit remainder.\n  n == 0: the result is nil (zero substrings)\n  n < 0: all substrings\n\nEdge cases for s and sep (for example, empty strings) are handled\nas described in the documentation for Split.\n\nGo input arguments: (s string, sep string, n int)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^String sep, ^Int n]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__splitN(__s, __sep, __n)"}
  [^String __s, ^String __sep, ^Int __n])

JOKER FUNC strings.Title from strings/strings.go:
(defn ^"String" Title
  "Title returns a copy of the string s with all Unicode letters that begin words\nmapped to their title case.\n\nBUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Title(__s)"}
  [^String __s])

JOKER FUNC strings.ToLower from strings/strings.go:
(defn ^"String" ToLower
  "ToLower returns a copy of the string s with all Unicode letters mapped to their lower case.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.ToLower(__s)"}
  [^String __s])

JOKER FUNC strings.ToLowerSpecial from strings/strings.go:
;; (defn ^"String" ToLowerSpecial
;;   "ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their\nlower case using the case mapping specified by c.\n\nGo input arguments: (c unicode.SpecialCase, s string)\n\nGo return type: string\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^String s]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.ToLowerSpecial(*__c, __s)"}
;;   [^unicode/SpecialCase __c, ^String __s])

JOKER FUNC strings.ToTitle from strings/strings.go:
(defn ^"String" ToTitle
  "ToTitle returns a copy of the string s with all Unicode letters mapped to their title case.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.ToTitle(__s)"}
  [^String __s])

JOKER FUNC strings.ToTitleSpecial from strings/strings.go:
;; (defn ^"String" ToTitleSpecial
;;   "ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their\ntitle case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s string)\n\nGo return type: string\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^String s]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.ToTitleSpecial(*__c, __s)"}
;;   [^unicode/SpecialCase __c, ^String __s])

JOKER FUNC strings.ToUpper from strings/strings.go:
(defn ^"String" ToUpper
  "ToUpper returns a copy of the string s with all Unicode letters mapped to their upper case.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.ToUpper(__s)"}
  [^String __s])

JOKER FUNC strings.ToUpperSpecial from strings/strings.go:
;; (defn ^"String" ToUpperSpecial
;;   "ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their\nupper case using the case mapping specified by c.\n\nGo input arguments: (c unicode.SpecialCase, s string)\n\nGo return type: string\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^String s]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.ToUpperSpecial(*__c, __s)"}
;;   [^unicode/SpecialCase __c, ^String __s])

JOKER FUNC strings.Trim from strings/strings.go:
(defn ^"String" Trim
  "Trim returns a slice of the string s with all leading and\ntrailing Unicode code points contained in cutset removed.\n\nGo input arguments: (s string, cutset string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String cutset]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Trim(__s, __cutset)"}
  [^String __s, ^String __cutset])

JOKER FUNC strings.TrimFunc from strings/strings.go:
;; (defn ^"String" TrimFunc
;;   "TrimFunc returns a slice of the string s with all leading\nand trailing Unicode code points c satisfying f(c) removed.\n\nGo input arguments: (s string, f func)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.TrimFunc(__s, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String __s, ^fn __f])

JOKER FUNC strings.TrimLeft from strings/strings.go:
(defn ^"String" TrimLeft
  "TrimLeft returns a slice of the string s with all leading\nUnicode code points contained in cutset removed.\n\nTo remove a prefix, use TrimPrefix instead.\n\nGo input arguments: (s string, cutset string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String cutset]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimLeft(__s, __cutset)"}
  [^String __s, ^String __cutset])

JOKER FUNC strings.TrimLeftFunc from strings/strings.go:
;; (defn ^"String" TrimLeftFunc
;;   "TrimLeftFunc returns a slice of the string s with all leading\nUnicode code points c satisfying f(c) removed.\n\nGo input arguments: (s string, f func)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.TrimLeftFunc(__s, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String __s, ^fn __f])

JOKER FUNC strings.TrimPrefix from strings/strings.go:
(defn ^"String" TrimPrefix
  "TrimPrefix returns s without the provided leading prefix string.\nIf s doesn't start with prefix, s is returned unchanged.\n\nGo input arguments: (s string, prefix string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String prefix]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimPrefix(__s, __prefix)"}
  [^String __s, ^String __prefix])

JOKER FUNC strings.TrimRight from strings/strings.go:
(defn ^"String" TrimRight
  "TrimRight returns a slice of the string s, with all trailing\nUnicode code points contained in cutset removed.\n\nTo remove a suffix, use TrimSuffix instead.\n\nGo input arguments: (s string, cutset string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String cutset]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimRight(__s, __cutset)"}
  [^String __s, ^String __cutset])

JOKER FUNC strings.TrimRightFunc from strings/strings.go:
;; (defn ^"String" TrimRightFunc
;;   "TrimRightFunc returns a slice of the string s with all trailing\nUnicode code points c satisfying f(c) removed.\n\nGo input arguments: (s string, f func)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.TrimRightFunc(__s, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String __s, ^fn __f])

JOKER FUNC strings.TrimSpace from strings/strings.go:
(defn ^"String" TrimSpace
  "TrimSpace returns a slice of the string s, with all leading\nand trailing white space removed, as defined by Unicode.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimSpace(__s)"}
  [^String __s])

JOKER FUNC strings.TrimSuffix from strings/strings.go:
(defn ^"String" TrimSuffix
  "TrimSuffix returns s without the provided trailing suffix string.\nIf s doesn't end with suffix, s is returned unchanged.\n\nGo input arguments: (s string, suffix string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String suffix]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimSuffix(__s, __suffix)"}
  [^String __s, ^String __suffix])

JOKER TYPE go.std.strings/Builder:
(def
  ^{:doc "A Builder is used to efficiently build a string using Write methods.\nIt minimizes memory copying. The zero value is ready to use.\nDo not copy a non-zero Builder.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Builder"}
  Builder)

JOKER TYPE go.std.strings/Reader:
(def
  ^{:doc "A Reader implements the io.Reader, io.ReaderAt, io.Seeker, io.WriterTo,\nio.ByteScanner, and io.RuneScanner interfaces by reading\nfrom a string.\nThe zero value for Reader operates like a Reader of an empty string.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Reader"}
  Reader)

JOKER TYPE go.std.strings/Replacer:
(def
  ^{:doc "Replacer replaces a list of strings with replacements.\nIt is safe for concurrent use by multiple goroutines.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Replacer"}
  Replacer)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["strings"]
    :doc "Provides a low-level interface to the strings package.\n\nPackage strings implements simple functions to manipulate UTF-8 encoded strings.\n\nFor information about UTF-8 strings in Go, see https://blog.golang.org/strings.\n"
    :empty false}
  go.std.strings)
JOKER TYPE sync.Cond from sync/cond.go:
;; (defn ^"GoObject" Cond.
;;   "Constructor for sync.Cond"
;;   {:added "1.0"
;;    :go "_ConstructCond(_v)"}
;;   [^Object _v])

JOKER TYPE sync.Locker from sync/mutex.go:
;; (defn ^"GoObject" Locker.
;;   "Constructor for sync.Locker"
;;   {:added "1.0"
;;    :go "_ConstructLocker(_v)"}
;;   [^Object _v])

JOKER TYPE sync.Map from sync/map.go:
(defn ^"GoObject" Map.
  "Constructor for sync.Map"
  {:added "1.0"
   :go "_ConstructMap(_v)"}
  [^Object _v])

JOKER TYPE sync.Mutex from sync/mutex.go:
(defn ^"GoObject" Mutex.
  "Constructor for sync.Mutex"
  {:added "1.0"
   :go "_ConstructMutex(_v)"}
  [^Object _v])

JOKER TYPE sync.Once from sync/once.go:
(defn ^"GoObject" Once.
  "Constructor for sync.Once"
  {:added "1.0"
   :go "_ConstructOnce(_v)"}
  [^Object _v])

JOKER TYPE sync.Pool from sync/pool.go:
;; (defn ^"GoObject" Pool.
;;   "Constructor for sync.Pool"
;;   {:added "1.0"
;;    :go "_ConstructPool(_v)"}
;;   [^Object _v])

JOKER TYPE sync.RWMutex from sync/rwmutex.go:
(defn ^"GoObject" RWMutex.
  "Constructor for sync.RWMutex"
  {:added "1.0"
   :go "_ConstructRWMutex(_v)"}
  [^Object _v])

JOKER TYPE sync.WaitGroup from sync/waitgroup.go:
(defn ^"GoObject" WaitGroup.
  "Constructor for sync.WaitGroup"
  {:added "1.0"
   :go "_ConstructWaitGroup(_v)"}
  [^Object _v])

JOKER FUNC sync.NewCond from sync/cond.go:
(defn NewCond
  "NewCond returns a new Cond with Locker l.\n\nGo input arguments: (l Locker)\n\nGo return type: *Cond\n\nJoker input arguments: [^go.std.sync/Locker l]\n\nJoker return type: (atom-of go.std.sync/Cond)"
  {:added "1.0"
   :go "__newCond(*__l)"}
  [^sync/Locker __l])

JOKER TYPE go.std.sync/Cond:
(def
  ^{:doc "Cond implements a condition variable, a rendezvous point\nfor goroutines waiting for or announcing the occurrence\nof an event.\n\nEach Cond has an associated Locker L (often a *Mutex or *RWMutex),\nwhich must be held when changing the condition and\nwhen calling the Wait method.\n\nA Cond must not be copied after first use.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Cond"}
  Cond)

JOKER TYPE go.std.sync/Locker:
(def
  ^{:doc "A Locker represents an object that can be locked and unlocked.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Locker"}
  Locker)

JOKER TYPE go.std.sync/Map:
(def
  ^{:doc "Map is like a Go map[interface{}]interface{} but is safe for concurrent use\nby multiple goroutines without additional locking or coordination.\nLoads, stores, and deletes run in amortized constant time.\n\nThe Map type is specialized. Most code should use a plain Go map instead,\nwith separate locking or coordination, for better type safety and to make it\neasier to maintain other invariants along with the map content.\n\nThe Map type is optimized for two common use cases: (1) when the entry for a given\nkey is only ever written once but read many times, as in caches that only grow,\nor (2) when multiple goroutines read, write, and overwrite entries for disjoint\nsets of keys. In these two cases, use of a Map may significantly reduce lock\ncontention compared to a Go map paired with a separate Mutex or RWMutex.\n\nThe zero Map is empty and ready for use. A Map must not be copied after first use.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Map"}
  Map)

JOKER TYPE go.std.sync/Mutex:
(def
  ^{:doc "A Mutex is a mutual exclusion lock.\nThe zero value for a Mutex is an unlocked mutex.\n\nA Mutex must not be copied after first use.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Mutex"}
  Mutex)

JOKER TYPE go.std.sync/Once:
(def
  ^{:doc "Once is an object that will perform exactly one action.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Once"}
  Once)

JOKER TYPE go.std.sync/Pool:
(def
  ^{:doc "A Pool is a set of temporary objects that may be individually saved and\nretrieved.\n\nAny item stored in the Pool may be removed automatically at any time without\nnotification. If the Pool holds the only reference when this happens, the\nitem might be deallocated.\n\nA Pool is safe for use by multiple goroutines simultaneously.\n\nPool's purpose is to cache allocated but unused items for later reuse,\nrelieving pressure on the garbage collector. That is, it makes it easy to\nbuild efficient, thread-safe free lists. However, it is not suitable for all\nfree lists.\n\nAn appropriate use of a Pool is to manage a group of temporary items\nsilently shared among and potentially reused by concurrent independent\nclients of a package. Pool provides a way to amortize allocation overhead\nacross many clients.\n\nAn example of good use of a Pool is in the fmt package, which maintains a\ndynamically-sized store of temporary output buffers. The store scales under\nload (when many goroutines are actively printing) and shrinks when\nquiescent.\n\nOn the other hand, a free list maintained as part of a short-lived object is\nnot a suitable use for a Pool, since the overhead does not amortize well in\nthat scenario. It is more efficient to have such objects implement their own\nfree list.\n\nA Pool must not be copied after first use.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Pool"}
  Pool)

JOKER TYPE go.std.sync/RWMutex:
(def
  ^{:doc "A RWMutex is a reader/writer mutual exclusion lock.\nThe lock can be held by an arbitrary number of readers or a single writer.\nThe zero value for a RWMutex is an unlocked mutex.\n\nA RWMutex must not be copied after first use.\n\nIf a goroutine holds a RWMutex for reading and another goroutine might\ncall Lock, no goroutine should expect to be able to acquire a read lock\nuntil the initial read lock is released. In particular, this prohibits\nrecursive read locking. This is to ensure that the lock eventually becomes\navailable; a blocked Lock call excludes new readers from acquiring the\nlock.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RWMutex"}
  RWMutex)

JOKER TYPE go.std.sync/WaitGroup:
(def
  ^{:doc "A WaitGroup waits for a collection of goroutines to finish.\nThe main goroutine calls Add to set the number of\ngoroutines to wait for. Then each of the goroutines\nruns and calls Done when finished. At the same time,\nWait can be used to block until all goroutines have finished.\n\nA WaitGroup must not be copied after first use.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_WaitGroup"}
  WaitGroup)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the sync package.\n\nPackage sync provides basic synchronization primitives such as mutual\nexclusion locks. Other than the Once and WaitGroup types, most are intended\nfor use by low-level library routines. Higher-level synchronization is\nbetter done via channels and communication.\n\nValues containing the types defined in this package should not be copied.\n"
    :empty false}
  go.std.sync)
JOKER FUNC sync/atomic.AddInt32 from sync/atomic/doc.go:
;; (defn AddInt32
;;   "AddInt32 atomically adds delta to *addr and returns the new value.\n\nGo input arguments: (addr *int32, delta int32)\n\nGo return type: int32\n\nJoker input arguments: [^(atom-of Int) addr, ^Int delta]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__addInt32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint32(__addr)), __delta)"}
;;   [^Object __addr, ^Int32 __delta])

JOKER FUNC sync/atomic.AddInt64 from sync/atomic/doc.go:
;; (defn AddInt64
;;   "AddInt64 atomically adds delta to *addr and returns the new value.\n\nGo input arguments: (addr *int64, delta int64)\n\nGo return type: int64\n\nJoker input arguments: [^(atom-of Number) addr, ^Number delta]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__addInt64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(__addr)), __delta)"}
;;   [^Object __addr, ^Int64 __delta])

JOKER FUNC sync/atomic.AddUint32 from sync/atomic/doc.go:
;; (defn AddUint32
;;   "AddUint32 atomically adds delta to *addr and returns the new value.\nTo subtract a signed positive constant value c from x, do AddUint32(&x, ^uint32(c-1)).\nIn particular, to decrement x, do AddUint32(&x, ^uint32(0)).\n\nGo input arguments: (addr *uint32, delta uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^(atom-of Number) addr, ^Number delta]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__addUint32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint32(__addr)), __delta)"}
;;   [^Object __addr, ^UInt32 __delta])

JOKER FUNC sync/atomic.AddUint64 from sync/atomic/doc.go:
;; (defn AddUint64
;;   "AddUint64 atomically adds delta to *addr and returns the new value.\nTo subtract a signed positive constant value c from x, do AddUint64(&x, ^uint64(c-1)).\nIn particular, to decrement x, do AddUint64(&x, ^uint64(0)).\n\nGo input arguments: (addr *uint64, delta uint64)\n\nGo return type: uint64\n\nJoker input arguments: [^(atom-of Number) addr, ^Number delta]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__addUint64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint64(__addr)), __delta)"}
;;   [^Object __addr, ^UInt64 __delta])

JOKER FUNC sync/atomic.AddUintptr from sync/atomic/doc.go:
;; (defn AddUintptr
;;   "AddUintptr atomically adds delta to *addr and returns the new value.\n\nGo input arguments: (addr *uintptr, delta uintptr)\n\nGo return type: uintptr\n\nJoker input arguments: [^(atom-of Number) addr, ^Number delta]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__addUintptr(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuintptr(__addr)), __delta)"}
;;   [^Object __addr, ^UIntPtr __delta])

JOKER FUNC sync/atomic.CompareAndSwapInt32 from sync/atomic/doc.go:
;; (defn ^"Boolean" CompareAndSwapInt32
;;   "CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.\n\nGo input arguments: (addr *int32, old int32, new int32)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of Int) addr, ^Int old, ^Int new]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapInt32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint32(__addr)), __old, __new)"}
;;   [^Object __addr, ^Int32 __old, ^Int32 __new])

JOKER FUNC sync/atomic.CompareAndSwapInt64 from sync/atomic/doc.go:
;; (defn ^"Boolean" CompareAndSwapInt64
;;   "CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value.\n\nGo input arguments: (addr *int64, old int64, new int64)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of Number) addr, ^Number old, ^Number new]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapInt64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(__addr)), __old, __new)"}
;;   [^Object __addr, ^Int64 __old, ^Int64 __new])

JOKER FUNC sync/atomic.CompareAndSwapPointer from sync/atomic/doc.go:
;; (defn ^"Boolean" CompareAndSwapPointer
;;   "CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value.\n\nGo input arguments: (addr *unsafe.Pointer, old unsafe.Pointer, new unsafe.Pointer)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.unsafe/Pointer) addr, ^go.std.unsafe/Pointer old, ^go.std.unsafe/Pointer new]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapPointer(__addr, *__old, *__new)"}
;;   [^unsafe/Pointer __addr, ^unsafe/Pointer __old, ^unsafe/Pointer __new])

JOKER FUNC sync/atomic.CompareAndSwapUint32 from sync/atomic/doc.go:
;; (defn ^"Boolean" CompareAndSwapUint32
;;   "CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value.\n\nGo input arguments: (addr *uint32, old uint32, new uint32)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of Number) addr, ^Number old, ^Number new]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapUint32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint32(__addr)), __old, __new)"}
;;   [^Object __addr, ^UInt32 __old, ^UInt32 __new])

JOKER FUNC sync/atomic.CompareAndSwapUint64 from sync/atomic/doc.go:
;; (defn ^"Boolean" CompareAndSwapUint64
;;   "CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value.\n\nGo input arguments: (addr *uint64, old uint64, new uint64)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of Number) addr, ^Number old, ^Number new]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapUint64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint64(__addr)), __old, __new)"}
;;   [^Object __addr, ^UInt64 __old, ^UInt64 __new])

JOKER FUNC sync/atomic.CompareAndSwapUintptr from sync/atomic/doc.go:
;; (defn ^"Boolean" CompareAndSwapUintptr
;;   "CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value.\n\nGo input arguments: (addr *uintptr, old uintptr, new uintptr)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of Number) addr, ^Number old, ^Number new]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapUintptr(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuintptr(__addr)), __old, __new)"}
;;   [^Object __addr, ^UIntPtr __old, ^UIntPtr __new])

JOKER FUNC sync/atomic.LoadInt32 from sync/atomic/doc.go:
;; (defn LoadInt32
;;   "LoadInt32 atomically loads *addr.\n\nGo input arguments: (addr *int32)\n\nGo return type: int32\n\nJoker input arguments: [^(atom-of Int) addr]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__loadInt32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint32(__addr)))"}
;;   [^Object __addr])

JOKER FUNC sync/atomic.LoadInt64 from sync/atomic/doc.go:
;; (defn LoadInt64
;;   "LoadInt64 atomically loads *addr.\n\nGo input arguments: (addr *int64)\n\nGo return type: int64\n\nJoker input arguments: [^(atom-of Number) addr]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__loadInt64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(__addr)))"}
;;   [^Object __addr])

JOKER FUNC sync/atomic.LoadPointer from sync/atomic/doc.go:
;; (defn LoadPointer
;;   "LoadPointer atomically loads *addr.\n\nGo input arguments: (addr *unsafe.Pointer)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of go.std.unsafe/Pointer) addr]\n\nJoker return type: ABEND042(post.go: cannot find typename unsafe.Pointer)"
;;   {:added "1.0"
;;    :go "__loadPointer(__addr)"}
;;   [^unsafe/Pointer __addr])

JOKER FUNC sync/atomic.LoadUint32 from sync/atomic/doc.go:
;; (defn LoadUint32
;;   "LoadUint32 atomically loads *addr.\n\nGo input arguments: (addr *uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^(atom-of Number) addr]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__loadUint32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint32(__addr)))"}
;;   [^Object __addr])

JOKER FUNC sync/atomic.LoadUint64 from sync/atomic/doc.go:
;; (defn LoadUint64
;;   "LoadUint64 atomically loads *addr.\n\nGo input arguments: (addr *uint64)\n\nGo return type: uint64\n\nJoker input arguments: [^(atom-of Number) addr]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__loadUint64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint64(__addr)))"}
;;   [^Object __addr])

JOKER FUNC sync/atomic.LoadUintptr from sync/atomic/doc.go:
;; (defn LoadUintptr
;;   "LoadUintptr atomically loads *addr.\n\nGo input arguments: (addr *uintptr)\n\nGo return type: uintptr\n\nJoker input arguments: [^(atom-of Number) addr]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__loadUintptr(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuintptr(__addr)))"}
;;   [^Object __addr])

JOKER FUNC sync/atomic.StoreInt32 from sync/atomic/doc.go:
;; (defn StoreInt32
;;   "StoreInt32 atomically stores val into *addr.\n\nGo input arguments: (addr *int32, val int32)\n\nJoker input arguments: [^(atom-of Int) addr, ^Int val]"
;;   {:added "1.0"
;;    :go "__storeInt32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint32(__addr)), __val)"}
;;   [^Object __addr, ^Int32 __val])

JOKER FUNC sync/atomic.StoreInt64 from sync/atomic/doc.go:
;; (defn StoreInt64
;;   "StoreInt64 atomically stores val into *addr.\n\nGo input arguments: (addr *int64, val int64)\n\nJoker input arguments: [^(atom-of Number) addr, ^Number val]"
;;   {:added "1.0"
;;    :go "__storeInt64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(__addr)), __val)"}
;;   [^Object __addr, ^Int64 __val])

JOKER FUNC sync/atomic.StorePointer from sync/atomic/doc.go:
;; (defn StorePointer
;;   "StorePointer atomically stores val into *addr.\n\nGo input arguments: (addr *unsafe.Pointer, val unsafe.Pointer)\n\nJoker input arguments: [^(atom-of go.std.unsafe/Pointer) addr, ^go.std.unsafe/Pointer val]"
;;   {:added "1.0"
;;    :go "__storePointer(__addr, *__val)"}
;;   [^unsafe/Pointer __addr, ^unsafe/Pointer __val])

JOKER FUNC sync/atomic.StoreUint32 from sync/atomic/doc.go:
;; (defn StoreUint32
;;   "StoreUint32 atomically stores val into *addr.\n\nGo input arguments: (addr *uint32, val uint32)\n\nJoker input arguments: [^(atom-of Number) addr, ^Number val]"
;;   {:added "1.0"
;;    :go "__storeUint32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint32(__addr)), __val)"}
;;   [^Object __addr, ^UInt32 __val])

JOKER FUNC sync/atomic.StoreUint64 from sync/atomic/doc.go:
;; (defn StoreUint64
;;   "StoreUint64 atomically stores val into *addr.\n\nGo input arguments: (addr *uint64, val uint64)\n\nJoker input arguments: [^(atom-of Number) addr, ^Number val]"
;;   {:added "1.0"
;;    :go "__storeUint64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint64(__addr)), __val)"}
;;   [^Object __addr, ^UInt64 __val])

JOKER FUNC sync/atomic.StoreUintptr from sync/atomic/doc.go:
;; (defn StoreUintptr
;;   "StoreUintptr atomically stores val into *addr.\n\nGo input arguments: (addr *uintptr, val uintptr)\n\nJoker input arguments: [^(atom-of Number) addr, ^Number val]"
;;   {:added "1.0"
;;    :go "__storeUintptr(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuintptr(__addr)), __val)"}
;;   [^Object __addr, ^UIntPtr __val])

JOKER FUNC sync/atomic.SwapInt32 from sync/atomic/doc.go:
;; (defn SwapInt32
;;   "SwapInt32 atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *int32, new int32)\n\nGo return type: int32\n\nJoker input arguments: [^(atom-of Int) addr, ^Int new]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__swapInt32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint32(__addr)), __new)"}
;;   [^Object __addr, ^Int32 __new])

JOKER FUNC sync/atomic.SwapInt64 from sync/atomic/doc.go:
;; (defn SwapInt64
;;   "SwapInt64 atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *int64, new int64)\n\nGo return type: int64\n\nJoker input arguments: [^(atom-of Number) addr, ^Number new]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__swapInt64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(__addr)), __new)"}
;;   [^Object __addr, ^Int64 __new])

JOKER FUNC sync/atomic.SwapPointer from sync/atomic/doc.go:
;; (defn SwapPointer
;;   "SwapPointer atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *unsafe.Pointer, new unsafe.Pointer)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of go.std.unsafe/Pointer) addr, ^go.std.unsafe/Pointer new]\n\nJoker return type: ABEND042(post.go: cannot find typename unsafe.Pointer)"
;;   {:added "1.0"
;;    :go "__swapPointer(__addr, *__new)"}
;;   [^unsafe/Pointer __addr, ^unsafe/Pointer __new])

JOKER FUNC sync/atomic.SwapUint32 from sync/atomic/doc.go:
;; (defn SwapUint32
;;   "SwapUint32 atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *uint32, new uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^(atom-of Number) addr, ^Number new]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__swapUint32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint32(__addr)), __new)"}
;;   [^Object __addr, ^UInt32 __new])

JOKER FUNC sync/atomic.SwapUint64 from sync/atomic/doc.go:
;; (defn SwapUint64
;;   "SwapUint64 atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *uint64, new uint64)\n\nGo return type: uint64\n\nJoker input arguments: [^(atom-of Number) addr, ^Number new]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__swapUint64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint64(__addr)), __new)"}
;;   [^Object __addr, ^UInt64 __new])

JOKER FUNC sync/atomic.SwapUintptr from sync/atomic/doc.go:
;; (defn SwapUintptr
;;   "SwapUintptr atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *uintptr, new uintptr)\n\nGo return type: uintptr\n\nJoker input arguments: [^(atom-of Number) addr, ^Number new]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__swapUintptr(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuintptr(__addr)), __new)"}
;;   [^Object __addr, ^UIntPtr __new])

JOKER TYPE go.std.sync.atomic/Value:
(def
  ^{:doc "A Value provides an atomic load and store of a consistently typed value.\nThe zero value for a Value returns nil from Load.\nOnce Store has been called, a Value must not be copied.\n\nA Value must not be copied after first use.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Value"}
  Value)

JOKER CONSTANT AF_ALG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_ALG"}
  AF_ALG)

JOKER CONSTANT AF_APPLETALK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_APPLETALK"}
  AF_APPLETALK)

JOKER CONSTANT AF_ASH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_ASH"}
  AF_ASH)

JOKER CONSTANT AF_ATMPVC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_ATMPVC"}
  AF_ATMPVC)

JOKER CONSTANT AF_ATMSVC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_ATMSVC"}
  AF_ATMSVC)

JOKER CONSTANT AF_AX25 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_AX25"}
  AF_AX25)

JOKER CONSTANT AF_BLUETOOTH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_BLUETOOTH"}
  AF_BLUETOOTH)

JOKER CONSTANT AF_BRIDGE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_BRIDGE"}
  AF_BRIDGE)

JOKER CONSTANT AF_CAIF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_CAIF"}
  AF_CAIF)

JOKER CONSTANT AF_CAN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_CAN"}
  AF_CAN)

JOKER CONSTANT AF_DECnet from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_DECnet"}
  AF_DECnet)

JOKER CONSTANT AF_ECONET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_ECONET"}
  AF_ECONET)

JOKER CONSTANT AF_FILE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_FILE"}
  AF_FILE)

JOKER CONSTANT AF_IEEE802154 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_IEEE802154"}
  AF_IEEE802154)

JOKER CONSTANT AF_INET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_INET"}
  AF_INET)

JOKER CONSTANT AF_INET6 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_INET6"}
  AF_INET6)

JOKER CONSTANT AF_IPX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_IPX"}
  AF_IPX)

JOKER CONSTANT AF_IRDA from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_IRDA"}
  AF_IRDA)

JOKER CONSTANT AF_ISDN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_ISDN"}
  AF_ISDN)

JOKER CONSTANT AF_IUCV from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_IUCV"}
  AF_IUCV)

JOKER CONSTANT AF_KEY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_KEY"}
  AF_KEY)

JOKER CONSTANT AF_LLC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_LLC"}
  AF_LLC)

JOKER CONSTANT AF_LOCAL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_LOCAL"}
  AF_LOCAL)

JOKER CONSTANT AF_MAX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_MAX"}
  AF_MAX)

JOKER CONSTANT AF_NETBEUI from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_NETBEUI"}
  AF_NETBEUI)

JOKER CONSTANT AF_NETLINK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_NETLINK"}
  AF_NETLINK)

JOKER CONSTANT AF_NETROM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_NETROM"}
  AF_NETROM)

JOKER CONSTANT AF_PACKET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_PACKET"}
  AF_PACKET)

JOKER CONSTANT AF_PHONET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_PHONET"}
  AF_PHONET)

JOKER CONSTANT AF_PPPOX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_PPPOX"}
  AF_PPPOX)

JOKER CONSTANT AF_RDS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_RDS"}
  AF_RDS)

JOKER CONSTANT AF_ROSE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_ROSE"}
  AF_ROSE)

JOKER CONSTANT AF_ROUTE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_ROUTE"}
  AF_ROUTE)

JOKER CONSTANT AF_RXRPC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_RXRPC"}
  AF_RXRPC)

JOKER CONSTANT AF_SECURITY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_SECURITY"}
  AF_SECURITY)

JOKER CONSTANT AF_SNA from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_SNA"}
  AF_SNA)

JOKER CONSTANT AF_TIPC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_TIPC"}
  AF_TIPC)

JOKER CONSTANT AF_UNIX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_UNIX"}
  AF_UNIX)

JOKER CONSTANT AF_UNSPEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_UNSPEC"}
  AF_UNSPEC)

JOKER CONSTANT AF_WANPIPE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_WANPIPE"}
  AF_WANPIPE)

JOKER CONSTANT AF_X25 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.AF_X25"}
  AF_X25)

JOKER CONSTANT ARPHRD_ADAPT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_ADAPT"}
  ARPHRD_ADAPT)

JOKER CONSTANT ARPHRD_APPLETLK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_APPLETLK"}
  ARPHRD_APPLETLK)

JOKER CONSTANT ARPHRD_ARCNET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_ARCNET"}
  ARPHRD_ARCNET)

JOKER CONSTANT ARPHRD_ASH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_ASH"}
  ARPHRD_ASH)

JOKER CONSTANT ARPHRD_ATM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_ATM"}
  ARPHRD_ATM)

JOKER CONSTANT ARPHRD_AX25 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_AX25"}
  ARPHRD_AX25)

JOKER CONSTANT ARPHRD_BIF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_BIF"}
  ARPHRD_BIF)

JOKER CONSTANT ARPHRD_CHAOS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_CHAOS"}
  ARPHRD_CHAOS)

JOKER CONSTANT ARPHRD_CISCO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_CISCO"}
  ARPHRD_CISCO)

JOKER CONSTANT ARPHRD_CSLIP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_CSLIP"}
  ARPHRD_CSLIP)

JOKER CONSTANT ARPHRD_CSLIP6 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_CSLIP6"}
  ARPHRD_CSLIP6)

JOKER CONSTANT ARPHRD_DDCMP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_DDCMP"}
  ARPHRD_DDCMP)

JOKER CONSTANT ARPHRD_DLCI from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_DLCI"}
  ARPHRD_DLCI)

JOKER CONSTANT ARPHRD_ECONET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_ECONET"}
  ARPHRD_ECONET)

JOKER CONSTANT ARPHRD_EETHER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_EETHER"}
  ARPHRD_EETHER)

JOKER CONSTANT ARPHRD_ETHER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_ETHER"}
  ARPHRD_ETHER)

JOKER CONSTANT ARPHRD_EUI64 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_EUI64"}
  ARPHRD_EUI64)

JOKER CONSTANT ARPHRD_FCAL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_FCAL"}
  ARPHRD_FCAL)

JOKER CONSTANT ARPHRD_FCFABRIC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_FCFABRIC"}
  ARPHRD_FCFABRIC)

JOKER CONSTANT ARPHRD_FCPL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_FCPL"}
  ARPHRD_FCPL)

JOKER CONSTANT ARPHRD_FCPP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_FCPP"}
  ARPHRD_FCPP)

JOKER CONSTANT ARPHRD_FDDI from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_FDDI"}
  ARPHRD_FDDI)

JOKER CONSTANT ARPHRD_FRAD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_FRAD"}
  ARPHRD_FRAD)

JOKER CONSTANT ARPHRD_HDLC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_HDLC"}
  ARPHRD_HDLC)

JOKER CONSTANT ARPHRD_HIPPI from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_HIPPI"}
  ARPHRD_HIPPI)

JOKER CONSTANT ARPHRD_HWX25 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_HWX25"}
  ARPHRD_HWX25)

JOKER CONSTANT ARPHRD_IEEE1394 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_IEEE1394"}
  ARPHRD_IEEE1394)

JOKER CONSTANT ARPHRD_IEEE802 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_IEEE802"}
  ARPHRD_IEEE802)

JOKER CONSTANT ARPHRD_IEEE80211 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_IEEE80211"}
  ARPHRD_IEEE80211)

JOKER CONSTANT ARPHRD_IEEE80211_PRISM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_IEEE80211_PRISM"}
  ARPHRD_IEEE80211_PRISM)

JOKER CONSTANT ARPHRD_IEEE80211_RADIOTAP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_IEEE80211_RADIOTAP"}
  ARPHRD_IEEE80211_RADIOTAP)

JOKER CONSTANT ARPHRD_IEEE802154 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_IEEE802154"}
  ARPHRD_IEEE802154)

JOKER CONSTANT ARPHRD_IEEE802154_PHY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_IEEE802154_PHY"}
  ARPHRD_IEEE802154_PHY)

JOKER CONSTANT ARPHRD_IEEE802_TR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_IEEE802_TR"}
  ARPHRD_IEEE802_TR)

JOKER CONSTANT ARPHRD_INFINIBAND from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_INFINIBAND"}
  ARPHRD_INFINIBAND)

JOKER CONSTANT ARPHRD_IPDDP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_IPDDP"}
  ARPHRD_IPDDP)

JOKER CONSTANT ARPHRD_IPGRE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_IPGRE"}
  ARPHRD_IPGRE)

JOKER CONSTANT ARPHRD_IRDA from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_IRDA"}
  ARPHRD_IRDA)

JOKER CONSTANT ARPHRD_LAPB from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_LAPB"}
  ARPHRD_LAPB)

JOKER CONSTANT ARPHRD_LOCALTLK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_LOCALTLK"}
  ARPHRD_LOCALTLK)

JOKER CONSTANT ARPHRD_LOOPBACK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_LOOPBACK"}
  ARPHRD_LOOPBACK)

JOKER CONSTANT ARPHRD_METRICOM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_METRICOM"}
  ARPHRD_METRICOM)

JOKER CONSTANT ARPHRD_NETROM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_NETROM"}
  ARPHRD_NETROM)

JOKER CONSTANT ARPHRD_NONE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_NONE"}
  ARPHRD_NONE)

JOKER CONSTANT ARPHRD_PIMREG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_PIMREG"}
  ARPHRD_PIMREG)

JOKER CONSTANT ARPHRD_PPP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_PPP"}
  ARPHRD_PPP)

JOKER CONSTANT ARPHRD_PRONET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_PRONET"}
  ARPHRD_PRONET)

JOKER CONSTANT ARPHRD_RAWHDLC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_RAWHDLC"}
  ARPHRD_RAWHDLC)

JOKER CONSTANT ARPHRD_ROSE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_ROSE"}
  ARPHRD_ROSE)

JOKER CONSTANT ARPHRD_RSRVD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_RSRVD"}
  ARPHRD_RSRVD)

JOKER CONSTANT ARPHRD_SIT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_SIT"}
  ARPHRD_SIT)

JOKER CONSTANT ARPHRD_SKIP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_SKIP"}
  ARPHRD_SKIP)

JOKER CONSTANT ARPHRD_SLIP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_SLIP"}
  ARPHRD_SLIP)

JOKER CONSTANT ARPHRD_SLIP6 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_SLIP6"}
  ARPHRD_SLIP6)

JOKER CONSTANT ARPHRD_TUNNEL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_TUNNEL"}
  ARPHRD_TUNNEL)

JOKER CONSTANT ARPHRD_TUNNEL6 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_TUNNEL6"}
  ARPHRD_TUNNEL6)

JOKER CONSTANT ARPHRD_VOID from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_VOID"}
  ARPHRD_VOID)

JOKER CONSTANT ARPHRD_X25 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ARPHRD_X25"}
  ARPHRD_X25)

JOKER CONSTANT B0 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B0"}
  B0)

JOKER CONSTANT B1000000 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B1000000"}
  B1000000)

JOKER CONSTANT B110 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B110"}
  B110)

JOKER CONSTANT B115200 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B115200"}
  B115200)

JOKER CONSTANT B1152000 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B1152000"}
  B1152000)

JOKER CONSTANT B1200 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B1200"}
  B1200)

JOKER CONSTANT B134 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B134"}
  B134)

JOKER CONSTANT B150 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B150"}
  B150)

JOKER CONSTANT B1500000 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B1500000"}
  B1500000)

JOKER CONSTANT B1800 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B1800"}
  B1800)

JOKER CONSTANT B19200 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B19200"}
  B19200)

JOKER CONSTANT B200 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B200"}
  B200)

JOKER CONSTANT B2000000 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B2000000"}
  B2000000)

JOKER CONSTANT B230400 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B230400"}
  B230400)

JOKER CONSTANT B2400 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B2400"}
  B2400)

JOKER CONSTANT B2500000 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B2500000"}
  B2500000)

JOKER CONSTANT B300 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B300"}
  B300)

JOKER CONSTANT B3000000 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B3000000"}
  B3000000)

JOKER CONSTANT B3500000 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B3500000"}
  B3500000)

JOKER CONSTANT B38400 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B38400"}
  B38400)

JOKER CONSTANT B4000000 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B4000000"}
  B4000000)

JOKER CONSTANT B460800 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B460800"}
  B460800)

JOKER CONSTANT B4800 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B4800"}
  B4800)

JOKER CONSTANT B50 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B50"}
  B50)

JOKER CONSTANT B500000 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B500000"}
  B500000)

JOKER CONSTANT B57600 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B57600"}
  B57600)

JOKER CONSTANT B576000 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B576000"}
  B576000)

JOKER CONSTANT B600 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B600"}
  B600)

JOKER CONSTANT B75 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B75"}
  B75)

JOKER CONSTANT B921600 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B921600"}
  B921600)

JOKER CONSTANT B9600 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.B9600"}
  B9600)

JOKER CONSTANT BPF_A from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_A"}
  BPF_A)

JOKER CONSTANT BPF_ABS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_ABS"}
  BPF_ABS)

JOKER CONSTANT BPF_ADD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_ADD"}
  BPF_ADD)

JOKER CONSTANT BPF_ALU from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_ALU"}
  BPF_ALU)

JOKER CONSTANT BPF_AND from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_AND"}
  BPF_AND)

JOKER CONSTANT BPF_B from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_B"}
  BPF_B)

JOKER CONSTANT BPF_DIV from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_DIV"}
  BPF_DIV)

JOKER CONSTANT BPF_H from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_H"}
  BPF_H)

JOKER CONSTANT BPF_IMM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_IMM"}
  BPF_IMM)

JOKER CONSTANT BPF_IND from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_IND"}
  BPF_IND)

JOKER CONSTANT BPF_JA from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_JA"}
  BPF_JA)

JOKER CONSTANT BPF_JEQ from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_JEQ"}
  BPF_JEQ)

JOKER CONSTANT BPF_JGE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_JGE"}
  BPF_JGE)

JOKER CONSTANT BPF_JGT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_JGT"}
  BPF_JGT)

JOKER CONSTANT BPF_JMP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_JMP"}
  BPF_JMP)

JOKER CONSTANT BPF_JSET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_JSET"}
  BPF_JSET)

JOKER CONSTANT BPF_K from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_K"}
  BPF_K)

JOKER CONSTANT BPF_LD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_LD"}
  BPF_LD)

JOKER CONSTANT BPF_LDX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_LDX"}
  BPF_LDX)

JOKER CONSTANT BPF_LEN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_LEN"}
  BPF_LEN)

JOKER CONSTANT BPF_LSH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_LSH"}
  BPF_LSH)

JOKER CONSTANT BPF_MAJOR_VERSION from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_MAJOR_VERSION"}
  BPF_MAJOR_VERSION)

JOKER CONSTANT BPF_MAXINSNS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_MAXINSNS"}
  BPF_MAXINSNS)

JOKER CONSTANT BPF_MEM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_MEM"}
  BPF_MEM)

JOKER CONSTANT BPF_MEMWORDS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_MEMWORDS"}
  BPF_MEMWORDS)

JOKER CONSTANT BPF_MINOR_VERSION from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_MINOR_VERSION"}
  BPF_MINOR_VERSION)

JOKER CONSTANT BPF_MISC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_MISC"}
  BPF_MISC)

JOKER CONSTANT BPF_MSH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_MSH"}
  BPF_MSH)

JOKER CONSTANT BPF_MUL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_MUL"}
  BPF_MUL)

JOKER CONSTANT BPF_NEG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_NEG"}
  BPF_NEG)

JOKER CONSTANT BPF_OR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_OR"}
  BPF_OR)

JOKER CONSTANT BPF_RET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_RET"}
  BPF_RET)

JOKER CONSTANT BPF_RSH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_RSH"}
  BPF_RSH)

JOKER CONSTANT BPF_ST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_ST"}
  BPF_ST)

JOKER CONSTANT BPF_STX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_STX"}
  BPF_STX)

JOKER CONSTANT BPF_SUB from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_SUB"}
  BPF_SUB)

JOKER CONSTANT BPF_TAX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_TAX"}
  BPF_TAX)

JOKER CONSTANT BPF_TXA from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_TXA"}
  BPF_TXA)

JOKER CONSTANT BPF_W from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_W"}
  BPF_W)

JOKER CONSTANT BPF_X from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BPF_X"}
  BPF_X)

JOKER CONSTANT BRKINT from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.BRKINT"}
  BRKINT)

JOKER CONSTANT CLOCAL from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLOCAL"}
  CLOCAL)

JOKER CONSTANT CLONE_CHILD_CLEARTID from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLONE_CHILD_CLEARTID"}
  CLONE_CHILD_CLEARTID)

JOKER CONSTANT CLONE_CHILD_SETTID from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLONE_CHILD_SETTID"}
  CLONE_CHILD_SETTID)

JOKER CONSTANT CLONE_DETACHED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLONE_DETACHED"}
  CLONE_DETACHED)

JOKER CONSTANT CLONE_FILES from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLONE_FILES"}
  CLONE_FILES)

JOKER CONSTANT CLONE_FS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLONE_FS"}
  CLONE_FS)

JOKER CONSTANT CLONE_IO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.CLONE_IO)"}
  CLONE_IO)

JOKER CONSTANT CLONE_NEWIPC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLONE_NEWIPC"}
  CLONE_NEWIPC)

JOKER CONSTANT CLONE_NEWNET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLONE_NEWNET"}
  CLONE_NEWNET)

JOKER CONSTANT CLONE_NEWNS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLONE_NEWNS"}
  CLONE_NEWNS)

JOKER CONSTANT CLONE_NEWPID from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLONE_NEWPID"}
  CLONE_NEWPID)

JOKER CONSTANT CLONE_NEWUSER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLONE_NEWUSER"}
  CLONE_NEWUSER)

JOKER CONSTANT CLONE_NEWUTS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLONE_NEWUTS"}
  CLONE_NEWUTS)

JOKER CONSTANT CLONE_PARENT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLONE_PARENT"}
  CLONE_PARENT)

JOKER CONSTANT CLONE_PARENT_SETTID from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLONE_PARENT_SETTID"}
  CLONE_PARENT_SETTID)

JOKER CONSTANT CLONE_PTRACE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLONE_PTRACE"}
  CLONE_PTRACE)

JOKER CONSTANT CLONE_SETTLS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLONE_SETTLS"}
  CLONE_SETTLS)

JOKER CONSTANT CLONE_SIGHAND from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLONE_SIGHAND"}
  CLONE_SIGHAND)

JOKER CONSTANT CLONE_SYSVSEM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLONE_SYSVSEM"}
  CLONE_SYSVSEM)

JOKER CONSTANT CLONE_THREAD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLONE_THREAD"}
  CLONE_THREAD)

JOKER CONSTANT CLONE_UNTRACED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLONE_UNTRACED"}
  CLONE_UNTRACED)

JOKER CONSTANT CLONE_VFORK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLONE_VFORK"}
  CLONE_VFORK)

JOKER CONSTANT CLONE_VM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CLONE_VM"}
  CLONE_VM)

JOKER CONSTANT CREAD from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CREAD"}
  CREAD)

JOKER CONSTANT CS5 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CS5"}
  CS5)

JOKER CONSTANT CS6 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CS6"}
  CS6)

JOKER CONSTANT CS7 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CS7"}
  CS7)

JOKER CONSTANT CS8 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CS8"}
  CS8)

JOKER CONSTANT CSIZE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CSIZE"}
  CSIZE)

JOKER CONSTANT CSTOPB from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.CSTOPB"}
  CSTOPB)

JOKER CONSTANT DT_BLK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.DT_BLK"}
  DT_BLK)

JOKER CONSTANT DT_CHR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.DT_CHR"}
  DT_CHR)

JOKER CONSTANT DT_DIR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.DT_DIR"}
  DT_DIR)

JOKER CONSTANT DT_FIFO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.DT_FIFO"}
  DT_FIFO)

JOKER CONSTANT DT_LNK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.DT_LNK"}
  DT_LNK)

JOKER CONSTANT DT_REG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.DT_REG"}
  DT_REG)

JOKER CONSTANT DT_SOCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.DT_SOCK"}
  DT_SOCK)

JOKER CONSTANT DT_UNKNOWN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.DT_UNKNOWN"}
  DT_UNKNOWN)

JOKER CONSTANT DT_WHT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.DT_WHT"}
  DT_WHT)

JOKER CONSTANT E2BIG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.E2BIG)"}
  E2BIG)

JOKER CONSTANT EACCES from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EACCES)"}
  EACCES)

JOKER CONSTANT EADDRINUSE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EADDRINUSE)"}
  EADDRINUSE)

JOKER CONSTANT EADDRNOTAVAIL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EADDRNOTAVAIL)"}
  EADDRNOTAVAIL)

JOKER CONSTANT EADV from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EADV)"}
  EADV)

JOKER CONSTANT EAFNOSUPPORT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EAFNOSUPPORT)"}
  EAFNOSUPPORT)

JOKER CONSTANT EAGAIN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EAGAIN)"}
  EAGAIN)

JOKER CONSTANT EALREADY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EALREADY)"}
  EALREADY)

JOKER CONSTANT EBADE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EBADE)"}
  EBADE)

JOKER CONSTANT EBADF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EBADF)"}
  EBADF)

JOKER CONSTANT EBADFD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EBADFD)"}
  EBADFD)

JOKER CONSTANT EBADMSG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EBADMSG)"}
  EBADMSG)

JOKER CONSTANT EBADR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EBADR)"}
  EBADR)

JOKER CONSTANT EBADRQC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EBADRQC)"}
  EBADRQC)

JOKER CONSTANT EBADSLT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EBADSLT)"}
  EBADSLT)

JOKER CONSTANT EBFONT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EBFONT)"}
  EBFONT)

JOKER CONSTANT EBUSY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EBUSY)"}
  EBUSY)

JOKER CONSTANT ECANCELED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ECANCELED)"}
  ECANCELED)

JOKER CONSTANT ECHILD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ECHILD)"}
  ECHILD)

JOKER CONSTANT ECHO from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ECHO"}
  ECHO)

JOKER CONSTANT ECHOCTL from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ECHOCTL"}
  ECHOCTL)

JOKER CONSTANT ECHOE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ECHOE"}
  ECHOE)

JOKER CONSTANT ECHOK from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ECHOK"}
  ECHOK)

JOKER CONSTANT ECHOKE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ECHOKE"}
  ECHOKE)

JOKER CONSTANT ECHONL from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ECHONL"}
  ECHONL)

JOKER CONSTANT ECHOPRT from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ECHOPRT"}
  ECHOPRT)

JOKER CONSTANT ECHRNG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ECHRNG)"}
  ECHRNG)

JOKER CONSTANT ECOMM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ECOMM)"}
  ECOMM)

JOKER CONSTANT ECONNABORTED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ECONNABORTED)"}
  ECONNABORTED)

JOKER CONSTANT ECONNREFUSED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ECONNREFUSED)"}
  ECONNREFUSED)

JOKER CONSTANT ECONNRESET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ECONNRESET)"}
  ECONNRESET)

JOKER CONSTANT EDEADLK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EDEADLK)"}
  EDEADLK)

JOKER CONSTANT EDEADLOCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EDEADLOCK)"}
  EDEADLOCK)

JOKER CONSTANT EDESTADDRREQ from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EDESTADDRREQ)"}
  EDESTADDRREQ)

JOKER CONSTANT EDOM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EDOM)"}
  EDOM)

JOKER CONSTANT EDOTDOT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EDOTDOT)"}
  EDOTDOT)

JOKER CONSTANT EDQUOT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EDQUOT)"}
  EDQUOT)

JOKER CONSTANT EEXIST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EEXIST)"}
  EEXIST)

JOKER CONSTANT EFAULT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EFAULT)"}
  EFAULT)

JOKER CONSTANT EFBIG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EFBIG)"}
  EFBIG)

JOKER CONSTANT EHOSTDOWN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EHOSTDOWN)"}
  EHOSTDOWN)

JOKER CONSTANT EHOSTUNREACH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EHOSTUNREACH)"}
  EHOSTUNREACH)

JOKER CONSTANT EIDRM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EIDRM)"}
  EIDRM)

JOKER CONSTANT EILSEQ from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EILSEQ)"}
  EILSEQ)

JOKER CONSTANT EINPROGRESS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EINPROGRESS)"}
  EINPROGRESS)

JOKER CONSTANT EINTR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EINTR)"}
  EINTR)

JOKER CONSTANT EINVAL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EINVAL)"}
  EINVAL)

JOKER CONSTANT EIO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EIO)"}
  EIO)

JOKER CONSTANT EISCONN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EISCONN)"}
  EISCONN)

JOKER CONSTANT EISDIR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EISDIR)"}
  EISDIR)

JOKER CONSTANT EISNAM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EISNAM)"}
  EISNAM)

JOKER CONSTANT EKEYEXPIRED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EKEYEXPIRED)"}
  EKEYEXPIRED)

JOKER CONSTANT EKEYREJECTED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EKEYREJECTED)"}
  EKEYREJECTED)

JOKER CONSTANT EKEYREVOKED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EKEYREVOKED)"}
  EKEYREVOKED)

JOKER CONSTANT EL2HLT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EL2HLT)"}
  EL2HLT)

JOKER CONSTANT EL2NSYNC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EL2NSYNC)"}
  EL2NSYNC)

JOKER CONSTANT EL3HLT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EL3HLT)"}
  EL3HLT)

JOKER CONSTANT EL3RST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EL3RST)"}
  EL3RST)

JOKER CONSTANT ELIBACC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ELIBACC)"}
  ELIBACC)

JOKER CONSTANT ELIBBAD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ELIBBAD)"}
  ELIBBAD)

JOKER CONSTANT ELIBEXEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ELIBEXEC)"}
  ELIBEXEC)

JOKER CONSTANT ELIBMAX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ELIBMAX)"}
  ELIBMAX)

JOKER CONSTANT ELIBSCN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ELIBSCN)"}
  ELIBSCN)

JOKER CONSTANT ELNRNG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ELNRNG)"}
  ELNRNG)

JOKER CONSTANT ELOOP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ELOOP)"}
  ELOOP)

JOKER CONSTANT EMEDIUMTYPE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EMEDIUMTYPE)"}
  EMEDIUMTYPE)

JOKER CONSTANT EMFILE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EMFILE)"}
  EMFILE)

JOKER CONSTANT EMLINK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EMLINK)"}
  EMLINK)

JOKER CONSTANT EMSGSIZE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EMSGSIZE)"}
  EMSGSIZE)

JOKER CONSTANT EMULTIHOP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EMULTIHOP)"}
  EMULTIHOP)

JOKER CONSTANT ENAMETOOLONG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENAMETOOLONG)"}
  ENAMETOOLONG)

JOKER CONSTANT ENAVAIL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENAVAIL)"}
  ENAVAIL)

JOKER CONSTANT ENETDOWN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENETDOWN)"}
  ENETDOWN)

JOKER CONSTANT ENETRESET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENETRESET)"}
  ENETRESET)

JOKER CONSTANT ENETUNREACH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENETUNREACH)"}
  ENETUNREACH)

JOKER CONSTANT ENFILE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENFILE)"}
  ENFILE)

JOKER CONSTANT ENOANO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOANO)"}
  ENOANO)

JOKER CONSTANT ENOBUFS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOBUFS)"}
  ENOBUFS)

JOKER CONSTANT ENOCSI from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOCSI)"}
  ENOCSI)

JOKER CONSTANT ENODATA from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENODATA)"}
  ENODATA)

JOKER CONSTANT ENODEV from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENODEV)"}
  ENODEV)

JOKER CONSTANT ENOENT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOENT)"}
  ENOENT)

JOKER CONSTANT ENOEXEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOEXEC)"}
  ENOEXEC)

JOKER CONSTANT ENOKEY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOKEY)"}
  ENOKEY)

JOKER CONSTANT ENOLCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOLCK)"}
  ENOLCK)

JOKER CONSTANT ENOLINK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOLINK)"}
  ENOLINK)

JOKER CONSTANT ENOMEDIUM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOMEDIUM)"}
  ENOMEDIUM)

JOKER CONSTANT ENOMEM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOMEM)"}
  ENOMEM)

JOKER CONSTANT ENOMSG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOMSG)"}
  ENOMSG)

JOKER CONSTANT ENONET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENONET)"}
  ENONET)

JOKER CONSTANT ENOPKG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOPKG)"}
  ENOPKG)

JOKER CONSTANT ENOPROTOOPT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOPROTOOPT)"}
  ENOPROTOOPT)

JOKER CONSTANT ENOSPC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOSPC)"}
  ENOSPC)

JOKER CONSTANT ENOSR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOSR)"}
  ENOSR)

JOKER CONSTANT ENOSTR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOSTR)"}
  ENOSTR)

JOKER CONSTANT ENOSYS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOSYS)"}
  ENOSYS)

JOKER CONSTANT ENOTBLK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOTBLK)"}
  ENOTBLK)

JOKER CONSTANT ENOTCONN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOTCONN)"}
  ENOTCONN)

JOKER CONSTANT ENOTDIR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOTDIR)"}
  ENOTDIR)

JOKER CONSTANT ENOTEMPTY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOTEMPTY)"}
  ENOTEMPTY)

JOKER CONSTANT ENOTNAM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOTNAM)"}
  ENOTNAM)

JOKER CONSTANT ENOTRECOVERABLE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOTRECOVERABLE)"}
  ENOTRECOVERABLE)

JOKER CONSTANT ENOTSOCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOTSOCK)"}
  ENOTSOCK)

JOKER CONSTANT ENOTSUP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOTSUP)"}
  ENOTSUP)

JOKER CONSTANT ENOTTY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOTTY)"}
  ENOTTY)

JOKER CONSTANT ENOTUNIQ from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENOTUNIQ)"}
  ENOTUNIQ)

JOKER CONSTANT ENXIO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ENXIO)"}
  ENXIO)

JOKER CONSTANT EOPNOTSUPP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EOPNOTSUPP)"}
  EOPNOTSUPP)

JOKER CONSTANT EOVERFLOW from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EOVERFLOW)"}
  EOVERFLOW)

JOKER CONSTANT EOWNERDEAD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EOWNERDEAD)"}
  EOWNERDEAD)

JOKER CONSTANT EPERM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EPERM)"}
  EPERM)

JOKER CONSTANT EPFNOSUPPORT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EPFNOSUPPORT)"}
  EPFNOSUPPORT)

JOKER CONSTANT EPIPE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EPIPE)"}
  EPIPE)

JOKER CONSTANT EPOLLERR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.EPOLLERR"}
  EPOLLERR)

JOKER CONSTANT EPOLLET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EPOLLET)"}
  EPOLLET)

JOKER CONSTANT EPOLLHUP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.EPOLLHUP"}
  EPOLLHUP)

JOKER CONSTANT EPOLLIN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.EPOLLIN"}
  EPOLLIN)

JOKER CONSTANT EPOLLMSG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.EPOLLMSG"}
  EPOLLMSG)

JOKER CONSTANT EPOLLONESHOT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.EPOLLONESHOT"}
  EPOLLONESHOT)

JOKER CONSTANT EPOLLOUT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.EPOLLOUT"}
  EPOLLOUT)

JOKER CONSTANT EPOLLPRI from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.EPOLLPRI"}
  EPOLLPRI)

JOKER CONSTANT EPOLLRDBAND from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.EPOLLRDBAND"}
  EPOLLRDBAND)

JOKER CONSTANT EPOLLRDHUP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.EPOLLRDHUP"}
  EPOLLRDHUP)

JOKER CONSTANT EPOLLRDNORM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.EPOLLRDNORM"}
  EPOLLRDNORM)

JOKER CONSTANT EPOLLWRBAND from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.EPOLLWRBAND"}
  EPOLLWRBAND)

JOKER CONSTANT EPOLLWRNORM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.EPOLLWRNORM"}
  EPOLLWRNORM)

JOKER CONSTANT EPOLL_CLOEXEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.EPOLL_CLOEXEC"}
  EPOLL_CLOEXEC)

JOKER CONSTANT EPOLL_CTL_ADD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.EPOLL_CTL_ADD"}
  EPOLL_CTL_ADD)

JOKER CONSTANT EPOLL_CTL_DEL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.EPOLL_CTL_DEL"}
  EPOLL_CTL_DEL)

JOKER CONSTANT EPOLL_CTL_MOD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.EPOLL_CTL_MOD"}
  EPOLL_CTL_MOD)

JOKER CONSTANT EPOLL_NONBLOCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.EPOLL_NONBLOCK"}
  EPOLL_NONBLOCK)

JOKER CONSTANT EPROTO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EPROTO)"}
  EPROTO)

JOKER CONSTANT EPROTONOSUPPORT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EPROTONOSUPPORT)"}
  EPROTONOSUPPORT)

JOKER CONSTANT EPROTOTYPE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EPROTOTYPE)"}
  EPROTOTYPE)

JOKER CONSTANT ERANGE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ERANGE)"}
  ERANGE)

JOKER CONSTANT EREMCHG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EREMCHG)"}
  EREMCHG)

JOKER CONSTANT EREMOTE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EREMOTE)"}
  EREMOTE)

JOKER CONSTANT EREMOTEIO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EREMOTEIO)"}
  EREMOTEIO)

JOKER CONSTANT ERESTART from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ERESTART)"}
  ERESTART)

JOKER CONSTANT ERFKILL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ERFKILL)"}
  ERFKILL)

JOKER CONSTANT EROFS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EROFS)"}
  EROFS)

JOKER CONSTANT ESHUTDOWN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ESHUTDOWN)"}
  ESHUTDOWN)

JOKER CONSTANT ESOCKTNOSUPPORT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ESOCKTNOSUPPORT)"}
  ESOCKTNOSUPPORT)

JOKER CONSTANT ESPIPE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ESPIPE)"}
  ESPIPE)

JOKER CONSTANT ESRCH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ESRCH)"}
  ESRCH)

JOKER CONSTANT ESRMNT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ESRMNT)"}
  ESRMNT)

JOKER CONSTANT ESTALE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ESTALE)"}
  ESTALE)

JOKER CONSTANT ESTRPIPE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ESTRPIPE)"}
  ESTRPIPE)

JOKER CONSTANT ETH_P_1588 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_1588"}
  ETH_P_1588)

JOKER CONSTANT ETH_P_8021Q from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_8021Q"}
  ETH_P_8021Q)

JOKER CONSTANT ETH_P_802_2 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_802_2"}
  ETH_P_802_2)

JOKER CONSTANT ETH_P_802_3 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_802_3"}
  ETH_P_802_3)

JOKER CONSTANT ETH_P_AARP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_AARP"}
  ETH_P_AARP)

JOKER CONSTANT ETH_P_ALL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_ALL"}
  ETH_P_ALL)

JOKER CONSTANT ETH_P_AOE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_AOE"}
  ETH_P_AOE)

JOKER CONSTANT ETH_P_ARCNET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_ARCNET"}
  ETH_P_ARCNET)

JOKER CONSTANT ETH_P_ARP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_ARP"}
  ETH_P_ARP)

JOKER CONSTANT ETH_P_ATALK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_ATALK"}
  ETH_P_ATALK)

JOKER CONSTANT ETH_P_ATMFATE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_ATMFATE"}
  ETH_P_ATMFATE)

JOKER CONSTANT ETH_P_ATMMPOA from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_ATMMPOA"}
  ETH_P_ATMMPOA)

JOKER CONSTANT ETH_P_AX25 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_AX25"}
  ETH_P_AX25)

JOKER CONSTANT ETH_P_BPQ from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_BPQ"}
  ETH_P_BPQ)

JOKER CONSTANT ETH_P_CAIF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_CAIF"}
  ETH_P_CAIF)

JOKER CONSTANT ETH_P_CAN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_CAN"}
  ETH_P_CAN)

JOKER CONSTANT ETH_P_CONTROL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_CONTROL"}
  ETH_P_CONTROL)

JOKER CONSTANT ETH_P_CUST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_CUST"}
  ETH_P_CUST)

JOKER CONSTANT ETH_P_DDCMP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_DDCMP"}
  ETH_P_DDCMP)

JOKER CONSTANT ETH_P_DEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_DEC"}
  ETH_P_DEC)

JOKER CONSTANT ETH_P_DIAG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_DIAG"}
  ETH_P_DIAG)

JOKER CONSTANT ETH_P_DNA_DL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_DNA_DL"}
  ETH_P_DNA_DL)

JOKER CONSTANT ETH_P_DNA_RC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_DNA_RC"}
  ETH_P_DNA_RC)

JOKER CONSTANT ETH_P_DNA_RT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_DNA_RT"}
  ETH_P_DNA_RT)

JOKER CONSTANT ETH_P_DSA from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_DSA"}
  ETH_P_DSA)

JOKER CONSTANT ETH_P_ECONET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_ECONET"}
  ETH_P_ECONET)

JOKER CONSTANT ETH_P_EDSA from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_EDSA"}
  ETH_P_EDSA)

JOKER CONSTANT ETH_P_FCOE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_FCOE"}
  ETH_P_FCOE)

JOKER CONSTANT ETH_P_FIP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_FIP"}
  ETH_P_FIP)

JOKER CONSTANT ETH_P_HDLC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_HDLC"}
  ETH_P_HDLC)

JOKER CONSTANT ETH_P_IEEE802154 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_IEEE802154"}
  ETH_P_IEEE802154)

JOKER CONSTANT ETH_P_IEEEPUP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_IEEEPUP"}
  ETH_P_IEEEPUP)

JOKER CONSTANT ETH_P_IEEEPUPAT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_IEEEPUPAT"}
  ETH_P_IEEEPUPAT)

JOKER CONSTANT ETH_P_IP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_IP"}
  ETH_P_IP)

JOKER CONSTANT ETH_P_IPV6 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_IPV6"}
  ETH_P_IPV6)

JOKER CONSTANT ETH_P_IPX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_IPX"}
  ETH_P_IPX)

JOKER CONSTANT ETH_P_IRDA from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_IRDA"}
  ETH_P_IRDA)

JOKER CONSTANT ETH_P_LAT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_LAT"}
  ETH_P_LAT)

JOKER CONSTANT ETH_P_LINK_CTL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_LINK_CTL"}
  ETH_P_LINK_CTL)

JOKER CONSTANT ETH_P_LOCALTALK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_LOCALTALK"}
  ETH_P_LOCALTALK)

JOKER CONSTANT ETH_P_LOOP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_LOOP"}
  ETH_P_LOOP)

JOKER CONSTANT ETH_P_MOBITEX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_MOBITEX"}
  ETH_P_MOBITEX)

JOKER CONSTANT ETH_P_MPLS_MC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_MPLS_MC"}
  ETH_P_MPLS_MC)

JOKER CONSTANT ETH_P_MPLS_UC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_MPLS_UC"}
  ETH_P_MPLS_UC)

JOKER CONSTANT ETH_P_PAE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_PAE"}
  ETH_P_PAE)

JOKER CONSTANT ETH_P_PAUSE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_PAUSE"}
  ETH_P_PAUSE)

JOKER CONSTANT ETH_P_PHONET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_PHONET"}
  ETH_P_PHONET)

JOKER CONSTANT ETH_P_PPPTALK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_PPPTALK"}
  ETH_P_PPPTALK)

JOKER CONSTANT ETH_P_PPP_DISC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_PPP_DISC"}
  ETH_P_PPP_DISC)

JOKER CONSTANT ETH_P_PPP_MP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_PPP_MP"}
  ETH_P_PPP_MP)

JOKER CONSTANT ETH_P_PPP_SES from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_PPP_SES"}
  ETH_P_PPP_SES)

JOKER CONSTANT ETH_P_PUP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_PUP"}
  ETH_P_PUP)

JOKER CONSTANT ETH_P_PUPAT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_PUPAT"}
  ETH_P_PUPAT)

JOKER CONSTANT ETH_P_RARP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_RARP"}
  ETH_P_RARP)

JOKER CONSTANT ETH_P_SCA from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_SCA"}
  ETH_P_SCA)

JOKER CONSTANT ETH_P_SLOW from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_SLOW"}
  ETH_P_SLOW)

JOKER CONSTANT ETH_P_SNAP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_SNAP"}
  ETH_P_SNAP)

JOKER CONSTANT ETH_P_TEB from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_TEB"}
  ETH_P_TEB)

JOKER CONSTANT ETH_P_TIPC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_TIPC"}
  ETH_P_TIPC)

JOKER CONSTANT ETH_P_TRAILER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_TRAILER"}
  ETH_P_TRAILER)

JOKER CONSTANT ETH_P_TR_802_2 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_TR_802_2"}
  ETH_P_TR_802_2)

JOKER CONSTANT ETH_P_WAN_PPP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_WAN_PPP"}
  ETH_P_WAN_PPP)

JOKER CONSTANT ETH_P_WCCP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_WCCP"}
  ETH_P_WCCP)

JOKER CONSTANT ETH_P_X25 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ETH_P_X25"}
  ETH_P_X25)

JOKER CONSTANT ETIME from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ETIME)"}
  ETIME)

JOKER CONSTANT ETIMEDOUT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ETIMEDOUT)"}
  ETIMEDOUT)

JOKER CONSTANT ETOOMANYREFS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ETOOMANYREFS)"}
  ETOOMANYREFS)

JOKER CONSTANT ETXTBSY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.ETXTBSY)"}
  ETXTBSY)

JOKER CONSTANT EUCLEAN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EUCLEAN)"}
  EUCLEAN)

JOKER CONSTANT EUNATCH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EUNATCH)"}
  EUNATCH)

JOKER CONSTANT EUSERS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EUSERS)"}
  EUSERS)

JOKER CONSTANT EWOULDBLOCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EWOULDBLOCK)"}
  EWOULDBLOCK)

JOKER CONSTANT EXDEV from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EXDEV)"}
  EXDEV)

JOKER CONSTANT EXFULL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Errors\n"
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.EXFULL)"}
  EXFULL)

JOKER CONSTANT FD_CLOEXEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.FD_CLOEXEC"}
  FD_CLOEXEC)

JOKER CONSTANT FD_SETSIZE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.FD_SETSIZE"}
  FD_SETSIZE)

JOKER CONSTANT FLUSHO from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.FLUSHO"}
  FLUSHO)

JOKER CONSTANT F_DUPFD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_DUPFD"}
  F_DUPFD)

JOKER CONSTANT F_DUPFD_CLOEXEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_DUPFD_CLOEXEC"}
  F_DUPFD_CLOEXEC)

JOKER CONSTANT F_EXLCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_EXLCK"}
  F_EXLCK)

JOKER CONSTANT F_GETFD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_GETFD"}
  F_GETFD)

JOKER CONSTANT F_GETFL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_GETFL"}
  F_GETFL)

JOKER CONSTANT F_GETLEASE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_GETLEASE"}
  F_GETLEASE)

JOKER CONSTANT F_GETLK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_GETLK"}
  F_GETLK)

JOKER CONSTANT F_GETLK64 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_GETLK64"}
  F_GETLK64)

JOKER CONSTANT F_GETOWN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_GETOWN"}
  F_GETOWN)

JOKER CONSTANT F_GETOWN_EX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_GETOWN_EX"}
  F_GETOWN_EX)

JOKER CONSTANT F_GETPIPE_SZ from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_GETPIPE_SZ"}
  F_GETPIPE_SZ)

JOKER CONSTANT F_GETSIG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_GETSIG"}
  F_GETSIG)

JOKER CONSTANT F_LOCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_LOCK"}
  F_LOCK)

JOKER CONSTANT F_NOTIFY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_NOTIFY"}
  F_NOTIFY)

JOKER CONSTANT F_OK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_OK"}
  F_OK)

JOKER CONSTANT F_RDLCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_RDLCK"}
  F_RDLCK)

JOKER CONSTANT F_SETFD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_SETFD"}
  F_SETFD)

JOKER CONSTANT F_SETFL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_SETFL"}
  F_SETFL)

JOKER CONSTANT F_SETLEASE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_SETLEASE"}
  F_SETLEASE)

JOKER CONSTANT F_SETLK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_SETLK"}
  F_SETLK)

JOKER CONSTANT F_SETLK64 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_SETLK64"}
  F_SETLK64)

JOKER CONSTANT F_SETLKW from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_SETLKW"}
  F_SETLKW)

JOKER CONSTANT F_SETLKW64 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_SETLKW64"}
  F_SETLKW64)

JOKER CONSTANT F_SETOWN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_SETOWN"}
  F_SETOWN)

JOKER CONSTANT F_SETOWN_EX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_SETOWN_EX"}
  F_SETOWN_EX)

JOKER CONSTANT F_SETPIPE_SZ from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_SETPIPE_SZ"}
  F_SETPIPE_SZ)

JOKER CONSTANT F_SETSIG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_SETSIG"}
  F_SETSIG)

JOKER CONSTANT F_SHLCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_SHLCK"}
  F_SHLCK)

JOKER CONSTANT F_TEST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_TEST"}
  F_TEST)

JOKER CONSTANT F_TLOCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_TLOCK"}
  F_TLOCK)

JOKER CONSTANT F_ULOCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_ULOCK"}
  F_ULOCK)

JOKER CONSTANT F_UNLCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_UNLCK"}
  F_UNLCK)

JOKER CONSTANT F_WRLCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.F_WRLCK"}
  F_WRLCK)

JOKER CONSTANT HUPCL from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.HUPCL"}
  HUPCL)

JOKER CONSTANT ICANON from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ICANON"}
  ICANON)

JOKER CONSTANT ICMPV6_FILTER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ICMPV6_FILTER"}
  ICMPV6_FILTER)

JOKER CONSTANT ICRNL from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ICRNL"}
  ICRNL)

JOKER CONSTANT IEXTEN from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IEXTEN"}
  IEXTEN)

JOKER CONSTANT IFA_ADDRESS from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFA_ADDRESS"}
  IFA_ADDRESS)

JOKER CONSTANT IFA_ANYCAST from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFA_ANYCAST"}
  IFA_ANYCAST)

JOKER CONSTANT IFA_BROADCAST from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFA_BROADCAST"}
  IFA_BROADCAST)

JOKER CONSTANT IFA_CACHEINFO from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFA_CACHEINFO"}
  IFA_CACHEINFO)

JOKER CONSTANT IFA_F_DADFAILED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFA_F_DADFAILED"}
  IFA_F_DADFAILED)

JOKER CONSTANT IFA_F_DEPRECATED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFA_F_DEPRECATED"}
  IFA_F_DEPRECATED)

JOKER CONSTANT IFA_F_HOMEADDRESS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFA_F_HOMEADDRESS"}
  IFA_F_HOMEADDRESS)

JOKER CONSTANT IFA_F_NODAD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFA_F_NODAD"}
  IFA_F_NODAD)

JOKER CONSTANT IFA_F_OPTIMISTIC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFA_F_OPTIMISTIC"}
  IFA_F_OPTIMISTIC)

JOKER CONSTANT IFA_F_PERMANENT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFA_F_PERMANENT"}
  IFA_F_PERMANENT)

JOKER CONSTANT IFA_F_SECONDARY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFA_F_SECONDARY"}
  IFA_F_SECONDARY)

JOKER CONSTANT IFA_F_TEMPORARY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFA_F_TEMPORARY"}
  IFA_F_TEMPORARY)

JOKER CONSTANT IFA_F_TENTATIVE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFA_F_TENTATIVE"}
  IFA_F_TENTATIVE)

JOKER CONSTANT IFA_LABEL from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFA_LABEL"}
  IFA_LABEL)

JOKER CONSTANT IFA_LOCAL from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFA_LOCAL"}
  IFA_LOCAL)

JOKER CONSTANT IFA_MAX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFA_MAX"}
  IFA_MAX)

JOKER CONSTANT IFA_MULTICAST from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFA_MULTICAST"}
  IFA_MULTICAST)

JOKER CONSTANT IFA_UNSPEC from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFA_UNSPEC"}
  IFA_UNSPEC)

JOKER CONSTANT IFF_ALLMULTI from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_ALLMULTI"}
  IFF_ALLMULTI)

JOKER CONSTANT IFF_AUTOMEDIA from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_AUTOMEDIA"}
  IFF_AUTOMEDIA)

JOKER CONSTANT IFF_BROADCAST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_BROADCAST"}
  IFF_BROADCAST)

JOKER CONSTANT IFF_DEBUG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_DEBUG"}
  IFF_DEBUG)

JOKER CONSTANT IFF_DYNAMIC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_DYNAMIC"}
  IFF_DYNAMIC)

JOKER CONSTANT IFF_LOOPBACK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_LOOPBACK"}
  IFF_LOOPBACK)

JOKER CONSTANT IFF_MASTER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_MASTER"}
  IFF_MASTER)

JOKER CONSTANT IFF_MULTICAST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_MULTICAST"}
  IFF_MULTICAST)

JOKER CONSTANT IFF_NOARP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_NOARP"}
  IFF_NOARP)

JOKER CONSTANT IFF_NOTRAILERS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_NOTRAILERS"}
  IFF_NOTRAILERS)

JOKER CONSTANT IFF_NO_PI from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_NO_PI"}
  IFF_NO_PI)

JOKER CONSTANT IFF_ONE_QUEUE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_ONE_QUEUE"}
  IFF_ONE_QUEUE)

JOKER CONSTANT IFF_POINTOPOINT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_POINTOPOINT"}
  IFF_POINTOPOINT)

JOKER CONSTANT IFF_PORTSEL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_PORTSEL"}
  IFF_PORTSEL)

JOKER CONSTANT IFF_PROMISC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_PROMISC"}
  IFF_PROMISC)

JOKER CONSTANT IFF_RUNNING from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_RUNNING"}
  IFF_RUNNING)

JOKER CONSTANT IFF_SLAVE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_SLAVE"}
  IFF_SLAVE)

JOKER CONSTANT IFF_TAP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_TAP"}
  IFF_TAP)

JOKER CONSTANT IFF_TUN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_TUN"}
  IFF_TUN)

JOKER CONSTANT IFF_TUN_EXCL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_TUN_EXCL"}
  IFF_TUN_EXCL)

JOKER CONSTANT IFF_UP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_UP"}
  IFF_UP)

JOKER CONSTANT IFF_VNET_HDR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFF_VNET_HDR"}
  IFF_VNET_HDR)

JOKER CONSTANT IFLA_ADDRESS from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_ADDRESS"}
  IFLA_ADDRESS)

JOKER CONSTANT IFLA_BROADCAST from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_BROADCAST"}
  IFLA_BROADCAST)

JOKER CONSTANT IFLA_COST from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_COST"}
  IFLA_COST)

JOKER CONSTANT IFLA_IFALIAS from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_IFALIAS"}
  IFLA_IFALIAS)

JOKER CONSTANT IFLA_IFNAME from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_IFNAME"}
  IFLA_IFNAME)

JOKER CONSTANT IFLA_LINK from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_LINK"}
  IFLA_LINK)

JOKER CONSTANT IFLA_LINKINFO from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_LINKINFO"}
  IFLA_LINKINFO)

JOKER CONSTANT IFLA_LINKMODE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_LINKMODE"}
  IFLA_LINKMODE)

JOKER CONSTANT IFLA_MAP from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_MAP"}
  IFLA_MAP)

JOKER CONSTANT IFLA_MASTER from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_MASTER"}
  IFLA_MASTER)

JOKER CONSTANT IFLA_MAX from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_MAX"}
  IFLA_MAX)

JOKER CONSTANT IFLA_MTU from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_MTU"}
  IFLA_MTU)

JOKER CONSTANT IFLA_NET_NS_PID from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_NET_NS_PID"}
  IFLA_NET_NS_PID)

JOKER CONSTANT IFLA_OPERSTATE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_OPERSTATE"}
  IFLA_OPERSTATE)

JOKER CONSTANT IFLA_PRIORITY from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_PRIORITY"}
  IFLA_PRIORITY)

JOKER CONSTANT IFLA_PROTINFO from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_PROTINFO"}
  IFLA_PROTINFO)

JOKER CONSTANT IFLA_QDISC from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_QDISC"}
  IFLA_QDISC)

JOKER CONSTANT IFLA_STATS from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_STATS"}
  IFLA_STATS)

JOKER CONSTANT IFLA_TXQLEN from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_TXQLEN"}
  IFLA_TXQLEN)

JOKER CONSTANT IFLA_UNSPEC from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_UNSPEC"}
  IFLA_UNSPEC)

JOKER CONSTANT IFLA_WEIGHT from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_WEIGHT"}
  IFLA_WEIGHT)

JOKER CONSTANT IFLA_WIRELESS from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFLA_WIRELESS"}
  IFLA_WIRELESS)

JOKER CONSTANT IFNAMSIZ from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IFNAMSIZ"}
  IFNAMSIZ)

JOKER CONSTANT IGNBRK from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IGNBRK"}
  IGNBRK)

JOKER CONSTANT IGNCR from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IGNCR"}
  IGNCR)

JOKER CONSTANT IGNPAR from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IGNPAR"}
  IGNPAR)

JOKER CONSTANT IMAXBEL from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IMAXBEL"}
  IMAXBEL)

JOKER CONSTANT INLCR from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.INLCR"}
  INLCR)

JOKER CONSTANT INPCK from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.INPCK"}
  INPCK)

JOKER CONSTANT IN_ACCESS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_ACCESS"}
  IN_ACCESS)

JOKER CONSTANT IN_ALL_EVENTS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_ALL_EVENTS"}
  IN_ALL_EVENTS)

JOKER CONSTANT IN_ATTRIB from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_ATTRIB"}
  IN_ATTRIB)

JOKER CONSTANT IN_CLASSA_HOST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_CLASSA_HOST"}
  IN_CLASSA_HOST)

JOKER CONSTANT IN_CLASSA_MAX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_CLASSA_MAX"}
  IN_CLASSA_MAX)

JOKER CONSTANT IN_CLASSA_NET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.IN_CLASSA_NET)"}
  IN_CLASSA_NET)

JOKER CONSTANT IN_CLASSA_NSHIFT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_CLASSA_NSHIFT"}
  IN_CLASSA_NSHIFT)

JOKER CONSTANT IN_CLASSB_HOST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_CLASSB_HOST"}
  IN_CLASSB_HOST)

JOKER CONSTANT IN_CLASSB_MAX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_CLASSB_MAX"}
  IN_CLASSB_MAX)

JOKER CONSTANT IN_CLASSB_NET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.IN_CLASSB_NET)"}
  IN_CLASSB_NET)

JOKER CONSTANT IN_CLASSB_NSHIFT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_CLASSB_NSHIFT"}
  IN_CLASSB_NSHIFT)

JOKER CONSTANT IN_CLASSC_HOST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_CLASSC_HOST"}
  IN_CLASSC_HOST)

JOKER CONSTANT IN_CLASSC_NET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.IN_CLASSC_NET)"}
  IN_CLASSC_NET)

JOKER CONSTANT IN_CLASSC_NSHIFT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_CLASSC_NSHIFT"}
  IN_CLASSC_NSHIFT)

JOKER CONSTANT IN_CLOEXEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_CLOEXEC"}
  IN_CLOEXEC)

JOKER CONSTANT IN_CLOSE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_CLOSE"}
  IN_CLOSE)

JOKER CONSTANT IN_CLOSE_NOWRITE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_CLOSE_NOWRITE"}
  IN_CLOSE_NOWRITE)

JOKER CONSTANT IN_CLOSE_WRITE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_CLOSE_WRITE"}
  IN_CLOSE_WRITE)

JOKER CONSTANT IN_CREATE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_CREATE"}
  IN_CREATE)

JOKER CONSTANT IN_DELETE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_DELETE"}
  IN_DELETE)

JOKER CONSTANT IN_DELETE_SELF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_DELETE_SELF"}
  IN_DELETE_SELF)

JOKER CONSTANT IN_DONT_FOLLOW from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_DONT_FOLLOW"}
  IN_DONT_FOLLOW)

JOKER CONSTANT IN_EXCL_UNLINK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_EXCL_UNLINK"}
  IN_EXCL_UNLINK)

JOKER CONSTANT IN_IGNORED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_IGNORED"}
  IN_IGNORED)

JOKER CONSTANT IN_ISDIR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_ISDIR"}
  IN_ISDIR)

JOKER CONSTANT IN_LOOPBACKNET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_LOOPBACKNET"}
  IN_LOOPBACKNET)

JOKER CONSTANT IN_MASK_ADD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_MASK_ADD"}
  IN_MASK_ADD)

JOKER CONSTANT IN_MODIFY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_MODIFY"}
  IN_MODIFY)

JOKER CONSTANT IN_MOVE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_MOVE"}
  IN_MOVE)

JOKER CONSTANT IN_MOVED_FROM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_MOVED_FROM"}
  IN_MOVED_FROM)

JOKER CONSTANT IN_MOVED_TO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_MOVED_TO"}
  IN_MOVED_TO)

JOKER CONSTANT IN_MOVE_SELF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_MOVE_SELF"}
  IN_MOVE_SELF)

JOKER CONSTANT IN_NONBLOCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_NONBLOCK"}
  IN_NONBLOCK)

JOKER CONSTANT IN_ONESHOT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.IN_ONESHOT)"}
  IN_ONESHOT)

JOKER CONSTANT IN_ONLYDIR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_ONLYDIR"}
  IN_ONLYDIR)

JOKER CONSTANT IN_OPEN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_OPEN"}
  IN_OPEN)

JOKER CONSTANT IN_Q_OVERFLOW from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_Q_OVERFLOW"}
  IN_Q_OVERFLOW)

JOKER CONSTANT IN_UNMOUNT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IN_UNMOUNT"}
  IN_UNMOUNT)

JOKER CONSTANT IPPROTO_AH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_AH"}
  IPPROTO_AH)

JOKER CONSTANT IPPROTO_COMP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_COMP"}
  IPPROTO_COMP)

JOKER CONSTANT IPPROTO_DCCP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_DCCP"}
  IPPROTO_DCCP)

JOKER CONSTANT IPPROTO_DSTOPTS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_DSTOPTS"}
  IPPROTO_DSTOPTS)

JOKER CONSTANT IPPROTO_EGP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_EGP"}
  IPPROTO_EGP)

JOKER CONSTANT IPPROTO_ENCAP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_ENCAP"}
  IPPROTO_ENCAP)

JOKER CONSTANT IPPROTO_ESP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_ESP"}
  IPPROTO_ESP)

JOKER CONSTANT IPPROTO_FRAGMENT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_FRAGMENT"}
  IPPROTO_FRAGMENT)

JOKER CONSTANT IPPROTO_GRE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_GRE"}
  IPPROTO_GRE)

JOKER CONSTANT IPPROTO_HOPOPTS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_HOPOPTS"}
  IPPROTO_HOPOPTS)

JOKER CONSTANT IPPROTO_ICMP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_ICMP"}
  IPPROTO_ICMP)

JOKER CONSTANT IPPROTO_ICMPV6 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_ICMPV6"}
  IPPROTO_ICMPV6)

JOKER CONSTANT IPPROTO_IDP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_IDP"}
  IPPROTO_IDP)

JOKER CONSTANT IPPROTO_IGMP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_IGMP"}
  IPPROTO_IGMP)

JOKER CONSTANT IPPROTO_IP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_IP"}
  IPPROTO_IP)

JOKER CONSTANT IPPROTO_IPIP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_IPIP"}
  IPPROTO_IPIP)

JOKER CONSTANT IPPROTO_IPV6 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_IPV6"}
  IPPROTO_IPV6)

JOKER CONSTANT IPPROTO_MTP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_MTP"}
  IPPROTO_MTP)

JOKER CONSTANT IPPROTO_NONE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_NONE"}
  IPPROTO_NONE)

JOKER CONSTANT IPPROTO_PIM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_PIM"}
  IPPROTO_PIM)

JOKER CONSTANT IPPROTO_PUP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_PUP"}
  IPPROTO_PUP)

JOKER CONSTANT IPPROTO_RAW from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_RAW"}
  IPPROTO_RAW)

JOKER CONSTANT IPPROTO_ROUTING from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_ROUTING"}
  IPPROTO_ROUTING)

JOKER CONSTANT IPPROTO_RSVP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_RSVP"}
  IPPROTO_RSVP)

JOKER CONSTANT IPPROTO_SCTP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_SCTP"}
  IPPROTO_SCTP)

JOKER CONSTANT IPPROTO_TCP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_TCP"}
  IPPROTO_TCP)

JOKER CONSTANT IPPROTO_TP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_TP"}
  IPPROTO_TP)

JOKER CONSTANT IPPROTO_UDP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_UDP"}
  IPPROTO_UDP)

JOKER CONSTANT IPPROTO_UDPLITE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPPROTO_UDPLITE"}
  IPPROTO_UDPLITE)

JOKER CONSTANT IPV6_2292DSTOPTS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_2292DSTOPTS"}
  IPV6_2292DSTOPTS)

JOKER CONSTANT IPV6_2292HOPLIMIT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_2292HOPLIMIT"}
  IPV6_2292HOPLIMIT)

JOKER CONSTANT IPV6_2292HOPOPTS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_2292HOPOPTS"}
  IPV6_2292HOPOPTS)

JOKER CONSTANT IPV6_2292PKTINFO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_2292PKTINFO"}
  IPV6_2292PKTINFO)

JOKER CONSTANT IPV6_2292PKTOPTIONS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_2292PKTOPTIONS"}
  IPV6_2292PKTOPTIONS)

JOKER CONSTANT IPV6_2292RTHDR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_2292RTHDR"}
  IPV6_2292RTHDR)

JOKER CONSTANT IPV6_ADDRFORM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_ADDRFORM"}
  IPV6_ADDRFORM)

JOKER CONSTANT IPV6_ADD_MEMBERSHIP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_ADD_MEMBERSHIP"}
  IPV6_ADD_MEMBERSHIP)

JOKER CONSTANT IPV6_AUTHHDR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_AUTHHDR"}
  IPV6_AUTHHDR)

JOKER CONSTANT IPV6_CHECKSUM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_CHECKSUM"}
  IPV6_CHECKSUM)

JOKER CONSTANT IPV6_DROP_MEMBERSHIP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_DROP_MEMBERSHIP"}
  IPV6_DROP_MEMBERSHIP)

JOKER CONSTANT IPV6_DSTOPTS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_DSTOPTS"}
  IPV6_DSTOPTS)

JOKER CONSTANT IPV6_HOPLIMIT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_HOPLIMIT"}
  IPV6_HOPLIMIT)

JOKER CONSTANT IPV6_HOPOPTS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_HOPOPTS"}
  IPV6_HOPOPTS)

JOKER CONSTANT IPV6_IPSEC_POLICY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_IPSEC_POLICY"}
  IPV6_IPSEC_POLICY)

JOKER CONSTANT IPV6_JOIN_ANYCAST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_JOIN_ANYCAST"}
  IPV6_JOIN_ANYCAST)

JOKER CONSTANT IPV6_JOIN_GROUP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_JOIN_GROUP"}
  IPV6_JOIN_GROUP)

JOKER CONSTANT IPV6_LEAVE_ANYCAST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_LEAVE_ANYCAST"}
  IPV6_LEAVE_ANYCAST)

JOKER CONSTANT IPV6_LEAVE_GROUP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_LEAVE_GROUP"}
  IPV6_LEAVE_GROUP)

JOKER CONSTANT IPV6_MTU from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_MTU"}
  IPV6_MTU)

JOKER CONSTANT IPV6_MTU_DISCOVER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_MTU_DISCOVER"}
  IPV6_MTU_DISCOVER)

JOKER CONSTANT IPV6_MULTICAST_HOPS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_MULTICAST_HOPS"}
  IPV6_MULTICAST_HOPS)

JOKER CONSTANT IPV6_MULTICAST_IF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_MULTICAST_IF"}
  IPV6_MULTICAST_IF)

JOKER CONSTANT IPV6_MULTICAST_LOOP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_MULTICAST_LOOP"}
  IPV6_MULTICAST_LOOP)

JOKER CONSTANT IPV6_NEXTHOP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_NEXTHOP"}
  IPV6_NEXTHOP)

JOKER CONSTANT IPV6_PKTINFO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_PKTINFO"}
  IPV6_PKTINFO)

JOKER CONSTANT IPV6_PMTUDISC_DO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_PMTUDISC_DO"}
  IPV6_PMTUDISC_DO)

JOKER CONSTANT IPV6_PMTUDISC_DONT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_PMTUDISC_DONT"}
  IPV6_PMTUDISC_DONT)

JOKER CONSTANT IPV6_PMTUDISC_PROBE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_PMTUDISC_PROBE"}
  IPV6_PMTUDISC_PROBE)

JOKER CONSTANT IPV6_PMTUDISC_WANT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_PMTUDISC_WANT"}
  IPV6_PMTUDISC_WANT)

JOKER CONSTANT IPV6_RECVDSTOPTS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_RECVDSTOPTS"}
  IPV6_RECVDSTOPTS)

JOKER CONSTANT IPV6_RECVERR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_RECVERR"}
  IPV6_RECVERR)

JOKER CONSTANT IPV6_RECVHOPLIMIT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_RECVHOPLIMIT"}
  IPV6_RECVHOPLIMIT)

JOKER CONSTANT IPV6_RECVHOPOPTS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_RECVHOPOPTS"}
  IPV6_RECVHOPOPTS)

JOKER CONSTANT IPV6_RECVPKTINFO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_RECVPKTINFO"}
  IPV6_RECVPKTINFO)

JOKER CONSTANT IPV6_RECVRTHDR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_RECVRTHDR"}
  IPV6_RECVRTHDR)

JOKER CONSTANT IPV6_RECVTCLASS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_RECVTCLASS"}
  IPV6_RECVTCLASS)

JOKER CONSTANT IPV6_ROUTER_ALERT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_ROUTER_ALERT"}
  IPV6_ROUTER_ALERT)

JOKER CONSTANT IPV6_RTHDR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_RTHDR"}
  IPV6_RTHDR)

JOKER CONSTANT IPV6_RTHDRDSTOPTS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_RTHDRDSTOPTS"}
  IPV6_RTHDRDSTOPTS)

JOKER CONSTANT IPV6_RTHDR_LOOSE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_RTHDR_LOOSE"}
  IPV6_RTHDR_LOOSE)

JOKER CONSTANT IPV6_RTHDR_STRICT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_RTHDR_STRICT"}
  IPV6_RTHDR_STRICT)

JOKER CONSTANT IPV6_RTHDR_TYPE_0 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_RTHDR_TYPE_0"}
  IPV6_RTHDR_TYPE_0)

JOKER CONSTANT IPV6_RXDSTOPTS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_RXDSTOPTS"}
  IPV6_RXDSTOPTS)

JOKER CONSTANT IPV6_RXHOPOPTS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_RXHOPOPTS"}
  IPV6_RXHOPOPTS)

JOKER CONSTANT IPV6_TCLASS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_TCLASS"}
  IPV6_TCLASS)

JOKER CONSTANT IPV6_UNICAST_HOPS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_UNICAST_HOPS"}
  IPV6_UNICAST_HOPS)

JOKER CONSTANT IPV6_V6ONLY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_V6ONLY"}
  IPV6_V6ONLY)

JOKER CONSTANT IPV6_XFRM_POLICY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IPV6_XFRM_POLICY"}
  IPV6_XFRM_POLICY)

JOKER CONSTANT IP_ADD_MEMBERSHIP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_ADD_MEMBERSHIP"}
  IP_ADD_MEMBERSHIP)

JOKER CONSTANT IP_ADD_SOURCE_MEMBERSHIP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_ADD_SOURCE_MEMBERSHIP"}
  IP_ADD_SOURCE_MEMBERSHIP)

JOKER CONSTANT IP_BLOCK_SOURCE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_BLOCK_SOURCE"}
  IP_BLOCK_SOURCE)

JOKER CONSTANT IP_DEFAULT_MULTICAST_LOOP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_DEFAULT_MULTICAST_LOOP"}
  IP_DEFAULT_MULTICAST_LOOP)

JOKER CONSTANT IP_DEFAULT_MULTICAST_TTL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_DEFAULT_MULTICAST_TTL"}
  IP_DEFAULT_MULTICAST_TTL)

JOKER CONSTANT IP_DF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_DF"}
  IP_DF)

JOKER CONSTANT IP_DROP_MEMBERSHIP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_DROP_MEMBERSHIP"}
  IP_DROP_MEMBERSHIP)

JOKER CONSTANT IP_DROP_SOURCE_MEMBERSHIP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_DROP_SOURCE_MEMBERSHIP"}
  IP_DROP_SOURCE_MEMBERSHIP)

JOKER CONSTANT IP_FREEBIND from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_FREEBIND"}
  IP_FREEBIND)

JOKER CONSTANT IP_HDRINCL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_HDRINCL"}
  IP_HDRINCL)

JOKER CONSTANT IP_IPSEC_POLICY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_IPSEC_POLICY"}
  IP_IPSEC_POLICY)

JOKER CONSTANT IP_MAXPACKET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_MAXPACKET"}
  IP_MAXPACKET)

JOKER CONSTANT IP_MAX_MEMBERSHIPS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_MAX_MEMBERSHIPS"}
  IP_MAX_MEMBERSHIPS)

JOKER CONSTANT IP_MF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_MF"}
  IP_MF)

JOKER CONSTANT IP_MINTTL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_MINTTL"}
  IP_MINTTL)

JOKER CONSTANT IP_MSFILTER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_MSFILTER"}
  IP_MSFILTER)

JOKER CONSTANT IP_MSS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_MSS"}
  IP_MSS)

JOKER CONSTANT IP_MTU from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_MTU"}
  IP_MTU)

JOKER CONSTANT IP_MTU_DISCOVER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_MTU_DISCOVER"}
  IP_MTU_DISCOVER)

JOKER CONSTANT IP_MULTICAST_IF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_MULTICAST_IF"}
  IP_MULTICAST_IF)

JOKER CONSTANT IP_MULTICAST_LOOP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_MULTICAST_LOOP"}
  IP_MULTICAST_LOOP)

JOKER CONSTANT IP_MULTICAST_TTL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_MULTICAST_TTL"}
  IP_MULTICAST_TTL)

JOKER CONSTANT IP_OFFMASK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_OFFMASK"}
  IP_OFFMASK)

JOKER CONSTANT IP_OPTIONS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_OPTIONS"}
  IP_OPTIONS)

JOKER CONSTANT IP_ORIGDSTADDR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_ORIGDSTADDR"}
  IP_ORIGDSTADDR)

JOKER CONSTANT IP_PASSSEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_PASSSEC"}
  IP_PASSSEC)

JOKER CONSTANT IP_PKTINFO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_PKTINFO"}
  IP_PKTINFO)

JOKER CONSTANT IP_PKTOPTIONS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_PKTOPTIONS"}
  IP_PKTOPTIONS)

JOKER CONSTANT IP_PMTUDISC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_PMTUDISC"}
  IP_PMTUDISC)

JOKER CONSTANT IP_PMTUDISC_DO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_PMTUDISC_DO"}
  IP_PMTUDISC_DO)

JOKER CONSTANT IP_PMTUDISC_DONT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_PMTUDISC_DONT"}
  IP_PMTUDISC_DONT)

JOKER CONSTANT IP_PMTUDISC_PROBE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_PMTUDISC_PROBE"}
  IP_PMTUDISC_PROBE)

JOKER CONSTANT IP_PMTUDISC_WANT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_PMTUDISC_WANT"}
  IP_PMTUDISC_WANT)

JOKER CONSTANT IP_RECVERR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_RECVERR"}
  IP_RECVERR)

JOKER CONSTANT IP_RECVOPTS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_RECVOPTS"}
  IP_RECVOPTS)

JOKER CONSTANT IP_RECVORIGDSTADDR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_RECVORIGDSTADDR"}
  IP_RECVORIGDSTADDR)

JOKER CONSTANT IP_RECVRETOPTS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_RECVRETOPTS"}
  IP_RECVRETOPTS)

JOKER CONSTANT IP_RECVTOS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_RECVTOS"}
  IP_RECVTOS)

JOKER CONSTANT IP_RECVTTL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_RECVTTL"}
  IP_RECVTTL)

JOKER CONSTANT IP_RETOPTS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_RETOPTS"}
  IP_RETOPTS)

JOKER CONSTANT IP_RF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_RF"}
  IP_RF)

JOKER CONSTANT IP_ROUTER_ALERT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_ROUTER_ALERT"}
  IP_ROUTER_ALERT)

JOKER CONSTANT IP_TOS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_TOS"}
  IP_TOS)

JOKER CONSTANT IP_TRANSPARENT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_TRANSPARENT"}
  IP_TRANSPARENT)

JOKER CONSTANT IP_TTL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_TTL"}
  IP_TTL)

JOKER CONSTANT IP_UNBLOCK_SOURCE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_UNBLOCK_SOURCE"}
  IP_UNBLOCK_SOURCE)

JOKER CONSTANT IP_XFRM_POLICY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IP_XFRM_POLICY"}
  IP_XFRM_POLICY)

JOKER CONSTANT ISIG from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ISIG"}
  ISIG)

JOKER CONSTANT ISTRIP from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ISTRIP"}
  ISTRIP)

JOKER CONSTANT IUCLC from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IUCLC"}
  IUCLC)

JOKER CONSTANT IUTF8 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IUTF8"}
  IUTF8)

JOKER CONSTANT IXANY from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IXANY"}
  IXANY)

JOKER CONSTANT IXOFF from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IXOFF"}
  IXOFF)

JOKER CONSTANT IXON from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.IXON"}
  IXON)

JOKER CONSTANT ImplementsGetwd from syscall/syscall_linux.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Boolean"
    :go "syscall.ImplementsGetwd"}
  ImplementsGetwd)

JOKER CONSTANT LINUX_REBOOT_CMD_CAD_OFF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.LINUX_REBOOT_CMD_CAD_OFF"}
  LINUX_REBOOT_CMD_CAD_OFF)

JOKER CONSTANT LINUX_REBOOT_CMD_CAD_ON from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.LINUX_REBOOT_CMD_CAD_ON)"}
  LINUX_REBOOT_CMD_CAD_ON)

JOKER CONSTANT LINUX_REBOOT_CMD_HALT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.LINUX_REBOOT_CMD_HALT)"}
  LINUX_REBOOT_CMD_HALT)

JOKER CONSTANT LINUX_REBOOT_CMD_KEXEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.LINUX_REBOOT_CMD_KEXEC"}
  LINUX_REBOOT_CMD_KEXEC)

JOKER CONSTANT LINUX_REBOOT_CMD_POWER_OFF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.LINUX_REBOOT_CMD_POWER_OFF"}
  LINUX_REBOOT_CMD_POWER_OFF)

JOKER CONSTANT LINUX_REBOOT_CMD_RESTART from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.LINUX_REBOOT_CMD_RESTART"}
  LINUX_REBOOT_CMD_RESTART)

JOKER CONSTANT LINUX_REBOOT_CMD_RESTART2 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.LINUX_REBOOT_CMD_RESTART2)"}
  LINUX_REBOOT_CMD_RESTART2)

JOKER CONSTANT LINUX_REBOOT_CMD_SW_SUSPEND from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.LINUX_REBOOT_CMD_SW_SUSPEND)"}
  LINUX_REBOOT_CMD_SW_SUSPEND)

JOKER CONSTANT LINUX_REBOOT_MAGIC1 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.LINUX_REBOOT_MAGIC1)"}
  LINUX_REBOOT_MAGIC1)

JOKER CONSTANT LINUX_REBOOT_MAGIC2 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.LINUX_REBOOT_MAGIC2"}
  LINUX_REBOOT_MAGIC2)

JOKER CONSTANT LOCK_EX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.LOCK_EX"}
  LOCK_EX)

JOKER CONSTANT LOCK_NB from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.LOCK_NB"}
  LOCK_NB)

JOKER CONSTANT LOCK_SH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.LOCK_SH"}
  LOCK_SH)

JOKER CONSTANT LOCK_UN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.LOCK_UN"}
  LOCK_UN)

JOKER CONSTANT MADV_DOFORK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MADV_DOFORK"}
  MADV_DOFORK)

JOKER CONSTANT MADV_DONTFORK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MADV_DONTFORK"}
  MADV_DONTFORK)

JOKER CONSTANT MADV_DONTNEED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MADV_DONTNEED"}
  MADV_DONTNEED)

JOKER CONSTANT MADV_HUGEPAGE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MADV_HUGEPAGE"}
  MADV_HUGEPAGE)

JOKER CONSTANT MADV_HWPOISON from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MADV_HWPOISON"}
  MADV_HWPOISON)

JOKER CONSTANT MADV_MERGEABLE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MADV_MERGEABLE"}
  MADV_MERGEABLE)

JOKER CONSTANT MADV_NOHUGEPAGE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MADV_NOHUGEPAGE"}
  MADV_NOHUGEPAGE)

JOKER CONSTANT MADV_NORMAL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MADV_NORMAL"}
  MADV_NORMAL)

JOKER CONSTANT MADV_RANDOM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MADV_RANDOM"}
  MADV_RANDOM)

JOKER CONSTANT MADV_REMOVE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MADV_REMOVE"}
  MADV_REMOVE)

JOKER CONSTANT MADV_SEQUENTIAL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MADV_SEQUENTIAL"}
  MADV_SEQUENTIAL)

JOKER CONSTANT MADV_UNMERGEABLE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MADV_UNMERGEABLE"}
  MADV_UNMERGEABLE)

JOKER CONSTANT MADV_WILLNEED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MADV_WILLNEED"}
  MADV_WILLNEED)

JOKER CONSTANT MAP_32BIT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MAP_32BIT"}
  MAP_32BIT)

JOKER CONSTANT MAP_ANON from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MAP_ANON"}
  MAP_ANON)

JOKER CONSTANT MAP_ANONYMOUS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MAP_ANONYMOUS"}
  MAP_ANONYMOUS)

JOKER CONSTANT MAP_DENYWRITE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MAP_DENYWRITE"}
  MAP_DENYWRITE)

JOKER CONSTANT MAP_EXECUTABLE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MAP_EXECUTABLE"}
  MAP_EXECUTABLE)

JOKER CONSTANT MAP_FILE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MAP_FILE"}
  MAP_FILE)

JOKER CONSTANT MAP_FIXED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MAP_FIXED"}
  MAP_FIXED)

JOKER CONSTANT MAP_GROWSDOWN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MAP_GROWSDOWN"}
  MAP_GROWSDOWN)

JOKER CONSTANT MAP_HUGETLB from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MAP_HUGETLB"}
  MAP_HUGETLB)

JOKER CONSTANT MAP_LOCKED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MAP_LOCKED"}
  MAP_LOCKED)

JOKER CONSTANT MAP_NONBLOCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MAP_NONBLOCK"}
  MAP_NONBLOCK)

JOKER CONSTANT MAP_NORESERVE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MAP_NORESERVE"}
  MAP_NORESERVE)

JOKER CONSTANT MAP_POPULATE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MAP_POPULATE"}
  MAP_POPULATE)

JOKER CONSTANT MAP_PRIVATE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MAP_PRIVATE"}
  MAP_PRIVATE)

JOKER CONSTANT MAP_SHARED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MAP_SHARED"}
  MAP_SHARED)

JOKER CONSTANT MAP_STACK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MAP_STACK"}
  MAP_STACK)

JOKER CONSTANT MAP_TYPE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MAP_TYPE"}
  MAP_TYPE)

JOKER CONSTANT MCL_CURRENT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MCL_CURRENT"}
  MCL_CURRENT)

JOKER CONSTANT MCL_FUTURE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MCL_FUTURE"}
  MCL_FUTURE)

JOKER CONSTANT MNT_DETACH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MNT_DETACH"}
  MNT_DETACH)

JOKER CONSTANT MNT_EXPIRE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MNT_EXPIRE"}
  MNT_EXPIRE)

JOKER CONSTANT MNT_FORCE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MNT_FORCE"}
  MNT_FORCE)

JOKER CONSTANT MSG_CMSG_CLOEXEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MSG_CMSG_CLOEXEC"}
  MSG_CMSG_CLOEXEC)

JOKER CONSTANT MSG_CONFIRM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MSG_CONFIRM"}
  MSG_CONFIRM)

JOKER CONSTANT MSG_CTRUNC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MSG_CTRUNC"}
  MSG_CTRUNC)

JOKER CONSTANT MSG_DONTROUTE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MSG_DONTROUTE"}
  MSG_DONTROUTE)

JOKER CONSTANT MSG_DONTWAIT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MSG_DONTWAIT"}
  MSG_DONTWAIT)

JOKER CONSTANT MSG_EOR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MSG_EOR"}
  MSG_EOR)

JOKER CONSTANT MSG_ERRQUEUE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MSG_ERRQUEUE"}
  MSG_ERRQUEUE)

JOKER CONSTANT MSG_FASTOPEN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MSG_FASTOPEN"}
  MSG_FASTOPEN)

JOKER CONSTANT MSG_FIN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MSG_FIN"}
  MSG_FIN)

JOKER CONSTANT MSG_MORE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MSG_MORE"}
  MSG_MORE)

JOKER CONSTANT MSG_NOSIGNAL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MSG_NOSIGNAL"}
  MSG_NOSIGNAL)

JOKER CONSTANT MSG_OOB from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MSG_OOB"}
  MSG_OOB)

JOKER CONSTANT MSG_PEEK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MSG_PEEK"}
  MSG_PEEK)

JOKER CONSTANT MSG_PROXY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MSG_PROXY"}
  MSG_PROXY)

JOKER CONSTANT MSG_RST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MSG_RST"}
  MSG_RST)

JOKER CONSTANT MSG_SYN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MSG_SYN"}
  MSG_SYN)

JOKER CONSTANT MSG_TRUNC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MSG_TRUNC"}
  MSG_TRUNC)

JOKER CONSTANT MSG_TRYHARD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MSG_TRYHARD"}
  MSG_TRYHARD)

JOKER CONSTANT MSG_WAITALL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MSG_WAITALL"}
  MSG_WAITALL)

JOKER CONSTANT MSG_WAITFORONE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MSG_WAITFORONE"}
  MSG_WAITFORONE)

JOKER CONSTANT MS_ACTIVE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_ACTIVE"}
  MS_ACTIVE)

JOKER CONSTANT MS_ASYNC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_ASYNC"}
  MS_ASYNC)

JOKER CONSTANT MS_BIND from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_BIND"}
  MS_BIND)

JOKER CONSTANT MS_DIRSYNC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_DIRSYNC"}
  MS_DIRSYNC)

JOKER CONSTANT MS_INVALIDATE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_INVALIDATE"}
  MS_INVALIDATE)

JOKER CONSTANT MS_I_VERSION from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_I_VERSION"}
  MS_I_VERSION)

JOKER CONSTANT MS_KERNMOUNT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_KERNMOUNT"}
  MS_KERNMOUNT)

JOKER CONSTANT MS_MANDLOCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_MANDLOCK"}
  MS_MANDLOCK)

JOKER CONSTANT MS_MGC_MSK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.MS_MGC_MSK)"}
  MS_MGC_MSK)

JOKER CONSTANT MS_MGC_VAL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.MS_MGC_VAL)"}
  MS_MGC_VAL)

JOKER CONSTANT MS_MOVE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_MOVE"}
  MS_MOVE)

JOKER CONSTANT MS_NOATIME from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_NOATIME"}
  MS_NOATIME)

JOKER CONSTANT MS_NODEV from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_NODEV"}
  MS_NODEV)

JOKER CONSTANT MS_NODIRATIME from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_NODIRATIME"}
  MS_NODIRATIME)

JOKER CONSTANT MS_NOEXEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_NOEXEC"}
  MS_NOEXEC)

JOKER CONSTANT MS_NOSUID from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_NOSUID"}
  MS_NOSUID)

JOKER CONSTANT MS_NOUSER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.MS_NOUSER)"}
  MS_NOUSER)

JOKER CONSTANT MS_POSIXACL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_POSIXACL"}
  MS_POSIXACL)

JOKER CONSTANT MS_PRIVATE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_PRIVATE"}
  MS_PRIVATE)

JOKER CONSTANT MS_RDONLY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_RDONLY"}
  MS_RDONLY)

JOKER CONSTANT MS_REC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_REC"}
  MS_REC)

JOKER CONSTANT MS_RELATIME from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_RELATIME"}
  MS_RELATIME)

JOKER CONSTANT MS_REMOUNT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_REMOUNT"}
  MS_REMOUNT)

JOKER CONSTANT MS_RMT_MASK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_RMT_MASK"}
  MS_RMT_MASK)

JOKER CONSTANT MS_SHARED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_SHARED"}
  MS_SHARED)

JOKER CONSTANT MS_SILENT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_SILENT"}
  MS_SILENT)

JOKER CONSTANT MS_SLAVE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_SLAVE"}
  MS_SLAVE)

JOKER CONSTANT MS_STRICTATIME from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_STRICTATIME"}
  MS_STRICTATIME)

JOKER CONSTANT MS_SYNC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_SYNC"}
  MS_SYNC)

JOKER CONSTANT MS_SYNCHRONOUS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_SYNCHRONOUS"}
  MS_SYNCHRONOUS)

JOKER CONSTANT MS_UNBINDABLE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.MS_UNBINDABLE"}
  MS_UNBINDABLE)

JOKER CONSTANT NAME_MAX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NAME_MAX"}
  NAME_MAX)

JOKER CONSTANT NETLINK_ADD_MEMBERSHIP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_ADD_MEMBERSHIP"}
  NETLINK_ADD_MEMBERSHIP)

JOKER CONSTANT NETLINK_AUDIT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_AUDIT"}
  NETLINK_AUDIT)

JOKER CONSTANT NETLINK_BROADCAST_ERROR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_BROADCAST_ERROR"}
  NETLINK_BROADCAST_ERROR)

JOKER CONSTANT NETLINK_CONNECTOR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_CONNECTOR"}
  NETLINK_CONNECTOR)

JOKER CONSTANT NETLINK_DNRTMSG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_DNRTMSG"}
  NETLINK_DNRTMSG)

JOKER CONSTANT NETLINK_DROP_MEMBERSHIP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_DROP_MEMBERSHIP"}
  NETLINK_DROP_MEMBERSHIP)

JOKER CONSTANT NETLINK_ECRYPTFS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_ECRYPTFS"}
  NETLINK_ECRYPTFS)

JOKER CONSTANT NETLINK_FIB_LOOKUP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_FIB_LOOKUP"}
  NETLINK_FIB_LOOKUP)

JOKER CONSTANT NETLINK_FIREWALL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_FIREWALL"}
  NETLINK_FIREWALL)

JOKER CONSTANT NETLINK_GENERIC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_GENERIC"}
  NETLINK_GENERIC)

JOKER CONSTANT NETLINK_INET_DIAG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_INET_DIAG"}
  NETLINK_INET_DIAG)

JOKER CONSTANT NETLINK_IP6_FW from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_IP6_FW"}
  NETLINK_IP6_FW)

JOKER CONSTANT NETLINK_ISCSI from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_ISCSI"}
  NETLINK_ISCSI)

JOKER CONSTANT NETLINK_KOBJECT_UEVENT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_KOBJECT_UEVENT"}
  NETLINK_KOBJECT_UEVENT)

JOKER CONSTANT NETLINK_NETFILTER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_NETFILTER"}
  NETLINK_NETFILTER)

JOKER CONSTANT NETLINK_NFLOG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_NFLOG"}
  NETLINK_NFLOG)

JOKER CONSTANT NETLINK_NO_ENOBUFS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_NO_ENOBUFS"}
  NETLINK_NO_ENOBUFS)

JOKER CONSTANT NETLINK_PKTINFO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_PKTINFO"}
  NETLINK_PKTINFO)

JOKER CONSTANT NETLINK_ROUTE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_ROUTE"}
  NETLINK_ROUTE)

JOKER CONSTANT NETLINK_SCSITRANSPORT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_SCSITRANSPORT"}
  NETLINK_SCSITRANSPORT)

JOKER CONSTANT NETLINK_SELINUX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_SELINUX"}
  NETLINK_SELINUX)

JOKER CONSTANT NETLINK_UNUSED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_UNUSED"}
  NETLINK_UNUSED)

JOKER CONSTANT NETLINK_USERSOCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_USERSOCK"}
  NETLINK_USERSOCK)

JOKER CONSTANT NETLINK_XFRM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NETLINK_XFRM"}
  NETLINK_XFRM)

JOKER CONSTANT NLA_ALIGNTO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLA_ALIGNTO"}
  NLA_ALIGNTO)

JOKER CONSTANT NLA_F_NESTED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLA_F_NESTED"}
  NLA_F_NESTED)

JOKER CONSTANT NLA_F_NET_BYTEORDER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLA_F_NET_BYTEORDER"}
  NLA_F_NET_BYTEORDER)

JOKER CONSTANT NLA_HDRLEN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLA_HDRLEN"}
  NLA_HDRLEN)

JOKER CONSTANT NLMSG_ALIGNTO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLMSG_ALIGNTO"}
  NLMSG_ALIGNTO)

JOKER CONSTANT NLMSG_DONE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLMSG_DONE"}
  NLMSG_DONE)

JOKER CONSTANT NLMSG_ERROR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLMSG_ERROR"}
  NLMSG_ERROR)

JOKER CONSTANT NLMSG_HDRLEN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLMSG_HDRLEN"}
  NLMSG_HDRLEN)

JOKER CONSTANT NLMSG_MIN_TYPE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLMSG_MIN_TYPE"}
  NLMSG_MIN_TYPE)

JOKER CONSTANT NLMSG_NOOP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLMSG_NOOP"}
  NLMSG_NOOP)

JOKER CONSTANT NLMSG_OVERRUN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLMSG_OVERRUN"}
  NLMSG_OVERRUN)

JOKER CONSTANT NLM_F_ACK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLM_F_ACK"}
  NLM_F_ACK)

JOKER CONSTANT NLM_F_APPEND from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLM_F_APPEND"}
  NLM_F_APPEND)

JOKER CONSTANT NLM_F_ATOMIC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLM_F_ATOMIC"}
  NLM_F_ATOMIC)

JOKER CONSTANT NLM_F_CREATE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLM_F_CREATE"}
  NLM_F_CREATE)

JOKER CONSTANT NLM_F_DUMP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLM_F_DUMP"}
  NLM_F_DUMP)

JOKER CONSTANT NLM_F_ECHO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLM_F_ECHO"}
  NLM_F_ECHO)

JOKER CONSTANT NLM_F_EXCL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLM_F_EXCL"}
  NLM_F_EXCL)

JOKER CONSTANT NLM_F_MATCH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLM_F_MATCH"}
  NLM_F_MATCH)

JOKER CONSTANT NLM_F_MULTI from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLM_F_MULTI"}
  NLM_F_MULTI)

JOKER CONSTANT NLM_F_REPLACE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLM_F_REPLACE"}
  NLM_F_REPLACE)

JOKER CONSTANT NLM_F_REQUEST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLM_F_REQUEST"}
  NLM_F_REQUEST)

JOKER CONSTANT NLM_F_ROOT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NLM_F_ROOT"}
  NLM_F_ROOT)

JOKER CONSTANT NOFLSH from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.NOFLSH"}
  NOFLSH)

JOKER CONSTANT OCRNL from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.OCRNL"}
  OCRNL)

JOKER CONSTANT OFDEL from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.OFDEL"}
  OFDEL)

JOKER CONSTANT OFILL from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.OFILL"}
  OFILL)

JOKER CONSTANT OLCUC from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.OLCUC"}
  OLCUC)

JOKER CONSTANT ONLCR from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ONLCR"}
  ONLCR)

JOKER CONSTANT ONLRET from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ONLRET"}
  ONLRET)

JOKER CONSTANT ONOCR from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.ONOCR"}
  ONOCR)

JOKER CONSTANT OPOST from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.OPOST"}
  OPOST)

JOKER CONSTANT O_ACCMODE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_ACCMODE"}
  O_ACCMODE)

JOKER CONSTANT O_APPEND from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_APPEND"}
  O_APPEND)

JOKER CONSTANT O_ASYNC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_ASYNC"}
  O_ASYNC)

JOKER CONSTANT O_CLOEXEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_CLOEXEC"}
  O_CLOEXEC)

JOKER CONSTANT O_CREAT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_CREAT"}
  O_CREAT)

JOKER CONSTANT O_DIRECT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_DIRECT"}
  O_DIRECT)

JOKER CONSTANT O_DIRECTORY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_DIRECTORY"}
  O_DIRECTORY)

JOKER CONSTANT O_DSYNC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_DSYNC"}
  O_DSYNC)

JOKER CONSTANT O_EXCL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_EXCL"}
  O_EXCL)

JOKER CONSTANT O_FSYNC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_FSYNC"}
  O_FSYNC)

JOKER CONSTANT O_LARGEFILE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_LARGEFILE"}
  O_LARGEFILE)

JOKER CONSTANT O_NDELAY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_NDELAY"}
  O_NDELAY)

JOKER CONSTANT O_NOATIME from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_NOATIME"}
  O_NOATIME)

JOKER CONSTANT O_NOCTTY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_NOCTTY"}
  O_NOCTTY)

JOKER CONSTANT O_NOFOLLOW from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_NOFOLLOW"}
  O_NOFOLLOW)

JOKER CONSTANT O_NONBLOCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_NONBLOCK"}
  O_NONBLOCK)

JOKER CONSTANT O_RDONLY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_RDONLY"}
  O_RDONLY)

JOKER CONSTANT O_RDWR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_RDWR"}
  O_RDWR)

JOKER CONSTANT O_RSYNC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_RSYNC"}
  O_RSYNC)

JOKER CONSTANT O_SYNC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_SYNC"}
  O_SYNC)

JOKER CONSTANT O_TRUNC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_TRUNC"}
  O_TRUNC)

JOKER CONSTANT O_WRONLY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.O_WRONLY"}
  O_WRONLY)

JOKER CONSTANT PACKET_ADD_MEMBERSHIP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PACKET_ADD_MEMBERSHIP"}
  PACKET_ADD_MEMBERSHIP)

JOKER CONSTANT PACKET_BROADCAST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PACKET_BROADCAST"}
  PACKET_BROADCAST)

JOKER CONSTANT PACKET_DROP_MEMBERSHIP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PACKET_DROP_MEMBERSHIP"}
  PACKET_DROP_MEMBERSHIP)

JOKER CONSTANT PACKET_FASTROUTE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PACKET_FASTROUTE"}
  PACKET_FASTROUTE)

JOKER CONSTANT PACKET_HOST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PACKET_HOST"}
  PACKET_HOST)

JOKER CONSTANT PACKET_LOOPBACK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PACKET_LOOPBACK"}
  PACKET_LOOPBACK)

JOKER CONSTANT PACKET_MR_ALLMULTI from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PACKET_MR_ALLMULTI"}
  PACKET_MR_ALLMULTI)

JOKER CONSTANT PACKET_MR_MULTICAST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PACKET_MR_MULTICAST"}
  PACKET_MR_MULTICAST)

JOKER CONSTANT PACKET_MR_PROMISC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PACKET_MR_PROMISC"}
  PACKET_MR_PROMISC)

JOKER CONSTANT PACKET_MULTICAST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PACKET_MULTICAST"}
  PACKET_MULTICAST)

JOKER CONSTANT PACKET_OTHERHOST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PACKET_OTHERHOST"}
  PACKET_OTHERHOST)

JOKER CONSTANT PACKET_OUTGOING from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PACKET_OUTGOING"}
  PACKET_OUTGOING)

JOKER CONSTANT PACKET_RECV_OUTPUT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PACKET_RECV_OUTPUT"}
  PACKET_RECV_OUTPUT)

JOKER CONSTANT PACKET_RX_RING from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PACKET_RX_RING"}
  PACKET_RX_RING)

JOKER CONSTANT PACKET_STATISTICS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PACKET_STATISTICS"}
  PACKET_STATISTICS)

JOKER CONSTANT PARENB from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PARENB"}
  PARENB)

JOKER CONSTANT PARMRK from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PARMRK"}
  PARMRK)

JOKER CONSTANT PARODD from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PARODD"}
  PARODD)

JOKER CONSTANT PENDIN from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PENDIN"}
  PENDIN)

JOKER CONSTANT PRIO_PGRP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PRIO_PGRP"}
  PRIO_PGRP)

JOKER CONSTANT PRIO_PROCESS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PRIO_PROCESS"}
  PRIO_PROCESS)

JOKER CONSTANT PRIO_USER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PRIO_USER"}
  PRIO_USER)

JOKER CONSTANT PROT_EXEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PROT_EXEC"}
  PROT_EXEC)

JOKER CONSTANT PROT_GROWSDOWN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PROT_GROWSDOWN"}
  PROT_GROWSDOWN)

JOKER CONSTANT PROT_GROWSUP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PROT_GROWSUP"}
  PROT_GROWSUP)

JOKER CONSTANT PROT_NONE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PROT_NONE"}
  PROT_NONE)

JOKER CONSTANT PROT_READ from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PROT_READ"}
  PROT_READ)

JOKER CONSTANT PROT_WRITE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PROT_WRITE"}
  PROT_WRITE)

JOKER CONSTANT PR_CAPBSET_DROP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_CAPBSET_DROP"}
  PR_CAPBSET_DROP)

JOKER CONSTANT PR_CAPBSET_READ from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_CAPBSET_READ"}
  PR_CAPBSET_READ)

JOKER CONSTANT PR_ENDIAN_BIG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_ENDIAN_BIG"}
  PR_ENDIAN_BIG)

JOKER CONSTANT PR_ENDIAN_LITTLE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_ENDIAN_LITTLE"}
  PR_ENDIAN_LITTLE)

JOKER CONSTANT PR_ENDIAN_PPC_LITTLE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_ENDIAN_PPC_LITTLE"}
  PR_ENDIAN_PPC_LITTLE)

JOKER CONSTANT PR_FPEMU_NOPRINT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_FPEMU_NOPRINT"}
  PR_FPEMU_NOPRINT)

JOKER CONSTANT PR_FPEMU_SIGFPE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_FPEMU_SIGFPE"}
  PR_FPEMU_SIGFPE)

JOKER CONSTANT PR_FP_EXC_ASYNC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_FP_EXC_ASYNC"}
  PR_FP_EXC_ASYNC)

JOKER CONSTANT PR_FP_EXC_DISABLED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_FP_EXC_DISABLED"}
  PR_FP_EXC_DISABLED)

JOKER CONSTANT PR_FP_EXC_DIV from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_FP_EXC_DIV"}
  PR_FP_EXC_DIV)

JOKER CONSTANT PR_FP_EXC_INV from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_FP_EXC_INV"}
  PR_FP_EXC_INV)

JOKER CONSTANT PR_FP_EXC_NONRECOV from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_FP_EXC_NONRECOV"}
  PR_FP_EXC_NONRECOV)

JOKER CONSTANT PR_FP_EXC_OVF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_FP_EXC_OVF"}
  PR_FP_EXC_OVF)

JOKER CONSTANT PR_FP_EXC_PRECISE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_FP_EXC_PRECISE"}
  PR_FP_EXC_PRECISE)

JOKER CONSTANT PR_FP_EXC_RES from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_FP_EXC_RES"}
  PR_FP_EXC_RES)

JOKER CONSTANT PR_FP_EXC_SW_ENABLE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_FP_EXC_SW_ENABLE"}
  PR_FP_EXC_SW_ENABLE)

JOKER CONSTANT PR_FP_EXC_UND from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_FP_EXC_UND"}
  PR_FP_EXC_UND)

JOKER CONSTANT PR_GET_DUMPABLE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_GET_DUMPABLE"}
  PR_GET_DUMPABLE)

JOKER CONSTANT PR_GET_ENDIAN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_GET_ENDIAN"}
  PR_GET_ENDIAN)

JOKER CONSTANT PR_GET_FPEMU from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_GET_FPEMU"}
  PR_GET_FPEMU)

JOKER CONSTANT PR_GET_FPEXC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_GET_FPEXC"}
  PR_GET_FPEXC)

JOKER CONSTANT PR_GET_KEEPCAPS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_GET_KEEPCAPS"}
  PR_GET_KEEPCAPS)

JOKER CONSTANT PR_GET_NAME from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_GET_NAME"}
  PR_GET_NAME)

JOKER CONSTANT PR_GET_PDEATHSIG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_GET_PDEATHSIG"}
  PR_GET_PDEATHSIG)

JOKER CONSTANT PR_GET_SECCOMP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_GET_SECCOMP"}
  PR_GET_SECCOMP)

JOKER CONSTANT PR_GET_SECUREBITS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_GET_SECUREBITS"}
  PR_GET_SECUREBITS)

JOKER CONSTANT PR_GET_TIMERSLACK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_GET_TIMERSLACK"}
  PR_GET_TIMERSLACK)

JOKER CONSTANT PR_GET_TIMING from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_GET_TIMING"}
  PR_GET_TIMING)

JOKER CONSTANT PR_GET_TSC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_GET_TSC"}
  PR_GET_TSC)

JOKER CONSTANT PR_GET_UNALIGN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_GET_UNALIGN"}
  PR_GET_UNALIGN)

JOKER CONSTANT PR_MCE_KILL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_MCE_KILL"}
  PR_MCE_KILL)

JOKER CONSTANT PR_MCE_KILL_CLEAR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_MCE_KILL_CLEAR"}
  PR_MCE_KILL_CLEAR)

JOKER CONSTANT PR_MCE_KILL_DEFAULT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_MCE_KILL_DEFAULT"}
  PR_MCE_KILL_DEFAULT)

JOKER CONSTANT PR_MCE_KILL_EARLY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_MCE_KILL_EARLY"}
  PR_MCE_KILL_EARLY)

JOKER CONSTANT PR_MCE_KILL_GET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_MCE_KILL_GET"}
  PR_MCE_KILL_GET)

JOKER CONSTANT PR_MCE_KILL_LATE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_MCE_KILL_LATE"}
  PR_MCE_KILL_LATE)

JOKER CONSTANT PR_MCE_KILL_SET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_MCE_KILL_SET"}
  PR_MCE_KILL_SET)

JOKER CONSTANT PR_SET_DUMPABLE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_SET_DUMPABLE"}
  PR_SET_DUMPABLE)

JOKER CONSTANT PR_SET_ENDIAN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_SET_ENDIAN"}
  PR_SET_ENDIAN)

JOKER CONSTANT PR_SET_FPEMU from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_SET_FPEMU"}
  PR_SET_FPEMU)

JOKER CONSTANT PR_SET_FPEXC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_SET_FPEXC"}
  PR_SET_FPEXC)

JOKER CONSTANT PR_SET_KEEPCAPS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_SET_KEEPCAPS"}
  PR_SET_KEEPCAPS)

JOKER CONSTANT PR_SET_NAME from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_SET_NAME"}
  PR_SET_NAME)

JOKER CONSTANT PR_SET_PDEATHSIG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_SET_PDEATHSIG"}
  PR_SET_PDEATHSIG)

JOKER CONSTANT PR_SET_PTRACER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_SET_PTRACER"}
  PR_SET_PTRACER)

JOKER CONSTANT PR_SET_SECCOMP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_SET_SECCOMP"}
  PR_SET_SECCOMP)

JOKER CONSTANT PR_SET_SECUREBITS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_SET_SECUREBITS"}
  PR_SET_SECUREBITS)

JOKER CONSTANT PR_SET_TIMERSLACK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_SET_TIMERSLACK"}
  PR_SET_TIMERSLACK)

JOKER CONSTANT PR_SET_TIMING from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_SET_TIMING"}
  PR_SET_TIMING)

JOKER CONSTANT PR_SET_TSC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_SET_TSC"}
  PR_SET_TSC)

JOKER CONSTANT PR_SET_UNALIGN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_SET_UNALIGN"}
  PR_SET_UNALIGN)

JOKER CONSTANT PR_TASK_PERF_EVENTS_DISABLE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_TASK_PERF_EVENTS_DISABLE"}
  PR_TASK_PERF_EVENTS_DISABLE)

JOKER CONSTANT PR_TASK_PERF_EVENTS_ENABLE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_TASK_PERF_EVENTS_ENABLE"}
  PR_TASK_PERF_EVENTS_ENABLE)

JOKER CONSTANT PR_TIMING_STATISTICAL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_TIMING_STATISTICAL"}
  PR_TIMING_STATISTICAL)

JOKER CONSTANT PR_TIMING_TIMESTAMP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_TIMING_TIMESTAMP"}
  PR_TIMING_TIMESTAMP)

JOKER CONSTANT PR_TSC_ENABLE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_TSC_ENABLE"}
  PR_TSC_ENABLE)

JOKER CONSTANT PR_TSC_SIGSEGV from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_TSC_SIGSEGV"}
  PR_TSC_SIGSEGV)

JOKER CONSTANT PR_UNALIGN_NOPRINT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_UNALIGN_NOPRINT"}
  PR_UNALIGN_NOPRINT)

JOKER CONSTANT PR_UNALIGN_SIGBUS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PR_UNALIGN_SIGBUS"}
  PR_UNALIGN_SIGBUS)

JOKER CONSTANT PTRACE_ARCH_PRCTL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_ARCH_PRCTL"}
  PTRACE_ARCH_PRCTL)

JOKER CONSTANT PTRACE_ATTACH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_ATTACH"}
  PTRACE_ATTACH)

JOKER CONSTANT PTRACE_CONT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_CONT"}
  PTRACE_CONT)

JOKER CONSTANT PTRACE_DETACH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_DETACH"}
  PTRACE_DETACH)

JOKER CONSTANT PTRACE_EVENT_CLONE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_EVENT_CLONE"}
  PTRACE_EVENT_CLONE)

JOKER CONSTANT PTRACE_EVENT_EXEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_EVENT_EXEC"}
  PTRACE_EVENT_EXEC)

JOKER CONSTANT PTRACE_EVENT_EXIT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_EVENT_EXIT"}
  PTRACE_EVENT_EXIT)

JOKER CONSTANT PTRACE_EVENT_FORK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_EVENT_FORK"}
  PTRACE_EVENT_FORK)

JOKER CONSTANT PTRACE_EVENT_VFORK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_EVENT_VFORK"}
  PTRACE_EVENT_VFORK)

JOKER CONSTANT PTRACE_EVENT_VFORK_DONE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_EVENT_VFORK_DONE"}
  PTRACE_EVENT_VFORK_DONE)

JOKER CONSTANT PTRACE_GETEVENTMSG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_GETEVENTMSG"}
  PTRACE_GETEVENTMSG)

JOKER CONSTANT PTRACE_GETFPREGS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_GETFPREGS"}
  PTRACE_GETFPREGS)

JOKER CONSTANT PTRACE_GETFPXREGS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_GETFPXREGS"}
  PTRACE_GETFPXREGS)

JOKER CONSTANT PTRACE_GETREGS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_GETREGS"}
  PTRACE_GETREGS)

JOKER CONSTANT PTRACE_GETREGSET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_GETREGSET"}
  PTRACE_GETREGSET)

JOKER CONSTANT PTRACE_GETSIGINFO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_GETSIGINFO"}
  PTRACE_GETSIGINFO)

JOKER CONSTANT PTRACE_GET_THREAD_AREA from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_GET_THREAD_AREA"}
  PTRACE_GET_THREAD_AREA)

JOKER CONSTANT PTRACE_KILL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_KILL"}
  PTRACE_KILL)

JOKER CONSTANT PTRACE_OLDSETOPTIONS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_OLDSETOPTIONS"}
  PTRACE_OLDSETOPTIONS)

JOKER CONSTANT PTRACE_O_MASK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_O_MASK"}
  PTRACE_O_MASK)

JOKER CONSTANT PTRACE_O_TRACECLONE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_O_TRACECLONE"}
  PTRACE_O_TRACECLONE)

JOKER CONSTANT PTRACE_O_TRACEEXEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_O_TRACEEXEC"}
  PTRACE_O_TRACEEXEC)

JOKER CONSTANT PTRACE_O_TRACEEXIT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_O_TRACEEXIT"}
  PTRACE_O_TRACEEXIT)

JOKER CONSTANT PTRACE_O_TRACEFORK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_O_TRACEFORK"}
  PTRACE_O_TRACEFORK)

JOKER CONSTANT PTRACE_O_TRACESYSGOOD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_O_TRACESYSGOOD"}
  PTRACE_O_TRACESYSGOOD)

JOKER CONSTANT PTRACE_O_TRACEVFORK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_O_TRACEVFORK"}
  PTRACE_O_TRACEVFORK)

JOKER CONSTANT PTRACE_O_TRACEVFORKDONE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_O_TRACEVFORKDONE"}
  PTRACE_O_TRACEVFORKDONE)

JOKER CONSTANT PTRACE_PEEKDATA from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_PEEKDATA"}
  PTRACE_PEEKDATA)

JOKER CONSTANT PTRACE_PEEKTEXT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_PEEKTEXT"}
  PTRACE_PEEKTEXT)

JOKER CONSTANT PTRACE_PEEKUSR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_PEEKUSR"}
  PTRACE_PEEKUSR)

JOKER CONSTANT PTRACE_POKEDATA from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_POKEDATA"}
  PTRACE_POKEDATA)

JOKER CONSTANT PTRACE_POKETEXT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_POKETEXT"}
  PTRACE_POKETEXT)

JOKER CONSTANT PTRACE_POKEUSR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_POKEUSR"}
  PTRACE_POKEUSR)

JOKER CONSTANT PTRACE_SETFPREGS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_SETFPREGS"}
  PTRACE_SETFPREGS)

JOKER CONSTANT PTRACE_SETFPXREGS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_SETFPXREGS"}
  PTRACE_SETFPXREGS)

JOKER CONSTANT PTRACE_SETOPTIONS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_SETOPTIONS"}
  PTRACE_SETOPTIONS)

JOKER CONSTANT PTRACE_SETREGS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_SETREGS"}
  PTRACE_SETREGS)

JOKER CONSTANT PTRACE_SETREGSET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_SETREGSET"}
  PTRACE_SETREGSET)

JOKER CONSTANT PTRACE_SETSIGINFO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_SETSIGINFO"}
  PTRACE_SETSIGINFO)

JOKER CONSTANT PTRACE_SET_THREAD_AREA from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_SET_THREAD_AREA"}
  PTRACE_SET_THREAD_AREA)

JOKER CONSTANT PTRACE_SINGLEBLOCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_SINGLEBLOCK"}
  PTRACE_SINGLEBLOCK)

JOKER CONSTANT PTRACE_SINGLESTEP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_SINGLESTEP"}
  PTRACE_SINGLESTEP)

JOKER CONSTANT PTRACE_SYSCALL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_SYSCALL"}
  PTRACE_SYSCALL)

JOKER CONSTANT PTRACE_SYSEMU from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_SYSEMU"}
  PTRACE_SYSEMU)

JOKER CONSTANT PTRACE_SYSEMU_SINGLESTEP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_SYSEMU_SINGLESTEP"}
  PTRACE_SYSEMU_SINGLESTEP)

JOKER CONSTANT PTRACE_TRACEME from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PTRACE_TRACEME"}
  PTRACE_TRACEME)

JOKER CONSTANT PathMax from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.PathMax"}
  PathMax)

JOKER CONSTANT RLIMIT_AS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RLIMIT_AS"}
  RLIMIT_AS)

JOKER CONSTANT RLIMIT_CORE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RLIMIT_CORE"}
  RLIMIT_CORE)

JOKER CONSTANT RLIMIT_CPU from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RLIMIT_CPU"}
  RLIMIT_CPU)

JOKER CONSTANT RLIMIT_DATA from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RLIMIT_DATA"}
  RLIMIT_DATA)

JOKER CONSTANT RLIMIT_FSIZE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RLIMIT_FSIZE"}
  RLIMIT_FSIZE)

JOKER CONSTANT RLIMIT_NOFILE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RLIMIT_NOFILE"}
  RLIMIT_NOFILE)

JOKER CONSTANT RLIMIT_STACK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RLIMIT_STACK"}
  RLIMIT_STACK)

JOKER CONSTANT RLIM_INFINITY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RLIM_INFINITY"}
  RLIM_INFINITY)

JOKER CONSTANT RTAX_ADVMSS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTAX_ADVMSS"}
  RTAX_ADVMSS)

JOKER CONSTANT RTAX_CWND from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTAX_CWND"}
  RTAX_CWND)

JOKER CONSTANT RTAX_FEATURES from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTAX_FEATURES"}
  RTAX_FEATURES)

JOKER CONSTANT RTAX_FEATURE_ALLFRAG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTAX_FEATURE_ALLFRAG"}
  RTAX_FEATURE_ALLFRAG)

JOKER CONSTANT RTAX_FEATURE_ECN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTAX_FEATURE_ECN"}
  RTAX_FEATURE_ECN)

JOKER CONSTANT RTAX_FEATURE_SACK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTAX_FEATURE_SACK"}
  RTAX_FEATURE_SACK)

JOKER CONSTANT RTAX_FEATURE_TIMESTAMP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTAX_FEATURE_TIMESTAMP"}
  RTAX_FEATURE_TIMESTAMP)

JOKER CONSTANT RTAX_HOPLIMIT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTAX_HOPLIMIT"}
  RTAX_HOPLIMIT)

JOKER CONSTANT RTAX_INITCWND from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTAX_INITCWND"}
  RTAX_INITCWND)

JOKER CONSTANT RTAX_INITRWND from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTAX_INITRWND"}
  RTAX_INITRWND)

JOKER CONSTANT RTAX_LOCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTAX_LOCK"}
  RTAX_LOCK)

JOKER CONSTANT RTAX_MAX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTAX_MAX"}
  RTAX_MAX)

JOKER CONSTANT RTAX_MTU from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTAX_MTU"}
  RTAX_MTU)

JOKER CONSTANT RTAX_REORDERING from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTAX_REORDERING"}
  RTAX_REORDERING)

JOKER CONSTANT RTAX_RTO_MIN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTAX_RTO_MIN"}
  RTAX_RTO_MIN)

JOKER CONSTANT RTAX_RTT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTAX_RTT"}
  RTAX_RTT)

JOKER CONSTANT RTAX_RTTVAR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTAX_RTTVAR"}
  RTAX_RTTVAR)

JOKER CONSTANT RTAX_SSTHRESH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTAX_SSTHRESH"}
  RTAX_SSTHRESH)

JOKER CONSTANT RTAX_UNSPEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTAX_UNSPEC"}
  RTAX_UNSPEC)

JOKER CONSTANT RTAX_WINDOW from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTAX_WINDOW"}
  RTAX_WINDOW)

JOKER CONSTANT RTA_ALIGNTO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTA_ALIGNTO"}
  RTA_ALIGNTO)

JOKER CONSTANT RTA_CACHEINFO from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTA_CACHEINFO"}
  RTA_CACHEINFO)

JOKER CONSTANT RTA_DST from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTA_DST"}
  RTA_DST)

JOKER CONSTANT RTA_FLOW from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTA_FLOW"}
  RTA_FLOW)

JOKER CONSTANT RTA_GATEWAY from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTA_GATEWAY"}
  RTA_GATEWAY)

JOKER CONSTANT RTA_IIF from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTA_IIF"}
  RTA_IIF)

JOKER CONSTANT RTA_MAX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTA_MAX"}
  RTA_MAX)

JOKER CONSTANT RTA_METRICS from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTA_METRICS"}
  RTA_METRICS)

JOKER CONSTANT RTA_MULTIPATH from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTA_MULTIPATH"}
  RTA_MULTIPATH)

JOKER CONSTANT RTA_OIF from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTA_OIF"}
  RTA_OIF)

JOKER CONSTANT RTA_PREFSRC from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTA_PREFSRC"}
  RTA_PREFSRC)

JOKER CONSTANT RTA_PRIORITY from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTA_PRIORITY"}
  RTA_PRIORITY)

JOKER CONSTANT RTA_SRC from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTA_SRC"}
  RTA_SRC)

JOKER CONSTANT RTA_TABLE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTA_TABLE"}
  RTA_TABLE)

JOKER CONSTANT RTA_UNSPEC from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTA_UNSPEC"}
  RTA_UNSPEC)

JOKER CONSTANT RTCF_DIRECTSRC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTCF_DIRECTSRC"}
  RTCF_DIRECTSRC)

JOKER CONSTANT RTCF_DOREDIRECT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTCF_DOREDIRECT"}
  RTCF_DOREDIRECT)

JOKER CONSTANT RTCF_LOG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTCF_LOG"}
  RTCF_LOG)

JOKER CONSTANT RTCF_MASQ from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTCF_MASQ"}
  RTCF_MASQ)

JOKER CONSTANT RTCF_NAT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTCF_NAT"}
  RTCF_NAT)

JOKER CONSTANT RTCF_VALVE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTCF_VALVE"}
  RTCF_VALVE)

JOKER CONSTANT RTF_ADDRCLASSMASK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.RTF_ADDRCLASSMASK)"}
  RTF_ADDRCLASSMASK)

JOKER CONSTANT RTF_ADDRCONF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_ADDRCONF"}
  RTF_ADDRCONF)

JOKER CONSTANT RTF_ALLONLINK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_ALLONLINK"}
  RTF_ALLONLINK)

JOKER CONSTANT RTF_BROADCAST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_BROADCAST"}
  RTF_BROADCAST)

JOKER CONSTANT RTF_CACHE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_CACHE"}
  RTF_CACHE)

JOKER CONSTANT RTF_DEFAULT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_DEFAULT"}
  RTF_DEFAULT)

JOKER CONSTANT RTF_DYNAMIC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_DYNAMIC"}
  RTF_DYNAMIC)

JOKER CONSTANT RTF_FLOW from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_FLOW"}
  RTF_FLOW)

JOKER CONSTANT RTF_GATEWAY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_GATEWAY"}
  RTF_GATEWAY)

JOKER CONSTANT RTF_HOST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_HOST"}
  RTF_HOST)

JOKER CONSTANT RTF_INTERFACE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_INTERFACE"}
  RTF_INTERFACE)

JOKER CONSTANT RTF_IRTT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_IRTT"}
  RTF_IRTT)

JOKER CONSTANT RTF_LINKRT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_LINKRT"}
  RTF_LINKRT)

JOKER CONSTANT RTF_LOCAL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.RTF_LOCAL)"}
  RTF_LOCAL)

JOKER CONSTANT RTF_MODIFIED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_MODIFIED"}
  RTF_MODIFIED)

JOKER CONSTANT RTF_MSS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_MSS"}
  RTF_MSS)

JOKER CONSTANT RTF_MTU from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_MTU"}
  RTF_MTU)

JOKER CONSTANT RTF_MULTICAST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_MULTICAST"}
  RTF_MULTICAST)

JOKER CONSTANT RTF_NAT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_NAT"}
  RTF_NAT)

JOKER CONSTANT RTF_NOFORWARD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_NOFORWARD"}
  RTF_NOFORWARD)

JOKER CONSTANT RTF_NONEXTHOP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_NONEXTHOP"}
  RTF_NONEXTHOP)

JOKER CONSTANT RTF_NOPMTUDISC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_NOPMTUDISC"}
  RTF_NOPMTUDISC)

JOKER CONSTANT RTF_POLICY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_POLICY"}
  RTF_POLICY)

JOKER CONSTANT RTF_REINSTATE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_REINSTATE"}
  RTF_REINSTATE)

JOKER CONSTANT RTF_REJECT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_REJECT"}
  RTF_REJECT)

JOKER CONSTANT RTF_STATIC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_STATIC"}
  RTF_STATIC)

JOKER CONSTANT RTF_THROW from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_THROW"}
  RTF_THROW)

JOKER CONSTANT RTF_UP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_UP"}
  RTF_UP)

JOKER CONSTANT RTF_WINDOW from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_WINDOW"}
  RTF_WINDOW)

JOKER CONSTANT RTF_XRESOLVE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTF_XRESOLVE"}
  RTF_XRESOLVE)

JOKER CONSTANT RTM_BASE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_BASE"}
  RTM_BASE)

JOKER CONSTANT RTM_DELACTION from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_DELACTION"}
  RTM_DELACTION)

JOKER CONSTANT RTM_DELADDR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_DELADDR"}
  RTM_DELADDR)

JOKER CONSTANT RTM_DELADDRLABEL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_DELADDRLABEL"}
  RTM_DELADDRLABEL)

JOKER CONSTANT RTM_DELLINK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_DELLINK"}
  RTM_DELLINK)

JOKER CONSTANT RTM_DELNEIGH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_DELNEIGH"}
  RTM_DELNEIGH)

JOKER CONSTANT RTM_DELQDISC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_DELQDISC"}
  RTM_DELQDISC)

JOKER CONSTANT RTM_DELROUTE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_DELROUTE"}
  RTM_DELROUTE)

JOKER CONSTANT RTM_DELRULE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_DELRULE"}
  RTM_DELRULE)

JOKER CONSTANT RTM_DELTCLASS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_DELTCLASS"}
  RTM_DELTCLASS)

JOKER CONSTANT RTM_DELTFILTER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_DELTFILTER"}
  RTM_DELTFILTER)

JOKER CONSTANT RTM_F_CLONED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_F_CLONED"}
  RTM_F_CLONED)

JOKER CONSTANT RTM_F_EQUALIZE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_F_EQUALIZE"}
  RTM_F_EQUALIZE)

JOKER CONSTANT RTM_F_NOTIFY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_F_NOTIFY"}
  RTM_F_NOTIFY)

JOKER CONSTANT RTM_F_PREFIX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_F_PREFIX"}
  RTM_F_PREFIX)

JOKER CONSTANT RTM_GETACTION from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_GETACTION"}
  RTM_GETACTION)

JOKER CONSTANT RTM_GETADDR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_GETADDR"}
  RTM_GETADDR)

JOKER CONSTANT RTM_GETADDRLABEL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_GETADDRLABEL"}
  RTM_GETADDRLABEL)

JOKER CONSTANT RTM_GETANYCAST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_GETANYCAST"}
  RTM_GETANYCAST)

JOKER CONSTANT RTM_GETDCB from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_GETDCB"}
  RTM_GETDCB)

JOKER CONSTANT RTM_GETLINK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_GETLINK"}
  RTM_GETLINK)

JOKER CONSTANT RTM_GETMULTICAST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_GETMULTICAST"}
  RTM_GETMULTICAST)

JOKER CONSTANT RTM_GETNEIGH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_GETNEIGH"}
  RTM_GETNEIGH)

JOKER CONSTANT RTM_GETNEIGHTBL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_GETNEIGHTBL"}
  RTM_GETNEIGHTBL)

JOKER CONSTANT RTM_GETQDISC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_GETQDISC"}
  RTM_GETQDISC)

JOKER CONSTANT RTM_GETROUTE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_GETROUTE"}
  RTM_GETROUTE)

JOKER CONSTANT RTM_GETRULE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_GETRULE"}
  RTM_GETRULE)

JOKER CONSTANT RTM_GETTCLASS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_GETTCLASS"}
  RTM_GETTCLASS)

JOKER CONSTANT RTM_GETTFILTER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_GETTFILTER"}
  RTM_GETTFILTER)

JOKER CONSTANT RTM_MAX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_MAX"}
  RTM_MAX)

JOKER CONSTANT RTM_NEWACTION from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_NEWACTION"}
  RTM_NEWACTION)

JOKER CONSTANT RTM_NEWADDR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_NEWADDR"}
  RTM_NEWADDR)

JOKER CONSTANT RTM_NEWADDRLABEL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_NEWADDRLABEL"}
  RTM_NEWADDRLABEL)

JOKER CONSTANT RTM_NEWLINK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_NEWLINK"}
  RTM_NEWLINK)

JOKER CONSTANT RTM_NEWNDUSEROPT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_NEWNDUSEROPT"}
  RTM_NEWNDUSEROPT)

JOKER CONSTANT RTM_NEWNEIGH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_NEWNEIGH"}
  RTM_NEWNEIGH)

JOKER CONSTANT RTM_NEWNEIGHTBL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_NEWNEIGHTBL"}
  RTM_NEWNEIGHTBL)

JOKER CONSTANT RTM_NEWPREFIX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_NEWPREFIX"}
  RTM_NEWPREFIX)

JOKER CONSTANT RTM_NEWQDISC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_NEWQDISC"}
  RTM_NEWQDISC)

JOKER CONSTANT RTM_NEWROUTE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_NEWROUTE"}
  RTM_NEWROUTE)

JOKER CONSTANT RTM_NEWRULE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_NEWRULE"}
  RTM_NEWRULE)

JOKER CONSTANT RTM_NEWTCLASS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_NEWTCLASS"}
  RTM_NEWTCLASS)

JOKER CONSTANT RTM_NEWTFILTER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_NEWTFILTER"}
  RTM_NEWTFILTER)

JOKER CONSTANT RTM_NR_FAMILIES from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_NR_FAMILIES"}
  RTM_NR_FAMILIES)

JOKER CONSTANT RTM_NR_MSGTYPES from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_NR_MSGTYPES"}
  RTM_NR_MSGTYPES)

JOKER CONSTANT RTM_SETDCB from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_SETDCB"}
  RTM_SETDCB)

JOKER CONSTANT RTM_SETLINK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_SETLINK"}
  RTM_SETLINK)

JOKER CONSTANT RTM_SETNEIGHTBL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTM_SETNEIGHTBL"}
  RTM_SETNEIGHTBL)

JOKER CONSTANT RTNH_ALIGNTO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTNH_ALIGNTO"}
  RTNH_ALIGNTO)

JOKER CONSTANT RTNH_F_DEAD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTNH_F_DEAD"}
  RTNH_F_DEAD)

JOKER CONSTANT RTNH_F_ONLINK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTNH_F_ONLINK"}
  RTNH_F_ONLINK)

JOKER CONSTANT RTNH_F_PERVASIVE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTNH_F_PERVASIVE"}
  RTNH_F_PERVASIVE)

JOKER CONSTANT RTNLGRP_IPV4_IFADDR from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTNLGRP_IPV4_IFADDR"}
  RTNLGRP_IPV4_IFADDR)

JOKER CONSTANT RTNLGRP_IPV4_MROUTE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTNLGRP_IPV4_MROUTE"}
  RTNLGRP_IPV4_MROUTE)

JOKER CONSTANT RTNLGRP_IPV4_ROUTE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTNLGRP_IPV4_ROUTE"}
  RTNLGRP_IPV4_ROUTE)

JOKER CONSTANT RTNLGRP_IPV4_RULE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTNLGRP_IPV4_RULE"}
  RTNLGRP_IPV4_RULE)

JOKER CONSTANT RTNLGRP_IPV6_IFADDR from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTNLGRP_IPV6_IFADDR"}
  RTNLGRP_IPV6_IFADDR)

JOKER CONSTANT RTNLGRP_IPV6_IFINFO from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTNLGRP_IPV6_IFINFO"}
  RTNLGRP_IPV6_IFINFO)

JOKER CONSTANT RTNLGRP_IPV6_MROUTE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTNLGRP_IPV6_MROUTE"}
  RTNLGRP_IPV6_MROUTE)

JOKER CONSTANT RTNLGRP_IPV6_PREFIX from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTNLGRP_IPV6_PREFIX"}
  RTNLGRP_IPV6_PREFIX)

JOKER CONSTANT RTNLGRP_IPV6_ROUTE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTNLGRP_IPV6_ROUTE"}
  RTNLGRP_IPV6_ROUTE)

JOKER CONSTANT RTNLGRP_IPV6_RULE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTNLGRP_IPV6_RULE"}
  RTNLGRP_IPV6_RULE)

JOKER CONSTANT RTNLGRP_LINK from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTNLGRP_LINK"}
  RTNLGRP_LINK)

JOKER CONSTANT RTNLGRP_ND_USEROPT from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTNLGRP_ND_USEROPT"}
  RTNLGRP_ND_USEROPT)

JOKER CONSTANT RTNLGRP_NEIGH from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTNLGRP_NEIGH"}
  RTNLGRP_NEIGH)

JOKER CONSTANT RTNLGRP_NONE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTNLGRP_NONE"}
  RTNLGRP_NONE)

JOKER CONSTANT RTNLGRP_NOTIFY from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTNLGRP_NOTIFY"}
  RTNLGRP_NOTIFY)

JOKER CONSTANT RTNLGRP_TC from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTNLGRP_TC"}
  RTNLGRP_TC)

JOKER CONSTANT RTN_ANYCAST from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTN_ANYCAST"}
  RTN_ANYCAST)

JOKER CONSTANT RTN_BLACKHOLE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTN_BLACKHOLE"}
  RTN_BLACKHOLE)

JOKER CONSTANT RTN_BROADCAST from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTN_BROADCAST"}
  RTN_BROADCAST)

JOKER CONSTANT RTN_LOCAL from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTN_LOCAL"}
  RTN_LOCAL)

JOKER CONSTANT RTN_MAX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTN_MAX"}
  RTN_MAX)

JOKER CONSTANT RTN_MULTICAST from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTN_MULTICAST"}
  RTN_MULTICAST)

JOKER CONSTANT RTN_NAT from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTN_NAT"}
  RTN_NAT)

JOKER CONSTANT RTN_PROHIBIT from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTN_PROHIBIT"}
  RTN_PROHIBIT)

JOKER CONSTANT RTN_THROW from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTN_THROW"}
  RTN_THROW)

JOKER CONSTANT RTN_UNICAST from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTN_UNICAST"}
  RTN_UNICAST)

JOKER CONSTANT RTN_UNREACHABLE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTN_UNREACHABLE"}
  RTN_UNREACHABLE)

JOKER CONSTANT RTN_UNSPEC from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTN_UNSPEC"}
  RTN_UNSPEC)

JOKER CONSTANT RTN_XRESOLVE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTN_XRESOLVE"}
  RTN_XRESOLVE)

JOKER CONSTANT RTPROT_BIRD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTPROT_BIRD"}
  RTPROT_BIRD)

JOKER CONSTANT RTPROT_BOOT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTPROT_BOOT"}
  RTPROT_BOOT)

JOKER CONSTANT RTPROT_DHCP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTPROT_DHCP"}
  RTPROT_DHCP)

JOKER CONSTANT RTPROT_DNROUTED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTPROT_DNROUTED"}
  RTPROT_DNROUTED)

JOKER CONSTANT RTPROT_GATED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTPROT_GATED"}
  RTPROT_GATED)

JOKER CONSTANT RTPROT_KERNEL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTPROT_KERNEL"}
  RTPROT_KERNEL)

JOKER CONSTANT RTPROT_MRT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTPROT_MRT"}
  RTPROT_MRT)

JOKER CONSTANT RTPROT_NTK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTPROT_NTK"}
  RTPROT_NTK)

JOKER CONSTANT RTPROT_RA from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTPROT_RA"}
  RTPROT_RA)

JOKER CONSTANT RTPROT_REDIRECT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTPROT_REDIRECT"}
  RTPROT_REDIRECT)

JOKER CONSTANT RTPROT_STATIC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTPROT_STATIC"}
  RTPROT_STATIC)

JOKER CONSTANT RTPROT_UNSPEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTPROT_UNSPEC"}
  RTPROT_UNSPEC)

JOKER CONSTANT RTPROT_XORP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTPROT_XORP"}
  RTPROT_XORP)

JOKER CONSTANT RTPROT_ZEBRA from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RTPROT_ZEBRA"}
  RTPROT_ZEBRA)

JOKER CONSTANT RT_CLASS_DEFAULT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RT_CLASS_DEFAULT"}
  RT_CLASS_DEFAULT)

JOKER CONSTANT RT_CLASS_LOCAL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RT_CLASS_LOCAL"}
  RT_CLASS_LOCAL)

JOKER CONSTANT RT_CLASS_MAIN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RT_CLASS_MAIN"}
  RT_CLASS_MAIN)

JOKER CONSTANT RT_CLASS_MAX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RT_CLASS_MAX"}
  RT_CLASS_MAX)

JOKER CONSTANT RT_CLASS_UNSPEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RT_CLASS_UNSPEC"}
  RT_CLASS_UNSPEC)

JOKER CONSTANT RT_SCOPE_HOST from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RT_SCOPE_HOST"}
  RT_SCOPE_HOST)

JOKER CONSTANT RT_SCOPE_LINK from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RT_SCOPE_LINK"}
  RT_SCOPE_LINK)

JOKER CONSTANT RT_SCOPE_NOWHERE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RT_SCOPE_NOWHERE"}
  RT_SCOPE_NOWHERE)

JOKER CONSTANT RT_SCOPE_SITE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RT_SCOPE_SITE"}
  RT_SCOPE_SITE)

JOKER CONSTANT RT_SCOPE_UNIVERSE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RT_SCOPE_UNIVERSE"}
  RT_SCOPE_UNIVERSE)

JOKER CONSTANT RT_TABLE_COMPAT from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RT_TABLE_COMPAT"}
  RT_TABLE_COMPAT)

JOKER CONSTANT RT_TABLE_DEFAULT from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RT_TABLE_DEFAULT"}
  RT_TABLE_DEFAULT)

JOKER CONSTANT RT_TABLE_LOCAL from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RT_TABLE_LOCAL"}
  RT_TABLE_LOCAL)

JOKER CONSTANT RT_TABLE_MAIN from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RT_TABLE_MAIN"}
  RT_TABLE_MAIN)

JOKER CONSTANT RT_TABLE_MAX from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.RT_TABLE_MAX)"}
  RT_TABLE_MAX)

JOKER CONSTANT RT_TABLE_UNSPEC from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RT_TABLE_UNSPEC"}
  RT_TABLE_UNSPEC)

JOKER CONSTANT RUSAGE_CHILDREN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RUSAGE_CHILDREN"}
  RUSAGE_CHILDREN)

JOKER CONSTANT RUSAGE_SELF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RUSAGE_SELF"}
  RUSAGE_SELF)

JOKER CONSTANT RUSAGE_THREAD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.RUSAGE_THREAD"}
  RUSAGE_THREAD)

JOKER CONSTANT SCM_CREDENTIALS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SCM_CREDENTIALS"}
  SCM_CREDENTIALS)

JOKER CONSTANT SCM_RIGHTS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SCM_RIGHTS"}
  SCM_RIGHTS)

JOKER CONSTANT SCM_TIMESTAMP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SCM_TIMESTAMP"}
  SCM_TIMESTAMP)

JOKER CONSTANT SCM_TIMESTAMPING from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SCM_TIMESTAMPING"}
  SCM_TIMESTAMPING)

JOKER CONSTANT SCM_TIMESTAMPNS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SCM_TIMESTAMPNS"}
  SCM_TIMESTAMPNS)

JOKER CONSTANT SHUT_RD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SHUT_RD"}
  SHUT_RD)

JOKER CONSTANT SHUT_RDWR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SHUT_RDWR"}
  SHUT_RDWR)

JOKER CONSTANT SHUT_WR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SHUT_WR"}
  SHUT_WR)

JOKER CONSTANT SIGABRT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGABRT)"}
  SIGABRT)

JOKER CONSTANT SIGALRM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGALRM)"}
  SIGALRM)

JOKER CONSTANT SIGBUS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGBUS)"}
  SIGBUS)

JOKER CONSTANT SIGCHLD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGCHLD)"}
  SIGCHLD)

JOKER CONSTANT SIGCLD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGCLD)"}
  SIGCLD)

JOKER CONSTANT SIGCONT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGCONT)"}
  SIGCONT)

JOKER CONSTANT SIGFPE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGFPE)"}
  SIGFPE)

JOKER CONSTANT SIGHUP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGHUP)"}
  SIGHUP)

JOKER CONSTANT SIGILL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGILL)"}
  SIGILL)

JOKER CONSTANT SIGINT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGINT)"}
  SIGINT)

JOKER CONSTANT SIGIO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGIO)"}
  SIGIO)

JOKER CONSTANT SIGIOT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGIOT)"}
  SIGIOT)

JOKER CONSTANT SIGKILL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGKILL)"}
  SIGKILL)

JOKER CONSTANT SIGPIPE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGPIPE)"}
  SIGPIPE)

JOKER CONSTANT SIGPOLL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGPOLL)"}
  SIGPOLL)

JOKER CONSTANT SIGPROF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGPROF)"}
  SIGPROF)

JOKER CONSTANT SIGPWR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGPWR)"}
  SIGPWR)

JOKER CONSTANT SIGQUIT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGQUIT)"}
  SIGQUIT)

JOKER CONSTANT SIGSEGV from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGSEGV)"}
  SIGSEGV)

JOKER CONSTANT SIGSTKFLT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGSTKFLT)"}
  SIGSTKFLT)

JOKER CONSTANT SIGSTOP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGSTOP)"}
  SIGSTOP)

JOKER CONSTANT SIGSYS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGSYS)"}
  SIGSYS)

JOKER CONSTANT SIGTERM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGTERM)"}
  SIGTERM)

JOKER CONSTANT SIGTRAP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGTRAP)"}
  SIGTRAP)

JOKER CONSTANT SIGTSTP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGTSTP)"}
  SIGTSTP)

JOKER CONSTANT SIGTTIN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGTTIN)"}
  SIGTTIN)

JOKER CONSTANT SIGTTOU from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGTTOU)"}
  SIGTTOU)

JOKER CONSTANT SIGUNUSED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGUNUSED)"}
  SIGUNUSED)

JOKER CONSTANT SIGURG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGURG)"}
  SIGURG)

JOKER CONSTANT SIGUSR1 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGUSR1)"}
  SIGUSR1)

JOKER CONSTANT SIGUSR2 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGUSR2)"}
  SIGUSR2)

JOKER CONSTANT SIGVTALRM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGVTALRM)"}
  SIGVTALRM)

JOKER CONSTANT SIGWINCH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGWINCH)"}
  SIGWINCH)

JOKER CONSTANT SIGXCPU from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGXCPU)"}
  SIGXCPU)

JOKER CONSTANT SIGXFSZ from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc "Signals\n"
    :added "1.0"
    :tag "Int"
    :go "int(syscall.SIGXFSZ)"}
  SIGXFSZ)

JOKER CONSTANT SIOCADDDLCI from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCADDDLCI"}
  SIOCADDDLCI)

JOKER CONSTANT SIOCADDMULTI from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCADDMULTI"}
  SIOCADDMULTI)

JOKER CONSTANT SIOCADDRT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCADDRT"}
  SIOCADDRT)

JOKER CONSTANT SIOCATMARK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCATMARK"}
  SIOCATMARK)

JOKER CONSTANT SIOCDARP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCDARP"}
  SIOCDARP)

JOKER CONSTANT SIOCDELDLCI from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCDELDLCI"}
  SIOCDELDLCI)

JOKER CONSTANT SIOCDELMULTI from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCDELMULTI"}
  SIOCDELMULTI)

JOKER CONSTANT SIOCDELRT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCDELRT"}
  SIOCDELRT)

JOKER CONSTANT SIOCDEVPRIVATE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCDEVPRIVATE"}
  SIOCDEVPRIVATE)

JOKER CONSTANT SIOCDIFADDR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCDIFADDR"}
  SIOCDIFADDR)

JOKER CONSTANT SIOCDRARP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCDRARP"}
  SIOCDRARP)

JOKER CONSTANT SIOCGARP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGARP"}
  SIOCGARP)

JOKER CONSTANT SIOCGIFADDR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGIFADDR"}
  SIOCGIFADDR)

JOKER CONSTANT SIOCGIFBR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGIFBR"}
  SIOCGIFBR)

JOKER CONSTANT SIOCGIFBRDADDR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGIFBRDADDR"}
  SIOCGIFBRDADDR)

JOKER CONSTANT SIOCGIFCONF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGIFCONF"}
  SIOCGIFCONF)

JOKER CONSTANT SIOCGIFCOUNT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGIFCOUNT"}
  SIOCGIFCOUNT)

JOKER CONSTANT SIOCGIFDSTADDR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGIFDSTADDR"}
  SIOCGIFDSTADDR)

JOKER CONSTANT SIOCGIFENCAP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGIFENCAP"}
  SIOCGIFENCAP)

JOKER CONSTANT SIOCGIFFLAGS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGIFFLAGS"}
  SIOCGIFFLAGS)

JOKER CONSTANT SIOCGIFHWADDR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGIFHWADDR"}
  SIOCGIFHWADDR)

JOKER CONSTANT SIOCGIFINDEX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGIFINDEX"}
  SIOCGIFINDEX)

JOKER CONSTANT SIOCGIFMAP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGIFMAP"}
  SIOCGIFMAP)

JOKER CONSTANT SIOCGIFMEM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGIFMEM"}
  SIOCGIFMEM)

JOKER CONSTANT SIOCGIFMETRIC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGIFMETRIC"}
  SIOCGIFMETRIC)

JOKER CONSTANT SIOCGIFMTU from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGIFMTU"}
  SIOCGIFMTU)

JOKER CONSTANT SIOCGIFNAME from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGIFNAME"}
  SIOCGIFNAME)

JOKER CONSTANT SIOCGIFNETMASK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGIFNETMASK"}
  SIOCGIFNETMASK)

JOKER CONSTANT SIOCGIFPFLAGS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGIFPFLAGS"}
  SIOCGIFPFLAGS)

JOKER CONSTANT SIOCGIFSLAVE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGIFSLAVE"}
  SIOCGIFSLAVE)

JOKER CONSTANT SIOCGIFTXQLEN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGIFTXQLEN"}
  SIOCGIFTXQLEN)

JOKER CONSTANT SIOCGPGRP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGPGRP"}
  SIOCGPGRP)

JOKER CONSTANT SIOCGRARP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGRARP"}
  SIOCGRARP)

JOKER CONSTANT SIOCGSTAMP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGSTAMP"}
  SIOCGSTAMP)

JOKER CONSTANT SIOCGSTAMPNS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCGSTAMPNS"}
  SIOCGSTAMPNS)

JOKER CONSTANT SIOCPROTOPRIVATE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCPROTOPRIVATE"}
  SIOCPROTOPRIVATE)

JOKER CONSTANT SIOCRTMSG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCRTMSG"}
  SIOCRTMSG)

JOKER CONSTANT SIOCSARP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCSARP"}
  SIOCSARP)

JOKER CONSTANT SIOCSIFADDR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCSIFADDR"}
  SIOCSIFADDR)

JOKER CONSTANT SIOCSIFBR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCSIFBR"}
  SIOCSIFBR)

JOKER CONSTANT SIOCSIFBRDADDR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCSIFBRDADDR"}
  SIOCSIFBRDADDR)

JOKER CONSTANT SIOCSIFDSTADDR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCSIFDSTADDR"}
  SIOCSIFDSTADDR)

JOKER CONSTANT SIOCSIFENCAP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCSIFENCAP"}
  SIOCSIFENCAP)

JOKER CONSTANT SIOCSIFFLAGS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCSIFFLAGS"}
  SIOCSIFFLAGS)

JOKER CONSTANT SIOCSIFHWADDR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCSIFHWADDR"}
  SIOCSIFHWADDR)

JOKER CONSTANT SIOCSIFHWBROADCAST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCSIFHWBROADCAST"}
  SIOCSIFHWBROADCAST)

JOKER CONSTANT SIOCSIFLINK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCSIFLINK"}
  SIOCSIFLINK)

JOKER CONSTANT SIOCSIFMAP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCSIFMAP"}
  SIOCSIFMAP)

JOKER CONSTANT SIOCSIFMEM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCSIFMEM"}
  SIOCSIFMEM)

JOKER CONSTANT SIOCSIFMETRIC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCSIFMETRIC"}
  SIOCSIFMETRIC)

JOKER CONSTANT SIOCSIFMTU from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCSIFMTU"}
  SIOCSIFMTU)

JOKER CONSTANT SIOCSIFNAME from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCSIFNAME"}
  SIOCSIFNAME)

JOKER CONSTANT SIOCSIFNETMASK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCSIFNETMASK"}
  SIOCSIFNETMASK)

JOKER CONSTANT SIOCSIFPFLAGS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCSIFPFLAGS"}
  SIOCSIFPFLAGS)

JOKER CONSTANT SIOCSIFSLAVE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCSIFSLAVE"}
  SIOCSIFSLAVE)

JOKER CONSTANT SIOCSIFTXQLEN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCSIFTXQLEN"}
  SIOCSIFTXQLEN)

JOKER CONSTANT SIOCSPGRP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCSPGRP"}
  SIOCSPGRP)

JOKER CONSTANT SIOCSRARP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SIOCSRARP"}
  SIOCSRARP)

JOKER CONSTANT SOCK_CLOEXEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOCK_CLOEXEC"}
  SOCK_CLOEXEC)

JOKER CONSTANT SOCK_DCCP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOCK_DCCP"}
  SOCK_DCCP)

JOKER CONSTANT SOCK_DGRAM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOCK_DGRAM"}
  SOCK_DGRAM)

JOKER CONSTANT SOCK_NONBLOCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOCK_NONBLOCK"}
  SOCK_NONBLOCK)

JOKER CONSTANT SOCK_PACKET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOCK_PACKET"}
  SOCK_PACKET)

JOKER CONSTANT SOCK_RAW from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOCK_RAW"}
  SOCK_RAW)

JOKER CONSTANT SOCK_RDM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOCK_RDM"}
  SOCK_RDM)

JOKER CONSTANT SOCK_SEQPACKET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOCK_SEQPACKET"}
  SOCK_SEQPACKET)

JOKER CONSTANT SOCK_STREAM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOCK_STREAM"}
  SOCK_STREAM)

JOKER CONSTANT SOL_AAL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOL_AAL"}
  SOL_AAL)

JOKER CONSTANT SOL_ATM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOL_ATM"}
  SOL_ATM)

JOKER CONSTANT SOL_DECNET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOL_DECNET"}
  SOL_DECNET)

JOKER CONSTANT SOL_ICMPV6 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOL_ICMPV6"}
  SOL_ICMPV6)

JOKER CONSTANT SOL_IP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOL_IP"}
  SOL_IP)

JOKER CONSTANT SOL_IPV6 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOL_IPV6"}
  SOL_IPV6)

JOKER CONSTANT SOL_IRDA from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOL_IRDA"}
  SOL_IRDA)

JOKER CONSTANT SOL_PACKET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOL_PACKET"}
  SOL_PACKET)

JOKER CONSTANT SOL_RAW from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOL_RAW"}
  SOL_RAW)

JOKER CONSTANT SOL_SOCKET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOL_SOCKET"}
  SOL_SOCKET)

JOKER CONSTANT SOL_TCP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOL_TCP"}
  SOL_TCP)

JOKER CONSTANT SOL_X25 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOL_X25"}
  SOL_X25)

JOKER CONSTANT SOMAXCONN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SOMAXCONN"}
  SOMAXCONN)

JOKER CONSTANT SO_ACCEPTCONN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_ACCEPTCONN"}
  SO_ACCEPTCONN)

JOKER CONSTANT SO_ATTACH_FILTER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_ATTACH_FILTER"}
  SO_ATTACH_FILTER)

JOKER CONSTANT SO_BINDTODEVICE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_BINDTODEVICE"}
  SO_BINDTODEVICE)

JOKER CONSTANT SO_BROADCAST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_BROADCAST"}
  SO_BROADCAST)

JOKER CONSTANT SO_BSDCOMPAT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_BSDCOMPAT"}
  SO_BSDCOMPAT)

JOKER CONSTANT SO_DEBUG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_DEBUG"}
  SO_DEBUG)

JOKER CONSTANT SO_DETACH_FILTER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_DETACH_FILTER"}
  SO_DETACH_FILTER)

JOKER CONSTANT SO_DOMAIN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_DOMAIN"}
  SO_DOMAIN)

JOKER CONSTANT SO_DONTROUTE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_DONTROUTE"}
  SO_DONTROUTE)

JOKER CONSTANT SO_ERROR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_ERROR"}
  SO_ERROR)

JOKER CONSTANT SO_KEEPALIVE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_KEEPALIVE"}
  SO_KEEPALIVE)

JOKER CONSTANT SO_LINGER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_LINGER"}
  SO_LINGER)

JOKER CONSTANT SO_MARK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_MARK"}
  SO_MARK)

JOKER CONSTANT SO_NO_CHECK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_NO_CHECK"}
  SO_NO_CHECK)

JOKER CONSTANT SO_OOBINLINE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_OOBINLINE"}
  SO_OOBINLINE)

JOKER CONSTANT SO_PASSCRED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_PASSCRED"}
  SO_PASSCRED)

JOKER CONSTANT SO_PASSSEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_PASSSEC"}
  SO_PASSSEC)

JOKER CONSTANT SO_PEERCRED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_PEERCRED"}
  SO_PEERCRED)

JOKER CONSTANT SO_PEERNAME from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_PEERNAME"}
  SO_PEERNAME)

JOKER CONSTANT SO_PEERSEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_PEERSEC"}
  SO_PEERSEC)

JOKER CONSTANT SO_PRIORITY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_PRIORITY"}
  SO_PRIORITY)

JOKER CONSTANT SO_PROTOCOL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_PROTOCOL"}
  SO_PROTOCOL)

JOKER CONSTANT SO_RCVBUF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_RCVBUF"}
  SO_RCVBUF)

JOKER CONSTANT SO_RCVBUFFORCE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_RCVBUFFORCE"}
  SO_RCVBUFFORCE)

JOKER CONSTANT SO_RCVLOWAT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_RCVLOWAT"}
  SO_RCVLOWAT)

JOKER CONSTANT SO_RCVTIMEO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_RCVTIMEO"}
  SO_RCVTIMEO)

JOKER CONSTANT SO_REUSEADDR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_REUSEADDR"}
  SO_REUSEADDR)

JOKER CONSTANT SO_RXQ_OVFL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_RXQ_OVFL"}
  SO_RXQ_OVFL)

JOKER CONSTANT SO_SECURITY_AUTHENTICATION from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_SECURITY_AUTHENTICATION"}
  SO_SECURITY_AUTHENTICATION)

JOKER CONSTANT SO_SECURITY_ENCRYPTION_NETWORK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_SECURITY_ENCRYPTION_NETWORK"}
  SO_SECURITY_ENCRYPTION_NETWORK)

JOKER CONSTANT SO_SECURITY_ENCRYPTION_TRANSPORT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_SECURITY_ENCRYPTION_TRANSPORT"}
  SO_SECURITY_ENCRYPTION_TRANSPORT)

JOKER CONSTANT SO_SNDBUF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_SNDBUF"}
  SO_SNDBUF)

JOKER CONSTANT SO_SNDBUFFORCE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_SNDBUFFORCE"}
  SO_SNDBUFFORCE)

JOKER CONSTANT SO_SNDLOWAT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_SNDLOWAT"}
  SO_SNDLOWAT)

JOKER CONSTANT SO_SNDTIMEO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_SNDTIMEO"}
  SO_SNDTIMEO)

JOKER CONSTANT SO_TIMESTAMP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_TIMESTAMP"}
  SO_TIMESTAMP)

JOKER CONSTANT SO_TIMESTAMPING from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_TIMESTAMPING"}
  SO_TIMESTAMPING)

JOKER CONSTANT SO_TIMESTAMPNS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_TIMESTAMPNS"}
  SO_TIMESTAMPNS)

JOKER CONSTANT SO_TYPE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SO_TYPE"}
  SO_TYPE)

JOKER CONSTANT SYS_ACCEPT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_ACCEPT"}
  SYS_ACCEPT)

JOKER CONSTANT SYS_ACCEPT4 from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_ACCEPT4"}
  SYS_ACCEPT4)

JOKER CONSTANT SYS_ACCESS from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_ACCESS"}
  SYS_ACCESS)

JOKER CONSTANT SYS_ACCT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_ACCT"}
  SYS_ACCT)

JOKER CONSTANT SYS_ADD_KEY from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_ADD_KEY"}
  SYS_ADD_KEY)

JOKER CONSTANT SYS_ADJTIMEX from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_ADJTIMEX"}
  SYS_ADJTIMEX)

JOKER CONSTANT SYS_AFS_SYSCALL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_AFS_SYSCALL"}
  SYS_AFS_SYSCALL)

JOKER CONSTANT SYS_ALARM from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_ALARM"}
  SYS_ALARM)

JOKER CONSTANT SYS_ARCH_PRCTL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_ARCH_PRCTL"}
  SYS_ARCH_PRCTL)

JOKER CONSTANT SYS_BIND from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_BIND"}
  SYS_BIND)

JOKER CONSTANT SYS_BRK from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_BRK"}
  SYS_BRK)

JOKER CONSTANT SYS_CAPGET from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_CAPGET"}
  SYS_CAPGET)

JOKER CONSTANT SYS_CAPSET from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_CAPSET"}
  SYS_CAPSET)

JOKER CONSTANT SYS_CHDIR from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_CHDIR"}
  SYS_CHDIR)

JOKER CONSTANT SYS_CHMOD from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_CHMOD"}
  SYS_CHMOD)

JOKER CONSTANT SYS_CHOWN from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_CHOWN"}
  SYS_CHOWN)

JOKER CONSTANT SYS_CHROOT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_CHROOT"}
  SYS_CHROOT)

JOKER CONSTANT SYS_CLOCK_GETRES from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_CLOCK_GETRES"}
  SYS_CLOCK_GETRES)

JOKER CONSTANT SYS_CLOCK_GETTIME from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_CLOCK_GETTIME"}
  SYS_CLOCK_GETTIME)

JOKER CONSTANT SYS_CLOCK_NANOSLEEP from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_CLOCK_NANOSLEEP"}
  SYS_CLOCK_NANOSLEEP)

JOKER CONSTANT SYS_CLOCK_SETTIME from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_CLOCK_SETTIME"}
  SYS_CLOCK_SETTIME)

JOKER CONSTANT SYS_CLONE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_CLONE"}
  SYS_CLONE)

JOKER CONSTANT SYS_CLOSE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_CLOSE"}
  SYS_CLOSE)

JOKER CONSTANT SYS_CONNECT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_CONNECT"}
  SYS_CONNECT)

JOKER CONSTANT SYS_CREAT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_CREAT"}
  SYS_CREAT)

JOKER CONSTANT SYS_CREATE_MODULE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_CREATE_MODULE"}
  SYS_CREATE_MODULE)

JOKER CONSTANT SYS_DELETE_MODULE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_DELETE_MODULE"}
  SYS_DELETE_MODULE)

JOKER CONSTANT SYS_DUP from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_DUP"}
  SYS_DUP)

JOKER CONSTANT SYS_DUP2 from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_DUP2"}
  SYS_DUP2)

JOKER CONSTANT SYS_DUP3 from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_DUP3"}
  SYS_DUP3)

JOKER CONSTANT SYS_EPOLL_CREATE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_EPOLL_CREATE"}
  SYS_EPOLL_CREATE)

JOKER CONSTANT SYS_EPOLL_CREATE1 from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_EPOLL_CREATE1"}
  SYS_EPOLL_CREATE1)

JOKER CONSTANT SYS_EPOLL_CTL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_EPOLL_CTL"}
  SYS_EPOLL_CTL)

JOKER CONSTANT SYS_EPOLL_CTL_OLD from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_EPOLL_CTL_OLD"}
  SYS_EPOLL_CTL_OLD)

JOKER CONSTANT SYS_EPOLL_PWAIT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_EPOLL_PWAIT"}
  SYS_EPOLL_PWAIT)

JOKER CONSTANT SYS_EPOLL_WAIT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_EPOLL_WAIT"}
  SYS_EPOLL_WAIT)

JOKER CONSTANT SYS_EPOLL_WAIT_OLD from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_EPOLL_WAIT_OLD"}
  SYS_EPOLL_WAIT_OLD)

JOKER CONSTANT SYS_EVENTFD from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_EVENTFD"}
  SYS_EVENTFD)

JOKER CONSTANT SYS_EVENTFD2 from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_EVENTFD2"}
  SYS_EVENTFD2)

JOKER CONSTANT SYS_EXECVE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_EXECVE"}
  SYS_EXECVE)

JOKER CONSTANT SYS_EXIT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_EXIT"}
  SYS_EXIT)

JOKER CONSTANT SYS_EXIT_GROUP from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_EXIT_GROUP"}
  SYS_EXIT_GROUP)

JOKER CONSTANT SYS_FACCESSAT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FACCESSAT"}
  SYS_FACCESSAT)

JOKER CONSTANT SYS_FADVISE64 from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FADVISE64"}
  SYS_FADVISE64)

JOKER CONSTANT SYS_FALLOCATE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FALLOCATE"}
  SYS_FALLOCATE)

JOKER CONSTANT SYS_FANOTIFY_INIT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FANOTIFY_INIT"}
  SYS_FANOTIFY_INIT)

JOKER CONSTANT SYS_FANOTIFY_MARK from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FANOTIFY_MARK"}
  SYS_FANOTIFY_MARK)

JOKER CONSTANT SYS_FCHDIR from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FCHDIR"}
  SYS_FCHDIR)

JOKER CONSTANT SYS_FCHMOD from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FCHMOD"}
  SYS_FCHMOD)

JOKER CONSTANT SYS_FCHMODAT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FCHMODAT"}
  SYS_FCHMODAT)

JOKER CONSTANT SYS_FCHOWN from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FCHOWN"}
  SYS_FCHOWN)

JOKER CONSTANT SYS_FCHOWNAT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FCHOWNAT"}
  SYS_FCHOWNAT)

JOKER CONSTANT SYS_FCNTL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FCNTL"}
  SYS_FCNTL)

JOKER CONSTANT SYS_FDATASYNC from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FDATASYNC"}
  SYS_FDATASYNC)

JOKER CONSTANT SYS_FGETXATTR from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FGETXATTR"}
  SYS_FGETXATTR)

JOKER CONSTANT SYS_FLISTXATTR from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FLISTXATTR"}
  SYS_FLISTXATTR)

JOKER CONSTANT SYS_FLOCK from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FLOCK"}
  SYS_FLOCK)

JOKER CONSTANT SYS_FORK from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FORK"}
  SYS_FORK)

JOKER CONSTANT SYS_FREMOVEXATTR from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FREMOVEXATTR"}
  SYS_FREMOVEXATTR)

JOKER CONSTANT SYS_FSETXATTR from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FSETXATTR"}
  SYS_FSETXATTR)

JOKER CONSTANT SYS_FSTAT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FSTAT"}
  SYS_FSTAT)

JOKER CONSTANT SYS_FSTATFS from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FSTATFS"}
  SYS_FSTATFS)

JOKER CONSTANT SYS_FSYNC from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FSYNC"}
  SYS_FSYNC)

JOKER CONSTANT SYS_FTRUNCATE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FTRUNCATE"}
  SYS_FTRUNCATE)

JOKER CONSTANT SYS_FUTEX from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FUTEX"}
  SYS_FUTEX)

JOKER CONSTANT SYS_FUTIMESAT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_FUTIMESAT"}
  SYS_FUTIMESAT)

JOKER CONSTANT SYS_GETCWD from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETCWD"}
  SYS_GETCWD)

JOKER CONSTANT SYS_GETDENTS from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETDENTS"}
  SYS_GETDENTS)

JOKER CONSTANT SYS_GETDENTS64 from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETDENTS64"}
  SYS_GETDENTS64)

JOKER CONSTANT SYS_GETEGID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETEGID"}
  SYS_GETEGID)

JOKER CONSTANT SYS_GETEUID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETEUID"}
  SYS_GETEUID)

JOKER CONSTANT SYS_GETGID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETGID"}
  SYS_GETGID)

JOKER CONSTANT SYS_GETGROUPS from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETGROUPS"}
  SYS_GETGROUPS)

JOKER CONSTANT SYS_GETITIMER from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETITIMER"}
  SYS_GETITIMER)

JOKER CONSTANT SYS_GETPEERNAME from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETPEERNAME"}
  SYS_GETPEERNAME)

JOKER CONSTANT SYS_GETPGID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETPGID"}
  SYS_GETPGID)

JOKER CONSTANT SYS_GETPGRP from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETPGRP"}
  SYS_GETPGRP)

JOKER CONSTANT SYS_GETPID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETPID"}
  SYS_GETPID)

JOKER CONSTANT SYS_GETPMSG from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETPMSG"}
  SYS_GETPMSG)

JOKER CONSTANT SYS_GETPPID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETPPID"}
  SYS_GETPPID)

JOKER CONSTANT SYS_GETPRIORITY from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETPRIORITY"}
  SYS_GETPRIORITY)

JOKER CONSTANT SYS_GETRESGID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETRESGID"}
  SYS_GETRESGID)

JOKER CONSTANT SYS_GETRESUID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETRESUID"}
  SYS_GETRESUID)

JOKER CONSTANT SYS_GETRLIMIT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETRLIMIT"}
  SYS_GETRLIMIT)

JOKER CONSTANT SYS_GETRUSAGE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETRUSAGE"}
  SYS_GETRUSAGE)

JOKER CONSTANT SYS_GETSID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETSID"}
  SYS_GETSID)

JOKER CONSTANT SYS_GETSOCKNAME from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETSOCKNAME"}
  SYS_GETSOCKNAME)

JOKER CONSTANT SYS_GETSOCKOPT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETSOCKOPT"}
  SYS_GETSOCKOPT)

JOKER CONSTANT SYS_GETTID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETTID"}
  SYS_GETTID)

JOKER CONSTANT SYS_GETTIMEOFDAY from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETTIMEOFDAY"}
  SYS_GETTIMEOFDAY)

JOKER CONSTANT SYS_GETUID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETUID"}
  SYS_GETUID)

JOKER CONSTANT SYS_GETXATTR from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GETXATTR"}
  SYS_GETXATTR)

JOKER CONSTANT SYS_GET_KERNEL_SYMS from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GET_KERNEL_SYMS"}
  SYS_GET_KERNEL_SYMS)

JOKER CONSTANT SYS_GET_MEMPOLICY from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GET_MEMPOLICY"}
  SYS_GET_MEMPOLICY)

JOKER CONSTANT SYS_GET_ROBUST_LIST from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GET_ROBUST_LIST"}
  SYS_GET_ROBUST_LIST)

JOKER CONSTANT SYS_GET_THREAD_AREA from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_GET_THREAD_AREA"}
  SYS_GET_THREAD_AREA)

JOKER CONSTANT SYS_INIT_MODULE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_INIT_MODULE"}
  SYS_INIT_MODULE)

JOKER CONSTANT SYS_INOTIFY_ADD_WATCH from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_INOTIFY_ADD_WATCH"}
  SYS_INOTIFY_ADD_WATCH)

JOKER CONSTANT SYS_INOTIFY_INIT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_INOTIFY_INIT"}
  SYS_INOTIFY_INIT)

JOKER CONSTANT SYS_INOTIFY_INIT1 from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_INOTIFY_INIT1"}
  SYS_INOTIFY_INIT1)

JOKER CONSTANT SYS_INOTIFY_RM_WATCH from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_INOTIFY_RM_WATCH"}
  SYS_INOTIFY_RM_WATCH)

JOKER CONSTANT SYS_IOCTL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_IOCTL"}
  SYS_IOCTL)

JOKER CONSTANT SYS_IOPERM from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_IOPERM"}
  SYS_IOPERM)

JOKER CONSTANT SYS_IOPL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_IOPL"}
  SYS_IOPL)

JOKER CONSTANT SYS_IOPRIO_GET from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_IOPRIO_GET"}
  SYS_IOPRIO_GET)

JOKER CONSTANT SYS_IOPRIO_SET from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_IOPRIO_SET"}
  SYS_IOPRIO_SET)

JOKER CONSTANT SYS_IO_CANCEL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_IO_CANCEL"}
  SYS_IO_CANCEL)

JOKER CONSTANT SYS_IO_DESTROY from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_IO_DESTROY"}
  SYS_IO_DESTROY)

JOKER CONSTANT SYS_IO_GETEVENTS from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_IO_GETEVENTS"}
  SYS_IO_GETEVENTS)

JOKER CONSTANT SYS_IO_SETUP from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_IO_SETUP"}
  SYS_IO_SETUP)

JOKER CONSTANT SYS_IO_SUBMIT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_IO_SUBMIT"}
  SYS_IO_SUBMIT)

JOKER CONSTANT SYS_KEXEC_LOAD from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_KEXEC_LOAD"}
  SYS_KEXEC_LOAD)

JOKER CONSTANT SYS_KEYCTL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_KEYCTL"}
  SYS_KEYCTL)

JOKER CONSTANT SYS_KILL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_KILL"}
  SYS_KILL)

JOKER CONSTANT SYS_LCHOWN from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_LCHOWN"}
  SYS_LCHOWN)

JOKER CONSTANT SYS_LGETXATTR from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_LGETXATTR"}
  SYS_LGETXATTR)

JOKER CONSTANT SYS_LINK from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_LINK"}
  SYS_LINK)

JOKER CONSTANT SYS_LINKAT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_LINKAT"}
  SYS_LINKAT)

JOKER CONSTANT SYS_LISTEN from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_LISTEN"}
  SYS_LISTEN)

JOKER CONSTANT SYS_LISTXATTR from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_LISTXATTR"}
  SYS_LISTXATTR)

JOKER CONSTANT SYS_LLISTXATTR from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_LLISTXATTR"}
  SYS_LLISTXATTR)

JOKER CONSTANT SYS_LOOKUP_DCOOKIE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_LOOKUP_DCOOKIE"}
  SYS_LOOKUP_DCOOKIE)

JOKER CONSTANT SYS_LREMOVEXATTR from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_LREMOVEXATTR"}
  SYS_LREMOVEXATTR)

JOKER CONSTANT SYS_LSEEK from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_LSEEK"}
  SYS_LSEEK)

JOKER CONSTANT SYS_LSETXATTR from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_LSETXATTR"}
  SYS_LSETXATTR)

JOKER CONSTANT SYS_LSTAT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_LSTAT"}
  SYS_LSTAT)

JOKER CONSTANT SYS_MADVISE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MADVISE"}
  SYS_MADVISE)

JOKER CONSTANT SYS_MBIND from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MBIND"}
  SYS_MBIND)

JOKER CONSTANT SYS_MIGRATE_PAGES from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MIGRATE_PAGES"}
  SYS_MIGRATE_PAGES)

JOKER CONSTANT SYS_MINCORE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MINCORE"}
  SYS_MINCORE)

JOKER CONSTANT SYS_MKDIR from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MKDIR"}
  SYS_MKDIR)

JOKER CONSTANT SYS_MKDIRAT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MKDIRAT"}
  SYS_MKDIRAT)

JOKER CONSTANT SYS_MKNOD from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MKNOD"}
  SYS_MKNOD)

JOKER CONSTANT SYS_MKNODAT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MKNODAT"}
  SYS_MKNODAT)

JOKER CONSTANT SYS_MLOCK from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MLOCK"}
  SYS_MLOCK)

JOKER CONSTANT SYS_MLOCKALL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MLOCKALL"}
  SYS_MLOCKALL)

JOKER CONSTANT SYS_MMAP from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MMAP"}
  SYS_MMAP)

JOKER CONSTANT SYS_MODIFY_LDT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MODIFY_LDT"}
  SYS_MODIFY_LDT)

JOKER CONSTANT SYS_MOUNT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MOUNT"}
  SYS_MOUNT)

JOKER CONSTANT SYS_MOVE_PAGES from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MOVE_PAGES"}
  SYS_MOVE_PAGES)

JOKER CONSTANT SYS_MPROTECT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MPROTECT"}
  SYS_MPROTECT)

JOKER CONSTANT SYS_MQ_GETSETATTR from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MQ_GETSETATTR"}
  SYS_MQ_GETSETATTR)

JOKER CONSTANT SYS_MQ_NOTIFY from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MQ_NOTIFY"}
  SYS_MQ_NOTIFY)

JOKER CONSTANT SYS_MQ_OPEN from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MQ_OPEN"}
  SYS_MQ_OPEN)

JOKER CONSTANT SYS_MQ_TIMEDRECEIVE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MQ_TIMEDRECEIVE"}
  SYS_MQ_TIMEDRECEIVE)

JOKER CONSTANT SYS_MQ_TIMEDSEND from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MQ_TIMEDSEND"}
  SYS_MQ_TIMEDSEND)

JOKER CONSTANT SYS_MQ_UNLINK from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MQ_UNLINK"}
  SYS_MQ_UNLINK)

JOKER CONSTANT SYS_MREMAP from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MREMAP"}
  SYS_MREMAP)

JOKER CONSTANT SYS_MSGCTL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MSGCTL"}
  SYS_MSGCTL)

JOKER CONSTANT SYS_MSGGET from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MSGGET"}
  SYS_MSGGET)

JOKER CONSTANT SYS_MSGRCV from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MSGRCV"}
  SYS_MSGRCV)

JOKER CONSTANT SYS_MSGSND from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MSGSND"}
  SYS_MSGSND)

JOKER CONSTANT SYS_MSYNC from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MSYNC"}
  SYS_MSYNC)

JOKER CONSTANT SYS_MUNLOCK from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MUNLOCK"}
  SYS_MUNLOCK)

JOKER CONSTANT SYS_MUNLOCKALL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MUNLOCKALL"}
  SYS_MUNLOCKALL)

JOKER CONSTANT SYS_MUNMAP from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_MUNMAP"}
  SYS_MUNMAP)

JOKER CONSTANT SYS_NANOSLEEP from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_NANOSLEEP"}
  SYS_NANOSLEEP)

JOKER CONSTANT SYS_NEWFSTATAT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_NEWFSTATAT"}
  SYS_NEWFSTATAT)

JOKER CONSTANT SYS_NFSSERVCTL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_NFSSERVCTL"}
  SYS_NFSSERVCTL)

JOKER CONSTANT SYS_OPEN from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_OPEN"}
  SYS_OPEN)

JOKER CONSTANT SYS_OPENAT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_OPENAT"}
  SYS_OPENAT)

JOKER CONSTANT SYS_PAUSE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_PAUSE"}
  SYS_PAUSE)

JOKER CONSTANT SYS_PERF_EVENT_OPEN from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_PERF_EVENT_OPEN"}
  SYS_PERF_EVENT_OPEN)

JOKER CONSTANT SYS_PERSONALITY from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_PERSONALITY"}
  SYS_PERSONALITY)

JOKER CONSTANT SYS_PIPE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_PIPE"}
  SYS_PIPE)

JOKER CONSTANT SYS_PIPE2 from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_PIPE2"}
  SYS_PIPE2)

JOKER CONSTANT SYS_PIVOT_ROOT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_PIVOT_ROOT"}
  SYS_PIVOT_ROOT)

JOKER CONSTANT SYS_POLL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_POLL"}
  SYS_POLL)

JOKER CONSTANT SYS_PPOLL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_PPOLL"}
  SYS_PPOLL)

JOKER CONSTANT SYS_PRCTL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_PRCTL"}
  SYS_PRCTL)

JOKER CONSTANT SYS_PREAD64 from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_PREAD64"}
  SYS_PREAD64)

JOKER CONSTANT SYS_PREADV from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_PREADV"}
  SYS_PREADV)

JOKER CONSTANT SYS_PRLIMIT64 from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_PRLIMIT64"}
  SYS_PRLIMIT64)

JOKER CONSTANT SYS_PSELECT6 from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_PSELECT6"}
  SYS_PSELECT6)

JOKER CONSTANT SYS_PTRACE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_PTRACE"}
  SYS_PTRACE)

JOKER CONSTANT SYS_PUTPMSG from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_PUTPMSG"}
  SYS_PUTPMSG)

JOKER CONSTANT SYS_PWRITE64 from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_PWRITE64"}
  SYS_PWRITE64)

JOKER CONSTANT SYS_PWRITEV from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_PWRITEV"}
  SYS_PWRITEV)

JOKER CONSTANT SYS_QUERY_MODULE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_QUERY_MODULE"}
  SYS_QUERY_MODULE)

JOKER CONSTANT SYS_QUOTACTL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_QUOTACTL"}
  SYS_QUOTACTL)

JOKER CONSTANT SYS_READ from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_READ"}
  SYS_READ)

JOKER CONSTANT SYS_READAHEAD from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_READAHEAD"}
  SYS_READAHEAD)

JOKER CONSTANT SYS_READLINK from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_READLINK"}
  SYS_READLINK)

JOKER CONSTANT SYS_READLINKAT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_READLINKAT"}
  SYS_READLINKAT)

JOKER CONSTANT SYS_READV from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_READV"}
  SYS_READV)

JOKER CONSTANT SYS_REBOOT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_REBOOT"}
  SYS_REBOOT)

JOKER CONSTANT SYS_RECVFROM from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_RECVFROM"}
  SYS_RECVFROM)

JOKER CONSTANT SYS_RECVMMSG from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_RECVMMSG"}
  SYS_RECVMMSG)

JOKER CONSTANT SYS_RECVMSG from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_RECVMSG"}
  SYS_RECVMSG)

JOKER CONSTANT SYS_REMAP_FILE_PAGES from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_REMAP_FILE_PAGES"}
  SYS_REMAP_FILE_PAGES)

JOKER CONSTANT SYS_REMOVEXATTR from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_REMOVEXATTR"}
  SYS_REMOVEXATTR)

JOKER CONSTANT SYS_RENAME from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_RENAME"}
  SYS_RENAME)

JOKER CONSTANT SYS_RENAMEAT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_RENAMEAT"}
  SYS_RENAMEAT)

JOKER CONSTANT SYS_REQUEST_KEY from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_REQUEST_KEY"}
  SYS_REQUEST_KEY)

JOKER CONSTANT SYS_RESTART_SYSCALL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_RESTART_SYSCALL"}
  SYS_RESTART_SYSCALL)

JOKER CONSTANT SYS_RMDIR from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_RMDIR"}
  SYS_RMDIR)

JOKER CONSTANT SYS_RT_SIGACTION from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_RT_SIGACTION"}
  SYS_RT_SIGACTION)

JOKER CONSTANT SYS_RT_SIGPENDING from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_RT_SIGPENDING"}
  SYS_RT_SIGPENDING)

JOKER CONSTANT SYS_RT_SIGPROCMASK from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_RT_SIGPROCMASK"}
  SYS_RT_SIGPROCMASK)

JOKER CONSTANT SYS_RT_SIGQUEUEINFO from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_RT_SIGQUEUEINFO"}
  SYS_RT_SIGQUEUEINFO)

JOKER CONSTANT SYS_RT_SIGRETURN from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_RT_SIGRETURN"}
  SYS_RT_SIGRETURN)

JOKER CONSTANT SYS_RT_SIGSUSPEND from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_RT_SIGSUSPEND"}
  SYS_RT_SIGSUSPEND)

JOKER CONSTANT SYS_RT_SIGTIMEDWAIT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_RT_SIGTIMEDWAIT"}
  SYS_RT_SIGTIMEDWAIT)

JOKER CONSTANT SYS_RT_TGSIGQUEUEINFO from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_RT_TGSIGQUEUEINFO"}
  SYS_RT_TGSIGQUEUEINFO)

JOKER CONSTANT SYS_SCHED_GETAFFINITY from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SCHED_GETAFFINITY"}
  SYS_SCHED_GETAFFINITY)

JOKER CONSTANT SYS_SCHED_GETPARAM from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SCHED_GETPARAM"}
  SYS_SCHED_GETPARAM)

JOKER CONSTANT SYS_SCHED_GETSCHEDULER from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SCHED_GETSCHEDULER"}
  SYS_SCHED_GETSCHEDULER)

JOKER CONSTANT SYS_SCHED_GET_PRIORITY_MAX from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SCHED_GET_PRIORITY_MAX"}
  SYS_SCHED_GET_PRIORITY_MAX)

JOKER CONSTANT SYS_SCHED_GET_PRIORITY_MIN from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SCHED_GET_PRIORITY_MIN"}
  SYS_SCHED_GET_PRIORITY_MIN)

JOKER CONSTANT SYS_SCHED_RR_GET_INTERVAL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SCHED_RR_GET_INTERVAL"}
  SYS_SCHED_RR_GET_INTERVAL)

JOKER CONSTANT SYS_SCHED_SETAFFINITY from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SCHED_SETAFFINITY"}
  SYS_SCHED_SETAFFINITY)

JOKER CONSTANT SYS_SCHED_SETPARAM from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SCHED_SETPARAM"}
  SYS_SCHED_SETPARAM)

JOKER CONSTANT SYS_SCHED_SETSCHEDULER from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SCHED_SETSCHEDULER"}
  SYS_SCHED_SETSCHEDULER)

JOKER CONSTANT SYS_SCHED_YIELD from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SCHED_YIELD"}
  SYS_SCHED_YIELD)

JOKER CONSTANT SYS_SECURITY from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SECURITY"}
  SYS_SECURITY)

JOKER CONSTANT SYS_SELECT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SELECT"}
  SYS_SELECT)

JOKER CONSTANT SYS_SEMCTL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SEMCTL"}
  SYS_SEMCTL)

JOKER CONSTANT SYS_SEMGET from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SEMGET"}
  SYS_SEMGET)

JOKER CONSTANT SYS_SEMOP from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SEMOP"}
  SYS_SEMOP)

JOKER CONSTANT SYS_SEMTIMEDOP from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SEMTIMEDOP"}
  SYS_SEMTIMEDOP)

JOKER CONSTANT SYS_SENDFILE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SENDFILE"}
  SYS_SENDFILE)

JOKER CONSTANT SYS_SENDMSG from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SENDMSG"}
  SYS_SENDMSG)

JOKER CONSTANT SYS_SENDTO from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SENDTO"}
  SYS_SENDTO)

JOKER CONSTANT SYS_SETDOMAINNAME from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SETDOMAINNAME"}
  SYS_SETDOMAINNAME)

JOKER CONSTANT SYS_SETFSGID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SETFSGID"}
  SYS_SETFSGID)

JOKER CONSTANT SYS_SETFSUID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SETFSUID"}
  SYS_SETFSUID)

JOKER CONSTANT SYS_SETGID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SETGID"}
  SYS_SETGID)

JOKER CONSTANT SYS_SETGROUPS from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SETGROUPS"}
  SYS_SETGROUPS)

JOKER CONSTANT SYS_SETHOSTNAME from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SETHOSTNAME"}
  SYS_SETHOSTNAME)

JOKER CONSTANT SYS_SETITIMER from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SETITIMER"}
  SYS_SETITIMER)

JOKER CONSTANT SYS_SETPGID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SETPGID"}
  SYS_SETPGID)

JOKER CONSTANT SYS_SETPRIORITY from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SETPRIORITY"}
  SYS_SETPRIORITY)

JOKER CONSTANT SYS_SETREGID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SETREGID"}
  SYS_SETREGID)

JOKER CONSTANT SYS_SETRESGID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SETRESGID"}
  SYS_SETRESGID)

JOKER CONSTANT SYS_SETRESUID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SETRESUID"}
  SYS_SETRESUID)

JOKER CONSTANT SYS_SETREUID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SETREUID"}
  SYS_SETREUID)

JOKER CONSTANT SYS_SETRLIMIT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SETRLIMIT"}
  SYS_SETRLIMIT)

JOKER CONSTANT SYS_SETSID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SETSID"}
  SYS_SETSID)

JOKER CONSTANT SYS_SETSOCKOPT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SETSOCKOPT"}
  SYS_SETSOCKOPT)

JOKER CONSTANT SYS_SETTIMEOFDAY from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SETTIMEOFDAY"}
  SYS_SETTIMEOFDAY)

JOKER CONSTANT SYS_SETUID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SETUID"}
  SYS_SETUID)

JOKER CONSTANT SYS_SETXATTR from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SETXATTR"}
  SYS_SETXATTR)

JOKER CONSTANT SYS_SET_MEMPOLICY from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SET_MEMPOLICY"}
  SYS_SET_MEMPOLICY)

JOKER CONSTANT SYS_SET_ROBUST_LIST from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SET_ROBUST_LIST"}
  SYS_SET_ROBUST_LIST)

JOKER CONSTANT SYS_SET_THREAD_AREA from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SET_THREAD_AREA"}
  SYS_SET_THREAD_AREA)

JOKER CONSTANT SYS_SET_TID_ADDRESS from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SET_TID_ADDRESS"}
  SYS_SET_TID_ADDRESS)

JOKER CONSTANT SYS_SHMAT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SHMAT"}
  SYS_SHMAT)

JOKER CONSTANT SYS_SHMCTL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SHMCTL"}
  SYS_SHMCTL)

JOKER CONSTANT SYS_SHMDT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SHMDT"}
  SYS_SHMDT)

JOKER CONSTANT SYS_SHMGET from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SHMGET"}
  SYS_SHMGET)

JOKER CONSTANT SYS_SHUTDOWN from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SHUTDOWN"}
  SYS_SHUTDOWN)

JOKER CONSTANT SYS_SIGALTSTACK from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SIGALTSTACK"}
  SYS_SIGALTSTACK)

JOKER CONSTANT SYS_SIGNALFD from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SIGNALFD"}
  SYS_SIGNALFD)

JOKER CONSTANT SYS_SIGNALFD4 from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SIGNALFD4"}
  SYS_SIGNALFD4)

JOKER CONSTANT SYS_SOCKET from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SOCKET"}
  SYS_SOCKET)

JOKER CONSTANT SYS_SOCKETPAIR from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SOCKETPAIR"}
  SYS_SOCKETPAIR)

JOKER CONSTANT SYS_SPLICE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SPLICE"}
  SYS_SPLICE)

JOKER CONSTANT SYS_STAT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_STAT"}
  SYS_STAT)

JOKER CONSTANT SYS_STATFS from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_STATFS"}
  SYS_STATFS)

JOKER CONSTANT SYS_SWAPOFF from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SWAPOFF"}
  SYS_SWAPOFF)

JOKER CONSTANT SYS_SWAPON from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SWAPON"}
  SYS_SWAPON)

JOKER CONSTANT SYS_SYMLINK from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SYMLINK"}
  SYS_SYMLINK)

JOKER CONSTANT SYS_SYMLINKAT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SYMLINKAT"}
  SYS_SYMLINKAT)

JOKER CONSTANT SYS_SYNC from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SYNC"}
  SYS_SYNC)

JOKER CONSTANT SYS_SYNC_FILE_RANGE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SYNC_FILE_RANGE"}
  SYS_SYNC_FILE_RANGE)

JOKER CONSTANT SYS_SYSFS from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SYSFS"}
  SYS_SYSFS)

JOKER CONSTANT SYS_SYSINFO from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SYSINFO"}
  SYS_SYSINFO)

JOKER CONSTANT SYS_SYSLOG from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_SYSLOG"}
  SYS_SYSLOG)

JOKER CONSTANT SYS_TEE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_TEE"}
  SYS_TEE)

JOKER CONSTANT SYS_TGKILL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_TGKILL"}
  SYS_TGKILL)

JOKER CONSTANT SYS_TIME from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_TIME"}
  SYS_TIME)

JOKER CONSTANT SYS_TIMERFD_CREATE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_TIMERFD_CREATE"}
  SYS_TIMERFD_CREATE)

JOKER CONSTANT SYS_TIMERFD_GETTIME from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_TIMERFD_GETTIME"}
  SYS_TIMERFD_GETTIME)

JOKER CONSTANT SYS_TIMERFD_SETTIME from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_TIMERFD_SETTIME"}
  SYS_TIMERFD_SETTIME)

JOKER CONSTANT SYS_TIMER_CREATE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_TIMER_CREATE"}
  SYS_TIMER_CREATE)

JOKER CONSTANT SYS_TIMER_DELETE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_TIMER_DELETE"}
  SYS_TIMER_DELETE)

JOKER CONSTANT SYS_TIMER_GETOVERRUN from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_TIMER_GETOVERRUN"}
  SYS_TIMER_GETOVERRUN)

JOKER CONSTANT SYS_TIMER_GETTIME from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_TIMER_GETTIME"}
  SYS_TIMER_GETTIME)

JOKER CONSTANT SYS_TIMER_SETTIME from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_TIMER_SETTIME"}
  SYS_TIMER_SETTIME)

JOKER CONSTANT SYS_TIMES from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_TIMES"}
  SYS_TIMES)

JOKER CONSTANT SYS_TKILL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_TKILL"}
  SYS_TKILL)

JOKER CONSTANT SYS_TRUNCATE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_TRUNCATE"}
  SYS_TRUNCATE)

JOKER CONSTANT SYS_TUXCALL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_TUXCALL"}
  SYS_TUXCALL)

JOKER CONSTANT SYS_UMASK from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_UMASK"}
  SYS_UMASK)

JOKER CONSTANT SYS_UMOUNT2 from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_UMOUNT2"}
  SYS_UMOUNT2)

JOKER CONSTANT SYS_UNAME from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_UNAME"}
  SYS_UNAME)

JOKER CONSTANT SYS_UNLINK from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_UNLINK"}
  SYS_UNLINK)

JOKER CONSTANT SYS_UNLINKAT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_UNLINKAT"}
  SYS_UNLINKAT)

JOKER CONSTANT SYS_UNSHARE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_UNSHARE"}
  SYS_UNSHARE)

JOKER CONSTANT SYS_USELIB from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_USELIB"}
  SYS_USELIB)

JOKER CONSTANT SYS_USTAT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_USTAT"}
  SYS_USTAT)

JOKER CONSTANT SYS_UTIME from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_UTIME"}
  SYS_UTIME)

JOKER CONSTANT SYS_UTIMENSAT from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_UTIMENSAT"}
  SYS_UTIMENSAT)

JOKER CONSTANT SYS_UTIMES from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_UTIMES"}
  SYS_UTIMES)

JOKER CONSTANT SYS_VFORK from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_VFORK"}
  SYS_VFORK)

JOKER CONSTANT SYS_VHANGUP from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_VHANGUP"}
  SYS_VHANGUP)

JOKER CONSTANT SYS_VMSPLICE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_VMSPLICE"}
  SYS_VMSPLICE)

JOKER CONSTANT SYS_VSERVER from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_VSERVER"}
  SYS_VSERVER)

JOKER CONSTANT SYS_WAIT4 from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_WAIT4"}
  SYS_WAIT4)

JOKER CONSTANT SYS_WAITID from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_WAITID"}
  SYS_WAITID)

JOKER CONSTANT SYS_WRITE from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_WRITE"}
  SYS_WRITE)

JOKER CONSTANT SYS_WRITEV from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS_WRITEV"}
  SYS_WRITEV)

JOKER CONSTANT SYS__SYSCTL from syscall/zsysnum_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SYS__SYSCTL"}
  SYS__SYSCTL)

JOKER CONSTANT S_BLKSIZE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_BLKSIZE"}
  S_BLKSIZE)

JOKER CONSTANT S_IEXEC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IEXEC"}
  S_IEXEC)

JOKER CONSTANT S_IFBLK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IFBLK"}
  S_IFBLK)

JOKER CONSTANT S_IFCHR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IFCHR"}
  S_IFCHR)

JOKER CONSTANT S_IFDIR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IFDIR"}
  S_IFDIR)

JOKER CONSTANT S_IFIFO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IFIFO"}
  S_IFIFO)

JOKER CONSTANT S_IFLNK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IFLNK"}
  S_IFLNK)

JOKER CONSTANT S_IFMT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IFMT"}
  S_IFMT)

JOKER CONSTANT S_IFREG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IFREG"}
  S_IFREG)

JOKER CONSTANT S_IFSOCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IFSOCK"}
  S_IFSOCK)

JOKER CONSTANT S_IREAD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IREAD"}
  S_IREAD)

JOKER CONSTANT S_IRGRP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IRGRP"}
  S_IRGRP)

JOKER CONSTANT S_IROTH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IROTH"}
  S_IROTH)

JOKER CONSTANT S_IRUSR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IRUSR"}
  S_IRUSR)

JOKER CONSTANT S_IRWXG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IRWXG"}
  S_IRWXG)

JOKER CONSTANT S_IRWXO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IRWXO"}
  S_IRWXO)

JOKER CONSTANT S_IRWXU from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IRWXU"}
  S_IRWXU)

JOKER CONSTANT S_ISGID from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_ISGID"}
  S_ISGID)

JOKER CONSTANT S_ISUID from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_ISUID"}
  S_ISUID)

JOKER CONSTANT S_ISVTX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_ISVTX"}
  S_ISVTX)

JOKER CONSTANT S_IWGRP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IWGRP"}
  S_IWGRP)

JOKER CONSTANT S_IWOTH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IWOTH"}
  S_IWOTH)

JOKER CONSTANT S_IWRITE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IWRITE"}
  S_IWRITE)

JOKER CONSTANT S_IWUSR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IWUSR"}
  S_IWUSR)

JOKER CONSTANT S_IXGRP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IXGRP"}
  S_IXGRP)

JOKER CONSTANT S_IXOTH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IXOTH"}
  S_IXOTH)

JOKER CONSTANT S_IXUSR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.S_IXUSR"}
  S_IXUSR)

JOKER CONSTANT SizeofCmsghdr from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofCmsghdr"}
  SizeofCmsghdr)

JOKER CONSTANT SizeofICMPv6Filter from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofICMPv6Filter"}
  SizeofICMPv6Filter)

JOKER CONSTANT SizeofIPMreq from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofIPMreq"}
  SizeofIPMreq)

JOKER CONSTANT SizeofIPMreqn from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofIPMreqn"}
  SizeofIPMreqn)

JOKER CONSTANT SizeofIPv6MTUInfo from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofIPv6MTUInfo"}
  SizeofIPv6MTUInfo)

JOKER CONSTANT SizeofIPv6Mreq from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofIPv6Mreq"}
  SizeofIPv6Mreq)

JOKER CONSTANT SizeofIfAddrmsg from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofIfAddrmsg"}
  SizeofIfAddrmsg)

JOKER CONSTANT SizeofIfInfomsg from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofIfInfomsg"}
  SizeofIfInfomsg)

JOKER CONSTANT SizeofInet4Pktinfo from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofInet4Pktinfo"}
  SizeofInet4Pktinfo)

JOKER CONSTANT SizeofInet6Pktinfo from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofInet6Pktinfo"}
  SizeofInet6Pktinfo)

JOKER CONSTANT SizeofInotifyEvent from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofInotifyEvent"}
  SizeofInotifyEvent)

JOKER CONSTANT SizeofLinger from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofLinger"}
  SizeofLinger)

JOKER CONSTANT SizeofMsghdr from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofMsghdr"}
  SizeofMsghdr)

JOKER CONSTANT SizeofNlAttr from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofNlAttr"}
  SizeofNlAttr)

JOKER CONSTANT SizeofNlMsgerr from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofNlMsgerr"}
  SizeofNlMsgerr)

JOKER CONSTANT SizeofNlMsghdr from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofNlMsghdr"}
  SizeofNlMsghdr)

JOKER CONSTANT SizeofRtAttr from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofRtAttr"}
  SizeofRtAttr)

JOKER CONSTANT SizeofRtGenmsg from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofRtGenmsg"}
  SizeofRtGenmsg)

JOKER CONSTANT SizeofRtMsg from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofRtMsg"}
  SizeofRtMsg)

JOKER CONSTANT SizeofRtNexthop from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofRtNexthop"}
  SizeofRtNexthop)

JOKER CONSTANT SizeofSockFilter from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofSockFilter"}
  SizeofSockFilter)

JOKER CONSTANT SizeofSockFprog from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofSockFprog"}
  SizeofSockFprog)

JOKER CONSTANT SizeofSockaddrAny from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofSockaddrAny"}
  SizeofSockaddrAny)

JOKER CONSTANT SizeofSockaddrInet4 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofSockaddrInet4"}
  SizeofSockaddrInet4)

JOKER CONSTANT SizeofSockaddrInet6 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofSockaddrInet6"}
  SizeofSockaddrInet6)

JOKER CONSTANT SizeofSockaddrLinklayer from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofSockaddrLinklayer"}
  SizeofSockaddrLinklayer)

JOKER CONSTANT SizeofSockaddrNetlink from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofSockaddrNetlink"}
  SizeofSockaddrNetlink)

JOKER CONSTANT SizeofSockaddrUnix from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofSockaddrUnix"}
  SizeofSockaddrUnix)

JOKER CONSTANT SizeofTCPInfo from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofTCPInfo"}
  SizeofTCPInfo)

JOKER CONSTANT SizeofUcred from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.SizeofUcred"}
  SizeofUcred)

JOKER CONSTANT TCGETS from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCGETS"}
  TCGETS)

JOKER CONSTANT TCIFLUSH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCIFLUSH"}
  TCIFLUSH)

JOKER CONSTANT TCIOFLUSH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCIOFLUSH"}
  TCIOFLUSH)

JOKER CONSTANT TCOFLUSH from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCOFLUSH"}
  TCOFLUSH)

JOKER CONSTANT TCP_CONGESTION from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCP_CONGESTION"}
  TCP_CONGESTION)

JOKER CONSTANT TCP_CORK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCP_CORK"}
  TCP_CORK)

JOKER CONSTANT TCP_DEFER_ACCEPT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCP_DEFER_ACCEPT"}
  TCP_DEFER_ACCEPT)

JOKER CONSTANT TCP_INFO from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCP_INFO"}
  TCP_INFO)

JOKER CONSTANT TCP_KEEPCNT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCP_KEEPCNT"}
  TCP_KEEPCNT)

JOKER CONSTANT TCP_KEEPIDLE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCP_KEEPIDLE"}
  TCP_KEEPIDLE)

JOKER CONSTANT TCP_KEEPINTVL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCP_KEEPINTVL"}
  TCP_KEEPINTVL)

JOKER CONSTANT TCP_LINGER2 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCP_LINGER2"}
  TCP_LINGER2)

JOKER CONSTANT TCP_MAXSEG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCP_MAXSEG"}
  TCP_MAXSEG)

JOKER CONSTANT TCP_MAXWIN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCP_MAXWIN"}
  TCP_MAXWIN)

JOKER CONSTANT TCP_MAX_WINSHIFT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCP_MAX_WINSHIFT"}
  TCP_MAX_WINSHIFT)

JOKER CONSTANT TCP_MD5SIG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCP_MD5SIG"}
  TCP_MD5SIG)

JOKER CONSTANT TCP_MD5SIG_MAXKEYLEN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCP_MD5SIG_MAXKEYLEN"}
  TCP_MD5SIG_MAXKEYLEN)

JOKER CONSTANT TCP_MSS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCP_MSS"}
  TCP_MSS)

JOKER CONSTANT TCP_NODELAY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCP_NODELAY"}
  TCP_NODELAY)

JOKER CONSTANT TCP_QUICKACK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCP_QUICKACK"}
  TCP_QUICKACK)

JOKER CONSTANT TCP_SYNCNT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCP_SYNCNT"}
  TCP_SYNCNT)

JOKER CONSTANT TCP_WINDOW_CLAMP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCP_WINDOW_CLAMP"}
  TCP_WINDOW_CLAMP)

JOKER CONSTANT TCSETS from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TCSETS"}
  TCSETS)

JOKER CONSTANT TIOCCBRK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCCBRK"}
  TIOCCBRK)

JOKER CONSTANT TIOCCONS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCCONS"}
  TIOCCONS)

JOKER CONSTANT TIOCEXCL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCEXCL"}
  TIOCEXCL)

JOKER CONSTANT TIOCGDEV from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.TIOCGDEV)"}
  TIOCGDEV)

JOKER CONSTANT TIOCGETD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCGETD"}
  TIOCGETD)

JOKER CONSTANT TIOCGICOUNT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCGICOUNT"}
  TIOCGICOUNT)

JOKER CONSTANT TIOCGLCKTRMIOS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCGLCKTRMIOS"}
  TIOCGLCKTRMIOS)

JOKER CONSTANT TIOCGPGRP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCGPGRP"}
  TIOCGPGRP)

JOKER CONSTANT TIOCGPTN from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.TIOCGPTN)"}
  TIOCGPTN)

JOKER CONSTANT TIOCGRS485 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCGRS485"}
  TIOCGRS485)

JOKER CONSTANT TIOCGSERIAL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCGSERIAL"}
  TIOCGSERIAL)

JOKER CONSTANT TIOCGSID from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCGSID"}
  TIOCGSID)

JOKER CONSTANT TIOCGSOFTCAR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCGSOFTCAR"}
  TIOCGSOFTCAR)

JOKER CONSTANT TIOCGWINSZ from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCGWINSZ"}
  TIOCGWINSZ)

JOKER CONSTANT TIOCINQ from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCINQ"}
  TIOCINQ)

JOKER CONSTANT TIOCLINUX from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCLINUX"}
  TIOCLINUX)

JOKER CONSTANT TIOCMBIC from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCMBIC"}
  TIOCMBIC)

JOKER CONSTANT TIOCMBIS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCMBIS"}
  TIOCMBIS)

JOKER CONSTANT TIOCMGET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCMGET"}
  TIOCMGET)

JOKER CONSTANT TIOCMIWAIT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCMIWAIT"}
  TIOCMIWAIT)

JOKER CONSTANT TIOCMSET from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCMSET"}
  TIOCMSET)

JOKER CONSTANT TIOCM_CAR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCM_CAR"}
  TIOCM_CAR)

JOKER CONSTANT TIOCM_CD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCM_CD"}
  TIOCM_CD)

JOKER CONSTANT TIOCM_CTS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCM_CTS"}
  TIOCM_CTS)

JOKER CONSTANT TIOCM_DSR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCM_DSR"}
  TIOCM_DSR)

JOKER CONSTANT TIOCM_DTR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCM_DTR"}
  TIOCM_DTR)

JOKER CONSTANT TIOCM_LE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCM_LE"}
  TIOCM_LE)

JOKER CONSTANT TIOCM_RI from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCM_RI"}
  TIOCM_RI)

JOKER CONSTANT TIOCM_RNG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCM_RNG"}
  TIOCM_RNG)

JOKER CONSTANT TIOCM_RTS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCM_RTS"}
  TIOCM_RTS)

JOKER CONSTANT TIOCM_SR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCM_SR"}
  TIOCM_SR)

JOKER CONSTANT TIOCM_ST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCM_ST"}
  TIOCM_ST)

JOKER CONSTANT TIOCNOTTY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCNOTTY"}
  TIOCNOTTY)

JOKER CONSTANT TIOCNXCL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCNXCL"}
  TIOCNXCL)

JOKER CONSTANT TIOCOUTQ from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCOUTQ"}
  TIOCOUTQ)

JOKER CONSTANT TIOCPKT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCPKT"}
  TIOCPKT)

JOKER CONSTANT TIOCPKT_DATA from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCPKT_DATA"}
  TIOCPKT_DATA)

JOKER CONSTANT TIOCPKT_DOSTOP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCPKT_DOSTOP"}
  TIOCPKT_DOSTOP)

JOKER CONSTANT TIOCPKT_FLUSHREAD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCPKT_FLUSHREAD"}
  TIOCPKT_FLUSHREAD)

JOKER CONSTANT TIOCPKT_FLUSHWRITE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCPKT_FLUSHWRITE"}
  TIOCPKT_FLUSHWRITE)

JOKER CONSTANT TIOCPKT_IOCTL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCPKT_IOCTL"}
  TIOCPKT_IOCTL)

JOKER CONSTANT TIOCPKT_NOSTOP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCPKT_NOSTOP"}
  TIOCPKT_NOSTOP)

JOKER CONSTANT TIOCPKT_START from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCPKT_START"}
  TIOCPKT_START)

JOKER CONSTANT TIOCPKT_STOP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCPKT_STOP"}
  TIOCPKT_STOP)

JOKER CONSTANT TIOCSBRK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCSBRK"}
  TIOCSBRK)

JOKER CONSTANT TIOCSCTTY from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCSCTTY"}
  TIOCSCTTY)

JOKER CONSTANT TIOCSERCONFIG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCSERCONFIG"}
  TIOCSERCONFIG)

JOKER CONSTANT TIOCSERGETLSR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCSERGETLSR"}
  TIOCSERGETLSR)

JOKER CONSTANT TIOCSERGETMULTI from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCSERGETMULTI"}
  TIOCSERGETMULTI)

JOKER CONSTANT TIOCSERGSTRUCT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCSERGSTRUCT"}
  TIOCSERGSTRUCT)

JOKER CONSTANT TIOCSERGWILD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCSERGWILD"}
  TIOCSERGWILD)

JOKER CONSTANT TIOCSERSETMULTI from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCSERSETMULTI"}
  TIOCSERSETMULTI)

JOKER CONSTANT TIOCSERSWILD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCSERSWILD"}
  TIOCSERSWILD)

JOKER CONSTANT TIOCSER_TEMT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCSER_TEMT"}
  TIOCSER_TEMT)

JOKER CONSTANT TIOCSETD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCSETD"}
  TIOCSETD)

JOKER CONSTANT TIOCSIG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCSIG"}
  TIOCSIG)

JOKER CONSTANT TIOCSLCKTRMIOS from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCSLCKTRMIOS"}
  TIOCSLCKTRMIOS)

JOKER CONSTANT TIOCSPGRP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCSPGRP"}
  TIOCSPGRP)

JOKER CONSTANT TIOCSPTLCK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCSPTLCK"}
  TIOCSPTLCK)

JOKER CONSTANT TIOCSRS485 from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCSRS485"}
  TIOCSRS485)

JOKER CONSTANT TIOCSSERIAL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCSSERIAL"}
  TIOCSSERIAL)

JOKER CONSTANT TIOCSSOFTCAR from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCSSOFTCAR"}
  TIOCSSOFTCAR)

JOKER CONSTANT TIOCSTI from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCSTI"}
  TIOCSTI)

JOKER CONSTANT TIOCSWINSZ from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TIOCSWINSZ"}
  TIOCSWINSZ)

JOKER CONSTANT TOSTOP from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TOSTOP"}
  TOSTOP)

JOKER CONSTANT TUNATTACHFILTER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TUNATTACHFILTER"}
  TUNATTACHFILTER)

JOKER CONSTANT TUNDETACHFILTER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TUNDETACHFILTER"}
  TUNDETACHFILTER)

JOKER CONSTANT TUNGETFEATURES from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.TUNGETFEATURES)"}
  TUNGETFEATURES)

JOKER CONSTANT TUNGETIFF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.TUNGETIFF)"}
  TUNGETIFF)

JOKER CONSTANT TUNGETSNDBUF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.TUNGETSNDBUF)"}
  TUNGETSNDBUF)

JOKER CONSTANT TUNGETVNETHDRSZ from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.TUNGETVNETHDRSZ)"}
  TUNGETVNETHDRSZ)

JOKER CONSTANT TUNSETDEBUG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TUNSETDEBUG"}
  TUNSETDEBUG)

JOKER CONSTANT TUNSETGROUP from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TUNSETGROUP"}
  TUNSETGROUP)

JOKER CONSTANT TUNSETIFF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TUNSETIFF"}
  TUNSETIFF)

JOKER CONSTANT TUNSETLINK from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TUNSETLINK"}
  TUNSETLINK)

JOKER CONSTANT TUNSETNOCSUM from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TUNSETNOCSUM"}
  TUNSETNOCSUM)

JOKER CONSTANT TUNSETOFFLOAD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TUNSETOFFLOAD"}
  TUNSETOFFLOAD)

JOKER CONSTANT TUNSETOWNER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TUNSETOWNER"}
  TUNSETOWNER)

JOKER CONSTANT TUNSETPERSIST from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TUNSETPERSIST"}
  TUNSETPERSIST)

JOKER CONSTANT TUNSETSNDBUF from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TUNSETSNDBUF"}
  TUNSETSNDBUF)

JOKER CONSTANT TUNSETTXFILTER from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TUNSETTXFILTER"}
  TUNSETTXFILTER)

JOKER CONSTANT TUNSETVNETHDRSZ from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.TUNSETVNETHDRSZ"}
  TUNSETVNETHDRSZ)

JOKER CONSTANT VDISCARD from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.VDISCARD"}
  VDISCARD)

JOKER CONSTANT VEOF from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.VEOF"}
  VEOF)

JOKER CONSTANT VEOL from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.VEOL"}
  VEOL)

JOKER CONSTANT VEOL2 from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.VEOL2"}
  VEOL2)

JOKER CONSTANT VERASE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.VERASE"}
  VERASE)

JOKER CONSTANT VINTR from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.VINTR"}
  VINTR)

JOKER CONSTANT VKILL from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.VKILL"}
  VKILL)

JOKER CONSTANT VLNEXT from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.VLNEXT"}
  VLNEXT)

JOKER CONSTANT VMIN from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.VMIN"}
  VMIN)

JOKER CONSTANT VQUIT from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.VQUIT"}
  VQUIT)

JOKER CONSTANT VREPRINT from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.VREPRINT"}
  VREPRINT)

JOKER CONSTANT VSTART from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.VSTART"}
  VSTART)

JOKER CONSTANT VSTOP from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.VSTOP"}
  VSTOP)

JOKER CONSTANT VSUSP from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.VSUSP"}
  VSUSP)

JOKER CONSTANT VSWTC from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.VSWTC"}
  VSWTC)

JOKER CONSTANT VTIME from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.VTIME"}
  VTIME)

JOKER CONSTANT VWERASE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.VWERASE"}
  VWERASE)

JOKER CONSTANT WALL from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.WALL"}
  WALL)

JOKER CONSTANT WCLONE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Number"
    :go "int64(syscall.WCLONE)"}
  WCLONE)

JOKER CONSTANT WCONTINUED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.WCONTINUED"}
  WCONTINUED)

JOKER CONSTANT WEXITED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.WEXITED"}
  WEXITED)

JOKER CONSTANT WNOHANG from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.WNOHANG"}
  WNOHANG)

JOKER CONSTANT WNOTHREAD from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.WNOTHREAD"}
  WNOTHREAD)

JOKER CONSTANT WNOWAIT from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.WNOWAIT"}
  WNOWAIT)

JOKER CONSTANT WORDSIZE from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.WORDSIZE"}
  WORDSIZE)

JOKER CONSTANT WSTOPPED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.WSTOPPED"}
  WSTOPPED)

JOKER CONSTANT WUNTRACED from syscall/zerrors_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.WUNTRACED"}
  WUNTRACED)

JOKER CONSTANT XCASE from syscall/ztypes_linux_amd64.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "syscall.XCASE"}
  XCASE)

JOKER VARIABLE ForkLock from syscall/exec_unix.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "syscall.ForkLock"}
  ForkLock)

JOKER VARIABLE SocketDisableIPv6 from syscall/syscall_unix.go:
(def
  ^{:doc "For testing: clients can set this flag to force\ncreation of IPv6 sockets to return EAFNOSUPPORT.\n"
    :added "1.0"
    :tag "Var"
    :go "syscall.SocketDisableIPv6"}
  SocketDisableIPv6)

JOKER VARIABLE Stderr from syscall/syscall_unix.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "syscall.Stderr"}
  Stderr)

JOKER VARIABLE Stdin from syscall/syscall_unix.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "syscall.Stdin"}
  Stdin)

JOKER VARIABLE Stdout from syscall/syscall_unix.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "syscall.Stdout"}
  Stdout)

JOKER TYPE syscall.Cmsghdr from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Cmsghdr.
  "Constructor for syscall.Cmsghdr"
  {:added "1.0"
   :go "_ConstructCmsghdr(_v)"}
  [^Object _v])

JOKER TYPE syscall.Conn from syscall/net.go:
;; (defn ^"GoObject" Conn.
;;   "Constructor for syscall.Conn"
;;   {:added "1.0"
;;    :go "_ConstructConn(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Credential from syscall/exec_unix.go:
;; (defn ^"GoObject" Credential.
;;   "Constructor for syscall.Credential"
;;   {:added "1.0"
;;    :go "_ConstructCredential(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Dirent from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" Dirent.
;;   "Constructor for syscall.Dirent"
;;   {:added "1.0"
;;    :go "_ConstructDirent(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.EpollEvent from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" EpollEvent.
  "Constructor for syscall.EpollEvent"
  {:added "1.0"
   :go "_ConstructEpollEvent(_v)"}
  [^Object _v])

JOKER TYPE syscall.Errno from syscall/syscall_unix.go:
(defn ^"GoObject" Errno.
  "Constructor for syscall.Errno"
  {:added "1.0"
   :go "_ConstructErrno(_v)"}
  [^Object _v])

JOKER TYPE syscall.FdSet from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" FdSet.
;;   "Constructor for syscall.FdSet"
;;   {:added "1.0"
;;    :go "_ConstructFdSet(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Flock_t from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" Flock_t.
;;   "Constructor for syscall.Flock_t"
;;   {:added "1.0"
;;    :go "_ConstructFlock_t(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Fsid from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" Fsid.
;;   "Constructor for syscall.Fsid"
;;   {:added "1.0"
;;    :go "_ConstructFsid(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.ICMPv6Filter from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" ICMPv6Filter.
;;   "Constructor for syscall.ICMPv6Filter"
;;   {:added "1.0"
;;    :go "_ConstructICMPv6Filter(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.IPMreq from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" IPMreq.
;;   "Constructor for syscall.IPMreq"
;;   {:added "1.0"
;;    :go "_ConstructIPMreq(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.IPMreqn from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" IPMreqn.
;;   "Constructor for syscall.IPMreqn"
;;   {:added "1.0"
;;    :go "_ConstructIPMreqn(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.IPv6MTUInfo from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" IPv6MTUInfo.
;;   "Constructor for syscall.IPv6MTUInfo"
;;   {:added "1.0"
;;    :go "_ConstructIPv6MTUInfo(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.IPv6Mreq from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" IPv6Mreq.
;;   "Constructor for syscall.IPv6Mreq"
;;   {:added "1.0"
;;    :go "_ConstructIPv6Mreq(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.IfAddrmsg from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" IfAddrmsg.
  "Constructor for syscall.IfAddrmsg"
  {:added "1.0"
   :go "_ConstructIfAddrmsg(_v)"}
  [^Object _v])

JOKER TYPE syscall.IfInfomsg from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" IfInfomsg.
  "Constructor for syscall.IfInfomsg"
  {:added "1.0"
   :go "_ConstructIfInfomsg(_v)"}
  [^Object _v])

JOKER TYPE syscall.Inet4Pktinfo from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" Inet4Pktinfo.
;;   "Constructor for syscall.Inet4Pktinfo"
;;   {:added "1.0"
;;    :go "_ConstructInet4Pktinfo(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Inet6Pktinfo from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" Inet6Pktinfo.
;;   "Constructor for syscall.Inet6Pktinfo"
;;   {:added "1.0"
;;    :go "_ConstructInet6Pktinfo(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.InotifyEvent from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" InotifyEvent.
;;   "Constructor for syscall.InotifyEvent"
;;   {:added "1.0"
;;    :go "_ConstructInotifyEvent(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Iovec from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" Iovec.
;;   "Constructor for syscall.Iovec"
;;   {:added "1.0"
;;    :go "_ConstructIovec(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Linger from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Linger.
  "Constructor for syscall.Linger"
  {:added "1.0"
   :go "_ConstructLinger(_v)"}
  [^Object _v])

JOKER TYPE syscall.Msghdr from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" Msghdr.
;;   "Constructor for syscall.Msghdr"
;;   {:added "1.0"
;;    :go "_ConstructMsghdr(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.NetlinkMessage from syscall/netlink_linux.go:
;; (defn ^"GoObject" NetlinkMessage.
;;   "Constructor for syscall.NetlinkMessage"
;;   {:added "1.0"
;;    :go "_ConstructNetlinkMessage(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.NetlinkRouteAttr from syscall/netlink_linux.go:
;; (defn ^"GoObject" NetlinkRouteAttr.
;;   "Constructor for syscall.NetlinkRouteAttr"
;;   {:added "1.0"
;;    :go "_ConstructNetlinkRouteAttr(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.NetlinkRouteRequest from syscall/netlink_linux.go:
;; (defn ^"GoObject" NetlinkRouteRequest.
;;   "Constructor for syscall.NetlinkRouteRequest"
;;   {:added "1.0"
;;    :go "_ConstructNetlinkRouteRequest(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.NlAttr from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" NlAttr.
  "Constructor for syscall.NlAttr"
  {:added "1.0"
   :go "_ConstructNlAttr(_v)"}
  [^Object _v])

JOKER TYPE syscall.NlMsgerr from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" NlMsgerr.
;;   "Constructor for syscall.NlMsgerr"
;;   {:added "1.0"
;;    :go "_ConstructNlMsgerr(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.NlMsghdr from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" NlMsghdr.
  "Constructor for syscall.NlMsghdr"
  {:added "1.0"
   :go "_ConstructNlMsghdr(_v)"}
  [^Object _v])

JOKER TYPE syscall.ProcAttr from syscall/exec_unix.go:
;; (defn ^"GoObject" ProcAttr.
;;   "Constructor for syscall.ProcAttr"
;;   {:added "1.0"
;;    :go "_ConstructProcAttr(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.PtraceRegs from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" PtraceRegs.
  "Constructor for syscall.PtraceRegs"
  {:added "1.0"
   :go "_ConstructPtraceRegs(_v)"}
  [^Object _v])

JOKER TYPE syscall.RawConn from syscall/net.go:
;; (defn ^"GoObject" RawConn.
;;   "Constructor for syscall.RawConn"
;;   {:added "1.0"
;;    :go "_ConstructRawConn(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.RawSockaddr from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" RawSockaddr.
;;   "Constructor for syscall.RawSockaddr"
;;   {:added "1.0"
;;    :go "_ConstructRawSockaddr(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.RawSockaddrAny from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" RawSockaddrAny.
;;   "Constructor for syscall.RawSockaddrAny"
;;   {:added "1.0"
;;    :go "_ConstructRawSockaddrAny(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.RawSockaddrInet4 from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" RawSockaddrInet4.
;;   "Constructor for syscall.RawSockaddrInet4"
;;   {:added "1.0"
;;    :go "_ConstructRawSockaddrInet4(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.RawSockaddrInet6 from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" RawSockaddrInet6.
;;   "Constructor for syscall.RawSockaddrInet6"
;;   {:added "1.0"
;;    :go "_ConstructRawSockaddrInet6(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.RawSockaddrLinklayer from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" RawSockaddrLinklayer.
;;   "Constructor for syscall.RawSockaddrLinklayer"
;;   {:added "1.0"
;;    :go "_ConstructRawSockaddrLinklayer(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.RawSockaddrNetlink from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" RawSockaddrNetlink.
  "Constructor for syscall.RawSockaddrNetlink"
  {:added "1.0"
   :go "_ConstructRawSockaddrNetlink(_v)"}
  [^Object _v])

JOKER TYPE syscall.RawSockaddrUnix from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" RawSockaddrUnix.
;;   "Constructor for syscall.RawSockaddrUnix"
;;   {:added "1.0"
;;    :go "_ConstructRawSockaddrUnix(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Rlimit from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Rlimit.
  "Constructor for syscall.Rlimit"
  {:added "1.0"
   :go "_ConstructRlimit(_v)"}
  [^Object _v])

JOKER TYPE syscall.RtAttr from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" RtAttr.
  "Constructor for syscall.RtAttr"
  {:added "1.0"
   :go "_ConstructRtAttr(_v)"}
  [^Object _v])

JOKER TYPE syscall.RtGenmsg from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" RtGenmsg.
  "Constructor for syscall.RtGenmsg"
  {:added "1.0"
   :go "_ConstructRtGenmsg(_v)"}
  [^Object _v])

JOKER TYPE syscall.RtMsg from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" RtMsg.
  "Constructor for syscall.RtMsg"
  {:added "1.0"
   :go "_ConstructRtMsg(_v)"}
  [^Object _v])

JOKER TYPE syscall.RtNexthop from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" RtNexthop.
  "Constructor for syscall.RtNexthop"
  {:added "1.0"
   :go "_ConstructRtNexthop(_v)"}
  [^Object _v])

JOKER TYPE syscall.Rusage from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" Rusage.
;;   "Constructor for syscall.Rusage"
;;   {:added "1.0"
;;    :go "_ConstructRusage(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Signal from syscall/syscall_unix.go:
(defn ^"GoObject" Signal.
  "Constructor for syscall.Signal"
  {:added "1.0"
   :go "_ConstructSignal(_v)"}
  [^Object _v])

JOKER TYPE syscall.SockFilter from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" SockFilter.
  "Constructor for syscall.SockFilter"
  {:added "1.0"
   :go "_ConstructSockFilter(_v)"}
  [^Object _v])

JOKER TYPE syscall.SockFprog from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" SockFprog.
;;   "Constructor for syscall.SockFprog"
;;   {:added "1.0"
;;    :go "_ConstructSockFprog(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Sockaddr from syscall/syscall_unix.go:
;; (defn ^"GoObject" Sockaddr.
;;   "Constructor for syscall.Sockaddr"
;;   {:added "1.0"
;;    :go "_ConstructSockaddr(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.SockaddrInet4 from syscall/syscall_unix.go:
;; (defn ^"GoObject" SockaddrInet4.
;;   "Constructor for syscall.SockaddrInet4"
;;   {:added "1.0"
;;    :go "_ConstructSockaddrInet4(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.SockaddrInet6 from syscall/syscall_unix.go:
;; (defn ^"GoObject" SockaddrInet6.
;;   "Constructor for syscall.SockaddrInet6"
;;   {:added "1.0"
;;    :go "_ConstructSockaddrInet6(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.SockaddrLinklayer from syscall/syscall_linux.go:
;; (defn ^"GoObject" SockaddrLinklayer.
;;   "Constructor for syscall.SockaddrLinklayer"
;;   {:added "1.0"
;;    :go "_ConstructSockaddrLinklayer(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.SockaddrNetlink from syscall/syscall_linux.go:
(defn ^"GoObject" SockaddrNetlink.
  "Constructor for syscall.SockaddrNetlink"
  {:added "1.0"
   :go "_ConstructSockaddrNetlink(_v)"}
  [^Object _v])

JOKER TYPE syscall.SockaddrUnix from syscall/syscall_unix.go:
(defn ^"GoObject" SockaddrUnix.
  "Constructor for syscall.SockaddrUnix"
  {:added "1.0"
   :go "_ConstructSockaddrUnix(_v)"}
  [^Object _v])

JOKER TYPE syscall.SocketControlMessage from syscall/sockcmsg_unix.go:
;; (defn ^"GoObject" SocketControlMessage.
;;   "Constructor for syscall.SocketControlMessage"
;;   {:added "1.0"
;;    :go "_ConstructSocketControlMessage(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Stat_t from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" Stat_t.
;;   "Constructor for syscall.Stat_t"
;;   {:added "1.0"
;;    :go "_ConstructStat_t(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Statfs_t from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" Statfs_t.
;;   "Constructor for syscall.Statfs_t"
;;   {:added "1.0"
;;    :go "_ConstructStatfs_t(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.SysProcAttr from syscall/exec_linux.go:
;; (defn ^"GoObject" SysProcAttr.
;;   "Constructor for syscall.SysProcAttr"
;;   {:added "1.0"
;;    :go "_ConstructSysProcAttr(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.SysProcIDMap from syscall/exec_linux.go:
(defn ^"GoObject" SysProcIDMap.
  "Constructor for syscall.SysProcIDMap"
  {:added "1.0"
   :go "_ConstructSysProcIDMap(_v)"}
  [^Object _v])

JOKER TYPE syscall.Sysinfo_t from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" Sysinfo_t.
;;   "Constructor for syscall.Sysinfo_t"
;;   {:added "1.0"
;;    :go "_ConstructSysinfo_t(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.TCPInfo from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" TCPInfo.
;;   "Constructor for syscall.TCPInfo"
;;   {:added "1.0"
;;    :go "_ConstructTCPInfo(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Termios from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" Termios.
;;   "Constructor for syscall.Termios"
;;   {:added "1.0"
;;    :go "_ConstructTermios(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Time_t from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Time_t.
  "Constructor for syscall.Time_t"
  {:added "1.0"
   :go "_ConstructTime_t(_v)"}
  [^Object _v])

JOKER TYPE syscall.Timespec from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Timespec.
  "Constructor for syscall.Timespec"
  {:added "1.0"
   :go "_ConstructTimespec(_v)"}
  [^Object _v])

JOKER TYPE syscall.Timeval from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Timeval.
  "Constructor for syscall.Timeval"
  {:added "1.0"
   :go "_ConstructTimeval(_v)"}
  [^Object _v])

JOKER TYPE syscall.Timex from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" Timex.
;;   "Constructor for syscall.Timex"
;;   {:added "1.0"
;;    :go "_ConstructTimex(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Tms from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Tms.
  "Constructor for syscall.Tms"
  {:added "1.0"
   :go "_ConstructTms(_v)"}
  [^Object _v])

JOKER TYPE syscall.Ucred from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Ucred.
  "Constructor for syscall.Ucred"
  {:added "1.0"
   :go "_ConstructUcred(_v)"}
  [^Object _v])

JOKER TYPE syscall.Ustat_t from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" Ustat_t.
;;   "Constructor for syscall.Ustat_t"
;;   {:added "1.0"
;;    :go "_ConstructUstat_t(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Utimbuf from syscall/ztypes_linux_amd64.go:
(defn ^"GoObject" Utimbuf.
  "Constructor for syscall.Utimbuf"
  {:added "1.0"
   :go "_ConstructUtimbuf(_v)"}
  [^Object _v])

JOKER TYPE syscall.Utsname from syscall/ztypes_linux_amd64.go:
;; (defn ^"GoObject" Utsname.
;;   "Constructor for syscall.Utsname"
;;   {:added "1.0"
;;    :go "_ConstructUtsname(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.WaitStatus from syscall/syscall_linux.go:
(defn ^"GoObject" WaitStatus.
  "Constructor for syscall.WaitStatus"
  {:added "1.0"
   :go "_ConstructWaitStatus(_v)"}
  [^Object _v])

JOKER FUNC syscall.Accept from syscall/syscall_linux.go:
(defn Accept
  "Go input arguments: (fd int)\n\nGo return type: (nfd int, sa Sockaddr, err error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [Int go.std.syscall/Sockaddr Error]"
  {:added "1.0"
   :go "__accept(__fd)"}
  [^Int __fd])

JOKER FUNC syscall.Accept4 from syscall/syscall_linux.go:
(defn Accept4
  "Go input arguments: (fd int, flags int)\n\nGo return type: (nfd int, sa Sockaddr, err error)\n\nJoker input arguments: [^Int fd, ^Int flags]\n\nJoker return type: [Int go.std.syscall/Sockaddr Error]"
  {:added "1.0"
   :go "__accept4(__fd, __flags)"}
  [^Int __fd, ^Int __flags])

JOKER FUNC syscall.Access from syscall/syscall_linux.go:
(defn ^"Error" Access
  "Go input arguments: (path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Number mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Access(__path, __mode)"}
  [^String __path, ^UInt32 __mode])

JOKER FUNC syscall.Acct from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Acct
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Acct(__path)"}
  [^String __path])

JOKER FUNC syscall.Adjtimex from syscall/zsyscall_linux_amd64.go:
(defn Adjtimex
  "Go input arguments: (buf *Timex)\n\nGo return type: (state int, err error)\n\nJoker input arguments: [^(atom-of go.std.syscall/Timex) buf]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__adjtimex(__buf)"}
  [^syscall/Timex __buf])

JOKER FUNC syscall.AttachLsf from syscall/lsf_linux.go:
;; (defn ^"Error" AttachLsf
;;   "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int, i []SockFilter)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(vector-of go.std.syscall/SockFilter) i]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.AttachLsf(__fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_syscall.SockFilter(*__i)))"}
;;   [^Int __fd, ^Object __i])

JOKER FUNC syscall.Bind from syscall/syscall_unix.go:
(defn ^"Error" Bind
  "Go input arguments: (fd int, sa Sockaddr)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^go.std.syscall/Sockaddr sa]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Bind(__fd, *__sa)"}
  [^Int __fd, ^syscall/Sockaddr __sa])

JOKER FUNC syscall.BindToDevice from syscall/syscall_linux.go:
(defn ^"Error" BindToDevice
  "BindToDevice binds the socket associated with fd to device.\n\nGo input arguments: (fd int, device string)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^String device]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.BindToDevice(__fd, __device)"}
  [^Int __fd, ^String __device])

JOKER FUNC syscall.BytePtrFromString from syscall/syscall.go:
(defn BytePtrFromString
  "BytePtrFromString returns a pointer to a NUL-terminated array of\nbytes containing the text of s. If s contains a NUL byte at any\nlocation, it returns (nil, EINVAL).\n\nGo input arguments: (s string)\n\nGo return type: (*byte, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [(atom-of Int) Error]"
  {:added "1.0"
   :go "__bytePtrFromString(__s)"}
  [^String __s])

JOKER FUNC syscall.ByteSliceFromString from syscall/syscall.go:
(defn ByteSliceFromString
  "ByteSliceFromString returns a NUL-terminated slice of bytes\ncontaining the text of s. If s contains a NUL byte at any\nlocation, it returns (nil, EINVAL).\n\nGo input arguments: (s string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__byteSliceFromString(__s)"}
  [^String __s])

JOKER FUNC syscall.Chdir from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Chdir
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chdir(__path)"}
  [^String __path])

JOKER FUNC syscall.Chmod from syscall/syscall_linux.go:
(defn ^"Error" Chmod
  "Go input arguments: (path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Number mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chmod(__path, __mode)"}
  [^String __path, ^UInt32 __mode])

JOKER FUNC syscall.Chown from syscall/syscall_linux.go:
(defn ^"Error" Chown
  "Go input arguments: (path string, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chown(__path, __uid, __gid)"}
  [^String __path, ^Int __uid, ^Int __gid])

JOKER FUNC syscall.Chroot from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Chroot
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chroot(__path)"}
  [^String __path])

JOKER FUNC syscall.Clearenv from syscall/env_unix.go:
;; (defn Clearenv
;;   "Joker input arguments: []"
;;   {:added "1.0"
;;    :go "__clearenv()"}
;;   [])

JOKER FUNC syscall.Close from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Close
  "Go input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Close(__fd)"}
  [^Int __fd])

JOKER FUNC syscall.CloseOnExec from syscall/exec_unix.go:
;; (defn CloseOnExec
;;   "Go input arguments: (fd int)\n\nJoker input arguments: [^Int fd]"
;;   {:added "1.0"
;;    :go "__closeOnExec(__fd)"}
;;   [^Int __fd])

JOKER FUNC syscall.CmsgLen from syscall/sockcmsg_unix.go:
(defn ^"Int" CmsgLen
  "CmsgLen returns the value to store in the Len field of the Cmsghdr\nstructure, taking into account any necessary alignment.\n\nGo input arguments: (datalen int)\n\nGo return type: int\n\nJoker input arguments: [^Int datalen]\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.CmsgLen(__datalen)"}
  [^Int __datalen])

JOKER FUNC syscall.CmsgSpace from syscall/sockcmsg_unix.go:
(defn ^"Int" CmsgSpace
  "CmsgSpace returns the number of bytes an ancillary element with\npayload of the passed data length occupies.\n\nGo input arguments: (datalen int)\n\nGo return type: int\n\nJoker input arguments: [^Int datalen]\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.CmsgSpace(__datalen)"}
  [^Int __datalen])

JOKER FUNC syscall.Connect from syscall/syscall_unix.go:
(defn ^"Error" Connect
  "Go input arguments: (fd int, sa Sockaddr)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^go.std.syscall/Sockaddr sa]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Connect(__fd, *__sa)"}
  [^Int __fd, ^syscall/Sockaddr __sa])

JOKER FUNC syscall.Creat from syscall/syscall_linux.go:
(defn Creat
  "Go input arguments: (path string, mode uint32)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^String path, ^Number mode]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__creat(__path, __mode)"}
  [^String __path, ^UInt32 __mode])

JOKER FUNC syscall.DetachLsf from syscall/lsf_linux.go:
(defn ^"Error" DetachLsf
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.DetachLsf(__fd)"}
  [^Int __fd])

JOKER FUNC syscall.Dup from syscall/zsyscall_linux_amd64.go:
(defn Dup
  "Go input arguments: (oldfd int)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^Int oldfd]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__dup(__oldfd)"}
  [^Int __oldfd])

JOKER FUNC syscall.Dup2 from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Dup2
  "Go input arguments: (oldfd int, newfd int)\n\nGo return type: error\n\nJoker input arguments: [^Int oldfd, ^Int newfd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Dup2(__oldfd, __newfd)"}
  [^Int __oldfd, ^Int __newfd])

JOKER FUNC syscall.Dup3 from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Dup3
  "Go input arguments: (oldfd int, newfd int, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int oldfd, ^Int newfd, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Dup3(__oldfd, __newfd, __flags)"}
  [^Int __oldfd, ^Int __newfd, ^Int __flags])

JOKER FUNC syscall.Environ from syscall/env_unix.go:
(defn Environ
  "Go return type: []string\n\nJoker input arguments: []\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__environ()"}
  [])

JOKER FUNC syscall.EpollCreate from syscall/zsyscall_linux_amd64.go:
(defn EpollCreate
  "Go input arguments: (size int)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^Int size]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__epollCreate(__size)"}
  [^Int __size])

JOKER FUNC syscall.EpollCreate1 from syscall/zsyscall_linux_amd64.go:
(defn EpollCreate1
  "Go input arguments: (flag int)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^Int flag]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__epollCreate1(__flag)"}
  [^Int __flag])

JOKER FUNC syscall.EpollCtl from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" EpollCtl
  "Go input arguments: (epfd int, op int, fd int, event *EpollEvent)\n\nGo return type: error\n\nJoker input arguments: [^Int epfd, ^Int op, ^Int fd, ^(atom-of go.std.syscall/EpollEvent) event]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.EpollCtl(__epfd, __op, __fd, __event)"}
  [^Int __epfd, ^Int __op, ^Int __fd, ^syscall/EpollEvent __event])

JOKER FUNC syscall.EpollWait from syscall/zsyscall_linux_amd64.go:
;; (defn EpollWait
;;   "Go input arguments: (epfd int, events []EpollEvent, msec int)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int epfd, ^(vector-of go.std.syscall/EpollEvent) events, ^Int msec]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__epollWait(__epfd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_syscall.EpollEvent(*__events)), __msec)"}
;;   [^Int __epfd, ^Object __events, ^Int __msec])

JOKER FUNC syscall.Exec from syscall/exec_unix.go:
;; (defn ^"Error" Exec
;;   "Exec invokes the execve(2) system call.\n\nGo input arguments: (argv0 string, argv []string, envv []string)\n\nGo return type: error\n\nJoker input arguments: [^String argv0, ^(vector-of String) argv, ^(vector-of String) envv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Exec(__argv0, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(__argv)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(__envv)))"}
;;   [^String __argv0, ^Object __argv, ^Object __envv])

JOKER FUNC syscall.Exit from syscall/syscall.go:
;; (defn Exit
;;   "Go input arguments: (code int)\n\nJoker input arguments: [^Int code]"
;;   {:added "1.0"
;;    :go "__exit(__code)"}
;;   [^Int __code])

JOKER FUNC syscall.Faccessat from syscall/syscall_linux.go:
(defn ^"Error" Faccessat
  "Go input arguments: (dirfd int, path string, mode uint32, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int dirfd, ^String path, ^Number mode, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Faccessat(__dirfd, __path, __mode, __flags)"}
  [^Int __dirfd, ^String __path, ^UInt32 __mode, ^Int __flags])

JOKER FUNC syscall.Fallocate from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Fallocate
  "Go input arguments: (fd int, mode uint32, off int64, len int64)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Number mode, ^Number off, ^Number len]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fallocate(__fd, __mode, __off, __len)"}
  [^Int __fd, ^UInt32 __mode, ^Int64 __off, ^Int64 __len])

JOKER FUNC syscall.Fchdir from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Fchdir
  "Go input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchdir(__fd)"}
  [^Int __fd])

JOKER FUNC syscall.Fchmod from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Fchmod
  "Go input arguments: (fd int, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Number mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchmod(__fd, __mode)"}
  [^Int __fd, ^UInt32 __mode])

JOKER FUNC syscall.Fchmodat from syscall/syscall_linux.go:
(defn ^"Error" Fchmodat
  "Go input arguments: (dirfd int, path string, mode uint32, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int dirfd, ^String path, ^Number mode, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchmodat(__dirfd, __path, __mode, __flags)"}
  [^Int __dirfd, ^String __path, ^UInt32 __mode, ^Int __flags])

JOKER FUNC syscall.Fchown from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Fchown
  "Go input arguments: (fd int, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchown(__fd, __uid, __gid)"}
  [^Int __fd, ^Int __uid, ^Int __gid])

JOKER FUNC syscall.Fchownat from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Fchownat
  "Go input arguments: (dirfd int, path string, uid int, gid int, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int dirfd, ^String path, ^Int uid, ^Int gid, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchownat(__dirfd, __path, __uid, __gid, __flags)"}
  [^Int __dirfd, ^String __path, ^Int __uid, ^Int __gid, ^Int __flags])

JOKER FUNC syscall.FcntlFlock from syscall/flock.go:
(defn ^"Error" FcntlFlock
  "FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.\n\nGo input arguments: (fd uintptr, cmd int, lk *Flock_t)\n\nGo return type: error\n\nJoker input arguments: [^Number fd, ^Int cmd, ^(atom-of go.std.syscall/Flock_t) lk]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.FcntlFlock(__fd, __cmd, __lk)"}
  [^UIntPtr __fd, ^Int __cmd, ^syscall/Flock_t __lk])

JOKER FUNC syscall.Fdatasync from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Fdatasync
  "Go input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fdatasync(__fd)"}
  [^Int __fd])

JOKER FUNC syscall.Flock from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Flock
  "Go input arguments: (fd int, how int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int how]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Flock(__fd, __how)"}
  [^Int __fd, ^Int __how])

JOKER FUNC syscall.ForkExec from syscall/exec_unix.go:
;; (defn ForkExec
;;   "Combination of fork and exec, careful to be thread safe.\n\nGo input arguments: (argv0 string, argv []string, attr *ProcAttr)\n\nGo return type: (pid int, err error)\n\nJoker input arguments: [^String argv0, ^(vector-of String) argv, ^(atom-of go.std.syscall/ProcAttr) attr]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__forkExec(__argv0, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(__argv)), __attr)"}
;;   [^String __argv0, ^Object __argv, ^syscall/ProcAttr __attr])

JOKER FUNC syscall.Fstat from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Fstat
  "Go input arguments: (fd int, stat *Stat_t)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(atom-of go.std.syscall/Stat_t) stat]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fstat(__fd, __stat)"}
  [^Int __fd, ^syscall/Stat_t __stat])

JOKER FUNC syscall.Fstatfs from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Fstatfs
  "Go input arguments: (fd int, buf *Statfs_t)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(atom-of go.std.syscall/Statfs_t) buf]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fstatfs(__fd, __buf)"}
  [^Int __fd, ^syscall/Statfs_t __buf])

JOKER FUNC syscall.Fsync from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Fsync
  "Go input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fsync(__fd)"}
  [^Int __fd])

JOKER FUNC syscall.Ftruncate from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Ftruncate
  "Go input arguments: (fd int, length int64)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Number length]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Ftruncate(__fd, __length)"}
  [^Int __fd, ^Int64 __length])

JOKER FUNC syscall.Futimes from syscall/syscall_linux.go:
;; (defn ^"Error" Futimes
;;   "Go input arguments: (fd int, tv []Timeval)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(vector-of go.std.syscall/Timeval) tv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Futimes(__fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_syscall.Timeval(*__tv)))"}
;;   [^Int __fd, ^Object __tv])

JOKER FUNC syscall.Futimesat from syscall/syscall_linux.go:
;; (defn ^"Error" Futimesat
;;   "Go input arguments: (dirfd int, path string, tv []Timeval)\n\nGo return type: error\n\nJoker input arguments: [^Int dirfd, ^String path, ^(vector-of go.std.syscall/Timeval) tv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Futimesat(__dirfd, __path, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_syscall.Timeval(*__tv)))"}
;;   [^Int __dirfd, ^String __path, ^Object __tv])

JOKER FUNC syscall.Getcwd from syscall/zsyscall_linux_amd64.go:
;; (defn Getcwd
;;   "Go input arguments: (buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(vector-of Int) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__getcwd(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__buf)))"}
;;   [^Object __buf])

JOKER FUNC syscall.Getdents from syscall/zsyscall_linux_amd64.go:
;; (defn Getdents
;;   "Go input arguments: (fd int, buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Int) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__getdents(__fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__buf)))"}
;;   [^Int __fd, ^Object __buf])

JOKER FUNC syscall.Getegid from syscall/zsyscall_linux_amd64.go:
(defn ^"Int" Getegid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getegid()"}
  [])

JOKER FUNC syscall.Getenv from syscall/env_unix.go:
(defn Getenv
  "Go input arguments: (key string)\n\nGo return type: (value string, found bool)\n\nJoker input arguments: [^String key]\n\nJoker return type: [String Boolean]"
  {:added "1.0"
   :go "__getenv(__key)"}
  [^String __key])

JOKER FUNC syscall.Geteuid from syscall/zsyscall_linux_amd64.go:
(defn ^"Int" Geteuid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Geteuid()"}
  [])

JOKER FUNC syscall.Getgid from syscall/zsyscall_linux_amd64.go:
(defn ^"Int" Getgid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getgid()"}
  [])

JOKER FUNC syscall.Getgroups from syscall/syscall_linux.go:
(defn Getgroups
  "Go return type: (gids []int, err error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__getgroups()"}
  [])

JOKER FUNC syscall.Getpagesize from syscall/syscall.go:
(defn ^"Int" Getpagesize
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getpagesize()"}
  [])

JOKER FUNC syscall.Getpeername from syscall/syscall_unix.go:
(defn Getpeername
  "Go input arguments: (fd int)\n\nGo return type: (sa Sockaddr, err error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [go.std.syscall/Sockaddr Error]"
  {:added "1.0"
   :go "__getpeername(__fd)"}
  [^Int __fd])

JOKER FUNC syscall.Getpgid from syscall/zsyscall_linux_amd64.go:
(defn Getpgid
  "Go input arguments: (pid int)\n\nGo return type: (pgid int, err error)\n\nJoker input arguments: [^Int pid]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__getpgid(__pid)"}
  [^Int __pid])

JOKER FUNC syscall.Getpgrp from syscall/syscall_linux.go:
(defn ^"Int" Getpgrp
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getpgrp()"}
  [])

JOKER FUNC syscall.Getpid from syscall/zsyscall_linux_amd64.go:
(defn ^"Int" Getpid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getpid()"}
  [])

JOKER FUNC syscall.Getppid from syscall/zsyscall_linux_amd64.go:
(defn ^"Int" Getppid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getppid()"}
  [])

JOKER FUNC syscall.Getpriority from syscall/zsyscall_linux_amd64.go:
(defn Getpriority
  "Go input arguments: (which int, who int)\n\nGo return type: (prio int, err error)\n\nJoker input arguments: [^Int which, ^Int who]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__getpriority(__which, __who)"}
  [^Int __which, ^Int __who])

JOKER FUNC syscall.Getrlimit from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Getrlimit
  "Go input arguments: (resource int, rlim *Rlimit)\n\nGo return type: error\n\nJoker input arguments: [^Int resource, ^(atom-of go.std.syscall/Rlimit) rlim]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Getrlimit(__resource, __rlim)"}
  [^Int __resource, ^syscall/Rlimit __rlim])

JOKER FUNC syscall.Getrusage from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Getrusage
  "Go input arguments: (who int, rusage *Rusage)\n\nGo return type: error\n\nJoker input arguments: [^Int who, ^(atom-of go.std.syscall/Rusage) rusage]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Getrusage(__who, __rusage)"}
  [^Int __who, ^syscall/Rusage __rusage])

JOKER FUNC syscall.Getsockname from syscall/syscall_linux.go:
(defn Getsockname
  "Go input arguments: (fd int)\n\nGo return type: (sa Sockaddr, err error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [go.std.syscall/Sockaddr Error]"
  {:added "1.0"
   :go "__getsockname(__fd)"}
  [^Int __fd])

JOKER FUNC syscall.GetsockoptICMPv6Filter from syscall/syscall_linux.go:
(defn GetsockoptICMPv6Filter
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*ICMPv6Filter, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(atom-of go.std.syscall/ICMPv6Filter) Error]"
  {:added "1.0"
   :go "__getsockoptICMPv6Filter(__fd, __level, __opt)"}
  [^Int __fd, ^Int __level, ^Int __opt])

JOKER FUNC syscall.GetsockoptIPMreq from syscall/syscall_linux.go:
(defn GetsockoptIPMreq
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*IPMreq, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(atom-of go.std.syscall/IPMreq) Error]"
  {:added "1.0"
   :go "__getsockoptIPMreq(__fd, __level, __opt)"}
  [^Int __fd, ^Int __level, ^Int __opt])

JOKER FUNC syscall.GetsockoptIPMreqn from syscall/syscall_linux.go:
(defn GetsockoptIPMreqn
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*IPMreqn, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(atom-of go.std.syscall/IPMreqn) Error]"
  {:added "1.0"
   :go "__getsockoptIPMreqn(__fd, __level, __opt)"}
  [^Int __fd, ^Int __level, ^Int __opt])

JOKER FUNC syscall.GetsockoptIPv6MTUInfo from syscall/syscall_linux.go:
(defn GetsockoptIPv6MTUInfo
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*IPv6MTUInfo, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(atom-of go.std.syscall/IPv6MTUInfo) Error]"
  {:added "1.0"
   :go "__getsockoptIPv6MTUInfo(__fd, __level, __opt)"}
  [^Int __fd, ^Int __level, ^Int __opt])

JOKER FUNC syscall.GetsockoptIPv6Mreq from syscall/syscall_linux.go:
(defn GetsockoptIPv6Mreq
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*IPv6Mreq, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(atom-of go.std.syscall/IPv6Mreq) Error]"
  {:added "1.0"
   :go "__getsockoptIPv6Mreq(__fd, __level, __opt)"}
  [^Int __fd, ^Int __level, ^Int __opt])

JOKER FUNC syscall.GetsockoptInet4Addr from syscall/syscall_linux.go:
(defn GetsockoptInet4Addr
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (value []byte, err error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__getsockoptInet4Addr(__fd, __level, __opt)"}
  [^Int __fd, ^Int __level, ^Int __opt])

JOKER FUNC syscall.GetsockoptInt from syscall/syscall_unix.go:
(defn GetsockoptInt
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (value int, err error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__getsockoptInt(__fd, __level, __opt)"}
  [^Int __fd, ^Int __level, ^Int __opt])

JOKER FUNC syscall.GetsockoptUcred from syscall/syscall_linux.go:
(defn GetsockoptUcred
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*Ucred, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(atom-of go.std.syscall/Ucred) Error]"
  {:added "1.0"
   :go "__getsockoptUcred(__fd, __level, __opt)"}
  [^Int __fd, ^Int __level, ^Int __opt])

JOKER FUNC syscall.Gettid from syscall/zsyscall_linux_amd64.go:
(defn ^"Int" Gettid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Gettid()"}
  [])

JOKER FUNC syscall.Gettimeofday from syscall/syscall_linux_amd64.go:
(defn ^"Error" Gettimeofday
  "Go input arguments: (tv *Timeval)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.syscall/Timeval) tv]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Gettimeofday(__tv)"}
  [^syscall/Timeval __tv])

JOKER FUNC syscall.Getuid from syscall/zsyscall_linux_amd64.go:
(defn ^"Int" Getuid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getuid()"}
  [])

JOKER FUNC syscall.Getwd from syscall/syscall_linux.go:
(defn Getwd
  "Go return type: (wd string, err error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__getwd()"}
  [])

JOKER FUNC syscall.Getxattr from syscall/zsyscall_linux_amd64.go:
;; (defn Getxattr
;;   "Go input arguments: (path string, attr string, dest []byte)\n\nGo return type: (sz int, err error)\n\nJoker input arguments: [^String path, ^String attr, ^(vector-of Int) dest]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__getxattr(__path, __attr, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__dest)))"}
;;   [^String __path, ^String __attr, ^Object __dest])

JOKER FUNC syscall.InotifyAddWatch from syscall/zsyscall_linux_amd64.go:
(defn InotifyAddWatch
  "Go input arguments: (fd int, pathname string, mask uint32)\n\nGo return type: (watchdesc int, err error)\n\nJoker input arguments: [^Int fd, ^String pathname, ^Number mask]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__inotifyAddWatch(__fd, __pathname, __mask)"}
  [^Int __fd, ^String __pathname, ^UInt32 __mask])

JOKER FUNC syscall.InotifyInit from syscall/zsyscall_linux_amd64.go:
(defn InotifyInit
  "Go return type: (fd int, err error)\n\nJoker input arguments: []\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__inotifyInit()"}
  [])

JOKER FUNC syscall.InotifyInit1 from syscall/zsyscall_linux_amd64.go:
(defn InotifyInit1
  "Go input arguments: (flags int)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^Int flags]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__inotifyInit1(__flags)"}
  [^Int __flags])

JOKER FUNC syscall.InotifyRmWatch from syscall/zsyscall_linux_amd64.go:
(defn InotifyRmWatch
  "Go input arguments: (fd int, watchdesc uint32)\n\nGo return type: (success int, err error)\n\nJoker input arguments: [^Int fd, ^Number watchdesc]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__inotifyRmWatch(__fd, __watchdesc)"}
  [^Int __fd, ^UInt32 __watchdesc])

JOKER FUNC syscall.Ioperm from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Ioperm
  "Go input arguments: (from int, num int, on int)\n\nGo return type: error\n\nJoker input arguments: [^Int from, ^Int num, ^Int on]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Ioperm(__from, __num, __on)"}
  [^Int __from, ^Int __num, ^Int __on])

JOKER FUNC syscall.Iopl from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Iopl
  "Go input arguments: (level int)\n\nGo return type: error\n\nJoker input arguments: [^Int level]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Iopl(__level)"}
  [^Int __level])

JOKER FUNC syscall.Kill from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Kill
  "Go input arguments: (pid int, sig Signal)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^go.std.syscall/Signal sig]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Kill(__pid, *__sig)"}
  [^Int __pid, ^syscall/Signal __sig])

JOKER FUNC syscall.Klogctl from syscall/zsyscall_linux_amd64.go:
;; (defn Klogctl
;;   "Go input arguments: (typ int, buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int typ, ^(vector-of Int) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__klogctl(__typ, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__buf)))"}
;;   [^Int __typ, ^Object __buf])

JOKER FUNC syscall.Lchown from syscall/syscall_linux_amd64.go:
(defn ^"Error" Lchown
  "Go input arguments: (path string, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Lchown(__path, __uid, __gid)"}
  [^String __path, ^Int __uid, ^Int __gid])

JOKER FUNC syscall.Link from syscall/syscall_linux.go:
(defn ^"Error" Link
  "Go input arguments: (oldpath string, newpath string)\n\nGo return type: error\n\nJoker input arguments: [^String oldpath, ^String newpath]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Link(__oldpath, __newpath)"}
  [^String __oldpath, ^String __newpath])

JOKER FUNC syscall.Listen from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Listen
  "Go input arguments: (s int, n int)\n\nGo return type: error\n\nJoker input arguments: [^Int s, ^Int n]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Listen(__s, __n)"}
  [^Int __s, ^Int __n])

JOKER FUNC syscall.Listxattr from syscall/zsyscall_linux_amd64.go:
;; (defn Listxattr
;;   "Go input arguments: (path string, dest []byte)\n\nGo return type: (sz int, err error)\n\nJoker input arguments: [^String path, ^(vector-of Int) dest]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__listxattr(__path, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__dest)))"}
;;   [^String __path, ^Object __dest])

JOKER FUNC syscall.LsfJump from syscall/lsf_linux.go:
(defn LsfJump
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (code int, k int, jt int, jf int)\n\nGo return type: *SockFilter\n\nJoker input arguments: [^Int code, ^Int k, ^Int jt, ^Int jf]\n\nJoker return type: (atom-of go.std.syscall/SockFilter)"
  {:added "1.0"
   :go "__lsfJump(__code, __k, __jt, __jf)"}
  [^Int __code, ^Int __k, ^Int __jt, ^Int __jf])

JOKER FUNC syscall.LsfSocket from syscall/lsf_linux.go:
(defn LsfSocket
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (ifindex int, proto int)\n\nGo return type: (int, error)\n\nJoker input arguments: [^Int ifindex, ^Int proto]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__lsfSocket(__ifindex, __proto)"}
  [^Int __ifindex, ^Int __proto])

JOKER FUNC syscall.LsfStmt from syscall/lsf_linux.go:
(defn LsfStmt
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (code int, k int)\n\nGo return type: *SockFilter\n\nJoker input arguments: [^Int code, ^Int k]\n\nJoker return type: (atom-of go.std.syscall/SockFilter)"
  {:added "1.0"
   :go "__lsfStmt(__code, __k)"}
  [^Int __code, ^Int __k])

JOKER FUNC syscall.Lstat from syscall/syscall_linux_amd64.go:
(defn ^"Error" Lstat
  "Go input arguments: (path string, stat *Stat_t)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(atom-of go.std.syscall/Stat_t) stat]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Lstat(__path, __stat)"}
  [^String __path, ^syscall/Stat_t __stat])

JOKER FUNC syscall.Madvise from syscall/zsyscall_linux_amd64.go:
;; (defn ^"Error" Madvise
;;   "Go input arguments: (b []byte, advice int)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) b, ^Int advice]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Madvise(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), __advice)"}
;;   [^Object __b, ^Int __advice])

JOKER FUNC syscall.Mkdir from syscall/syscall_linux.go:
(defn ^"Error" Mkdir
  "Go input arguments: (path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Number mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mkdir(__path, __mode)"}
  [^String __path, ^UInt32 __mode])

JOKER FUNC syscall.Mkdirat from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Mkdirat
  "Go input arguments: (dirfd int, path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^Int dirfd, ^String path, ^Number mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mkdirat(__dirfd, __path, __mode)"}
  [^Int __dirfd, ^String __path, ^UInt32 __mode])

JOKER FUNC syscall.Mkfifo from syscall/syscall_linux.go:
(defn ^"Error" Mkfifo
  "Go input arguments: (path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Number mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mkfifo(__path, __mode)"}
  [^String __path, ^UInt32 __mode])

JOKER FUNC syscall.Mknod from syscall/syscall_linux.go:
(defn ^"Error" Mknod
  "Go input arguments: (path string, mode uint32, dev int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Number mode, ^Int dev]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mknod(__path, __mode, __dev)"}
  [^String __path, ^UInt32 __mode, ^Int __dev])

JOKER FUNC syscall.Mknodat from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Mknodat
  "Go input arguments: (dirfd int, path string, mode uint32, dev int)\n\nGo return type: error\n\nJoker input arguments: [^Int dirfd, ^String path, ^Number mode, ^Int dev]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mknodat(__dirfd, __path, __mode, __dev)"}
  [^Int __dirfd, ^String __path, ^UInt32 __mode, ^Int __dev])

JOKER FUNC syscall.Mlock from syscall/zsyscall_linux_amd64.go:
;; (defn ^"Error" Mlock
;;   "Go input arguments: (b []byte)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) b]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Mlock(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))"}
;;   [^Object __b])

JOKER FUNC syscall.Mlockall from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Mlockall
  "Go input arguments: (flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mlockall(__flags)"}
  [^Int __flags])

JOKER FUNC syscall.Mmap from syscall/syscall_linux.go:
(defn Mmap
  "Go input arguments: (fd int, offset int64, length int, prot int, flags int)\n\nGo return type: (data []byte, err error)\n\nJoker input arguments: [^Int fd, ^Number offset, ^Int length, ^Int prot, ^Int flags]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__mmap(__fd, __offset, __length, __prot, __flags)"}
  [^Int __fd, ^Int64 __offset, ^Int __length, ^Int __prot, ^Int __flags])

JOKER FUNC syscall.Mount from syscall/syscall_linux.go:
(defn ^"Error" Mount
  "Go input arguments: (source string, target string, fstype string, flags uintptr, data string)\n\nGo return type: error\n\nJoker input arguments: [^String source, ^String target, ^String fstype, ^Number flags, ^String data]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mount(__source, __target, __fstype, __flags, __data)"}
  [^String __source, ^String __target, ^String __fstype, ^UIntPtr __flags, ^String __data])

JOKER FUNC syscall.Mprotect from syscall/zsyscall_linux_amd64.go:
;; (defn ^"Error" Mprotect
;;   "Go input arguments: (b []byte, prot int)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) b, ^Int prot]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Mprotect(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), __prot)"}
;;   [^Object __b, ^Int __prot])

JOKER FUNC syscall.Munlock from syscall/zsyscall_linux_amd64.go:
;; (defn ^"Error" Munlock
;;   "Go input arguments: (b []byte)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) b]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Munlock(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))"}
;;   [^Object __b])

JOKER FUNC syscall.Munlockall from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Munlockall
  "Go return type: error\n\nJoker input arguments: []\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Munlockall()"}
  [])

JOKER FUNC syscall.Munmap from syscall/syscall_linux.go:
;; (defn ^"Error" Munmap
;;   "Go input arguments: (b []byte)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) b]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Munmap(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))"}
;;   [^Object __b])

JOKER FUNC syscall.Nanosleep from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Nanosleep
  "Go input arguments: (time *Timespec, leftover *Timespec)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.syscall/Timespec) time, ^(atom-of go.std.syscall/Timespec) leftover]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Nanosleep(__time, __leftover)"}
  [^syscall/Timespec __time, ^syscall/Timespec __leftover])

JOKER FUNC syscall.NetlinkRIB from syscall/netlink_linux.go:
(defn NetlinkRIB
  "NetlinkRIB returns routing information base, as known as RIB, which\nconsists of network facility information, states and parameters.\n\nGo input arguments: (proto int, family int)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^Int proto, ^Int family]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__netlinkRIB(__proto, __family)"}
  [^Int __proto, ^Int __family])

JOKER FUNC syscall.NsecToTimespec from syscall/timestruct.go:
(defn NsecToTimespec
  "NsecToTimespec takes a number of nanoseconds since the Unix epoch\nand returns the corresponding Timespec value.\n\nGo input arguments: (nsec int64)\n\nGo return type: Timespec\n\nJoker input arguments: [^Number nsec]\n\nJoker return type: go.std.syscall/Timespec"
  {:added "1.0"
   :go "__nsecToTimespec(__nsec)"}
  [^Int64 __nsec])

JOKER FUNC syscall.NsecToTimeval from syscall/timestruct.go:
(defn NsecToTimeval
  "NsecToTimeval takes a number of nanoseconds since the Unix epoch\nand returns the corresponding Timeval value.\n\nGo input arguments: (nsec int64)\n\nGo return type: Timeval\n\nJoker input arguments: [^Number nsec]\n\nJoker return type: go.std.syscall/Timeval"
  {:added "1.0"
   :go "__nsecToTimeval(__nsec)"}
  [^Int64 __nsec])

JOKER FUNC syscall.Open from syscall/syscall_linux.go:
(defn Open
  "Go input arguments: (path string, mode int, perm uint32)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^String path, ^Int mode, ^Number perm]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__open(__path, __mode, __perm)"}
  [^String __path, ^Int __mode, ^UInt32 __perm])

JOKER FUNC syscall.Openat from syscall/syscall_linux.go:
(defn Openat
  "Go input arguments: (dirfd int, path string, flags int, mode uint32)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^Int dirfd, ^String path, ^Int flags, ^Number mode]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__openat(__dirfd, __path, __flags, __mode)"}
  [^Int __dirfd, ^String __path, ^Int __flags, ^UInt32 __mode])

JOKER FUNC syscall.ParseDirent from syscall/dirent.go:
;; (defn ParseDirent
;;   "ParseDirent parses up to max directory entries in buf,\nappending the names to names. It returns the number of\nbytes consumed from buf, the number of entries added\nto names, and the new names slice.\n\nGo input arguments: (buf []byte, max int, names []string)\n\nGo return type: (consumed int, count int, newnames []string)\n\nJoker input arguments: [^(vector-of Int) buf, ^Int max, ^(vector-of String) names]\n\nJoker return type: [Int Int (vector-of String)]"
;;   {:added "1.0"
;;    :go "__parseDirent(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__buf)), __max, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(__names)))"}
;;   [^Object __buf, ^Int __max, ^Object __names])

JOKER FUNC syscall.ParseNetlinkMessage from syscall/netlink_linux.go:
;; (defn ParseNetlinkMessage
;;   "ParseNetlinkMessage parses b as an array of netlink messages and\nreturns the slice containing the NetlinkMessage structures.\n\nGo input arguments: (b []byte)\n\nGo return type: ([]NetlinkMessage, error)\n\nJoker input arguments: [^(vector-of Int) b]\n\nJoker return type: [(vector-of go.std.syscall/NetlinkMessage) Error]"
;;   {:added "1.0"
;;    :go "__parseNetlinkMessage(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))"}
;;   [^Object __b])

JOKER FUNC syscall.ParseNetlinkRouteAttr from syscall/netlink_linux.go:
(defn ParseNetlinkRouteAttr
  "ParseNetlinkRouteAttr parses m's payload as an array of netlink\nroute attributes and returns the slice containing the\nNetlinkRouteAttr structures.\n\nGo input arguments: (m *NetlinkMessage)\n\nGo return type: ([]NetlinkRouteAttr, error)\n\nJoker input arguments: [^(atom-of go.std.syscall/NetlinkMessage) m]\n\nJoker return type: [(vector-of go.std.syscall/NetlinkRouteAttr) Error]"
  {:added "1.0"
   :go "__parseNetlinkRouteAttr(__m)"}
  [^syscall/NetlinkMessage __m])

JOKER FUNC syscall.ParseSocketControlMessage from syscall/sockcmsg_unix.go:
;; (defn ParseSocketControlMessage
;;   "ParseSocketControlMessage parses b as an array of socket control\nmessages.\n\nGo input arguments: (b []byte)\n\nGo return type: ([]SocketControlMessage, error)\n\nJoker input arguments: [^(vector-of Int) b]\n\nJoker return type: [(vector-of go.std.syscall/SocketControlMessage) Error]"
;;   {:added "1.0"
;;    :go "__parseSocketControlMessage(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))"}
;;   [^Object __b])

JOKER FUNC syscall.ParseUnixCredentials from syscall/sockcmsg_linux.go:
(defn ParseUnixCredentials
  "ParseUnixCredentials decodes a socket control message that contains\ncredentials in a Ucred structure. To receive such a message, the\nSO_PASSCRED option must be enabled on the socket.\n\nGo input arguments: (m *SocketControlMessage)\n\nGo return type: (*Ucred, error)\n\nJoker input arguments: [^(atom-of go.std.syscall/SocketControlMessage) m]\n\nJoker return type: [(atom-of go.std.syscall/Ucred) Error]"
  {:added "1.0"
   :go "__parseUnixCredentials(__m)"}
  [^syscall/SocketControlMessage __m])

JOKER FUNC syscall.ParseUnixRights from syscall/sockcmsg_unix.go:
(defn ParseUnixRights
  "ParseUnixRights decodes a socket control message that contains an\ninteger array of open file descriptors from another process.\n\nGo input arguments: (m *SocketControlMessage)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^(atom-of go.std.syscall/SocketControlMessage) m]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__parseUnixRights(__m)"}
  [^syscall/SocketControlMessage __m])

JOKER FUNC syscall.Pause from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Pause
  "Go return type: error\n\nJoker input arguments: []\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Pause()"}
  [])

JOKER FUNC syscall.Pipe from syscall/syscall_linux_amd64.go:
;; (defn ^"Error" Pipe
;;   "Go input arguments: (p []int)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) p]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Pipe(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfint(__p)))"}
;;   [^Object __p])

JOKER FUNC syscall.Pipe2 from syscall/syscall_linux_amd64.go:
;; (defn ^"Error" Pipe2
;;   "Go input arguments: (p []int, flags int)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) p, ^Int flags]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Pipe2(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfint(__p)), __flags)"}
;;   [^Object __p, ^Int __flags])

JOKER FUNC syscall.PivotRoot from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" PivotRoot
  "Go input arguments: (newroot string, putold string)\n\nGo return type: error\n\nJoker input arguments: [^String newroot, ^String putold]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PivotRoot(__newroot, __putold)"}
  [^String __newroot, ^String __putold])

JOKER FUNC syscall.Pread from syscall/zsyscall_linux_amd64.go:
;; (defn Pread
;;   "Go input arguments: (fd int, p []byte, offset int64)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Int) p, ^Number offset]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__pread(__fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)), __offset)"}
;;   [^Int __fd, ^Object __p, ^Int64 __offset])

JOKER FUNC syscall.PtraceAttach from syscall/syscall_linux.go:
(defn ^"Error" PtraceAttach
  "Go input arguments: (pid int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceAttach(__pid)"}
  [^Int __pid])

JOKER FUNC syscall.PtraceCont from syscall/syscall_linux.go:
(defn ^"Error" PtraceCont
  "Go input arguments: (pid int, signal int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^Int signal]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceCont(__pid, __signal)"}
  [^Int __pid, ^Int __signal])

JOKER FUNC syscall.PtraceDetach from syscall/syscall_linux.go:
(defn ^"Error" PtraceDetach
  "Go input arguments: (pid int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceDetach(__pid)"}
  [^Int __pid])

JOKER FUNC syscall.PtraceGetEventMsg from syscall/syscall_linux.go:
(defn PtraceGetEventMsg
  "Go input arguments: (pid int)\n\nGo return type: (msg uint, err error)\n\nJoker input arguments: [^Int pid]\n\nJoker return type: [Number Error]"
  {:added "1.0"
   :go "__ptraceGetEventMsg(__pid)"}
  [^Int __pid])

JOKER FUNC syscall.PtraceGetRegs from syscall/syscall_linux.go:
(defn ^"Error" PtraceGetRegs
  "Go input arguments: (pid int, regsout *PtraceRegs)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^(atom-of go.std.syscall/PtraceRegs) regsout]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceGetRegs(__pid, __regsout)"}
  [^Int __pid, ^syscall/PtraceRegs __regsout])

JOKER FUNC syscall.PtracePeekData from syscall/syscall_linux.go:
;; (defn PtracePeekData
;;   "Go input arguments: (pid int, addr uintptr, out []byte)\n\nGo return type: (count int, err error)\n\nJoker input arguments: [^Int pid, ^Number addr, ^(vector-of Int) out]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__ptracePeekData(__pid, __addr, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__out)))"}
;;   [^Int __pid, ^UIntPtr __addr, ^Object __out])

JOKER FUNC syscall.PtracePeekText from syscall/syscall_linux.go:
;; (defn PtracePeekText
;;   "Go input arguments: (pid int, addr uintptr, out []byte)\n\nGo return type: (count int, err error)\n\nJoker input arguments: [^Int pid, ^Number addr, ^(vector-of Int) out]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__ptracePeekText(__pid, __addr, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__out)))"}
;;   [^Int __pid, ^UIntPtr __addr, ^Object __out])

JOKER FUNC syscall.PtracePokeData from syscall/syscall_linux.go:
;; (defn PtracePokeData
;;   "Go input arguments: (pid int, addr uintptr, data []byte)\n\nGo return type: (count int, err error)\n\nJoker input arguments: [^Int pid, ^Number addr, ^(vector-of Int) data]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__ptracePokeData(__pid, __addr, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)))"}
;;   [^Int __pid, ^UIntPtr __addr, ^Object __data])

JOKER FUNC syscall.PtracePokeText from syscall/syscall_linux.go:
;; (defn PtracePokeText
;;   "Go input arguments: (pid int, addr uintptr, data []byte)\n\nGo return type: (count int, err error)\n\nJoker input arguments: [^Int pid, ^Number addr, ^(vector-of Int) data]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__ptracePokeText(__pid, __addr, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)))"}
;;   [^Int __pid, ^UIntPtr __addr, ^Object __data])

JOKER FUNC syscall.PtraceSetOptions from syscall/syscall_linux.go:
(defn ^"Error" PtraceSetOptions
  "Go input arguments: (pid int, options int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^Int options]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceSetOptions(__pid, __options)"}
  [^Int __pid, ^Int __options])

JOKER FUNC syscall.PtraceSetRegs from syscall/syscall_linux.go:
(defn ^"Error" PtraceSetRegs
  "Go input arguments: (pid int, regs *PtraceRegs)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^(atom-of go.std.syscall/PtraceRegs) regs]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceSetRegs(__pid, __regs)"}
  [^Int __pid, ^syscall/PtraceRegs __regs])

JOKER FUNC syscall.PtraceSingleStep from syscall/syscall_linux.go:
(defn ^"Error" PtraceSingleStep
  "Go input arguments: (pid int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceSingleStep(__pid)"}
  [^Int __pid])

JOKER FUNC syscall.PtraceSyscall from syscall/syscall_linux.go:
(defn ^"Error" PtraceSyscall
  "Go input arguments: (pid int, signal int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^Int signal]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceSyscall(__pid, __signal)"}
  [^Int __pid, ^Int __signal])

JOKER FUNC syscall.Pwrite from syscall/zsyscall_linux_amd64.go:
;; (defn Pwrite
;;   "Go input arguments: (fd int, p []byte, offset int64)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Int) p, ^Number offset]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__pwrite(__fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)), __offset)"}
;;   [^Int __fd, ^Object __p, ^Int64 __offset])

JOKER FUNC syscall.RawSyscall from syscall/syscall_unix.go:
;; (defn RawSyscall
;;   "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr)\n\nGo return type: (r1 uintptr, r2 uintptr, err Errno)\n\nJoker input arguments: [^Number trap, ^Number a1, ^Number a2, ^Number a3]\n\nJoker return type: [Number Number go.std.syscall/Errno]"
;;   {:added "1.0"
;;    :go "__rawSyscall(__trap, __a1, __a2, __a3)"}
;;   [^UIntPtr __trap, ^UIntPtr __a1, ^UIntPtr __a2, ^UIntPtr __a3])

JOKER FUNC syscall.RawSyscall6 from syscall/syscall_unix.go:
;; (defn RawSyscall6
;;   "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr)\n\nGo return type: (r1 uintptr, r2 uintptr, err Errno)\n\nJoker input arguments: [^Number trap, ^Number a1, ^Number a2, ^Number a3, ^Number a4, ^Number a5, ^Number a6]\n\nJoker return type: [Number Number go.std.syscall/Errno]"
;;   {:added "1.0"
;;    :go "__rawSyscall6(__trap, __a1, __a2, __a3, __a4, __a5, __a6)"}
;;   [^UIntPtr __trap, ^UIntPtr __a1, ^UIntPtr __a2, ^UIntPtr __a3, ^UIntPtr __a4, ^UIntPtr __a5, ^UIntPtr __a6])

JOKER FUNC syscall.Read from syscall/syscall_unix.go:
;; (defn Read
;;   "Go input arguments: (fd int, p []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Int) p]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__read(__fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)))"}
;;   [^Int __fd, ^Object __p])

JOKER FUNC syscall.ReadDirent from syscall/syscall_linux.go:
;; (defn ReadDirent
;;   "Go input arguments: (fd int, buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Int) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__readDirent(__fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__buf)))"}
;;   [^Int __fd, ^Object __buf])

JOKER FUNC syscall.Readlink from syscall/syscall_linux.go:
;; (defn Readlink
;;   "Go input arguments: (path string, buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String path, ^(vector-of Int) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__readlink(__path, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__buf)))"}
;;   [^String __path, ^Object __buf])

JOKER FUNC syscall.Reboot from syscall/syscall_linux.go:
(defn ^"Error" Reboot
  "Go input arguments: (cmd int)\n\nGo return type: error\n\nJoker input arguments: [^Int cmd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Reboot(__cmd)"}
  [^Int __cmd])

JOKER FUNC syscall.Recvfrom from syscall/syscall_unix.go:
;; (defn Recvfrom
;;   "Go input arguments: (fd int, p []byte, flags int)\n\nGo return type: (n int, from Sockaddr, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Int) p, ^Int flags]\n\nJoker return type: [Int go.std.syscall/Sockaddr Error]"
;;   {:added "1.0"
;;    :go "__recvfrom(__fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)), __flags)"}
;;   [^Int __fd, ^Object __p, ^Int __flags])

JOKER FUNC syscall.Recvmsg from syscall/syscall_linux.go:
;; (defn Recvmsg
;;   "Go input arguments: (fd int, p []byte, oob []byte, flags int)\n\nGo return type: (n int, oobn int, recvflags int, from Sockaddr, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Int) p, ^(vector-of Int) oob, ^Int flags]\n\nJoker return type: [Int Int Int go.std.syscall/Sockaddr Error]"
;;   {:added "1.0"
;;    :go "__recvmsg(__fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__oob)), __flags)"}
;;   [^Int __fd, ^Object __p, ^Object __oob, ^Int __flags])

JOKER FUNC syscall.Removexattr from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Removexattr
  "Go input arguments: (path string, attr string)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^String attr]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Removexattr(__path, __attr)"}
  [^String __path, ^String __attr])

JOKER FUNC syscall.Rename from syscall/syscall_linux.go:
(defn ^"Error" Rename
  "Go input arguments: (oldpath string, newpath string)\n\nGo return type: error\n\nJoker input arguments: [^String oldpath, ^String newpath]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Rename(__oldpath, __newpath)"}
  [^String __oldpath, ^String __newpath])

JOKER FUNC syscall.Renameat from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Renameat
  "Go input arguments: (olddirfd int, oldpath string, newdirfd int, newpath string)\n\nGo return type: error\n\nJoker input arguments: [^Int olddirfd, ^String oldpath, ^Int newdirfd, ^String newpath]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Renameat(__olddirfd, __oldpath, __newdirfd, __newpath)"}
  [^Int __olddirfd, ^String __oldpath, ^Int __newdirfd, ^String __newpath])

JOKER FUNC syscall.Rmdir from syscall/syscall_linux.go:
(defn ^"Error" Rmdir
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Rmdir(__path)"}
  [^String __path])

JOKER FUNC syscall.Seek from syscall/zsyscall_linux_amd64.go:
(defn Seek
  "Go input arguments: (fd int, offset int64, whence int)\n\nGo return type: (off int64, err error)\n\nJoker input arguments: [^Int fd, ^Number offset, ^Int whence]\n\nJoker return type: [Number Error]"
  {:added "1.0"
   :go "__seek(__fd, __offset, __whence)"}
  [^Int __fd, ^Int64 __offset, ^Int __whence])

JOKER FUNC syscall.Select from syscall/zsyscall_linux_amd64.go:
(defn Select
  "Go input arguments: (nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int nfd, ^(atom-of go.std.syscall/FdSet) r, ^(atom-of go.std.syscall/FdSet) w, ^(atom-of go.std.syscall/FdSet) e, ^(atom-of go.std.syscall/Timeval) timeout]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__select(__nfd, __r, __w, __e, __timeout)"}
  [^Int __nfd, ^syscall/FdSet __r, ^syscall/FdSet __w, ^syscall/FdSet __e, ^syscall/Timeval __timeout])

JOKER FUNC syscall.Sendfile from syscall/syscall_unix.go:
;; (defn Sendfile
;;   "Go input arguments: (outfd int, infd int, offset *int64, count int)\n\nGo return type: (written int, err error)\n\nJoker input arguments: [^Int outfd, ^Int infd, ^(atom-of Number) offset, ^Int count]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__sendfile(__outfd, __infd, ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(__offset)), __count)"}
;;   [^Int __outfd, ^Int __infd, ^Object __offset, ^Int __count])

JOKER FUNC syscall.Sendmsg from syscall/syscall_linux.go:
;; (defn ^"Error" Sendmsg
;;   "Go input arguments: (fd int, p []byte, oob []byte, to Sockaddr, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(vector-of Int) p, ^(vector-of Int) oob, ^go.std.syscall/Sockaddr to, ^Int flags]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Sendmsg(__fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__oob)), *__to, __flags)"}
;;   [^Int __fd, ^Object __p, ^Object __oob, ^syscall/Sockaddr __to, ^Int __flags])

JOKER FUNC syscall.SendmsgN from syscall/syscall_linux.go:
;; (defn SendmsgN
;;   "Go input arguments: (fd int, p []byte, oob []byte, to Sockaddr, flags int)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Int) p, ^(vector-of Int) oob, ^go.std.syscall/Sockaddr to, ^Int flags]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__sendmsgN(__fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__oob)), *__to, __flags)"}
;;   [^Int __fd, ^Object __p, ^Object __oob, ^syscall/Sockaddr __to, ^Int __flags])

JOKER FUNC syscall.Sendto from syscall/syscall_unix.go:
;; (defn ^"Error" Sendto
;;   "Go input arguments: (fd int, p []byte, flags int, to Sockaddr)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(vector-of Int) p, ^Int flags, ^go.std.syscall/Sockaddr to]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Sendto(__fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)), __flags, *__to)"}
;;   [^Int __fd, ^Object __p, ^Int __flags, ^syscall/Sockaddr __to])

JOKER FUNC syscall.SetLsfPromisc from syscall/lsf_linux.go:
(defn ^"Error" SetLsfPromisc
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (name string, m bool)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^Boolean m]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetLsfPromisc(__name, __m)"}
  [^String __name, ^Boolean __m])

JOKER FUNC syscall.SetNonblock from syscall/exec_unix.go:
(defn ^"Error" SetNonblock
  "Go input arguments: (fd int, nonblocking bool)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Boolean nonblocking]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetNonblock(__fd, __nonblocking)"}
  [^Int __fd, ^Boolean __nonblocking])

JOKER FUNC syscall.Setdomainname from syscall/zsyscall_linux_amd64.go:
;; (defn ^"Error" Setdomainname
;;   "Go input arguments: (p []byte)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) p]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Setdomainname(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)))"}
;;   [^Object __p])

JOKER FUNC syscall.Setenv from syscall/env_unix.go:
(defn ^"Error" Setenv
  "Go input arguments: (key string, value string)\n\nGo return type: error\n\nJoker input arguments: [^String key, ^String value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setenv(__key, __value)"}
  [^String __key, ^String __value])

JOKER FUNC syscall.Setfsgid from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Setfsgid
  "Go input arguments: (gid int)\n\nGo return type: error\n\nJoker input arguments: [^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setfsgid(__gid)"}
  [^Int __gid])

JOKER FUNC syscall.Setfsuid from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Setfsuid
  "Go input arguments: (uid int)\n\nGo return type: error\n\nJoker input arguments: [^Int uid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setfsuid(__uid)"}
  [^Int __uid])

JOKER FUNC syscall.Setgid from syscall/syscall_linux.go:
(defn ^"Error" Setgid
  "Go input arguments: (gid int)\n\nGo return type: error\n\nJoker input arguments: [^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setgid(__gid)"}
  [^Int __gid])

JOKER FUNC syscall.Setgroups from syscall/syscall_linux.go:
;; (defn ^"Error" Setgroups
;;   "Go input arguments: (gids []int)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) gids]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Setgroups(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfint(__gids)))"}
;;   [^Object __gids])

JOKER FUNC syscall.Sethostname from syscall/zsyscall_linux_amd64.go:
;; (defn ^"Error" Sethostname
;;   "Go input arguments: (p []byte)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) p]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Sethostname(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)))"}
;;   [^Object __p])

JOKER FUNC syscall.Setpgid from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Setpgid
  "Go input arguments: (pid int, pgid int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^Int pgid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setpgid(__pid, __pgid)"}
  [^Int __pid, ^Int __pgid])

JOKER FUNC syscall.Setpriority from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Setpriority
  "Go input arguments: (which int, who int, prio int)\n\nGo return type: error\n\nJoker input arguments: [^Int which, ^Int who, ^Int prio]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setpriority(__which, __who, __prio)"}
  [^Int __which, ^Int __who, ^Int __prio])

JOKER FUNC syscall.Setregid from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Setregid
  "Go input arguments: (rgid int, egid int)\n\nGo return type: error\n\nJoker input arguments: [^Int rgid, ^Int egid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setregid(__rgid, __egid)"}
  [^Int __rgid, ^Int __egid])

JOKER FUNC syscall.Setresgid from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Setresgid
  "Go input arguments: (rgid int, egid int, sgid int)\n\nGo return type: error\n\nJoker input arguments: [^Int rgid, ^Int egid, ^Int sgid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setresgid(__rgid, __egid, __sgid)"}
  [^Int __rgid, ^Int __egid, ^Int __sgid])

JOKER FUNC syscall.Setresuid from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Setresuid
  "Go input arguments: (ruid int, euid int, suid int)\n\nGo return type: error\n\nJoker input arguments: [^Int ruid, ^Int euid, ^Int suid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setresuid(__ruid, __euid, __suid)"}
  [^Int __ruid, ^Int __euid, ^Int __suid])

JOKER FUNC syscall.Setreuid from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Setreuid
  "Go input arguments: (ruid int, euid int)\n\nGo return type: error\n\nJoker input arguments: [^Int ruid, ^Int euid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setreuid(__ruid, __euid)"}
  [^Int __ruid, ^Int __euid])

JOKER FUNC syscall.Setrlimit from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Setrlimit
  "Go input arguments: (resource int, rlim *Rlimit)\n\nGo return type: error\n\nJoker input arguments: [^Int resource, ^(atom-of go.std.syscall/Rlimit) rlim]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setrlimit(__resource, __rlim)"}
  [^Int __resource, ^syscall/Rlimit __rlim])

JOKER FUNC syscall.Setsid from syscall/zsyscall_linux_amd64.go:
(defn Setsid
  "Go return type: (pid int, err error)\n\nJoker input arguments: []\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__setsid()"}
  [])

JOKER FUNC syscall.SetsockoptByte from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptByte
  "Go input arguments: (fd int, level int, opt int, value byte)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^Int value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptByte(__fd, __level, __opt, __value)"}
  [^Int __fd, ^Int __level, ^Int __opt, ^Byte __value])

JOKER FUNC syscall.SetsockoptICMPv6Filter from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptICMPv6Filter
  "Go input arguments: (fd int, level int, opt int, filter *ICMPv6Filter)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/ICMPv6Filter) filter]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptICMPv6Filter(__fd, __level, __opt, __filter)"}
  [^Int __fd, ^Int __level, ^Int __opt, ^syscall/ICMPv6Filter __filter])

JOKER FUNC syscall.SetsockoptIPMreq from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptIPMreq
  "Go input arguments: (fd int, level int, opt int, mreq *IPMreq)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/IPMreq) mreq]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptIPMreq(__fd, __level, __opt, __mreq)"}
  [^Int __fd, ^Int __level, ^Int __opt, ^syscall/IPMreq __mreq])

JOKER FUNC syscall.SetsockoptIPMreqn from syscall/syscall_linux.go:
(defn ^"Error" SetsockoptIPMreqn
  "Go input arguments: (fd int, level int, opt int, mreq *IPMreqn)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/IPMreqn) mreq]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptIPMreqn(__fd, __level, __opt, __mreq)"}
  [^Int __fd, ^Int __level, ^Int __opt, ^syscall/IPMreqn __mreq])

JOKER FUNC syscall.SetsockoptIPv6Mreq from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptIPv6Mreq
  "Go input arguments: (fd int, level int, opt int, mreq *IPv6Mreq)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/IPv6Mreq) mreq]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptIPv6Mreq(__fd, __level, __opt, __mreq)"}
  [^Int __fd, ^Int __level, ^Int __opt, ^syscall/IPv6Mreq __mreq])

JOKER FUNC syscall.SetsockoptInet4Addr from syscall/syscall_unix.go:
;; (defn ^"Error" SetsockoptInet4Addr
;;   "Go input arguments: (fd int, level int, opt int, value []byte)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(vector-of Int) value]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptInet4Addr(__fd, __level, __opt, ABEND901(pre.go: specific-length arrays not supported: ConvertToArrayOfbyte(__value)))"}
;;   [^Int __fd, ^Int __level, ^Int __opt, ^Object __value])

JOKER FUNC syscall.SetsockoptInt from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptInt
  "Go input arguments: (fd int, level int, opt int, value int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^Int value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptInt(__fd, __level, __opt, __value)"}
  [^Int __fd, ^Int __level, ^Int __opt, ^Int __value])

JOKER FUNC syscall.SetsockoptLinger from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptLinger
  "Go input arguments: (fd int, level int, opt int, l *Linger)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/Linger) l]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptLinger(__fd, __level, __opt, __l)"}
  [^Int __fd, ^Int __level, ^Int __opt, ^syscall/Linger __l])

JOKER FUNC syscall.SetsockoptString from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptString
  "Go input arguments: (fd int, level int, opt int, s string)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^String s]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptString(__fd, __level, __opt, __s)"}
  [^Int __fd, ^Int __level, ^Int __opt, ^String __s])

JOKER FUNC syscall.SetsockoptTimeval from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptTimeval
  "Go input arguments: (fd int, level int, opt int, tv *Timeval)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/Timeval) tv]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptTimeval(__fd, __level, __opt, __tv)"}
  [^Int __fd, ^Int __level, ^Int __opt, ^syscall/Timeval __tv])

JOKER FUNC syscall.Settimeofday from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Settimeofday
  "Go input arguments: (tv *Timeval)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.syscall/Timeval) tv]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Settimeofday(__tv)"}
  [^syscall/Timeval __tv])

JOKER FUNC syscall.Setuid from syscall/syscall_linux.go:
(defn ^"Error" Setuid
  "Go input arguments: (uid int)\n\nGo return type: error\n\nJoker input arguments: [^Int uid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setuid(__uid)"}
  [^Int __uid])

JOKER FUNC syscall.Setxattr from syscall/zsyscall_linux_amd64.go:
;; (defn ^"Error" Setxattr
;;   "Go input arguments: (path string, attr string, data []byte, flags int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^String attr, ^(vector-of Int) data, ^Int flags]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Setxattr(__path, __attr, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)), __flags)"}
;;   [^String __path, ^String __attr, ^Object __data, ^Int __flags])

JOKER FUNC syscall.Shutdown from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Shutdown
  "Go input arguments: (fd int, how int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int how]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Shutdown(__fd, __how)"}
  [^Int __fd, ^Int __how])

JOKER FUNC syscall.SlicePtrFromStrings from syscall/exec_unix.go:
;; (defn SlicePtrFromStrings
;;   "SlicePtrFromStrings converts a slice of strings to a slice of\npointers to NUL-terminated byte arrays. If any string contains\na NUL byte, it returns (nil, EINVAL).\n\nGo input arguments: (ss []string)\n\nGo return type: ([]*byte, error)\n\nJoker input arguments: [^(vector-of String) ss]\n\nJoker return type: [(vector-of (atom-of Int)) Error]"
;;   {:added "1.0"
;;    :go "__slicePtrFromStrings(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(__ss)))"}
;;   [^Object __ss])

JOKER FUNC syscall.Socket from syscall/syscall_unix.go:
(defn Socket
  "Go input arguments: (domain int, typ int, proto int)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^Int domain, ^Int typ, ^Int proto]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__socket(__domain, __typ, __proto)"}
  [^Int __domain, ^Int __typ, ^Int __proto])

JOKER FUNC syscall.Socketpair from syscall/syscall_unix.go:
(defn Socketpair
  "Go input arguments: (domain int, typ int, proto int)\n\nGo return type: (fd []int, err error)\n\nJoker input arguments: [^Int domain, ^Int typ, ^Int proto]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__socketpair(__domain, __typ, __proto)"}
  [^Int __domain, ^Int __typ, ^Int __proto])

JOKER FUNC syscall.Splice from syscall/zsyscall_linux_amd64.go:
;; (defn Splice
;;   "Go input arguments: (rfd int, roff *int64, wfd int, woff *int64, len int, flags int)\n\nGo return type: (n int64, err error)\n\nJoker input arguments: [^Int rfd, ^(atom-of Number) roff, ^Int wfd, ^(atom-of Number) woff, ^Int len, ^Int flags]\n\nJoker return type: [Number Error]"
;;   {:added "1.0"
;;    :go "__splice(__rfd, ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(__roff)), __wfd, ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(__woff)), __len, __flags)"}
;;   [^Int __rfd, ^Object __roff, ^Int __wfd, ^Object __woff, ^Int __len, ^Int __flags])

JOKER FUNC syscall.StartProcess from syscall/exec_unix.go:
;; (defn StartProcess
;;   "StartProcess wraps ForkExec for package os.\n\nGo input arguments: (argv0 string, argv []string, attr *ProcAttr)\n\nGo return type: (pid int, handle uintptr, err error)\n\nJoker input arguments: [^String argv0, ^(vector-of String) argv, ^(atom-of go.std.syscall/ProcAttr) attr]\n\nJoker return type: [Int Number Error]"
;;   {:added "1.0"
;;    :go "__startProcess(__argv0, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(__argv)), __attr)"}
;;   [^String __argv0, ^Object __argv, ^syscall/ProcAttr __attr])

JOKER FUNC syscall.Stat from syscall/syscall_linux_amd64.go:
(defn ^"Error" Stat
  "Go input arguments: (path string, stat *Stat_t)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(atom-of go.std.syscall/Stat_t) stat]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Stat(__path, __stat)"}
  [^String __path, ^syscall/Stat_t __stat])

JOKER FUNC syscall.Statfs from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Statfs
  "Go input arguments: (path string, buf *Statfs_t)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(atom-of go.std.syscall/Statfs_t) buf]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Statfs(__path, __buf)"}
  [^String __path, ^syscall/Statfs_t __buf])

JOKER FUNC syscall.StringBytePtr from syscall/syscall.go:
(defn StringBytePtr
  "StringBytePtr returns a pointer to a NUL-terminated array of bytes.\nIf s contains a NUL byte this function panics instead of returning\nan error.\n\nDeprecated: Use BytePtrFromString instead.\n\nGo input arguments: (s string)\n\nGo return type: *byte\n\nJoker input arguments: [^String s]\n\nJoker return type: (atom-of Int)"
  {:added "1.0"
   :go "__stringBytePtr(__s)"}
  [^String __s])

JOKER FUNC syscall.StringByteSlice from syscall/syscall.go:
(defn StringByteSlice
  "StringByteSlice converts a string to a NUL-terminated []byte,\nIf s contains a NUL byte this function panics instead of\nreturning an error.\n\nDeprecated: Use ByteSliceFromString instead.\n\nGo input arguments: (s string)\n\nGo return type: []byte\n\nJoker input arguments: [^String s]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__stringByteSlice(__s)"}
  [^String __s])

JOKER FUNC syscall.StringSlicePtr from syscall/exec_unix.go:
;; (defn StringSlicePtr
;;   "StringSlicePtr converts a slice of strings to a slice of pointers\nto NUL-terminated byte arrays. If any string contains a NUL byte\nthis function panics instead of returning an error.\n\nDeprecated: Use SlicePtrFromStrings instead.\n\nGo input arguments: (ss []string)\n\nGo return type: []*byte\n\nJoker input arguments: [^(vector-of String) ss]\n\nJoker return type: (vector-of (atom-of Int))"
;;   {:added "1.0"
;;    :go "__stringSlicePtr(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(__ss)))"}
;;   [^Object __ss])

JOKER FUNC syscall.Symlink from syscall/syscall_linux.go:
(defn ^"Error" Symlink
  "Go input arguments: (oldpath string, newpath string)\n\nGo return type: error\n\nJoker input arguments: [^String oldpath, ^String newpath]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Symlink(__oldpath, __newpath)"}
  [^String __oldpath, ^String __newpath])

JOKER FUNC syscall.Sync from syscall/zsyscall_linux_amd64.go:
;; (defn Sync
;;   "Joker input arguments: []"
;;   {:added "1.0"
;;    :go "__sync()"}
;;   [])

JOKER FUNC syscall.SyncFileRange from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" SyncFileRange
  "Go input arguments: (fd int, off int64, n int64, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Number off, ^Number n, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SyncFileRange(__fd, __off, __n, __flags)"}
  [^Int __fd, ^Int64 __off, ^Int64 __n, ^Int __flags])

JOKER FUNC syscall.Syscall from syscall/syscall_unix.go:
;; (defn Syscall
;;   "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr)\n\nGo return type: (r1 uintptr, r2 uintptr, err Errno)\n\nJoker input arguments: [^Number trap, ^Number a1, ^Number a2, ^Number a3]\n\nJoker return type: [Number Number go.std.syscall/Errno]"
;;   {:added "1.0"
;;    :go "__syscall(__trap, __a1, __a2, __a3)"}
;;   [^UIntPtr __trap, ^UIntPtr __a1, ^UIntPtr __a2, ^UIntPtr __a3])

JOKER FUNC syscall.Syscall6 from syscall/syscall_unix.go:
;; (defn Syscall6
;;   "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr)\n\nGo return type: (r1 uintptr, r2 uintptr, err Errno)\n\nJoker input arguments: [^Number trap, ^Number a1, ^Number a2, ^Number a3, ^Number a4, ^Number a5, ^Number a6]\n\nJoker return type: [Number Number go.std.syscall/Errno]"
;;   {:added "1.0"
;;    :go "__syscall6(__trap, __a1, __a2, __a3, __a4, __a5, __a6)"}
;;   [^UIntPtr __trap, ^UIntPtr __a1, ^UIntPtr __a2, ^UIntPtr __a3, ^UIntPtr __a4, ^UIntPtr __a5, ^UIntPtr __a6])

JOKER FUNC syscall.Sysinfo from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Sysinfo
  "Go input arguments: (info *Sysinfo_t)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.syscall/Sysinfo_t) info]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Sysinfo(__info)"}
  [^syscall/Sysinfo_t __info])

JOKER FUNC syscall.Tee from syscall/zsyscall_linux_amd64.go:
(defn Tee
  "Go input arguments: (rfd int, wfd int, len int, flags int)\n\nGo return type: (n int64, err error)\n\nJoker input arguments: [^Int rfd, ^Int wfd, ^Int len, ^Int flags]\n\nJoker return type: [Number Error]"
  {:added "1.0"
   :go "__tee(__rfd, __wfd, __len, __flags)"}
  [^Int __rfd, ^Int __wfd, ^Int __len, ^Int __flags])

JOKER FUNC syscall.Tgkill from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Tgkill
  "Go input arguments: (tgid int, tid int, sig Signal)\n\nGo return type: error\n\nJoker input arguments: [^Int tgid, ^Int tid, ^go.std.syscall/Signal sig]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Tgkill(__tgid, __tid, *__sig)"}
  [^Int __tgid, ^Int __tid, ^syscall/Signal __sig])

JOKER FUNC syscall.Time from syscall/syscall_linux_amd64.go:
(defn Time
  "Go input arguments: (t *Time_t)\n\nGo return type: (tt Time_t, err error)\n\nJoker input arguments: [^(atom-of go.std.syscall/Time_t) t]\n\nJoker return type: [go.std.syscall/Time_t Error]"
  {:added "1.0"
   :go "__time(__t)"}
  [^syscall/Time_t __t])

JOKER FUNC syscall.Times from syscall/zsyscall_linux_amd64.go:
;; (defn Times
;;   "Go input arguments: (tms *Tms)\n\nGo return type: (ticks uintptr, err error)\n\nJoker input arguments: [^(atom-of go.std.syscall/Tms) tms]\n\nJoker return type: [Number Error]"
;;   {:added "1.0"
;;    :go "__times(__tms)"}
;;   [^syscall/Tms __tms])

JOKER FUNC syscall.TimespecToNsec from syscall/timestruct.go:
(defn TimespecToNsec
  "TimespecToNsec converts a Timespec value into a number of\nnanoseconds since the Unix epoch.\n\nGo input arguments: (ts Timespec)\n\nGo return type: int64\n\nJoker input arguments: [^go.std.syscall/Timespec ts]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__timespecToNsec(*__ts)"}
  [^syscall/Timespec __ts])

JOKER FUNC syscall.TimevalToNsec from syscall/timestruct.go:
(defn TimevalToNsec
  "TimevalToNsec converts a Timeval value into a number of nanoseconds\nsince the Unix epoch.\n\nGo input arguments: (tv Timeval)\n\nGo return type: int64\n\nJoker input arguments: [^go.std.syscall/Timeval tv]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__timevalToNsec(*__tv)"}
  [^syscall/Timeval __tv])

JOKER FUNC syscall.Truncate from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Truncate
  "Go input arguments: (path string, length int64)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Number length]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Truncate(__path, __length)"}
  [^String __path, ^Int64 __length])

JOKER FUNC syscall.Umask from syscall/zsyscall_linux_amd64.go:
(defn ^"Int" Umask
  "Go input arguments: (mask int)\n\nGo return type: int\n\nJoker input arguments: [^Int mask]\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Umask(__mask)"}
  [^Int __mask])

JOKER FUNC syscall.Uname from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Uname
  "Go input arguments: (buf *Utsname)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.syscall/Utsname) buf]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Uname(__buf)"}
  [^syscall/Utsname __buf])

JOKER FUNC syscall.UnixCredentials from syscall/sockcmsg_linux.go:
(defn UnixCredentials
  "UnixCredentials encodes credentials into a socket control message\nfor sending to another process. This can be used for\nauthentication.\n\nGo input arguments: (ucred *Ucred)\n\nGo return type: []byte\n\nJoker input arguments: [^(atom-of go.std.syscall/Ucred) ucred]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__unixCredentials(__ucred)"}
  [^syscall/Ucred __ucred])

JOKER FUNC syscall.UnixRights from syscall/sockcmsg_unix.go:
;; (defn UnixRights
;;   "UnixRights encodes a set of open file descriptors into a socket\ncontrol message for sending to another process.\n\nGo input arguments: (fds ...int)\n\nGo return type: []byte\n\nJoker input arguments: [^(ellipsis-somehow Int) fds]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__unixRights(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHaint(__fds)))"}
;;   [^Int __fds])

JOKER FUNC syscall.Unlink from syscall/syscall_linux.go:
(defn ^"Error" Unlink
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unlink(__path)"}
  [^String __path])

JOKER FUNC syscall.Unlinkat from syscall/syscall_linux.go:
(defn ^"Error" Unlinkat
  "Go input arguments: (dirfd int, path string)\n\nGo return type: error\n\nJoker input arguments: [^Int dirfd, ^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unlinkat(__dirfd, __path)"}
  [^Int __dirfd, ^String __path])

JOKER FUNC syscall.Unmount from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Unmount
  "Go input arguments: (target string, flags int)\n\nGo return type: error\n\nJoker input arguments: [^String target, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unmount(__target, __flags)"}
  [^String __target, ^Int __flags])

JOKER FUNC syscall.Unsetenv from syscall/env_unix.go:
(defn ^"Error" Unsetenv
  "Go input arguments: (key string)\n\nGo return type: error\n\nJoker input arguments: [^String key]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unsetenv(__key)"}
  [^String __key])

JOKER FUNC syscall.Unshare from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Unshare
  "Go input arguments: (flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unshare(__flags)"}
  [^Int __flags])

JOKER FUNC syscall.Ustat from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Ustat
  "Go input arguments: (dev int, ubuf *Ustat_t)\n\nGo return type: error\n\nJoker input arguments: [^Int dev, ^(atom-of go.std.syscall/Ustat_t) ubuf]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Ustat(__dev, __ubuf)"}
  [^Int __dev, ^syscall/Ustat_t __ubuf])

JOKER FUNC syscall.Utime from syscall/zsyscall_linux_amd64.go:
(defn ^"Error" Utime
  "Go input arguments: (path string, buf *Utimbuf)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(atom-of go.std.syscall/Utimbuf) buf]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Utime(__path, __buf)"}
  [^String __path, ^syscall/Utimbuf __buf])

JOKER FUNC syscall.Utimes from syscall/syscall_linux.go:
;; (defn ^"Error" Utimes
;;   "Go input arguments: (path string, tv []Timeval)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(vector-of go.std.syscall/Timeval) tv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Utimes(__path, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_syscall.Timeval(*__tv)))"}
;;   [^String __path, ^Object __tv])

JOKER FUNC syscall.UtimesNano from syscall/syscall_linux.go:
;; (defn ^"Error" UtimesNano
;;   "Go input arguments: (path string, ts []Timespec)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(vector-of go.std.syscall/Timespec) ts]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.UtimesNano(__path, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_syscall.Timespec(*__ts)))"}
;;   [^String __path, ^Object __ts])

JOKER FUNC syscall.Wait4 from syscall/syscall_linux.go:
(defn Wait4
  "Go input arguments: (pid int, wstatus *WaitStatus, options int, rusage *Rusage)\n\nGo return type: (wpid int, err error)\n\nJoker input arguments: [^Int pid, ^(atom-of go.std.syscall/WaitStatus) wstatus, ^Int options, ^(atom-of go.std.syscall/Rusage) rusage]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__wait4(__pid, __wstatus, __options, __rusage)"}
  [^Int __pid, ^syscall/WaitStatus __wstatus, ^Int __options, ^syscall/Rusage __rusage])

JOKER FUNC syscall.Write from syscall/syscall_unix.go:
;; (defn Write
;;   "Go input arguments: (fd int, p []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Int) p]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__write(__fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)))"}
;;   [^Int __fd, ^Object __p])

JOKER TYPE go.std.syscall/Cmsghdr:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Cmsghdr"}
  Cmsghdr)

JOKER TYPE go.std.syscall/Conn:
(def
  ^{:doc "Conn is implemented by some types in the net and os packages to provide\naccess to the underlying file descriptor or handle.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Conn"}
  Conn)

JOKER TYPE go.std.syscall/Credential:
(def
  ^{:doc "Credential holds user and group identities to be assumed\nby a child process started by StartProcess.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Credential"}
  Credential)

JOKER TYPE go.std.syscall/Dirent:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Dirent"}
  Dirent)

JOKER TYPE go.std.syscall/EpollEvent:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_EpollEvent"}
  EpollEvent)

JOKER TYPE go.std.syscall/Errno:
(def
  ^{:doc "An Errno is an unsigned number describing an error condition.\nIt implements the error interface. The zero Errno is by convention\na non-error, so code to convert from Errno to error should use:\n\terr = nil\n\tif errno != 0 {\n\t\terr = errno\n\t}\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Errno"}
  Errno)

JOKER TYPE go.std.syscall/FdSet:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_FdSet"}
  FdSet)

JOKER TYPE go.std.syscall/Flock_t:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Flock_t"}
  Flock_t)

JOKER TYPE go.std.syscall/Fsid:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Fsid"}
  Fsid)

JOKER TYPE go.std.syscall/ICMPv6Filter:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_ICMPv6Filter"}
  ICMPv6Filter)

JOKER TYPE go.std.syscall/IPMreq:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_IPMreq"}
  IPMreq)

JOKER TYPE go.std.syscall/IPMreqn:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_IPMreqn"}
  IPMreqn)

JOKER TYPE go.std.syscall/IPv6MTUInfo:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_IPv6MTUInfo"}
  IPv6MTUInfo)

JOKER TYPE go.std.syscall/IPv6Mreq:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_IPv6Mreq"}
  IPv6Mreq)

JOKER TYPE go.std.syscall/IfAddrmsg:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_IfAddrmsg"}
  IfAddrmsg)

JOKER TYPE go.std.syscall/IfInfomsg:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_IfInfomsg"}
  IfInfomsg)

JOKER TYPE go.std.syscall/Inet4Pktinfo:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Inet4Pktinfo"}
  Inet4Pktinfo)

JOKER TYPE go.std.syscall/Inet6Pktinfo:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Inet6Pktinfo"}
  Inet6Pktinfo)

JOKER TYPE go.std.syscall/InotifyEvent:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_InotifyEvent"}
  InotifyEvent)

JOKER TYPE go.std.syscall/Iovec:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Iovec"}
  Iovec)

JOKER TYPE go.std.syscall/Linger:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Linger"}
  Linger)

JOKER TYPE go.std.syscall/Msghdr:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Msghdr"}
  Msghdr)

JOKER TYPE go.std.syscall/NetlinkMessage:
(def
  ^{:doc "NetlinkMessage represents a netlink message.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NetlinkMessage"}
  NetlinkMessage)

JOKER TYPE go.std.syscall/NetlinkRouteAttr:
(def
  ^{:doc "NetlinkRouteAttr represents a netlink route attribute.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NetlinkRouteAttr"}
  NetlinkRouteAttr)

JOKER TYPE go.std.syscall/NetlinkRouteRequest:
(def
  ^{:doc "NetlinkRouteRequest represents a request message to receive routing\nand link states from the kernel.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NetlinkRouteRequest"}
  NetlinkRouteRequest)

JOKER TYPE go.std.syscall/NlAttr:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_NlAttr"}
  NlAttr)

JOKER TYPE go.std.syscall/NlMsgerr:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_NlMsgerr"}
  NlMsgerr)

JOKER TYPE go.std.syscall/NlMsghdr:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_NlMsghdr"}
  NlMsghdr)

JOKER TYPE go.std.syscall/ProcAttr:
(def
  ^{:doc "ProcAttr holds attributes that will be applied to a new process started\nby StartProcess.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ProcAttr"}
  ProcAttr)

JOKER TYPE go.std.syscall/PtraceRegs:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtraceRegs"}
  PtraceRegs)

JOKER TYPE go.std.syscall/RawConn:
(def
  ^{:doc "A RawConn is a raw network connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RawConn"}
  RawConn)

JOKER TYPE go.std.syscall/RawSockaddr:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_RawSockaddr"}
  RawSockaddr)

JOKER TYPE go.std.syscall/RawSockaddrAny:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_RawSockaddrAny"}
  RawSockaddrAny)

JOKER TYPE go.std.syscall/RawSockaddrInet4:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_RawSockaddrInet4"}
  RawSockaddrInet4)

JOKER TYPE go.std.syscall/RawSockaddrInet6:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_RawSockaddrInet6"}
  RawSockaddrInet6)

JOKER TYPE go.std.syscall/RawSockaddrLinklayer:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_RawSockaddrLinklayer"}
  RawSockaddrLinklayer)

JOKER TYPE go.std.syscall/RawSockaddrNetlink:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_RawSockaddrNetlink"}
  RawSockaddrNetlink)

JOKER TYPE go.std.syscall/RawSockaddrUnix:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_RawSockaddrUnix"}
  RawSockaddrUnix)

JOKER TYPE go.std.syscall/Rlimit:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Rlimit"}
  Rlimit)

JOKER TYPE go.std.syscall/RtAttr:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_RtAttr"}
  RtAttr)

JOKER TYPE go.std.syscall/RtGenmsg:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_RtGenmsg"}
  RtGenmsg)

JOKER TYPE go.std.syscall/RtMsg:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_RtMsg"}
  RtMsg)

JOKER TYPE go.std.syscall/RtNexthop:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_RtNexthop"}
  RtNexthop)

JOKER TYPE go.std.syscall/Rusage:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Rusage"}
  Rusage)

JOKER TYPE go.std.syscall/Signal:
(def
  ^{:doc "A Signal is a number describing a process signal.\nIt implements the os.Signal interface.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Signal"}
  Signal)

JOKER TYPE go.std.syscall/SockFilter:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_SockFilter"}
  SockFilter)

JOKER TYPE go.std.syscall/SockFprog:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_SockFprog"}
  SockFprog)

JOKER TYPE go.std.syscall/Sockaddr:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Sockaddr"}
  Sockaddr)

JOKER TYPE go.std.syscall/SockaddrInet4:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_SockaddrInet4"}
  SockaddrInet4)

JOKER TYPE go.std.syscall/SockaddrInet6:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_SockaddrInet6"}
  SockaddrInet6)

JOKER TYPE go.std.syscall/SockaddrLinklayer:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_SockaddrLinklayer"}
  SockaddrLinklayer)

JOKER TYPE go.std.syscall/SockaddrNetlink:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_SockaddrNetlink"}
  SockaddrNetlink)

JOKER TYPE go.std.syscall/SockaddrUnix:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_SockaddrUnix"}
  SockaddrUnix)

JOKER TYPE go.std.syscall/SocketControlMessage:
(def
  ^{:doc "SocketControlMessage represents a socket control message.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SocketControlMessage"}
  SocketControlMessage)

JOKER TYPE go.std.syscall/Stat_t:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Stat_t"}
  Stat_t)

JOKER TYPE go.std.syscall/Statfs_t:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Statfs_t"}
  Statfs_t)

JOKER TYPE go.std.syscall/SysProcAttr:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_SysProcAttr"}
  SysProcAttr)

JOKER TYPE go.std.syscall/SysProcIDMap:
(def
  ^{:doc "SysProcIDMap holds Container ID to Host ID mappings used for User Namespaces in Linux.\nSee user_namespaces(7).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SysProcIDMap"}
  SysProcIDMap)

JOKER TYPE go.std.syscall/Sysinfo_t:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Sysinfo_t"}
  Sysinfo_t)

JOKER TYPE go.std.syscall/TCPInfo:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_TCPInfo"}
  TCPInfo)

JOKER TYPE go.std.syscall/Termios:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Termios"}
  Termios)

JOKER TYPE go.std.syscall/Time_t:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Time_t"}
  Time_t)

JOKER TYPE go.std.syscall/Timespec:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Timespec"}
  Timespec)

JOKER TYPE go.std.syscall/Timeval:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Timeval"}
  Timeval)

JOKER TYPE go.std.syscall/Timex:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Timex"}
  Timex)

JOKER TYPE go.std.syscall/Tms:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Tms"}
  Tms)

JOKER TYPE go.std.syscall/Ucred:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Ucred"}
  Ucred)

JOKER TYPE go.std.syscall/Ustat_t:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Ustat_t"}
  Ustat_t)

JOKER TYPE go.std.syscall/Utimbuf:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Utimbuf"}
  Utimbuf)

JOKER TYPE go.std.syscall/Utsname:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Utsname"}
  Utsname)

JOKER TYPE go.std.syscall/WaitStatus:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_WaitStatus"}
  WaitStatus)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["syscall"]
    :doc "Provides a low-level interface to the syscall package.\n\nPackage syscall contains an interface to the low-level operating system\nprimitives. The details vary depending on the underlying system, and\nby default, godoc will display the syscall documentation for the current\nsystem. If you want godoc to display syscall documentation for another\nsystem, set $GOOS and $GOARCH to the desired system. For example, if\nyou want to view documentation for freebsd/arm on linux/amd64, set $GOOS\nto freebsd and $GOARCH to arm.\nThe primary use of syscall is inside other packages that provide a more\nportable interface to the system, such as \"os\", \"time\" and \"net\".  Use\nthose packages rather than this one if you can.\nFor details of the functions and data types in this package consult\nthe manuals for the appropriate operating system.\nThese calls return err == nil to indicate success; otherwise\nerr is an operating system error describing the failure.\nOn most systems, that error has type syscall.Errno.\n\nDeprecated: this package is locked down. Callers should use the\ncorresponding package in the golang.org/x/sys repository instead.\nThat is also where updates required by new systems or versions\nshould be applied. See https://golang.org/s/go1.4-syscall for more\ninformation.\n"
    :empty false}
  go.std.syscall)
JOKER TYPE testing.B from testing/benchmark.go:
(defn ^"GoObject" B.
  "Constructor for testing.B"
  {:added "1.0"
   :go "_ConstructB(_v)"}
  [^Object _v])

JOKER TYPE testing.BenchmarkResult from testing/benchmark.go:
;; (defn ^"GoObject" BenchmarkResult.
;;   "Constructor for testing.BenchmarkResult"
;;   {:added "1.0"
;;    :go "_ConstructBenchmarkResult(_v)"}
;;   [^Object _v])

JOKER TYPE testing.Cover from testing/cover.go:
;; (defn ^"GoObject" Cover.
;;   "Constructor for testing.Cover"
;;   {:added "1.0"
;;    :go "_ConstructCover(_v)"}
;;   [^Object _v])

JOKER TYPE testing.CoverBlock from testing/cover.go:
(defn ^"GoObject" CoverBlock.
  "Constructor for testing.CoverBlock"
  {:added "1.0"
   :go "_ConstructCoverBlock(_v)"}
  [^Object _v])

JOKER TYPE testing.InternalBenchmark from testing/benchmark.go:
;; (defn ^"GoObject" InternalBenchmark.
;;   "Constructor for testing.InternalBenchmark"
;;   {:added "1.0"
;;    :go "_ConstructInternalBenchmark(_v)"}
;;   [^Object _v])

JOKER TYPE testing.InternalExample from testing/example.go:
;; (defn ^"GoObject" InternalExample.
;;   "Constructor for testing.InternalExample"
;;   {:added "1.0"
;;    :go "_ConstructInternalExample(_v)"}
;;   [^Object _v])

JOKER TYPE testing.InternalTest from testing/testing.go:
;; (defn ^"GoObject" InternalTest.
;;   "Constructor for testing.InternalTest"
;;   {:added "1.0"
;;    :go "_ConstructInternalTest(_v)"}
;;   [^Object _v])

JOKER TYPE testing.M from testing/testing.go:
(defn ^"GoObject" M.
  "Constructor for testing.M"
  {:added "1.0"
   :go "_ConstructM(_v)"}
  [^Object _v])

JOKER TYPE testing.PB from testing/benchmark.go:
(defn ^"GoObject" PB.
  "Constructor for testing.PB"
  {:added "1.0"
   :go "_ConstructPB(_v)"}
  [^Object _v])

JOKER TYPE testing.T from testing/testing.go:
(defn ^"GoObject" T.
  "Constructor for testing.T"
  {:added "1.0"
   :go "_ConstructT(_v)"}
  [^Object _v])

JOKER TYPE testing.TB from testing/testing.go:
;; (defn ^"GoObject" TB.
;;   "Constructor for testing.TB"
;;   {:added "1.0"
;;    :go "_ConstructTB(_v)"}
;;   [^Object _v])

JOKER FUNC testing.AllocsPerRun from testing/allocs.go:
;; (defn AllocsPerRun
;;   "AllocsPerRun returns the average number of allocations during calls to f.\nAlthough the return value has type float64, it will always be an integral value.\n\nTo compute the number of allocations, the function will first be run once as\na warm-up. The average number of allocations over the specified number of\nruns will then be measured and returned.\n\nAllocsPerRun sets GOMAXPROCS to 1 during its measurement and will restore\nit before returning.\n\nGo input arguments: (runs int, f func)\n\nGo return type: float64\n\nJoker input arguments: [^Int runs, ^fn f]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__allocsPerRun(__runs, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Int __runs, ^fn __f])

JOKER FUNC testing.Benchmark from testing/benchmark.go:
;; (defn Benchmark
;;   "Benchmark benchmarks a single function. Useful for creating\ncustom benchmarks that do not use the \"go test\" command.\n\nIf f calls Run, the result will be an estimate of running all its\nsubbenchmarks that don't call Run in sequence in a single benchmark.\n\nGo input arguments: (f func)\n\nGo return type: BenchmarkResult\n\nJoker input arguments: [^fn f]\n\nJoker return type: go.std.testing/BenchmarkResult"
;;   {:added "1.0"
;;    :go "__benchmark(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^fn __f])

JOKER FUNC testing.CoverMode from testing/testing.go:
(defn ^"String" CoverMode
  "CoverMode reports what the test coverage mode is set to. The\nvalues are \"set\", \"count\", or \"atomic\". The return value will be\nempty if test coverage is not enabled.\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "testing.CoverMode()"}
  [])

JOKER FUNC testing.Coverage from testing/cover.go:
;; (defn Coverage
;;   "Coverage reports the current code coverage as a fraction in the range [0, 1].\nIf coverage is not enabled, Coverage returns 0.\n\nWhen running a large set of sequential test cases, checking Coverage after each one\ncan be useful for identifying which test cases exercise new code paths.\nIt is not a replacement for the reports generated by 'go test -cover' and\n'go tool cover'.\n\nGo return type: float64\n\nJoker input arguments: []\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__coverage()"}
;;   [])

JOKER FUNC testing.Main from testing/testing.go:
;; (defn Main
;;   "Main is an internal function, part of the implementation of the \"go test\" command.\nIt was exported because it is cross-package and predates \"internal\" packages.\nIt is no longer used by \"go test\" but preserved, as much as possible, for other\nsystems that simulate \"go test\" using Main, but Main sometimes cannot be updated as\nnew functionality is added to the testing package.\nSystems simulating \"go test\" should be updated to use MainStart.\n\nGo input arguments: (matchString func, tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)\n\nJoker input arguments: [^fn matchString, ^(vector-of go.std.testing/InternalTest) tests, ^(vector-of go.std.testing/InternalBenchmark) benchmarks, ^(vector-of go.std.testing/InternalExample) examples]"
;;   {:added "1.0"
;;    :go "__main(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalTest(*__tests)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalBenchmark(*__benchmarks)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalExample(*__examples)))"}
;;   [^fn __matchString, ^Object __tests, ^Object __benchmarks, ^Object __examples])

JOKER FUNC testing.MainStart from testing/testing.go:
;; (defn MainStart
;;   "MainStart is meant for use by tests generated by 'go test'.\nIt is not meant to be called directly and is not subject to the Go 1 compatibility document.\nIt may change signature from release to release.\n\nGo input arguments: (deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)\n\nGo return type: *M\n\nJoker input arguments: [^testDeps deps, ^(vector-of go.std.testing/InternalTest) tests, ^(vector-of go.std.testing/InternalBenchmark) benchmarks, ^(vector-of go.std.testing/InternalExample) examples]\n\nJoker return type: (atom-of go.std.testing/M)"
;;   {:added "1.0"
;;    :go "__mainStart(__deps, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalTest(*__tests)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalBenchmark(*__benchmarks)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalExample(*__examples)))"}
;;   [^ABEND044(pre.go: unsupported built-in type testDeps) __deps, ^Object __tests, ^Object __benchmarks, ^Object __examples])

JOKER FUNC testing.RegisterCover from testing/cover.go:
;; (defn RegisterCover
;;   "RegisterCover records the coverage data accumulators for the tests.\nNOTE: This function is internal to the testing infrastructure and may change.\nIt is not covered (yet) by the Go 1 compatibility guidelines.\n\nGo input arguments: (c Cover)\n\nJoker input arguments: [^go.std.testing/Cover c]"
;;   {:added "1.0"
;;    :go "__registerCover(*__c)"}
;;   [^testing/Cover __c])

JOKER FUNC testing.RunBenchmarks from testing/benchmark.go:
;; (defn RunBenchmarks
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n\nGo input arguments: (matchString func, benchmarks []InternalBenchmark)\n\nJoker input arguments: [^fn matchString, ^(vector-of go.std.testing/InternalBenchmark) benchmarks]"
;;   {:added "1.0"
;;    :go "__runBenchmarks(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalBenchmark(*__benchmarks)))"}
;;   [^fn __matchString, ^Object __benchmarks])

JOKER FUNC testing.RunExamples from testing/example.go:
;; (defn ^"Boolean" RunExamples
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n\nGo input arguments: (matchString func, examples []InternalExample)\n\nGo return type: bool\n\nJoker input arguments: [^fn matchString, ^(vector-of go.std.testing/InternalExample) examples]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "testing.RunExamples(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalExample(*__examples)))"}
;;   [^fn __matchString, ^Object __examples])

JOKER FUNC testing.RunTests from testing/testing.go:
;; (defn ^"Boolean" RunTests
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n\nGo input arguments: (matchString func, tests []InternalTest)\n\nGo return type: bool\n\nJoker input arguments: [^fn matchString, ^(vector-of go.std.testing/InternalTest) tests]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "testing.RunTests(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalTest(*__tests)))"}
;;   [^fn __matchString, ^Object __tests])

JOKER FUNC testing.Short from testing/testing.go:
(defn ^"Boolean" Short
  "Short reports whether the -test.short flag is set.\n\nGo return type: bool\n\nJoker input arguments: []\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "testing.Short()"}
  [])

JOKER FUNC testing.Verbose from testing/testing.go:
(defn ^"Boolean" Verbose
  "Verbose reports whether the -test.v flag is set.\n\nGo return type: bool\n\nJoker input arguments: []\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "testing.Verbose()"}
  [])

JOKER TYPE go.std.testing/B:
(def
  ^{:doc "B is a type passed to Benchmark functions to manage benchmark\ntiming and to specify the number of iterations to run.\n\nA benchmark ends when its Benchmark function returns or calls any of the methods\nFailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods must be called\nonly from the goroutine running the Benchmark function.\nThe other reporting methods, such as the variations of Log and Error,\nmay be called simultaneously from multiple goroutines.\n\nLike in tests, benchmark logs are accumulated during execution\nand dumped to standard error when done. Unlike in tests, benchmark logs\nare always printed, so as not to hide output whose existence may be\naffecting benchmark results.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_B"}
  B)

JOKER TYPE go.std.testing/BenchmarkResult:
(def
  ^{:doc "The results of a benchmark run.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BenchmarkResult"}
  BenchmarkResult)

JOKER TYPE go.std.testing/Cover:
(def
  ^{:doc "Cover records information about test coverage checking.\nNOTE: This struct is internal to the testing infrastructure and may change.\nIt is not covered (yet) by the Go 1 compatibility guidelines.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Cover"}
  Cover)

JOKER TYPE go.std.testing/CoverBlock:
(def
  ^{:doc "CoverBlock records the coverage data for a single basic block.\nThe fields are 1-indexed, as in an editor: The opening line of\nthe file is number 1, for example. Columns are measured\nin bytes.\nNOTE: This struct is internal to the testing infrastructure and may change.\nIt is not covered (yet) by the Go 1 compatibility guidelines.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CoverBlock"}
  CoverBlock)

JOKER TYPE go.std.testing/InternalBenchmark:
(def
  ^{:doc "An internal type but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_InternalBenchmark"}
  InternalBenchmark)

JOKER TYPE go.std.testing/InternalExample:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_InternalExample"}
  InternalExample)

JOKER TYPE go.std.testing/InternalTest:
(def
  ^{:doc "An internal type but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_InternalTest"}
  InternalTest)

JOKER TYPE go.std.testing/M:
(def
  ^{:doc "M is a type passed to a TestMain function to run the actual tests.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_M"}
  M)

JOKER TYPE go.std.testing/PB:
(def
  ^{:doc "A PB is used by RunParallel for running parallel benchmarks.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PB"}
  PB)

JOKER TYPE go.std.testing/T:
(def
  ^{:doc "T is a type passed to Test functions to manage test state and support formatted test logs.\nLogs are accumulated during execution and dumped to standard output when done.\n\nA test ends when its Test function returns or calls any of the methods\nFailNow, Fatal, Fatalf, SkipNow, Skip, or Skipf. Those methods, as well as\nthe Parallel method, must be called only from the goroutine running the\nTest function.\n\nThe other reporting methods, such as the variations of Log and Error,\nmay be called simultaneously from multiple goroutines.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_T"}
  T)

JOKER TYPE go.std.testing/TB:
(def
  ^{:doc "TB is the interface common to T and B.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TB"}
  TB)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["testing"]
    :doc "Provides a low-level interface to the testing package.\n\nPackage testing provides support for automated testing of Go packages.\nIt is intended to be used in concert with the ``go test'' command, which automates\nexecution of any function of the form\n    func TestXxx(*testing.T)\nwhere Xxx does not start with a lowercase letter. The function name\nserves to identify the test routine.\n\nWithin these functions, use the Error, Fail or related methods to signal failure.\n\nTo write a new test suite, create a file whose name ends _test.go that\ncontains the TestXxx functions as described here. Put the file in the same\npackage as the one being tested. The file will be excluded from regular\npackage builds but will be included when the ``go test'' command is run.\nFor more detail, run ``go help test'' and ``go help testflag''.\n\nA simple test function looks like this:\n\n    func TestAbs(t *testing.T) {\n        got := Abs(-1)\n        if got != 1 {\n            t.Errorf(\"Abs(-1) = %d; want 1\", got)\n        }\n    }\n\nBenchmarks\n\nFunctions of the form\n    func BenchmarkXxx(*testing.B)\nare considered benchmarks, and are executed by the \"go test\" command when\nits -bench flag is provided. Benchmarks are run sequentially.\n\nFor a description of the testing flags, see\nhttps://golang.org/cmd/go/#hdr-Testing_flags\n\nA sample benchmark function looks like this:\n    func BenchmarkHello(b *testing.B) {\n        for i := 0; i < b.N; i++ {\n            fmt.Sprintf(\"hello\")\n        }\n    }\n\nThe benchmark function must run the target code b.N times.\nDuring benchmark execution, b.N is adjusted until the benchmark function lasts\nlong enough to be timed reliably. The output\n    BenchmarkHello    10000000    282 ns/op\nmeans that the loop ran 10000000 times at a speed of 282 ns per loop.\n\nIf a benchmark needs some expensive setup before running, the timer\nmay be reset:\n\n    func BenchmarkBigLen(b *testing.B) {\n        big := NewBig()\n        b.ResetTimer()\n        for i := 0; i < b.N; i++ {\n            big.Len()\n        }\n    }\n\nIf a benchmark needs to test performance in a parallel setting, it may use\nthe RunParallel helper function; such benchmarks are intended to be used with\nthe go test -cpu flag:\n\n    func BenchmarkTemplateParallel(b *testing.B) {\n        templ := template.Must(template.New(\"test\").Parse(\"Hello, {{.}}!\"))\n        b.RunParallel(func(pb *testing.PB) {\n            var buf bytes.Buffer\n            for pb.Next() {\n                buf.Reset()\n                templ.Execute(&buf, \"World\")\n            }\n        })\n    }\n\nExamples\n\nThe package also runs and verifies example code. Example functions may\ninclude a concluding line comment that begins with \"Output:\" and is compared with\nthe standard output of the function when the tests are run. (The comparison\nignores leading and trailing space.) These are examples of an example:\n\n    func ExampleHello() {\n        fmt.Println(\"hello\")\n        // Output: hello\n    }\n\n    func ExampleSalutations() {\n        fmt.Println(\"hello, and\")\n        fmt.Println(\"goodbye\")\n        // Output:\n        // hello, and\n        // goodbye\n    }\n\nThe comment prefix \"Unordered output:\" is like \"Output:\", but matches any\nline order:\n\n    func ExamplePerm() {\n        for _, value := range Perm(4) {\n            fmt.Println(value)\n        }\n        // Unordered output: 4\n        // 2\n        // 1\n        // 3\n        // 0\n    }\n\nExample functions without output comments are compiled but not executed.\n\nThe naming convention to declare examples for the package, a function F, a type T and\nmethod M on type T are:\n\n    func Example() { ... }\n    func ExampleF() { ... }\n    func ExampleT() { ... }\n    func ExampleT_M() { ... }\n\nMultiple example functions for a package/type/function/method may be provided by\nappending a distinct suffix to the name. The suffix must start with a\nlower-case letter.\n\n    func Example_suffix() { ... }\n    func ExampleF_suffix() { ... }\n    func ExampleT_suffix() { ... }\n    func ExampleT_M_suffix() { ... }\n\nThe entire test file is presented as the example when it contains a single\nexample function, at least one other function, type, variable, or constant\ndeclaration, and no test or benchmark functions.\n\nSkipping\n\nTests or benchmarks may be skipped at run time with a call to\nthe Skip method of *T or *B:\n\n    func TestTimeConsuming(t *testing.T) {\n        if testing.Short() {\n            t.Skip(\"skipping test in short mode.\")\n        }\n        ...\n    }\n\nSubtests and Sub-benchmarks\n\nThe Run methods of T and B allow defining subtests and sub-benchmarks,\nwithout having to define separate functions for each. This enables uses\nlike table-driven benchmarks and creating hierarchical tests.\nIt also provides a way to share common setup and tear-down code:\n\n    func TestFoo(t *testing.T) {\n        // <setup code>\n        t.Run(\"A=1\", func(t *testing.T) { ... })\n        t.Run(\"A=2\", func(t *testing.T) { ... })\n        t.Run(\"B=1\", func(t *testing.T) { ... })\n        // <tear-down code>\n    }\n\nEach subtest and sub-benchmark has a unique name: the combination of the name\nof the top-level test and the sequence of names passed to Run, separated by\nslashes, with an optional trailing sequence number for disambiguation.\n\nThe argument to the -run and -bench command-line flags is an unanchored regular\nexpression that matches the test's name. For tests with multiple slash-separated\nelements, such as subtests, the argument is itself slash-separated, with\nexpressions matching each name element in turn. Because it is unanchored, an\nempty expression matches any string.\nFor example, using \"matching\" to mean \"whose name contains\":\n\n    go test -run ''      # Run all tests.\n    go test -run Foo     # Run top-level tests matching \"Foo\", such as \"TestFooBar\".\n    go test -run Foo/A=  # For top-level tests matching \"Foo\", run subtests matching \"A=\".\n    go test -run /A=1    # For all top-level tests, run subtests matching \"A=1\".\n\nSubtests can also be used to control parallelism. A parent test will only\ncomplete once all of its subtests complete. In this example, all tests are\nrun in parallel with each other, and only with each other, regardless of\nother top-level tests that may be defined:\n\n    func TestGroupedParallel(t *testing.T) {\n        for _, tc := range tests {\n            tc := tc // capture range variable\n            t.Run(tc.Name, func(t *testing.T) {\n                t.Parallel()\n                ...\n            })\n        }\n    }\n\nThe race detector kills the program if it exceeds 8192 concurrent goroutines,\nso use care when running parallel tests with the -race flag set.\n\nRun does not return until parallel subtests have completed, providing a way\nto clean up after a group of parallel tests:\n\n    func TestTeardownParallel(t *testing.T) {\n        // This Run will not return until the parallel tests finish.\n        t.Run(\"group\", func(t *testing.T) {\n            t.Run(\"Test1\", parallelTest1)\n            t.Run(\"Test2\", parallelTest2)\n            t.Run(\"Test3\", parallelTest3)\n        })\n        // <tear-down code>\n    }\n\nMain\n\nIt is sometimes necessary for a test program to do extra setup or teardown\nbefore or after testing. It is also sometimes necessary for a test to control\nwhich code runs on the main thread. To support these and other cases,\nif a test file contains a function:\n\n\tfunc TestMain(m *testing.M)\n\nthen the generated test will call TestMain(m) instead of running the tests\ndirectly. TestMain runs in the main goroutine and can do whatever setup\nand teardown is necessary around a call to m.Run. It should then call\nos.Exit with the result of m.Run. When TestMain is called, flag.Parse has\nnot been run. If TestMain depends on command-line flags, including those\nof the testing package, it should call flag.Parse explicitly.\n\nA simple implementation of TestMain is:\n\n\tfunc TestMain(m *testing.M) {\n\t\t// call flag.Parse() here if TestMain uses flags\n\t\tos.Exit(m.Run())\n\t}\n"
    :empty false}
  go.std.testing)
JOKER VARIABLE ErrTimeout from testing/iotest/reader.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "iotest.ErrTimeout"}
  ErrTimeout)

JOKER FUNC testing/iotest.DataErrReader from testing/iotest/reader.go:
;; (defn DataErrReader
;;   "DataErrReader changes the way errors are handled by a Reader. Normally, a\nReader returns an error (typically EOF) from the first Read call after the\nlast piece of data is read. DataErrReader wraps a Reader and changes its\nbehavior so the final error is returned along with the final data, instead\nof in the first call after the final data.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__dataErrReader(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC testing/iotest.HalfReader from testing/iotest/reader.go:
;; (defn HalfReader
;;   "HalfReader returns a Reader that implements Read\nby reading half as many requested bytes from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__halfReader(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC testing/iotest.NewReadLogger from testing/iotest/logger.go:
;; (defn NewReadLogger
;;   "NewReadLogger returns a reader that behaves like r except\nthat it logs (using log.Printf) each read to standard error,\nprinting the prefix and the hexadecimal data read.\n\nGo input arguments: (prefix string, r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^String prefix, ^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__newReadLogger(__prefix, *__r)"}
;;   [^String __prefix, ^io/Reader __r])

JOKER FUNC testing/iotest.NewWriteLogger from testing/iotest/logger.go:
;; (defn NewWriteLogger
;;   "NewWriteLogger returns a writer that behaves like w except\nthat it logs (using log.Printf) each write to standard error,\nprinting the prefix and the hexadecimal data written.\n\nGo input arguments: (prefix string, w io.Writer)\n\nGo return type: io.Writer\n\nJoker input arguments: [^String prefix, ^go.std.io/Writer w]\n\nJoker return type: go.std.io/Writer"
;;   {:added "1.0"
;;    :go "__newWriteLogger(__prefix, *__w)"}
;;   [^String __prefix, ^io/Writer __w])

JOKER FUNC testing/iotest.OneByteReader from testing/iotest/reader.go:
;; (defn OneByteReader
;;   "OneByteReader returns a Reader that implements\neach non-empty Read by reading one byte from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__oneByteReader(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC testing/iotest.TimeoutReader from testing/iotest/reader.go:
;; (defn TimeoutReader
;;   "TimeoutReader returns ErrTimeout on the second read\nwith no data. Subsequent calls to read succeed.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__timeoutReader(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC testing/iotest.TruncateWriter from testing/iotest/writer.go:
;; (defn TruncateWriter
;;   "TruncateWriter returns a Writer that writes to w\nbut stops silently after n bytes.\n\nGo input arguments: (w io.Writer, n int64)\n\nGo return type: io.Writer\n\nJoker input arguments: [^go.std.io/Writer w, ^Number n]\n\nJoker return type: go.std.io/Writer"
;;   {:added "1.0"
;;    :go "__truncateWriter(*__w, __n)"}
;;   [^io/Writer __w, ^Int64 __n])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["testing/iotest"]
    :doc "Provides a low-level interface to the testing/iotest package.\n\nPackage iotest implements Readers and Writers useful mainly for testing.\n"
    :empty false}
  go.std.testing.iotest)
JOKER TYPE testing/quick.CheckEqualError from testing/quick/quick.go:
;; (defn ^"GoObject" CheckEqualError.
;;   "Constructor for quick.CheckEqualError"
;;   {:added "1.0"
;;    :go "_ConstructCheckEqualError(_v)"}
;;   [^Object _v])

JOKER TYPE testing/quick.CheckError from testing/quick/quick.go:
;; (defn ^"GoObject" CheckError.
;;   "Constructor for quick.CheckError"
;;   {:added "1.0"
;;    :go "_ConstructCheckError(_v)"}
;;   [^Object _v])

JOKER TYPE testing/quick.Config from testing/quick/quick.go:
;; (defn ^"GoObject" Config.
;;   "Constructor for quick.Config"
;;   {:added "1.0"
;;    :go "_ConstructConfig(_v)"}
;;   [^Object _v])

JOKER TYPE testing/quick.Generator from testing/quick/quick.go:
;; (defn ^"GoObject" Generator.
;;   "Constructor for quick.Generator"
;;   {:added "1.0"
;;    :go "_ConstructGenerator(_v)"}
;;   [^Object _v])

JOKER TYPE testing/quick.SetupError from testing/quick/quick.go:
(defn ^"GoObject" SetupError.
  "Constructor for quick.SetupError"
  {:added "1.0"
   :go "_ConstructSetupError(_v)"}
  [^Object _v])

JOKER FUNC testing/quick.Check from testing/quick/quick.go:
;; (defn ^"Error" Check
;;   "Check looks for an input to f, any function that returns bool,\nsuch that f returns false. It calls f repeatedly, with arbitrary\nvalues for each argument. If f returns false on a given input,\nCheck returns that input as a *CheckError.\nFor example:\n\n\tfunc TestOddMultipleOfThree(t *testing.T) {\n\t\tf := func(x int) bool {\n\t\t\ty := OddMultipleOfThree(x)\n\t\t\treturn y%2 == 1 && y%3 == 0\n\t\t}\n\t\tif err := quick.Check(f, nil); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n\nGo input arguments: (f interface {}, config *Config)\n\nGo return type: error\n\nJoker input arguments: [^<protocol-or-something> f, ^(atom-of go.std.testing.quick/Config) config]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "quick.Check(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), __config)"}
;;   [^<protocol-or-something> __f, ^quick/Config __config])

JOKER FUNC testing/quick.CheckEqual from testing/quick/quick.go:
;; (defn ^"Error" CheckEqual
;;   "CheckEqual looks for an input on which f and g return different results.\nIt calls f and g repeatedly with arbitrary values for each argument.\nIf f and g return different answers, CheckEqual returns a *CheckEqualError\ndescribing the input and the outputs.\n\nGo input arguments: (f interface {}, g interface {}, config *Config)\n\nGo return type: error\n\nJoker input arguments: [^<protocol-or-something> f, ^<protocol-or-something> g, ^(atom-of go.std.testing.quick/Config) config]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "quick.CheckEqual(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), __config)"}
;;   [^<protocol-or-something> __f, ^<protocol-or-something> __g, ^quick/Config __config])

JOKER FUNC testing/quick.Value from testing/quick/quick.go:
;; (defn Value
;;   "Value returns an arbitrary value of the given type.\nIf the type implements the Generator interface, that will be used.\nNote: To create arbitrary values for structs, all the fields must be exported.\n\nGo input arguments: (t reflect.Type, rand *rand.Rand)\n\nGo return type: (value reflect.Value, ok bool)\n\nJoker input arguments: [^go.std.reflect/Type t, ^(atom-of go.std.math.rand/Rand) rand]\n\nJoker return type: [go.std.reflect/Value Boolean]"
;;   {:added "1.0"
;;    :go "__value(*__t, __rand)"}
;;   [^reflect/Type __t, ^rand/Rand __rand])

JOKER TYPE go.std.testing.quick/CheckEqualError:
(def
  ^{:doc "A CheckEqualError is the result CheckEqual finding an error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CheckEqualError"}
  CheckEqualError)

JOKER TYPE go.std.testing.quick/CheckError:
(def
  ^{:doc "A CheckError is the result of Check finding an error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CheckError"}
  CheckError)

JOKER TYPE go.std.testing.quick/Config:
(def
  ^{:doc "A Config structure contains options for running a test.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Config"}
  Config)

JOKER TYPE go.std.testing.quick/Generator:
(def
  ^{:doc "A Generator can generate random values of its own type.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Generator"}
  Generator)

JOKER TYPE go.std.testing.quick/SetupError:
(def
  ^{:doc "A SetupError is the result of an error in the way that check is being\nused, independent of the functions being tested.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SetupError"}
  SetupError)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the testing/quick package.\n\nPackage quick implements utility functions to help with black box testing.\n\nThe testing/quick package is frozen and is not accepting new features.\n"
    :empty false}
  go.std.testing.quick)
JOKER CONSTANT GoTokens from text/scanner/scanner.go:
(def
  ^{:doc "Predefined mode bits to control recognition of tokens. For instance,\nto configure a Scanner such that it only recognizes (Go) identifiers,\nintegers, and skips comments, set the Scanner's Mode field to:\n\n\tScanIdents | ScanInts | SkipComments\n\nWith the exceptions of comments, which are skipped if SkipComments is\nset, unrecognized tokens are not ignored. Instead, the scanner simply\nreturns the respective individual characters (or possibly sub-tokens).\nFor instance, if the mode is ScanIdents (not ScanStrings), the string\n\"foo\" is scanned as the token sequence '\"' Ident '\"'.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(scanner.GoTokens)"}
  GoTokens)

JOKER CONSTANT GoWhitespace from text/scanner/scanner.go:
(def
  ^{:doc "GoWhitespace is the default value for the Scanner's Whitespace field.\nIts value selects Go's white space characters.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(scanner.GoWhitespace)"}
  GoWhitespace)

JOKER CONSTANT ScanChars from text/scanner/scanner.go:
(def
  ^{:doc "Predefined mode bits to control recognition of tokens. For instance,\nto configure a Scanner such that it only recognizes (Go) identifiers,\nintegers, and skips comments, set the Scanner's Mode field to:\n\n\tScanIdents | ScanInts | SkipComments\n\nWith the exceptions of comments, which are skipped if SkipComments is\nset, unrecognized tokens are not ignored. Instead, the scanner simply\nreturns the respective individual characters (or possibly sub-tokens).\nFor instance, if the mode is ScanIdents (not ScanStrings), the string\n\"foo\" is scanned as the token sequence '\"' Ident '\"'.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(scanner.ScanChars)"}
  ScanChars)

JOKER CONSTANT ScanComments from text/scanner/scanner.go:
(def
  ^{:doc "Predefined mode bits to control recognition of tokens. For instance,\nto configure a Scanner such that it only recognizes (Go) identifiers,\nintegers, and skips comments, set the Scanner's Mode field to:\n\n\tScanIdents | ScanInts | SkipComments\n\nWith the exceptions of comments, which are skipped if SkipComments is\nset, unrecognized tokens are not ignored. Instead, the scanner simply\nreturns the respective individual characters (or possibly sub-tokens).\nFor instance, if the mode is ScanIdents (not ScanStrings), the string\n\"foo\" is scanned as the token sequence '\"' Ident '\"'.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(scanner.ScanComments)"}
  ScanComments)

JOKER CONSTANT ScanFloats from text/scanner/scanner.go:
(def
  ^{:doc "includes Ints\n"
    :added "1.0"
    :tag "Number"
    :go "int64(scanner.ScanFloats)"}
  ScanFloats)

JOKER CONSTANT ScanIdents from text/scanner/scanner.go:
(def
  ^{:doc "Predefined mode bits to control recognition of tokens. For instance,\nto configure a Scanner such that it only recognizes (Go) identifiers,\nintegers, and skips comments, set the Scanner's Mode field to:\n\n\tScanIdents | ScanInts | SkipComments\n\nWith the exceptions of comments, which are skipped if SkipComments is\nset, unrecognized tokens are not ignored. Instead, the scanner simply\nreturns the respective individual characters (or possibly sub-tokens).\nFor instance, if the mode is ScanIdents (not ScanStrings), the string\n\"foo\" is scanned as the token sequence '\"' Ident '\"'.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(scanner.ScanIdents)"}
  ScanIdents)

JOKER CONSTANT ScanInts from text/scanner/scanner.go:
(def
  ^{:doc "Predefined mode bits to control recognition of tokens. For instance,\nto configure a Scanner such that it only recognizes (Go) identifiers,\nintegers, and skips comments, set the Scanner's Mode field to:\n\n\tScanIdents | ScanInts | SkipComments\n\nWith the exceptions of comments, which are skipped if SkipComments is\nset, unrecognized tokens are not ignored. Instead, the scanner simply\nreturns the respective individual characters (or possibly sub-tokens).\nFor instance, if the mode is ScanIdents (not ScanStrings), the string\n\"foo\" is scanned as the token sequence '\"' Ident '\"'.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(scanner.ScanInts)"}
  ScanInts)

JOKER CONSTANT ScanRawStrings from text/scanner/scanner.go:
(def
  ^{:doc "Predefined mode bits to control recognition of tokens. For instance,\nto configure a Scanner such that it only recognizes (Go) identifiers,\nintegers, and skips comments, set the Scanner's Mode field to:\n\n\tScanIdents | ScanInts | SkipComments\n\nWith the exceptions of comments, which are skipped if SkipComments is\nset, unrecognized tokens are not ignored. Instead, the scanner simply\nreturns the respective individual characters (or possibly sub-tokens).\nFor instance, if the mode is ScanIdents (not ScanStrings), the string\n\"foo\" is scanned as the token sequence '\"' Ident '\"'.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(scanner.ScanRawStrings)"}
  ScanRawStrings)

JOKER CONSTANT ScanStrings from text/scanner/scanner.go:
(def
  ^{:doc "Predefined mode bits to control recognition of tokens. For instance,\nto configure a Scanner such that it only recognizes (Go) identifiers,\nintegers, and skips comments, set the Scanner's Mode field to:\n\n\tScanIdents | ScanInts | SkipComments\n\nWith the exceptions of comments, which are skipped if SkipComments is\nset, unrecognized tokens are not ignored. Instead, the scanner simply\nreturns the respective individual characters (or possibly sub-tokens).\nFor instance, if the mode is ScanIdents (not ScanStrings), the string\n\"foo\" is scanned as the token sequence '\"' Ident '\"'.\n"
    :added "1.0"
    :tag "Number"
    :go "int64(scanner.ScanStrings)"}
  ScanStrings)

JOKER CONSTANT SkipComments from text/scanner/scanner.go:
(def
  ^{:doc "if set with ScanComments, comments become white space\n"
    :added "1.0"
    :tag "Number"
    :go "int64(scanner.SkipComments)"}
  SkipComments)

JOKER TYPE text/scanner.Position from text/scanner/scanner.go:
(defn ^"GoObject" Position.
  "Constructor for scanner.Position"
  {:added "1.0"
   :go "_ConstructPosition(_v)"}
  [^Object _v])

JOKER TYPE text/scanner.Scanner from text/scanner/scanner.go:
;; (defn ^"GoObject" Scanner.
;;   "Constructor for scanner.Scanner"
;;   {:added "1.0"
;;    :go "_ConstructScanner(_v)"}
;;   [^Object _v])

JOKER FUNC text/scanner.TokenString from text/scanner/scanner.go:
(defn ^"String" TokenString
  "TokenString returns a printable string for a token or Unicode character.\n\nGo input arguments: (tok rune)\n\nGo return type: string\n\nJoker input arguments: [^Char tok]\n\nJoker return type: String"
  {:added "1.0"
   :go "scanner.TokenString(__tok)"}
  [^Char __tok])

JOKER TYPE go.std.text.scanner/Position:
(def
  ^{:doc "A source position is represented by a Position value.\nA position is valid if Line > 0.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Position"}
  Position)

JOKER TYPE go.std.text.scanner/Scanner:
(def
  ^{:doc "A Scanner implements reading of Unicode characters and tokens from an io.Reader.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Scanner"}
  Scanner)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["text/scanner"]
    :doc "Provides a low-level interface to the text/scanner package.\n\nPackage scanner provides a scanner and tokenizer for UTF-8-encoded text.\nIt takes an io.Reader providing the source, which then can be tokenized\nthrough repeated calls to the Scan function. For compatibility with\nexisting tools, the NUL character is not allowed. If the first character\nin the source is a UTF-8 encoded byte order mark (BOM), it is discarded.\n\nBy default, a Scanner skips white space and Go comments and recognizes all\nliterals as defined by the Go language specification. It may be\ncustomized to recognize only a subset of those literals and to recognize\ndifferent identifier and white space characters.\n"
    :empty false}
  go.std.text.scanner)
JOKER CONSTANT AlignRight from text/tabwriter/tabwriter.go:
(def
  ^{:doc "Force right-alignment of cell content.\nDefault is left-alignment.\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(tabwriter.AlignRight)"}
  AlignRight)

JOKER CONSTANT Debug from text/tabwriter/tabwriter.go:
(def
  ^{:doc "Print a vertical bar ('|') between columns (after formatting).\nDiscarded columns appear as zero-width columns (\"||\").\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(tabwriter.Debug)"}
  Debug)

JOKER CONSTANT DiscardEmptyColumns from text/tabwriter/tabwriter.go:
(def
  ^{:doc "Handle empty columns as if they were not present in\nthe input in the first place.\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(tabwriter.DiscardEmptyColumns)"}
  DiscardEmptyColumns)

JOKER CONSTANT Escape from text/tabwriter/tabwriter.go:
(def
  ^{:doc "To escape a text segment, bracket it with Escape characters.\nFor instance, the tab in this string \"Ignore this tab: \\xff\\t\\xff\"\ndoes not terminate a cell and constitutes a single character of\nwidth one for formatting purposes.\n\nThe value 0xff was chosen because it cannot appear in a valid UTF-8 sequence.\n"
    :added "1.0"
    :tag "Char"
    :go "tabwriter.Escape"}
  Escape)

JOKER CONSTANT FilterHTML from text/tabwriter/tabwriter.go:
(def
  ^{:doc "Ignore html tags and treat entities (starting with '&'\nand ending in ';') as single characters (width = 1).\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(tabwriter.FilterHTML)"}
  FilterHTML)

JOKER CONSTANT StripEscape from text/tabwriter/tabwriter.go:
(def
  ^{:doc "Strip Escape characters bracketing escaped text segments\ninstead of passing them through unchanged with the text.\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(tabwriter.StripEscape)"}
  StripEscape)

JOKER CONSTANT TabIndent from text/tabwriter/tabwriter.go:
(def
  ^{:doc "Always use tabs for indentation columns (i.e., padding of\nleading empty cells on the left) independent of padchar.\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(tabwriter.TabIndent)"}
  TabIndent)

JOKER TYPE text/tabwriter.Writer from text/tabwriter/tabwriter.go:
(defn ^"GoObject" Writer.
  "Constructor for tabwriter.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC text/tabwriter.NewWriter from text/tabwriter/tabwriter.go:
;; (defn NewWriter
;;   "NewWriter allocates and initializes a new tabwriter.Writer.\nThe parameters are the same as for the Init function.\n\nGo input arguments: (output io.Writer, minwidth int, tabwidth int, padding int, padchar byte, flags uint)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer output, ^Int minwidth, ^Int tabwidth, ^Int padding, ^Int padchar, ^Number flags]\n\nJoker return type: (atom-of go.std.text.tabwriter/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*__output, __minwidth, __tabwidth, __padding, __padchar, __flags)"}
;;   [^io/Writer __output, ^Int __minwidth, ^Int __tabwidth, ^Int __padding, ^Byte __padchar, ^UInt __flags])

JOKER TYPE go.std.text.tabwriter/Writer:
(def
  ^{:doc "A Writer is a filter that inserts padding around tab-delimited\ncolumns in its input to align them in the output.\n\nThe Writer treats incoming bytes as UTF-8-encoded text consisting\nof cells terminated by horizontal ('\\t') or vertical ('\\v') tabs,\nand newline ('\\n') or formfeed ('\\f') characters; both newline and\nformfeed act as line breaks.\n\nTab-terminated cells in contiguous lines constitute a column. The\nWriter inserts padding as needed to make all cells in a column have\nthe same width, effectively aligning the columns. It assumes that\nall characters have the same width, except for tabs for which a\ntabwidth must be specified. Column cells must be tab-terminated, not\ntab-separated: non-tab terminated trailing text at the end of a line\nforms a cell but that cell is not part of an aligned column.\nFor instance, in this example (where | stands for a horizontal tab):\n\n\taaaa|bbb|d\n\taa  |b  |dd\n\ta   |\n\taa  |cccc|eee\n\nthe b and c are in distinct columns (the b column is not contiguous\nall the way). The d and e are not in a column at all (there's no\nterminating tab, nor would the column be contiguous).\n\nThe Writer assumes that all Unicode code points have the same width;\nthis may not be true in some fonts or if the string contains combining\ncharacters.\n\nIf DiscardEmptyColumns is set, empty columns that are terminated\nentirely by vertical (or \"soft\") tabs are discarded. Columns\nterminated by horizontal (or \"hard\") tabs are not affected by\nthis flag.\n\nIf a Writer is configured to filter HTML, HTML tags and entities\nare passed through. The widths of tags and entities are\nassumed to be zero (tags) and one (entities) for formatting purposes.\n\nA segment of text may be escaped by bracketing it with Escape\ncharacters. The tabwriter passes escaped text segments through\nunchanged. In particular, it does not interpret any tabs or line\nbreaks within the segment. If the StripEscape flag is set, the\nEscape characters are stripped from the output; otherwise they\nare passed through as well. For the purpose of formatting, the\nwidth of the escaped text is always computed excluding the Escape\ncharacters.\n\nThe formfeed character acts like a newline but it also terminates\nall columns in the current line (effectively calling Flush). Tab-\nterminated cells in the next line start new columns. Unless found\ninside an HTML tag or inside an escaped text segment, formfeed\ncharacters appear as newlines in the output.\n\nThe Writer must buffer input internally, because proper spacing\nof one line may depend on the cells in future lines. Clients must\ncall Flush when done calling Write.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Writer"}
  Writer)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["text/tabwriter"]
    :doc "Provides a low-level interface to the text/tabwriter package.\n\nPackage tabwriter implements a write filter (tabwriter.Writer) that\ntranslates tabbed columns in input into properly aligned text.\n\nThe package is using the Elastic Tabstops algorithm described at\nhttp://nickgravgaard.com/elastictabstops/index.html.\n\nThe text/tabwriter package is frozen and is not accepting new features.\n"
    :empty false}
  go.std.text.tabwriter)
;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["text/template"]
    :doc "Provides a low-level interface to the text/template package.\n\nPackage template implements data-driven templates for generating textual output.\n\nTo generate HTML output, see package html/template, which has the same interface\nas this package but automatically secures HTML output against certain attacks.\n\nTemplates are executed by applying them to a data structure. Annotations in the\ntemplate refer to elements of the data structure (typically a field of a struct\nor a key in a map) to control execution and derive values to be displayed.\nExecution of the template walks the structure and sets the cursor, represented\nby a period '.' and called \"dot\", to the value at the current location in the\nstructure as execution proceeds.\n\nThe input text for a template is UTF-8-encoded text in any format.\n\"Actions\"--data evaluations or control structures--are delimited by\n\"{{\" and \"}}\"; all text outside actions is copied to the output unchanged.\nExcept for raw strings, actions may not span newlines, although comments can.\n\nOnce parsed, a template may be executed safely in parallel, although if parallel\nexecutions share a Writer the output may be interleaved.\n\nHere is a trivial example that prints \"17 items are made of wool\".\n\n\ttype Inventory struct {\n\t\tMaterial string\n\t\tCount    uint\n\t}\n\tsweaters := Inventory{\"wool\", 17}\n\ttmpl, err := template.New(\"test\").Parse(\"{{.Count}} items are made of {{.Material}}\")\n\tif err != nil { panic(err) }\n\terr = tmpl.Execute(os.Stdout, sweaters)\n\tif err != nil { panic(err) }\n\nMore intricate examples appear below.\n\nText and spaces\n\nBy default, all text between actions is copied verbatim when the template is\nexecuted. For example, the string \" items are made of \" in the example above appears\non standard output when the program is run.\n\nHowever, to aid in formatting template source code, if an action's left delimiter\n(by default \"{{\") is followed immediately by a minus sign and ASCII space character\n(\"{{- \"), all trailing white space is trimmed from the immediately preceding text.\nSimilarly, if the right delimiter (\"}}\") is preceded by a space and minus sign\n(\" -}}\"), all leading white space is trimmed from the immediately following text.\nIn these trim markers, the ASCII space must be present; \"{{-3}}\" parses as an\naction containing the number -3.\n\nFor instance, when executing the template whose source is\n\n\t\"{{23 -}} < {{- 45}}\"\n\nthe generated output would be\n\n\t\"23<45\"\n\nFor this trimming, the definition of white space characters is the same as in Go:\nspace, horizontal tab, carriage return, and newline.\n\nActions\n\nHere is the list of actions. \"Arguments\" and \"pipelines\" are evaluations of\ndata, defined in detail in the corresponding sections that follow.\n\n\t{{/* a comment */}}\n\t{{- /* a comment with white space trimmed from preceding and following text */ -}}\n\t\tA comment; discarded. May contain newlines.\n\t\tComments do not nest and must start and end at the\n\t\tdelimiters, as shown here.\n\n\t{{pipeline}}\n\t\tThe default textual representation (the same as would be\n\t\tprinted by fmt.Print) of the value of the pipeline is copied\n\t\tto the output.\n\n\t{{if pipeline}} T1 {{end}}\n\t\tIf the value of the pipeline is empty, no output is generated;\n\t\totherwise, T1 is executed. The empty values are false, 0, any\n\t\tnil pointer or interface value, and any array, slice, map, or\n\t\tstring of length zero.\n\t\tDot is unaffected.\n\n\t{{if pipeline}} T1 {{else}} T0 {{end}}\n\t\tIf the value of the pipeline is empty, T0 is executed;\n\t\totherwise, T1 is executed. Dot is unaffected.\n\n\t{{if pipeline}} T1 {{else if pipeline}} T0 {{end}}\n\t\tTo simplify the appearance of if-else chains, the else action\n\t\tof an if may include another if directly; the effect is exactly\n\t\tthe same as writing\n\t\t\t{{if pipeline}} T1 {{else}}{{if pipeline}} T0 {{end}}{{end}}\n\n\t{{range pipeline}} T1 {{end}}\n\t\tThe value of the pipeline must be an array, slice, map, or channel.\n\t\tIf the value of the pipeline has length zero, nothing is output;\n\t\totherwise, dot is set to the successive elements of the array,\n\t\tslice, or map and T1 is executed. If the value is a map and the\n\t\tkeys are of basic type with a defined order (\"comparable\"), the\n\t\telements will be visited in sorted key order.\n\n\t{{range pipeline}} T1 {{else}} T0 {{end}}\n\t\tThe value of the pipeline must be an array, slice, map, or channel.\n\t\tIf the value of the pipeline has length zero, dot is unaffected and\n\t\tT0 is executed; otherwise, dot is set to the successive elements\n\t\tof the array, slice, or map and T1 is executed.\n\n\t{{template \"name\"}}\n\t\tThe template with the specified name is executed with nil data.\n\n\t{{template \"name\" pipeline}}\n\t\tThe template with the specified name is executed with dot set\n\t\tto the value of the pipeline.\n\n\t{{block \"name\" pipeline}} T1 {{end}}\n\t\tA block is shorthand for defining a template\n\t\t\t{{define \"name\"}} T1 {{end}}\n\t\tand then executing it in place\n\t\t\t{{template \"name\" pipeline}}\n\t\tThe typical use is to define a set of root templates that are\n\t\tthen customized by redefining the block templates within.\n\n\t{{with pipeline}} T1 {{end}}\n\t\tIf the value of the pipeline is empty, no output is generated;\n\t\totherwise, dot is set to the value of the pipeline and T1 is\n\t\texecuted.\n\n\t{{with pipeline}} T1 {{else}} T0 {{end}}\n\t\tIf the value of the pipeline is empty, dot is unaffected and T0\n\t\tis executed; otherwise, dot is set to the value of the pipeline\n\t\tand T1 is executed.\n\nArguments\n\nAn argument is a simple value, denoted by one of the following.\n\n\t- A boolean, string, character, integer, floating-point, imaginary\n\t  or complex constant in Go syntax. These behave like Go's untyped\n\t  constants. Note that, as in Go, whether a large integer constant\n\t  overflows when assigned or passed to a function can depend on whether\n\t  the host machine's ints are 32 or 64 bits.\n\t- The keyword nil, representing an untyped Go nil.\n\t- The character '.' (period):\n\t\t.\n\t  The result is the value of dot.\n\t- A variable name, which is a (possibly empty) alphanumeric string\n\t  preceded by a dollar sign, such as\n\t\t$piOver2\n\t  or\n\t\t$\n\t  The result is the value of the variable.\n\t  Variables are described below.\n\t- The name of a field of the data, which must be a struct, preceded\n\t  by a period, such as\n\t\t.Field\n\t  The result is the value of the field. Field invocations may be\n\t  chained:\n\t    .Field1.Field2\n\t  Fields can also be evaluated on variables, including chaining:\n\t    $x.Field1.Field2\n\t- The name of a key of the data, which must be a map, preceded\n\t  by a period, such as\n\t\t.Key\n\t  The result is the map element value indexed by the key.\n\t  Key invocations may be chained and combined with fields to any\n\t  depth:\n\t    .Field1.Key1.Field2.Key2\n\t  Although the key must be an alphanumeric identifier, unlike with\n\t  field names they do not need to start with an upper case letter.\n\t  Keys can also be evaluated on variables, including chaining:\n\t    $x.key1.key2\n\t- The name of a niladic method of the data, preceded by a period,\n\t  such as\n\t\t.Method\n\t  The result is the value of invoking the method with dot as the\n\t  receiver, dot.Method(). Such a method must have one return value (of\n\t  any type) or two return values, the second of which is an error.\n\t  If it has two and the returned error is non-nil, execution terminates\n\t  and an error is returned to the caller as the value of Execute.\n\t  Method invocations may be chained and combined with fields and keys\n\t  to any depth:\n\t    .Field1.Key1.Method1.Field2.Key2.Method2\n\t  Methods can also be evaluated on variables, including chaining:\n\t    $x.Method1.Field\n\t- The name of a niladic function, such as\n\t\tfun\n\t  The result is the value of invoking the function, fun(). The return\n\t  types and values behave as in methods. Functions and function\n\t  names are described below.\n\t- A parenthesized instance of one the above, for grouping. The result\n\t  may be accessed by a field or map key invocation.\n\t\tprint (.F1 arg1) (.F2 arg2)\n\t\t(.StructValuedMethod \"arg\").Field\n\nArguments may evaluate to any type; if they are pointers the implementation\nautomatically indirects to the base type when required.\nIf an evaluation yields a function value, such as a function-valued\nfield of a struct, the function is not invoked automatically, but it\ncan be used as a truth value for an if action and the like. To invoke\nit, use the call function, defined below.\n\nPipelines\n\nA pipeline is a possibly chained sequence of \"commands\". A command is a simple\nvalue (argument) or a function or method call, possibly with multiple arguments:\n\n\tArgument\n\t\tThe result is the value of evaluating the argument.\n\t.Method [Argument...]\n\t\tThe method can be alone or the last element of a chain but,\n\t\tunlike methods in the middle of a chain, it can take arguments.\n\t\tThe result is the value of calling the method with the\n\t\targuments:\n\t\t\tdot.Method(Argument1, etc.)\n\tfunctionName [Argument...]\n\t\tThe result is the value of calling the function associated\n\t\twith the name:\n\t\t\tfunction(Argument1, etc.)\n\t\tFunctions and function names are described below.\n\nA pipeline may be \"chained\" by separating a sequence of commands with pipeline\ncharacters '|'. In a chained pipeline, the result of each command is\npassed as the last argument of the following command. The output of the final\ncommand in the pipeline is the value of the pipeline.\n\nThe output of a command will be either one value or two values, the second of\nwhich has type error. If that second value is present and evaluates to\nnon-nil, execution terminates and the error is returned to the caller of\nExecute.\n\nVariables\n\nA pipeline inside an action may initialize a variable to capture the result.\nThe initialization has syntax\n\n\t$variable := pipeline\n\nwhere $variable is the name of the variable. An action that declares a\nvariable produces no output.\n\nVariables previously declared can also be assigned, using the syntax\n\n\t$variable = pipeline\n\nIf a \"range\" action initializes a variable, the variable is set to the\nsuccessive elements of the iteration. Also, a \"range\" may declare two\nvariables, separated by a comma:\n\n\trange $index, $element := pipeline\n\nin which case $index and $element are set to the successive values of the\narray/slice index or map key and element, respectively. Note that if there is\nonly one variable, it is assigned the element; this is opposite to the\nconvention in Go range clauses.\n\nA variable's scope extends to the \"end\" action of the control structure (\"if\",\n\"with\", or \"range\") in which it is declared, or to the end of the template if\nthere is no such control structure. A template invocation does not inherit\nvariables from the point of its invocation.\n\nWhen execution begins, $ is set to the data argument passed to Execute, that is,\nto the starting value of dot.\n\nExamples\n\nHere are some example one-line templates demonstrating pipelines and variables.\nAll produce the quoted word \"output\":\n\n\t{{\"\\\"output\\\"\"}}\n\t\tA string constant.\n\t{{`\"output\"`}}\n\t\tA raw string constant.\n\t{{printf \"%q\" \"output\"}}\n\t\tA function call.\n\t{{\"output\" | printf \"%q\"}}\n\t\tA function call whose final argument comes from the previous\n\t\tcommand.\n\t{{printf \"%q\" (print \"out\" \"put\")}}\n\t\tA parenthesized argument.\n\t{{\"put\" | printf \"%s%s\" \"out\" | printf \"%q\"}}\n\t\tA more elaborate call.\n\t{{\"output\" | printf \"%s\" | printf \"%q\"}}\n\t\tA longer chain.\n\t{{with \"output\"}}{{printf \"%q\" .}}{{end}}\n\t\tA with action using dot.\n\t{{with $x := \"output\" | printf \"%q\"}}{{$x}}{{end}}\n\t\tA with action that creates and uses a variable.\n\t{{with $x := \"output\"}}{{printf \"%q\" $x}}{{end}}\n\t\tA with action that uses the variable in another action.\n\t{{with $x := \"output\"}}{{$x | printf \"%q\"}}{{end}}\n\t\tThe same, but pipelined.\n\nFunctions\n\nDuring execution functions are found in two function maps: first in the\ntemplate, then in the global function map. By default, no functions are defined\nin the template but the Funcs method can be used to add them.\n\nPredefined global functions are named as follows.\n\n\tand\n\t\tReturns the boolean AND of its arguments by returning the\n\t\tfirst empty argument or the last argument, that is,\n\t\t\"and x y\" behaves as \"if x then y else x\". All the\n\t\targuments are evaluated.\n\tcall\n\t\tReturns the result of calling the first argument, which\n\t\tmust be a function, with the remaining arguments as parameters.\n\t\tThus \"call .X.Y 1 2\" is, in Go notation, dot.X.Y(1, 2) where\n\t\tY is a func-valued field, map entry, or the like.\n\t\tThe first argument must be the result of an evaluation\n\t\tthat yields a value of function type (as distinct from\n\t\ta predefined function such as print). The function must\n\t\treturn either one or two result values, the second of which\n\t\tis of type error. If the arguments don't match the function\n\t\tor the returned error value is non-nil, execution stops.\n\thtml\n\t\tReturns the escaped HTML equivalent of the textual\n\t\trepresentation of its arguments. This function is unavailable\n\t\tin html/template, with a few exceptions.\n\tindex\n\t\tReturns the result of indexing its first argument by the\n\t\tfollowing arguments. Thus \"index x 1 2 3\" is, in Go syntax,\n\t\tx[1][2][3]. Each indexed item must be a map, slice, or array.\n\tjs\n\t\tReturns the escaped JavaScript equivalent of the textual\n\t\trepresentation of its arguments.\n\tlen\n\t\tReturns the integer length of its argument.\n\tnot\n\t\tReturns the boolean negation of its single argument.\n\tor\n\t\tReturns the boolean OR of its arguments by returning the\n\t\tfirst non-empty argument or the last argument, that is,\n\t\t\"or x y\" behaves as \"if x then x else y\". All the\n\t\targuments are evaluated.\n\tprint\n\t\tAn alias for fmt.Sprint\n\tprintf\n\t\tAn alias for fmt.Sprintf\n\tprintln\n\t\tAn alias for fmt.Sprintln\n\turlquery\n\t\tReturns the escaped value of the textual representation of\n\t\tits arguments in a form suitable for embedding in a URL query.\n\t\tThis function is unavailable in html/template, with a few\n\t\texceptions.\n\nThe boolean functions take any zero value to be false and a non-zero\nvalue to be true.\n\nThere is also a set of binary comparison operators defined as\nfunctions:\n\n\teq\n\t\tReturns the boolean truth of arg1 == arg2\n\tne\n\t\tReturns the boolean truth of arg1 != arg2\n\tlt\n\t\tReturns the boolean truth of arg1 < arg2\n\tle\n\t\tReturns the boolean truth of arg1 <= arg2\n\tgt\n\t\tReturns the boolean truth of arg1 > arg2\n\tge\n\t\tReturns the boolean truth of arg1 >= arg2\n\nFor simpler multi-way equality tests, eq (only) accepts two or more\narguments and compares the second and subsequent to the first,\nreturning in effect\n\n\targ1==arg2 || arg1==arg3 || arg1==arg4 ...\n\n(Unlike with || in Go, however, eq is a function call and all the\narguments will be evaluated.)\n\nThe comparison functions work on basic types only (or named basic\ntypes, such as \"type Celsius float32\"). They implement the Go rules\nfor comparison of values, except that size and exact type are\nignored, so any integer value, signed or unsigned, may be compared\nwith any other integer value. (The arithmetic value is compared,\nnot the bit pattern, so all negative integers are less than all\nunsigned integers.) However, as usual, one may not compare an int\nwith a float32 and so on.\n\nAssociated templates\n\nEach template is named by a string specified when it is created. Also, each\ntemplate is associated with zero or more other templates that it may invoke by\nname; such associations are transitive and form a name space of templates.\n\nA template may use a template invocation to instantiate another associated\ntemplate; see the explanation of the \"template\" action above. The name must be\nthat of a template associated with the template that contains the invocation.\n\nNested template definitions\n\nWhen parsing a template, another template may be defined and associated with the\ntemplate being parsed. Template definitions must appear at the top level of the\ntemplate, much like global variables in a Go program.\n\nThe syntax of such definitions is to surround each template declaration with a\n\"define\" and \"end\" action.\n\nThe define action names the template being created by providing a string\nconstant. Here is a simple example:\n\n\t`{{define \"T1\"}}ONE{{end}}\n\t{{define \"T2\"}}TWO{{end}}\n\t{{define \"T3\"}}{{template \"T1\"}} {{template \"T2\"}}{{end}}\n\t{{template \"T3\"}}`\n\nThis defines two templates, T1 and T2, and a third T3 that invokes the other two\nwhen it is executed. Finally it invokes T3. If executed this template will\nproduce the text\n\n\tONE TWO\n\nBy construction, a template may reside in only one association. If it's\nnecessary to have a template addressable from multiple associations, the\ntemplate definition must be parsed multiple times to create distinct *Template\nvalues, or must be copied with the Clone or AddParseTree method.\n\nParse may be called multiple times to assemble the various associated templates;\nsee the ParseFiles and ParseGlob functions and methods for simple ways to parse\nrelated templates stored in files.\n\nA template may be executed directly or through ExecuteTemplate, which executes\nan associated template identified by name. To invoke our example above, we\nmight write,\n\n\terr := tmpl.Execute(os.Stdout, \"no data needed\")\n\tif err != nil {\n\t\tlog.Fatalf(\"execution failed: %s\", err)\n\t}\n\nor to invoke a particular template explicitly by name,\n\n\terr := tmpl.ExecuteTemplate(os.Stdout, \"T2\", \"no data needed\")\n\tif err != nil {\n\t\tlog.Fatalf(\"execution failed: %s\", err)\n\t}\n"
    :empty false}
  go.std.text.template)
JOKER TYPE text/template.ExecError from text/template/exec.go:
(defn ^"GoObject" ExecError.
  "Constructor for template.ExecError"
  {:added "1.0"
   :go "_ConstructExecError(_v)"}
  [^Object _v])

JOKER TYPE text/template.FuncMap from text/template/funcs.go:
;; (defn ^"GoObject" FuncMap.
;;   "Constructor for template.FuncMap"
;;   {:added "1.0"
;;    :go "_ConstructFuncMap(_v)"}
;;   [^Object _v])

JOKER TYPE text/template.Template from text/template/template.go:
(defn ^"GoObject" Template.
  "Constructor for template.Template"
  {:added "1.0"
   :go "_ConstructTemplate(_v)"}
  [^Object _v])

JOKER FUNC text/template.HTMLEscape from text/template/funcs.go:
;; (defn HTMLEscape
;;   "HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.\n\nGo input arguments: (w io.Writer, b []byte)\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Int) b]"
;;   {:added "1.0"
;;    :go "__hTMLEscape(*__w, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))"}
;;   [^io/Writer __w, ^Object __b])

JOKER FUNC text/template.HTMLEscapeString from text/template/funcs.go:
(defn ^"String" HTMLEscapeString
  "HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "template.HTMLEscapeString(__s)"}
  [^String __s])

JOKER FUNC text/template.HTMLEscaper from text/template/funcs.go:
;; (defn ^"String" HTMLEscaper
;;   "HTMLEscaper returns the escaped HTML equivalent of the textual\nrepresentation of its arguments.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.HTMLEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> __args])

JOKER FUNC text/template.IsTrue from text/template/exec.go:
;; (defn IsTrue
;;   "IsTrue reports whether the value is 'true', in the sense of not the zero of its type,\nand whether the value has a meaningful truth value. This is the definition of\ntruth used by if and other such actions.\n\nGo input arguments: (val interface {})\n\nGo return type: (truth bool, ok bool)\n\nJoker input arguments: [^<protocol-or-something> val]\n\nJoker return type: [Boolean Boolean]"
;;   {:added "1.0"
;;    :go "__isTrue(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> __val])

JOKER FUNC text/template.JSEscape from text/template/funcs.go:
;; (defn JSEscape
;;   "JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.\n\nGo input arguments: (w io.Writer, b []byte)\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Int) b]"
;;   {:added "1.0"
;;    :go "__jSEscape(*__w, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))"}
;;   [^io/Writer __w, ^Object __b])

JOKER FUNC text/template.JSEscapeString from text/template/funcs.go:
(defn ^"String" JSEscapeString
  "JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "template.JSEscapeString(__s)"}
  [^String __s])

JOKER FUNC text/template.JSEscaper from text/template/funcs.go:
;; (defn ^"String" JSEscaper
;;   "JSEscaper returns the escaped JavaScript equivalent of the textual\nrepresentation of its arguments.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.JSEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> __args])

JOKER FUNC text/template.Must from text/template/helper.go:
(defn Must
  "Must is a helper that wraps a call to a function returning (*Template, error)\nand panics if the error is non-nil. It is intended for use in variable\ninitializations such as\n\tvar t = template.Must(template.New(\"name\").Parse(\"text\"))\n\nGo input arguments: (t *Template, err error)\n\nGo return type: *Template\n\nJoker input arguments: [^(atom-of go.std.text.template/Template) t, ^Error err]\n\nJoker return type: (atom-of go.std.text.template/Template)"
  {:added "1.0"
   :go "__must(__t, __err)"}
  [^template/Template __t, ^Error __err])

JOKER FUNC text/template.New from text/template/template.go:
(defn New
  "New allocates a new, undefined template with the given name.\n\nGo input arguments: (name string)\n\nGo return type: *Template\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.text.template/Template)"
  {:added "1.0"
   :go "__new(__name)"}
  [^String __name])

JOKER FUNC text/template.ParseFiles from text/template/helper.go:
;; (defn ParseFiles
;;   "ParseFiles creates a new Template and parses the template definitions from\nthe named files. The returned template's name will have the base name and\nparsed contents of the first file. There must be at least one file.\nIf an error occurs, parsing stops and the returned *Template is nil.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\nFor instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template\nnamed \"foo\", while \"a/foo\" is unavailable.\n\nGo input arguments: (filenames ...string)\n\nGo return type: (*Template, error)\n\nJoker input arguments: [^(ellipsis-somehow String) filenames]\n\nJoker return type: [(atom-of go.std.text.template/Template) Error]"
;;   {:added "1.0"
;;    :go "__parseFiles(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(__filenames)))"}
;;   [^String __filenames])

JOKER FUNC text/template.ParseGlob from text/template/helper.go:
(defn ParseGlob
  "ParseGlob creates a new Template and parses the template definitions from the\nfiles identified by the pattern, which must match at least one file. The\nreturned template will have the (base) name and (parsed) contents of the\nfirst file matched by the pattern. ParseGlob is equivalent to calling\nParseFiles with the list of files matched by the pattern.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\n\nGo input arguments: (pattern string)\n\nGo return type: (*Template, error)\n\nJoker input arguments: [^String pattern]\n\nJoker return type: [(atom-of go.std.text.template/Template) Error]"
  {:added "1.0"
   :go "__parseGlob(__pattern)"}
  [^String __pattern])

JOKER FUNC text/template.URLQueryEscaper from text/template/funcs.go:
;; (defn ^"String" URLQueryEscaper
;;   "URLQueryEscaper returns the escaped value of the textual representation of\nits arguments in a form suitable for embedding in a URL query.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.URLQueryEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> __args])

JOKER TYPE go.std.text.template/ExecError:
(def
  ^{:doc "ExecError is the custom error type returned when Execute has an\nerror evaluating its template. (If a write error occurs, the actual\nerror is returned; it will not be of type ExecError.)\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ExecError"}
  ExecError)

JOKER TYPE go.std.text.template/FuncMap:
(def
  ^{:doc "FuncMap is the type of the map defining the mapping from names to functions.\nEach function must have either a single return value, or two return values of\nwhich the second has type error. In that case, if the second (error)\nreturn value evaluates to non-nil during execution, execution terminates and\nExecute returns that error.\n\nWhen template execution invokes a function with an argument list, that list\nmust be assignable to the function's parameter types. Functions meant to\napply to arguments of arbitrary type can use parameters of type interface{} or\nof type reflect.Value. Similarly, functions meant to return a result of arbitrary\ntype can return interface{} or reflect.Value.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FuncMap"}
  FuncMap)

JOKER TYPE go.std.text.template/Template:
(def
  ^{:doc "Template is the representation of a parsed template. The *parse.Tree\nfield is exported only for use by html/template and should be treated\nas unexported by all other clients.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Template"}
  Template)

JOKER CONSTANT NodeAction from text/template/parse/node.go:
(def
  ^{:doc "A non-control action such as a field evaluation.\n"
    :added "1.0"
    :tag "Int"
    :go "int(parse.NodeAction)"}
  NodeAction)

JOKER CONSTANT NodeBool from text/template/parse/node.go:
(def
  ^{:doc "A boolean constant.\n"
    :added "1.0"
    :tag "Int"
    :go "int(parse.NodeBool)"}
  NodeBool)

JOKER CONSTANT NodeChain from text/template/parse/node.go:
(def
  ^{:doc "A sequence of field accesses.\n"
    :added "1.0"
    :tag "Int"
    :go "int(parse.NodeChain)"}
  NodeChain)

JOKER CONSTANT NodeCommand from text/template/parse/node.go:
(def
  ^{:doc "An element of a pipeline.\n"
    :added "1.0"
    :tag "Int"
    :go "int(parse.NodeCommand)"}
  NodeCommand)

JOKER CONSTANT NodeDot from text/template/parse/node.go:
(def
  ^{:doc "The cursor, dot.\n"
    :added "1.0"
    :tag "Int"
    :go "int(parse.NodeDot)"}
  NodeDot)

JOKER CONSTANT NodeField from text/template/parse/node.go:
(def
  ^{:doc "A field or method name.\n"
    :added "1.0"
    :tag "Int"
    :go "int(parse.NodeField)"}
  NodeField)

JOKER CONSTANT NodeIdentifier from text/template/parse/node.go:
(def
  ^{:doc "An identifier; always a function name.\n"
    :added "1.0"
    :tag "Int"
    :go "int(parse.NodeIdentifier)"}
  NodeIdentifier)

JOKER CONSTANT NodeIf from text/template/parse/node.go:
(def
  ^{:doc "An if action.\n"
    :added "1.0"
    :tag "Int"
    :go "int(parse.NodeIf)"}
  NodeIf)

JOKER CONSTANT NodeList from text/template/parse/node.go:
(def
  ^{:doc "A list of Nodes.\n"
    :added "1.0"
    :tag "Int"
    :go "int(parse.NodeList)"}
  NodeList)

JOKER CONSTANT NodeNil from text/template/parse/node.go:
(def
  ^{:doc "An untyped nil constant.\n"
    :added "1.0"
    :tag "Int"
    :go "int(parse.NodeNil)"}
  NodeNil)

JOKER CONSTANT NodeNumber from text/template/parse/node.go:
(def
  ^{:doc "A numerical constant.\n"
    :added "1.0"
    :tag "Int"
    :go "int(parse.NodeNumber)"}
  NodeNumber)

JOKER CONSTANT NodePipe from text/template/parse/node.go:
(def
  ^{:doc "A pipeline of commands.\n"
    :added "1.0"
    :tag "Int"
    :go "int(parse.NodePipe)"}
  NodePipe)

JOKER CONSTANT NodeRange from text/template/parse/node.go:
(def
  ^{:doc "A range action.\n"
    :added "1.0"
    :tag "Int"
    :go "int(parse.NodeRange)"}
  NodeRange)

JOKER CONSTANT NodeString from text/template/parse/node.go:
(def
  ^{:doc "A string constant.\n"
    :added "1.0"
    :tag "Int"
    :go "int(parse.NodeString)"}
  NodeString)

JOKER CONSTANT NodeTemplate from text/template/parse/node.go:
(def
  ^{:doc "A template invocation action.\n"
    :added "1.0"
    :tag "Int"
    :go "int(parse.NodeTemplate)"}
  NodeTemplate)

JOKER CONSTANT NodeText from text/template/parse/node.go:
(def
  ^{:doc "Plain text.\n"
    :added "1.0"
    :tag "Int"
    :go "int(parse.NodeText)"}
  NodeText)

JOKER CONSTANT NodeVariable from text/template/parse/node.go:
(def
  ^{:doc "A $ variable.\n"
    :added "1.0"
    :tag "Int"
    :go "int(parse.NodeVariable)"}
  NodeVariable)

JOKER CONSTANT NodeWith from text/template/parse/node.go:
(def
  ^{:doc "A with action.\n"
    :added "1.0"
    :tag "Int"
    :go "int(parse.NodeWith)"}
  NodeWith)

JOKER TYPE text/template/parse.ActionNode from text/template/parse/node.go:
;; (defn ^"GoObject" ActionNode.
;;   "Constructor for parse.ActionNode"
;;   {:added "1.0"
;;    :go "_ConstructActionNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.BoolNode from text/template/parse/node.go:
(defn ^"GoObject" BoolNode.
  "Constructor for parse.BoolNode"
  {:added "1.0"
   :go "_ConstructBoolNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.BranchNode from text/template/parse/node.go:
;; (defn ^"GoObject" BranchNode.
;;   "Constructor for parse.BranchNode"
;;   {:added "1.0"
;;    :go "_ConstructBranchNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.ChainNode from text/template/parse/node.go:
;; (defn ^"GoObject" ChainNode.
;;   "Constructor for parse.ChainNode"
;;   {:added "1.0"
;;    :go "_ConstructChainNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.CommandNode from text/template/parse/node.go:
;; (defn ^"GoObject" CommandNode.
;;   "Constructor for parse.CommandNode"
;;   {:added "1.0"
;;    :go "_ConstructCommandNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.DotNode from text/template/parse/node.go:
(defn ^"GoObject" DotNode.
  "Constructor for parse.DotNode"
  {:added "1.0"
   :go "_ConstructDotNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.FieldNode from text/template/parse/node.go:
;; (defn ^"GoObject" FieldNode.
;;   "Constructor for parse.FieldNode"
;;   {:added "1.0"
;;    :go "_ConstructFieldNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.IdentifierNode from text/template/parse/node.go:
(defn ^"GoObject" IdentifierNode.
  "Constructor for parse.IdentifierNode"
  {:added "1.0"
   :go "_ConstructIdentifierNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.IfNode from text/template/parse/node.go:
(defn ^"GoObject" IfNode.
  "Constructor for parse.IfNode"
  {:added "1.0"
   :go "_ConstructIfNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.ListNode from text/template/parse/node.go:
;; (defn ^"GoObject" ListNode.
;;   "Constructor for parse.ListNode"
;;   {:added "1.0"
;;    :go "_ConstructListNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.NilNode from text/template/parse/node.go:
(defn ^"GoObject" NilNode.
  "Constructor for parse.NilNode"
  {:added "1.0"
   :go "_ConstructNilNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.Node from text/template/parse/node.go:
;; (defn ^"GoObject" Node.
;;   "Constructor for parse.Node"
;;   {:added "1.0"
;;    :go "_ConstructNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.NodeType from text/template/parse/node.go:
(defn ^"GoObject" NodeType.
  "Constructor for parse.NodeType"
  {:added "1.0"
   :go "_ConstructNodeType(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.NumberNode from text/template/parse/node.go:
;; (defn ^"GoObject" NumberNode.
;;   "Constructor for parse.NumberNode"
;;   {:added "1.0"
;;    :go "_ConstructNumberNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.PipeNode from text/template/parse/node.go:
;; (defn ^"GoObject" PipeNode.
;;   "Constructor for parse.PipeNode"
;;   {:added "1.0"
;;    :go "_ConstructPipeNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.Pos from text/template/parse/node.go:
(defn ^"GoObject" Pos.
  "Constructor for parse.Pos"
  {:added "1.0"
   :go "_ConstructPos(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.RangeNode from text/template/parse/node.go:
(defn ^"GoObject" RangeNode.
  "Constructor for parse.RangeNode"
  {:added "1.0"
   :go "_ConstructRangeNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.StringNode from text/template/parse/node.go:
(defn ^"GoObject" StringNode.
  "Constructor for parse.StringNode"
  {:added "1.0"
   :go "_ConstructStringNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.TemplateNode from text/template/parse/node.go:
;; (defn ^"GoObject" TemplateNode.
;;   "Constructor for parse.TemplateNode"
;;   {:added "1.0"
;;    :go "_ConstructTemplateNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.TextNode from text/template/parse/node.go:
;; (defn ^"GoObject" TextNode.
;;   "Constructor for parse.TextNode"
;;   {:added "1.0"
;;    :go "_ConstructTextNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.Tree from text/template/parse/parse.go:
;; (defn ^"GoObject" Tree.
;;   "Constructor for parse.Tree"
;;   {:added "1.0"
;;    :go "_ConstructTree(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.VariableNode from text/template/parse/node.go:
;; (defn ^"GoObject" VariableNode.
;;   "Constructor for parse.VariableNode"
;;   {:added "1.0"
;;    :go "_ConstructVariableNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.WithNode from text/template/parse/node.go:
(defn ^"GoObject" WithNode.
  "Constructor for parse.WithNode"
  {:added "1.0"
   :go "_ConstructWithNode(_v)"}
  [^Object _v])

JOKER FUNC text/template/parse.IsEmptyTree from text/template/parse/parse.go:
(defn ^"Boolean" IsEmptyTree
  "IsEmptyTree reports whether this tree (node) is empty of everything but space.\n\nGo input arguments: (n Node)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.text.template.parse/Node n]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "parse.IsEmptyTree(*__n)"}
  [^parse/Node __n])

JOKER FUNC text/template/parse.New from text/template/parse/parse.go:
;; (defn New
;;   "New allocates a new parse tree with the given name.\n\nGo input arguments: (name string, funcs ...map[])\n\nGo return type: *Tree\n\nJoker input arguments: [^String name, ^(ellipsis-somehow {}) funcs]\n\nJoker return type: (atom-of go.std.text.template.parse/Tree)"
;;   {:added "1.0"
;;    :go "__new(__name, ConvertToEllipsisHaHamap[](ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa())))"}
;;   [^String __name, ^{} __funcs])

JOKER FUNC text/template/parse.NewIdentifier from text/template/parse/node.go:
(defn NewIdentifier
  "NewIdentifier returns a new IdentifierNode with the given identifier name.\n\nGo input arguments: (ident string)\n\nGo return type: *IdentifierNode\n\nJoker input arguments: [^String ident]\n\nJoker return type: (atom-of go.std.text.template.parse/IdentifierNode)"
  {:added "1.0"
   :go "__newIdentifier(__ident)"}
  [^String __ident])

JOKER FUNC text/template/parse.Parse from text/template/parse/parse.go:
;; (defn Parse
;;   "Parse returns a map from template name to parse.Tree, created by parsing the\ntemplates described in the argument string. The top-level template will be\ngiven the specified name. If an error is encountered, parsing stops and an\nempty map is returned with the error.\n\nGo input arguments: (name string, text string, leftDelim string, rightDelim string, funcs ...map[])\n\nGo return type: (..., error)\n\nJoker input arguments: [^String name, ^String text, ^String leftDelim, ^String rightDelim, ^(ellipsis-somehow {}) funcs]\n\nJoker return type: [ABEND883(post.go: unrecognized Expr type *ast.MapType at: /usr/local/go/src/text/template/parse/parse.go:51:88) Error]"
;;   {:added "1.0"
;;    :go "__parse(__name, __text, __leftDelim, __rightDelim, ConvertToEllipsisHaHamap[](ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa())))"}
;;   [^String __name, ^String __text, ^String __leftDelim, ^String __rightDelim, ^{} __funcs])

JOKER TYPE go.std.text.template.parse/ActionNode:
(def
  ^{:doc "ActionNode holds an action (something bounded by delimiters).\nControl actions have their own nodes; ActionNode represents simple\nones such as field evaluations and parenthesized pipelines.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ActionNode"}
  ActionNode)

JOKER TYPE go.std.text.template.parse/BoolNode:
(def
  ^{:doc "BoolNode holds a boolean constant.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BoolNode"}
  BoolNode)

JOKER TYPE go.std.text.template.parse/BranchNode:
(def
  ^{:doc "BranchNode is the common representation of if, range, and with.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BranchNode"}
  BranchNode)

JOKER TYPE go.std.text.template.parse/ChainNode:
(def
  ^{:doc "ChainNode holds a term followed by a chain of field accesses (identifier starting with '.').\nThe names may be chained ('.x.y').\nThe periods are dropped from each ident.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ChainNode"}
  ChainNode)

JOKER TYPE go.std.text.template.parse/CommandNode:
(def
  ^{:doc "CommandNode holds a command (a pipeline inside an evaluating action).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CommandNode"}
  CommandNode)

JOKER TYPE go.std.text.template.parse/DotNode:
(def
  ^{:doc "DotNode holds the special identifier '.'.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DotNode"}
  DotNode)

JOKER TYPE go.std.text.template.parse/FieldNode:
(def
  ^{:doc "FieldNode holds a field (identifier starting with '.').\nThe names may be chained ('.x.y').\nThe period is dropped from each ident.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FieldNode"}
  FieldNode)

JOKER TYPE go.std.text.template.parse/IdentifierNode:
(def
  ^{:doc "IdentifierNode holds an identifier.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IdentifierNode"}
  IdentifierNode)

JOKER TYPE go.std.text.template.parse/IfNode:
(def
  ^{:doc "IfNode represents an {{if}} action and its commands.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IfNode"}
  IfNode)

JOKER TYPE go.std.text.template.parse/ListNode:
(def
  ^{:doc "ListNode holds a sequence of nodes.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ListNode"}
  ListNode)

JOKER TYPE go.std.text.template.parse/NilNode:
(def
  ^{:doc "NilNode holds the special identifier 'nil' representing an untyped nil constant.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NilNode"}
  NilNode)

JOKER TYPE go.std.text.template.parse/Node:
(def
  ^{:doc "A Node is an element in the parse tree. The interface is trivial.\nThe interface contains an unexported method so that only\ntypes local to this package can satisfy it.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Node"}
  Node)

JOKER TYPE go.std.text.template.parse/NodeType:
(def
  ^{:doc "NodeType identifies the type of a parse tree node.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NodeType"}
  NodeType)

JOKER TYPE go.std.text.template.parse/NumberNode:
(def
  ^{:doc "NumberNode holds a number: signed or unsigned integer, float, or complex.\nThe value is parsed and stored under all the types that can represent the value.\nThis simulates in a small amount of code the behavior of Go's ideal constants.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NumberNode"}
  NumberNode)

JOKER TYPE go.std.text.template.parse/PipeNode:
(def
  ^{:doc "PipeNode holds a pipeline with optional declaration\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PipeNode"}
  PipeNode)

JOKER TYPE go.std.text.template.parse/Pos:
(def
  ^{:doc "Pos represents a byte position in the original input text from which\nthis template was parsed.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Pos"}
  Pos)

JOKER TYPE go.std.text.template.parse/RangeNode:
(def
  ^{:doc "RangeNode represents a {{range}} action and its commands.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RangeNode"}
  RangeNode)

JOKER TYPE go.std.text.template.parse/StringNode:
(def
  ^{:doc "StringNode holds a string constant. The value has been \"unquoted\".\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_StringNode"}
  StringNode)

JOKER TYPE go.std.text.template.parse/TemplateNode:
(def
  ^{:doc "TemplateNode represents a {{template}} action.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TemplateNode"}
  TemplateNode)

JOKER TYPE go.std.text.template.parse/TextNode:
(def
  ^{:doc "TextNode holds plain text.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TextNode"}
  TextNode)

JOKER TYPE go.std.text.template.parse/Tree:
(def
  ^{:doc "Tree is the representation of a single parsed template.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Tree"}
  Tree)

JOKER TYPE go.std.text.template.parse/VariableNode:
(def
  ^{:doc "AssignNode holds a list of variable names, possibly with chained field\naccesses. The dollar sign is part of the (first) name.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_VariableNode"}
  VariableNode)

JOKER TYPE go.std.text.template.parse/WithNode:
(def
  ^{:doc "WithNode represents a {{with}} action and its commands.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_WithNode"}
  WithNode)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["text/template/parse"]
    :doc "Provides a low-level interface to the text/template/parse package.\n\nPackage parse builds parse trees for templates as defined by text/template\nand html/template. Clients should use those packages to construct templates\nrather than this one, which provides shared internal data structures not\nintended for general use.\n"
    :empty false}
  go.std.text.template.parse)
JOKER CONSTANT ANSIC from time/format.go:
(def
  ^{:doc "These are predefined layouts for use in Time.Format and time.Parse.\nThe reference time used in the layouts is the specific time:\n\tMon Jan 2 15:04:05 MST 2006\nwhich is Unix time 1136239445. Since MST is GMT-0700,\nthe reference time can be thought of as\n\t01/02 03:04:05PM '06 -0700\nTo define your own format, write down what the reference time would look\nlike formatted your way; see the values of constants like ANSIC,\nStampMicro or Kitchen for examples. The model is to demonstrate what the\nreference time looks like so that the Format and Parse methods can apply\nthe same transformation to a general time value.\n\nSome valid layouts are invalid time values for time.Parse, due to formats\nsuch as _ for space padding and Z for zone information.\n\nWithin the format string, an underscore _ represents a space that may be\nreplaced by a digit if the following number (a day) has two digits; for\ncompatibility with fixed-width Unix time formats.\n\nA decimal point followed by one or more zeros represents a fractional\nsecond, printed to the given number of decimal places. A decimal point\nfollowed by one or more nines represents a fractional second, printed to\nthe given number of decimal places, with trailing zeros removed.\nWhen parsing (only), the input may contain a fractional second\nfield immediately after the seconds field, even if the layout does not\nsignify its presence. In that case a decimal point followed by a maximal\nseries of digits is parsed as a fractional second.\n\nNumeric time zone offsets format as follows:\n\t-0700  ±hhmm\n\t-07:00 ±hh:mm\n\t-07    ±hh\nReplacing the sign in the format with a Z triggers\nthe ISO 8601 behavior of printing Z instead of an\noffset for the UTC zone. Thus:\n\tZ0700  Z or ±hhmm\n\tZ07:00 Z or ±hh:mm\n\tZ07    Z or ±hh\n\nThe recognized day of week formats are \"Mon\" and \"Monday\".\nThe recognized month formats are \"Jan\" and \"January\".\n\nText in the format string that is not recognized as part of the reference\ntime is echoed verbatim during Format and expected to appear verbatim\nin the input to Parse.\n\nThe executable example for Time.Format demonstrates the working\nof the layout string in detail and is a good reference.\n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied\nonly to local times. Applying them to UTC times will use \"UTC\" as the\ntime zone abbreviation, while strictly speaking those RFCs require the\nuse of \"GMT\" in that case.\nIn general RFC1123Z should be used instead of RFC1123 for servers\nthat insist on that format, and RFC3339 should be preferred for new protocols.\nRFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;\nwhen used with time.Parse they do not accept all the time formats\npermitted by the RFCs.\nThe RFC3339Nano format removes trailing zeros from the seconds field\nand thus may not sort correctly once formatted.\n"
    :added "1.0"
    :tag "String"
    :go "time.ANSIC"}
  ANSIC)

JOKER CONSTANT April from time/time.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(time.April)"}
  April)

JOKER CONSTANT August from time/time.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(time.August)"}
  August)

JOKER CONSTANT December from time/time.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(time.December)"}
  December)

JOKER CONSTANT February from time/time.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(time.February)"}
  February)

JOKER CONSTANT Friday from time/time.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(time.Friday)"}
  Friday)

JOKER CONSTANT Hour from time/time.go:
(def
  ^{:doc "Common durations. There is no definition for units of Day or larger\nto avoid confusion across daylight savings time zone transitions.\n\nTo count the number of units in a Duration, divide:\n\tsecond := time.Second\n\tfmt.Print(int64(second/time.Millisecond)) // prints 1000\n\nTo convert an integer number of units to a Duration, multiply:\n\tseconds := 10\n\tfmt.Print(time.Duration(seconds)*time.Second) // prints 10s\n"
    :added "1.0"
    :tag "Number"
    :go "int64(int64(time.Hour))"}
  Hour)

JOKER CONSTANT January from time/time.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(time.January)"}
  January)

JOKER CONSTANT July from time/time.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(time.July)"}
  July)

JOKER CONSTANT June from time/time.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(time.June)"}
  June)

JOKER CONSTANT Kitchen from time/format.go:
(def
  ^{:doc "These are predefined layouts for use in Time.Format and time.Parse.\nThe reference time used in the layouts is the specific time:\n\tMon Jan 2 15:04:05 MST 2006\nwhich is Unix time 1136239445. Since MST is GMT-0700,\nthe reference time can be thought of as\n\t01/02 03:04:05PM '06 -0700\nTo define your own format, write down what the reference time would look\nlike formatted your way; see the values of constants like ANSIC,\nStampMicro or Kitchen for examples. The model is to demonstrate what the\nreference time looks like so that the Format and Parse methods can apply\nthe same transformation to a general time value.\n\nSome valid layouts are invalid time values for time.Parse, due to formats\nsuch as _ for space padding and Z for zone information.\n\nWithin the format string, an underscore _ represents a space that may be\nreplaced by a digit if the following number (a day) has two digits; for\ncompatibility with fixed-width Unix time formats.\n\nA decimal point followed by one or more zeros represents a fractional\nsecond, printed to the given number of decimal places. A decimal point\nfollowed by one or more nines represents a fractional second, printed to\nthe given number of decimal places, with trailing zeros removed.\nWhen parsing (only), the input may contain a fractional second\nfield immediately after the seconds field, even if the layout does not\nsignify its presence. In that case a decimal point followed by a maximal\nseries of digits is parsed as a fractional second.\n\nNumeric time zone offsets format as follows:\n\t-0700  ±hhmm\n\t-07:00 ±hh:mm\n\t-07    ±hh\nReplacing the sign in the format with a Z triggers\nthe ISO 8601 behavior of printing Z instead of an\noffset for the UTC zone. Thus:\n\tZ0700  Z or ±hhmm\n\tZ07:00 Z or ±hh:mm\n\tZ07    Z or ±hh\n\nThe recognized day of week formats are \"Mon\" and \"Monday\".\nThe recognized month formats are \"Jan\" and \"January\".\n\nText in the format string that is not recognized as part of the reference\ntime is echoed verbatim during Format and expected to appear verbatim\nin the input to Parse.\n\nThe executable example for Time.Format demonstrates the working\nof the layout string in detail and is a good reference.\n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied\nonly to local times. Applying them to UTC times will use \"UTC\" as the\ntime zone abbreviation, while strictly speaking those RFCs require the\nuse of \"GMT\" in that case.\nIn general RFC1123Z should be used instead of RFC1123 for servers\nthat insist on that format, and RFC3339 should be preferred for new protocols.\nRFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;\nwhen used with time.Parse they do not accept all the time formats\npermitted by the RFCs.\nThe RFC3339Nano format removes trailing zeros from the seconds field\nand thus may not sort correctly once formatted.\n"
    :added "1.0"
    :tag "String"
    :go "time.Kitchen"}
  Kitchen)

JOKER CONSTANT March from time/time.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(time.March)"}
  March)

JOKER CONSTANT May from time/time.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(time.May)"}
  May)

JOKER CONSTANT Microsecond from time/time.go:
(def
  ^{:doc "Common durations. There is no definition for units of Day or larger\nto avoid confusion across daylight savings time zone transitions.\n\nTo count the number of units in a Duration, divide:\n\tsecond := time.Second\n\tfmt.Print(int64(second/time.Millisecond)) // prints 1000\n\nTo convert an integer number of units to a Duration, multiply:\n\tseconds := 10\n\tfmt.Print(time.Duration(seconds)*time.Second) // prints 10s\n"
    :added "1.0"
    :tag "Number"
    :go "int64(int64(time.Microsecond))"}
  Microsecond)

JOKER CONSTANT Millisecond from time/time.go:
(def
  ^{:doc "Common durations. There is no definition for units of Day or larger\nto avoid confusion across daylight savings time zone transitions.\n\nTo count the number of units in a Duration, divide:\n\tsecond := time.Second\n\tfmt.Print(int64(second/time.Millisecond)) // prints 1000\n\nTo convert an integer number of units to a Duration, multiply:\n\tseconds := 10\n\tfmt.Print(time.Duration(seconds)*time.Second) // prints 10s\n"
    :added "1.0"
    :tag "Number"
    :go "int64(int64(time.Millisecond))"}
  Millisecond)

JOKER CONSTANT Minute from time/time.go:
(def
  ^{:doc "Common durations. There is no definition for units of Day or larger\nto avoid confusion across daylight savings time zone transitions.\n\nTo count the number of units in a Duration, divide:\n\tsecond := time.Second\n\tfmt.Print(int64(second/time.Millisecond)) // prints 1000\n\nTo convert an integer number of units to a Duration, multiply:\n\tseconds := 10\n\tfmt.Print(time.Duration(seconds)*time.Second) // prints 10s\n"
    :added "1.0"
    :tag "Number"
    :go "int64(int64(time.Minute))"}
  Minute)

JOKER CONSTANT Monday from time/time.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(time.Monday)"}
  Monday)

JOKER CONSTANT Nanosecond from time/time.go:
(def
  ^{:doc "Common durations. There is no definition for units of Day or larger\nto avoid confusion across daylight savings time zone transitions.\n\nTo count the number of units in a Duration, divide:\n\tsecond := time.Second\n\tfmt.Print(int64(second/time.Millisecond)) // prints 1000\n\nTo convert an integer number of units to a Duration, multiply:\n\tseconds := 10\n\tfmt.Print(time.Duration(seconds)*time.Second) // prints 10s\n"
    :added "1.0"
    :tag "Number"
    :go "int64(int64(time.Nanosecond))"}
  Nanosecond)

JOKER CONSTANT November from time/time.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(time.November)"}
  November)

JOKER CONSTANT October from time/time.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(time.October)"}
  October)

JOKER CONSTANT RFC1123 from time/format.go:
(def
  ^{:doc "These are predefined layouts for use in Time.Format and time.Parse.\nThe reference time used in the layouts is the specific time:\n\tMon Jan 2 15:04:05 MST 2006\nwhich is Unix time 1136239445. Since MST is GMT-0700,\nthe reference time can be thought of as\n\t01/02 03:04:05PM '06 -0700\nTo define your own format, write down what the reference time would look\nlike formatted your way; see the values of constants like ANSIC,\nStampMicro or Kitchen for examples. The model is to demonstrate what the\nreference time looks like so that the Format and Parse methods can apply\nthe same transformation to a general time value.\n\nSome valid layouts are invalid time values for time.Parse, due to formats\nsuch as _ for space padding and Z for zone information.\n\nWithin the format string, an underscore _ represents a space that may be\nreplaced by a digit if the following number (a day) has two digits; for\ncompatibility with fixed-width Unix time formats.\n\nA decimal point followed by one or more zeros represents a fractional\nsecond, printed to the given number of decimal places. A decimal point\nfollowed by one or more nines represents a fractional second, printed to\nthe given number of decimal places, with trailing zeros removed.\nWhen parsing (only), the input may contain a fractional second\nfield immediately after the seconds field, even if the layout does not\nsignify its presence. In that case a decimal point followed by a maximal\nseries of digits is parsed as a fractional second.\n\nNumeric time zone offsets format as follows:\n\t-0700  ±hhmm\n\t-07:00 ±hh:mm\n\t-07    ±hh\nReplacing the sign in the format with a Z triggers\nthe ISO 8601 behavior of printing Z instead of an\noffset for the UTC zone. Thus:\n\tZ0700  Z or ±hhmm\n\tZ07:00 Z or ±hh:mm\n\tZ07    Z or ±hh\n\nThe recognized day of week formats are \"Mon\" and \"Monday\".\nThe recognized month formats are \"Jan\" and \"January\".\n\nText in the format string that is not recognized as part of the reference\ntime is echoed verbatim during Format and expected to appear verbatim\nin the input to Parse.\n\nThe executable example for Time.Format demonstrates the working\nof the layout string in detail and is a good reference.\n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied\nonly to local times. Applying them to UTC times will use \"UTC\" as the\ntime zone abbreviation, while strictly speaking those RFCs require the\nuse of \"GMT\" in that case.\nIn general RFC1123Z should be used instead of RFC1123 for servers\nthat insist on that format, and RFC3339 should be preferred for new protocols.\nRFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;\nwhen used with time.Parse they do not accept all the time formats\npermitted by the RFCs.\nThe RFC3339Nano format removes trailing zeros from the seconds field\nand thus may not sort correctly once formatted.\n"
    :added "1.0"
    :tag "String"
    :go "time.RFC1123"}
  RFC1123)

JOKER CONSTANT RFC1123Z from time/format.go:
(def
  ^{:doc "RFC1123 with numeric zone\n"
    :added "1.0"
    :tag "String"
    :go "time.RFC1123Z"}
  RFC1123Z)

JOKER CONSTANT RFC3339 from time/format.go:
(def
  ^{:doc "These are predefined layouts for use in Time.Format and time.Parse.\nThe reference time used in the layouts is the specific time:\n\tMon Jan 2 15:04:05 MST 2006\nwhich is Unix time 1136239445. Since MST is GMT-0700,\nthe reference time can be thought of as\n\t01/02 03:04:05PM '06 -0700\nTo define your own format, write down what the reference time would look\nlike formatted your way; see the values of constants like ANSIC,\nStampMicro or Kitchen for examples. The model is to demonstrate what the\nreference time looks like so that the Format and Parse methods can apply\nthe same transformation to a general time value.\n\nSome valid layouts are invalid time values for time.Parse, due to formats\nsuch as _ for space padding and Z for zone information.\n\nWithin the format string, an underscore _ represents a space that may be\nreplaced by a digit if the following number (a day) has two digits; for\ncompatibility with fixed-width Unix time formats.\n\nA decimal point followed by one or more zeros represents a fractional\nsecond, printed to the given number of decimal places. A decimal point\nfollowed by one or more nines represents a fractional second, printed to\nthe given number of decimal places, with trailing zeros removed.\nWhen parsing (only), the input may contain a fractional second\nfield immediately after the seconds field, even if the layout does not\nsignify its presence. In that case a decimal point followed by a maximal\nseries of digits is parsed as a fractional second.\n\nNumeric time zone offsets format as follows:\n\t-0700  ±hhmm\n\t-07:00 ±hh:mm\n\t-07    ±hh\nReplacing the sign in the format with a Z triggers\nthe ISO 8601 behavior of printing Z instead of an\noffset for the UTC zone. Thus:\n\tZ0700  Z or ±hhmm\n\tZ07:00 Z or ±hh:mm\n\tZ07    Z or ±hh\n\nThe recognized day of week formats are \"Mon\" and \"Monday\".\nThe recognized month formats are \"Jan\" and \"January\".\n\nText in the format string that is not recognized as part of the reference\ntime is echoed verbatim during Format and expected to appear verbatim\nin the input to Parse.\n\nThe executable example for Time.Format demonstrates the working\nof the layout string in detail and is a good reference.\n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied\nonly to local times. Applying them to UTC times will use \"UTC\" as the\ntime zone abbreviation, while strictly speaking those RFCs require the\nuse of \"GMT\" in that case.\nIn general RFC1123Z should be used instead of RFC1123 for servers\nthat insist on that format, and RFC3339 should be preferred for new protocols.\nRFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;\nwhen used with time.Parse they do not accept all the time formats\npermitted by the RFCs.\nThe RFC3339Nano format removes trailing zeros from the seconds field\nand thus may not sort correctly once formatted.\n"
    :added "1.0"
    :tag "String"
    :go "time.RFC3339"}
  RFC3339)

JOKER CONSTANT RFC3339Nano from time/format.go:
(def
  ^{:doc "These are predefined layouts for use in Time.Format and time.Parse.\nThe reference time used in the layouts is the specific time:\n\tMon Jan 2 15:04:05 MST 2006\nwhich is Unix time 1136239445. Since MST is GMT-0700,\nthe reference time can be thought of as\n\t01/02 03:04:05PM '06 -0700\nTo define your own format, write down what the reference time would look\nlike formatted your way; see the values of constants like ANSIC,\nStampMicro or Kitchen for examples. The model is to demonstrate what the\nreference time looks like so that the Format and Parse methods can apply\nthe same transformation to a general time value.\n\nSome valid layouts are invalid time values for time.Parse, due to formats\nsuch as _ for space padding and Z for zone information.\n\nWithin the format string, an underscore _ represents a space that may be\nreplaced by a digit if the following number (a day) has two digits; for\ncompatibility with fixed-width Unix time formats.\n\nA decimal point followed by one or more zeros represents a fractional\nsecond, printed to the given number of decimal places. A decimal point\nfollowed by one or more nines represents a fractional second, printed to\nthe given number of decimal places, with trailing zeros removed.\nWhen parsing (only), the input may contain a fractional second\nfield immediately after the seconds field, even if the layout does not\nsignify its presence. In that case a decimal point followed by a maximal\nseries of digits is parsed as a fractional second.\n\nNumeric time zone offsets format as follows:\n\t-0700  ±hhmm\n\t-07:00 ±hh:mm\n\t-07    ±hh\nReplacing the sign in the format with a Z triggers\nthe ISO 8601 behavior of printing Z instead of an\noffset for the UTC zone. Thus:\n\tZ0700  Z or ±hhmm\n\tZ07:00 Z or ±hh:mm\n\tZ07    Z or ±hh\n\nThe recognized day of week formats are \"Mon\" and \"Monday\".\nThe recognized month formats are \"Jan\" and \"January\".\n\nText in the format string that is not recognized as part of the reference\ntime is echoed verbatim during Format and expected to appear verbatim\nin the input to Parse.\n\nThe executable example for Time.Format demonstrates the working\nof the layout string in detail and is a good reference.\n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied\nonly to local times. Applying them to UTC times will use \"UTC\" as the\ntime zone abbreviation, while strictly speaking those RFCs require the\nuse of \"GMT\" in that case.\nIn general RFC1123Z should be used instead of RFC1123 for servers\nthat insist on that format, and RFC3339 should be preferred for new protocols.\nRFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;\nwhen used with time.Parse they do not accept all the time formats\npermitted by the RFCs.\nThe RFC3339Nano format removes trailing zeros from the seconds field\nand thus may not sort correctly once formatted.\n"
    :added "1.0"
    :tag "String"
    :go "time.RFC3339Nano"}
  RFC3339Nano)

JOKER CONSTANT RFC822 from time/format.go:
(def
  ^{:doc "These are predefined layouts for use in Time.Format and time.Parse.\nThe reference time used in the layouts is the specific time:\n\tMon Jan 2 15:04:05 MST 2006\nwhich is Unix time 1136239445. Since MST is GMT-0700,\nthe reference time can be thought of as\n\t01/02 03:04:05PM '06 -0700\nTo define your own format, write down what the reference time would look\nlike formatted your way; see the values of constants like ANSIC,\nStampMicro or Kitchen for examples. The model is to demonstrate what the\nreference time looks like so that the Format and Parse methods can apply\nthe same transformation to a general time value.\n\nSome valid layouts are invalid time values for time.Parse, due to formats\nsuch as _ for space padding and Z for zone information.\n\nWithin the format string, an underscore _ represents a space that may be\nreplaced by a digit if the following number (a day) has two digits; for\ncompatibility with fixed-width Unix time formats.\n\nA decimal point followed by one or more zeros represents a fractional\nsecond, printed to the given number of decimal places. A decimal point\nfollowed by one or more nines represents a fractional second, printed to\nthe given number of decimal places, with trailing zeros removed.\nWhen parsing (only), the input may contain a fractional second\nfield immediately after the seconds field, even if the layout does not\nsignify its presence. In that case a decimal point followed by a maximal\nseries of digits is parsed as a fractional second.\n\nNumeric time zone offsets format as follows:\n\t-0700  ±hhmm\n\t-07:00 ±hh:mm\n\t-07    ±hh\nReplacing the sign in the format with a Z triggers\nthe ISO 8601 behavior of printing Z instead of an\noffset for the UTC zone. Thus:\n\tZ0700  Z or ±hhmm\n\tZ07:00 Z or ±hh:mm\n\tZ07    Z or ±hh\n\nThe recognized day of week formats are \"Mon\" and \"Monday\".\nThe recognized month formats are \"Jan\" and \"January\".\n\nText in the format string that is not recognized as part of the reference\ntime is echoed verbatim during Format and expected to appear verbatim\nin the input to Parse.\n\nThe executable example for Time.Format demonstrates the working\nof the layout string in detail and is a good reference.\n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied\nonly to local times. Applying them to UTC times will use \"UTC\" as the\ntime zone abbreviation, while strictly speaking those RFCs require the\nuse of \"GMT\" in that case.\nIn general RFC1123Z should be used instead of RFC1123 for servers\nthat insist on that format, and RFC3339 should be preferred for new protocols.\nRFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;\nwhen used with time.Parse they do not accept all the time formats\npermitted by the RFCs.\nThe RFC3339Nano format removes trailing zeros from the seconds field\nand thus may not sort correctly once formatted.\n"
    :added "1.0"
    :tag "String"
    :go "time.RFC822"}
  RFC822)

JOKER CONSTANT RFC822Z from time/format.go:
(def
  ^{:doc "RFC822 with numeric zone\n"
    :added "1.0"
    :tag "String"
    :go "time.RFC822Z"}
  RFC822Z)

JOKER CONSTANT RFC850 from time/format.go:
(def
  ^{:doc "These are predefined layouts for use in Time.Format and time.Parse.\nThe reference time used in the layouts is the specific time:\n\tMon Jan 2 15:04:05 MST 2006\nwhich is Unix time 1136239445. Since MST is GMT-0700,\nthe reference time can be thought of as\n\t01/02 03:04:05PM '06 -0700\nTo define your own format, write down what the reference time would look\nlike formatted your way; see the values of constants like ANSIC,\nStampMicro or Kitchen for examples. The model is to demonstrate what the\nreference time looks like so that the Format and Parse methods can apply\nthe same transformation to a general time value.\n\nSome valid layouts are invalid time values for time.Parse, due to formats\nsuch as _ for space padding and Z for zone information.\n\nWithin the format string, an underscore _ represents a space that may be\nreplaced by a digit if the following number (a day) has two digits; for\ncompatibility with fixed-width Unix time formats.\n\nA decimal point followed by one or more zeros represents a fractional\nsecond, printed to the given number of decimal places. A decimal point\nfollowed by one or more nines represents a fractional second, printed to\nthe given number of decimal places, with trailing zeros removed.\nWhen parsing (only), the input may contain a fractional second\nfield immediately after the seconds field, even if the layout does not\nsignify its presence. In that case a decimal point followed by a maximal\nseries of digits is parsed as a fractional second.\n\nNumeric time zone offsets format as follows:\n\t-0700  ±hhmm\n\t-07:00 ±hh:mm\n\t-07    ±hh\nReplacing the sign in the format with a Z triggers\nthe ISO 8601 behavior of printing Z instead of an\noffset for the UTC zone. Thus:\n\tZ0700  Z or ±hhmm\n\tZ07:00 Z or ±hh:mm\n\tZ07    Z or ±hh\n\nThe recognized day of week formats are \"Mon\" and \"Monday\".\nThe recognized month formats are \"Jan\" and \"January\".\n\nText in the format string that is not recognized as part of the reference\ntime is echoed verbatim during Format and expected to appear verbatim\nin the input to Parse.\n\nThe executable example for Time.Format demonstrates the working\nof the layout string in detail and is a good reference.\n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied\nonly to local times. Applying them to UTC times will use \"UTC\" as the\ntime zone abbreviation, while strictly speaking those RFCs require the\nuse of \"GMT\" in that case.\nIn general RFC1123Z should be used instead of RFC1123 for servers\nthat insist on that format, and RFC3339 should be preferred for new protocols.\nRFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;\nwhen used with time.Parse they do not accept all the time formats\npermitted by the RFCs.\nThe RFC3339Nano format removes trailing zeros from the seconds field\nand thus may not sort correctly once formatted.\n"
    :added "1.0"
    :tag "String"
    :go "time.RFC850"}
  RFC850)

JOKER CONSTANT RubyDate from time/format.go:
(def
  ^{:doc "These are predefined layouts for use in Time.Format and time.Parse.\nThe reference time used in the layouts is the specific time:\n\tMon Jan 2 15:04:05 MST 2006\nwhich is Unix time 1136239445. Since MST is GMT-0700,\nthe reference time can be thought of as\n\t01/02 03:04:05PM '06 -0700\nTo define your own format, write down what the reference time would look\nlike formatted your way; see the values of constants like ANSIC,\nStampMicro or Kitchen for examples. The model is to demonstrate what the\nreference time looks like so that the Format and Parse methods can apply\nthe same transformation to a general time value.\n\nSome valid layouts are invalid time values for time.Parse, due to formats\nsuch as _ for space padding and Z for zone information.\n\nWithin the format string, an underscore _ represents a space that may be\nreplaced by a digit if the following number (a day) has two digits; for\ncompatibility with fixed-width Unix time formats.\n\nA decimal point followed by one or more zeros represents a fractional\nsecond, printed to the given number of decimal places. A decimal point\nfollowed by one or more nines represents a fractional second, printed to\nthe given number of decimal places, with trailing zeros removed.\nWhen parsing (only), the input may contain a fractional second\nfield immediately after the seconds field, even if the layout does not\nsignify its presence. In that case a decimal point followed by a maximal\nseries of digits is parsed as a fractional second.\n\nNumeric time zone offsets format as follows:\n\t-0700  ±hhmm\n\t-07:00 ±hh:mm\n\t-07    ±hh\nReplacing the sign in the format with a Z triggers\nthe ISO 8601 behavior of printing Z instead of an\noffset for the UTC zone. Thus:\n\tZ0700  Z or ±hhmm\n\tZ07:00 Z or ±hh:mm\n\tZ07    Z or ±hh\n\nThe recognized day of week formats are \"Mon\" and \"Monday\".\nThe recognized month formats are \"Jan\" and \"January\".\n\nText in the format string that is not recognized as part of the reference\ntime is echoed verbatim during Format and expected to appear verbatim\nin the input to Parse.\n\nThe executable example for Time.Format demonstrates the working\nof the layout string in detail and is a good reference.\n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied\nonly to local times. Applying them to UTC times will use \"UTC\" as the\ntime zone abbreviation, while strictly speaking those RFCs require the\nuse of \"GMT\" in that case.\nIn general RFC1123Z should be used instead of RFC1123 for servers\nthat insist on that format, and RFC3339 should be preferred for new protocols.\nRFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;\nwhen used with time.Parse they do not accept all the time formats\npermitted by the RFCs.\nThe RFC3339Nano format removes trailing zeros from the seconds field\nand thus may not sort correctly once formatted.\n"
    :added "1.0"
    :tag "String"
    :go "time.RubyDate"}
  RubyDate)

JOKER CONSTANT Saturday from time/time.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(time.Saturday)"}
  Saturday)

JOKER CONSTANT Second from time/time.go:
(def
  ^{:doc "Common durations. There is no definition for units of Day or larger\nto avoid confusion across daylight savings time zone transitions.\n\nTo count the number of units in a Duration, divide:\n\tsecond := time.Second\n\tfmt.Print(int64(second/time.Millisecond)) // prints 1000\n\nTo convert an integer number of units to a Duration, multiply:\n\tseconds := 10\n\tfmt.Print(time.Duration(seconds)*time.Second) // prints 10s\n"
    :added "1.0"
    :tag "Number"
    :go "int64(int64(time.Second))"}
  Second)

JOKER CONSTANT September from time/time.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(time.September)"}
  September)

JOKER CONSTANT Stamp from time/format.go:
(def
  ^{:doc "Handy time stamps.\n"
    :added "1.0"
    :tag "String"
    :go "time.Stamp"}
  Stamp)

JOKER CONSTANT StampMicro from time/format.go:
(def
  ^{:doc "These are predefined layouts for use in Time.Format and time.Parse.\nThe reference time used in the layouts is the specific time:\n\tMon Jan 2 15:04:05 MST 2006\nwhich is Unix time 1136239445. Since MST is GMT-0700,\nthe reference time can be thought of as\n\t01/02 03:04:05PM '06 -0700\nTo define your own format, write down what the reference time would look\nlike formatted your way; see the values of constants like ANSIC,\nStampMicro or Kitchen for examples. The model is to demonstrate what the\nreference time looks like so that the Format and Parse methods can apply\nthe same transformation to a general time value.\n\nSome valid layouts are invalid time values for time.Parse, due to formats\nsuch as _ for space padding and Z for zone information.\n\nWithin the format string, an underscore _ represents a space that may be\nreplaced by a digit if the following number (a day) has two digits; for\ncompatibility with fixed-width Unix time formats.\n\nA decimal point followed by one or more zeros represents a fractional\nsecond, printed to the given number of decimal places. A decimal point\nfollowed by one or more nines represents a fractional second, printed to\nthe given number of decimal places, with trailing zeros removed.\nWhen parsing (only), the input may contain a fractional second\nfield immediately after the seconds field, even if the layout does not\nsignify its presence. In that case a decimal point followed by a maximal\nseries of digits is parsed as a fractional second.\n\nNumeric time zone offsets format as follows:\n\t-0700  ±hhmm\n\t-07:00 ±hh:mm\n\t-07    ±hh\nReplacing the sign in the format with a Z triggers\nthe ISO 8601 behavior of printing Z instead of an\noffset for the UTC zone. Thus:\n\tZ0700  Z or ±hhmm\n\tZ07:00 Z or ±hh:mm\n\tZ07    Z or ±hh\n\nThe recognized day of week formats are \"Mon\" and \"Monday\".\nThe recognized month formats are \"Jan\" and \"January\".\n\nText in the format string that is not recognized as part of the reference\ntime is echoed verbatim during Format and expected to appear verbatim\nin the input to Parse.\n\nThe executable example for Time.Format demonstrates the working\nof the layout string in detail and is a good reference.\n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied\nonly to local times. Applying them to UTC times will use \"UTC\" as the\ntime zone abbreviation, while strictly speaking those RFCs require the\nuse of \"GMT\" in that case.\nIn general RFC1123Z should be used instead of RFC1123 for servers\nthat insist on that format, and RFC3339 should be preferred for new protocols.\nRFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;\nwhen used with time.Parse they do not accept all the time formats\npermitted by the RFCs.\nThe RFC3339Nano format removes trailing zeros from the seconds field\nand thus may not sort correctly once formatted.\n"
    :added "1.0"
    :tag "String"
    :go "time.StampMicro"}
  StampMicro)

JOKER CONSTANT StampMilli from time/format.go:
(def
  ^{:doc "These are predefined layouts for use in Time.Format and time.Parse.\nThe reference time used in the layouts is the specific time:\n\tMon Jan 2 15:04:05 MST 2006\nwhich is Unix time 1136239445. Since MST is GMT-0700,\nthe reference time can be thought of as\n\t01/02 03:04:05PM '06 -0700\nTo define your own format, write down what the reference time would look\nlike formatted your way; see the values of constants like ANSIC,\nStampMicro or Kitchen for examples. The model is to demonstrate what the\nreference time looks like so that the Format and Parse methods can apply\nthe same transformation to a general time value.\n\nSome valid layouts are invalid time values for time.Parse, due to formats\nsuch as _ for space padding and Z for zone information.\n\nWithin the format string, an underscore _ represents a space that may be\nreplaced by a digit if the following number (a day) has two digits; for\ncompatibility with fixed-width Unix time formats.\n\nA decimal point followed by one or more zeros represents a fractional\nsecond, printed to the given number of decimal places. A decimal point\nfollowed by one or more nines represents a fractional second, printed to\nthe given number of decimal places, with trailing zeros removed.\nWhen parsing (only), the input may contain a fractional second\nfield immediately after the seconds field, even if the layout does not\nsignify its presence. In that case a decimal point followed by a maximal\nseries of digits is parsed as a fractional second.\n\nNumeric time zone offsets format as follows:\n\t-0700  ±hhmm\n\t-07:00 ±hh:mm\n\t-07    ±hh\nReplacing the sign in the format with a Z triggers\nthe ISO 8601 behavior of printing Z instead of an\noffset for the UTC zone. Thus:\n\tZ0700  Z or ±hhmm\n\tZ07:00 Z or ±hh:mm\n\tZ07    Z or ±hh\n\nThe recognized day of week formats are \"Mon\" and \"Monday\".\nThe recognized month formats are \"Jan\" and \"January\".\n\nText in the format string that is not recognized as part of the reference\ntime is echoed verbatim during Format and expected to appear verbatim\nin the input to Parse.\n\nThe executable example for Time.Format demonstrates the working\nof the layout string in detail and is a good reference.\n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied\nonly to local times. Applying them to UTC times will use \"UTC\" as the\ntime zone abbreviation, while strictly speaking those RFCs require the\nuse of \"GMT\" in that case.\nIn general RFC1123Z should be used instead of RFC1123 for servers\nthat insist on that format, and RFC3339 should be preferred for new protocols.\nRFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;\nwhen used with time.Parse they do not accept all the time formats\npermitted by the RFCs.\nThe RFC3339Nano format removes trailing zeros from the seconds field\nand thus may not sort correctly once formatted.\n"
    :added "1.0"
    :tag "String"
    :go "time.StampMilli"}
  StampMilli)

JOKER CONSTANT StampNano from time/format.go:
(def
  ^{:doc "These are predefined layouts for use in Time.Format and time.Parse.\nThe reference time used in the layouts is the specific time:\n\tMon Jan 2 15:04:05 MST 2006\nwhich is Unix time 1136239445. Since MST is GMT-0700,\nthe reference time can be thought of as\n\t01/02 03:04:05PM '06 -0700\nTo define your own format, write down what the reference time would look\nlike formatted your way; see the values of constants like ANSIC,\nStampMicro or Kitchen for examples. The model is to demonstrate what the\nreference time looks like so that the Format and Parse methods can apply\nthe same transformation to a general time value.\n\nSome valid layouts are invalid time values for time.Parse, due to formats\nsuch as _ for space padding and Z for zone information.\n\nWithin the format string, an underscore _ represents a space that may be\nreplaced by a digit if the following number (a day) has two digits; for\ncompatibility with fixed-width Unix time formats.\n\nA decimal point followed by one or more zeros represents a fractional\nsecond, printed to the given number of decimal places. A decimal point\nfollowed by one or more nines represents a fractional second, printed to\nthe given number of decimal places, with trailing zeros removed.\nWhen parsing (only), the input may contain a fractional second\nfield immediately after the seconds field, even if the layout does not\nsignify its presence. In that case a decimal point followed by a maximal\nseries of digits is parsed as a fractional second.\n\nNumeric time zone offsets format as follows:\n\t-0700  ±hhmm\n\t-07:00 ±hh:mm\n\t-07    ±hh\nReplacing the sign in the format with a Z triggers\nthe ISO 8601 behavior of printing Z instead of an\noffset for the UTC zone. Thus:\n\tZ0700  Z or ±hhmm\n\tZ07:00 Z or ±hh:mm\n\tZ07    Z or ±hh\n\nThe recognized day of week formats are \"Mon\" and \"Monday\".\nThe recognized month formats are \"Jan\" and \"January\".\n\nText in the format string that is not recognized as part of the reference\ntime is echoed verbatim during Format and expected to appear verbatim\nin the input to Parse.\n\nThe executable example for Time.Format demonstrates the working\nof the layout string in detail and is a good reference.\n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied\nonly to local times. Applying them to UTC times will use \"UTC\" as the\ntime zone abbreviation, while strictly speaking those RFCs require the\nuse of \"GMT\" in that case.\nIn general RFC1123Z should be used instead of RFC1123 for servers\nthat insist on that format, and RFC3339 should be preferred for new protocols.\nRFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;\nwhen used with time.Parse they do not accept all the time formats\npermitted by the RFCs.\nThe RFC3339Nano format removes trailing zeros from the seconds field\nand thus may not sort correctly once formatted.\n"
    :added "1.0"
    :tag "String"
    :go "time.StampNano"}
  StampNano)

JOKER CONSTANT Sunday from time/time.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(time.Sunday)"}
  Sunday)

JOKER CONSTANT Thursday from time/time.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(time.Thursday)"}
  Thursday)

JOKER CONSTANT Tuesday from time/time.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(time.Tuesday)"}
  Tuesday)

JOKER CONSTANT UnixDate from time/format.go:
(def
  ^{:doc "These are predefined layouts for use in Time.Format and time.Parse.\nThe reference time used in the layouts is the specific time:\n\tMon Jan 2 15:04:05 MST 2006\nwhich is Unix time 1136239445. Since MST is GMT-0700,\nthe reference time can be thought of as\n\t01/02 03:04:05PM '06 -0700\nTo define your own format, write down what the reference time would look\nlike formatted your way; see the values of constants like ANSIC,\nStampMicro or Kitchen for examples. The model is to demonstrate what the\nreference time looks like so that the Format and Parse methods can apply\nthe same transformation to a general time value.\n\nSome valid layouts are invalid time values for time.Parse, due to formats\nsuch as _ for space padding and Z for zone information.\n\nWithin the format string, an underscore _ represents a space that may be\nreplaced by a digit if the following number (a day) has two digits; for\ncompatibility with fixed-width Unix time formats.\n\nA decimal point followed by one or more zeros represents a fractional\nsecond, printed to the given number of decimal places. A decimal point\nfollowed by one or more nines represents a fractional second, printed to\nthe given number of decimal places, with trailing zeros removed.\nWhen parsing (only), the input may contain a fractional second\nfield immediately after the seconds field, even if the layout does not\nsignify its presence. In that case a decimal point followed by a maximal\nseries of digits is parsed as a fractional second.\n\nNumeric time zone offsets format as follows:\n\t-0700  ±hhmm\n\t-07:00 ±hh:mm\n\t-07    ±hh\nReplacing the sign in the format with a Z triggers\nthe ISO 8601 behavior of printing Z instead of an\noffset for the UTC zone. Thus:\n\tZ0700  Z or ±hhmm\n\tZ07:00 Z or ±hh:mm\n\tZ07    Z or ±hh\n\nThe recognized day of week formats are \"Mon\" and \"Monday\".\nThe recognized month formats are \"Jan\" and \"January\".\n\nText in the format string that is not recognized as part of the reference\ntime is echoed verbatim during Format and expected to appear verbatim\nin the input to Parse.\n\nThe executable example for Time.Format demonstrates the working\nof the layout string in detail and is a good reference.\n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied\nonly to local times. Applying them to UTC times will use \"UTC\" as the\ntime zone abbreviation, while strictly speaking those RFCs require the\nuse of \"GMT\" in that case.\nIn general RFC1123Z should be used instead of RFC1123 for servers\nthat insist on that format, and RFC3339 should be preferred for new protocols.\nRFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;\nwhen used with time.Parse they do not accept all the time formats\npermitted by the RFCs.\nThe RFC3339Nano format removes trailing zeros from the seconds field\nand thus may not sort correctly once formatted.\n"
    :added "1.0"
    :tag "String"
    :go "time.UnixDate"}
  UnixDate)

JOKER CONSTANT Wednesday from time/time.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(time.Wednesday)"}
  Wednesday)

JOKER VARIABLE Local from time/zoneinfo.go:
(def
  ^{:doc "Local represents the system's local time zone.\n"
    :added "1.0"
    :tag "Var"
    :go "time.Local"}
  Local)

JOKER VARIABLE UTC from time/zoneinfo.go:
(def
  ^{:doc "UTC represents Universal Coordinated Time (UTC).\n"
    :added "1.0"
    :tag "Var"
    :go "time.UTC"}
  UTC)

JOKER TYPE time.Duration from time/time.go:
(defn ^"GoObject" Duration.
  "Constructor for time.Duration"
  {:added "1.0"
   :go "_ConstructDuration(_v)"}
  [^Object _v])

JOKER TYPE time.Location from time/zoneinfo.go:
(defn ^"GoObject" Location.
  "Constructor for time.Location"
  {:added "1.0"
   :go "_ConstructLocation(_v)"}
  [^Object _v])

JOKER TYPE time.Month from time/time.go:
(defn ^"GoObject" Month.
  "Constructor for time.Month"
  {:added "1.0"
   :go "_ConstructMonth(_v)"}
  [^Object _v])

JOKER TYPE time.ParseError from time/format.go:
(defn ^"GoObject" ParseError.
  "Constructor for time.ParseError"
  {:added "1.0"
   :go "_ConstructParseError(_v)"}
  [^Object _v])

JOKER TYPE time.Ticker from time/tick.go:
;; (defn ^"GoObject" Ticker.
;;   "Constructor for time.Ticker"
;;   {:added "1.0"
;;    :go "_ConstructTicker(_v)"}
;;   [^Object _v])

JOKER TYPE time.Time from time/time.go:
(defn ^"GoObject" Time.
  "Constructor for time.Time"
  {:added "1.0"
   :go "_ConstructTime(_v)"}
  [^Object _v])

JOKER TYPE time.Timer from time/sleep.go:
;; (defn ^"GoObject" Timer.
;;   "Constructor for time.Timer"
;;   {:added "1.0"
;;    :go "_ConstructTimer(_v)"}
;;   [^Object _v])

JOKER TYPE time.Weekday from time/time.go:
(defn ^"GoObject" Weekday.
  "Constructor for time.Weekday"
  {:added "1.0"
   :go "_ConstructWeekday(_v)"}
  [^Object _v])

JOKER FUNC time.After from time/sleep.go:
;; (defn After
;;   "After waits for the duration to elapse and then sends the current time\non the returned channel.\nIt is equivalent to NewTimer(d).C.\nThe underlying Timer is not recovered by the garbage collector\nuntil the timer fires. If efficiency is a concern, use NewTimer\ninstead and call Timer.Stop if the timer is no longer needed.\n\nGo input arguments: (d Duration)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.time/Duration d]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.ChanType at: /usr/local/go/src/time/sleep.go:149:24)"
;;   {:added "1.0"
;;    :go "__after(*__d)"}
;;   [^time/Duration __d])

JOKER FUNC time.AfterFunc from time/sleep.go:
;; (defn AfterFunc
;;   "AfterFunc waits for the duration to elapse and then calls f\nin its own goroutine. It returns a Timer that can\nbe used to cancel the call using its Stop method.\n\nGo input arguments: (d Duration, f func)\n\nGo return type: *Timer\n\nJoker input arguments: [^go.std.time/Duration d, ^fn f]\n\nJoker return type: (atom-of go.std.time/Timer)"
;;   {:added "1.0"
;;    :go "__afterFunc(*__d, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^time/Duration __d, ^fn __f])

JOKER FUNC time.Date from time/time.go:
(defn Date
  "Date returns the Time corresponding to\n\tyyyy-mm-dd hh:mm:ss + nsec nanoseconds\nin the appropriate zone for that time in the given location.\n\nThe month, day, hour, min, sec, and nsec values may be outside\ntheir usual ranges and will be normalized during the conversion.\nFor example, October 32 converts to November 1.\n\nA daylight savings time transition skips or repeats times.\nFor example, in the United States, March 13, 2011 2:15am never occurred,\nwhile November 6, 2011 1:15am occurred twice. In such cases, the\nchoice of time zone, and therefore the time, is not well-defined.\nDate returns a time that is correct in one of the two zones involved\nin the transition, but it does not guarantee which.\n\nDate panics if loc is nil.\n\nGo input arguments: (year int, month Month, day int, hour int, min int, sec int, nsec int, loc *Location)\n\nGo return type: Time\n\nJoker input arguments: [^Int year, ^go.std.time/Month month, ^Int day, ^Int hour, ^Int min, ^Int sec, ^Int nsec, ^(atom-of go.std.time/Location) loc]\n\nJoker return type: go.std.time/Time"
  {:added "1.0"
   :go "__date(__year, *__month, __day, __hour, __min, __sec, __nsec, __loc)"}
  [^Int __year, ^time/Month __month, ^Int __day, ^Int __hour, ^Int __min, ^Int __sec, ^Int __nsec, ^time/Location __loc])

JOKER FUNC time.FixedZone from time/zoneinfo.go:
(defn FixedZone
  "FixedZone returns a Location that always uses\nthe given zone name and offset (seconds east of UTC).\n\nGo input arguments: (name string, offset int)\n\nGo return type: *Location\n\nJoker input arguments: [^String name, ^Int offset]\n\nJoker return type: (atom-of go.std.time/Location)"
  {:added "1.0"
   :go "__fixedZone(__name, __offset)"}
  [^String __name, ^Int __offset])

JOKER FUNC time.LoadLocation from time/zoneinfo.go:
(defn LoadLocation
  "LoadLocation returns the Location with the given name.\n\nIf the name is \"\" or \"UTC\", LoadLocation returns UTC.\nIf the name is \"Local\", LoadLocation returns Local.\n\nOtherwise, the name is taken to be a location name corresponding to a file\nin the IANA Time Zone database, such as \"America/New_York\".\n\nThe time zone database needed by LoadLocation may not be\npresent on all systems, especially non-Unix systems.\nLoadLocation looks in the directory or uncompressed zip file\nnamed by the ZONEINFO environment variable, if any, then looks in\nknown installation locations on Unix systems,\nand finally looks in $GOROOT/lib/time/zoneinfo.zip.\n\nGo input arguments: (name string)\n\nGo return type: (*Location, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.time/Location) Error]"
  {:added "1.0"
   :go "__loadLocation(__name)"}
  [^String __name])

JOKER FUNC time.LoadLocationFromTZData from time/zoneinfo_read.go:
;; (defn LoadLocationFromTZData
;;   "LoadLocationFromTZData returns a Location with the given name\ninitialized from the IANA Time Zone database-formatted data.\nThe data should be in the format of a standard IANA time zone file\n(for example, the content of /etc/localtime on Unix systems).\n\nGo input arguments: (name string, data []byte)\n\nGo return type: (*Location, error)\n\nJoker input arguments: [^String name, ^(vector-of Int) data]\n\nJoker return type: [(atom-of go.std.time/Location) Error]"
;;   {:added "1.0"
;;    :go "__loadLocationFromTZData(__name, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)))"}
;;   [^String __name, ^Object __data])

JOKER FUNC time.NewTicker from time/tick.go:
(defn NewTicker
  "NewTicker returns a new Ticker containing a channel that will send the\ntime with a period specified by the duration argument.\nIt adjusts the intervals or drops ticks to make up for slow receivers.\nThe duration d must be greater than zero; if not, NewTicker will panic.\nStop the ticker to release associated resources.\n\nGo input arguments: (d Duration)\n\nGo return type: *Ticker\n\nJoker input arguments: [^go.std.time/Duration d]\n\nJoker return type: (atom-of go.std.time/Ticker)"
  {:added "1.0"
   :go "__newTicker(*__d)"}
  [^time/Duration __d])

JOKER FUNC time.NewTimer from time/sleep.go:
(defn NewTimer
  "NewTimer creates a new Timer that will send\nthe current time on its channel after at least duration d.\n\nGo input arguments: (d Duration)\n\nGo return type: *Timer\n\nJoker input arguments: [^go.std.time/Duration d]\n\nJoker return type: (atom-of go.std.time/Timer)"
  {:added "1.0"
   :go "__newTimer(*__d)"}
  [^time/Duration __d])

JOKER FUNC time.Now from time/time.go:
(defn Now
  "Now returns the current local time.\n\nGo return type: Time\n\nJoker input arguments: []\n\nJoker return type: go.std.time/Time"
  {:added "1.0"
   :go "__now()"}
  [])

JOKER FUNC time.Parse from time/format.go:
(defn Parse
  "Parse parses a formatted string and returns the time value it represents.\nThe layout defines the format by showing how the reference time,\ndefined to be\n\tMon Jan 2 15:04:05 -0700 MST 2006\nwould be interpreted if it were the value; it serves as an example of\nthe input format. The same interpretation will then be made to the\ninput string.\n\nPredefined layouts ANSIC, UnixDate, RFC3339 and others describe standard\nand convenient representations of the reference time. For more information\nabout the formats and the definition of the reference time, see the\ndocumentation for ANSIC and the other constants defined by this package.\nAlso, the executable example for Time.Format demonstrates the working\nof the layout string in detail and is a good reference.\n\nElements omitted from the value are assumed to be zero or, when\nzero is impossible, one, so parsing \"3:04pm\" returns the time\ncorresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is\n0, this time is before the zero Time).\nYears must be in the range 0000..9999. The day of the week is checked\nfor syntax but it is otherwise ignored.\n\nIn the absence of a time zone indicator, Parse returns a time in UTC.\n\nWhen parsing a time with a zone offset like -0700, if the offset corresponds\nto a time zone used by the current location (Local), then Parse uses that\nlocation and zone in the returned time. Otherwise it records the time as\nbeing in a fabricated location with time fixed at the given zone offset.\n\nWhen parsing a time with a zone abbreviation like MST, if the zone abbreviation\nhas a defined offset in the current location, then that offset is used.\nThe zone abbreviation \"UTC\" is recognized as UTC regardless of location.\nIf the zone abbreviation is unknown, Parse records the time as being\nin a fabricated location with the given zone abbreviation and a zero offset.\nThis choice means that such a time can be parsed and reformatted with the\nsame layout losslessly, but the exact instant used in the representation will\ndiffer by the actual zone offset. To avoid such problems, prefer time layouts\nthat use a numeric zone offset, or use ParseInLocation.\n\nGo input arguments: (layout string, value string)\n\nGo return type: (Time, error)\n\nJoker input arguments: [^String layout, ^String value]\n\nJoker return type: [go.std.time/Time Error]"
  {:added "1.0"
   :go "__parse(__layout, __value)"}
  [^String __layout, ^String __value])

JOKER FUNC time.ParseDuration from time/format.go:
(defn ParseDuration
  "ParseDuration parses a duration string.\nA duration string is a possibly signed sequence of\ndecimal numbers, each with optional fraction and a unit suffix,\nsuch as \"300ms\", \"-1.5h\" or \"2h45m\".\nValid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\".\n\nGo input arguments: (s string)\n\nGo return type: (Duration, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [go.std.time/Duration Error]"
  {:added "1.0"
   :go "__parseDuration(__s)"}
  [^String __s])

JOKER FUNC time.ParseInLocation from time/format.go:
(defn ParseInLocation
  "ParseInLocation is like Parse but differs in two important ways.\nFirst, in the absence of time zone information, Parse interprets a time as UTC;\nParseInLocation interprets the time as in the given location.\nSecond, when given a zone offset or abbreviation, Parse tries to match it\nagainst the Local location; ParseInLocation uses the given location.\n\nGo input arguments: (layout string, value string, loc *Location)\n\nGo return type: (Time, error)\n\nJoker input arguments: [^String layout, ^String value, ^(atom-of go.std.time/Location) loc]\n\nJoker return type: [go.std.time/Time Error]"
  {:added "1.0"
   :go "__parseInLocation(__layout, __value, __loc)"}
  [^String __layout, ^String __value, ^time/Location __loc])

JOKER FUNC time.Since from time/time.go:
(defn Since
  "Since returns the time elapsed since t.\nIt is shorthand for time.Now().Sub(t).\n\nGo input arguments: (t Time)\n\nGo return type: Duration\n\nJoker input arguments: [^go.std.time/Time t]\n\nJoker return type: go.std.time/Duration"
  {:added "1.0"
   :go "__since(*__t)"}
  [^time/Time __t])

JOKER FUNC time.Sleep from time/sleep.go:
;; (defn Sleep
;;   "Sleep pauses the current goroutine for at least the duration d.\nA negative or zero duration causes Sleep to return immediately.\n\nGo input arguments: (d Duration)\n\nJoker input arguments: [^go.std.time/Duration d]"
;;   {:added "1.0"
;;    :go "__sleep(*__d)"}
;;   [^time/Duration __d])

JOKER FUNC time.Tick from time/tick.go:
;; (defn Tick
;;   "Tick is a convenience wrapper for NewTicker providing access to the ticking\nchannel only. While Tick is useful for clients that have no need to shut down\nthe Ticker, be aware that without a way to shut it down the underlying\nTicker cannot be recovered by the garbage collector; it \"leaks\".\nUnlike NewTicker, Tick will return nil if d <= 0.\n\nGo input arguments: (d Duration)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.time/Duration d]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.ChanType at: /usr/local/go/src/time/tick.go:54:23)"
;;   {:added "1.0"
;;    :go "__tick(*__d)"}
;;   [^time/Duration __d])

JOKER FUNC time.Unix from time/time.go:
(defn Unix
  "Unix returns the local Time corresponding to the given Unix time,\nsec seconds and nsec nanoseconds since January 1, 1970 UTC.\nIt is valid to pass nsec outside the range [0, 999999999].\nNot all sec values have a corresponding time value. One such\nvalue is 1<<63-1 (the largest int64 value).\n\nGo input arguments: (sec int64, nsec int64)\n\nGo return type: Time\n\nJoker input arguments: [^Number sec, ^Number nsec]\n\nJoker return type: go.std.time/Time"
  {:added "1.0"
   :go "__unix(__sec, __nsec)"}
  [^Int64 __sec, ^Int64 __nsec])

JOKER FUNC time.Until from time/time.go:
(defn Until
  "Until returns the duration until t.\nIt is shorthand for t.Sub(time.Now()).\n\nGo input arguments: (t Time)\n\nGo return type: Duration\n\nJoker input arguments: [^go.std.time/Time t]\n\nJoker return type: go.std.time/Duration"
  {:added "1.0"
   :go "__until(*__t)"}
  [^time/Time __t])

JOKER TYPE go.std.time/Duration:
(def
  ^{:doc "A Duration represents the elapsed time between two instants\nas an int64 nanosecond count. The representation limits the\nlargest representable duration to approximately 290 years.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Duration"}
  Duration)

JOKER TYPE go.std.time/Location:
(def
  ^{:doc "A Location maps time instants to the zone in use at that time.\nTypically, the Location represents the collection of time offsets\nin use in a geographical area, such as CEST and CET for central Europe.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Location"}
  Location)

JOKER TYPE go.std.time/Month:
(def
  ^{:doc "A Month specifies a month of the year (January = 1, ...).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Month"}
  Month)

JOKER TYPE go.std.time/ParseError:
(def
  ^{:doc "ParseError describes a problem parsing a time string.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ParseError"}
  ParseError)

JOKER TYPE go.std.time/Ticker:
(def
  ^{:doc "A Ticker holds a channel that delivers `ticks' of a clock\nat intervals.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Ticker"}
  Ticker)

JOKER TYPE go.std.time/Time:
(def
  ^{:doc "A Time represents an instant in time with nanosecond precision.\n\nPrograms using times should typically store and pass them as values,\nnot pointers. That is, time variables and struct fields should be of\ntype time.Time, not *time.Time.\n\nA Time value can be used by multiple goroutines simultaneously except\nthat the methods GobDecode, UnmarshalBinary, UnmarshalJSON and\nUnmarshalText are not concurrency-safe.\n\nTime instants can be compared using the Before, After, and Equal methods.\nThe Sub method subtracts two instants, producing a Duration.\nThe Add method adds a Time and a Duration, producing a Time.\n\nThe zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC.\nAs this time is unlikely to come up in practice, the IsZero method gives\na simple way of detecting a time that has not been initialized explicitly.\n\nEach Time has associated with it a Location, consulted when computing the\npresentation form of the time, such as in the Format, Hour, and Year methods.\nThe methods Local, UTC, and In return a Time with a specific location.\nChanging the location in this way changes only the presentation; it does not\nchange the instant in time being denoted and therefore does not affect the\ncomputations described in earlier paragraphs.\n\nRepresentations of a Time value saved by the GobEncode, MarshalBinary,\nMarshalJSON, and MarshalText methods store the Time.Location's offset, but not\nthe location name. They therefore lose information about Daylight Saving Time.\n\nIn addition to the required “wall clock” reading, a Time may contain an optional\nreading of the current process's monotonic clock, to provide additional precision\nfor comparison or subtraction.\nSee the “Monotonic Clocks” section in the package documentation for details.\n\nNote that the Go == operator compares not just the time instant but also the\nLocation and the monotonic clock reading. Therefore, Time values should not\nbe used as map or database keys without first guaranteeing that the\nidentical Location has been set for all values, which can be achieved\nthrough use of the UTC or Local method, and that the monotonic clock reading\nhas been stripped by setting t = t.Round(0). In general, prefer t.Equal(u)\nto t == u, since t.Equal uses the most accurate comparison available and\ncorrectly handles the case when only one of its arguments has a monotonic\nclock reading.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Time"}
  Time)

JOKER TYPE go.std.time/Timer:
(def
  ^{:doc "The Timer type represents a single event.\nWhen the Timer expires, the current time will be sent on C,\nunless the Timer was created by AfterFunc.\nA Timer must be created with NewTimer or AfterFunc.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Timer"}
  Timer)

JOKER TYPE go.std.time/Weekday:
(def
  ^{:doc "A Weekday specifies a day of the week (Sunday = 0, ...).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Weekday"}
  Weekday)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["time"]
    :doc "Provides a low-level interface to the time package.\n\nPackage time provides functionality for measuring and displaying time.\n\nThe calendrical calculations always assume a Gregorian calendar, with\nno leap seconds.\n\nMonotonic Clocks\n\nOperating systems provide both a “wall clock,” which is subject to\nchanges for clock synchronization, and a “monotonic clock,” which is\nnot. The general rule is that the wall clock is for telling time and\nthe monotonic clock is for measuring time. Rather than split the API,\nin this package the Time returned by time.Now contains both a wall\nclock reading and a monotonic clock reading; later time-telling\noperations use the wall clock reading, but later time-measuring\noperations, specifically comparisons and subtractions, use the\nmonotonic clock reading.\n\nFor example, this code always computes a positive elapsed time of\napproximately 20 milliseconds, even if the wall clock is changed during\nthe operation being timed:\n\n\tstart := time.Now()\n\t... operation that takes 20 milliseconds ...\n\tt := time.Now()\n\telapsed := t.Sub(start)\n\nOther idioms, such as time.Since(start), time.Until(deadline), and\ntime.Now().Before(deadline), are similarly robust against wall clock\nresets.\n\nThe rest of this section gives the precise details of how operations\nuse monotonic clocks, but understanding those details is not required\nto use this package.\n\nThe Time returned by time.Now contains a monotonic clock reading.\nIf Time t has a monotonic clock reading, t.Add adds the same duration to\nboth the wall clock and monotonic clock readings to compute the result.\nBecause t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time\ncomputations, they always strip any monotonic clock reading from their results.\nBecause t.In, t.Local, and t.UTC are used for their effect on the interpretation\nof the wall time, they also strip any monotonic clock reading from their results.\nThe canonical way to strip a monotonic clock reading is to use t = t.Round(0).\n\nIf Times t and u both contain monotonic clock readings, the operations\nt.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out\nusing the monotonic clock readings alone, ignoring the wall clock\nreadings. If either t or u contains no monotonic clock reading, these\noperations fall back to using the wall clock readings.\n\nOn some systems the monotonic clock will stop if the computer goes to sleep.\nOn such a system, t.Sub(u) may not accurately reflect the actual\ntime that passed between t and u.\n\nBecause the monotonic clock reading has no meaning outside\nthe current process, the serialized forms generated by t.GobEncode,\nt.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic\nclock reading, and t.Format provides no format for it. Similarly, the\nconstructors time.Date, time.Parse, time.ParseInLocation, and time.Unix,\nas well as the unmarshalers t.GobDecode, t.UnmarshalBinary.\nt.UnmarshalJSON, and t.UnmarshalText always create times with\nno monotonic clock reading.\n\nNote that the Go == operator compares not just the time instant but\nalso the Location and the monotonic clock reading. See the\ndocumentation for the Time type for a discussion of equality\ntesting for Time values.\n\nFor debugging, the result of t.String does include the monotonic\nclock reading if present. If t != u because of different monotonic clock readings,\nthat difference will be visible when printing t.String() and u.String().\n"
    :empty false}
  go.std.time)
JOKER CONSTANT LowerCase from unicode/letter.go:
(def
  ^{:doc "Indices into the Delta arrays inside CaseRanges for case mapping.\n"
    :added "1.0"
    :tag "Int"
    :go "unicode.LowerCase"}
  LowerCase)

JOKER CONSTANT MaxASCII from unicode/letter.go:
(def
  ^{:doc "maximum ASCII value.\n"
    :added "1.0"
    :tag "Char"
    :go "unicode.MaxASCII"}
  MaxASCII)

JOKER CONSTANT MaxCase from unicode/letter.go:
(def
  ^{:doc "Indices into the Delta arrays inside CaseRanges for case mapping.\n"
    :added "1.0"
    :tag "Int"
    :go "unicode.MaxCase"}
  MaxCase)

JOKER CONSTANT MaxLatin1 from unicode/letter.go:
(def
  ^{:doc "maximum Latin-1 value.\n"
    :added "1.0"
    :tag "Char"
    :go "unicode.MaxLatin1"}
  MaxLatin1)

JOKER CONSTANT MaxRune from unicode/letter.go:
(def
  ^{:doc "Maximum valid Unicode code point.\n"
    :added "1.0"
    :tag "Char"
    :go "unicode.MaxRune"}
  MaxRune)

JOKER CONSTANT ReplacementChar from unicode/letter.go:
(def
  ^{:doc "Represents invalid code points.\n"
    :added "1.0"
    :tag "Char"
    :go "unicode.ReplacementChar"}
  ReplacementChar)

JOKER CONSTANT TitleCase from unicode/letter.go:
(def
  ^{:doc "Indices into the Delta arrays inside CaseRanges for case mapping.\n"
    :added "1.0"
    :tag "Int"
    :go "unicode.TitleCase"}
  TitleCase)

JOKER CONSTANT UpperCase from unicode/letter.go:
(def
  ^{:doc "Indices into the Delta arrays inside CaseRanges for case mapping.\n"
    :added "1.0"
    :tag "Int"
    :go "unicode.UpperCase"}
  UpperCase)

JOKER CONSTANT UpperLower from unicode/letter.go:
(def
  ^{:doc "(Cannot be a valid delta.)\n"
    :added "1.0"
    :tag "Int"
    :go "unicode.UpperLower"}
  UpperLower)

JOKER CONSTANT Version from unicode/tables.go:
(def
  ^{:doc "Version is the Unicode edition from which the tables are derived.\n"
    :added "1.0"
    :tag "String"
    :go "unicode.Version"}
  Version)

JOKER VARIABLE ASCII_Hex_Digit from unicode/tables.go:
(def
  ^{:doc "ASCII_Hex_Digit is the set of Unicode characters with property ASCII_Hex_Digit.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.ASCII_Hex_Digit"}
  ASCII_Hex_Digit)

JOKER VARIABLE Adlam from unicode/tables.go:
(def
  ^{:doc "Adlam is the set of Unicode characters in script Adlam.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Adlam"}
  Adlam)

JOKER VARIABLE Ahom from unicode/tables.go:
(def
  ^{:doc "Ahom is the set of Unicode characters in script Ahom.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Ahom"}
  Ahom)

JOKER VARIABLE Anatolian_Hieroglyphs from unicode/tables.go:
(def
  ^{:doc "Anatolian_Hieroglyphs is the set of Unicode characters in script Anatolian_Hieroglyphs.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Anatolian_Hieroglyphs"}
  Anatolian_Hieroglyphs)

JOKER VARIABLE Arabic from unicode/tables.go:
(def
  ^{:doc "Arabic is the set of Unicode characters in script Arabic.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Arabic"}
  Arabic)

JOKER VARIABLE Armenian from unicode/tables.go:
(def
  ^{:doc "Armenian is the set of Unicode characters in script Armenian.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Armenian"}
  Armenian)

JOKER VARIABLE Avestan from unicode/tables.go:
(def
  ^{:doc "Avestan is the set of Unicode characters in script Avestan.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Avestan"}
  Avestan)

JOKER VARIABLE AzeriCase from unicode/casetables.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "unicode.AzeriCase"}
  AzeriCase)

JOKER VARIABLE Balinese from unicode/tables.go:
(def
  ^{:doc "Balinese is the set of Unicode characters in script Balinese.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Balinese"}
  Balinese)

JOKER VARIABLE Bamum from unicode/tables.go:
(def
  ^{:doc "Bamum is the set of Unicode characters in script Bamum.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Bamum"}
  Bamum)

JOKER VARIABLE Bassa_Vah from unicode/tables.go:
(def
  ^{:doc "Bassa_Vah is the set of Unicode characters in script Bassa_Vah.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Bassa_Vah"}
  Bassa_Vah)

JOKER VARIABLE Batak from unicode/tables.go:
(def
  ^{:doc "Batak is the set of Unicode characters in script Batak.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Batak"}
  Batak)

JOKER VARIABLE Bengali from unicode/tables.go:
(def
  ^{:doc "Bengali is the set of Unicode characters in script Bengali.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Bengali"}
  Bengali)

JOKER VARIABLE Bhaiksuki from unicode/tables.go:
(def
  ^{:doc "Bhaiksuki is the set of Unicode characters in script Bhaiksuki.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Bhaiksuki"}
  Bhaiksuki)

JOKER VARIABLE Bidi_Control from unicode/tables.go:
(def
  ^{:doc "Bidi_Control is the set of Unicode characters with property Bidi_Control.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Bidi_Control"}
  Bidi_Control)

JOKER VARIABLE Bopomofo from unicode/tables.go:
(def
  ^{:doc "Bopomofo is the set of Unicode characters in script Bopomofo.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Bopomofo"}
  Bopomofo)

JOKER VARIABLE Brahmi from unicode/tables.go:
(def
  ^{:doc "Brahmi is the set of Unicode characters in script Brahmi.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Brahmi"}
  Brahmi)

JOKER VARIABLE Braille from unicode/tables.go:
(def
  ^{:doc "Braille is the set of Unicode characters in script Braille.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Braille"}
  Braille)

JOKER VARIABLE Buginese from unicode/tables.go:
(def
  ^{:doc "Buginese is the set of Unicode characters in script Buginese.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Buginese"}
  Buginese)

JOKER VARIABLE Buhid from unicode/tables.go:
(def
  ^{:doc "Buhid is the set of Unicode characters in script Buhid.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Buhid"}
  Buhid)

JOKER VARIABLE C from unicode/tables.go:
(def
  ^{:doc "These variables have type *RangeTable.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.C"}
  C)

JOKER VARIABLE Canadian_Aboriginal from unicode/tables.go:
(def
  ^{:doc "Canadian_Aboriginal is the set of Unicode characters in script Canadian_Aboriginal.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Canadian_Aboriginal"}
  Canadian_Aboriginal)

JOKER VARIABLE Carian from unicode/tables.go:
(def
  ^{:doc "Carian is the set of Unicode characters in script Carian.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Carian"}
  Carian)

JOKER VARIABLE CaseRanges from unicode/tables.go:
(def
  ^{:doc "CaseRanges is the table describing case mappings for all letters with\nnon-self mappings.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.CaseRanges"}
  CaseRanges)

JOKER VARIABLE Categories from unicode/tables.go:
(def
  ^{:doc "Categories is the set of Unicode category tables.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Categories"}
  Categories)

JOKER VARIABLE Caucasian_Albanian from unicode/tables.go:
(def
  ^{:doc "Caucasian_Albanian is the set of Unicode characters in script Caucasian_Albanian.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Caucasian_Albanian"}
  Caucasian_Albanian)

JOKER VARIABLE Cc from unicode/tables.go:
(def
  ^{:doc "Cc is the set of Unicode characters in category Cc (Other, control).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Cc"}
  Cc)

JOKER VARIABLE Cf from unicode/tables.go:
(def
  ^{:doc "Cf is the set of Unicode characters in category Cf (Other, format).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Cf"}
  Cf)

JOKER VARIABLE Chakma from unicode/tables.go:
(def
  ^{:doc "Chakma is the set of Unicode characters in script Chakma.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Chakma"}
  Chakma)

JOKER VARIABLE Cham from unicode/tables.go:
(def
  ^{:doc "Cham is the set of Unicode characters in script Cham.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Cham"}
  Cham)

JOKER VARIABLE Cherokee from unicode/tables.go:
(def
  ^{:doc "Cherokee is the set of Unicode characters in script Cherokee.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Cherokee"}
  Cherokee)

JOKER VARIABLE Co from unicode/tables.go:
(def
  ^{:doc "Co is the set of Unicode characters in category Co (Other, private use).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Co"}
  Co)

JOKER VARIABLE Common from unicode/tables.go:
(def
  ^{:doc "Common is the set of Unicode characters in script Common.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Common"}
  Common)

JOKER VARIABLE Coptic from unicode/tables.go:
(def
  ^{:doc "Coptic is the set of Unicode characters in script Coptic.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Coptic"}
  Coptic)

JOKER VARIABLE Cs from unicode/tables.go:
(def
  ^{:doc "Cs is the set of Unicode characters in category Cs (Other, surrogate).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Cs"}
  Cs)

JOKER VARIABLE Cuneiform from unicode/tables.go:
(def
  ^{:doc "Cuneiform is the set of Unicode characters in script Cuneiform.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Cuneiform"}
  Cuneiform)

JOKER VARIABLE Cypriot from unicode/tables.go:
(def
  ^{:doc "Cypriot is the set of Unicode characters in script Cypriot.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Cypriot"}
  Cypriot)

JOKER VARIABLE Cyrillic from unicode/tables.go:
(def
  ^{:doc "Cyrillic is the set of Unicode characters in script Cyrillic.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Cyrillic"}
  Cyrillic)

JOKER VARIABLE Dash from unicode/tables.go:
(def
  ^{:doc "Dash is the set of Unicode characters with property Dash.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Dash"}
  Dash)

JOKER VARIABLE Deprecated from unicode/tables.go:
(def
  ^{:doc "Deprecated is the set of Unicode characters with property Deprecated.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Deprecated"}
  Deprecated)

JOKER VARIABLE Deseret from unicode/tables.go:
(def
  ^{:doc "Deseret is the set of Unicode characters in script Deseret.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Deseret"}
  Deseret)

JOKER VARIABLE Devanagari from unicode/tables.go:
(def
  ^{:doc "Devanagari is the set of Unicode characters in script Devanagari.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Devanagari"}
  Devanagari)

JOKER VARIABLE Diacritic from unicode/tables.go:
(def
  ^{:doc "Diacritic is the set of Unicode characters with property Diacritic.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Diacritic"}
  Diacritic)

JOKER VARIABLE Digit from unicode/tables.go:
(def
  ^{:doc "Digit is the set of Unicode characters with the \"decimal digit\" property.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Digit"}
  Digit)

JOKER VARIABLE Duployan from unicode/tables.go:
(def
  ^{:doc "Duployan is the set of Unicode characters in script Duployan.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Duployan"}
  Duployan)

JOKER VARIABLE Egyptian_Hieroglyphs from unicode/tables.go:
(def
  ^{:doc "Egyptian_Hieroglyphs is the set of Unicode characters in script Egyptian_Hieroglyphs.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Egyptian_Hieroglyphs"}
  Egyptian_Hieroglyphs)

JOKER VARIABLE Elbasan from unicode/tables.go:
(def
  ^{:doc "Elbasan is the set of Unicode characters in script Elbasan.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Elbasan"}
  Elbasan)

JOKER VARIABLE Ethiopic from unicode/tables.go:
(def
  ^{:doc "Ethiopic is the set of Unicode characters in script Ethiopic.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Ethiopic"}
  Ethiopic)

JOKER VARIABLE Extender from unicode/tables.go:
(def
  ^{:doc "Extender is the set of Unicode characters with property Extender.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Extender"}
  Extender)

JOKER VARIABLE FoldCategory from unicode/tables.go:
(def
  ^{:doc "FoldCategory maps a category name to a table of\ncode points outside the category that are equivalent under\nsimple case folding to code points inside the category.\nIf there is no entry for a category name, there are no such points.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.FoldCategory"}
  FoldCategory)

JOKER VARIABLE FoldScript from unicode/tables.go:
(def
  ^{:doc "FoldScript maps a script name to a table of\ncode points outside the script that are equivalent under\nsimple case folding to code points inside the script.\nIf there is no entry for a script name, there are no such points.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.FoldScript"}
  FoldScript)

JOKER VARIABLE Georgian from unicode/tables.go:
(def
  ^{:doc "Georgian is the set of Unicode characters in script Georgian.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Georgian"}
  Georgian)

JOKER VARIABLE Glagolitic from unicode/tables.go:
(def
  ^{:doc "Glagolitic is the set of Unicode characters in script Glagolitic.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Glagolitic"}
  Glagolitic)

JOKER VARIABLE Gothic from unicode/tables.go:
(def
  ^{:doc "Gothic is the set of Unicode characters in script Gothic.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Gothic"}
  Gothic)

JOKER VARIABLE Grantha from unicode/tables.go:
(def
  ^{:doc "Grantha is the set of Unicode characters in script Grantha.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Grantha"}
  Grantha)

JOKER VARIABLE GraphicRanges from unicode/graphic.go:
(def
  ^{:doc "GraphicRanges defines the set of graphic characters according to Unicode.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.GraphicRanges"}
  GraphicRanges)

JOKER VARIABLE Greek from unicode/tables.go:
(def
  ^{:doc "Greek is the set of Unicode characters in script Greek.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Greek"}
  Greek)

JOKER VARIABLE Gujarati from unicode/tables.go:
(def
  ^{:doc "Gujarati is the set of Unicode characters in script Gujarati.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Gujarati"}
  Gujarati)

JOKER VARIABLE Gurmukhi from unicode/tables.go:
(def
  ^{:doc "Gurmukhi is the set of Unicode characters in script Gurmukhi.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Gurmukhi"}
  Gurmukhi)

JOKER VARIABLE Han from unicode/tables.go:
(def
  ^{:doc "Han is the set of Unicode characters in script Han.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Han"}
  Han)

JOKER VARIABLE Hangul from unicode/tables.go:
(def
  ^{:doc "Hangul is the set of Unicode characters in script Hangul.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Hangul"}
  Hangul)

JOKER VARIABLE Hanunoo from unicode/tables.go:
(def
  ^{:doc "Hanunoo is the set of Unicode characters in script Hanunoo.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Hanunoo"}
  Hanunoo)

JOKER VARIABLE Hatran from unicode/tables.go:
(def
  ^{:doc "Hatran is the set of Unicode characters in script Hatran.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Hatran"}
  Hatran)

JOKER VARIABLE Hebrew from unicode/tables.go:
(def
  ^{:doc "Hebrew is the set of Unicode characters in script Hebrew.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Hebrew"}
  Hebrew)

JOKER VARIABLE Hex_Digit from unicode/tables.go:
(def
  ^{:doc "Hex_Digit is the set of Unicode characters with property Hex_Digit.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Hex_Digit"}
  Hex_Digit)

JOKER VARIABLE Hiragana from unicode/tables.go:
(def
  ^{:doc "Hiragana is the set of Unicode characters in script Hiragana.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Hiragana"}
  Hiragana)

JOKER VARIABLE Hyphen from unicode/tables.go:
(def
  ^{:doc "Hyphen is the set of Unicode characters with property Hyphen.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Hyphen"}
  Hyphen)

JOKER VARIABLE IDS_Binary_Operator from unicode/tables.go:
(def
  ^{:doc "IDS_Binary_Operator is the set of Unicode characters with property IDS_Binary_Operator.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.IDS_Binary_Operator"}
  IDS_Binary_Operator)

JOKER VARIABLE IDS_Trinary_Operator from unicode/tables.go:
(def
  ^{:doc "IDS_Trinary_Operator is the set of Unicode characters with property IDS_Trinary_Operator.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.IDS_Trinary_Operator"}
  IDS_Trinary_Operator)

JOKER VARIABLE Ideographic from unicode/tables.go:
(def
  ^{:doc "Ideographic is the set of Unicode characters with property Ideographic.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Ideographic"}
  Ideographic)

JOKER VARIABLE Imperial_Aramaic from unicode/tables.go:
(def
  ^{:doc "Imperial_Aramaic is the set of Unicode characters in script Imperial_Aramaic.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Imperial_Aramaic"}
  Imperial_Aramaic)

JOKER VARIABLE Inherited from unicode/tables.go:
(def
  ^{:doc "Inherited is the set of Unicode characters in script Inherited.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Inherited"}
  Inherited)

JOKER VARIABLE Inscriptional_Pahlavi from unicode/tables.go:
(def
  ^{:doc "Inscriptional_Pahlavi is the set of Unicode characters in script Inscriptional_Pahlavi.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Inscriptional_Pahlavi"}
  Inscriptional_Pahlavi)

JOKER VARIABLE Inscriptional_Parthian from unicode/tables.go:
(def
  ^{:doc "Inscriptional_Parthian is the set of Unicode characters in script Inscriptional_Parthian.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Inscriptional_Parthian"}
  Inscriptional_Parthian)

JOKER VARIABLE Javanese from unicode/tables.go:
(def
  ^{:doc "Javanese is the set of Unicode characters in script Javanese.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Javanese"}
  Javanese)

JOKER VARIABLE Join_Control from unicode/tables.go:
(def
  ^{:doc "Join_Control is the set of Unicode characters with property Join_Control.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Join_Control"}
  Join_Control)

JOKER VARIABLE Kaithi from unicode/tables.go:
(def
  ^{:doc "Kaithi is the set of Unicode characters in script Kaithi.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Kaithi"}
  Kaithi)

JOKER VARIABLE Kannada from unicode/tables.go:
(def
  ^{:doc "Kannada is the set of Unicode characters in script Kannada.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Kannada"}
  Kannada)

JOKER VARIABLE Katakana from unicode/tables.go:
(def
  ^{:doc "Katakana is the set of Unicode characters in script Katakana.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Katakana"}
  Katakana)

JOKER VARIABLE Kayah_Li from unicode/tables.go:
(def
  ^{:doc "Kayah_Li is the set of Unicode characters in script Kayah_Li.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Kayah_Li"}
  Kayah_Li)

JOKER VARIABLE Kharoshthi from unicode/tables.go:
(def
  ^{:doc "Kharoshthi is the set of Unicode characters in script Kharoshthi.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Kharoshthi"}
  Kharoshthi)

JOKER VARIABLE Khmer from unicode/tables.go:
(def
  ^{:doc "Khmer is the set of Unicode characters in script Khmer.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Khmer"}
  Khmer)

JOKER VARIABLE Khojki from unicode/tables.go:
(def
  ^{:doc "Khojki is the set of Unicode characters in script Khojki.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Khojki"}
  Khojki)

JOKER VARIABLE Khudawadi from unicode/tables.go:
(def
  ^{:doc "Khudawadi is the set of Unicode characters in script Khudawadi.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Khudawadi"}
  Khudawadi)

JOKER VARIABLE L from unicode/tables.go:
(def
  ^{:doc "These variables have type *RangeTable.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.L"}
  L)

JOKER VARIABLE Lao from unicode/tables.go:
(def
  ^{:doc "Lao is the set of Unicode characters in script Lao.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Lao"}
  Lao)

JOKER VARIABLE Latin from unicode/tables.go:
(def
  ^{:doc "Latin is the set of Unicode characters in script Latin.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Latin"}
  Latin)

JOKER VARIABLE Lepcha from unicode/tables.go:
(def
  ^{:doc "Lepcha is the set of Unicode characters in script Lepcha.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Lepcha"}
  Lepcha)

JOKER VARIABLE Letter from unicode/tables.go:
(def
  ^{:doc "Letter/L is the set of Unicode letters, category L.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Letter"}
  Letter)

JOKER VARIABLE Limbu from unicode/tables.go:
(def
  ^{:doc "Limbu is the set of Unicode characters in script Limbu.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Limbu"}
  Limbu)

JOKER VARIABLE Linear_A from unicode/tables.go:
(def
  ^{:doc "Linear_A is the set of Unicode characters in script Linear_A.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Linear_A"}
  Linear_A)

JOKER VARIABLE Linear_B from unicode/tables.go:
(def
  ^{:doc "Linear_B is the set of Unicode characters in script Linear_B.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Linear_B"}
  Linear_B)

JOKER VARIABLE Lisu from unicode/tables.go:
(def
  ^{:doc "Lisu is the set of Unicode characters in script Lisu.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Lisu"}
  Lisu)

JOKER VARIABLE Ll from unicode/tables.go:
(def
  ^{:doc "Ll is the set of Unicode characters in category Ll (Letter, lowercase).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Ll"}
  Ll)

JOKER VARIABLE Lm from unicode/tables.go:
(def
  ^{:doc "Lm is the set of Unicode characters in category Lm (Letter, modifier).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Lm"}
  Lm)

JOKER VARIABLE Lo from unicode/tables.go:
(def
  ^{:doc "Lo is the set of Unicode characters in category Lo (Letter, other).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Lo"}
  Lo)

JOKER VARIABLE Logical_Order_Exception from unicode/tables.go:
(def
  ^{:doc "Logical_Order_Exception is the set of Unicode characters with property Logical_Order_Exception.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Logical_Order_Exception"}
  Logical_Order_Exception)

JOKER VARIABLE Lower from unicode/tables.go:
(def
  ^{:doc "Lower is the set of Unicode lower case letters.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Lower"}
  Lower)

JOKER VARIABLE Lt from unicode/tables.go:
(def
  ^{:doc "Lt is the set of Unicode characters in category Lt (Letter, titlecase).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Lt"}
  Lt)

JOKER VARIABLE Lu from unicode/tables.go:
(def
  ^{:doc "Lu is the set of Unicode characters in category Lu (Letter, uppercase).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Lu"}
  Lu)

JOKER VARIABLE Lycian from unicode/tables.go:
(def
  ^{:doc "Lycian is the set of Unicode characters in script Lycian.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Lycian"}
  Lycian)

JOKER VARIABLE Lydian from unicode/tables.go:
(def
  ^{:doc "Lydian is the set of Unicode characters in script Lydian.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Lydian"}
  Lydian)

JOKER VARIABLE M from unicode/tables.go:
(def
  ^{:doc "These variables have type *RangeTable.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.M"}
  M)

JOKER VARIABLE Mahajani from unicode/tables.go:
(def
  ^{:doc "Mahajani is the set of Unicode characters in script Mahajani.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Mahajani"}
  Mahajani)

JOKER VARIABLE Malayalam from unicode/tables.go:
(def
  ^{:doc "Malayalam is the set of Unicode characters in script Malayalam.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Malayalam"}
  Malayalam)

JOKER VARIABLE Mandaic from unicode/tables.go:
(def
  ^{:doc "Mandaic is the set of Unicode characters in script Mandaic.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Mandaic"}
  Mandaic)

JOKER VARIABLE Manichaean from unicode/tables.go:
(def
  ^{:doc "Manichaean is the set of Unicode characters in script Manichaean.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Manichaean"}
  Manichaean)

JOKER VARIABLE Marchen from unicode/tables.go:
(def
  ^{:doc "Marchen is the set of Unicode characters in script Marchen.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Marchen"}
  Marchen)

JOKER VARIABLE Mark from unicode/tables.go:
(def
  ^{:doc "Mark/M is the set of Unicode mark characters, category M.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Mark"}
  Mark)

JOKER VARIABLE Masaram_Gondi from unicode/tables.go:
(def
  ^{:doc "Masaram_Gondi is the set of Unicode characters in script Masaram_Gondi.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Masaram_Gondi"}
  Masaram_Gondi)

JOKER VARIABLE Mc from unicode/tables.go:
(def
  ^{:doc "Mc is the set of Unicode characters in category Mc (Mark, spacing combining).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Mc"}
  Mc)

JOKER VARIABLE Me from unicode/tables.go:
(def
  ^{:doc "Me is the set of Unicode characters in category Me (Mark, enclosing).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Me"}
  Me)

JOKER VARIABLE Meetei_Mayek from unicode/tables.go:
(def
  ^{:doc "Meetei_Mayek is the set of Unicode characters in script Meetei_Mayek.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Meetei_Mayek"}
  Meetei_Mayek)

JOKER VARIABLE Mende_Kikakui from unicode/tables.go:
(def
  ^{:doc "Mende_Kikakui is the set of Unicode characters in script Mende_Kikakui.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Mende_Kikakui"}
  Mende_Kikakui)

JOKER VARIABLE Meroitic_Cursive from unicode/tables.go:
(def
  ^{:doc "Meroitic_Cursive is the set of Unicode characters in script Meroitic_Cursive.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Meroitic_Cursive"}
  Meroitic_Cursive)

JOKER VARIABLE Meroitic_Hieroglyphs from unicode/tables.go:
(def
  ^{:doc "Meroitic_Hieroglyphs is the set of Unicode characters in script Meroitic_Hieroglyphs.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Meroitic_Hieroglyphs"}
  Meroitic_Hieroglyphs)

JOKER VARIABLE Miao from unicode/tables.go:
(def
  ^{:doc "Miao is the set of Unicode characters in script Miao.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Miao"}
  Miao)

JOKER VARIABLE Mn from unicode/tables.go:
(def
  ^{:doc "Mn is the set of Unicode characters in category Mn (Mark, nonspacing).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Mn"}
  Mn)

JOKER VARIABLE Modi from unicode/tables.go:
(def
  ^{:doc "Modi is the set of Unicode characters in script Modi.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Modi"}
  Modi)

JOKER VARIABLE Mongolian from unicode/tables.go:
(def
  ^{:doc "Mongolian is the set of Unicode characters in script Mongolian.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Mongolian"}
  Mongolian)

JOKER VARIABLE Mro from unicode/tables.go:
(def
  ^{:doc "Mro is the set of Unicode characters in script Mro.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Mro"}
  Mro)

JOKER VARIABLE Multani from unicode/tables.go:
(def
  ^{:doc "Multani is the set of Unicode characters in script Multani.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Multani"}
  Multani)

JOKER VARIABLE Myanmar from unicode/tables.go:
(def
  ^{:doc "Myanmar is the set of Unicode characters in script Myanmar.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Myanmar"}
  Myanmar)

JOKER VARIABLE N from unicode/tables.go:
(def
  ^{:doc "These variables have type *RangeTable.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.N"}
  N)

JOKER VARIABLE Nabataean from unicode/tables.go:
(def
  ^{:doc "Nabataean is the set of Unicode characters in script Nabataean.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Nabataean"}
  Nabataean)

JOKER VARIABLE Nd from unicode/tables.go:
(def
  ^{:doc "Nd is the set of Unicode characters in category Nd (Number, decimal digit).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Nd"}
  Nd)

JOKER VARIABLE New_Tai_Lue from unicode/tables.go:
(def
  ^{:doc "New_Tai_Lue is the set of Unicode characters in script New_Tai_Lue.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.New_Tai_Lue"}
  New_Tai_Lue)

JOKER VARIABLE Newa from unicode/tables.go:
(def
  ^{:doc "Newa is the set of Unicode characters in script Newa.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Newa"}
  Newa)

JOKER VARIABLE Nko from unicode/tables.go:
(def
  ^{:doc "Nko is the set of Unicode characters in script Nko.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Nko"}
  Nko)

JOKER VARIABLE Nl from unicode/tables.go:
(def
  ^{:doc "Nl is the set of Unicode characters in category Nl (Number, letter).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Nl"}
  Nl)

JOKER VARIABLE No from unicode/tables.go:
(def
  ^{:doc "No is the set of Unicode characters in category No (Number, other).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.No"}
  No)

JOKER VARIABLE Noncharacter_Code_Point from unicode/tables.go:
(def
  ^{:doc "Noncharacter_Code_Point is the set of Unicode characters with property Noncharacter_Code_Point.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Noncharacter_Code_Point"}
  Noncharacter_Code_Point)

JOKER VARIABLE Number from unicode/tables.go:
(def
  ^{:doc "Number/N is the set of Unicode number characters, category N.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Number"}
  Number)

JOKER VARIABLE Nushu from unicode/tables.go:
(def
  ^{:doc "Nushu is the set of Unicode characters in script Nushu.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Nushu"}
  Nushu)

JOKER VARIABLE Ogham from unicode/tables.go:
(def
  ^{:doc "Ogham is the set of Unicode characters in script Ogham.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Ogham"}
  Ogham)

JOKER VARIABLE Ol_Chiki from unicode/tables.go:
(def
  ^{:doc "Ol_Chiki is the set of Unicode characters in script Ol_Chiki.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Ol_Chiki"}
  Ol_Chiki)

JOKER VARIABLE Old_Hungarian from unicode/tables.go:
(def
  ^{:doc "Old_Hungarian is the set of Unicode characters in script Old_Hungarian.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Old_Hungarian"}
  Old_Hungarian)

JOKER VARIABLE Old_Italic from unicode/tables.go:
(def
  ^{:doc "Old_Italic is the set of Unicode characters in script Old_Italic.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Old_Italic"}
  Old_Italic)

JOKER VARIABLE Old_North_Arabian from unicode/tables.go:
(def
  ^{:doc "Old_North_Arabian is the set of Unicode characters in script Old_North_Arabian.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Old_North_Arabian"}
  Old_North_Arabian)

JOKER VARIABLE Old_Permic from unicode/tables.go:
(def
  ^{:doc "Old_Permic is the set of Unicode characters in script Old_Permic.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Old_Permic"}
  Old_Permic)

JOKER VARIABLE Old_Persian from unicode/tables.go:
(def
  ^{:doc "Old_Persian is the set of Unicode characters in script Old_Persian.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Old_Persian"}
  Old_Persian)

JOKER VARIABLE Old_South_Arabian from unicode/tables.go:
(def
  ^{:doc "Old_South_Arabian is the set of Unicode characters in script Old_South_Arabian.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Old_South_Arabian"}
  Old_South_Arabian)

JOKER VARIABLE Old_Turkic from unicode/tables.go:
(def
  ^{:doc "Old_Turkic is the set of Unicode characters in script Old_Turkic.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Old_Turkic"}
  Old_Turkic)

JOKER VARIABLE Oriya from unicode/tables.go:
(def
  ^{:doc "Oriya is the set of Unicode characters in script Oriya.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Oriya"}
  Oriya)

JOKER VARIABLE Osage from unicode/tables.go:
(def
  ^{:doc "Osage is the set of Unicode characters in script Osage.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Osage"}
  Osage)

JOKER VARIABLE Osmanya from unicode/tables.go:
(def
  ^{:doc "Osmanya is the set of Unicode characters in script Osmanya.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Osmanya"}
  Osmanya)

JOKER VARIABLE Other from unicode/tables.go:
(def
  ^{:doc "Other/C is the set of Unicode control and special characters, category C.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Other"}
  Other)

JOKER VARIABLE Other_Alphabetic from unicode/tables.go:
(def
  ^{:doc "Other_Alphabetic is the set of Unicode characters with property Other_Alphabetic.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Other_Alphabetic"}
  Other_Alphabetic)

JOKER VARIABLE Other_Default_Ignorable_Code_Point from unicode/tables.go:
(def
  ^{:doc "Other_Default_Ignorable_Code_Point is the set of Unicode characters with property Other_Default_Ignorable_Code_Point.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Other_Default_Ignorable_Code_Point"}
  Other_Default_Ignorable_Code_Point)

JOKER VARIABLE Other_Grapheme_Extend from unicode/tables.go:
(def
  ^{:doc "Other_Grapheme_Extend is the set of Unicode characters with property Other_Grapheme_Extend.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Other_Grapheme_Extend"}
  Other_Grapheme_Extend)

JOKER VARIABLE Other_ID_Continue from unicode/tables.go:
(def
  ^{:doc "Other_ID_Continue is the set of Unicode characters with property Other_ID_Continue.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Other_ID_Continue"}
  Other_ID_Continue)

JOKER VARIABLE Other_ID_Start from unicode/tables.go:
(def
  ^{:doc "Other_ID_Start is the set of Unicode characters with property Other_ID_Start.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Other_ID_Start"}
  Other_ID_Start)

JOKER VARIABLE Other_Lowercase from unicode/tables.go:
(def
  ^{:doc "Other_Lowercase is the set of Unicode characters with property Other_Lowercase.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Other_Lowercase"}
  Other_Lowercase)

JOKER VARIABLE Other_Math from unicode/tables.go:
(def
  ^{:doc "Other_Math is the set of Unicode characters with property Other_Math.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Other_Math"}
  Other_Math)

JOKER VARIABLE Other_Uppercase from unicode/tables.go:
(def
  ^{:doc "Other_Uppercase is the set of Unicode characters with property Other_Uppercase.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Other_Uppercase"}
  Other_Uppercase)

JOKER VARIABLE P from unicode/tables.go:
(def
  ^{:doc "These variables have type *RangeTable.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.P"}
  P)

JOKER VARIABLE Pahawh_Hmong from unicode/tables.go:
(def
  ^{:doc "Pahawh_Hmong is the set of Unicode characters in script Pahawh_Hmong.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Pahawh_Hmong"}
  Pahawh_Hmong)

JOKER VARIABLE Palmyrene from unicode/tables.go:
(def
  ^{:doc "Palmyrene is the set of Unicode characters in script Palmyrene.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Palmyrene"}
  Palmyrene)

JOKER VARIABLE Pattern_Syntax from unicode/tables.go:
(def
  ^{:doc "Pattern_Syntax is the set of Unicode characters with property Pattern_Syntax.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Pattern_Syntax"}
  Pattern_Syntax)

JOKER VARIABLE Pattern_White_Space from unicode/tables.go:
(def
  ^{:doc "Pattern_White_Space is the set of Unicode characters with property Pattern_White_Space.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Pattern_White_Space"}
  Pattern_White_Space)

JOKER VARIABLE Pau_Cin_Hau from unicode/tables.go:
(def
  ^{:doc "Pau_Cin_Hau is the set of Unicode characters in script Pau_Cin_Hau.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Pau_Cin_Hau"}
  Pau_Cin_Hau)

JOKER VARIABLE Pc from unicode/tables.go:
(def
  ^{:doc "Pc is the set of Unicode characters in category Pc (Punctuation, connector).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Pc"}
  Pc)

JOKER VARIABLE Pd from unicode/tables.go:
(def
  ^{:doc "Pd is the set of Unicode characters in category Pd (Punctuation, dash).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Pd"}
  Pd)

JOKER VARIABLE Pe from unicode/tables.go:
(def
  ^{:doc "Pe is the set of Unicode characters in category Pe (Punctuation, close).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Pe"}
  Pe)

JOKER VARIABLE Pf from unicode/tables.go:
(def
  ^{:doc "Pf is the set of Unicode characters in category Pf (Punctuation, final quote).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Pf"}
  Pf)

JOKER VARIABLE Phags_Pa from unicode/tables.go:
(def
  ^{:doc "Phags_Pa is the set of Unicode characters in script Phags_Pa.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Phags_Pa"}
  Phags_Pa)

JOKER VARIABLE Phoenician from unicode/tables.go:
(def
  ^{:doc "Phoenician is the set of Unicode characters in script Phoenician.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Phoenician"}
  Phoenician)

JOKER VARIABLE Pi from unicode/tables.go:
(def
  ^{:doc "Pi is the set of Unicode characters in category Pi (Punctuation, initial quote).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Pi"}
  Pi)

JOKER VARIABLE Po from unicode/tables.go:
(def
  ^{:doc "Po is the set of Unicode characters in category Po (Punctuation, other).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Po"}
  Po)

JOKER VARIABLE Prepended_Concatenation_Mark from unicode/tables.go:
(def
  ^{:doc "Prepended_Concatenation_Mark is the set of Unicode characters with property Prepended_Concatenation_Mark.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Prepended_Concatenation_Mark"}
  Prepended_Concatenation_Mark)

JOKER VARIABLE PrintRanges from unicode/graphic.go:
(def
  ^{:doc "PrintRanges defines the set of printable characters according to Go.\nASCII space, U+0020, is handled separately.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.PrintRanges"}
  PrintRanges)

JOKER VARIABLE Properties from unicode/tables.go:
(def
  ^{:doc "Properties is the set of Unicode property tables.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Properties"}
  Properties)

JOKER VARIABLE Ps from unicode/tables.go:
(def
  ^{:doc "Ps is the set of Unicode characters in category Ps (Punctuation, open).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Ps"}
  Ps)

JOKER VARIABLE Psalter_Pahlavi from unicode/tables.go:
(def
  ^{:doc "Psalter_Pahlavi is the set of Unicode characters in script Psalter_Pahlavi.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Psalter_Pahlavi"}
  Psalter_Pahlavi)

JOKER VARIABLE Punct from unicode/tables.go:
(def
  ^{:doc "Punct/P is the set of Unicode punctuation characters, category P.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Punct"}
  Punct)

JOKER VARIABLE Quotation_Mark from unicode/tables.go:
(def
  ^{:doc "Quotation_Mark is the set of Unicode characters with property Quotation_Mark.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Quotation_Mark"}
  Quotation_Mark)

JOKER VARIABLE Radical from unicode/tables.go:
(def
  ^{:doc "Radical is the set of Unicode characters with property Radical.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Radical"}
  Radical)

JOKER VARIABLE Regional_Indicator from unicode/tables.go:
(def
  ^{:doc "Regional_Indicator is the set of Unicode characters with property Regional_Indicator.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Regional_Indicator"}
  Regional_Indicator)

JOKER VARIABLE Rejang from unicode/tables.go:
(def
  ^{:doc "Rejang is the set of Unicode characters in script Rejang.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Rejang"}
  Rejang)

JOKER VARIABLE Runic from unicode/tables.go:
(def
  ^{:doc "Runic is the set of Unicode characters in script Runic.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Runic"}
  Runic)

JOKER VARIABLE S from unicode/tables.go:
(def
  ^{:doc "These variables have type *RangeTable.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.S"}
  S)

JOKER VARIABLE STerm from unicode/tables.go:
(def
  ^{:doc "STerm is an alias for Sentence_Terminal.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.STerm"}
  STerm)

JOKER VARIABLE Samaritan from unicode/tables.go:
(def
  ^{:doc "Samaritan is the set of Unicode characters in script Samaritan.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Samaritan"}
  Samaritan)

JOKER VARIABLE Saurashtra from unicode/tables.go:
(def
  ^{:doc "Saurashtra is the set of Unicode characters in script Saurashtra.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Saurashtra"}
  Saurashtra)

JOKER VARIABLE Sc from unicode/tables.go:
(def
  ^{:doc "Sc is the set of Unicode characters in category Sc (Symbol, currency).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Sc"}
  Sc)

JOKER VARIABLE Scripts from unicode/tables.go:
(def
  ^{:doc "Scripts is the set of Unicode script tables.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Scripts"}
  Scripts)

JOKER VARIABLE Sentence_Terminal from unicode/tables.go:
(def
  ^{:doc "Sentence_Terminal is the set of Unicode characters with property Sentence_Terminal.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Sentence_Terminal"}
  Sentence_Terminal)

JOKER VARIABLE Sharada from unicode/tables.go:
(def
  ^{:doc "Sharada is the set of Unicode characters in script Sharada.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Sharada"}
  Sharada)

JOKER VARIABLE Shavian from unicode/tables.go:
(def
  ^{:doc "Shavian is the set of Unicode characters in script Shavian.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Shavian"}
  Shavian)

JOKER VARIABLE Siddham from unicode/tables.go:
(def
  ^{:doc "Siddham is the set of Unicode characters in script Siddham.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Siddham"}
  Siddham)

JOKER VARIABLE SignWriting from unicode/tables.go:
(def
  ^{:doc "SignWriting is the set of Unicode characters in script SignWriting.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.SignWriting"}
  SignWriting)

JOKER VARIABLE Sinhala from unicode/tables.go:
(def
  ^{:doc "Sinhala is the set of Unicode characters in script Sinhala.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Sinhala"}
  Sinhala)

JOKER VARIABLE Sk from unicode/tables.go:
(def
  ^{:doc "Sk is the set of Unicode characters in category Sk (Symbol, modifier).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Sk"}
  Sk)

JOKER VARIABLE Sm from unicode/tables.go:
(def
  ^{:doc "Sm is the set of Unicode characters in category Sm (Symbol, math).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Sm"}
  Sm)

JOKER VARIABLE So from unicode/tables.go:
(def
  ^{:doc "So is the set of Unicode characters in category So (Symbol, other).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.So"}
  So)

JOKER VARIABLE Soft_Dotted from unicode/tables.go:
(def
  ^{:doc "Soft_Dotted is the set of Unicode characters with property Soft_Dotted.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Soft_Dotted"}
  Soft_Dotted)

JOKER VARIABLE Sora_Sompeng from unicode/tables.go:
(def
  ^{:doc "Sora_Sompeng is the set of Unicode characters in script Sora_Sompeng.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Sora_Sompeng"}
  Sora_Sompeng)

JOKER VARIABLE Soyombo from unicode/tables.go:
(def
  ^{:doc "Soyombo is the set of Unicode characters in script Soyombo.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Soyombo"}
  Soyombo)

JOKER VARIABLE Space from unicode/tables.go:
(def
  ^{:doc "Space/Z is the set of Unicode space characters, category Z.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Space"}
  Space)

JOKER VARIABLE Sundanese from unicode/tables.go:
(def
  ^{:doc "Sundanese is the set of Unicode characters in script Sundanese.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Sundanese"}
  Sundanese)

JOKER VARIABLE Syloti_Nagri from unicode/tables.go:
(def
  ^{:doc "Syloti_Nagri is the set of Unicode characters in script Syloti_Nagri.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Syloti_Nagri"}
  Syloti_Nagri)

JOKER VARIABLE Symbol from unicode/tables.go:
(def
  ^{:doc "Symbol/S is the set of Unicode symbol characters, category S.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Symbol"}
  Symbol)

JOKER VARIABLE Syriac from unicode/tables.go:
(def
  ^{:doc "Syriac is the set of Unicode characters in script Syriac.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Syriac"}
  Syriac)

JOKER VARIABLE Tagalog from unicode/tables.go:
(def
  ^{:doc "Tagalog is the set of Unicode characters in script Tagalog.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Tagalog"}
  Tagalog)

JOKER VARIABLE Tagbanwa from unicode/tables.go:
(def
  ^{:doc "Tagbanwa is the set of Unicode characters in script Tagbanwa.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Tagbanwa"}
  Tagbanwa)

JOKER VARIABLE Tai_Le from unicode/tables.go:
(def
  ^{:doc "Tai_Le is the set of Unicode characters in script Tai_Le.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Tai_Le"}
  Tai_Le)

JOKER VARIABLE Tai_Tham from unicode/tables.go:
(def
  ^{:doc "Tai_Tham is the set of Unicode characters in script Tai_Tham.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Tai_Tham"}
  Tai_Tham)

JOKER VARIABLE Tai_Viet from unicode/tables.go:
(def
  ^{:doc "Tai_Viet is the set of Unicode characters in script Tai_Viet.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Tai_Viet"}
  Tai_Viet)

JOKER VARIABLE Takri from unicode/tables.go:
(def
  ^{:doc "Takri is the set of Unicode characters in script Takri.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Takri"}
  Takri)

JOKER VARIABLE Tamil from unicode/tables.go:
(def
  ^{:doc "Tamil is the set of Unicode characters in script Tamil.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Tamil"}
  Tamil)

JOKER VARIABLE Tangut from unicode/tables.go:
(def
  ^{:doc "Tangut is the set of Unicode characters in script Tangut.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Tangut"}
  Tangut)

JOKER VARIABLE Telugu from unicode/tables.go:
(def
  ^{:doc "Telugu is the set of Unicode characters in script Telugu.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Telugu"}
  Telugu)

JOKER VARIABLE Terminal_Punctuation from unicode/tables.go:
(def
  ^{:doc "Terminal_Punctuation is the set of Unicode characters with property Terminal_Punctuation.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Terminal_Punctuation"}
  Terminal_Punctuation)

JOKER VARIABLE Thaana from unicode/tables.go:
(def
  ^{:doc "Thaana is the set of Unicode characters in script Thaana.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Thaana"}
  Thaana)

JOKER VARIABLE Thai from unicode/tables.go:
(def
  ^{:doc "Thai is the set of Unicode characters in script Thai.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Thai"}
  Thai)

JOKER VARIABLE Tibetan from unicode/tables.go:
(def
  ^{:doc "Tibetan is the set of Unicode characters in script Tibetan.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Tibetan"}
  Tibetan)

JOKER VARIABLE Tifinagh from unicode/tables.go:
(def
  ^{:doc "Tifinagh is the set of Unicode characters in script Tifinagh.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Tifinagh"}
  Tifinagh)

JOKER VARIABLE Tirhuta from unicode/tables.go:
(def
  ^{:doc "Tirhuta is the set of Unicode characters in script Tirhuta.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Tirhuta"}
  Tirhuta)

JOKER VARIABLE Title from unicode/tables.go:
(def
  ^{:doc "Title is the set of Unicode title case letters.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Title"}
  Title)

JOKER VARIABLE TurkishCase from unicode/casetables.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "unicode.TurkishCase"}
  TurkishCase)

JOKER VARIABLE Ugaritic from unicode/tables.go:
(def
  ^{:doc "Ugaritic is the set of Unicode characters in script Ugaritic.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Ugaritic"}
  Ugaritic)

JOKER VARIABLE Unified_Ideograph from unicode/tables.go:
(def
  ^{:doc "Unified_Ideograph is the set of Unicode characters with property Unified_Ideograph.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Unified_Ideograph"}
  Unified_Ideograph)

JOKER VARIABLE Upper from unicode/tables.go:
(def
  ^{:doc "Upper is the set of Unicode upper case letters.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Upper"}
  Upper)

JOKER VARIABLE Vai from unicode/tables.go:
(def
  ^{:doc "Vai is the set of Unicode characters in script Vai.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Vai"}
  Vai)

JOKER VARIABLE Variation_Selector from unicode/tables.go:
(def
  ^{:doc "Variation_Selector is the set of Unicode characters with property Variation_Selector.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Variation_Selector"}
  Variation_Selector)

JOKER VARIABLE Warang_Citi from unicode/tables.go:
(def
  ^{:doc "Warang_Citi is the set of Unicode characters in script Warang_Citi.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Warang_Citi"}
  Warang_Citi)

JOKER VARIABLE White_Space from unicode/tables.go:
(def
  ^{:doc "White_Space is the set of Unicode characters with property White_Space.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.White_Space"}
  White_Space)

JOKER VARIABLE Yi from unicode/tables.go:
(def
  ^{:doc "Yi is the set of Unicode characters in script Yi.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Yi"}
  Yi)

JOKER VARIABLE Z from unicode/tables.go:
(def
  ^{:doc "These variables have type *RangeTable.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Z"}
  Z)

JOKER VARIABLE Zanabazar_Square from unicode/tables.go:
(def
  ^{:doc "Zanabazar_Square is the set of Unicode characters in script Zanabazar_Square.\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Zanabazar_Square"}
  Zanabazar_Square)

JOKER VARIABLE Zl from unicode/tables.go:
(def
  ^{:doc "Zl is the set of Unicode characters in category Zl (Separator, line).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Zl"}
  Zl)

JOKER VARIABLE Zp from unicode/tables.go:
(def
  ^{:doc "Zp is the set of Unicode characters in category Zp (Separator, paragraph).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Zp"}
  Zp)

JOKER VARIABLE Zs from unicode/tables.go:
(def
  ^{:doc "Zs is the set of Unicode characters in category Zs (Separator, space).\n"
    :added "1.0"
    :tag "Var"
    :go "unicode.Zs"}
  Zs)

JOKER TYPE unicode.CaseRange from unicode/letter.go:
;; (defn ^"GoObject" CaseRange.
;;   "Constructor for unicode.CaseRange"
;;   {:added "1.0"
;;    :go "_ConstructCaseRange(_v)"}
;;   [^Object _v])

JOKER TYPE unicode.Range16 from unicode/letter.go:
(defn ^"GoObject" Range16.
  "Constructor for unicode.Range16"
  {:added "1.0"
   :go "_ConstructRange16(_v)"}
  [^Object _v])

JOKER TYPE unicode.Range32 from unicode/letter.go:
(defn ^"GoObject" Range32.
  "Constructor for unicode.Range32"
  {:added "1.0"
   :go "_ConstructRange32(_v)"}
  [^Object _v])

JOKER TYPE unicode.RangeTable from unicode/letter.go:
;; (defn ^"GoObject" RangeTable.
;;   "Constructor for unicode.RangeTable"
;;   {:added "1.0"
;;    :go "_ConstructRangeTable(_v)"}
;;   [^Object _v])

JOKER TYPE unicode.SpecialCase from unicode/letter.go:
;; (defn ^"GoObject" SpecialCase.
;;   "Constructor for unicode.SpecialCase"
;;   {:added "1.0"
;;    :go "_ConstructSpecialCase(_v)"}
;;   [^Object _v])

JOKER FUNC unicode.In from unicode/graphic.go:
;; (defn ^"Boolean" In
;;   "In reports whether the rune is a member of one of the ranges.\n\nGo input arguments: (r rune, ranges ...*RangeTable)\n\nGo return type: bool\n\nJoker input arguments: [^Char r, ^(ellipsis-somehow unicode/RangeTable) ranges]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "unicode.In(__r, ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHa*_unicode.RangeTable(__ranges)))"}
;;   [^Char __r, ^unicode/RangeTable __ranges])

JOKER FUNC unicode.Is from unicode/letter.go:
(defn ^"Boolean" Is
  "Is reports whether the rune is in the specified table of ranges.\n\nGo input arguments: (rangeTab *RangeTable, r rune)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.unicode/RangeTable) rangeTab, ^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.Is(__rangeTab, __r)"}
  [^unicode/RangeTable __rangeTab, ^Char __r])

JOKER FUNC unicode.IsControl from unicode/graphic.go:
(defn ^"Boolean" IsControl
  "IsControl reports whether the rune is a control character.\nThe C (Other) Unicode category includes more code points\nsuch as surrogates; use Is(C, r) to test for them.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsControl(__r)"}
  [^Char __r])

JOKER FUNC unicode.IsDigit from unicode/digit.go:
(defn ^"Boolean" IsDigit
  "IsDigit reports whether the rune is a decimal digit.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsDigit(__r)"}
  [^Char __r])

JOKER FUNC unicode.IsGraphic from unicode/graphic.go:
(defn ^"Boolean" IsGraphic
  "IsGraphic reports whether the rune is defined as a Graphic by Unicode.\nSuch characters include letters, marks, numbers, punctuation, symbols, and\nspaces, from categories L, M, N, P, S, Zs.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsGraphic(__r)"}
  [^Char __r])

JOKER FUNC unicode.IsLetter from unicode/graphic.go:
(defn ^"Boolean" IsLetter
  "IsLetter reports whether the rune is a letter (category L).\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsLetter(__r)"}
  [^Char __r])

JOKER FUNC unicode.IsLower from unicode/letter.go:
(defn ^"Boolean" IsLower
  "IsLower reports whether the rune is a lower case letter.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsLower(__r)"}
  [^Char __r])

JOKER FUNC unicode.IsMark from unicode/graphic.go:
(defn ^"Boolean" IsMark
  "IsMark reports whether the rune is a mark character (category M).\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsMark(__r)"}
  [^Char __r])

JOKER FUNC unicode.IsNumber from unicode/graphic.go:
(defn ^"Boolean" IsNumber
  "IsNumber reports whether the rune is a number (category N).\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsNumber(__r)"}
  [^Char __r])

JOKER FUNC unicode.IsOneOf from unicode/graphic.go:
;; (defn ^"Boolean" IsOneOf
;;   "IsOneOf reports whether the rune is a member of one of the ranges.\nThe function \"In\" provides a nicer signature and should be used in preference to IsOneOf.\n\nGo input arguments: (ranges []*RangeTable, r rune)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of (atom-of go.std.unicode/RangeTable)) ranges, ^Char r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "unicode.IsOneOf(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_unicode.RangeTable(__ranges)), __r)"}
;;   [^Object __ranges, ^Char __r])

JOKER FUNC unicode.IsPrint from unicode/graphic.go:
(defn ^"Boolean" IsPrint
  "IsPrint reports whether the rune is defined as printable by Go. Such\ncharacters include letters, marks, numbers, punctuation, symbols, and the\nASCII space character, from categories L, M, N, P, S and the ASCII space\ncharacter. This categorization is the same as IsGraphic except that the\nonly spacing character is ASCII space, U+0020.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsPrint(__r)"}
  [^Char __r])

JOKER FUNC unicode.IsPunct from unicode/graphic.go:
(defn ^"Boolean" IsPunct
  "IsPunct reports whether the rune is a Unicode punctuation character\n(category P).\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsPunct(__r)"}
  [^Char __r])

JOKER FUNC unicode.IsSpace from unicode/graphic.go:
(defn ^"Boolean" IsSpace
  "IsSpace reports whether the rune is a space character as defined\nby Unicode's White Space property; in the Latin-1 space\nthis is\n\t'\\t', '\\n', '\\v', '\\f', '\\r', ' ', U+0085 (NEL), U+00A0 (NBSP).\nOther definitions of spacing characters are set by category\nZ and property Pattern_White_Space.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsSpace(__r)"}
  [^Char __r])

JOKER FUNC unicode.IsSymbol from unicode/graphic.go:
(defn ^"Boolean" IsSymbol
  "IsSymbol reports whether the rune is a symbolic character.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsSymbol(__r)"}
  [^Char __r])

JOKER FUNC unicode.IsTitle from unicode/letter.go:
(defn ^"Boolean" IsTitle
  "IsTitle reports whether the rune is a title case letter.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsTitle(__r)"}
  [^Char __r])

JOKER FUNC unicode.IsUpper from unicode/letter.go:
(defn ^"Boolean" IsUpper
  "IsUpper reports whether the rune is an upper case letter.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsUpper(__r)"}
  [^Char __r])

JOKER FUNC unicode.SimpleFold from unicode/letter.go:
(defn SimpleFold
  "SimpleFold iterates over Unicode code points equivalent under\nthe Unicode-defined simple case folding. Among the code points\nequivalent to rune (including rune itself), SimpleFold returns the\nsmallest rune > r if one exists, or else the smallest rune >= 0.\nIf r is not a valid Unicode code point, SimpleFold(r) returns r.\n\nFor example:\n\tSimpleFold('A') = 'a'\n\tSimpleFold('a') = 'A'\n\n\tSimpleFold('K') = 'k'\n\tSimpleFold('k') = '\\u212A' (Kelvin symbol, K)\n\tSimpleFold('\\u212A') = 'K'\n\n\tSimpleFold('1') = '1'\n\n\tSimpleFold(-2) = -2\n\nGo input arguments: (r rune)\n\nGo return type: rune\n\nJoker input arguments: [^Char r]\n\nJoker return type: Char"
  {:added "1.0"
   :go "__simpleFold(__r)"}
  [^Char __r])

JOKER FUNC unicode.To from unicode/letter.go:
(defn To
  "To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase.\n\nGo input arguments: (_case int, r rune)\n\nGo return type: rune\n\nJoker input arguments: [^Int _case, ^Char r]\n\nJoker return type: Char"
  {:added "1.0"
   :go "__to(___case, __r)"}
  [^Int ___case, ^Char __r])

JOKER FUNC unicode.ToLower from unicode/letter.go:
(defn ToLower
  "ToLower maps the rune to lower case.\n\nGo input arguments: (r rune)\n\nGo return type: rune\n\nJoker input arguments: [^Char r]\n\nJoker return type: Char"
  {:added "1.0"
   :go "__toLower(__r)"}
  [^Char __r])

JOKER FUNC unicode.ToTitle from unicode/letter.go:
(defn ToTitle
  "ToTitle maps the rune to title case.\n\nGo input arguments: (r rune)\n\nGo return type: rune\n\nJoker input arguments: [^Char r]\n\nJoker return type: Char"
  {:added "1.0"
   :go "__toTitle(__r)"}
  [^Char __r])

JOKER FUNC unicode.ToUpper from unicode/letter.go:
(defn ToUpper
  "ToUpper maps the rune to upper case.\n\nGo input arguments: (r rune)\n\nGo return type: rune\n\nJoker input arguments: [^Char r]\n\nJoker return type: Char"
  {:added "1.0"
   :go "__toUpper(__r)"}
  [^Char __r])

JOKER TYPE go.std.unicode/CaseRange:
(def
  ^{:doc "CaseRange represents a range of Unicode code points for simple (one\ncode point to one code point) case conversion.\nThe range runs from Lo to Hi inclusive, with a fixed stride of 1. Deltas\nare the number to add to the code point to reach the code point for a\ndifferent case for that character. They may be negative. If zero, it\nmeans the character is in the corresponding case. There is a special\ncase representing sequences of alternating corresponding Upper and Lower\npairs. It appears with a fixed Delta of\n\t{UpperLower, UpperLower, UpperLower}\nThe constant UpperLower has an otherwise impossible delta value.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CaseRange"}
  CaseRange)

JOKER TYPE go.std.unicode/Range16:
(def
  ^{:doc "Range16 represents of a range of 16-bit Unicode code points. The range runs from Lo to Hi\ninclusive and has the specified stride.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Range16"}
  Range16)

JOKER TYPE go.std.unicode/Range32:
(def
  ^{:doc "Range32 represents of a range of Unicode code points and is used when one or\nmore of the values will not fit in 16 bits. The range runs from Lo to Hi\ninclusive and has the specified stride. Lo and Hi must always be >= 1<<16.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Range32"}
  Range32)

JOKER TYPE go.std.unicode/RangeTable:
(def
  ^{:doc "RangeTable defines a set of Unicode code points by listing the ranges of\ncode points within the set. The ranges are listed in two slices\nto save space: a slice of 16-bit ranges and a slice of 32-bit ranges.\nThe two slices must be in sorted order and non-overlapping.\nAlso, R32 should contain only values >= 0x10000 (1<<16).\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RangeTable"}
  RangeTable)

JOKER TYPE go.std.unicode/SpecialCase:
(def
  ^{:doc "SpecialCase represents language-specific case mappings such as Turkish.\nMethods of SpecialCase customize (by overriding) the standard mappings.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SpecialCase"}
  SpecialCase)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["unicode"]
    :doc "Provides a low-level interface to the unicode package.\n\nPackage unicode provides data and functions to test some properties of\nUnicode code points.\n"
    :empty false}
  go.std.unicode)
JOKER FUNC unicode/utf16.Decode from unicode/utf16/utf16.go:
;; (defn Decode
;;   "Decode returns the Unicode code point sequence represented\nby the UTF-16 encoding s.\n\nGo input arguments: (s []uint16)\n\nGo return type: []rune\n\nJoker input arguments: [^(vector-of Int) s]\n\nJoker return type: (vector-of Char)"
;;   {:added "1.0"
;;    :go "__decode(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfuint16(__s)))"}
;;   [^Object __s])

JOKER FUNC unicode/utf16.DecodeRune from unicode/utf16/utf16.go:
(defn DecodeRune
  "DecodeRune returns the UTF-16 decoding of a surrogate pair.\nIf the pair is not a valid UTF-16 surrogate pair, DecodeRune returns\nthe Unicode replacement code point U+FFFD.\n\nGo input arguments: (r1 rune, r2 rune)\n\nGo return type: rune\n\nJoker input arguments: [^Char r1, ^Char r2]\n\nJoker return type: Char"
  {:added "1.0"
   :go "__decodeRune(__r1, __r2)"}
  [^Char __r1, ^Char __r2])

JOKER FUNC unicode/utf16.Encode from unicode/utf16/utf16.go:
;; (defn Encode
;;   "Encode returns the UTF-16 encoding of the Unicode code point sequence s.\n\nGo input arguments: (s []rune)\n\nGo return type: []uint16\n\nJoker input arguments: [^(vector-of Char) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__encode(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfrune(__s)))"}
;;   [^Object __s])

JOKER FUNC unicode/utf16.EncodeRune from unicode/utf16/utf16.go:
(defn EncodeRune
  "EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune.\nIf the rune is not a valid Unicode code point or does not need encoding,\nEncodeRune returns U+FFFD, U+FFFD.\n\nGo input arguments: (r rune)\n\nGo return type: (r1 rune, r2 rune)\n\nJoker input arguments: [^Char r]\n\nJoker return type: [Char Char]"
  {:added "1.0"
   :go "__encodeRune(__r)"}
  [^Char __r])

JOKER FUNC unicode/utf16.IsSurrogate from unicode/utf16/utf16.go:
(defn ^"Boolean" IsSurrogate
  "IsSurrogate reports whether the specified Unicode code point\ncan appear in a surrogate pair.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "utf16.IsSurrogate(__r)"}
  [^Char __r])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["unicode/utf16"]
    :doc "Provides a low-level interface to the unicode/utf16 package.\n\nPackage utf16 implements encoding and decoding of UTF-16 sequences.\n"
    :empty false}
  go.std.unicode.utf16)
JOKER CONSTANT MaxRune from unicode/utf8/utf8.go:
(def
  ^{:doc "Maximum valid Unicode code point.\n"
    :added "1.0"
    :tag "Char"
    :go "utf8.MaxRune"}
  MaxRune)

JOKER CONSTANT RuneError from unicode/utf8/utf8.go:
(def
  ^{:doc "the \"error\" Rune or \"Unicode replacement character\"\n"
    :added "1.0"
    :tag "Char"
    :go "utf8.RuneError"}
  RuneError)

JOKER CONSTANT RuneSelf from unicode/utf8/utf8.go:
(def
  ^{:doc "characters below Runeself are represented as themselves in a single byte.\n"
    :added "1.0"
    :tag "Int"
    :go "utf8.RuneSelf"}
  RuneSelf)

JOKER CONSTANT UTFMax from unicode/utf8/utf8.go:
(def
  ^{:doc "maximum number of bytes of a UTF-8 encoded Unicode character.\n"
    :added "1.0"
    :tag "Int"
    :go "utf8.UTFMax"}
  UTFMax)

JOKER FUNC unicode/utf8.DecodeLastRune from unicode/utf8/utf8.go:
;; (defn DecodeLastRune
;;   "DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and\nits width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if\nthe encoding is invalid, it returns (RuneError, 1). Both are impossible\nresults for correct, non-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo input arguments: (p []byte)\n\nGo return type: (r rune, size int)\n\nJoker input arguments: [^(vector-of Int) p]\n\nJoker return type: [Char Int]"
;;   {:added "1.0"
;;    :go "__decodeLastRune(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)))"}
;;   [^Object __p])

JOKER FUNC unicode/utf8.DecodeLastRuneInString from unicode/utf8/utf8.go:
(defn DecodeLastRuneInString
  "DecodeLastRuneInString is like DecodeLastRune but its input is a string. If\ns is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid,\nit returns (RuneError, 1). Both are impossible results for correct,\nnon-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo input arguments: (s string)\n\nGo return type: (r rune, size int)\n\nJoker input arguments: [^String s]\n\nJoker return type: [Char Int]"
  {:added "1.0"
   :go "__decodeLastRuneInString(__s)"}
  [^String __s])

JOKER FUNC unicode/utf8.DecodeRune from unicode/utf8/utf8.go:
;; (defn DecodeRune
;;   "DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and\nits width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if\nthe encoding is invalid, it returns (RuneError, 1). Both are impossible\nresults for correct, non-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo input arguments: (p []byte)\n\nGo return type: (r rune, size int)\n\nJoker input arguments: [^(vector-of Int) p]\n\nJoker return type: [Char Int]"
;;   {:added "1.0"
;;    :go "__decodeRune(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)))"}
;;   [^Object __p])

JOKER FUNC unicode/utf8.DecodeRuneInString from unicode/utf8/utf8.go:
(defn DecodeRuneInString
  "DecodeRuneInString is like DecodeRune but its input is a string. If s is\nempty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it\nreturns (RuneError, 1). Both are impossible results for correct, non-empty\nUTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo input arguments: (s string)\n\nGo return type: (r rune, size int)\n\nJoker input arguments: [^String s]\n\nJoker return type: [Char Int]"
  {:added "1.0"
   :go "__decodeRuneInString(__s)"}
  [^String __s])

JOKER FUNC unicode/utf8.EncodeRune from unicode/utf8/utf8.go:
;; (defn ^"Int" EncodeRune
;;   "EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.\nIt returns the number of bytes written.\n\nGo input arguments: (p []byte, r rune)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) p, ^Char r]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "utf8.EncodeRune(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)), __r)"}
;;   [^Object __p, ^Char __r])

JOKER FUNC unicode/utf8.FullRune from unicode/utf8/utf8.go:
;; (defn ^"Boolean" FullRune
;;   "FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune.\nAn invalid encoding is considered a full Rune since it will convert as a width-1 error rune.\n\nGo input arguments: (p []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) p]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "utf8.FullRune(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)))"}
;;   [^Object __p])

JOKER FUNC unicode/utf8.FullRuneInString from unicode/utf8/utf8.go:
(defn ^"Boolean" FullRuneInString
  "FullRuneInString is like FullRune but its input is a string.\n\nGo input arguments: (s string)\n\nGo return type: bool\n\nJoker input arguments: [^String s]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "utf8.FullRuneInString(__s)"}
  [^String __s])

JOKER FUNC unicode/utf8.RuneCount from unicode/utf8/utf8.go:
;; (defn ^"Int" RuneCount
;;   "RuneCount returns the number of runes in p. Erroneous and short\nencodings are treated as single runes of width 1 byte.\n\nGo input arguments: (p []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) p]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "utf8.RuneCount(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)))"}
;;   [^Object __p])

JOKER FUNC unicode/utf8.RuneCountInString from unicode/utf8/utf8.go:
(defn ^"Int" RuneCountInString
  "RuneCountInString is like RuneCount but its input is a string.\n\nGo input arguments: (s string)\n\nGo return type: int\n\nJoker input arguments: [^String s]\n\nJoker return type: Int"
  {:added "1.0"
   :go "utf8.RuneCountInString(__s)"}
  [^String __s])

JOKER FUNC unicode/utf8.RuneLen from unicode/utf8/utf8.go:
(defn ^"Int" RuneLen
  "RuneLen returns the number of bytes required to encode the rune.\nIt returns -1 if the rune is not a valid value to encode in UTF-8.\n\nGo input arguments: (r rune)\n\nGo return type: int\n\nJoker input arguments: [^Char r]\n\nJoker return type: Int"
  {:added "1.0"
   :go "utf8.RuneLen(__r)"}
  [^Char __r])

JOKER FUNC unicode/utf8.RuneStart from unicode/utf8/utf8.go:
(defn ^"Boolean" RuneStart
  "RuneStart reports whether the byte could be the first byte of an encoded,\npossibly invalid rune. Second and subsequent bytes always have the top two\nbits set to 10.\n\nGo input arguments: (b byte)\n\nGo return type: bool\n\nJoker input arguments: [^Int b]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "utf8.RuneStart(__b)"}
  [^Byte __b])

JOKER FUNC unicode/utf8.Valid from unicode/utf8/utf8.go:
;; (defn ^"Boolean" Valid
;;   "Valid reports whether p consists entirely of valid UTF-8-encoded runes.\n\nGo input arguments: (p []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) p]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "utf8.Valid(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)))"}
;;   [^Object __p])

JOKER FUNC unicode/utf8.ValidRune from unicode/utf8/utf8.go:
(defn ^"Boolean" ValidRune
  "ValidRune reports whether r can be legally encoded as UTF-8.\nCode points that are out of range or a surrogate half are illegal.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "utf8.ValidRune(__r)"}
  [^Char __r])

JOKER FUNC unicode/utf8.ValidString from unicode/utf8/utf8.go:
(defn ^"Boolean" ValidString
  "ValidString reports whether s consists entirely of valid UTF-8-encoded runes.\n\nGo input arguments: (s string)\n\nGo return type: bool\n\nJoker input arguments: [^String s]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "utf8.ValidString(__s)"}
  [^String __s])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["unicode/utf8"]
    :doc "Provides a low-level interface to the unicode/utf8 package.\n\nPackage utf8 implements functions and constants to support text encoded in\nUTF-8. It includes functions to translate between runes and UTF-8 byte sequences.\n"
    :empty false}
  go.std.unicode.utf8)
GO TYPE archive/tar.Format from archive/tar/format.go:
func ExtractGoObjectFormat(args []Object, index int) *_tar.Format {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tar.Format:
			return &r
		case *_tar.Format:
			return r
		}
	case Int:
		v := _tar.Format(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/tar.Format]"))
}

func _ConstructFormat(_v Object) _tar.Format {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tar.Format:
			return _g
		case *_tar.Format:
			return *_g
		}
	case Number:
		return _tar.Format(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tar.Format] or: Number"))
}

func ExtractGo_go_std_archive_tar__Format(rcvr, arg string, args *ArraySeq, n int) (res _tar.Format) {
	a := CheckGoNth(rcvr, "go.std.archive.tar/Format", arg, args, n).O
	res, ok := a.(_tar.Format)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.archive.tar/Format], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE archive/tar.Header from archive/tar/common.go:
func ExtractGoObjectHeader(args []Object, index int) *_tar.Header {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tar.Header:
			return &r
		case *_tar.Header:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/tar.Header]"))
}

// func _mapToHeader(o Map) *_tar.Header {
// 	return &_tar.Header{}
// }

// func _vectorToHeader(o *Vector) *_tar.Header {
// 	return &_tar.Header{
// 		Typeflag: byte(AssertInt(o.Nth(0), "").I),
// 		Name: AssertString(o.Nth(1), "").S,
// 		Linkname: AssertString(o.Nth(2), "").S,
// 		Size: AssertNumber(o.Nth(3), "").BigInt().Int64(),
// 		Mode: AssertNumber(o.Nth(4), "").BigInt().Int64(),
// 		Uid: AssertInt(o.Nth(5), "").I,
// 		Gid: AssertInt(o.Nth(6), "").I,
// 		Uname: AssertString(o.Nth(7), "").S,
// 		Gname: AssertString(o.Nth(8), "").S,
// 		ModTime: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		AccessTime: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ChangeTime: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Devmajor: AssertNumber(o.Nth(12), "").BigInt().Int64(),
// 		Devminor: AssertNumber(o.Nth(13), "").BigInt().Int64(),
// 		Xattrs: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		PAXRecords: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		Format: _tar.Format(AssertInt(o.Nth(16), "").I),
// 	}
// }

// func _ConstructHeader(_v Object) *_tar.Header {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _tar.Header:
// 			return &_g
// 		case *_tar.Header:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToHeader(_o.(Map))
// 	case *Vector:
// 		return _vectorToHeader(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[tar.Header] or: Map or Vector"))
// }

func ExtractGo_go_std_archive_tar__Header(rcvr, arg string, args *ArraySeq, n int) (res _tar.Header) {
	a := CheckGoNth(rcvr, "go.std.archive.tar/Header", arg, args, n).O
	res, ok := a.(_tar.Header)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.archive.tar/Header], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE archive/tar.Reader from archive/tar/reader.go:
func ExtractGoObjectReader(args []Object, index int) *_tar.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tar.Reader:
			return &r
		case *_tar.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/tar.Reader]"))
}

func _mapToReader(o Map) *_tar.Reader {
	return &_tar.Reader{}
}

func _vectorToReader(o *Vector) *_tar.Reader {
	return &_tar.Reader{}
}

func _ConstructReader(_v Object) *_tar.Reader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tar.Reader:
			return &_g
		case *_tar.Reader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReader(_o.(Map))
	case *Vector:
		return _vectorToReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tar.Reader] or: Map or Vector"))
}

func ExtractGo_go_std_archive_tar__Reader(rcvr, arg string, args *ArraySeq, n int) (res _tar.Reader) {
	a := CheckGoNth(rcvr, "go.std.archive.tar/Reader", arg, args, n).O
	res, ok := a.(_tar.Reader)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.archive.tar/Reader], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE archive/tar.Writer from archive/tar/writer.go:
func ExtractGoObjectWriter(args []Object, index int) *_tar.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tar.Writer:
			return &r
		case *_tar.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/tar.Writer]"))
}

func _mapToWriter(o Map) *_tar.Writer {
	return &_tar.Writer{}
}

func _vectorToWriter(o *Vector) *_tar.Writer {
	return &_tar.Writer{}
}

func _ConstructWriter(_v Object) *_tar.Writer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tar.Writer:
			return &_g
		case *_tar.Writer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWriter(_o.(Map))
	case *Vector:
		return _vectorToWriter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tar.Writer] or: Map or Vector"))
}

func ExtractGo_go_std_archive_tar__Writer(rcvr, arg string, args *ArraySeq, n int) (res _tar.Writer) {
	a := CheckGoNth(rcvr, "go.std.archive.tar/Writer", arg, args, n).O
	res, ok := a.(_tar.Writer)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.archive.tar/Writer], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO FUNC archive/tar.FileInfoHeader from archive/tar/common.go:
// func __fileInfoHeader(__fi ABEND987(genutils.go: imports not yet supported: os.FileInfo), __link string) Object {
// 	_res1, _res2 := _tar.FileInfoHeader(__fi, __link)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC archive/tar.NewReader from archive/tar/reader.go:
// func __newReader(__r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _tar.NewReader(__r)
// 	return MakeGoObject(_res)
// }

GO FUNC archive/tar.NewWriter from archive/tar/writer.go:
// func __newWriter(__w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _tar.NewWriter(__w)
// 	return MakeGoObject(_res)
// }

GO FUNC archive/tar.__format_String from archive/tar/format.go:
func __format_String(o GoObject, args Object) Object {
	CheckGoArity("(_archive/tar.Format)String()", args, 0, 0)
	_res := o.O.(_tar.Format).String()
	return MakeString(_res)
}

GO FUNC archive/tar.__ptrTo_Header_FileInfo from archive/tar/common.go:
func __ptrTo_Header_FileInfo(o GoObject, args Object) Object {
	CheckGoArity("(*_archive/tar.Header)FileInfo()", args, 0, 0)
	_res := o.O.(*_tar.Header).FileInfo()
	return MakeGoObject(_res)
}

GO FUNC archive/tar.__ptrTo_Reader_Next from archive/tar/reader.go:
func __ptrTo_Reader_Next(o GoObject, args Object) Object {
	CheckGoArity("(*_archive/tar.Reader)Next()", args, 0, 0)
	_res1, _res2 := o.O.(*_tar.Reader).Next()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC archive/tar.__ptrTo_Reader_Read from archive/tar/reader.go:
// func __ptrTo_Reader_Read(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))}

GO FUNC archive/tar.__ptrTo_Writer_Close from archive/tar/writer.go:
func __ptrTo_Writer_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_archive/tar.Writer)Close()", args, 0, 0)
	_res := o.O.(*_tar.Writer).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC archive/tar.__ptrTo_Writer_Flush from archive/tar/writer.go:
func __ptrTo_Writer_Flush(o GoObject, args Object) Object {
	CheckGoArity("(*_archive/tar.Writer)Flush()", args, 0, 0)
	_res := o.O.(*_tar.Writer).Flush()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC archive/tar.__ptrTo_Writer_Write from archive/tar/writer.go:
// func __ptrTo_Writer_Write(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))}

GO FUNC archive/tar.__ptrTo_Writer_WriteHeader from archive/tar/writer.go:
// func __ptrTo_Writer_WriteHeader(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_archive/tar.Writer)WriteHeader()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for __hdr at: /usr/local/go/src/archive/tar/writer.go:67:35)
// 	_res := o.O.(*_tar.Writer).WriteHeader(__hdr)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

panic: unrecognized expr *ast.StructType

goroutine 1 [running]:
github.com/candid82/joker/tools/gostd/types.(*TypeDefInfo).TypeReflected(0xc00023fcc0, 0xc0079c04b0, 0x42)
	/home/craig/go/src/github.com/candid82/joker/tools/gostd/types/types.go:172 +0x386
main.outputGoCode.func5(0xc00023fcc0)
	/home/craig/go/src/github.com/candid82/joker/tools/gostd/output.go:338 +0x49
github.com/candid82/joker/tools/gostd/types.SortedTypeDefinitions(0xc000256ab0, 0xc0001076a0)
	/home/craig/go/src/github.com/candid82/joker/tools/gostd/types/types.go:120 +0x26a
main.outputGoCode(0xc000014a92, 0xb, 0xc0002569f0, 0xc000256a20, 0xc000256a50, 0xc000256a80, 0xc000256ab0, 0xc000256ae0, 0x0, 0x0, ...)
	/home/craig/go/src/github.com/candid82/joker/tools/gostd/output.go:336 +0x3b4
main.outputPackageCode.func2(0xc000014a92, 0xb, 0xc0002569f0, 0xc000256a20, 0xc000256a50, 0xc000256a80, 0xc000256ab0, 0xc000256ae0)
	/home/craig/go/src/github.com/candid82/joker/tools/gostd/output.go:363 +0x7b
github.com/candid82/joker/tools/gostd/gowalk.SortedPackageMap(0xc0000a26f0, 0xc000107950)
	/home/craig/go/src/github.com/candid82/joker/tools/gostd/gowalk/gowalk.go:143 +0x275
main.outputPackageCode(0x0, 0x0, 0x1)
	/home/craig/go/src/github.com/candid82/joker/tools/gostd/output.go:361 +0xe9
main.main()
	/home/craig/go/src/github.com/candid82/joker/tools/gostd/main.go:297 +0x1e57
