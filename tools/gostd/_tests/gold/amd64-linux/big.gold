Walking from _tests/big/src to _tests/big/src/go
Processing go:
Walking from _tests/big/src to _tests/big/src/net
Processing net:
Matchfile(_tests/big/src/net/conf_netcgo.go) => false <nil>
Ignoring test code in main_cloexec_test.go
Ignoring test code in example_test.go
Matchfile(_tests/big/src/net/sockopt_bsd.go) => false <nil>
Matchfile(_tests/big/src/net/sock_bsd.go) => false <nil>
Matchfile(_tests/big/src/net/error_windows.go) => false <nil>
Ignoring test code in unixsock_test.go
Matchfile(_tests/big/src/net/interface_darwin.go) => false <nil>
Matchfile(_tests/big/src/net/sendfile_windows.go) => false <nil>
Matchfile(_tests/big/src/net/iprawsock.go) => true <nil>
Matchfile(_tests/big/src/net/tcpsockopt_darwin.go) => false <nil>
Ignoring test code in main_test.go
Matchfile(_tests/big/src/net/tcpsockopt_dragonfly.go) => false <nil>
Matchfile(_tests/big/src/net/file_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/sock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/net.go) => true <nil>
Matchfile(_tests/big/src/net/sendfile_linux.go) => true <nil>
Ignoring test code in udpsock_plan9_test.go
Matchfile(_tests/big/src/net/cgo_resnew.go) => true <nil>
Matchfile(_tests/big/src/net/splice_stub.go) => false <nil>
Ignoring test code in error_plan9_test.go
Ignoring test code in iprawsock_test.go
Matchfile(_tests/big/src/net/sockaddr_posix.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_openbsd.go) => false <nil>
Matchfile(_tests/big/src/net/dnsclient_unix.go) => true <nil>
Matchfile(_tests/big/src/net/sock_cloexec.go) => true <nil>
Ignoring test code in timeout_test.go
Ignoring test code in lookup_windows_test.go
Ignoring test code in udpsock_test.go
Ignoring test code in rawconn_unix_test.go
Matchfile(_tests/big/src/net/sockopt_linux.go) => true <nil>
Matchfile(_tests/big/src/net/sock_linux.go) => true <nil>
Ignoring test code in hosts_test.go
Matchfile(_tests/big/src/net/lookup_fake.go) => false <nil>
Matchfile(_tests/big/src/net/lookup_windows.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_openbsd.go) => false <nil>
Matchfile(_tests/big/src/net/unixsock.go) => true <nil>
Matchfile(_tests/big/src/net/sockopt_posix.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_bsd.go) => false <nil>
Matchfile(_tests/big/src/net/sockopt_solaris.go) => false <nil>
Matchfile(_tests/big/src/net/interface_stub.go) => false <nil>
Matchfile(_tests/big/src/net/hook.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_linux.go) => true <nil>
Matchfile(_tests/big/src/net/addrselect.go) => true <nil>
Matchfile(_tests/big/src/net/mac.go) => true <nil>
Ignoring test code in dnsclient_unix_test.go
Matchfile(_tests/big/src/net/iprawsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_unix.go) => true <nil>
Ignoring test code in dnsname_test.go
Ignoring test code in conf_test.go
Matchfile(_tests/big/src/net/sockopt_plan9.go) => false <nil>
Ignoring test code in interface_test.go
Ignoring test code in sendfile_test.go
Matchfile(_tests/big/src/net/sockoptip_windows.go) => false <nil>
Matchfile(_tests/big/src/net/error_unix.go) => true <nil>
Matchfile(_tests/big/src/net/fd_windows.go) => false <nil>
Matchfile(_tests/big/src/net/error_nacl.go) => false <nil>
Ignoring test code in dnsclient_test.go
Matchfile(_tests/big/src/net/tcpsockopt_solaris.go) => false <nil>
Ignoring test code in net_windows_test.go
Matchfile(_tests/big/src/net/sockoptip_linux.go) => true <nil>
Matchfile(_tests/big/src/net/lookup_unix.go) => true <nil>
Matchfile(_tests/big/src/net/interface_solaris.go) => false <nil>
Matchfile(_tests/big/src/net/net_fake.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/parse.go) => true <nil>
Ignoring test code in parse_test.go
Ignoring test code in lookup_test.go
Ignoring test code in main_windows_test.go
Matchfile(_tests/big/src/net/interface_bsdvar.go) => false <nil>
Matchfile(_tests/big/src/net/interface.go) => true <nil>
Ignoring test code in ipsock_test.go
Matchfile(_tests/big/src/net/tcpsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/file.go) => true <nil>
Ignoring test code in net_test.go
Ignoring test code in server_test.go
Matchfile(_tests/big/src/net/cgo_solaris.go) => false <nil>
Ignoring test code in splice_test.go
Ignoring test code in error_unix_test.go
Ignoring test code in platform_test.go
Ignoring test code in dnsconfig_unix_test.go
Matchfile(_tests/big/src/net/cgo_android.go) => false <nil>
Matchfile(_tests/big/src/net/sockoptip_bsdvar.go) => false <nil>
Ignoring test code in rawconn_windows_test.go
Matchfile(_tests/big/src/net/unixsock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/lookup_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/sockopt_stub.go) => false <nil>
Matchfile(_tests/big/src/net/rawconn.go) => true <nil>
Matchfile(_tests/big/src/net/sock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/sockoptip_posix.go) => true <nil>
Ignoring test code in write_unix_test.go
Matchfile(_tests/big/src/net/splice_linux.go) => true <nil>
Ignoring test code in unixsock_linux_test.go
Ignoring test code in error_posix_test.go
Ignoring test code in listen_test.go
Matchfile(_tests/big/src/net/dnsclient.go) => true <nil>
Matchfile(_tests/big/src/net/fd_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/sendfile_stub.go) => false <nil>
Ignoring test code in dial_test.go
Ignoring test code in interface_linux_test.go
Ignoring test code in tcpsock_test.go
Matchfile(_tests/big/src/net/hook_windows.go) => false <nil>
Ignoring test code in ip_test.go
Matchfile(_tests/big/src/net/file_stub.go) => false <nil>
Matchfile(_tests/big/src/net/fd_unix.go) => true <nil>
Matchfile(_tests/big/src/net/ipsock.go) => true <nil>
Ignoring test code in netgo_unix_test.go
Ignoring test code in addrselect_test.go
Matchfile(_tests/big/src/net/lookup.go) => true <nil>
Matchfile(_tests/big/src/net/tcpsock.go) => true <nil>
Matchfile(_tests/big/src/net/pipe.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_resold.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_stub.go) => false <nil>
Matchfile(_tests/big/src/net/dial.go) => true <nil>
Matchfile(_tests/big/src/net/interface_bsd.go) => false <nil>
Ignoring test code in main_unix_test.go
Matchfile(_tests/big/src/net/hosts.go) => true <nil>
Ignoring test code in file_test.go
Matchfile(_tests/big/src/net/dnsconfig_unix.go) => true <nil>
Matchfile(_tests/big/src/net/interface_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/interface_windows.go) => false <nil>
Ignoring test code in packetconn_test.go
Matchfile(_tests/big/src/net/writev_unix.go) => true <nil>
Matchfile(_tests/big/src/net/interface_freebsd.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_windows.go) => false <nil>
Ignoring test code in protoconn_test.go
Ignoring test code in nss_test.go
Ignoring test code in rawconn_test.go
Matchfile(_tests/big/src/net/sys_cloexec.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_posix.go) => true <nil>
Matchfile(_tests/big/src/net/ip.go) => true <nil>
Matchfile(_tests/big/src/net/sendfile_unix_alt.go) => false <nil>
Ignoring test code in dial_unix_test.go
Ignoring test code in main_conf_test.go
Matchfile(_tests/big/src/net/interface_linux.go) => true <nil>
Matchfile(_tests/big/src/net/error_posix.go) => true <nil>
Matchfile(_tests/big/src/net/hook_plan9.go) => false <nil>
Ignoring test code in main_posix_test.go
Matchfile(_tests/big/src/net/cgo_sockold.go) => false <nil>
Ignoring test code in cgo_unix_test.go
Matchfile(_tests/big/src/net/file_unix.go) => true <nil>
Ignoring test code in mac_test.go
Matchfile(_tests/big/src/net/udpsock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/file_windows.go) => false <nil>
Matchfile(_tests/big/src/net/udpsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_windows.go) => false <nil>
Matchfile(_tests/big/src/net/sock_windows.go) => false <nil>
Ignoring test code in pipe_test.go
Ignoring test code in main_plan9_test.go
Matchfile(_tests/big/src/net/udpsock.go) => true <nil>
Matchfile(_tests/big/src/net/nss.go) => true <nil>
Matchfile(_tests/big/src/net/conf.go) => true <nil>
Matchfile(_tests/big/src/net/iprawsock_posix.go) => true <nil>
Ignoring test code in interface_unix_test.go
Matchfile(_tests/big/src/net/sockopt_windows.go) => false <nil>
Matchfile(_tests/big/src/net/ipsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_socknew.go) => true <nil>
Matchfile(_tests/big/src/net/port_unix.go) => true <nil>
Matchfile(_tests/big/src/net/sock_stub.go) => false <nil>
Ignoring test code in error_test.go
Matchfile(_tests/big/src/net/port.go) => true <nil>
Ignoring test code in rawconn_stub_test.go
Ignoring test code in mockserver_test.go
Matchfile(_tests/big/src/net/unixsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_netbsd.go) => false <nil>
Ignoring test code in port_test.go
Ignoring test code in conn_test.go
Ignoring test code in external_test.go
Matchfile(_tests/big/src/net/cgo_stub.go) => false <nil>
Ignoring test code in error_windows_test.go
Matchfile(_tests/big/src/net/ipsock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/hook_unix.go) => true <nil>
Ignoring test code in tcpsock_unix_test.go
Matchfile(_tests/big/src/net/sockoptip_stub.go) => false <nil>
Ignoring test code in main_noconf_test.go
Matchfile(_tests/big/src/net/tcpsockopt_unix.go) => true <nil>
Matchfile(_tests/big/src/net/error_plan9.go) => false <nil>
Ignoring test code in writev_test.go
Ignoring test code in interface_bsd_test.go
Processing package=net:
Walking from _tests/big/src to _tests/big/src/net/http
Processing net/http:
Matchfile(_tests/big/src/net/http/header.go) => true <nil>
Ignoring test code in response_test.go
Ignoring test code in transport_internal_test.go
Ignoring test code in example_test.go
Matchfile(_tests/big/src/net/http/request.go) => true <nil>
Ignoring test code in main_test.go
Ignoring test code in request_test.go
Ignoring test code in cookie_test.go
Ignoring test code in header_test.go
Matchfile(_tests/big/src/net/http/roundtrip.go) => true <nil>
Ignoring test code in responsewrite_test.go
Ignoring test code in export_test.go
Ignoring test code in fs_test.go
Matchfile(_tests/big/src/net/http/client.go) => true <nil>
Matchfile(_tests/big/src/net/http/transport.go) => true <nil>
Matchfile(_tests/big/src/net/http/fs.go) => true <nil>
Matchfile(_tests/big/src/net/http/triv.go) => false <nil>
Ignoring test code in requestwrite_test.go
Matchfile(_tests/big/src/net/http/method.go) => true <nil>
Ignoring test code in sniff_test.go
Ignoring test code in npn_test.go
Matchfile(_tests/big/src/net/http/cookie.go) => true <nil>
Ignoring test code in transport_test.go
Matchfile(_tests/big/src/net/http/filetransport.go) => true <nil>
Matchfile(_tests/big/src/net/http/race.go) => false <nil>
Ignoring test code in filetransport_test.go
Ignoring test code in range_test.go
Matchfile(_tests/big/src/net/http/status.go) => true <nil>
Matchfile(_tests/big/src/net/http/socks_bundle.go) => true <nil>
Ignoring test code in client_test.go
Matchfile(_tests/big/src/net/http/jar.go) => true <nil>
Matchfile(_tests/big/src/net/http/sniff.go) => true <nil>
Ignoring test code in transfer_test.go
Matchfile(_tests/big/src/net/http/doc.go) => true <nil>
Matchfile(_tests/big/src/net/http/h2_bundle.go) => true <nil>
Ignoring test code in http_test.go
Matchfile(_tests/big/src/net/http/http.go) => true <nil>
Matchfile(_tests/big/src/net/http/transfer.go) => true <nil>
Ignoring test code in clientserver_test.go
Ignoring test code in readrequest_test.go
Ignoring test code in serve_test.go
Matchfile(_tests/big/src/net/http/roundtrip_js.go) => false <nil>
Ignoring test code in proxy_test.go
Matchfile(_tests/big/src/net/http/server.go) => true <nil>
Matchfile(_tests/big/src/net/http/response.go) => true <nil>
Processing package=net/http:
Walking from _tests/big/src to _tests/big/src/net/http/cgi
Processing net/http/cgi:
Ignoring test code in child_test.go
Ignoring test code in host_test.go
Ignoring test code in matryoshka_test.go
Ignoring test code in posix_test.go
Ignoring test code in plan9_test.go
Matchfile(_tests/big/src/net/http/cgi/host.go) => true <nil>
Matchfile(_tests/big/src/net/http/cgi/child.go) => true <nil>
Processing package=net/http/cgi:
Excluding _tests/big/src/net/http/cgi/testdata
Walking from _tests/big/src to _tests/big/src/net/http/cookiejar
Processing net/http/cookiejar:
Ignoring test code in example_test.go
Matchfile(_tests/big/src/net/http/cookiejar/punycode.go) => true <nil>
Ignoring test code in punycode_test.go
Ignoring test code in jar_test.go
Ignoring test code in dummy_publicsuffix_test.go
Matchfile(_tests/big/src/net/http/cookiejar/jar.go) => true <nil>
Processing package=net/http/cookiejar:
Walking from _tests/big/src to _tests/big/src/net/http/fcgi
Processing net/http/fcgi:
Matchfile(_tests/big/src/net/http/fcgi/fcgi.go) => true <nil>
Ignoring test code in fcgi_test.go
Matchfile(_tests/big/src/net/http/fcgi/child.go) => true <nil>
Processing package=net/http/fcgi:
Walking from _tests/big/src to _tests/big/src/net/http/httptest
Processing net/http/httptest:
Matchfile(_tests/big/src/net/http/httptest/recorder.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in server_test.go
Matchfile(_tests/big/src/net/http/httptest/httptest.go) => true <nil>
Ignoring test code in httptest_test.go
Ignoring test code in recorder_test.go
Matchfile(_tests/big/src/net/http/httptest/server.go) => true <nil>
Processing package=net/http/httptest:
Walking from _tests/big/src to _tests/big/src/net/http/httptrace
Processing net/http/httptrace:
Ignoring test code in example_test.go
Matchfile(_tests/big/src/net/http/httptrace/trace.go) => true <nil>
Ignoring test code in trace_test.go
Processing package=net/http/httptrace:
Walking from _tests/big/src to _tests/big/src/net/http/httputil
Processing net/http/httputil:
Ignoring test code in example_test.go
Matchfile(_tests/big/src/net/http/httputil/httputil.go) => true <nil>
Matchfile(_tests/big/src/net/http/httputil/dump.go) => true <nil>
Ignoring test code in dump_test.go
Matchfile(_tests/big/src/net/http/httputil/reverseproxy.go) => true <nil>
Ignoring test code in reverseproxy_test.go
Matchfile(_tests/big/src/net/http/httputil/persist.go) => true <nil>
Processing package=net/http/httputil:
Excluding _tests/big/src/net/http/internal
Walking from _tests/big/src to _tests/big/src/net/http/pprof
Processing net/http/pprof:
Ignoring test code in pprof_test.go
Matchfile(_tests/big/src/net/http/pprof/pprof.go) => true <nil>
Processing package=net/http/pprof:
Excluding _tests/big/src/net/http/testdata
Excluding _tests/big/src/net/internal
Walking from _tests/big/src to _tests/big/src/net/mail
Processing net/mail:
Ignoring test code in example_test.go
Ignoring test code in message_test.go
Matchfile(_tests/big/src/net/mail/message.go) => true <nil>
Processing package=net/mail:
Walking from _tests/big/src to _tests/big/src/net/rpc
Processing net/rpc:
Matchfile(_tests/big/src/net/rpc/debug.go) => true <nil>
Matchfile(_tests/big/src/net/rpc/client.go) => true <nil>
Ignoring test code in server_test.go
Ignoring test code in client_test.go
Matchfile(_tests/big/src/net/rpc/server.go) => true <nil>
Processing package=net/rpc:
Walking from _tests/big/src to _tests/big/src/net/rpc/jsonrpc
Processing net/rpc/jsonrpc:
Matchfile(_tests/big/src/net/rpc/jsonrpc/client.go) => true <nil>
Ignoring test code in all_test.go
Matchfile(_tests/big/src/net/rpc/jsonrpc/server.go) => true <nil>
Processing package=net/rpc/jsonrpc:
Walking from _tests/big/src to _tests/big/src/net/smtp
Processing net/smtp:
Ignoring test code in example_test.go
Ignoring test code in smtp_test.go
Matchfile(_tests/big/src/net/smtp/auth.go) => true <nil>
Matchfile(_tests/big/src/net/smtp/smtp.go) => true <nil>
Processing package=net/smtp:
Excluding _tests/big/src/net/testdata
Walking from _tests/big/src to _tests/big/src/net/textproto
Processing net/textproto:
Matchfile(_tests/big/src/net/textproto/header.go) => true <nil>
Ignoring test code in writer_test.go
Matchfile(_tests/big/src/net/textproto/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(_tests/big/src/net/textproto/pipeline.go) => true <nil>
Matchfile(_tests/big/src/net/textproto/writer.go) => true <nil>
Matchfile(_tests/big/src/net/textproto/textproto.go) => true <nil>
Processing package=net/textproto:
Walking from _tests/big/src to _tests/big/src/net/url
Processing net/url:
Ignoring test code in example_test.go
Ignoring test code in url_test.go
Matchfile(_tests/big/src/net/url/url.go) => true <nil>
Processing package=net/url:
TYPE net.Addr:
  _tests/big/src/net/net.go
TYPE net.AddrError:
  _tests/big/src/net/net.go
TYPE net.Buffers:
  _tests/big/src/net/net.go
TYPE net.Conn:
  _tests/big/src/net/net.go
TYPE net.DNSConfigError:
  _tests/big/src/net/net.go
TYPE net.DNSError:
  _tests/big/src/net/net.go
TYPE net.Dialer:
  _tests/big/src/net/dial.go
TYPE net.Error:
  _tests/big/src/net/net.go
TYPE net.Flags:
  _tests/big/src/net/interface.go
TYPE net.HardwareAddr:
  _tests/big/src/net/mac.go
TYPE net.IP:
  _tests/big/src/net/ip.go
TYPE net.IPAddr:
  _tests/big/src/net/iprawsock.go
TYPE net.IPConn:
  _tests/big/src/net/iprawsock.go
TYPE net.IPMask:
  _tests/big/src/net/ip.go
TYPE net.IPNet:
  _tests/big/src/net/ip.go
TYPE net.Interface:
  _tests/big/src/net/interface.go
TYPE net.InvalidAddrError:
  _tests/big/src/net/net.go
TYPE net.ListenConfig:
  _tests/big/src/net/dial.go
TYPE net.Listener:
  _tests/big/src/net/net.go
TYPE net.MX:
  _tests/big/src/net/dnsclient.go
TYPE net.NS:
  _tests/big/src/net/dnsclient.go
TYPE net.OpError:
  _tests/big/src/net/net.go
TYPE net.PacketConn:
  _tests/big/src/net/net.go
TYPE net.ParseError:
  _tests/big/src/net/net.go
TYPE net.Resolver:
  _tests/big/src/net/lookup.go
TYPE net.SRV:
  _tests/big/src/net/dnsclient.go
TYPE net.TCPAddr:
  _tests/big/src/net/tcpsock.go
TYPE net.TCPConn:
  _tests/big/src/net/tcpsock.go
TYPE net.TCPListener:
  _tests/big/src/net/tcpsock.go
TYPE net.UDPAddr:
  _tests/big/src/net/udpsock.go
TYPE net.UDPConn:
  _tests/big/src/net/udpsock.go
TYPE net.UnixAddr:
  _tests/big/src/net/unixsock.go
TYPE net.UnixConn:
  _tests/big/src/net/unixsock.go
TYPE net.UnixListener:
  _tests/big/src/net/unixsock.go
TYPE net.UnknownNetworkError:
  _tests/big/src/net/net.go
TYPE net/http.Client:
  _tests/big/src/net/http/client.go
TYPE net/http.CloseNotifier:
  _tests/big/src/net/http/server.go
TYPE net/http.ConnState:
  _tests/big/src/net/http/server.go
TYPE net/http.Cookie:
  _tests/big/src/net/http/cookie.go
TYPE net/http.CookieJar:
  _tests/big/src/net/http/jar.go
TYPE net/http.Dir:
  _tests/big/src/net/http/fs.go
TYPE net/http.File:
  _tests/big/src/net/http/fs.go
TYPE net/http.FileSystem:
  _tests/big/src/net/http/fs.go
TYPE net/http.Flusher:
  _tests/big/src/net/http/server.go
TYPE net/http.Handler:
  _tests/big/src/net/http/server.go
TYPE net/http.HandlerFunc:
  _tests/big/src/net/http/server.go
TYPE net/http.Header:
  _tests/big/src/net/http/header.go
TYPE net/http.Hijacker:
  _tests/big/src/net/http/server.go
TYPE net/http.ProtocolError:
  _tests/big/src/net/http/request.go
TYPE net/http.PushOptions:
  _tests/big/src/net/http/http.go
TYPE net/http.Pusher:
  _tests/big/src/net/http/http.go
TYPE net/http.Request:
  _tests/big/src/net/http/request.go
TYPE net/http.Response:
  _tests/big/src/net/http/response.go
TYPE net/http.ResponseWriter:
  _tests/big/src/net/http/server.go
TYPE net/http.RoundTripper:
  _tests/big/src/net/http/client.go
TYPE net/http.SameSite:
  _tests/big/src/net/http/cookie.go
TYPE net/http.ServeMux:
  _tests/big/src/net/http/server.go
TYPE net/http.Server:
  _tests/big/src/net/http/server.go
TYPE net/http.Transport:
  _tests/big/src/net/http/transport.go
TYPE net/http/cgi.Handler:
  _tests/big/src/net/http/cgi/host.go
TYPE net/http/cookiejar.Jar:
  _tests/big/src/net/http/cookiejar/jar.go
TYPE net/http/cookiejar.Options:
  _tests/big/src/net/http/cookiejar/jar.go
TYPE net/http/cookiejar.PublicSuffixList:
  _tests/big/src/net/http/cookiejar/jar.go
TYPE net/http/httptest.ResponseRecorder:
  _tests/big/src/net/http/httptest/recorder.go
TYPE net/http/httptest.Server:
  _tests/big/src/net/http/httptest/server.go
TYPE net/http/httptrace.ClientTrace:
  _tests/big/src/net/http/httptrace/trace.go
TYPE net/http/httptrace.DNSDoneInfo:
  _tests/big/src/net/http/httptrace/trace.go
TYPE net/http/httptrace.DNSStartInfo:
  _tests/big/src/net/http/httptrace/trace.go
TYPE net/http/httptrace.GotConnInfo:
  _tests/big/src/net/http/httptrace/trace.go
TYPE net/http/httptrace.WroteRequestInfo:
  _tests/big/src/net/http/httptrace/trace.go
TYPE net/http/httputil.BufferPool:
  _tests/big/src/net/http/httputil/reverseproxy.go
TYPE net/http/httputil.ClientConn:
  _tests/big/src/net/http/httputil/persist.go
TYPE net/http/httputil.ReverseProxy:
  _tests/big/src/net/http/httputil/reverseproxy.go
TYPE net/http/httputil.ServerConn:
  _tests/big/src/net/http/httputil/persist.go
TYPE net/mail.Address:
  _tests/big/src/net/mail/message.go
TYPE net/mail.AddressParser:
  _tests/big/src/net/mail/message.go
TYPE net/mail.Header:
  _tests/big/src/net/mail/message.go
TYPE net/mail.Message:
  _tests/big/src/net/mail/message.go
TYPE net/rpc.Call:
  _tests/big/src/net/rpc/client.go
TYPE net/rpc.Client:
  _tests/big/src/net/rpc/client.go
TYPE net/rpc.ClientCodec:
  _tests/big/src/net/rpc/client.go
TYPE net/rpc.Request:
  _tests/big/src/net/rpc/server.go
TYPE net/rpc.Response:
  _tests/big/src/net/rpc/server.go
TYPE net/rpc.Server:
  _tests/big/src/net/rpc/server.go
TYPE net/rpc.ServerCodec:
  _tests/big/src/net/rpc/server.go
TYPE net/rpc.ServerError:
  _tests/big/src/net/rpc/client.go
TYPE net/smtp.Auth:
  _tests/big/src/net/smtp/auth.go
TYPE net/smtp.Client:
  _tests/big/src/net/smtp/smtp.go
TYPE net/smtp.ServerInfo:
  _tests/big/src/net/smtp/auth.go
TYPE net/textproto.Conn:
  _tests/big/src/net/textproto/textproto.go
TYPE net/textproto.Error:
  _tests/big/src/net/textproto/textproto.go
TYPE net/textproto.MIMEHeader:
  _tests/big/src/net/textproto/header.go
TYPE net/textproto.Pipeline:
  _tests/big/src/net/textproto/pipeline.go
TYPE net/textproto.ProtocolError:
  _tests/big/src/net/textproto/textproto.go
TYPE net/textproto.Reader:
  _tests/big/src/net/textproto/reader.go
TYPE net/textproto.Writer:
  _tests/big/src/net/textproto/writer.go
TYPE net/url.Error:
  _tests/big/src/net/url/url.go
TYPE net/url.EscapeError:
  _tests/big/src/net/url/url.go
TYPE net/url.InvalidHostError:
  _tests/big/src/net/url/url.go
TYPE net/url.URL:
  _tests/big/src/net/url/url.go
TYPE net/url.Userinfo:
  _tests/big/src/net/url/url.go
TYPE net/url.Values:
  _tests/big/src/net/url/url.go
JOKER FUNC net.CIDRMask:
(defn CIDRMask
  "CIDRMask returns an IPMask consisting of `ones' 1 bits\nfollowed by 0s up to a total length of `bits' bits.\nFor a mask of this form, CIDRMask is the inverse of IPMask.Size.\n\nGo input arguments: (ones int, bits int)\n\nGo return type: IPMask\n\nJoker input arguments: [^Int ones, ^Int bits]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "cIDRMask(_ones, _bits)"}
  [^Int _ones, ^Int _bits])

JOKER FUNC net.Dial:
;; (defn Dial
;;   "Dial connects to the address on the named network.\n\nKnown networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only),\n\"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\"\n(IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and\n\"unixpacket\".\n\nFor TCP and UDP networks, the address has the form \"host:port\".\nThe host must be a literal IP address, or a host name that can be\nresolved to IP addresses.\nThe port must be a literal port number or a service name.\nIf the host is a literal IPv6 address it must be enclosed in square\nbrackets, as in \"[2001:db8::1]:80\" or \"[fe80::1%zone]:80\".\nThe zone specifies the scope of the literal IPv6 address as defined\nin RFC 4007.\nThe functions JoinHostPort and SplitHostPort manipulate a pair of\nhost and port in this form.\nWhen using TCP, and the host resolves to multiple IP addresses,\nDial will try each IP address in order until one succeeds.\n\nExamples:\n\tDial(\"tcp\", \"golang.org:http\")\n\tDial(\"tcp\", \"192.0.2.1:http\")\n\tDial(\"tcp\", \"198.51.100.1:80\")\n\tDial(\"udp\", \"[2001:db8::1]:domain\")\n\tDial(\"udp\", \"[fe80::1%lo0]:53\")\n\tDial(\"tcp\", \":80\")\n\nFor IP networks, the network must be \"ip\", \"ip4\" or \"ip6\" followed\nby a colon and a literal protocol number or a protocol name, and\nthe address has the form \"host\". The host must be a literal IP\naddress or a literal IPv6 address with zone.\nIt depends on each operating system how the operating system\nbehaves with a non-well known protocol number such as \"0\" or \"255\".\n\nExamples:\n\tDial(\"ip4:1\", \"192.0.2.1\")\n\tDial(\"ip6:ipv6-icmp\", \"2001:db8::1\")\n\tDial(\"ip6:58\", \"fe80::1%lo0\")\n\nFor TCP, UDP and IP networks, if the host is empty or a literal\nunspecified IP address, as in \":80\", \"0.0.0.0:80\" or \"[::]:80\" for\nTCP and UDP, \"\", \"0.0.0.0\" or \"::\" for IP, the local system is\nassumed.\n\nFor Unix networks, the address must be a file system path.\n\nGo input arguments: (network string, address string)\n\nGo return type: (Conn, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/net.go:113:11) Error]"
;;   {:added "1.0"
;;    :go "dial(_network, _address)"}
;;   [^String _network, ^String _address])

JOKER FUNC net.DialIP:
;; (defn DialIP
;;   "DialIP acts like Dial for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *ABEND884(unrecognized type IPAddr at: _tests/big/src/net/iprawsock.go:211:43), raddr *ABEND884(unrecognized type IPAddr at: _tests/big/src/net/iprawsock.go:211:43))\n\nGo return type: (*IPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of IPAddr) laddr, ^(atom-of IPAddr) raddr]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialIP(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfIPAddr(_laddr)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfIPAddr(_raddr)))"}
;;   [^String _network, ^Object _laddr, ^Object _raddr])

JOKER FUNC net.DialTCP:
;; (defn DialTCP
;;   "DialTCP acts like Dial for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *ABEND884(unrecognized type TCPAddr at: _tests/big/src/net/tcpsock.go:206:44), raddr *ABEND884(unrecognized type TCPAddr at: _tests/big/src/net/tcpsock.go:206:44))\n\nGo return type: (*TCPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of TCPAddr) laddr, ^(atom-of TCPAddr) raddr]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialTCP(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfTCPAddr(_laddr)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfTCPAddr(_raddr)))"}
;;   [^String _network, ^Object _laddr, ^Object _raddr])

JOKER FUNC net.DialTimeout:
;; (defn DialTimeout
;;   "DialTimeout acts like Dial but takes a timeout.\n\nThe timeout includes name resolution, if required.\nWhen using TCP, and the host in the address parameter resolves to\nmultiple IP addresses, the timeout is spread over each consecutive\ndial, such that each is given an appropriate fraction of the time\nto connect.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string, timeout *ABEND884(unrecognized type Duration at: _tests/big/src/net/dial.go:313:56))\n\nGo return type: (Conn, error)\n\nJoker input arguments: [^String network, ^String address, ^Duration timeout]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/net.go:113:11) Error]"
;;   {:added "1.0"
;;    :go "dialTimeout(_network, _address, ABEND904(custom-runtime routine not implemented: time.Duration(_timeout)))"}
;;   [^String _network, ^String _address, ^Duration _timeout])

JOKER FUNC net.DialUDP:
;; (defn DialUDP
;;   "DialUDP acts like Dial for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *ABEND884(unrecognized type UDPAddr at: _tests/big/src/net/udpsock.go:205:44), raddr *ABEND884(unrecognized type UDPAddr at: _tests/big/src/net/udpsock.go:205:44))\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of UDPAddr) laddr, ^(atom-of UDPAddr) raddr]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialUDP(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfUDPAddr(_laddr)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfUDPAddr(_raddr)))"}
;;   [^String _network, ^Object _laddr, ^Object _raddr])

JOKER FUNC net.DialUnix:
;; (defn DialUnix
;;   "DialUnix acts like Dial for Unix networks.\n\nThe network must be a Unix network name; see func Dial for details.\n\nIf laddr is non-nil, it is used as the local address for the\nconnection.\n\nGo input arguments: (network string, laddr *ABEND884(unrecognized type UnixAddr at: _tests/big/src/net/unixsock.go:200:45), raddr *ABEND884(unrecognized type UnixAddr at: _tests/big/src/net/unixsock.go:200:45))\n\nGo return type: (*UnixConn, error)\n\nJoker input arguments: [^String network, ^(atom-of UnixAddr) laddr, ^(atom-of UnixAddr) raddr]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialUnix(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfUnixAddr(_laddr)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfUnixAddr(_raddr)))"}
;;   [^String _network, ^Object _laddr, ^Object _raddr])

JOKER FUNC net.FileConn:
;; (defn FileConn
;;   "FileConn returns a copy of the network connection corresponding to\nthe open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo input arguments: (f **ABEND884(unrecognized type File at: _tests/big/src/net/file.go:21:21))\n\nGo return type: (c Conn, err error)\n\nJoker input arguments: [^(atom-of File) f]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/net.go:113:11) Error]"
;;   {:added "1.0"
;;    :go "fileConn(ConvertToIndirectOfFile(ABEND904(custom-runtime routine not implemented: os.File(_f))))"}
;;   [^Object _f])

JOKER FUNC net.FileListener:
;; (defn FileListener
;;   "FileListener returns a copy of the network listener corresponding\nto the open file f.\nIt is the caller's responsibility to close ln when finished.\nClosing ln does not affect f, and closing f does not affect ln.\n\nGo input arguments: (f **ABEND884(unrecognized type File at: _tests/big/src/net/file.go:33:25))\n\nGo return type: (ln Listener, err error)\n\nJoker input arguments: [^(atom-of File) f]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/net.go:365:15) Error]"
;;   {:added "1.0"
;;    :go "fileListener(ConvertToIndirectOfFile(ABEND904(custom-runtime routine not implemented: os.File(_f))))"}
;;   [^Object _f])

JOKER FUNC net.FilePacketConn:
;; (defn FilePacketConn
;;   "FilePacketConn returns a copy of the packet network connection\ncorresponding to the open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo input arguments: (f **ABEND884(unrecognized type File at: _tests/big/src/net/file.go:45:27))\n\nGo return type: (c PacketConn, err error)\n\nJoker input arguments: [^(atom-of File) f]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/net.go:303:17) Error]"
;;   {:added "1.0"
;;    :go "filePacketConn(ConvertToIndirectOfFile(ABEND904(custom-runtime routine not implemented: os.File(_f))))"}
;;   [^Object _f])

JOKER FUNC net.IPv4:
(defn IPv4
  "IPv4 returns the IP address (in 16-byte form) of the\nIPv4 address a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo return type: IP\n\nJoker input arguments: [^Byte a, ^Byte b, ^Byte c, ^Byte d]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "iPv4(_a, _b, _c, _d)"}
  [^Byte _a, ^Byte _b, ^Byte _c, ^Byte _d])

JOKER FUNC net.IPv4Mask:
(defn IPv4Mask
  "IPv4Mask returns the IP mask (in 4-byte form) of the\nIPv4 mask a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo return type: IPMask\n\nJoker input arguments: [^Byte a, ^Byte b, ^Byte c, ^Byte d]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "iPv4Mask(_a, _b, _c, _d)"}
  [^Byte _a, ^Byte _b, ^Byte _c, ^Byte _d])

JOKER FUNC net.InterfaceAddrs:
;; (defn InterfaceAddrs
;;   "InterfaceAddrs returns a list of the system's unicast interface\naddresses.\n\nThe returned list does not identify the associated interface; use\nInterfaces and Interface.Addrs for more detail.\n\nGo return type: ([]Addr, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/net.go:105:11)) Error]"
;;   {:added "1.0"
;;    :go "interfaceAddrs()"}
;;   [])

JOKER FUNC net.InterfaceByIndex:
(defn InterfaceByIndex
  "InterfaceByIndex returns the interface specified by index.\n\nOn Solaris, it returns one of the logical network interfaces\nsharing the logical data link; for more precision use\nInterfaceByName.\n\nGo input arguments: (index int)\n\nGo return type: (*Interface, error)\n\nJoker input arguments: [^Int index]\n\nJoker return type: [{:Index ^Int, :MTU ^Int, :Name ^String, :HardwareAddr ^(vector-of Int), :Flags ^Int} Error]"
  {:added "1.0"
   :go "interfaceByIndex(_index)"}
  [^Int _index])

JOKER FUNC net.InterfaceByName:
(defn InterfaceByName
  "InterfaceByName returns the interface specified by name.\n\nGo input arguments: (name string)\n\nGo return type: (*Interface, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [{:Index ^Int, :MTU ^Int, :Name ^String, :HardwareAddr ^(vector-of Int), :Flags ^Int} Error]"
  {:added "1.0"
   :go "interfaceByName(_name)"}
  [^String _name])

JOKER FUNC net.Interfaces:
(defn Interfaces
  "Interfaces returns a list of the system's network interfaces.\n\nGo return type: ([]Interface, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of {:Index ^Int, :MTU ^Int, :Name ^String, :HardwareAddr ^(vector-of Int), :Flags ^Int}) Error]"
  {:added "1.0"
   :go "interfaces()"}
  [])

JOKER FUNC net.JoinHostPort:
(defn ^"String" JoinHostPort
  "JoinHostPort combines host and port into a network address of the\nform \"host:port\". If host contains a colon, as found in literal\nIPv6 addresses, then JoinHostPort returns \"[host]:port\".\n\nSee func Dial for a description of the host and port parameters.\n\nGo input arguments: (host string, port string)\n\nGo return type: string\n\nJoker input arguments: [^String host, ^String port]\n\nJoker return type: String"
  {:added "1.0"
   :go "net.JoinHostPort(_host, _port)"}
  [^String _host, ^String _port])

JOKER FUNC net.Listen:
;; (defn Listen
;;   "Listen announces on the local network address.\n\nThe network must be \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\".\n\nFor TCP networks, if the host in the address parameter is empty or\na literal unspecified IP address, Listen listens on all available\nunicast and anycast IP addresses of the local system.\nTo only use IPv4, use network \"tcp4\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe Addr method of Listener can be used to discover the chosen\nport.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (Listener, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/net.go:365:15) Error]"
;;   {:added "1.0"
;;    :go "listen(_network, _address)"}
;;   [^String _network, ^String _address])

JOKER FUNC net.ListenIP:
;; (defn ListenIP
;;   "ListenIP acts like ListenPacket for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenIP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\n\nGo input arguments: (network string, laddr *ABEND884(unrecognized type IPAddr at: _tests/big/src/net/iprawsock.go:230:38))\n\nGo return type: (*IPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of IPAddr) laddr]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenIP(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfIPAddr(_laddr)))"}
;;   [^String _network, ^Object _laddr])

JOKER FUNC net.ListenMulticastUDP:
;; (defn ListenMulticastUDP
;;   "ListenMulticastUDP acts like ListenPacket for UDP networks but\ntakes a group address on a specific network interface.\n\nThe network must be a UDP network name; see func Dial for details.\n\nListenMulticastUDP listens on all available IP addresses of the\nlocal system including the group, multicast IP address.\nIf ifi is nil, ListenMulticastUDP uses the system-assigned\nmulticast interface, although this is not recommended because the\nassignment depends on platforms and sometimes it might require\nrouting configuration.\nIf the Port field of gaddr is 0, a port number is automatically\nchosen.\n\nListenMulticastUDP is just for convenience of simple, small\napplications. There are golang.org/x/net/ipv4 and\ngolang.org/x/net/ipv6 packages for general purpose uses.\n\nGo input arguments: (network string, ifi *ABEND884(unrecognized type Interface at: _tests/big/src/net/udpsock.go:265:46), gaddr *ABEND884(unrecognized type UDPAddr at: _tests/big/src/net/udpsock.go:265:64))\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of Interface) ifi, ^(atom-of UDPAddr) gaddr]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenMulticastUDP(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfInterface(_ifi)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfUDPAddr(_gaddr)))"}
;;   [^String _network, ^Object _ifi, ^Object _gaddr])

JOKER FUNC net.ListenPacket:
;; (defn ListenPacket
;;   "ListenPacket announces on the local network address.\n\nThe network must be \"udp\", \"udp4\", \"udp6\", \"unixgram\", or an IP\ntransport. The IP transports are \"ip\", \"ip4\", or \"ip6\" followed by\na colon and a literal protocol number or a protocol name, as in\n\"ip:1\" or \"ip:icmp\".\n\nFor UDP and IP networks, if the host in the address parameter is\nempty or a literal unspecified IP address, ListenPacket listens on\nall available IP addresses of the local system except multicast IP\naddresses.\nTo only use IPv4, use network \"udp4\" or \"ip4:proto\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe LocalAddr method of PacketConn can be used to discover the\nchosen port.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (PacketConn, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/net.go:303:17) Error]"
;;   {:added "1.0"
;;    :go "listenPacket(_network, _address)"}
;;   [^String _network, ^String _address])

JOKER FUNC net.ListenTCP:
;; (defn ListenTCP
;;   "ListenTCP acts like Listen for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenTCP listens on all available unicast and anycast IP addresses\nof the local system.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo input arguments: (network string, laddr *ABEND884(unrecognized type TCPAddr at: _tests/big/src/net/tcpsock.go:323:39))\n\nGo return type: (*TCPListener, error)\n\nJoker input arguments: [^String network, ^(atom-of TCPAddr) laddr]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenTCP(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfTCPAddr(_laddr)))"}
;;   [^String _network, ^Object _laddr])

JOKER FUNC net.ListenUDP:
;; (defn ListenUDP
;;   "ListenUDP acts like ListenPacket for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenUDP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo input arguments: (network string, laddr *ABEND884(unrecognized type UDPAddr at: _tests/big/src/net/udpsock.go:231:39))\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of UDPAddr) laddr]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenUDP(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfUDPAddr(_laddr)))"}
;;   [^String _network, ^Object _laddr])

JOKER FUNC net.ListenUnix:
;; (defn ListenUnix
;;   "ListenUnix acts like Listen for Unix networks.\n\nThe network must be \"unix\" or \"unixpacket\".\n\nGo input arguments: (network string, laddr *ABEND884(unrecognized type UnixAddr at: _tests/big/src/net/unixsock.go:314:40))\n\nGo return type: (*UnixListener, error)\n\nJoker input arguments: [^String network, ^(atom-of UnixAddr) laddr]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenUnix(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfUnixAddr(_laddr)))"}
;;   [^String _network, ^Object _laddr])

JOKER FUNC net.ListenUnixgram:
;; (defn ListenUnixgram
;;   "ListenUnixgram acts like ListenPacket for Unix networks.\n\nThe network must be \"unixgram\".\n\nGo input arguments: (network string, laddr *ABEND884(unrecognized type UnixAddr at: _tests/big/src/net/unixsock.go:334:44))\n\nGo return type: (*UnixConn, error)\n\nJoker input arguments: [^String network, ^(atom-of UnixAddr) laddr]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenUnixgram(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfUnixAddr(_laddr)))"}
;;   [^String _network, ^Object _laddr])

JOKER FUNC net.LookupAddr:
(defn LookupAddr
  "LookupAddr performs a reverse lookup for the given address, returning a list\nof names mapping to that address.\n\nWhen using the host C library resolver, at most one result will be\nreturned. To bypass the host resolver, use a custom Resolver.\n\nGo input arguments: (addr string)\n\nGo return type: (names []string, err error)\n\nJoker input arguments: [^String addr]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "lookupAddr(_addr)"}
  [^String _addr])

JOKER FUNC net.LookupCNAME:
(defn LookupCNAME
  "LookupCNAME returns the canonical name for the given host.\nCallers that do not care about the canonical name can call\nLookupHost or LookupIP directly; both take care of resolving\nthe canonical name as part of the lookup.\n\nA canonical name is the final name after following zero\nor more CNAME records.\nLookupCNAME does not return an error if host does not\ncontain DNS \"CNAME\" records, as long as host resolves to\naddress records.\n\nGo input arguments: (host string)\n\nGo return type: (cname string, err error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "lookupCNAME(_host)"}
  [^String _host])

JOKER FUNC net.LookupHost:
(defn LookupHost
  "LookupHost looks up the given host using the local resolver.\nIt returns a slice of that host's addresses.\n\nGo input arguments: (host string)\n\nGo return type: (addrs []string, err error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "lookupHost(_host)"}
  [^String _host])

JOKER FUNC net.LookupIP:
(defn LookupIP
  "LookupIP looks up host using the local resolver.\nIt returns a slice of that host's IPv4 and IPv6 addresses.\n\nGo input arguments: (host string)\n\nGo return type: ([]IP, error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [(vector-of (vector-of Int)) Error]"
  {:added "1.0"
   :go "lookupIP(_host)"}
  [^String _host])

JOKER FUNC net.LookupMX:
(defn LookupMX
  "LookupMX returns the DNS MX records for the given domain name sorted by preference.\n\nGo input arguments: (name string)\n\nGo return type: ([]*MX, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of {:Host ^String, :Pref ^Int}) Error]"
  {:added "1.0"
   :go "lookupMX(_name)"}
  [^String _name])

JOKER FUNC net.LookupNS:
(defn LookupNS
  "LookupNS returns the DNS NS records for the given domain name.\n\nGo input arguments: (name string)\n\nGo return type: ([]*NS, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of {:Host ^String}) Error]"
  {:added "1.0"
   :go "lookupNS(_name)"}
  [^String _name])

JOKER FUNC net.LookupPort:
(defn LookupPort
  "LookupPort looks up the port for the given network and service.\n\nGo input arguments: (network string, service string)\n\nGo return type: (port int, err error)\n\nJoker input arguments: [^String network, ^String service]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "lookupPort(_network, _service)"}
  [^String _network, ^String _service])

JOKER FUNC net.LookupSRV:
(defn LookupSRV
  "LookupSRV tries to resolve an SRV query of the given service,\nprotocol, and domain name. The proto is \"tcp\" or \"udp\".\nThe returned records are sorted by priority and randomized\nby weight within a priority.\n\nLookupSRV constructs the DNS name to look up following RFC 2782.\nThat is, it looks up _service._proto.name. To accommodate services\npublishing SRV records under non-standard names, if both service\nand proto are empty strings, LookupSRV looks up name directly.\n\nGo input arguments: (service string, proto string, name string)\n\nGo return type: (cname string, addrs []*SRV, err error)\n\nJoker input arguments: [^String service, ^String proto, ^String name]\n\nJoker return type: [String (vector-of {:Target ^String, :Port ^Int, :Priority ^Int, :Weight ^Int}) Error]"
  {:added "1.0"
   :go "lookupSRV(_service, _proto, _name)"}
  [^String _service, ^String _proto, ^String _name])

JOKER FUNC net.LookupTXT:
(defn LookupTXT
  "LookupTXT returns the DNS TXT records for the given domain name.\n\nGo input arguments: (name string)\n\nGo return type: ([]string, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "lookupTXT(_name)"}
  [^String _name])

JOKER FUNC net.ParseCIDR:
(defn ParseCIDR
  "ParseCIDR parses s as a CIDR notation IP address and prefix length,\nlike \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in\nRFC 4632 and RFC 4291.\n\nIt returns the IP address and the network implied by the IP and\nprefix length.\nFor example, ParseCIDR(\"192.0.2.1/24\") returns the IP address\n192.0.2.1 and the network 192.0.2.0/24.\n\nGo input arguments: (s string)\n\nGo return type: (IP, *IPNet, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [(vector-of Int) {:IP ^(vector-of Int), :Mask ^(vector-of Int)} Error]"
  {:added "1.0"
   :go "parseCIDR(_s)"}
  [^String _s])

JOKER FUNC net.ParseIP:
(defn ParseIP
  "ParseIP parses s as an IP address, returning the result.\nThe string s can be in dotted decimal (\"192.0.2.1\")\nor IPv6 (\"2001:db8::68\") form.\nIf s is not a valid textual representation of an IP address,\nParseIP returns nil.\n\nGo input arguments: (s string)\n\nGo return type: IP\n\nJoker input arguments: [^String s]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "parseIP(_s)"}
  [^String _s])

JOKER FUNC net.ParseMAC:
(defn ParseMAC
  "ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet\nIP over InfiniBand link-layer address using one of the following formats:\n  01:23:45:67:89:ab\n  01:23:45:67:89:ab:cd:ef\n  01:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00\n  01-23-45-67-89-ab\n  01-23-45-67-89-ab-cd-ef\n  01-23-45-67-89-ab-cd-ef-00-00-01-23-45-67-89-ab-cd-ef-00-00\n  0123.4567.89ab\n  0123.4567.89ab.cdef\n  0123.4567.89ab.cdef.0000.0123.4567.89ab.cdef.0000\n\nGo input arguments: (s string)\n\nGo return type: (hw HardwareAddr, err error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "parseMAC(_s)"}
  [^String _s])

JOKER FUNC net.Pipe:
;; (defn Pipe
;;   "Pipe creates a synchronous, in-memory, full duplex\nnetwork connection; both ends implement the Conn interface.\nReads on one end are matched with writes on the other,\ncopying data directly between the two; there is no internal\nbuffering.\n\nGo return type: (Conn, Conn)\n\nJoker input arguments: []\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/net.go:113:11) ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/net.go:113:11)]"
;;   {:added "1.0"
;;    :go "pipe()"}
;;   [])

JOKER FUNC net.ResolveIPAddr:
(defn ResolveIPAddr
  "ResolveIPAddr returns an address of IP end point.\n\nThe network must be an IP network name.\n\nIf the host in the address parameter is not a literal IP address,\nResolveIPAddr resolves the address to an address of IP end point.\nOtherwise, it parses the address as a literal IP address.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*IPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [{:IP ^(vector-of Int), :Zone ^String} Error]"
  {:added "1.0"
   :go "resolveIPAddr(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.ResolveTCPAddr:
(defn ResolveTCPAddr
  "ResolveTCPAddr returns an address of TCP end point.\n\nThe network must be a TCP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveTCPAddr resolves the\naddress to an address of TCP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*TCPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [{:IP ^(vector-of Int), :Port ^Int, :Zone ^String} Error]"
  {:added "1.0"
   :go "resolveTCPAddr(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.ResolveUDPAddr:
(defn ResolveUDPAddr
  "ResolveUDPAddr returns an address of UDP end point.\n\nThe network must be a UDP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveUDPAddr resolves the\naddress to an address of UDP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*UDPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [{:IP ^(vector-of Int), :Port ^Int, :Zone ^String} Error]"
  {:added "1.0"
   :go "resolveUDPAddr(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.ResolveUnixAddr:
(defn ResolveUnixAddr
  "ResolveUnixAddr returns an address of Unix domain socket end point.\n\nThe network must be a Unix network name.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*UnixAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [{:Name ^String, :Net ^String} Error]"
  {:added "1.0"
   :go "resolveUnixAddr(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.SplitHostPort:
(defn SplitHostPort
  "SplitHostPort splits a network address of the form \"host:port\",\n\"host%zone:port\", \"[host]:port\" or \"[host%zone]:port\" into host or\nhost%zone and port.\n\nA literal IPv6 address in hostport must be enclosed in square\nbrackets, as in \"[::1]:80\", \"[::1%lo0]:80\".\n\nSee func Dial for a description of the hostport parameter, and host\nand port results.\n\nGo input arguments: (hostport string)\n\nGo return type: (host string, port string, err error)\n\nJoker input arguments: [^String hostport]\n\nJoker return type: [String String Error]"
  {:added "1.0"
   :go "splitHostPort(_hostport)"}
  [^String _hostport])

JOKER FUNC net/http.CanonicalHeaderKey:
(defn ^"String" CanonicalHeaderKey
  "CanonicalHeaderKey returns the canonical format of the\nheader key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.CanonicalHeaderKey(_s)"}
  [^String _s])

JOKER FUNC net/http.DetectContentType:
(defn ^"String" DetectContentType
  "DetectContentType implements the algorithm described\nat https://mimesniff.spec.whatwg.org/ to determine the\nContent-Type of the given data. It considers at most the\nfirst 512 bytes of data. DetectContentType always returns\na valid MIME type: if it cannot determine a more specific one, it\nreturns \"application/octet-stream\".\n\nGo input arguments: (data []byte)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.DetectContentType(ConvertToArrayOfByte(_data))"}
  [^Object _data])

JOKER FUNC net/http.Error:
;; (defn Error
;;   "Error replies to the request with the specified error message and HTTP code.\nIt does not otherwise end the request; the caller should ensure no further\nwrites are done to w.\nThe error message should be plain text.\n\nGo input arguments: (w ResponseWriter, error string, code int)\n\nJoker input arguments: [^ResponseWriter w, ^String error, ^Int code]"
;;   {:added "1.0"
;;    :go "error(_w, _error, _code)"}
;;   [^ResponseWriter _w, ^String _error, ^Int _code])

JOKER FUNC net/http.FileServer:
;; (defn FileServer
;;   "FileServer returns a handler that serves HTTP requests\nwith the contents of the file system rooted at root.\n\nTo use the operating system's file system implementation,\nuse http.Dir:\n\n    http.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))\n\nAs a special case, the returned file server redirects any request\nending in \"/index.html\" to the same path, without the final\n\"index.html\".\n\nGo input arguments: (root FileSystem)\n\nGo return type: Handler\n\nJoker input arguments: [^FileSystem root]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "fileServer(_root)"}
;;   [^FileSystem _root])

JOKER FUNC net/http.Get:
;; (defn Get
;;   "Get issues a GET to the specified URL. If the response is one of\nthe following redirect codes, Get follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nAn error is returned if there were too many redirects or if there\nwas an HTTP protocol error. A non-2xx response doesn't cause an\nerror. Any returned error will be of type *url.Error. The url.Error\nvalue's Timeout method will report true if request timed out or was\ncanceled.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nGet is a wrapper around DefaultClient.Get.\n\nTo make a request with custom headers, use NewRequest and\nDefaultClient.Do.\n\nGo input arguments: (url string)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker return type: [{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Body ^ABEND042(cannot find typename io.ReadCloser), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Body ^ABEND042(cannot find typename io.ReadCloser), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/url/url.go:804:13), :PostForm ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/url/url.go:804:13), :MultipartForm ^ABEND042(cannot find typename mime/multipart.Form), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND042(cannot find typename crypto/tls.ConnectionState), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: _tests/big/src/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving net/http.Response)}, :TLS ^ABEND042(cannot find typename crypto/tls.ConnectionState)} Error]"
;;   {:added "1.0"
;;    :go "get(_url)"}
;;   [^String _url])

JOKER FUNC net/http.Handle:
;; (defn Handle
;;   "Handle registers the handler for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler Handler)\n\nJoker input arguments: [^String pattern, ^Handler handler]"
;;   {:added "1.0"
;;    :go "handle(_pattern, _handler)"}
;;   [^String _pattern, ^Handler _handler])

JOKER FUNC net/http.HandleFunc:
;; (defn HandleFunc
;;   "HandleFunc registers the handler function for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler func)\n\nJoker input arguments: [^String pattern, ^fn handler]"
;;   {:added "1.0"
;;    :go "handleFunc(_pattern, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^String _pattern, ^fn _handler])

JOKER FUNC net/http.Head:
;; (defn Head
;;   "Head issues a HEAD to the specified URL. If the response is one of\nthe following redirect codes, Head follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nHead is a wrapper around DefaultClient.Head\n\nGo input arguments: (url string)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker return type: [{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Body ^ABEND042(cannot find typename io.ReadCloser), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Body ^ABEND042(cannot find typename io.ReadCloser), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/url/url.go:804:13), :PostForm ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/url/url.go:804:13), :MultipartForm ^ABEND042(cannot find typename mime/multipart.Form), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND042(cannot find typename crypto/tls.ConnectionState), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: _tests/big/src/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving net/http.Response)}, :TLS ^ABEND042(cannot find typename crypto/tls.ConnectionState)} Error]"
;;   {:added "1.0"
;;    :go "head(_url)"}
;;   [^String _url])

JOKER FUNC net/http.ListenAndServe:
(defn ^"Error" ListenAndServe
  "ListenAndServe listens on the TCP network address addr and then calls\nServe with handler to handle requests on incoming connections.\nAccepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error.\n\nGo input arguments: (addr string, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^Handler handler]\n\nJoker return type: Error"
  {:added "1.0"
   :go "http.ListenAndServe(_addr, _handler)"}
  [^String _addr, ^Handler _handler])

JOKER FUNC net/http.ListenAndServeTLS:
(defn ^"Error" ListenAndServeTLS
  "ListenAndServeTLS acts identically to ListenAndServe, except that it\nexpects HTTPS connections. Additionally, files containing a certificate and\nmatching private key for the server must be provided. If the certificate\nis signed by a certificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nGo input arguments: (addr string, certFile string, keyFile string, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^String certFile, ^String keyFile, ^Handler handler]\n\nJoker return type: Error"
  {:added "1.0"
   :go "http.ListenAndServeTLS(_addr, _certFile, _keyFile, _handler)"}
  [^String _addr, ^String _certFile, ^String _keyFile, ^Handler _handler])

JOKER FUNC net/http.MaxBytesReader:
;; (defn MaxBytesReader
;;   "MaxBytesReader is similar to io.LimitReader but is intended for\nlimiting the size of incoming request bodies. In contrast to\nio.LimitReader, MaxBytesReader's result is a ReadCloser, returns a\nnon-EOF error for a Read beyond the limit, and closes the\nunderlying reader when its Close method is called.\n\nMaxBytesReader prevents clients from accidentally or maliciously\nsending a large request and wasting server resources.\n\nGo input arguments: (w ResponseWriter, r *ABEND884(unrecognized type ReadCloser at: _tests/big/src/net/http/request.go:1056:44), n int64)\n\nGo return type: ...\n\nJoker input arguments: [^ResponseWriter w, ^ReadCloser r, ^Int64 n]\n\nJoker return type: ABEND042(cannot find typename io.ReadCloser)"
;;   {:added "1.0"
;;    :go "maxBytesReader(_w, ABEND904(custom-runtime routine not implemented: io.ReadCloser(_r)), _n)"}
;;   [^ResponseWriter _w, ^ReadCloser _r, ^Int64 _n])

JOKER FUNC net/http.NewFileTransport:
;; (defn NewFileTransport
;;   "NewFileTransport returns a new RoundTripper, serving the provided\nFileSystem. The returned RoundTripper ignores the URL host in its\nincoming requests, as well as most other properties of the\nrequest.\n\nThe typical use case for NewFileTransport is to register the \"file\"\nprotocol with a Transport, as in:\n\n  t := &http.Transport{}\n  t.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))\n  c := &http.Client{Transport: t}\n  res, err := c.Get(\"file:///etc/passwd\")\n  ...\n\nGo input arguments: (fs FileSystem)\n\nGo return type: RoundTripper\n\nJoker input arguments: [^FileSystem fs]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/http/client.go:115:19)"
;;   {:added "1.0"
;;    :go "newFileTransport(_fs)"}
;;   [^FileSystem _fs])

JOKER FUNC net/http.NewRequest:
;; (defn NewRequest
;;   "NewRequest returns a new Request given a method, URL, and optional body.\n\nIf the provided body is also an io.Closer, the returned\nRequest.Body is set to body and will be closed by the Client\nmethods Do, Post, and PostForm, and Transport.RoundTrip.\n\nNewRequest returns a Request suitable for use with Client.Do or\nTransport.RoundTrip. To create a request for use with testing a\nServer Handler, either use the NewRequest function in the\nnet/http/httptest package, use ReadRequest, or manually update the\nRequest fields. See the Request type's documentation for the\ndifference between inbound and outbound request fields.\n\nIf body is of type *bytes.Buffer, *bytes.Reader, or\n*strings.Reader, the returned request's ContentLength is set to its\nexact value (instead of -1), GetBody is populated (so 307 and 308\nredirects can replay the body), and Body is set to NoBody if the\nContentLength is 0.\n\nGo input arguments: (method string, url string, body *ABEND884(unrecognized type Reader at: _tests/big/src/net/http/request.go:792:45))\n\nGo return type: (*Request, error)\n\nJoker input arguments: [^String method, ^String url, ^Reader body]\n\nJoker return type: [{:Method ^String, :URL ^{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Body ^ABEND042(cannot find typename io.ReadCloser), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/url/url.go:804:13), :PostForm ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/url/url.go:804:13), :MultipartForm ^ABEND042(cannot find typename mime/multipart.Form), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND042(cannot find typename crypto/tls.ConnectionState), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: _tests/big/src/net/http/request.go:308:9), :Response ^{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Body ^ABEND042(cannot find typename io.ReadCloser), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Request ^ABEND947(recursive type reference involving net/http.Request), :TLS ^ABEND042(cannot find typename crypto/tls.ConnectionState)}} Error]"
;;   {:added "1.0"
;;    :go "newRequest(_method, _url, ABEND904(custom-runtime routine not implemented: io.Reader(_body)))"}
;;   [^String _method, ^String _url, ^Reader _body])

JOKER FUNC net/http.NewServeMux:
;; (defn NewServeMux
;;   "NewServeMux allocates and returns a new ServeMux.\n\nGo return type: *ServeMux\n\nJoker input arguments: []\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newServeMux())"}
;;   [])

JOKER FUNC net/http.NotFound:
;; (defn NotFound
;;   "NotFound replies to the request with an HTTP 404 not found error.\n\nGo input arguments: (w ResponseWriter, r *ABEND884(unrecognized type Request at: _tests/big/src/net/http/server.go:1981:36))\n\nJoker input arguments: [^ResponseWriter w, ^(atom-of Request) r]"
;;   {:added "1.0"
;;    :go "notFound(_w, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfRequest(_r)))"}
;;   [^ResponseWriter _w, ^Object _r])

JOKER FUNC net/http.NotFoundHandler:
;; (defn NotFoundHandler
;;   "NotFoundHandler returns a simple request handler\nthat replies to each request with a ``404 page not found'' reply.\n\nGo return type: Handler\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "notFoundHandler()"}
;;   [])

JOKER FUNC net/http.ParseHTTPVersion:
(defn ParseHTTPVersion
  "ParseHTTPVersion parses a HTTP version string.\n\"HTTP/1.0\" returns (1, 0, true).\n\nGo input arguments: (vers string)\n\nGo return type: (major int, minor int, ok bool)\n\nJoker input arguments: [^String vers]\n\nJoker return type: [Int Int Bool]"
  {:added "1.0"
   :go "parseHTTPVersion(_vers)"}
  [^String _vers])

JOKER FUNC net/http.ParseTime:
;; (defn ParseTime
;;   "ParseTime parses a time header (such as the Date: header),\ntrying each of the three formats allowed by HTTP/1.1:\nTimeFormat, time.RFC850, and time.ANSIC.\n\nGo input arguments: (text string)\n\nGo return type: (t ..., err error)\n\nJoker input arguments: [^String text]\n\nJoker return type: [ABEND042(cannot find typename time.Time) Error]"
;;   {:added "1.0"
;;    :go "parseTime(_text)"}
;;   [^String _text])

JOKER FUNC net/http.Post:
;; (defn Post
;;   "Post issues a POST to the specified URL.\n\nCaller should close resp.Body when done reading from it.\n\nIf the provided body is an io.Closer, it is closed after the\nrequest.\n\nPost is a wrapper around DefaultClient.Post.\n\nTo set custom headers, use NewRequest and DefaultClient.Do.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, contentType string, body *ABEND884(unrecognized type Reader at: _tests/big/src/net/http/client.go:748:44))\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^String contentType, ^Reader body]\n\nJoker return type: [{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Body ^ABEND042(cannot find typename io.ReadCloser), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Body ^ABEND042(cannot find typename io.ReadCloser), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/url/url.go:804:13), :PostForm ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/url/url.go:804:13), :MultipartForm ^ABEND042(cannot find typename mime/multipart.Form), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND042(cannot find typename crypto/tls.ConnectionState), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: _tests/big/src/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving net/http.Response)}, :TLS ^ABEND042(cannot find typename crypto/tls.ConnectionState)} Error]"
;;   {:added "1.0"
;;    :go "post(_url, _contentType, ABEND904(custom-runtime routine not implemented: io.Reader(_body)))"}
;;   [^String _url, ^String _contentType, ^Reader _body])

JOKER FUNC net/http.PostForm:
;; (defn PostForm
;;   "PostForm issues a POST to the specified URL, with data's keys and\nvalues URL-encoded as the request body.\n\nThe Content-Type header is set to application/x-www-form-urlencoded.\nTo set other headers, use NewRequest and DefaultClient.Do.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nPostForm is a wrapper around DefaultClient.PostForm.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, data *ABEND884(unrecognized type Values at: _tests/big/src/net/http/client.go:785:36))\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^Values data]\n\nJoker return type: [{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Body ^ABEND042(cannot find typename io.ReadCloser), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Body ^ABEND042(cannot find typename io.ReadCloser), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/url/url.go:804:13), :PostForm ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/url/url.go:804:13), :MultipartForm ^ABEND042(cannot find typename mime/multipart.Form), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND042(cannot find typename crypto/tls.ConnectionState), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: _tests/big/src/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving net/http.Response)}, :TLS ^ABEND042(cannot find typename crypto/tls.ConnectionState)} Error]"
;;   {:added "1.0"
;;    :go "postForm(_url, ABEND904(custom-runtime routine not implemented: url.Values(_data)))"}
;;   [^String _url, ^Values _data])

JOKER FUNC net/http.ProxyFromEnvironment:
;; (defn ProxyFromEnvironment
;;   "ProxyFromEnvironment returns the URL of the proxy to use for a\ngiven request, as indicated by the environment variables\nHTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions\nthereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https\nrequests.\n\nThe environment values may be either a complete URL or a\n\"host[:port]\", in which case the \"http\" scheme is assumed.\nAn error is returned if the value is a different form.\n\nA nil URL and nil error are returned if no proxy is defined in the\nenvironment, or a proxy should not be used for the given request,\nas defined by NO_PROXY.\n\nAs a special case, if req.URL.Host is \"localhost\" (with or without\na port number), then a nil URL and nil error will be returned.\n\nGo input arguments: (req *ABEND884(unrecognized type Request at: _tests/big/src/net/http/transport.go:345:32))\n\nGo return type: (*struct {Scheme string; Opaque string; User *Userinfo; Host string; Path string; RawPath string; ForceQuery bool; RawQuery string; Fragment string}, error)\n\nJoker input arguments: [^(atom-of Request) req]\n\nJoker return type: [{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String} Error]"
;;   {:added "1.0"
;;    :go "proxyFromEnvironment(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfRequest(_req)))"}
;;   [^Object _req])

JOKER FUNC net/http.ProxyURL:
;; (defn ProxyURL
;;   "ProxyURL returns a proxy function (for use in a Transport)\nthat always returns the same URL.\n\nGo input arguments: (fixedURL **ABEND884(unrecognized type URL at: _tests/big/src/net/http/transport.go:351:29))\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of URL) fixedURL]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/transport.go:351:34)"
;;   {:added "1.0"
;;    :go "proxyURL(ConvertToIndirectOfURL(ABEND904(custom-runtime routine not implemented: url.URL(_fixedURL))))"}
;;   [^Object _fixedURL])

JOKER FUNC net/http.ReadRequest:
;; (defn ReadRequest
;;   "ReadRequest reads and parses an incoming request from b.\n\nReadRequest is a low-level function and should only be used for\nspecialized applications; most code should use the Server to read\nrequests and handle them via the Handler interface. ReadRequest\nonly supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.\n\nGo input arguments: (b **ABEND884(unrecognized type Reader at: _tests/big/src/net/http/request.go:942:27))\n\nGo return type: (*Request, error)\n\nJoker input arguments: [^(atom-of Reader) b]\n\nJoker return type: [{:Method ^String, :URL ^{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Body ^ABEND042(cannot find typename io.ReadCloser), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/url/url.go:804:13), :PostForm ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/url/url.go:804:13), :MultipartForm ^ABEND042(cannot find typename mime/multipart.Form), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND042(cannot find typename crypto/tls.ConnectionState), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: _tests/big/src/net/http/request.go:308:9), :Response ^{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Body ^ABEND042(cannot find typename io.ReadCloser), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Request ^ABEND947(recursive type reference involving net/http.Request), :TLS ^ABEND042(cannot find typename crypto/tls.ConnectionState)}} Error]"
;;   {:added "1.0"
;;    :go "readRequest(ConvertToIndirectOfReader(ABEND904(custom-runtime routine not implemented: bufio.Reader(_b))))"}
;;   [^Object _b])

JOKER FUNC net/http.ReadResponse:
;; (defn ReadResponse
;;   "ReadResponse reads and returns an HTTP response from r.\nThe req parameter optionally specifies the Request that corresponds\nto this Response. If nil, a GET request is assumed.\nClients must call resp.Body.Close when finished reading resp.Body.\nAfter that call, clients can inspect resp.Trailer to find key/value\npairs included in the response trailer.\n\nGo input arguments: (r **ABEND884(unrecognized type Reader at: _tests/big/src/net/http/response.go:148:28), req *ABEND884(unrecognized type Request at: _tests/big/src/net/http/response.go:148:41))\n\nGo return type: (*Response, error)\n\nJoker input arguments: [^(atom-of Reader) r, ^(atom-of Request) req]\n\nJoker return type: [{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Body ^ABEND042(cannot find typename io.ReadCloser), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Body ^ABEND042(cannot find typename io.ReadCloser), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/url/url.go:804:13), :PostForm ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/url/url.go:804:13), :MultipartForm ^ABEND042(cannot find typename mime/multipart.Form), :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND042(cannot find typename crypto/tls.ConnectionState), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: _tests/big/src/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving net/http.Response)}, :TLS ^ABEND042(cannot find typename crypto/tls.ConnectionState)} Error]"
;;   {:added "1.0"
;;    :go "readResponse(ConvertToIndirectOfReader(ABEND904(custom-runtime routine not implemented: bufio.Reader(_r))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfRequest(_req)))"}
;;   [^Object _r, ^Object _req])

JOKER FUNC net/http.Redirect:
;; (defn Redirect
;;   "Redirect replies to the request with a redirect to url,\nwhich may be a path relative to the request path.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nIf the Content-Type header has not been set, Redirect sets it\nto \"text/html; charset=utf-8\" and writes a small HTML body.\nSetting the Content-Type header to any value, including nil,\ndisables that behavior.\n\nGo input arguments: (w ResponseWriter, r *ABEND884(unrecognized type Request at: _tests/big/src/net/http/server.go:2020:36), url string, code int)\n\nJoker input arguments: [^ResponseWriter w, ^(atom-of Request) r, ^String url, ^Int code]"
;;   {:added "1.0"
;;    :go "redirect(_w, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfRequest(_r)), _url, _code)"}
;;   [^ResponseWriter _w, ^Object _r, ^String _url, ^Int _code])

JOKER FUNC net/http.RedirectHandler:
;; (defn RedirectHandler
;;   "RedirectHandler returns a request handler that redirects\neach request it receives to the given url using the given\nstatus code.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nGo input arguments: (url string, code int)\n\nGo return type: Handler\n\nJoker input arguments: [^String url, ^Int code]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "redirectHandler(_url, _code)"}
;;   [^String _url, ^Int _code])

JOKER FUNC net/http.Serve:
;; (defn ^"Error" Serve
;;   "Serve accepts incoming HTTP connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nHTTP/2 support is only enabled if the Listener returns *tls.Conn\nconnections and they were configured with \"h2\" in the TLS\nConfig.NextProtos.\n\nServe always returns a non-nil error.\n\nGo input arguments: (l *ABEND884(unrecognized type Listener at: _tests/big/src/net/http/server.go:2421:18), handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^Listener l, ^Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.Serve(ABEND904(custom-runtime routine not implemented: net.Listener(_l)), _handler)"}
;;   [^Listener _l, ^Handler _handler])

JOKER FUNC net/http.ServeContent:
;; (defn ServeContent
;;   "ServeContent replies to the request using the content in the\nprovided ReadSeeker. The main benefit of ServeContent over io.Copy\nis that it handles Range requests properly, sets the MIME type, and\nhandles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,\nand If-Range requests.\n\nIf the response's Content-Type header is not set, ServeContent\nfirst tries to deduce the type from name's file extension and,\nif that fails, falls back to reading the first block of the content\nand passing it to DetectContentType.\nThe name is otherwise unused; in particular it can be empty and is\nnever sent in the response.\n\nIf modtime is not the zero time or Unix epoch, ServeContent\nincludes it in a Last-Modified header in the response. If the\nrequest includes an If-Modified-Since header, ServeContent uses\nmodtime to decide whether the content needs to be sent at all.\n\nThe content's Seek method must work: ServeContent uses\na seek to the end of the content to determine its size.\n\nIf the caller has set w's ETag header formatted per RFC 7232, section 2.3,\nServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.\n\nNote that *os.File implements the io.ReadSeeker interface.\n\nGo input arguments: (w ResponseWriter, req *ABEND884(unrecognized type Request at: _tests/big/src/net/http/fs.go:151:42), name string, modtime *ABEND884(unrecognized type Time at: _tests/big/src/net/http/fs.go:151:77), content *ABEND884(unrecognized type ReadSeeker at: _tests/big/src/net/http/fs.go:151:94))\n\nJoker input arguments: [^ResponseWriter w, ^(atom-of Request) req, ^String name, ^Time modtime, ^ReadSeeker content]"
;;   {:added "1.0"
;;    :go "serveContent(_w, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfRequest(_req)), _name, ABEND904(custom-runtime routine not implemented: time.Time(_modtime)), ABEND904(custom-runtime routine not implemented: io.ReadSeeker(_content)))"}
;;   [^ResponseWriter _w, ^Object _req, ^String _name, ^Time _modtime, ^ReadSeeker _content])

JOKER FUNC net/http.ServeFile:
;; (defn ServeFile
;;   "ServeFile replies to the request with the contents of the named\nfile or directory.\n\nIf the provided file or directory name is a relative path, it is\ninterpreted relative to the current directory and may ascend to\nparent directories. If the provided name is constructed from user\ninput, it should be sanitized before calling ServeFile.\n\nAs a precaution, ServeFile will reject requests where r.URL.Path\ncontains a \"..\" path element; this protects against callers who\nmight unsafely use filepath.Join on r.URL.Path without sanitizing\nit and then use that filepath.Join result as the name argument.\n\nAs another special case, ServeFile redirects any request where r.URL.Path\nends in \"/index.html\" to the same path, without the final\n\"index.html\". To avoid such redirects either modify the path or\nuse ServeContent.\n\nOutside of those two special cases, ServeFile does not use\nr.URL.Path for selecting the file or directory to serve; only the\nfile or directory provided in the name argument is used.\n\nGo input arguments: (w ResponseWriter, r *ABEND884(unrecognized type Request at: _tests/big/src/net/http/fs.go:670:37), name string)\n\nJoker input arguments: [^ResponseWriter w, ^(atom-of Request) r, ^String name]"
;;   {:added "1.0"
;;    :go "serveFile(_w, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfRequest(_r)), _name)"}
;;   [^ResponseWriter _w, ^Object _r, ^String _name])

JOKER FUNC net/http.ServeTLS:
;; (defn ^"Error" ServeTLS
;;   "ServeTLS accepts incoming HTTPS connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nAdditionally, files containing a certificate and matching private key\nfor the server must be provided. If the certificate is signed by a\ncertificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nServeTLS always returns a non-nil error.\n\nGo input arguments: (l *ABEND884(unrecognized type Listener at: _tests/big/src/net/http/server.go:2438:21), handler Handler, certFile string, keyFile string)\n\nGo return type: error\n\nJoker input arguments: [^Listener l, ^Handler handler, ^String certFile, ^String keyFile]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.ServeTLS(ABEND904(custom-runtime routine not implemented: net.Listener(_l)), _handler, _certFile, _keyFile)"}
;;   [^Listener _l, ^Handler _handler, ^String _certFile, ^String _keyFile])

JOKER FUNC net/http.SetCookie:
;; (defn SetCookie
;;   "SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.\nThe provided cookie must have a valid Name. Invalid cookies may be\nsilently dropped.\n\nGo input arguments: (w ResponseWriter, cookie *ABEND884(unrecognized type Cookie at: _tests/big/src/net/http/cookie.go:157:42))\n\nJoker input arguments: [^ResponseWriter w, ^(atom-of Cookie) cookie]"
;;   {:added "1.0"
;;    :go "setCookie(_w, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfCookie(_cookie)))"}
;;   [^ResponseWriter _w, ^Object _cookie])

JOKER FUNC net/http.StatusText:
(defn ^"String" StatusText
  "StatusText returns a text for the HTTP status code. It returns the empty\nstring if the code is unknown.\n\nGo input arguments: (code int)\n\nGo return type: string\n\nJoker input arguments: [^Int code]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.StatusText(_code)"}
  [^Int _code])

JOKER FUNC net/http.StripPrefix:
;; (defn StripPrefix
;;   "StripPrefix returns a handler that serves HTTP requests\nby removing the given prefix from the request URL's Path\nand invoking the handler h. StripPrefix handles a\nrequest for a path that doesn't begin with prefix by\nreplying with an HTTP 404 not found error.\n\nGo input arguments: (prefix string, h Handler)\n\nGo return type: Handler\n\nJoker input arguments: [^String prefix, ^Handler h]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "stripPrefix(_prefix, _h)"}
;;   [^String _prefix, ^Handler _h])

JOKER FUNC net/http.TimeoutHandler:
;; (defn TimeoutHandler
;;   "TimeoutHandler returns a Handler that runs h with the given time limit.\n\nThe new Handler calls h.ServeHTTP to handle each request, but if a\ncall runs for longer than its time limit, the handler responds with\na 503 Service Unavailable error and the given message in its body.\n(If msg is empty, a suitable default message will be sent.)\nAfter such a timeout, writes by h to its ResponseWriter will return\nErrHandlerTimeout.\n\nTimeoutHandler buffers all Handler writes to memory and does not\nsupport the Hijacker or Flusher interfaces.\n\nGo input arguments: (h Handler, dt *ABEND884(unrecognized type Duration at: _tests/big/src/net/http/server.go:3106:40), msg string)\n\nGo return type: Handler\n\nJoker input arguments: [^Handler h, ^Duration dt, ^String msg]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "timeoutHandler(_h, ABEND904(custom-runtime routine not implemented: time.Duration(_dt)), _msg)"}
;;   [^Handler _h, ^Duration _dt, ^String _msg])

JOKER FUNC net/http/cgi.Request:
;; (defn Request
;;   "Request returns the HTTP request as represented in the current\nenvironment. This assumes the current program is being run\nby a web server in a CGI environment.\nThe returned Request's Body is populated, if applicable.\n\nGo return type: (*struct {Method string; URL *struct {Scheme string; Opaque string; User *Userinfo; Host string; Path string; RawPath string; ForceQuery bool; RawQuery string; Fragment string}; Proto string; ProtoMajor int; ProtoMinor int; Header Header; Body ...; GetBody ...; ContentLength int; TransferEncoding []string; Close bool; Host string; Form ...; PostForm ...; MultipartForm *...; Trailer Header; RemoteAddr string; RequestURI string; TLS *...; Cancel ...; Response *Response}, error)\n\nJoker input arguments: []\n\nJoker return type: [{:Method ^String, :URL ^{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http/cgi.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND042(cannot find typename net/http/cgi.Header), :Body ^ABEND042(cannot find typename io.ReadCloser), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/url/url.go:804:13), :PostForm ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/url/url.go:804:13), :MultipartForm ^ABEND042(cannot find typename mime/multipart.Form), :Trailer ^ABEND042(cannot find typename net/http/cgi.Header), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND042(cannot find typename crypto/tls.ConnectionState), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: _tests/big/src/net/http/request.go:308:9), :Response ^ABEND042(cannot find typename net/http/cgi.Response)} Error]"
;;   {:added "1.0"
;;    :go "request()"}
;;   [])

JOKER FUNC net/http/cgi.RequestFromMap:
;; (defn RequestFromMap
;;   "RequestFromMap creates an http.Request from CGI variables.\nThe returned Request's Body field is not populated.\n\nGo input arguments: (params map[])\n\nGo return type: (*struct {Method string; URL *struct {Scheme string; Opaque string; User *Userinfo; Host string; Path string; RawPath string; ForceQuery bool; RawQuery string; Fragment string}; Proto string; ProtoMajor int; ProtoMinor int; Header Header; Body ...; GetBody ...; ContentLength int; TransferEncoding []string; Close bool; Host string; Form ...; PostForm ...; MultipartForm *...; Trailer Header; RemoteAddr string; RequestURI string; TLS *...; Cancel ...; Response *Response}, error)\n\nJoker input arguments: [^{} params]\n\nJoker return type: [{:Method ^String, :URL ^{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http/cgi.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND042(cannot find typename net/http/cgi.Header), :Body ^ABEND042(cannot find typename io.ReadCloser), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/url/url.go:804:13), :PostForm ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/url/url.go:804:13), :MultipartForm ^ABEND042(cannot find typename mime/multipart.Form), :Trailer ^ABEND042(cannot find typename net/http/cgi.Header), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND042(cannot find typename crypto/tls.ConnectionState), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: _tests/big/src/net/http/request.go:308:9), :Response ^ABEND042(cannot find typename net/http/cgi.Response)} Error]"
;;   {:added "1.0"
;;    :go "requestFromMap(ABEND908(custom-runtime routine not implemented: ConvertToMapTypeHaHa()))"}
;;   [^{} _params])

JOKER FUNC net/http/cgi.Serve:
;; (defn ^"Error" Serve
;;   "Serve executes the provided Handler on the currently active CGI\nrequest, if any. If there's no current CGI environment\nan error is returned. The provided handler may be nil to use\nhttp.DefaultServeMux.\n\nGo input arguments: (handler *ABEND884(unrecognized type Handler at: _tests/big/src/net/http/cgi/child.go:146:25))\n\nGo return type: error\n\nJoker input arguments: [^Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "cgi.Serve(ABEND904(custom-runtime routine not implemented: http.Handler(_handler)))"}
;;   [^Handler _handler])

JOKER FUNC net/http/cookiejar.New:
;; (defn New
;;   "New returns a new cookie jar. A nil *Options is equivalent to a zero\nOptions.\n\nGo input arguments: (o *ABEND884(unrecognized type Options at: _tests/big/src/net/http/cookiejar/jar.go:77:13))\n\nGo return type: (*Jar, error)\n\nJoker input arguments: [^(atom-of Options) o]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "new(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfOptions(_o)))"}
;;   [^Object _o])

JOKER FUNC net/http/fcgi.ProcessEnv:
;; (defn ProcessEnv
;;   "ProcessEnv returns FastCGI environment variables associated with the request r\nfor which no effort was made to be included in the request itself - the data\nis hidden in the request's context. As an example, if REMOTE_USER is set for a\nrequest, it will not be found anywhere in r, but it will be included in\nProcessEnv's response (via r's context).\n\nGo input arguments: (r **ABEND884(unrecognized type Request at: _tests/big/src/net/http/fcgi/child.go:358:25))\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of Request) r]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/fcgi/child.go:358:34)"
;;   {:added "1.0"
;;    :go "processEnv(ConvertToIndirectOfRequest(ABEND904(custom-runtime routine not implemented: http.Request(_r))))"}
;;   [^Object _r])

JOKER FUNC net/http/fcgi.Serve:
;; (defn ^"Error" Serve
;;   "Serve accepts incoming FastCGI connections on the listener l, creating a new\ngoroutine for each. The goroutine reads requests and then calls handler\nto reply to them.\nIf l is nil, Serve accepts connections from os.Stdin.\nIf handler is nil, http.DefaultServeMux is used.\n\nGo input arguments: (l *ABEND884(unrecognized type Listener at: _tests/big/src/net/http/fcgi/child.go:331:18), handler *ABEND884(unrecognized type Handler at: _tests/big/src/net/http/fcgi/child.go:331:41))\n\nGo return type: error\n\nJoker input arguments: [^Listener l, ^Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "fcgi.Serve(ABEND904(custom-runtime routine not implemented: net.Listener(_l)), ABEND904(custom-runtime routine not implemented: http.Handler(_handler)))"}
;;   [^Listener _l, ^Handler _handler])

JOKER FUNC net/http/httptest.NewRecorder:
;; (defn NewRecorder
;;   "NewRecorder returns an initialized ResponseRecorder.\n\nGo return type: *ResponseRecorder\n\nJoker input arguments: []\n\nJoker return type: {:Code ^Int, :HeaderMap ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/header.go:20:13), :Body ^ABEND042(cannot find typename bytes.Buffer), :Flushed ^Bool}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newRecorder())"}
;;   [])

JOKER FUNC net/http/httptest.NewRequest:
;; (defn NewRequest
;;   "NewRequest returns a new incoming server Request, suitable\nfor passing to an http.Handler for testing.\n\nThe target is the RFC 7230 \"request-target\": it may be either a\npath or an absolute URL. If target is an absolute URL, the host name\nfrom the URL is used. Otherwise, \"example.com\" is used.\n\nThe TLS field is set to a non-nil dummy value if target has scheme\n\"https\".\n\nThe Request.Proto is always HTTP/1.1.\n\nAn empty method means \"GET\".\n\nThe provided body may be nil. If the body is of type *bytes.Reader,\n*strings.Reader, or *bytes.Buffer, the Request.ContentLength is\nset.\n\nNewRequest panics on error for ease of use in testing, where a\npanic is acceptable.\n\nTo generate a client HTTP request instead of a server request, see\nthe NewRequest function in the net/http package.\n\nGo input arguments: (method string, target string, body *ABEND884(unrecognized type Reader at: _tests/big/src/net/http/httptest/httptest.go:41:48))\n\nGo return type: *struct {Method string; URL *struct {Scheme string; Opaque string; User *Userinfo; Host string; Path string; RawPath string; ForceQuery bool; RawQuery string; Fragment string}; Proto string; ProtoMajor int; ProtoMinor int; Header Header; Body ...; GetBody ...; ContentLength int; TransferEncoding []string; Close bool; Host string; Form ...; PostForm ...; MultipartForm *...; Trailer Header; RemoteAddr string; RequestURI string; TLS *...; Cancel ...; Response *Response}\n\nJoker input arguments: [^String method, ^String target, ^Reader body]\n\nJoker return type: {:Method ^String, :URL ^{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http/httptest.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND042(cannot find typename net/http/httptest.Header), :Body ^ABEND042(cannot find typename io.ReadCloser), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/url/url.go:804:13), :PostForm ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/url/url.go:804:13), :MultipartForm ^ABEND042(cannot find typename mime/multipart.Form), :Trailer ^ABEND042(cannot find typename net/http/httptest.Header), :RemoteAddr ^String, :RequestURI ^String, :TLS ^ABEND042(cannot find typename crypto/tls.ConnectionState), :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: _tests/big/src/net/http/request.go:308:9), :Response ^ABEND042(cannot find typename net/http/httptest.Response)}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newRequest(_method, _target, ABEND904(custom-runtime routine not implemented: io.Reader(_body))))"}
;;   [^String _method, ^String _target, ^Reader _body])

JOKER FUNC net/http/httptest.NewServer:
;; (defn NewServer
;;   "NewServer starts and returns a new Server.\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler *ABEND884(unrecognized type Handler at: _tests/big/src/net/http/httptest/server.go:80:29))\n\nGo return type: *Server\n\nJoker input arguments: [^Handler handler]\n\nJoker return type: {:URL ^String, :Listener ^ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/net.go:365:15), :TLS ^ABEND042(cannot find typename crypto/tls.Config), :Config ^{:Addr ^String, :Handler ^ABEND042(cannot find typename net/http/httptest.Handler), :TLSConfig ^ABEND042(cannot find typename crypto/tls.Config), :ReadTimeout ^ABEND042(cannot find typename time.Duration), :ReadHeaderTimeout ^ABEND042(cannot find typename time.Duration), :WriteTimeout ^ABEND042(cannot find typename time.Duration), :IdleTimeout ^ABEND042(cannot find typename time.Duration), :MaxHeaderBytes ^Int, :TLSNextProto ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/server.go:2501:15), :ConnState ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/server.go:2506:12), :ErrorLog ^ABEND042(cannot find typename log.Logger)}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newServer(ABEND904(custom-runtime routine not implemented: http.Handler(_handler))))"}
;;   [^Handler _handler])

JOKER FUNC net/http/httptest.NewTLSServer:
;; (defn NewTLSServer
;;   "NewTLSServer starts and returns a new Server using TLS.\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler *ABEND884(unrecognized type Handler at: _tests/big/src/net/http/httptest/server.go:160:32))\n\nGo return type: *Server\n\nJoker input arguments: [^Handler handler]\n\nJoker return type: {:URL ^String, :Listener ^ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/net.go:365:15), :TLS ^ABEND042(cannot find typename crypto/tls.Config), :Config ^{:Addr ^String, :Handler ^ABEND042(cannot find typename net/http/httptest.Handler), :TLSConfig ^ABEND042(cannot find typename crypto/tls.Config), :ReadTimeout ^ABEND042(cannot find typename time.Duration), :ReadHeaderTimeout ^ABEND042(cannot find typename time.Duration), :WriteTimeout ^ABEND042(cannot find typename time.Duration), :IdleTimeout ^ABEND042(cannot find typename time.Duration), :MaxHeaderBytes ^Int, :TLSNextProto ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/server.go:2501:15), :ConnState ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/server.go:2506:12), :ErrorLog ^ABEND042(cannot find typename log.Logger)}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newTLSServer(ABEND904(custom-runtime routine not implemented: http.Handler(_handler))))"}
;;   [^Handler _handler])

JOKER FUNC net/http/httptest.NewUnstartedServer:
;; (defn NewUnstartedServer
;;   "NewUnstartedServer returns a new Server but doesn't start it.\n\nAfter changing its configuration, the caller should call Start or\nStartTLS.\n\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler *ABEND884(unrecognized type Handler at: _tests/big/src/net/http/httptest/server.go:92:38))\n\nGo return type: *Server\n\nJoker input arguments: [^Handler handler]\n\nJoker return type: {:URL ^String, :Listener ^ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/net.go:365:15), :TLS ^ABEND042(cannot find typename crypto/tls.Config), :Config ^{:Addr ^String, :Handler ^ABEND042(cannot find typename net/http/httptest.Handler), :TLSConfig ^ABEND042(cannot find typename crypto/tls.Config), :ReadTimeout ^ABEND042(cannot find typename time.Duration), :ReadHeaderTimeout ^ABEND042(cannot find typename time.Duration), :WriteTimeout ^ABEND042(cannot find typename time.Duration), :IdleTimeout ^ABEND042(cannot find typename time.Duration), :MaxHeaderBytes ^Int, :TLSNextProto ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/server.go:2501:15), :ConnState ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/server.go:2506:12), :ErrorLog ^ABEND042(cannot find typename log.Logger)}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newUnstartedServer(ABEND904(custom-runtime routine not implemented: http.Handler(_handler))))"}
;;   [^Handler _handler])

JOKER FUNC net/http/httptrace.ContextClientTrace:
;; (defn ContextClientTrace
;;   "ContextClientTrace returns the ClientTrace associated with the\nprovided context. If none, it returns nil.\n\nGo input arguments: (ctx *ABEND884(unrecognized type Context at: _tests/big/src/net/http/httptrace/trace.go:24:37))\n\nGo return type: *ClientTrace\n\nJoker input arguments: [^Context ctx]\n\nJoker return type: {:GetConn ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/httptrace/trace.go:85:10), :GotConn ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/httptrace/trace.go:91:10), :PutIdleConn ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/httptrace/trace.go:101:14), :GotFirstResponseByte ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/httptrace/trace.go:105:23), :Got100Continue ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/httptrace/trace.go:109:17), :Got1xxResponse ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/httptrace/trace.go:115:17), :DNSStart ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/httptrace/trace.go:118:11), :DNSDone ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/httptrace/trace.go:121:10), :ConnectStart ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/httptrace/trace.go:126:15), :ConnectDone ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/httptrace/trace.go:133:14), :TLSHandshakeStart ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/httptrace/trace.go:138:20), :TLSHandshakeDone ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/httptrace/trace.go:143:19), :WroteHeaderField ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/httptrace/trace.go:148:19), :WroteHeaders ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/httptrace/trace.go:152:15), :Wait100Continue ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/httptrace/trace.go:158:18), :WroteRequest ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/httptrace/trace.go:163:15)}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: contextClientTrace(ABEND904(custom-runtime routine not implemented: context.Context(_ctx))))"}
;;   [^Context _ctx])

JOKER FUNC net/http/httptrace.WithClientTrace:
;; (defn WithClientTrace
;;   "WithClientTrace returns a new context based on the provided parent\nctx. HTTP client requests made with the returned context will use\nthe provided trace hooks, in addition to any previous hooks\nregistered with ctx. Any hooks defined in the provided trace will\nbe called first.\n\nGo input arguments: (ctx *ABEND884(unrecognized type Context at: _tests/big/src/net/http/httptrace/trace.go:34:34), trace *ABEND884(unrecognized type ClientTrace at: _tests/big/src/net/http/httptrace/trace.go:34:50))\n\nGo return type: ...\n\nJoker input arguments: [^Context ctx, ^(atom-of ClientTrace) trace]\n\nJoker return type: ABEND042(cannot find typename context.Context)"
;;   {:added "1.0"
;;    :go "withClientTrace(ABEND904(custom-runtime routine not implemented: context.Context(_ctx)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfClientTrace(_trace)))"}
;;   [^Context _ctx, ^Object _trace])

JOKER FUNC net/http/httputil.DumpRequest:
;; (defn DumpRequest
;;   "DumpRequest returns the given request in its HTTP/1.x wire\nrepresentation. It should only be used by servers to debug client\nrequests. The returned representation is an approximation only;\nsome details of the initial request are lost while parsing it into\nan http.Request. In particular, the order and case of header field\nnames are lost. The order of values in multi-valued headers is kept\nintact. HTTP/2 requests are dumped in HTTP/1.x form, not in their\noriginal binary representations.\n\nIf body is true, DumpRequest also returns the body. To do so, it\nconsumes req.Body and then replaces it with a new io.ReadCloser\nthat yields the same bytes. If DumpRequest returns an error,\nthe state of req is undefined.\n\nThe documentation for http.Request.Write details which fields\nof req are included in the dump.\n\nGo input arguments: (req **ABEND884(unrecognized type Request at: _tests/big/src/net/http/httputil/dump.go:191:28), body bool)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^(atom-of Request) req, ^Bool body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "dumpRequest(ConvertToIndirectOfRequest(ABEND904(custom-runtime routine not implemented: http.Request(_req))), _body)"}
;;   [^Object _req, ^Bool _body])

JOKER FUNC net/http/httputil.DumpRequestOut:
;; (defn DumpRequestOut
;;   "DumpRequestOut is like DumpRequest but for outgoing client requests. It\nincludes any headers that the standard http.Transport adds, such as\nUser-Agent.\n\nGo input arguments: (req **ABEND884(unrecognized type Request at: _tests/big/src/net/http/httputil/dump.go:66:31), body bool)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^(atom-of Request) req, ^Bool body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "dumpRequestOut(ConvertToIndirectOfRequest(ABEND904(custom-runtime routine not implemented: http.Request(_req))), _body)"}
;;   [^Object _req, ^Bool _body])

JOKER FUNC net/http/httputil.DumpResponse:
;; (defn DumpResponse
;;   "DumpResponse is like DumpRequest but dumps a response.\n\nGo input arguments: (resp **ABEND884(unrecognized type Response at: _tests/big/src/net/http/httputil/dump.go:281:30), body bool)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^(atom-of Response) resp, ^Bool body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "dumpResponse(ConvertToIndirectOfResponse(ABEND904(custom-runtime routine not implemented: http.Response(_resp))), _body)"}
;;   [^Object _resp, ^Bool _body])

JOKER FUNC net/http/httputil.NewChunkedReader:
;; (defn NewChunkedReader
;;   "NewChunkedReader returns a new chunkedReader that translates the data read from r\nout of HTTP \"chunked\" format before returning it.\nThe chunkedReader returns io.EOF when the final 0-length chunk is read.\n\nNewChunkedReader is not needed by normal applications. The http package\nautomatically decodes chunking when reading response bodies.\n\nGo input arguments: (r *ABEND884(unrecognized type Reader at: _tests/big/src/net/http/httputil/httputil.go:20:28))\n\nGo return type: ...\n\nJoker input arguments: [^Reader r]\n\nJoker return type: ABEND042(cannot find typename io.Reader)"
;;   {:added "1.0"
;;    :go "newChunkedReader(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^Reader _r])

JOKER FUNC net/http/httputil.NewChunkedWriter:
;; (defn NewChunkedWriter
;;   "NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP\n\"chunked\" format before writing them to w. Closing the returned chunkedWriter\nsends the final 0-length chunk that marks the end of the stream but does\nnot send the final CRLF that appears after trailers; trailers and the last\nCRLF must be written separately.\n\nNewChunkedWriter is not needed by normal applications. The http\npackage adds chunking automatically if handlers don't set a\nContent-Length header. Using NewChunkedWriter inside a handler\nwould result in double chunking or chunking with a Content-Length\nlength, both of which are wrong.\n\nGo input arguments: (w *ABEND884(unrecognized type Writer at: _tests/big/src/net/http/httputil/httputil.go:35:28))\n\nGo return type: ...\n\nJoker input arguments: [^Writer w]\n\nJoker return type: ABEND042(cannot find typename io.WriteCloser)"
;;   {:added "1.0"
;;    :go "newChunkedWriter(ABEND904(custom-runtime routine not implemented: io.Writer(_w)))"}
;;   [^Writer _w])

JOKER FUNC net/http/httputil.NewClientConn:
;; (defn NewClientConn
;;   "NewClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo input arguments: (c *ABEND884(unrecognized type Conn at: _tests/big/src/net/http/httputil/persist.go:248:26), r **ABEND884(unrecognized type Reader at: _tests/big/src/net/http/httputil/persist.go:248:41))\n\nGo return type: *ClientConn\n\nJoker input arguments: [^Conn c, ^(atom-of Reader) r]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newClientConn(ABEND904(custom-runtime routine not implemented: net.Conn(_c)), ConvertToIndirectOfReader(ABEND904(custom-runtime routine not implemented: bufio.Reader(_r)))))"}
;;   [^Conn _c, ^Object _r])

JOKER FUNC net/http/httputil.NewProxyClientConn:
;; (defn NewProxyClientConn
;;   "NewProxyClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo input arguments: (c *ABEND884(unrecognized type Conn at: _tests/big/src/net/http/httputil/persist.go:265:31), r **ABEND884(unrecognized type Reader at: _tests/big/src/net/http/httputil/persist.go:265:46))\n\nGo return type: *ClientConn\n\nJoker input arguments: [^Conn c, ^(atom-of Reader) r]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newProxyClientConn(ABEND904(custom-runtime routine not implemented: net.Conn(_c)), ConvertToIndirectOfReader(ABEND904(custom-runtime routine not implemented: bufio.Reader(_r)))))"}
;;   [^Conn _c, ^Object _r])

JOKER FUNC net/http/httputil.NewServerConn:
;; (defn NewServerConn
;;   "NewServerConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Server in package net/http instead.\n\nGo input arguments: (c *ABEND884(unrecognized type Conn at: _tests/big/src/net/http/httputil/persist.go:54:26), r **ABEND884(unrecognized type Reader at: _tests/big/src/net/http/httputil/persist.go:54:41))\n\nGo return type: *ServerConn\n\nJoker input arguments: [^Conn c, ^(atom-of Reader) r]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newServerConn(ABEND904(custom-runtime routine not implemented: net.Conn(_c)), ConvertToIndirectOfReader(ABEND904(custom-runtime routine not implemented: bufio.Reader(_r)))))"}
;;   [^Conn _c, ^Object _r])

JOKER FUNC net/http/httputil.NewSingleHostReverseProxy:
;; (defn NewSingleHostReverseProxy
;;   "NewSingleHostReverseProxy returns a new ReverseProxy that routes\nURLs to the scheme, host, and base path provided in target. If the\ntarget's path is \"/base\" and the incoming request was for \"/dir\",\nthe target request will be for /base/dir.\nNewSingleHostReverseProxy does not rewrite the Host header.\nTo rewrite Host headers, use ReverseProxy directly with a custom\nDirector policy.\n\nGo input arguments: (target **ABEND884(unrecognized type URL at: _tests/big/src/net/http/httputil/reverseproxy.go:103:44))\n\nGo return type: *ReverseProxy\n\nJoker input arguments: [^(atom-of URL) target]\n\nJoker return type: {:Director ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/httputil/reverseproxy.go:35:11), :Transport ^ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/http/client.go:115:19), :FlushInterval ^ABEND042(cannot find typename time.Duration), :ErrorLog ^ABEND042(cannot find typename log.Logger), :BufferPool ^ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/http/httputil/reverseproxy.go:79:17), :ModifyResponse ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/httputil/reverseproxy.go:67:17), :ErrorHandler ^ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/httputil/reverseproxy.go:74:15)}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newSingleHostReverseProxy(ConvertToIndirectOfURL(ABEND904(custom-runtime routine not implemented: url.URL(_target)))))"}
;;   [^Object _target])

JOKER FUNC net/http/pprof.Cmdline:
;; (defn Cmdline
;;   "Cmdline responds with the running program's\ncommand line, with arguments separated by NUL bytes.\nThe package initialization registers it as /debug/pprof/cmdline.\n\nGo input arguments: (w *ABEND884(unrecognized type ResponseWriter at: _tests/big/src/net/http/pprof/pprof.go:83:21), r **ABEND884(unrecognized type Request at: _tests/big/src/net/http/pprof/pprof.go:83:45))\n\nJoker input arguments: [^ResponseWriter w, ^(atom-of Request) r]"
;;   {:added "1.0"
;;    :go "cmdline(ABEND904(custom-runtime routine not implemented: http.ResponseWriter(_w)), ConvertToIndirectOfRequest(ABEND904(custom-runtime routine not implemented: http.Request(_r))))"}
;;   [^ResponseWriter _w, ^Object _r])

JOKER FUNC net/http/pprof.Handler:
;; (defn Handler
;;   "Handler returns an HTTP handler that serves the named profile.\n\nGo input arguments: (name string)\n\nGo return type: ...\n\nJoker input arguments: [^String name]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "handler(_name)"}
;;   [^String _name])

JOKER FUNC net/http/pprof.Index:
;; (defn Index
;;   "Index responds with the pprof-formatted profile named by the request.\nFor example, \"/debug/pprof/heap\" serves the \"heap\" profile.\nIndex responds to a request for \"/debug/pprof/\" with an HTML page\nlisting the available profiles.\n\nGo input arguments: (w *ABEND884(unrecognized type ResponseWriter at: _tests/big/src/net/http/pprof/pprof.go:264:19), r **ABEND884(unrecognized type Request at: _tests/big/src/net/http/pprof/pprof.go:264:43))\n\nJoker input arguments: [^ResponseWriter w, ^(atom-of Request) r]"
;;   {:added "1.0"
;;    :go "index(ABEND904(custom-runtime routine not implemented: http.ResponseWriter(_w)), ConvertToIndirectOfRequest(ABEND904(custom-runtime routine not implemented: http.Request(_r))))"}
;;   [^ResponseWriter _w, ^Object _r])

JOKER FUNC net/http/pprof.Profile:
;; (defn Profile
;;   "Profile responds with the pprof-formatted cpu profile.\nProfiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.\nThe package initialization registers it as /debug/pprof/profile.\n\nGo input arguments: (w *ABEND884(unrecognized type ResponseWriter at: _tests/big/src/net/http/pprof/pprof.go:116:21), r **ABEND884(unrecognized type Request at: _tests/big/src/net/http/pprof/pprof.go:116:45))\n\nJoker input arguments: [^ResponseWriter w, ^(atom-of Request) r]"
;;   {:added "1.0"
;;    :go "profile(ABEND904(custom-runtime routine not implemented: http.ResponseWriter(_w)), ConvertToIndirectOfRequest(ABEND904(custom-runtime routine not implemented: http.Request(_r))))"}
;;   [^ResponseWriter _w, ^Object _r])

JOKER FUNC net/http/pprof.Symbol:
;; (defn Symbol
;;   "Symbol looks up the program counters listed in the request,\nresponding with a table mapping program counters to function names.\nThe package initialization registers it as /debug/pprof/symbol.\n\nGo input arguments: (w *ABEND884(unrecognized type ResponseWriter at: _tests/big/src/net/http/pprof/pprof.go:174:20), r **ABEND884(unrecognized type Request at: _tests/big/src/net/http/pprof/pprof.go:174:44))\n\nJoker input arguments: [^ResponseWriter w, ^(atom-of Request) r]"
;;   {:added "1.0"
;;    :go "symbol(ABEND904(custom-runtime routine not implemented: http.ResponseWriter(_w)), ConvertToIndirectOfRequest(ABEND904(custom-runtime routine not implemented: http.Request(_r))))"}
;;   [^ResponseWriter _w, ^Object _r])

JOKER FUNC net/http/pprof.Trace:
;; (defn Trace
;;   "Trace responds with the execution trace in binary form.\nTracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.\nThe package initialization registers it as /debug/pprof/trace.\n\nGo input arguments: (w *ABEND884(unrecognized type ResponseWriter at: _tests/big/src/net/http/pprof/pprof.go:145:19), r **ABEND884(unrecognized type Request at: _tests/big/src/net/http/pprof/pprof.go:145:43))\n\nJoker input arguments: [^ResponseWriter w, ^(atom-of Request) r]"
;;   {:added "1.0"
;;    :go "trace(ABEND904(custom-runtime routine not implemented: http.ResponseWriter(_w)), ConvertToIndirectOfRequest(ABEND904(custom-runtime routine not implemented: http.Request(_r))))"}
;;   [^ResponseWriter _w, ^Object _r])

JOKER FUNC net/mail.ParseAddress:
(defn ParseAddress
  "Parses a single RFC 5322 address, e.g. \"Barry Gibbs <bg@example.com>\"\n\nGo input arguments: (address string)\n\nGo return type: (*Address, error)\n\nJoker input arguments: [^String address]\n\nJoker return type: [{:Name ^String, :Address ^String} Error]"
  {:added "1.0"
   :go "parseAddress(_address)"}
  [^String _address])

JOKER FUNC net/mail.ParseAddressList:
(defn ParseAddressList
  "ParseAddressList parses the given string as a list of addresses.\n\nGo input arguments: (list string)\n\nGo return type: ([]*Address, error)\n\nJoker input arguments: [^String list]\n\nJoker return type: [(vector-of {:Name ^String, :Address ^String}) Error]"
  {:added "1.0"
   :go "parseAddressList(_list)"}
  [^String _list])

JOKER FUNC net/mail.ParseDate:
;; (defn ParseDate
;;   "ParseDate parses an RFC 5322 date string.\n\nGo input arguments: (date string)\n\nGo return type: (..., error)\n\nJoker input arguments: [^String date]\n\nJoker return type: [ABEND042(cannot find typename time.Time) Error]"
;;   {:added "1.0"
;;    :go "parseDate(_date)"}
;;   [^String _date])

JOKER FUNC net/mail.ReadMessage:
;; (defn ReadMessage
;;   "ReadMessage reads a message from r.\nThe headers are parsed, and the body of the message will be available\nfor reading from msg.Body.\n\nGo input arguments: (r *ABEND884(unrecognized type Reader at: _tests/big/src/net/mail/message.go:52:23))\n\nGo return type: (msg *Message, err error)\n\nJoker input arguments: [^Reader r]\n\nJoker return type: [{:Header ^ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/mail/message.go:106:13), :Body ^ABEND042(cannot find typename io.Reader)} Error]"
;;   {:added "1.0"
;;    :go "readMessage(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^Reader _r])

JOKER FUNC net/rpc.Accept:
;; (defn Accept
;;   "Accept accepts connections on the listener and serves requests\nto DefaultServer for each incoming connection.\nAccept blocks; the caller typically invokes it in a go statement.\n\nGo input arguments: (lis *ABEND884(unrecognized type Listener at: _tests/big/src/net/rpc/server.go:692:21))\n\nJoker input arguments: [^Listener lis]"
;;   {:added "1.0"
;;    :go "accept(ABEND904(custom-runtime routine not implemented: net.Listener(_lis)))"}
;;   [^Listener _lis])

JOKER FUNC net/rpc.Dial:
(defn Dial
  "Dial connects to an RPC server at the specified network address.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "dial(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net/rpc.DialHTTP:
(defn DialHTTP
  "DialHTTP connects to an HTTP RPC server at the specified network address\nlistening on the default HTTP RPC path.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "dialHTTP(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net/rpc.DialHTTPPath:
(defn DialHTTPPath
  "DialHTTPPath connects to an HTTP RPC server\nat the specified network address and path.\n\nGo input arguments: (network string, address string, path string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address, ^String path]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "dialHTTPPath(_network, _address, _path)"}
  [^String _network, ^String _address, ^String _path])

JOKER FUNC net/rpc.HandleHTTP:
;; (defn HandleHTTP
;;   "HandleHTTP registers an HTTP handler for RPC messages to DefaultServer\non DefaultRPCPath and a debugging handler on DefaultDebugPath.\nIt is still necessary to invoke http.Serve(), typically in a go statement.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "handleHTTP()"}
;;   [])

JOKER FUNC net/rpc.NewClient:
;; (defn NewClient
;;   "NewClient returns a new Client to handle requests to the\nset of services at the other end of the connection.\nIt adds a buffer to the write side of the connection so\nthe header and payload are sent as a unit.\n\nThe read and write halves of the connection are serialized independently,\nso no interlocking is required. However each half may be accessed\nconcurrently so the implementation of conn should protect against\nconcurrent reads or concurrent writes.\n\nGo input arguments: (conn *ABEND884(unrecognized type ReadWriteCloser at: _tests/big/src/net/rpc/client.go:193:24))\n\nGo return type: *Client\n\nJoker input arguments: [^ReadWriteCloser conn]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newClient(ABEND904(custom-runtime routine not implemented: io.ReadWriteCloser(_conn))))"}
;;   [^ReadWriteCloser _conn])

JOKER FUNC net/rpc.NewClientWithCodec:
;; (defn NewClientWithCodec
;;   "NewClientWithCodec is like NewClient but uses the specified\ncodec to encode requests and decode responses.\n\nGo input arguments: (codec ClientCodec)\n\nGo return type: *Client\n\nJoker input arguments: [^ClientCodec codec]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newClientWithCodec(_codec))"}
;;   [^ClientCodec _codec])

JOKER FUNC net/rpc.NewServer:
;; (defn NewServer
;;   "NewServer returns a new Server.\n\nGo return type: *Server\n\nJoker input arguments: []\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newServer())"}
;;   [])

JOKER FUNC net/rpc.Register:
;; (defn ^"Error" Register
;;   "Register publishes the receiver's methods in the DefaultServer.\n\nGo input arguments: (rcvr interface {})\n\nGo return type: error\n\nJoker input arguments: [^<protocol-or-something> rcvr]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.Register(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _rcvr])

JOKER FUNC net/rpc.RegisterName:
;; (defn ^"Error" RegisterName
;;   "RegisterName is like Register but uses the provided name for the type\ninstead of the receiver's concrete type.\n\nGo input arguments: (name string, rcvr interface {})\n\nGo return type: error\n\nJoker input arguments: [^String name, ^<protocol-or-something> rcvr]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.RegisterName(_name, ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^String _name, ^<protocol-or-something> _rcvr])

JOKER FUNC net/rpc.ServeCodec:
;; (defn ServeCodec
;;   "ServeCodec is like ServeConn but uses the specified codec to\ndecode requests and encode responses.\n\nGo input arguments: (codec ServerCodec)\n\nJoker input arguments: [^ServerCodec codec]"
;;   {:added "1.0"
;;    :go "serveCodec(_codec)"}
;;   [^ServerCodec _codec])

JOKER FUNC net/rpc.ServeConn:
;; (defn ServeConn
;;   "ServeConn runs the DefaultServer on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\nServeConn uses the gob wire format (see package gob) on the\nconnection. To use an alternate codec, use ServeCodec.\nSee NewClient's comment for information about concurrent access.\n\nGo input arguments: (conn *ABEND884(unrecognized type ReadWriteCloser at: _tests/big/src/net/rpc/server.go:673:24))\n\nJoker input arguments: [^ReadWriteCloser conn]"
;;   {:added "1.0"
;;    :go "serveConn(ABEND904(custom-runtime routine not implemented: io.ReadWriteCloser(_conn)))"}
;;   [^ReadWriteCloser _conn])

JOKER FUNC net/rpc.ServeRequest:
(defn ^"Error" ServeRequest
  "ServeRequest is like ServeCodec but synchronously serves a single request.\nIt does not close the codec upon completion.\n\nGo input arguments: (codec ServerCodec)\n\nGo return type: error\n\nJoker input arguments: [^ServerCodec codec]\n\nJoker return type: Error"
  {:added "1.0"
   :go "rpc.ServeRequest(_codec)"}
  [^ServerCodec _codec])

JOKER FUNC net/rpc/jsonrpc.Dial:
(defn Dial
  "Dial connects to a JSON-RPC server at the specified network address.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*struct {}, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "dial(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net/rpc/jsonrpc.NewClient:
;; (defn NewClient
;;   "NewClient returns a new rpc.Client to handle requests to the\nset of services at the other end of the connection.\n\nGo input arguments: (conn *ABEND884(unrecognized type ReadWriteCloser at: _tests/big/src/net/rpc/jsonrpc/client.go:113:24))\n\nGo return type: *struct {}\n\nJoker input arguments: [^ReadWriteCloser conn]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newClient(ABEND904(custom-runtime routine not implemented: io.ReadWriteCloser(_conn))))"}
;;   [^ReadWriteCloser _conn])

JOKER FUNC net/rpc/jsonrpc.NewClientCodec:
;; (defn NewClientCodec
;;   "NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn.\n\nGo input arguments: (conn *ABEND884(unrecognized type ReadWriteCloser at: _tests/big/src/net/rpc/jsonrpc/client.go:37:29))\n\nGo return type: ...\n\nJoker input arguments: [^ReadWriteCloser conn]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/rpc/client.go:63:18)"
;;   {:added "1.0"
;;    :go "newClientCodec(ABEND904(custom-runtime routine not implemented: io.ReadWriteCloser(_conn)))"}
;;   [^ReadWriteCloser _conn])

JOKER FUNC net/rpc/jsonrpc.NewServerCodec:
;; (defn NewServerCodec
;;   "NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn.\n\nGo input arguments: (conn *ABEND884(unrecognized type ReadWriteCloser at: _tests/big/src/net/rpc/jsonrpc/server.go:37:29))\n\nGo return type: ...\n\nJoker input arguments: [^ReadWriteCloser conn]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/rpc/server.go:658:18)"
;;   {:added "1.0"
;;    :go "newServerCodec(ABEND904(custom-runtime routine not implemented: io.ReadWriteCloser(_conn)))"}
;;   [^ReadWriteCloser _conn])

JOKER FUNC net/rpc/jsonrpc.ServeConn:
;; (defn ServeConn
;;   "ServeConn runs the JSON-RPC server on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\n\nGo input arguments: (conn *ABEND884(unrecognized type ReadWriteCloser at: _tests/big/src/net/rpc/jsonrpc/server.go:132:24))\n\nJoker input arguments: [^ReadWriteCloser conn]"
;;   {:added "1.0"
;;    :go "serveConn(ABEND904(custom-runtime routine not implemented: io.ReadWriteCloser(_conn)))"}
;;   [^ReadWriteCloser _conn])

JOKER FUNC net/smtp.CRAMMD5Auth:
;; (defn CRAMMD5Auth
;;   "CRAMMD5Auth returns an Auth that implements the CRAM-MD5 authentication\nmechanism as defined in RFC 2195.\nThe returned Auth uses the given username and secret to authenticate\nto the server using the challenge-response mechanism.\n\nGo input arguments: (username string, secret string)\n\nGo return type: Auth\n\nJoker input arguments: [^String username, ^String secret]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/smtp/auth.go:15:11)"
;;   {:added "1.0"
;;    :go "cRAMMD5Auth(_username, _secret)"}
;;   [^String _username, ^String _secret])

JOKER FUNC net/smtp.Dial:
(defn Dial
  "Dial returns a new Client connected to an SMTP server at addr.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nGo input arguments: (addr string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String addr]\n\nJoker return type: [{:Text ^{}} Error]"
  {:added "1.0"
   :go "dial(_addr)"}
  [^String _addr])

JOKER FUNC net/smtp.NewClient:
;; (defn NewClient
;;   "NewClient returns a new Client using an existing connection and host as a\nserver name to be used when authenticating.\n\nGo input arguments: (conn *ABEND884(unrecognized type Conn at: _tests/big/src/net/smtp/smtp.go:62:25), host string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^Conn conn, ^String host]\n\nJoker return type: [{:Text ^{}} Error]"
;;   {:added "1.0"
;;    :go "newClient(ABEND904(custom-runtime routine not implemented: net.Conn(_conn)), _host)"}
;;   [^Conn _conn, ^String _host])

JOKER FUNC net/smtp.PlainAuth:
;; (defn PlainAuth
;;   "PlainAuth returns an Auth that implements the PLAIN authentication\nmechanism as defined in RFC 4616. The returned Auth uses the given\nusername and password to authenticate to host and act as identity.\nUsually identity should be the empty string, to act as username.\n\nPlainAuth will only send the credentials if the connection is using TLS\nor is connected to localhost. Otherwise authentication will fail with an\nerror, without sending the credentials.\n\nGo input arguments: (identity string, username string, password string, host string)\n\nGo return type: Auth\n\nJoker input arguments: [^String identity, ^String username, ^String password, ^String host]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: _tests/big/src/net/smtp/auth.go:15:11)"
;;   {:added "1.0"
;;    :go "plainAuth(_identity, _username, _password, _host)"}
;;   [^String _identity, ^String _username, ^String _password, ^String _host])

JOKER FUNC net/smtp.SendMail:
(defn ^"Error" SendMail
  "SendMail connects to the server at addr, switches to TLS if\npossible, authenticates with the optional mechanism a if possible,\nand then sends an email from address from, to addresses to, with\nmessage msg.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nThe addresses in the to parameter are the SMTP RCPT addresses.\n\nThe msg parameter should be an RFC 822-style email with headers\nfirst, a blank line, and then the message body. The lines of msg\nshould be CRLF terminated. The msg headers should usually include\nfields such as \"From\", \"To\", \"Subject\", and \"Cc\".  Sending \"Bcc\"\nmessages is accomplished by including an email address in the to\nparameter but not including it in the msg headers.\n\nThe SendMail function and the net/smtp package are low-level\nmechanisms and provide no support for DKIM signing, MIME\nattachments (see the mime/multipart package), or other mail\nfunctionality. Higher-level packages exist outside of the standard\nlibrary.\n\nGo input arguments: (addr string, a Auth, from string, to []string, msg []byte)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^Auth a, ^String from, ^(vector-of String) to, ^(vector-of Byte) msg]\n\nJoker return type: Error"
  {:added "1.0"
   :go "smtp.SendMail(_addr, _a, _from, ConvertToArrayOfString(_to), ConvertToArrayOfByte(_msg))"}
  [^String _addr, ^Auth _a, ^String _from, ^Object _to, ^Object _msg])

JOKER FUNC net/textproto.CanonicalMIMEHeaderKey:
(defn ^"String" CanonicalMIMEHeaderKey
  "CanonicalMIMEHeaderKey returns the canonical format of the\nMIME header key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nMIME header keys are assumed to be ASCII only.\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "textproto.CanonicalMIMEHeaderKey(_s)"}
  [^String _s])

JOKER FUNC net/textproto.Dial:
(defn Dial
  "Dial connects to the given address on the given network using net.Dial\nand then returns a new Conn for the connection.\n\nGo input arguments: (network string, addr string)\n\nGo return type: (*Conn, error)\n\nJoker input arguments: [^String network, ^String addr]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "dial(_network, _addr)"}
  [^String _network, ^String _addr])

JOKER FUNC net/textproto.NewConn:
;; (defn NewConn
;;   "NewConn returns a new Conn using conn for I/O.\n\nGo input arguments: (conn *ABEND884(unrecognized type ReadWriteCloser at: _tests/big/src/net/textproto/textproto.go:66:22))\n\nGo return type: *Conn\n\nJoker input arguments: [^ReadWriteCloser conn]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newConn(ABEND904(custom-runtime routine not implemented: io.ReadWriteCloser(_conn))))"}
;;   [^ReadWriteCloser _conn])

JOKER FUNC net/textproto.NewReader:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from r.\n\nTo avoid denial of service attacks, the provided bufio.Reader\nshould be reading from an io.LimitReader or similar Reader to bound\nthe size of responses.\n\nGo input arguments: (r **ABEND884(unrecognized type Reader at: _tests/big/src/net/textproto/reader.go:29:25))\n\nGo return type: *Reader\n\nJoker input arguments: [^(atom-of Reader) r]\n\nJoker return type: {:R ^ABEND042(cannot find typename bufio.Reader)}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newReader(ConvertToIndirectOfReader(ABEND904(custom-runtime routine not implemented: bufio.Reader(_r)))))"}
;;   [^Object _r])

JOKER FUNC net/textproto.NewWriter:
;; (defn NewWriter
;;   "NewWriter returns a new Writer writing to w.\n\nGo input arguments: (w **ABEND884(unrecognized type Writer at: _tests/big/src/net/textproto/writer.go:21:25))\n\nGo return type: *Writer\n\nJoker input arguments: [^(atom-of Writer) w]\n\nJoker return type: {:W ^ABEND042(cannot find typename bufio.Writer)}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newWriter(ConvertToIndirectOfWriter(ABEND904(custom-runtime routine not implemented: bufio.Writer(_w)))))"}
;;   [^Object _w])

JOKER FUNC net/textproto.TrimBytes:
(defn TrimBytes
  "TrimBytes returns b without leading and trailing ASCII space.\n\nGo input arguments: (b []byte)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "trimBytes(ConvertToArrayOfByte(_b))"}
  [^Object _b])

JOKER FUNC net/textproto.TrimString:
(defn ^"String" TrimString
  "TrimString returns s without leading and trailing ASCII space.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "textproto.TrimString(_s)"}
  [^String _s])

JOKER FUNC net/url.Parse:
(defn Parse
  "Parse parses rawurl into a URL structure.\n\nThe rawurl may be relative (a path, without a host) or absolute\n(starting with a scheme). Trying to parse a hostname and path\nwithout a scheme is invalid but may not necessarily return an\nerror, due to parsing ambiguities.\n\nGo input arguments: (rawurl string)\n\nGo return type: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker return type: [{:Scheme ^String, :Opaque ^String, :User ^{}, :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String} Error]"
  {:added "1.0"
   :go "parse(_rawurl)"}
  [^String _rawurl])

JOKER FUNC net/url.ParseQuery:
;; (defn ParseQuery
;;   "ParseQuery parses the URL-encoded query string and returns\na map listing the values specified for each key.\nParseQuery always returns a non-nil map containing all the\nvalid query parameters found; err describes the first decoding error\nencountered, if any.\n\nQuery is expected to be a list of key=value settings separated by\nampersands or semicolons. A setting without an equals sign is\ninterpreted as a key set to an empty value.\n\nGo input arguments: (query string)\n\nGo return type: (Values, error)\n\nJoker input arguments: [^String query]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/url/url.go:804:13) Error]"
;;   {:added "1.0"
;;    :go "parseQuery(_query)"}
;;   [^String _query])

JOKER FUNC net/url.ParseRequestURI:
(defn ParseRequestURI
  "ParseRequestURI parses rawurl into a URL structure. It assumes that\nrawurl was received in an HTTP request, so the rawurl is interpreted\nonly as an absolute URI or an absolute path.\nThe string rawurl is assumed not to have a #fragment suffix.\n(Web browsers strip #fragment before sending the URL to a web server.)\n\nGo input arguments: (rawurl string)\n\nGo return type: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker return type: [{:Scheme ^String, :Opaque ^String, :User ^{}, :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String} Error]"
  {:added "1.0"
   :go "parseRequestURI(_rawurl)"}
  [^String _rawurl])

JOKER FUNC net/url.PathEscape:
(defn ^"String" PathEscape
  "PathEscape escapes the string so it can be safely placed\ninside a URL path segment.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "url.PathEscape(_s)"}
  [^String _s])

JOKER FUNC net/url.PathUnescape:
(defn PathUnescape
  "PathUnescape does the inverse transformation of PathEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB. It returns an error if any % is not followed\nby two hexadecimal digits.\n\nPathUnescape is identical to QueryUnescape except that it does not\nunescape '+' to ' ' (space).\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "pathUnescape(_s)"}
  [^String _s])

JOKER FUNC net/url.QueryEscape:
(defn ^"String" QueryEscape
  "QueryEscape escapes the string so it can be safely placed\ninside a URL query.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "url.QueryEscape(_s)"}
  [^String _s])

JOKER FUNC net/url.QueryUnescape:
(defn QueryUnescape
  "QueryUnescape does the inverse transformation of QueryEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB.\nIt returns an error if any % is not followed by two hexadecimal\ndigits.\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "queryUnescape(_s)"}
  [^String _s])

JOKER FUNC net/url.User:
;; (defn User
;;   "User returns a Userinfo containing the provided username\nand no password set.\n\nGo input arguments: (username string)\n\nGo return type: *Userinfo\n\nJoker input arguments: [^String username]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: user(_username))"}
;;   [^String _username])

JOKER FUNC net/url.UserPassword:
;; (defn UserPassword
;;   "UserPassword returns a Userinfo containing the provided username\nand password.\n\nThis functionality should only be used with legacy web sites.\nRFC 2396 warns that interpreting Userinfo this way\n``is NOT RECOMMENDED, because the passing of authentication\ninformation in clear text (such as URI) has proven to be a\nsecurity risk in almost every case where it has been used.''\n\nGo input arguments: (username string, password string)\n\nGo return type: *Userinfo\n\nJoker input arguments: [^String username, ^String password]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: userPassword(_username, _password))"}
;;   [^String _username, ^String _password])

GO FUNC net.CIDRMask:
func cIDRMask(ones int, bits int) Object {
	_res := _net.CIDRMask(ones, bits)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC net.Dial:
// func dial(network string, address string) Object {
// 	_res1, _res2 := _net.Dial(network, address)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialIP:
// func dialIP(network string, laddr *ABEND884(unrecognized type IPAddr at: _tests/big/src/net/iprawsock.go:211:43), raddr *ABEND884(unrecognized type IPAddr at: _tests/big/src/net/iprawsock.go:211:43)) Object {
// 	_, _res2 := _net.DialIP(network, laddr, raddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialTCP:
// func dialTCP(network string, laddr *ABEND884(unrecognized type TCPAddr at: _tests/big/src/net/tcpsock.go:206:44), raddr *ABEND884(unrecognized type TCPAddr at: _tests/big/src/net/tcpsock.go:206:44)) Object {
// 	_, _res2 := _net.DialTCP(network, laddr, raddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialTimeout:
// func dialTimeout(network string, address string, timeout *ABEND884(unrecognized type Duration at: _tests/big/src/net/dial.go:313:56)) Object {
// 	_res1, _res2 := _net.DialTimeout(network, address, timeout)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialUDP:
// func dialUDP(network string, laddr *ABEND884(unrecognized type UDPAddr at: _tests/big/src/net/udpsock.go:205:44), raddr *ABEND884(unrecognized type UDPAddr at: _tests/big/src/net/udpsock.go:205:44)) Object {
// 	_, _res2 := _net.DialUDP(network, laddr, raddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialUnix:
// func dialUnix(network string, laddr *ABEND884(unrecognized type UnixAddr at: _tests/big/src/net/unixsock.go:200:45), raddr *ABEND884(unrecognized type UnixAddr at: _tests/big/src/net/unixsock.go:200:45)) Object {
// 	_, _res2 := _net.DialUnix(network, laddr, raddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.FileConn:
// func fileConn(f **ABEND884(unrecognized type File at: _tests/big/src/net/file.go:21:21)) Object {
// 	c, err := _net.FileConn(f)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(c)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.FileListener:
// func fileListener(f **ABEND884(unrecognized type File at: _tests/big/src/net/file.go:33:25)) Object {
// 	ln, err := _net.FileListener(f)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ln)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.FilePacketConn:
// func filePacketConn(f **ABEND884(unrecognized type File at: _tests/big/src/net/file.go:45:27)) Object {
// 	c, err := _net.FilePacketConn(f)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(c)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.IPv4:
func iPv4(a byte, b byte, c byte, d byte) Object {
	_res := _net.IPv4(a, b, c, d)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC net.IPv4Mask:
func iPv4Mask(a byte, b byte, c byte, d byte) Object {
	_res := _net.IPv4Mask(a, b, c, d)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC net.InterfaceAddrs:
// func interfaceAddrs() Object {
// 	_res1, _res2 := _net.InterfaceAddrs()
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(_elem1)
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.InterfaceByIndex:
func interfaceByIndex(index int) Object {
	_res1, _res2 := _net.InterfaceByIndex(index)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map1.Add(MakeKeyword("Index"), MakeInt((*_res1).Index))
		_map1.Add(MakeKeyword("MTU"), MakeInt((*_res1).MTU))
		_map1.Add(MakeKeyword("Name"), MakeString((*_res1).Name))
		_vec2 := EmptyVector
		for _, _elem2 := range (*_res1).HardwareAddr {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_map1.Add(MakeKeyword("HardwareAddr"), _vec2)
		_map1.Add(MakeKeyword("Flags"), MakeInt(int((*_res1).Flags)))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.InterfaceByName:
func interfaceByName(name string) Object {
	_res1, _res2 := _net.InterfaceByName(name)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map1.Add(MakeKeyword("Index"), MakeInt((*_res1).Index))
		_map1.Add(MakeKeyword("MTU"), MakeInt((*_res1).MTU))
		_map1.Add(MakeKeyword("Name"), MakeString((*_res1).Name))
		_vec2 := EmptyVector
		for _, _elem2 := range (*_res1).HardwareAddr {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_map1.Add(MakeKeyword("HardwareAddr"), _vec2)
		_map1.Add(MakeKeyword("Flags"), MakeInt(int((*_res1).Flags)))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.Interfaces:
func interfaces() Object {
	_res1, _res2 := _net.Interfaces()
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_map2 := EmptyArrayMap()
		_map2.Add(MakeKeyword("Index"), MakeInt(_elem1.Index))
		_map2.Add(MakeKeyword("MTU"), MakeInt(_elem1.MTU))
		_map2.Add(MakeKeyword("Name"), MakeString(_elem1.Name))
		_vec3 := EmptyVector
		for _, _elem3 := range _elem1.HardwareAddr {
			_vec3 = _vec3.Conjoin(MakeInt(int(_elem3)))
		}
		_map2.Add(MakeKeyword("HardwareAddr"), _vec3)
		_map2.Add(MakeKeyword("Flags"), MakeInt(int(_elem1.Flags)))
		_vec1 = _vec1.Conjoin(_map2)
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.Listen:
// func listen(network string, address string) Object {
// 	_res1, _res2 := _net.Listen(network, address)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenIP:
// func listenIP(network string, laddr *ABEND884(unrecognized type IPAddr at: _tests/big/src/net/iprawsock.go:230:38)) Object {
// 	_, _res2 := _net.ListenIP(network, laddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenMulticastUDP:
// func listenMulticastUDP(network string, ifi *ABEND884(unrecognized type Interface at: _tests/big/src/net/udpsock.go:265:46), gaddr *ABEND884(unrecognized type UDPAddr at: _tests/big/src/net/udpsock.go:265:64)) Object {
// 	_, _res2 := _net.ListenMulticastUDP(network, ifi, gaddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenPacket:
// func listenPacket(network string, address string) Object {
// 	_res1, _res2 := _net.ListenPacket(network, address)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenTCP:
// func listenTCP(network string, laddr *ABEND884(unrecognized type TCPAddr at: _tests/big/src/net/tcpsock.go:323:39)) Object {
// 	_, _res2 := _net.ListenTCP(network, laddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenUDP:
// func listenUDP(network string, laddr *ABEND884(unrecognized type UDPAddr at: _tests/big/src/net/udpsock.go:231:39)) Object {
// 	_, _res2 := _net.ListenUDP(network, laddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenUnix:
// func listenUnix(network string, laddr *ABEND884(unrecognized type UnixAddr at: _tests/big/src/net/unixsock.go:314:40)) Object {
// 	_, _res2 := _net.ListenUnix(network, laddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenUnixgram:
// func listenUnixgram(network string, laddr *ABEND884(unrecognized type UnixAddr at: _tests/big/src/net/unixsock.go:334:44)) Object {
// 	_, _res2 := _net.ListenUnixgram(network, laddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.LookupAddr:
func lookupAddr(addr string) Object {
	names, err := _net.LookupAddr(addr)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range names {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupCNAME:
func lookupCNAME(host string) Object {
	cname, err := _net.LookupCNAME(host)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(cname))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupHost:
func lookupHost(host string) Object {
	addrs, err := _net.LookupHost(host)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range addrs {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupIP:
func lookupIP(host string) Object {
	_res1, _res2 := _net.LookupIP(host)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec2 := EmptyVector
		for _, _elem2 := range _elem1 {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_vec1 = _vec1.Conjoin(_vec2)
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupMX:
func lookupMX(name string) Object {
	_res1, _res2 := _net.LookupMX(name)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		var _obj_map2 Object
		if _elem1 != nil {
			_map2 := EmptyArrayMap()
			_map2.Add(MakeKeyword("Host"), MakeString((*_elem1).Host))
			_map2.Add(MakeKeyword("Pref"), MakeInt(int((*_elem1).Pref)))
			_obj_map2 = Object(_map2)
		} else {
			_obj_map2 = NIL
		}
		_vec1 = _vec1.Conjoin(_obj_map2)
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupNS:
func lookupNS(name string) Object {
	_res1, _res2 := _net.LookupNS(name)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		var _obj_map2 Object
		if _elem1 != nil {
			_map2 := EmptyArrayMap()
			_map2.Add(MakeKeyword("Host"), MakeString((*_elem1).Host))
			_obj_map2 = Object(_map2)
		} else {
			_obj_map2 = NIL
		}
		_vec1 = _vec1.Conjoin(_obj_map2)
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupPort:
func lookupPort(network string, service string) Object {
	port, err := _net.LookupPort(network, service)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(port))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupSRV:
func lookupSRV(service string, proto string, name string) Object {
	cname, addrs, err := _net.LookupSRV(service, proto, name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(cname))
	_vec1 := EmptyVector
	for _, _elem1 := range addrs {
		var _obj_map2 Object
		if _elem1 != nil {
			_map2 := EmptyArrayMap()
			_map2.Add(MakeKeyword("Target"), MakeString((*_elem1).Target))
			_map2.Add(MakeKeyword("Port"), MakeInt(int((*_elem1).Port)))
			_map2.Add(MakeKeyword("Priority"), MakeInt(int((*_elem1).Priority)))
			_map2.Add(MakeKeyword("Weight"), MakeInt(int((*_elem1).Weight)))
			_obj_map2 = Object(_map2)
		} else {
			_obj_map2 = NIL
		}
		_vec1 = _vec1.Conjoin(_obj_map2)
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupTXT:
func lookupTXT(name string) Object {
	_res1, _res2 := _net.LookupTXT(name)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ParseCIDR:
func parseCIDR(s string) Object {
	_res1, _res2, _res3 := _net.ParseCIDR(s)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	var _obj_map2 Object
	if _res2 != nil {
		_map2 := EmptyArrayMap()
		_vec3 := EmptyVector
		for _, _elem3 := range (*_res2).IP {
			_vec3 = _vec3.Conjoin(MakeInt(int(_elem3)))
		}
		_map2.Add(MakeKeyword("IP"), _vec3)
		_vec4 := EmptyVector
		for _, _elem4 := range (*_res2).Mask {
			_vec4 = _vec4.Conjoin(MakeInt(int(_elem4)))
		}
		_map2.Add(MakeKeyword("Mask"), _vec4)
		_obj_map2 = Object(_map2)
	} else {
		_obj_map2 = NIL
	}
	_res = _res.Conjoin(_obj_map2)
	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
	return _res
}

GO FUNC net.ParseIP:
func parseIP(s string) Object {
	_res := _net.ParseIP(s)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC net.ParseMAC:
func parseMAC(s string) Object {
	hw, err := _net.ParseMAC(s)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range hw {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.Pipe:
// func pipe() Object {
// 	_res1, _res2 := _net.Pipe()
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(_res2)
// 	return _res
// }

GO FUNC net.ResolveIPAddr:
func resolveIPAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveIPAddr(network, address)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_vec2 := EmptyVector
		for _, _elem2 := range (*_res1).IP {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_map1.Add(MakeKeyword("IP"), _vec2)
		_map1.Add(MakeKeyword("Zone"), MakeString((*_res1).Zone))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveTCPAddr:
func resolveTCPAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveTCPAddr(network, address)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_vec2 := EmptyVector
		for _, _elem2 := range (*_res1).IP {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_map1.Add(MakeKeyword("IP"), _vec2)
		_map1.Add(MakeKeyword("Port"), MakeInt((*_res1).Port))
		_map1.Add(MakeKeyword("Zone"), MakeString((*_res1).Zone))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveUDPAddr:
func resolveUDPAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveUDPAddr(network, address)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_vec2 := EmptyVector
		for _, _elem2 := range (*_res1).IP {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_map1.Add(MakeKeyword("IP"), _vec2)
		_map1.Add(MakeKeyword("Port"), MakeInt((*_res1).Port))
		_map1.Add(MakeKeyword("Zone"), MakeString((*_res1).Zone))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveUnixAddr:
func resolveUnixAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveUnixAddr(network, address)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map1.Add(MakeKeyword("Name"), MakeString((*_res1).Name))
		_map1.Add(MakeKeyword("Net"), MakeString((*_res1).Net))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.SplitHostPort:
func splitHostPort(hostport string) Object {
	host, port, err := _net.SplitHostPort(hostport)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(host))
	_res = _res.Conjoin(MakeString(port))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.Error:
// func error(w ABEND884(unrecognized type ResponseWriter at: _tests/big/src/net/http/server.go:1973:14), error string, code int) Object {
// 	_http.Error(w, error, code)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.FileServer:
// func fileServer(root ABEND884(unrecognized type FileSystem at: _tests/big/src/net/http/fs.go:713:22)) Object {
// 	return _http.FileServer(root)
// }

GO FUNC net/http.Get:
// func get(url string) Object {
// 	resp, err := _http.Get(url)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if resp != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Status"), MakeString((*resp).Status))
// 		_map1.Add(MakeKeyword("StatusCode"), MakeInt((*resp).StatusCode))
// 		_map1.Add(MakeKeyword("Proto"), MakeString((*resp).Proto))
// 		_map1.Add(MakeKeyword("ProtoMajor"), MakeInt((*resp).ProtoMajor))
// 		_map1.Add(MakeKeyword("ProtoMinor"), MakeInt((*resp).ProtoMinor))
// 		_map1.Add(MakeKeyword("Header"), (*resp).Header)
// 		_map1.Add(MakeKeyword("Body"), (*resp).Body)
// 		_map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*resp).ContentLength)))
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*resp).TransferEncoding {
// 			_vec2 = _vec2.Conjoin(MakeString(_elem2))
// 		}
// 		_map1.Add(MakeKeyword("TransferEncoding"), _vec2)
// 		_map1.Add(MakeKeyword("Close"), MakeBool((*resp).Close))
// 		_map1.Add(MakeKeyword("Uncompressed"), MakeBool((*resp).Uncompressed))
// 		_map1.Add(MakeKeyword("Trailer"), (*resp).Trailer)
// 		var _obj_map3 Object
// 		if (*resp).Request != nil {
// 			_map3 := EmptyArrayMap()
// 			_map3.Add(MakeKeyword("Method"), MakeString((*(*resp).Request).Method))
// 			var _obj_map4 Object
// 			if (*(*resp).Request).URL != nil {
// 				_map4 := EmptyArrayMap()
// 				_map4.Add(MakeKeyword("Scheme"), MakeString((*(*(*resp).Request).URL).Scheme))
// 				_map4.Add(MakeKeyword("Opaque"), MakeString((*(*(*resp).Request).URL).Opaque))
// 				_map4.Add(MakeKeyword("User"), (*(*(*(*resp).Request).URL).User))
// 				_map4.Add(MakeKeyword("Host"), MakeString((*(*(*resp).Request).URL).Host))
// 				_map4.Add(MakeKeyword("Path"), MakeString((*(*(*resp).Request).URL).Path))
// 				_map4.Add(MakeKeyword("RawPath"), MakeString((*(*(*resp).Request).URL).RawPath))
// 				_map4.Add(MakeKeyword("ForceQuery"), MakeBool((*(*(*resp).Request).URL).ForceQuery))
// 				_map4.Add(MakeKeyword("RawQuery"), MakeString((*(*(*resp).Request).URL).RawQuery))
// 				_map4.Add(MakeKeyword("Fragment"), MakeString((*(*(*resp).Request).URL).Fragment))
// 				_obj_map4 = Object(_map4)
// 			} else {
// 				_obj_map4 = NIL
// 			}
// 			_map3.Add(MakeKeyword("URL"), _obj_map4)
// 			_map3.Add(MakeKeyword("Proto"), MakeString((*(*resp).Request).Proto))
// 			_map3.Add(MakeKeyword("ProtoMajor"), MakeInt((*(*resp).Request).ProtoMajor))
// 			_map3.Add(MakeKeyword("ProtoMinor"), MakeInt((*(*resp).Request).ProtoMinor))
// 			_map3.Add(MakeKeyword("Header"), (*(*resp).Request).Header)
// 			_map3.Add(MakeKeyword("Body"), (*(*resp).Request).Body)
// 			_map3.Add(MakeKeyword("GetBody"), (*(*resp).Request).GetBody)
// 			_map3.Add(MakeKeyword("ContentLength"), MakeInt(int((*(*resp).Request).ContentLength)))
// 			_vec5 := EmptyVector
// 			for _, _elem5 := range (*(*resp).Request).TransferEncoding {
// 				_vec5 = _vec5.Conjoin(MakeString(_elem5))
// 			}
// 			_map3.Add(MakeKeyword("TransferEncoding"), _vec5)
// 			_map3.Add(MakeKeyword("Close"), MakeBool((*(*resp).Request).Close))
// 			_map3.Add(MakeKeyword("Host"), MakeString((*(*resp).Request).Host))
// 			_map3.Add(MakeKeyword("Form"), (*(*resp).Request).Form)
// 			_map3.Add(MakeKeyword("PostForm"), (*(*resp).Request).PostForm)
// 			_map3.Add(MakeKeyword("MultipartForm"), (*(*(*resp).Request).MultipartForm))
// 			_map3.Add(MakeKeyword("Trailer"), (*(*resp).Request).Trailer)
// 			_map3.Add(MakeKeyword("RemoteAddr"), MakeString((*(*resp).Request).RemoteAddr))
// 			_map3.Add(MakeKeyword("RequestURI"), MakeString((*(*resp).Request).RequestURI))
// 			_map3.Add(MakeKeyword("TLS"), (*(*(*resp).Request).TLS))
// 			_map3.Add(MakeKeyword("Cancel"), (*(*resp).Request).Cancel)
// 			_map3.Add(MakeKeyword("Response"), )
// 			_obj_map3 = Object(_map3)
// 		} else {
// 			_obj_map3 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Request"), _obj_map3)
// 		_map1.Add(MakeKeyword("TLS"), (*(*resp).TLS))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.Handle:
// func handle(pattern string, handler ABEND884(unrecognized type Handler at: _tests/big/src/net/http/server.go:2401:37)) Object {
// 	_http.Handle(pattern, handler)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.HandleFunc:
// func handleFunc(pattern string, handler func) Object {
// 	_http.HandleFunc(pattern, handler)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.Head:
// func head(url string) Object {
// 	resp, err := _http.Head(url)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if resp != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Status"), MakeString((*resp).Status))
// 		_map1.Add(MakeKeyword("StatusCode"), MakeInt((*resp).StatusCode))
// 		_map1.Add(MakeKeyword("Proto"), MakeString((*resp).Proto))
// 		_map1.Add(MakeKeyword("ProtoMajor"), MakeInt((*resp).ProtoMajor))
// 		_map1.Add(MakeKeyword("ProtoMinor"), MakeInt((*resp).ProtoMinor))
// 		_map1.Add(MakeKeyword("Header"), (*resp).Header)
// 		_map1.Add(MakeKeyword("Body"), (*resp).Body)
// 		_map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*resp).ContentLength)))
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*resp).TransferEncoding {
// 			_vec2 = _vec2.Conjoin(MakeString(_elem2))
// 		}
// 		_map1.Add(MakeKeyword("TransferEncoding"), _vec2)
// 		_map1.Add(MakeKeyword("Close"), MakeBool((*resp).Close))
// 		_map1.Add(MakeKeyword("Uncompressed"), MakeBool((*resp).Uncompressed))
// 		_map1.Add(MakeKeyword("Trailer"), (*resp).Trailer)
// 		var _obj_map3 Object
// 		if (*resp).Request != nil {
// 			_map3 := EmptyArrayMap()
// 			_map3.Add(MakeKeyword("Method"), MakeString((*(*resp).Request).Method))
// 			var _obj_map4 Object
// 			if (*(*resp).Request).URL != nil {
// 				_map4 := EmptyArrayMap()
// 				_map4.Add(MakeKeyword("Scheme"), MakeString((*(*(*resp).Request).URL).Scheme))
// 				_map4.Add(MakeKeyword("Opaque"), MakeString((*(*(*resp).Request).URL).Opaque))
// 				_map4.Add(MakeKeyword("User"), (*(*(*(*resp).Request).URL).User))
// 				_map4.Add(MakeKeyword("Host"), MakeString((*(*(*resp).Request).URL).Host))
// 				_map4.Add(MakeKeyword("Path"), MakeString((*(*(*resp).Request).URL).Path))
// 				_map4.Add(MakeKeyword("RawPath"), MakeString((*(*(*resp).Request).URL).RawPath))
// 				_map4.Add(MakeKeyword("ForceQuery"), MakeBool((*(*(*resp).Request).URL).ForceQuery))
// 				_map4.Add(MakeKeyword("RawQuery"), MakeString((*(*(*resp).Request).URL).RawQuery))
// 				_map4.Add(MakeKeyword("Fragment"), MakeString((*(*(*resp).Request).URL).Fragment))
// 				_obj_map4 = Object(_map4)
// 			} else {
// 				_obj_map4 = NIL
// 			}
// 			_map3.Add(MakeKeyword("URL"), _obj_map4)
// 			_map3.Add(MakeKeyword("Proto"), MakeString((*(*resp).Request).Proto))
// 			_map3.Add(MakeKeyword("ProtoMajor"), MakeInt((*(*resp).Request).ProtoMajor))
// 			_map3.Add(MakeKeyword("ProtoMinor"), MakeInt((*(*resp).Request).ProtoMinor))
// 			_map3.Add(MakeKeyword("Header"), (*(*resp).Request).Header)
// 			_map3.Add(MakeKeyword("Body"), (*(*resp).Request).Body)
// 			_map3.Add(MakeKeyword("GetBody"), (*(*resp).Request).GetBody)
// 			_map3.Add(MakeKeyword("ContentLength"), MakeInt(int((*(*resp).Request).ContentLength)))
// 			_vec5 := EmptyVector
// 			for _, _elem5 := range (*(*resp).Request).TransferEncoding {
// 				_vec5 = _vec5.Conjoin(MakeString(_elem5))
// 			}
// 			_map3.Add(MakeKeyword("TransferEncoding"), _vec5)
// 			_map3.Add(MakeKeyword("Close"), MakeBool((*(*resp).Request).Close))
// 			_map3.Add(MakeKeyword("Host"), MakeString((*(*resp).Request).Host))
// 			_map3.Add(MakeKeyword("Form"), (*(*resp).Request).Form)
// 			_map3.Add(MakeKeyword("PostForm"), (*(*resp).Request).PostForm)
// 			_map3.Add(MakeKeyword("MultipartForm"), (*(*(*resp).Request).MultipartForm))
// 			_map3.Add(MakeKeyword("Trailer"), (*(*resp).Request).Trailer)
// 			_map3.Add(MakeKeyword("RemoteAddr"), MakeString((*(*resp).Request).RemoteAddr))
// 			_map3.Add(MakeKeyword("RequestURI"), MakeString((*(*resp).Request).RequestURI))
// 			_map3.Add(MakeKeyword("TLS"), (*(*(*resp).Request).TLS))
// 			_map3.Add(MakeKeyword("Cancel"), (*(*resp).Request).Cancel)
// 			_map3.Add(MakeKeyword("Response"), )
// 			_obj_map3 = Object(_map3)
// 		} else {
// 			_obj_map3 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Request"), _obj_map3)
// 		_map1.Add(MakeKeyword("TLS"), (*(*resp).TLS))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.MaxBytesReader:
// func maxBytesReader(w ABEND884(unrecognized type ResponseWriter at: _tests/big/src/net/http/request.go:1056:23), r *ABEND884(unrecognized type ReadCloser at: _tests/big/src/net/http/request.go:1056:44), n int64) Object {
// 	return _http.MaxBytesReader(w, r, n)
// }

GO FUNC net/http.NewFileTransport:
// func newFileTransport(fs ABEND884(unrecognized type FileSystem at: _tests/big/src/net/http/filetransport.go:30:26)) Object {
// 	return _http.NewFileTransport(fs)
// }

GO FUNC net/http.NewRequest:
// func newRequest(method string, url string, body *ABEND884(unrecognized type Reader at: _tests/big/src/net/http/request.go:792:45)) Object {
// 	_res1, _res2 := _http.NewRequest(method, url, body)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Method"), MakeString((*_res1).Method))
// 		var _obj_map2 Object
// 		if (*_res1).URL != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Scheme"), MakeString((*(*_res1).URL).Scheme))
// 			_map2.Add(MakeKeyword("Opaque"), MakeString((*(*_res1).URL).Opaque))
// 			_map2.Add(MakeKeyword("User"), (*(*(*_res1).URL).User))
// 			_map2.Add(MakeKeyword("Host"), MakeString((*(*_res1).URL).Host))
// 			_map2.Add(MakeKeyword("Path"), MakeString((*(*_res1).URL).Path))
// 			_map2.Add(MakeKeyword("RawPath"), MakeString((*(*_res1).URL).RawPath))
// 			_map2.Add(MakeKeyword("ForceQuery"), MakeBool((*(*_res1).URL).ForceQuery))
// 			_map2.Add(MakeKeyword("RawQuery"), MakeString((*(*_res1).URL).RawQuery))
// 			_map2.Add(MakeKeyword("Fragment"), MakeString((*(*_res1).URL).Fragment))
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("URL"), _obj_map2)
// 		_map1.Add(MakeKeyword("Proto"), MakeString((*_res1).Proto))
// 		_map1.Add(MakeKeyword("ProtoMajor"), MakeInt((*_res1).ProtoMajor))
// 		_map1.Add(MakeKeyword("ProtoMinor"), MakeInt((*_res1).ProtoMinor))
// 		_map1.Add(MakeKeyword("Header"), (*_res1).Header)
// 		_map1.Add(MakeKeyword("Body"), (*_res1).Body)
// 		_map1.Add(MakeKeyword("GetBody"), (*_res1).GetBody)
// 		_map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*_res1).ContentLength)))
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res1).TransferEncoding {
// 			_vec3 = _vec3.Conjoin(MakeString(_elem3))
// 		}
// 		_map1.Add(MakeKeyword("TransferEncoding"), _vec3)
// 		_map1.Add(MakeKeyword("Close"), MakeBool((*_res1).Close))
// 		_map1.Add(MakeKeyword("Host"), MakeString((*_res1).Host))
// 		_map1.Add(MakeKeyword("Form"), (*_res1).Form)
// 		_map1.Add(MakeKeyword("PostForm"), (*_res1).PostForm)
// 		_map1.Add(MakeKeyword("MultipartForm"), (*(*_res1).MultipartForm))
// 		_map1.Add(MakeKeyword("Trailer"), (*_res1).Trailer)
// 		_map1.Add(MakeKeyword("RemoteAddr"), MakeString((*_res1).RemoteAddr))
// 		_map1.Add(MakeKeyword("RequestURI"), MakeString((*_res1).RequestURI))
// 		_map1.Add(MakeKeyword("TLS"), (*(*_res1).TLS))
// 		_map1.Add(MakeKeyword("Cancel"), (*_res1).Cancel)
// 		var _obj_map4 Object
// 		if (*_res1).Response != nil {
// 			_map4 := EmptyArrayMap()
// 			_map4.Add(MakeKeyword("Status"), MakeString((*(*_res1).Response).Status))
// 			_map4.Add(MakeKeyword("StatusCode"), MakeInt((*(*_res1).Response).StatusCode))
// 			_map4.Add(MakeKeyword("Proto"), MakeString((*(*_res1).Response).Proto))
// 			_map4.Add(MakeKeyword("ProtoMajor"), MakeInt((*(*_res1).Response).ProtoMajor))
// 			_map4.Add(MakeKeyword("ProtoMinor"), MakeInt((*(*_res1).Response).ProtoMinor))
// 			_map4.Add(MakeKeyword("Header"), (*(*_res1).Response).Header)
// 			_map4.Add(MakeKeyword("Body"), (*(*_res1).Response).Body)
// 			_map4.Add(MakeKeyword("ContentLength"), MakeInt(int((*(*_res1).Response).ContentLength)))
// 			_vec5 := EmptyVector
// 			for _, _elem5 := range (*(*_res1).Response).TransferEncoding {
// 				_vec5 = _vec5.Conjoin(MakeString(_elem5))
// 			}
// 			_map4.Add(MakeKeyword("TransferEncoding"), _vec5)
// 			_map4.Add(MakeKeyword("Close"), MakeBool((*(*_res1).Response).Close))
// 			_map4.Add(MakeKeyword("Uncompressed"), MakeBool((*(*_res1).Response).Uncompressed))
// 			_map4.Add(MakeKeyword("Trailer"), (*(*_res1).Response).Trailer)
// 			_map4.Add(MakeKeyword("Request"), )
// 			_map4.Add(MakeKeyword("TLS"), (*(*(*_res1).Response).TLS))
// 			_obj_map4 = Object(_map4)
// 		} else {
// 			_obj_map4 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Response"), _obj_map4)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.NewServeMux:
// func newServeMux() Object {
// 	return _http.NewServeMux()
// 	ABEND124(no public information returned)
// }

GO FUNC net/http.NotFound:
// func notFound(w ABEND884(unrecognized type ResponseWriter at: _tests/big/src/net/http/server.go:1981:17), r *ABEND884(unrecognized type Request at: _tests/big/src/net/http/server.go:1981:36)) Object {
// 	_http.NotFound(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.NotFoundHandler:
// func notFoundHandler() Object {
// 	return _http.NotFoundHandler()
// }

GO FUNC net/http.ParseHTTPVersion:
func parseHTTPVersion(vers string) Object {
	major, minor, ok := _http.ParseHTTPVersion(vers)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(major))
	_res = _res.Conjoin(MakeInt(minor))
	_res = _res.Conjoin(MakeBool(ok))
	return _res
}

GO FUNC net/http.ParseTime:
// func parseTime(text string) Object {
// 	t, err := _http.ParseTime(text)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(t)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.Post:
// func post(url string, contentType string, body *ABEND884(unrecognized type Reader at: _tests/big/src/net/http/client.go:748:44)) Object {
// 	resp, err := _http.Post(url, contentType, body)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if resp != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Status"), MakeString((*resp).Status))
// 		_map1.Add(MakeKeyword("StatusCode"), MakeInt((*resp).StatusCode))
// 		_map1.Add(MakeKeyword("Proto"), MakeString((*resp).Proto))
// 		_map1.Add(MakeKeyword("ProtoMajor"), MakeInt((*resp).ProtoMajor))
// 		_map1.Add(MakeKeyword("ProtoMinor"), MakeInt((*resp).ProtoMinor))
// 		_map1.Add(MakeKeyword("Header"), (*resp).Header)
// 		_map1.Add(MakeKeyword("Body"), (*resp).Body)
// 		_map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*resp).ContentLength)))
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*resp).TransferEncoding {
// 			_vec2 = _vec2.Conjoin(MakeString(_elem2))
// 		}
// 		_map1.Add(MakeKeyword("TransferEncoding"), _vec2)
// 		_map1.Add(MakeKeyword("Close"), MakeBool((*resp).Close))
// 		_map1.Add(MakeKeyword("Uncompressed"), MakeBool((*resp).Uncompressed))
// 		_map1.Add(MakeKeyword("Trailer"), (*resp).Trailer)
// 		var _obj_map3 Object
// 		if (*resp).Request != nil {
// 			_map3 := EmptyArrayMap()
// 			_map3.Add(MakeKeyword("Method"), MakeString((*(*resp).Request).Method))
// 			var _obj_map4 Object
// 			if (*(*resp).Request).URL != nil {
// 				_map4 := EmptyArrayMap()
// 				_map4.Add(MakeKeyword("Scheme"), MakeString((*(*(*resp).Request).URL).Scheme))
// 				_map4.Add(MakeKeyword("Opaque"), MakeString((*(*(*resp).Request).URL).Opaque))
// 				_map4.Add(MakeKeyword("User"), (*(*(*(*resp).Request).URL).User))
// 				_map4.Add(MakeKeyword("Host"), MakeString((*(*(*resp).Request).URL).Host))
// 				_map4.Add(MakeKeyword("Path"), MakeString((*(*(*resp).Request).URL).Path))
// 				_map4.Add(MakeKeyword("RawPath"), MakeString((*(*(*resp).Request).URL).RawPath))
// 				_map4.Add(MakeKeyword("ForceQuery"), MakeBool((*(*(*resp).Request).URL).ForceQuery))
// 				_map4.Add(MakeKeyword("RawQuery"), MakeString((*(*(*resp).Request).URL).RawQuery))
// 				_map4.Add(MakeKeyword("Fragment"), MakeString((*(*(*resp).Request).URL).Fragment))
// 				_obj_map4 = Object(_map4)
// 			} else {
// 				_obj_map4 = NIL
// 			}
// 			_map3.Add(MakeKeyword("URL"), _obj_map4)
// 			_map3.Add(MakeKeyword("Proto"), MakeString((*(*resp).Request).Proto))
// 			_map3.Add(MakeKeyword("ProtoMajor"), MakeInt((*(*resp).Request).ProtoMajor))
// 			_map3.Add(MakeKeyword("ProtoMinor"), MakeInt((*(*resp).Request).ProtoMinor))
// 			_map3.Add(MakeKeyword("Header"), (*(*resp).Request).Header)
// 			_map3.Add(MakeKeyword("Body"), (*(*resp).Request).Body)
// 			_map3.Add(MakeKeyword("GetBody"), (*(*resp).Request).GetBody)
// 			_map3.Add(MakeKeyword("ContentLength"), MakeInt(int((*(*resp).Request).ContentLength)))
// 			_vec5 := EmptyVector
// 			for _, _elem5 := range (*(*resp).Request).TransferEncoding {
// 				_vec5 = _vec5.Conjoin(MakeString(_elem5))
// 			}
// 			_map3.Add(MakeKeyword("TransferEncoding"), _vec5)
// 			_map3.Add(MakeKeyword("Close"), MakeBool((*(*resp).Request).Close))
// 			_map3.Add(MakeKeyword("Host"), MakeString((*(*resp).Request).Host))
// 			_map3.Add(MakeKeyword("Form"), (*(*resp).Request).Form)
// 			_map3.Add(MakeKeyword("PostForm"), (*(*resp).Request).PostForm)
// 			_map3.Add(MakeKeyword("MultipartForm"), (*(*(*resp).Request).MultipartForm))
// 			_map3.Add(MakeKeyword("Trailer"), (*(*resp).Request).Trailer)
// 			_map3.Add(MakeKeyword("RemoteAddr"), MakeString((*(*resp).Request).RemoteAddr))
// 			_map3.Add(MakeKeyword("RequestURI"), MakeString((*(*resp).Request).RequestURI))
// 			_map3.Add(MakeKeyword("TLS"), (*(*(*resp).Request).TLS))
// 			_map3.Add(MakeKeyword("Cancel"), (*(*resp).Request).Cancel)
// 			_map3.Add(MakeKeyword("Response"), )
// 			_obj_map3 = Object(_map3)
// 		} else {
// 			_obj_map3 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Request"), _obj_map3)
// 		_map1.Add(MakeKeyword("TLS"), (*(*resp).TLS))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.PostForm:
// func postForm(url string, data *ABEND884(unrecognized type Values at: _tests/big/src/net/http/client.go:785:36)) Object {
// 	resp, err := _http.PostForm(url, data)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if resp != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Status"), MakeString((*resp).Status))
// 		_map1.Add(MakeKeyword("StatusCode"), MakeInt((*resp).StatusCode))
// 		_map1.Add(MakeKeyword("Proto"), MakeString((*resp).Proto))
// 		_map1.Add(MakeKeyword("ProtoMajor"), MakeInt((*resp).ProtoMajor))
// 		_map1.Add(MakeKeyword("ProtoMinor"), MakeInt((*resp).ProtoMinor))
// 		_map1.Add(MakeKeyword("Header"), (*resp).Header)
// 		_map1.Add(MakeKeyword("Body"), (*resp).Body)
// 		_map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*resp).ContentLength)))
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*resp).TransferEncoding {
// 			_vec2 = _vec2.Conjoin(MakeString(_elem2))
// 		}
// 		_map1.Add(MakeKeyword("TransferEncoding"), _vec2)
// 		_map1.Add(MakeKeyword("Close"), MakeBool((*resp).Close))
// 		_map1.Add(MakeKeyword("Uncompressed"), MakeBool((*resp).Uncompressed))
// 		_map1.Add(MakeKeyword("Trailer"), (*resp).Trailer)
// 		var _obj_map3 Object
// 		if (*resp).Request != nil {
// 			_map3 := EmptyArrayMap()
// 			_map3.Add(MakeKeyword("Method"), MakeString((*(*resp).Request).Method))
// 			var _obj_map4 Object
// 			if (*(*resp).Request).URL != nil {
// 				_map4 := EmptyArrayMap()
// 				_map4.Add(MakeKeyword("Scheme"), MakeString((*(*(*resp).Request).URL).Scheme))
// 				_map4.Add(MakeKeyword("Opaque"), MakeString((*(*(*resp).Request).URL).Opaque))
// 				_map4.Add(MakeKeyword("User"), (*(*(*(*resp).Request).URL).User))
// 				_map4.Add(MakeKeyword("Host"), MakeString((*(*(*resp).Request).URL).Host))
// 				_map4.Add(MakeKeyword("Path"), MakeString((*(*(*resp).Request).URL).Path))
// 				_map4.Add(MakeKeyword("RawPath"), MakeString((*(*(*resp).Request).URL).RawPath))
// 				_map4.Add(MakeKeyword("ForceQuery"), MakeBool((*(*(*resp).Request).URL).ForceQuery))
// 				_map4.Add(MakeKeyword("RawQuery"), MakeString((*(*(*resp).Request).URL).RawQuery))
// 				_map4.Add(MakeKeyword("Fragment"), MakeString((*(*(*resp).Request).URL).Fragment))
// 				_obj_map4 = Object(_map4)
// 			} else {
// 				_obj_map4 = NIL
// 			}
// 			_map3.Add(MakeKeyword("URL"), _obj_map4)
// 			_map3.Add(MakeKeyword("Proto"), MakeString((*(*resp).Request).Proto))
// 			_map3.Add(MakeKeyword("ProtoMajor"), MakeInt((*(*resp).Request).ProtoMajor))
// 			_map3.Add(MakeKeyword("ProtoMinor"), MakeInt((*(*resp).Request).ProtoMinor))
// 			_map3.Add(MakeKeyword("Header"), (*(*resp).Request).Header)
// 			_map3.Add(MakeKeyword("Body"), (*(*resp).Request).Body)
// 			_map3.Add(MakeKeyword("GetBody"), (*(*resp).Request).GetBody)
// 			_map3.Add(MakeKeyword("ContentLength"), MakeInt(int((*(*resp).Request).ContentLength)))
// 			_vec5 := EmptyVector
// 			for _, _elem5 := range (*(*resp).Request).TransferEncoding {
// 				_vec5 = _vec5.Conjoin(MakeString(_elem5))
// 			}
// 			_map3.Add(MakeKeyword("TransferEncoding"), _vec5)
// 			_map3.Add(MakeKeyword("Close"), MakeBool((*(*resp).Request).Close))
// 			_map3.Add(MakeKeyword("Host"), MakeString((*(*resp).Request).Host))
// 			_map3.Add(MakeKeyword("Form"), (*(*resp).Request).Form)
// 			_map3.Add(MakeKeyword("PostForm"), (*(*resp).Request).PostForm)
// 			_map3.Add(MakeKeyword("MultipartForm"), (*(*(*resp).Request).MultipartForm))
// 			_map3.Add(MakeKeyword("Trailer"), (*(*resp).Request).Trailer)
// 			_map3.Add(MakeKeyword("RemoteAddr"), MakeString((*(*resp).Request).RemoteAddr))
// 			_map3.Add(MakeKeyword("RequestURI"), MakeString((*(*resp).Request).RequestURI))
// 			_map3.Add(MakeKeyword("TLS"), (*(*(*resp).Request).TLS))
// 			_map3.Add(MakeKeyword("Cancel"), (*(*resp).Request).Cancel)
// 			_map3.Add(MakeKeyword("Response"), )
// 			_obj_map3 = Object(_map3)
// 		} else {
// 			_obj_map3 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Request"), _obj_map3)
// 		_map1.Add(MakeKeyword("TLS"), (*(*resp).TLS))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.ProxyFromEnvironment:
// func proxyFromEnvironment(req *ABEND884(unrecognized type Request at: _tests/big/src/net/http/transport.go:345:32)) Object {
// 	_res1, _res2 := _http.ProxyFromEnvironment(req)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Scheme"), MakeString((*_res1).Scheme))
// 		_map1.Add(MakeKeyword("Opaque"), MakeString((*_res1).Opaque))
// 		_map1.Add(MakeKeyword("User"), (*(*_res1).User))
// 		_map1.Add(MakeKeyword("Host"), MakeString((*_res1).Host))
// 		_map1.Add(MakeKeyword("Path"), MakeString((*_res1).Path))
// 		_map1.Add(MakeKeyword("RawPath"), MakeString((*_res1).RawPath))
// 		_map1.Add(MakeKeyword("ForceQuery"), MakeBool((*_res1).ForceQuery))
// 		_map1.Add(MakeKeyword("RawQuery"), MakeString((*_res1).RawQuery))
// 		_map1.Add(MakeKeyword("Fragment"), MakeString((*_res1).Fragment))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.ProxyURL:
// func proxyURL(fixedURL **ABEND884(unrecognized type URL at: _tests/big/src/net/http/transport.go:351:29)) Object {
// 	return _http.ProxyURL(fixedURL)
// }

GO FUNC net/http.ReadRequest:
// func readRequest(b **ABEND884(unrecognized type Reader at: _tests/big/src/net/http/request.go:942:27)) Object {
// 	_res1, _res2 := _http.ReadRequest(b)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Method"), MakeString((*_res1).Method))
// 		var _obj_map2 Object
// 		if (*_res1).URL != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Scheme"), MakeString((*(*_res1).URL).Scheme))
// 			_map2.Add(MakeKeyword("Opaque"), MakeString((*(*_res1).URL).Opaque))
// 			_map2.Add(MakeKeyword("User"), (*(*(*_res1).URL).User))
// 			_map2.Add(MakeKeyword("Host"), MakeString((*(*_res1).URL).Host))
// 			_map2.Add(MakeKeyword("Path"), MakeString((*(*_res1).URL).Path))
// 			_map2.Add(MakeKeyword("RawPath"), MakeString((*(*_res1).URL).RawPath))
// 			_map2.Add(MakeKeyword("ForceQuery"), MakeBool((*(*_res1).URL).ForceQuery))
// 			_map2.Add(MakeKeyword("RawQuery"), MakeString((*(*_res1).URL).RawQuery))
// 			_map2.Add(MakeKeyword("Fragment"), MakeString((*(*_res1).URL).Fragment))
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("URL"), _obj_map2)
// 		_map1.Add(MakeKeyword("Proto"), MakeString((*_res1).Proto))
// 		_map1.Add(MakeKeyword("ProtoMajor"), MakeInt((*_res1).ProtoMajor))
// 		_map1.Add(MakeKeyword("ProtoMinor"), MakeInt((*_res1).ProtoMinor))
// 		_map1.Add(MakeKeyword("Header"), (*_res1).Header)
// 		_map1.Add(MakeKeyword("Body"), (*_res1).Body)
// 		_map1.Add(MakeKeyword("GetBody"), (*_res1).GetBody)
// 		_map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*_res1).ContentLength)))
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res1).TransferEncoding {
// 			_vec3 = _vec3.Conjoin(MakeString(_elem3))
// 		}
// 		_map1.Add(MakeKeyword("TransferEncoding"), _vec3)
// 		_map1.Add(MakeKeyword("Close"), MakeBool((*_res1).Close))
// 		_map1.Add(MakeKeyword("Host"), MakeString((*_res1).Host))
// 		_map1.Add(MakeKeyword("Form"), (*_res1).Form)
// 		_map1.Add(MakeKeyword("PostForm"), (*_res1).PostForm)
// 		_map1.Add(MakeKeyword("MultipartForm"), (*(*_res1).MultipartForm))
// 		_map1.Add(MakeKeyword("Trailer"), (*_res1).Trailer)
// 		_map1.Add(MakeKeyword("RemoteAddr"), MakeString((*_res1).RemoteAddr))
// 		_map1.Add(MakeKeyword("RequestURI"), MakeString((*_res1).RequestURI))
// 		_map1.Add(MakeKeyword("TLS"), (*(*_res1).TLS))
// 		_map1.Add(MakeKeyword("Cancel"), (*_res1).Cancel)
// 		var _obj_map4 Object
// 		if (*_res1).Response != nil {
// 			_map4 := EmptyArrayMap()
// 			_map4.Add(MakeKeyword("Status"), MakeString((*(*_res1).Response).Status))
// 			_map4.Add(MakeKeyword("StatusCode"), MakeInt((*(*_res1).Response).StatusCode))
// 			_map4.Add(MakeKeyword("Proto"), MakeString((*(*_res1).Response).Proto))
// 			_map4.Add(MakeKeyword("ProtoMajor"), MakeInt((*(*_res1).Response).ProtoMajor))
// 			_map4.Add(MakeKeyword("ProtoMinor"), MakeInt((*(*_res1).Response).ProtoMinor))
// 			_map4.Add(MakeKeyword("Header"), (*(*_res1).Response).Header)
// 			_map4.Add(MakeKeyword("Body"), (*(*_res1).Response).Body)
// 			_map4.Add(MakeKeyword("ContentLength"), MakeInt(int((*(*_res1).Response).ContentLength)))
// 			_vec5 := EmptyVector
// 			for _, _elem5 := range (*(*_res1).Response).TransferEncoding {
// 				_vec5 = _vec5.Conjoin(MakeString(_elem5))
// 			}
// 			_map4.Add(MakeKeyword("TransferEncoding"), _vec5)
// 			_map4.Add(MakeKeyword("Close"), MakeBool((*(*_res1).Response).Close))
// 			_map4.Add(MakeKeyword("Uncompressed"), MakeBool((*(*_res1).Response).Uncompressed))
// 			_map4.Add(MakeKeyword("Trailer"), (*(*_res1).Response).Trailer)
// 			_map4.Add(MakeKeyword("Request"), )
// 			_map4.Add(MakeKeyword("TLS"), (*(*(*_res1).Response).TLS))
// 			_obj_map4 = Object(_map4)
// 		} else {
// 			_obj_map4 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Response"), _obj_map4)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.ReadResponse:
// func readResponse(r **ABEND884(unrecognized type Reader at: _tests/big/src/net/http/response.go:148:28), req *ABEND884(unrecognized type Request at: _tests/big/src/net/http/response.go:148:41)) Object {
// 	_res1, _res2 := _http.ReadResponse(r, req)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Status"), MakeString((*_res1).Status))
// 		_map1.Add(MakeKeyword("StatusCode"), MakeInt((*_res1).StatusCode))
// 		_map1.Add(MakeKeyword("Proto"), MakeString((*_res1).Proto))
// 		_map1.Add(MakeKeyword("ProtoMajor"), MakeInt((*_res1).ProtoMajor))
// 		_map1.Add(MakeKeyword("ProtoMinor"), MakeInt((*_res1).ProtoMinor))
// 		_map1.Add(MakeKeyword("Header"), (*_res1).Header)
// 		_map1.Add(MakeKeyword("Body"), (*_res1).Body)
// 		_map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*_res1).ContentLength)))
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res1).TransferEncoding {
// 			_vec2 = _vec2.Conjoin(MakeString(_elem2))
// 		}
// 		_map1.Add(MakeKeyword("TransferEncoding"), _vec2)
// 		_map1.Add(MakeKeyword("Close"), MakeBool((*_res1).Close))
// 		_map1.Add(MakeKeyword("Uncompressed"), MakeBool((*_res1).Uncompressed))
// 		_map1.Add(MakeKeyword("Trailer"), (*_res1).Trailer)
// 		var _obj_map3 Object
// 		if (*_res1).Request != nil {
// 			_map3 := EmptyArrayMap()
// 			_map3.Add(MakeKeyword("Method"), MakeString((*(*_res1).Request).Method))
// 			var _obj_map4 Object
// 			if (*(*_res1).Request).URL != nil {
// 				_map4 := EmptyArrayMap()
// 				_map4.Add(MakeKeyword("Scheme"), MakeString((*(*(*_res1).Request).URL).Scheme))
// 				_map4.Add(MakeKeyword("Opaque"), MakeString((*(*(*_res1).Request).URL).Opaque))
// 				_map4.Add(MakeKeyword("User"), (*(*(*(*_res1).Request).URL).User))
// 				_map4.Add(MakeKeyword("Host"), MakeString((*(*(*_res1).Request).URL).Host))
// 				_map4.Add(MakeKeyword("Path"), MakeString((*(*(*_res1).Request).URL).Path))
// 				_map4.Add(MakeKeyword("RawPath"), MakeString((*(*(*_res1).Request).URL).RawPath))
// 				_map4.Add(MakeKeyword("ForceQuery"), MakeBool((*(*(*_res1).Request).URL).ForceQuery))
// 				_map4.Add(MakeKeyword("RawQuery"), MakeString((*(*(*_res1).Request).URL).RawQuery))
// 				_map4.Add(MakeKeyword("Fragment"), MakeString((*(*(*_res1).Request).URL).Fragment))
// 				_obj_map4 = Object(_map4)
// 			} else {
// 				_obj_map4 = NIL
// 			}
// 			_map3.Add(MakeKeyword("URL"), _obj_map4)
// 			_map3.Add(MakeKeyword("Proto"), MakeString((*(*_res1).Request).Proto))
// 			_map3.Add(MakeKeyword("ProtoMajor"), MakeInt((*(*_res1).Request).ProtoMajor))
// 			_map3.Add(MakeKeyword("ProtoMinor"), MakeInt((*(*_res1).Request).ProtoMinor))
// 			_map3.Add(MakeKeyword("Header"), (*(*_res1).Request).Header)
// 			_map3.Add(MakeKeyword("Body"), (*(*_res1).Request).Body)
// 			_map3.Add(MakeKeyword("GetBody"), (*(*_res1).Request).GetBody)
// 			_map3.Add(MakeKeyword("ContentLength"), MakeInt(int((*(*_res1).Request).ContentLength)))
// 			_vec5 := EmptyVector
// 			for _, _elem5 := range (*(*_res1).Request).TransferEncoding {
// 				_vec5 = _vec5.Conjoin(MakeString(_elem5))
// 			}
// 			_map3.Add(MakeKeyword("TransferEncoding"), _vec5)
// 			_map3.Add(MakeKeyword("Close"), MakeBool((*(*_res1).Request).Close))
// 			_map3.Add(MakeKeyword("Host"), MakeString((*(*_res1).Request).Host))
// 			_map3.Add(MakeKeyword("Form"), (*(*_res1).Request).Form)
// 			_map3.Add(MakeKeyword("PostForm"), (*(*_res1).Request).PostForm)
// 			_map3.Add(MakeKeyword("MultipartForm"), (*(*(*_res1).Request).MultipartForm))
// 			_map3.Add(MakeKeyword("Trailer"), (*(*_res1).Request).Trailer)
// 			_map3.Add(MakeKeyword("RemoteAddr"), MakeString((*(*_res1).Request).RemoteAddr))
// 			_map3.Add(MakeKeyword("RequestURI"), MakeString((*(*_res1).Request).RequestURI))
// 			_map3.Add(MakeKeyword("TLS"), (*(*(*_res1).Request).TLS))
// 			_map3.Add(MakeKeyword("Cancel"), (*(*_res1).Request).Cancel)
// 			_map3.Add(MakeKeyword("Response"), )
// 			_obj_map3 = Object(_map3)
// 		} else {
// 			_obj_map3 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Request"), _obj_map3)
// 		_map1.Add(MakeKeyword("TLS"), (*(*_res1).TLS))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.Redirect:
// func redirect(w ABEND884(unrecognized type ResponseWriter at: _tests/big/src/net/http/server.go:2020:17), r *ABEND884(unrecognized type Request at: _tests/big/src/net/http/server.go:2020:36), url string, code int) Object {
// 	_http.Redirect(w, r, url, code)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.RedirectHandler:
// func redirectHandler(url string, code int) Object {
// 	return _http.RedirectHandler(url, code)
// }

GO FUNC net/http.ServeContent:
// func serveContent(w ABEND884(unrecognized type ResponseWriter at: _tests/big/src/net/http/fs.go:151:21), req *ABEND884(unrecognized type Request at: _tests/big/src/net/http/fs.go:151:42), name string, modtime *ABEND884(unrecognized type Time at: _tests/big/src/net/http/fs.go:151:77), content *ABEND884(unrecognized type ReadSeeker at: _tests/big/src/net/http/fs.go:151:94)) Object {
// 	_http.ServeContent(w, req, name, modtime, content)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.ServeFile:
// func serveFile(w ABEND884(unrecognized type ResponseWriter at: _tests/big/src/net/http/fs.go:670:18), r *ABEND884(unrecognized type Request at: _tests/big/src/net/http/fs.go:670:37), name string) Object {
// 	_http.ServeFile(w, r, name)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.SetCookie:
// func setCookie(w ABEND884(unrecognized type ResponseWriter at: _tests/big/src/net/http/cookie.go:157:18), cookie *ABEND884(unrecognized type Cookie at: _tests/big/src/net/http/cookie.go:157:42)) Object {
// 	_http.SetCookie(w, cookie)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.StripPrefix:
// func stripPrefix(prefix string, h ABEND884(unrecognized type Handler at: _tests/big/src/net/http/server.go:1992:35)) Object {
// 	return _http.StripPrefix(prefix, h)
// }

GO FUNC net/http.TimeoutHandler:
// func timeoutHandler(h ABEND884(unrecognized type Handler at: _tests/big/src/net/http/server.go:3106:23), dt *ABEND884(unrecognized type Duration at: _tests/big/src/net/http/server.go:3106:40), msg string) Object {
// 	return _http.TimeoutHandler(h, dt, msg)
// }

GO FUNC net/http/cgi.Request:
// func request() Object {
// 	_res1, _res2 := _cgi.Request()
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Method"), MakeString((*_res1).Method))
// 		var _obj_map2 Object
// 		if (*_res1).URL != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Scheme"), MakeString((*(*_res1).URL).Scheme))
// 			_map2.Add(MakeKeyword("Opaque"), MakeString((*(*_res1).URL).Opaque))
// 			_map2.Add(MakeKeyword("User"), (*(*(*_res1).URL).User))
// 			_map2.Add(MakeKeyword("Host"), MakeString((*(*_res1).URL).Host))
// 			_map2.Add(MakeKeyword("Path"), MakeString((*(*_res1).URL).Path))
// 			_map2.Add(MakeKeyword("RawPath"), MakeString((*(*_res1).URL).RawPath))
// 			_map2.Add(MakeKeyword("ForceQuery"), MakeBool((*(*_res1).URL).ForceQuery))
// 			_map2.Add(MakeKeyword("RawQuery"), MakeString((*(*_res1).URL).RawQuery))
// 			_map2.Add(MakeKeyword("Fragment"), MakeString((*(*_res1).URL).Fragment))
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("URL"), _obj_map2)
// 		_map1.Add(MakeKeyword("Proto"), MakeString((*_res1).Proto))
// 		_map1.Add(MakeKeyword("ProtoMajor"), MakeInt((*_res1).ProtoMajor))
// 		_map1.Add(MakeKeyword("ProtoMinor"), MakeInt((*_res1).ProtoMinor))
// 		_map1.Add(MakeKeyword("Header"), (*_res1).Header)
// 		_map1.Add(MakeKeyword("Body"), (*_res1).Body)
// 		_map1.Add(MakeKeyword("GetBody"), (*_res1).GetBody)
// 		_map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*_res1).ContentLength)))
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res1).TransferEncoding {
// 			_vec3 = _vec3.Conjoin(MakeString(_elem3))
// 		}
// 		_map1.Add(MakeKeyword("TransferEncoding"), _vec3)
// 		_map1.Add(MakeKeyword("Close"), MakeBool((*_res1).Close))
// 		_map1.Add(MakeKeyword("Host"), MakeString((*_res1).Host))
// 		_map1.Add(MakeKeyword("Form"), (*_res1).Form)
// 		_map1.Add(MakeKeyword("PostForm"), (*_res1).PostForm)
// 		_map1.Add(MakeKeyword("MultipartForm"), (*(*_res1).MultipartForm))
// 		_map1.Add(MakeKeyword("Trailer"), (*_res1).Trailer)
// 		_map1.Add(MakeKeyword("RemoteAddr"), MakeString((*_res1).RemoteAddr))
// 		_map1.Add(MakeKeyword("RequestURI"), MakeString((*_res1).RequestURI))
// 		_map1.Add(MakeKeyword("TLS"), (*(*_res1).TLS))
// 		_map1.Add(MakeKeyword("Cancel"), (*_res1).Cancel)
// 		_map1.Add(MakeKeyword("Response"), (*(*_res1).Response))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/cgi.RequestFromMap:
// func requestFromMap(params map[]) Object {
// 	_res1, _res2 := _cgi.RequestFromMap(params)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Method"), MakeString((*_res1).Method))
// 		var _obj_map2 Object
// 		if (*_res1).URL != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Scheme"), MakeString((*(*_res1).URL).Scheme))
// 			_map2.Add(MakeKeyword("Opaque"), MakeString((*(*_res1).URL).Opaque))
// 			_map2.Add(MakeKeyword("User"), (*(*(*_res1).URL).User))
// 			_map2.Add(MakeKeyword("Host"), MakeString((*(*_res1).URL).Host))
// 			_map2.Add(MakeKeyword("Path"), MakeString((*(*_res1).URL).Path))
// 			_map2.Add(MakeKeyword("RawPath"), MakeString((*(*_res1).URL).RawPath))
// 			_map2.Add(MakeKeyword("ForceQuery"), MakeBool((*(*_res1).URL).ForceQuery))
// 			_map2.Add(MakeKeyword("RawQuery"), MakeString((*(*_res1).URL).RawQuery))
// 			_map2.Add(MakeKeyword("Fragment"), MakeString((*(*_res1).URL).Fragment))
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("URL"), _obj_map2)
// 		_map1.Add(MakeKeyword("Proto"), MakeString((*_res1).Proto))
// 		_map1.Add(MakeKeyword("ProtoMajor"), MakeInt((*_res1).ProtoMajor))
// 		_map1.Add(MakeKeyword("ProtoMinor"), MakeInt((*_res1).ProtoMinor))
// 		_map1.Add(MakeKeyword("Header"), (*_res1).Header)
// 		_map1.Add(MakeKeyword("Body"), (*_res1).Body)
// 		_map1.Add(MakeKeyword("GetBody"), (*_res1).GetBody)
// 		_map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*_res1).ContentLength)))
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res1).TransferEncoding {
// 			_vec3 = _vec3.Conjoin(MakeString(_elem3))
// 		}
// 		_map1.Add(MakeKeyword("TransferEncoding"), _vec3)
// 		_map1.Add(MakeKeyword("Close"), MakeBool((*_res1).Close))
// 		_map1.Add(MakeKeyword("Host"), MakeString((*_res1).Host))
// 		_map1.Add(MakeKeyword("Form"), (*_res1).Form)
// 		_map1.Add(MakeKeyword("PostForm"), (*_res1).PostForm)
// 		_map1.Add(MakeKeyword("MultipartForm"), (*(*_res1).MultipartForm))
// 		_map1.Add(MakeKeyword("Trailer"), (*_res1).Trailer)
// 		_map1.Add(MakeKeyword("RemoteAddr"), MakeString((*_res1).RemoteAddr))
// 		_map1.Add(MakeKeyword("RequestURI"), MakeString((*_res1).RequestURI))
// 		_map1.Add(MakeKeyword("TLS"), (*(*_res1).TLS))
// 		_map1.Add(MakeKeyword("Cancel"), (*_res1).Cancel)
// 		_map1.Add(MakeKeyword("Response"), (*(*_res1).Response))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/cookiejar.New:
// func new(o *ABEND884(unrecognized type Options at: _tests/big/src/net/http/cookiejar/jar.go:77:13)) Object {
// 	_, _res2 := _cookiejar.New(o)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/fcgi.ProcessEnv:
// func processEnv(r **ABEND884(unrecognized type Request at: _tests/big/src/net/http/fcgi/child.go:358:25)) Object {
// 	return _fcgi.ProcessEnv(r)
// }

GO FUNC net/http/httptest.NewRecorder:
// func newRecorder() Object {
// 	_res := _httptest.NewRecorder()
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Code"), MakeInt((*_res).Code))
// 		_map1.Add(MakeKeyword("HeaderMap"), (*_res).HeaderMap)
// 		_map1.Add(MakeKeyword("Body"), (*(*_res).Body))
// 		_map1.Add(MakeKeyword("Flushed"), MakeBool((*_res).Flushed))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC net/http/httptest.NewRequest:
// func newRequest(method string, target string, body *ABEND884(unrecognized type Reader at: _tests/big/src/net/http/httptest/httptest.go:41:48)) Object {
// 	_res := _httptest.NewRequest(method, target, body)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Method"), MakeString((*_res).Method))
// 		var _obj_map2 Object
// 		if (*_res).URL != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Scheme"), MakeString((*(*_res).URL).Scheme))
// 			_map2.Add(MakeKeyword("Opaque"), MakeString((*(*_res).URL).Opaque))
// 			_map2.Add(MakeKeyword("User"), (*(*(*_res).URL).User))
// 			_map2.Add(MakeKeyword("Host"), MakeString((*(*_res).URL).Host))
// 			_map2.Add(MakeKeyword("Path"), MakeString((*(*_res).URL).Path))
// 			_map2.Add(MakeKeyword("RawPath"), MakeString((*(*_res).URL).RawPath))
// 			_map2.Add(MakeKeyword("ForceQuery"), MakeBool((*(*_res).URL).ForceQuery))
// 			_map2.Add(MakeKeyword("RawQuery"), MakeString((*(*_res).URL).RawQuery))
// 			_map2.Add(MakeKeyword("Fragment"), MakeString((*(*_res).URL).Fragment))
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("URL"), _obj_map2)
// 		_map1.Add(MakeKeyword("Proto"), MakeString((*_res).Proto))
// 		_map1.Add(MakeKeyword("ProtoMajor"), MakeInt((*_res).ProtoMajor))
// 		_map1.Add(MakeKeyword("ProtoMinor"), MakeInt((*_res).ProtoMinor))
// 		_map1.Add(MakeKeyword("Header"), (*_res).Header)
// 		_map1.Add(MakeKeyword("Body"), (*_res).Body)
// 		_map1.Add(MakeKeyword("GetBody"), (*_res).GetBody)
// 		_map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*_res).ContentLength)))
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res).TransferEncoding {
// 			_vec3 = _vec3.Conjoin(MakeString(_elem3))
// 		}
// 		_map1.Add(MakeKeyword("TransferEncoding"), _vec3)
// 		_map1.Add(MakeKeyword("Close"), MakeBool((*_res).Close))
// 		_map1.Add(MakeKeyword("Host"), MakeString((*_res).Host))
// 		_map1.Add(MakeKeyword("Form"), (*_res).Form)
// 		_map1.Add(MakeKeyword("PostForm"), (*_res).PostForm)
// 		_map1.Add(MakeKeyword("MultipartForm"), (*(*_res).MultipartForm))
// 		_map1.Add(MakeKeyword("Trailer"), (*_res).Trailer)
// 		_map1.Add(MakeKeyword("RemoteAddr"), MakeString((*_res).RemoteAddr))
// 		_map1.Add(MakeKeyword("RequestURI"), MakeString((*_res).RequestURI))
// 		_map1.Add(MakeKeyword("TLS"), (*(*_res).TLS))
// 		_map1.Add(MakeKeyword("Cancel"), (*_res).Cancel)
// 		_map1.Add(MakeKeyword("Response"), (*(*_res).Response))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC net/http/httptest.NewServer:
// func newServer(handler *ABEND884(unrecognized type Handler at: _tests/big/src/net/http/httptest/server.go:80:29)) Object {
// 	_res := _httptest.NewServer(handler)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("URL"), MakeString((*_res).URL))
// 		_map1.Add(MakeKeyword("Listener"), (*_res).Listener)
// 		_map1.Add(MakeKeyword("TLS"), (*(*_res).TLS))
// 		var _obj_map2 Object
// 		if (*_res).Config != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Addr"), MakeString((*(*_res).Config).Addr))
// 			_map2.Add(MakeKeyword("Handler"), (*(*_res).Config).Handler)
// 			_map2.Add(MakeKeyword("TLSConfig"), (*(*(*_res).Config).TLSConfig))
// 			_map2.Add(MakeKeyword("ReadTimeout"), (*(*_res).Config).ReadTimeout)
// 			_map2.Add(MakeKeyword("ReadHeaderTimeout"), (*(*_res).Config).ReadHeaderTimeout)
// 			_map2.Add(MakeKeyword("WriteTimeout"), (*(*_res).Config).WriteTimeout)
// 			_map2.Add(MakeKeyword("IdleTimeout"), (*(*_res).Config).IdleTimeout)
// 			_map2.Add(MakeKeyword("MaxHeaderBytes"), MakeInt((*(*_res).Config).MaxHeaderBytes))
// 			_map2.Add(MakeKeyword("TLSNextProto"), (*(*_res).Config).TLSNextProto)
// 			_map2.Add(MakeKeyword("ConnState"), (*(*_res).Config).ConnState)
// 			_map2.Add(MakeKeyword("ErrorLog"), (*(*(*_res).Config).ErrorLog))
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Config"), _obj_map2)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC net/http/httptest.NewTLSServer:
// func newTLSServer(handler *ABEND884(unrecognized type Handler at: _tests/big/src/net/http/httptest/server.go:160:32)) Object {
// 	_res := _httptest.NewTLSServer(handler)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("URL"), MakeString((*_res).URL))
// 		_map1.Add(MakeKeyword("Listener"), (*_res).Listener)
// 		_map1.Add(MakeKeyword("TLS"), (*(*_res).TLS))
// 		var _obj_map2 Object
// 		if (*_res).Config != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Addr"), MakeString((*(*_res).Config).Addr))
// 			_map2.Add(MakeKeyword("Handler"), (*(*_res).Config).Handler)
// 			_map2.Add(MakeKeyword("TLSConfig"), (*(*(*_res).Config).TLSConfig))
// 			_map2.Add(MakeKeyword("ReadTimeout"), (*(*_res).Config).ReadTimeout)
// 			_map2.Add(MakeKeyword("ReadHeaderTimeout"), (*(*_res).Config).ReadHeaderTimeout)
// 			_map2.Add(MakeKeyword("WriteTimeout"), (*(*_res).Config).WriteTimeout)
// 			_map2.Add(MakeKeyword("IdleTimeout"), (*(*_res).Config).IdleTimeout)
// 			_map2.Add(MakeKeyword("MaxHeaderBytes"), MakeInt((*(*_res).Config).MaxHeaderBytes))
// 			_map2.Add(MakeKeyword("TLSNextProto"), (*(*_res).Config).TLSNextProto)
// 			_map2.Add(MakeKeyword("ConnState"), (*(*_res).Config).ConnState)
// 			_map2.Add(MakeKeyword("ErrorLog"), (*(*(*_res).Config).ErrorLog))
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Config"), _obj_map2)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC net/http/httptest.NewUnstartedServer:
// func newUnstartedServer(handler *ABEND884(unrecognized type Handler at: _tests/big/src/net/http/httptest/server.go:92:38)) Object {
// 	_res := _httptest.NewUnstartedServer(handler)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("URL"), MakeString((*_res).URL))
// 		_map1.Add(MakeKeyword("Listener"), (*_res).Listener)
// 		_map1.Add(MakeKeyword("TLS"), (*(*_res).TLS))
// 		var _obj_map2 Object
// 		if (*_res).Config != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Addr"), MakeString((*(*_res).Config).Addr))
// 			_map2.Add(MakeKeyword("Handler"), (*(*_res).Config).Handler)
// 			_map2.Add(MakeKeyword("TLSConfig"), (*(*(*_res).Config).TLSConfig))
// 			_map2.Add(MakeKeyword("ReadTimeout"), (*(*_res).Config).ReadTimeout)
// 			_map2.Add(MakeKeyword("ReadHeaderTimeout"), (*(*_res).Config).ReadHeaderTimeout)
// 			_map2.Add(MakeKeyword("WriteTimeout"), (*(*_res).Config).WriteTimeout)
// 			_map2.Add(MakeKeyword("IdleTimeout"), (*(*_res).Config).IdleTimeout)
// 			_map2.Add(MakeKeyword("MaxHeaderBytes"), MakeInt((*(*_res).Config).MaxHeaderBytes))
// 			_map2.Add(MakeKeyword("TLSNextProto"), (*(*_res).Config).TLSNextProto)
// 			_map2.Add(MakeKeyword("ConnState"), (*(*_res).Config).ConnState)
// 			_map2.Add(MakeKeyword("ErrorLog"), (*(*(*_res).Config).ErrorLog))
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Config"), _obj_map2)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC net/http/httptrace.ContextClientTrace:
// func contextClientTrace(ctx *ABEND884(unrecognized type Context at: _tests/big/src/net/http/httptrace/trace.go:24:37)) Object {
// 	_res := _httptrace.ContextClientTrace(ctx)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("GetConn"), (*_res).GetConn)
// 		_map1.Add(MakeKeyword("GotConn"), (*_res).GotConn)
// 		_map1.Add(MakeKeyword("PutIdleConn"), (*_res).PutIdleConn)
// 		_map1.Add(MakeKeyword("GotFirstResponseByte"), (*_res).GotFirstResponseByte)
// 		_map1.Add(MakeKeyword("Got100Continue"), (*_res).Got100Continue)
// 		_map1.Add(MakeKeyword("Got1xxResponse"), (*_res).Got1xxResponse)
// 		_map1.Add(MakeKeyword("DNSStart"), (*_res).DNSStart)
// 		_map1.Add(MakeKeyword("DNSDone"), (*_res).DNSDone)
// 		_map1.Add(MakeKeyword("ConnectStart"), (*_res).ConnectStart)
// 		_map1.Add(MakeKeyword("ConnectDone"), (*_res).ConnectDone)
// 		_map1.Add(MakeKeyword("TLSHandshakeStart"), (*_res).TLSHandshakeStart)
// 		_map1.Add(MakeKeyword("TLSHandshakeDone"), (*_res).TLSHandshakeDone)
// 		_map1.Add(MakeKeyword("WroteHeaderField"), (*_res).WroteHeaderField)
// 		_map1.Add(MakeKeyword("WroteHeaders"), (*_res).WroteHeaders)
// 		_map1.Add(MakeKeyword("Wait100Continue"), (*_res).Wait100Continue)
// 		_map1.Add(MakeKeyword("WroteRequest"), (*_res).WroteRequest)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC net/http/httptrace.WithClientTrace:
// func withClientTrace(ctx *ABEND884(unrecognized type Context at: _tests/big/src/net/http/httptrace/trace.go:34:34), trace *ABEND884(unrecognized type ClientTrace at: _tests/big/src/net/http/httptrace/trace.go:34:50)) Object {
// 	return _httptrace.WithClientTrace(ctx, trace)
// }

GO FUNC net/http/httputil.DumpRequest:
// func dumpRequest(req **ABEND884(unrecognized type Request at: _tests/big/src/net/http/httputil/dump.go:191:28), body bool) Object {
// 	_res1, _res2 := _httputil.DumpRequest(req, body)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.DumpRequestOut:
// func dumpRequestOut(req **ABEND884(unrecognized type Request at: _tests/big/src/net/http/httputil/dump.go:66:31), body bool) Object {
// 	_res1, _res2 := _httputil.DumpRequestOut(req, body)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.DumpResponse:
// func dumpResponse(resp **ABEND884(unrecognized type Response at: _tests/big/src/net/http/httputil/dump.go:281:30), body bool) Object {
// 	_res1, _res2 := _httputil.DumpResponse(resp, body)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.NewChunkedReader:
// func newChunkedReader(r *ABEND884(unrecognized type Reader at: _tests/big/src/net/http/httputil/httputil.go:20:28)) Object {
// 	return _httputil.NewChunkedReader(r)
// }

GO FUNC net/http/httputil.NewChunkedWriter:
// func newChunkedWriter(w *ABEND884(unrecognized type Writer at: _tests/big/src/net/http/httputil/httputil.go:35:28)) Object {
// 	return _httputil.NewChunkedWriter(w)
// }

GO FUNC net/http/httputil.NewClientConn:
// func newClientConn(c *ABEND884(unrecognized type Conn at: _tests/big/src/net/http/httputil/persist.go:248:26), r **ABEND884(unrecognized type Reader at: _tests/big/src/net/http/httputil/persist.go:248:41)) Object {
// 	return _httputil.NewClientConn(c, r)
// 	ABEND124(no public information returned)
// }

GO FUNC net/http/httputil.NewProxyClientConn:
// func newProxyClientConn(c *ABEND884(unrecognized type Conn at: _tests/big/src/net/http/httputil/persist.go:265:31), r **ABEND884(unrecognized type Reader at: _tests/big/src/net/http/httputil/persist.go:265:46)) Object {
// 	return _httputil.NewProxyClientConn(c, r)
// 	ABEND124(no public information returned)
// }

GO FUNC net/http/httputil.NewServerConn:
// func newServerConn(c *ABEND884(unrecognized type Conn at: _tests/big/src/net/http/httputil/persist.go:54:26), r **ABEND884(unrecognized type Reader at: _tests/big/src/net/http/httputil/persist.go:54:41)) Object {
// 	return _httputil.NewServerConn(c, r)
// 	ABEND124(no public information returned)
// }

GO FUNC net/http/httputil.NewSingleHostReverseProxy:
// func newSingleHostReverseProxy(target **ABEND884(unrecognized type URL at: _tests/big/src/net/http/httputil/reverseproxy.go:103:44)) Object {
// 	_res := _httputil.NewSingleHostReverseProxy(target)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Director"), (*_res).Director)
// 		_map1.Add(MakeKeyword("Transport"), (*_res).Transport)
// 		_map1.Add(MakeKeyword("FlushInterval"), (*_res).FlushInterval)
// 		_map1.Add(MakeKeyword("ErrorLog"), (*(*_res).ErrorLog))
// 		_map1.Add(MakeKeyword("BufferPool"), (*_res).BufferPool)
// 		_map1.Add(MakeKeyword("ModifyResponse"), (*_res).ModifyResponse)
// 		_map1.Add(MakeKeyword("ErrorHandler"), (*_res).ErrorHandler)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC net/http/pprof.Cmdline:
// func cmdline(w *ABEND884(unrecognized type ResponseWriter at: _tests/big/src/net/http/pprof/pprof.go:83:21), r **ABEND884(unrecognized type Request at: _tests/big/src/net/http/pprof/pprof.go:83:45)) Object {
// 	_pprof.Cmdline(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Handler:
// func handler(name string) Object {
// 	return _pprof.Handler(name)
// }

GO FUNC net/http/pprof.Index:
// func index(w *ABEND884(unrecognized type ResponseWriter at: _tests/big/src/net/http/pprof/pprof.go:264:19), r **ABEND884(unrecognized type Request at: _tests/big/src/net/http/pprof/pprof.go:264:43)) Object {
// 	_pprof.Index(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Profile:
// func profile(w *ABEND884(unrecognized type ResponseWriter at: _tests/big/src/net/http/pprof/pprof.go:116:21), r **ABEND884(unrecognized type Request at: _tests/big/src/net/http/pprof/pprof.go:116:45)) Object {
// 	_pprof.Profile(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Symbol:
// func symbol(w *ABEND884(unrecognized type ResponseWriter at: _tests/big/src/net/http/pprof/pprof.go:174:20), r **ABEND884(unrecognized type Request at: _tests/big/src/net/http/pprof/pprof.go:174:44)) Object {
// 	_pprof.Symbol(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Trace:
// func trace(w *ABEND884(unrecognized type ResponseWriter at: _tests/big/src/net/http/pprof/pprof.go:145:19), r **ABEND884(unrecognized type Request at: _tests/big/src/net/http/pprof/pprof.go:145:43)) Object {
// 	_pprof.Trace(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/mail.ParseAddress:
func parseAddress(address string) Object {
	_res1, _res2 := _mail.ParseAddress(address)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map1.Add(MakeKeyword("Name"), MakeString((*_res1).Name))
		_map1.Add(MakeKeyword("Address"), MakeString((*_res1).Address))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.ParseAddressList:
func parseAddressList(list string) Object {
	_res1, _res2 := _mail.ParseAddressList(list)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		var _obj_map2 Object
		if _elem1 != nil {
			_map2 := EmptyArrayMap()
			_map2.Add(MakeKeyword("Name"), MakeString((*_elem1).Name))
			_map2.Add(MakeKeyword("Address"), MakeString((*_elem1).Address))
			_obj_map2 = Object(_map2)
		} else {
			_obj_map2 = NIL
		}
		_vec1 = _vec1.Conjoin(_obj_map2)
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.ParseDate:
// func parseDate(date string) Object {
// 	_res1, _res2 := _mail.ParseDate(date)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/mail.ReadMessage:
// func readMessage(r *ABEND884(unrecognized type Reader at: _tests/big/src/net/mail/message.go:52:23)) Object {
// 	msg, err := _mail.ReadMessage(r)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if msg != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Header"), (*msg).Header)
// 		_map1.Add(MakeKeyword("Body"), (*msg).Body)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/rpc.Accept:
// func accept(lis *ABEND884(unrecognized type Listener at: _tests/big/src/net/rpc/server.go:692:21)) Object {
// 	_rpc.Accept(lis)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.Dial:
func dial(network string, address string) Object {
	_, _res2 := _rpc.Dial(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.DialHTTP:
func dialHTTP(network string, address string) Object {
	_, _res2 := _rpc.DialHTTP(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.DialHTTPPath:
func dialHTTPPath(network string, address string, path string) Object {
	_, _res2 := _rpc.DialHTTPPath(network, address, path)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.HandleHTTP:
// func handleHTTP() Object {
// 	_rpc.HandleHTTP()
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.NewClient:
// func newClient(conn *ABEND884(unrecognized type ReadWriteCloser at: _tests/big/src/net/rpc/client.go:193:24)) Object {
// 	return _rpc.NewClient(conn)
// 	ABEND124(no public information returned)
// }

GO FUNC net/rpc.NewClientWithCodec:
// func newClientWithCodec(codec ABEND884(unrecognized type ClientCodec at: _tests/big/src/net/rpc/client.go:201:31)) Object {
// 	return _rpc.NewClientWithCodec(codec)
// 	ABEND124(no public information returned)
// }

GO FUNC net/rpc.NewServer:
// func newServer() Object {
// 	return _rpc.NewServer()
// 	ABEND124(no public information returned)
// }

GO FUNC net/rpc.ServeCodec:
// func serveCodec(codec ABEND884(unrecognized type ServerCodec at: _tests/big/src/net/rpc/server.go:679:23)) Object {
// 	_rpc.ServeCodec(codec)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.ServeConn:
// func serveConn(conn *ABEND884(unrecognized type ReadWriteCloser at: _tests/big/src/net/rpc/server.go:673:24)) Object {
// 	_rpc.ServeConn(conn)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc/jsonrpc.Dial:
func dial(network string, address string) Object {
	_, _res2 := _jsonrpc.Dial(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc/jsonrpc.NewClient:
// func newClient(conn *ABEND884(unrecognized type ReadWriteCloser at: _tests/big/src/net/rpc/jsonrpc/client.go:113:24)) Object {
// 	return _jsonrpc.NewClient(conn)
// 	ABEND124(no public information returned)
// }

GO FUNC net/rpc/jsonrpc.NewClientCodec:
// func newClientCodec(conn *ABEND884(unrecognized type ReadWriteCloser at: _tests/big/src/net/rpc/jsonrpc/client.go:37:29)) Object {
// 	return _jsonrpc.NewClientCodec(conn)
// }

GO FUNC net/rpc/jsonrpc.NewServerCodec:
// func newServerCodec(conn *ABEND884(unrecognized type ReadWriteCloser at: _tests/big/src/net/rpc/jsonrpc/server.go:37:29)) Object {
// 	return _jsonrpc.NewServerCodec(conn)
// }

GO FUNC net/rpc/jsonrpc.ServeConn:
// func serveConn(conn *ABEND884(unrecognized type ReadWriteCloser at: _tests/big/src/net/rpc/jsonrpc/server.go:132:24)) Object {
// 	_jsonrpc.ServeConn(conn)
// 	...ABEND675: TODO...
// }

GO FUNC net/smtp.CRAMMD5Auth:
// func cRAMMD5Auth(username string, secret string) Object {
// 	return _smtp.CRAMMD5Auth(username, secret)
// }

GO FUNC net/smtp.Dial:
func dial(addr string) Object {
	_, _res2 := _smtp.Dial(addr)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/smtp.NewClient:
// func newClient(conn *ABEND884(unrecognized type Conn at: _tests/big/src/net/smtp/smtp.go:62:25), host string) Object {
// 	_, _res2 := _smtp.NewClient(conn, host)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/smtp.PlainAuth:
// func plainAuth(identity string, username string, password string, host string) Object {
// 	return _smtp.PlainAuth(identity, username, password, host)
// }

GO FUNC net/textproto.Dial:
func dial(network string, addr string) Object {
	_, _res2 := _textproto.Dial(network, addr)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.NewConn:
// func newConn(conn *ABEND884(unrecognized type ReadWriteCloser at: _tests/big/src/net/textproto/textproto.go:66:22)) Object {
// 	return _textproto.NewConn(conn)
// 	ABEND124(no public information returned)
// }

GO FUNC net/textproto.NewReader:
// func newReader(r **ABEND884(unrecognized type Reader at: _tests/big/src/net/textproto/reader.go:29:25)) Object {
// 	_res := _textproto.NewReader(r)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("R"), (*(*_res).R))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC net/textproto.NewWriter:
// func newWriter(w **ABEND884(unrecognized type Writer at: _tests/big/src/net/textproto/writer.go:21:25)) Object {
// 	_res := _textproto.NewWriter(w)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("W"), (*(*_res).W))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC net/textproto.TrimBytes:
func trimBytes(b []byte) Object {
	_res := _textproto.TrimBytes(b)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC net/url.Parse:
func parse(rawurl string) Object {
	_res1, _res2 := _url.Parse(rawurl)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map1.Add(MakeKeyword("Scheme"), MakeString((*_res1).Scheme))
		_map1.Add(MakeKeyword("Opaque"), MakeString((*_res1).Opaque))
		_map1.Add(MakeKeyword("User"), NIL)
		_map1.Add(MakeKeyword("Host"), MakeString((*_res1).Host))
		_map1.Add(MakeKeyword("Path"), MakeString((*_res1).Path))
		_map1.Add(MakeKeyword("RawPath"), MakeString((*_res1).RawPath))
		_map1.Add(MakeKeyword("ForceQuery"), MakeBool((*_res1).ForceQuery))
		_map1.Add(MakeKeyword("RawQuery"), MakeString((*_res1).RawQuery))
		_map1.Add(MakeKeyword("Fragment"), MakeString((*_res1).Fragment))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.ParseQuery:
// func parseQuery(query string) Object {
// 	_res1, _res2 := _url.ParseQuery(query)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/url.ParseRequestURI:
func parseRequestURI(rawurl string) Object {
	_res1, _res2 := _url.ParseRequestURI(rawurl)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map1.Add(MakeKeyword("Scheme"), MakeString((*_res1).Scheme))
		_map1.Add(MakeKeyword("Opaque"), MakeString((*_res1).Opaque))
		_map1.Add(MakeKeyword("User"), NIL)
		_map1.Add(MakeKeyword("Host"), MakeString((*_res1).Host))
		_map1.Add(MakeKeyword("Path"), MakeString((*_res1).Path))
		_map1.Add(MakeKeyword("RawPath"), MakeString((*_res1).RawPath))
		_map1.Add(MakeKeyword("ForceQuery"), MakeBool((*_res1).ForceQuery))
		_map1.Add(MakeKeyword("RawQuery"), MakeString((*_res1).RawQuery))
		_map1.Add(MakeKeyword("Fragment"), MakeString((*_res1).Fragment))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.PathUnescape:
func pathUnescape(s string) Object {
	_res1, _res2 := _url.PathUnescape(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.QueryUnescape:
func queryUnescape(s string) Object {
	_res1, _res2 := _url.QueryUnescape(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.User:
// func user(username string) Object {
// 	return _url.User(username)
// 	ABEND124(no public information returned)
// }

GO FUNC net/url.UserPassword:
// func userPassword(username string, password string) Object {
// 	return _url.UserPassword(username, password)
// 	ABEND124(no public information returned)
// }

Adding custom imports to _tests/gold/amd64-linux/joker/custom.go
Adding custom loaded libraries to _tests/gold/amd64-linux/joker/core/data/core.joke
Adding custom loaded libraries to _tests/gold/amd64-linux/joker/std/generate-custom.joke
ABENDs: 884(177) 883(124) 042(100) 904(60) 903(24) 401(20) 675(18) 124(11) 947(7) 907(2) 906(1) 908(1)
Totals: types=102 functions=1348 methods=1200 (89.02%) standalone=148 (10.98%) generated=49 (33.11%)
