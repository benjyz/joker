Walking from _tests/big/src to _tests/big/src/go
Processing go:
Walking from _tests/big/src to _tests/big/src/net
Processing net:
Matchfile(_tests/big/src/net/conf_netcgo.go) => false <nil>
Ignoring test code in main_cloexec_test.go
Ignoring test code in example_test.go
Matchfile(_tests/big/src/net/sockopt_bsd.go) => false <nil>
Matchfile(_tests/big/src/net/sock_bsd.go) => false <nil>
Matchfile(_tests/big/src/net/error_windows.go) => false <nil>
Ignoring test code in unixsock_test.go
Matchfile(_tests/big/src/net/interface_darwin.go) => false <nil>
Matchfile(_tests/big/src/net/sendfile_windows.go) => false <nil>
Matchfile(_tests/big/src/net/iprawsock.go) => true <nil>
Matchfile(_tests/big/src/net/tcpsockopt_darwin.go) => false <nil>
Ignoring test code in main_test.go
Matchfile(_tests/big/src/net/tcpsockopt_dragonfly.go) => false <nil>
Matchfile(_tests/big/src/net/file_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/sock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/net.go) => true <nil>
Matchfile(_tests/big/src/net/sendfile_linux.go) => true <nil>
Ignoring test code in udpsock_plan9_test.go
Matchfile(_tests/big/src/net/cgo_resnew.go) => true <nil>
Matchfile(_tests/big/src/net/splice_stub.go) => false <nil>
Ignoring test code in error_plan9_test.go
Ignoring test code in iprawsock_test.go
Matchfile(_tests/big/src/net/sockaddr_posix.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_openbsd.go) => false <nil>
Matchfile(_tests/big/src/net/dnsclient_unix.go) => true <nil>
Matchfile(_tests/big/src/net/sock_cloexec.go) => true <nil>
Ignoring test code in timeout_test.go
Ignoring test code in lookup_windows_test.go
Ignoring test code in udpsock_test.go
Ignoring test code in rawconn_unix_test.go
Matchfile(_tests/big/src/net/sockopt_linux.go) => true <nil>
Matchfile(_tests/big/src/net/sock_linux.go) => true <nil>
Ignoring test code in hosts_test.go
Matchfile(_tests/big/src/net/lookup_fake.go) => false <nil>
Matchfile(_tests/big/src/net/lookup_windows.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_openbsd.go) => false <nil>
Matchfile(_tests/big/src/net/unixsock.go) => true <nil>
Matchfile(_tests/big/src/net/sockopt_posix.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_bsd.go) => false <nil>
Matchfile(_tests/big/src/net/sockopt_solaris.go) => false <nil>
Matchfile(_tests/big/src/net/interface_stub.go) => false <nil>
Matchfile(_tests/big/src/net/hook.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_linux.go) => true <nil>
Matchfile(_tests/big/src/net/addrselect.go) => true <nil>
Matchfile(_tests/big/src/net/mac.go) => true <nil>
Ignoring test code in dnsclient_unix_test.go
Matchfile(_tests/big/src/net/iprawsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_unix.go) => true <nil>
Ignoring test code in dnsname_test.go
Ignoring test code in conf_test.go
Matchfile(_tests/big/src/net/sockopt_plan9.go) => false <nil>
Ignoring test code in interface_test.go
Ignoring test code in sendfile_test.go
Matchfile(_tests/big/src/net/sockoptip_windows.go) => false <nil>
Matchfile(_tests/big/src/net/error_unix.go) => true <nil>
Matchfile(_tests/big/src/net/fd_windows.go) => false <nil>
Matchfile(_tests/big/src/net/error_nacl.go) => false <nil>
Ignoring test code in dnsclient_test.go
Matchfile(_tests/big/src/net/tcpsockopt_solaris.go) => false <nil>
Ignoring test code in net_windows_test.go
Matchfile(_tests/big/src/net/sockoptip_linux.go) => true <nil>
Matchfile(_tests/big/src/net/lookup_unix.go) => true <nil>
Matchfile(_tests/big/src/net/interface_solaris.go) => false <nil>
Matchfile(_tests/big/src/net/net_fake.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/parse.go) => true <nil>
Ignoring test code in parse_test.go
Ignoring test code in lookup_test.go
Ignoring test code in main_windows_test.go
Matchfile(_tests/big/src/net/interface_bsdvar.go) => false <nil>
Matchfile(_tests/big/src/net/interface.go) => true <nil>
Ignoring test code in ipsock_test.go
Matchfile(_tests/big/src/net/tcpsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/file.go) => true <nil>
Ignoring test code in net_test.go
Ignoring test code in server_test.go
Matchfile(_tests/big/src/net/cgo_solaris.go) => false <nil>
Ignoring test code in splice_test.go
Ignoring test code in error_unix_test.go
Ignoring test code in platform_test.go
Ignoring test code in dnsconfig_unix_test.go
Matchfile(_tests/big/src/net/cgo_android.go) => false <nil>
Matchfile(_tests/big/src/net/sockoptip_bsdvar.go) => false <nil>
Ignoring test code in rawconn_windows_test.go
Matchfile(_tests/big/src/net/unixsock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/lookup_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/sockopt_stub.go) => false <nil>
Matchfile(_tests/big/src/net/rawconn.go) => true <nil>
Matchfile(_tests/big/src/net/sock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/sockoptip_posix.go) => true <nil>
Ignoring test code in write_unix_test.go
Matchfile(_tests/big/src/net/splice_linux.go) => true <nil>
Ignoring test code in unixsock_linux_test.go
Ignoring test code in error_posix_test.go
Ignoring test code in listen_test.go
Matchfile(_tests/big/src/net/dnsclient.go) => true <nil>
Matchfile(_tests/big/src/net/fd_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/sendfile_stub.go) => false <nil>
Ignoring test code in dial_test.go
Ignoring test code in interface_linux_test.go
Ignoring test code in tcpsock_test.go
Matchfile(_tests/big/src/net/hook_windows.go) => false <nil>
Ignoring test code in ip_test.go
Matchfile(_tests/big/src/net/file_stub.go) => false <nil>
Matchfile(_tests/big/src/net/fd_unix.go) => true <nil>
Matchfile(_tests/big/src/net/ipsock.go) => true <nil>
Ignoring test code in netgo_unix_test.go
Ignoring test code in addrselect_test.go
Matchfile(_tests/big/src/net/lookup.go) => true <nil>
Matchfile(_tests/big/src/net/tcpsock.go) => true <nil>
Matchfile(_tests/big/src/net/pipe.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_resold.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_stub.go) => false <nil>
Matchfile(_tests/big/src/net/dial.go) => true <nil>
Matchfile(_tests/big/src/net/interface_bsd.go) => false <nil>
Ignoring test code in main_unix_test.go
Matchfile(_tests/big/src/net/hosts.go) => true <nil>
Ignoring test code in file_test.go
Matchfile(_tests/big/src/net/dnsconfig_unix.go) => true <nil>
Matchfile(_tests/big/src/net/interface_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/interface_windows.go) => false <nil>
Ignoring test code in packetconn_test.go
Matchfile(_tests/big/src/net/writev_unix.go) => true <nil>
Matchfile(_tests/big/src/net/interface_freebsd.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_windows.go) => false <nil>
Ignoring test code in protoconn_test.go
Ignoring test code in nss_test.go
Ignoring test code in rawconn_test.go
Matchfile(_tests/big/src/net/sys_cloexec.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_posix.go) => true <nil>
Matchfile(_tests/big/src/net/ip.go) => true <nil>
Matchfile(_tests/big/src/net/sendfile_unix_alt.go) => false <nil>
Ignoring test code in dial_unix_test.go
Ignoring test code in main_conf_test.go
Matchfile(_tests/big/src/net/interface_linux.go) => true <nil>
Matchfile(_tests/big/src/net/error_posix.go) => true <nil>
Matchfile(_tests/big/src/net/hook_plan9.go) => false <nil>
Ignoring test code in main_posix_test.go
Matchfile(_tests/big/src/net/cgo_sockold.go) => false <nil>
Ignoring test code in cgo_unix_test.go
Matchfile(_tests/big/src/net/file_unix.go) => true <nil>
Ignoring test code in mac_test.go
Matchfile(_tests/big/src/net/udpsock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/file_windows.go) => false <nil>
Matchfile(_tests/big/src/net/udpsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_windows.go) => false <nil>
Matchfile(_tests/big/src/net/sock_windows.go) => false <nil>
Ignoring test code in pipe_test.go
Ignoring test code in main_plan9_test.go
Matchfile(_tests/big/src/net/udpsock.go) => true <nil>
Matchfile(_tests/big/src/net/nss.go) => true <nil>
Matchfile(_tests/big/src/net/conf.go) => true <nil>
Matchfile(_tests/big/src/net/iprawsock_posix.go) => true <nil>
Ignoring test code in interface_unix_test.go
Matchfile(_tests/big/src/net/sockopt_windows.go) => false <nil>
Matchfile(_tests/big/src/net/ipsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_socknew.go) => true <nil>
Matchfile(_tests/big/src/net/port_unix.go) => true <nil>
Matchfile(_tests/big/src/net/sock_stub.go) => false <nil>
Ignoring test code in error_test.go
Matchfile(_tests/big/src/net/port.go) => true <nil>
Ignoring test code in rawconn_stub_test.go
Ignoring test code in mockserver_test.go
Matchfile(_tests/big/src/net/unixsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_netbsd.go) => false <nil>
Ignoring test code in port_test.go
Ignoring test code in conn_test.go
Ignoring test code in external_test.go
Matchfile(_tests/big/src/net/cgo_stub.go) => false <nil>
Ignoring test code in error_windows_test.go
Matchfile(_tests/big/src/net/ipsock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/hook_unix.go) => true <nil>
Ignoring test code in tcpsock_unix_test.go
Matchfile(_tests/big/src/net/sockoptip_stub.go) => false <nil>
Ignoring test code in main_noconf_test.go
Matchfile(_tests/big/src/net/tcpsockopt_unix.go) => true <nil>
Matchfile(_tests/big/src/net/error_plan9.go) => false <nil>
Ignoring test code in writev_test.go
Ignoring test code in interface_bsd_test.go
Processing package=net:
Walking from _tests/big/src to _tests/big/src/net/http
Processing net/http:
Matchfile(_tests/big/src/net/http/header.go) => true <nil>
Ignoring test code in response_test.go
Ignoring test code in transport_internal_test.go
Ignoring test code in example_test.go
Matchfile(_tests/big/src/net/http/request.go) => true <nil>
Ignoring test code in main_test.go
Ignoring test code in request_test.go
Ignoring test code in cookie_test.go
Ignoring test code in header_test.go
Matchfile(_tests/big/src/net/http/roundtrip.go) => true <nil>
Ignoring test code in responsewrite_test.go
Ignoring test code in export_test.go
Ignoring test code in fs_test.go
Matchfile(_tests/big/src/net/http/client.go) => true <nil>
Matchfile(_tests/big/src/net/http/transport.go) => true <nil>
Matchfile(_tests/big/src/net/http/fs.go) => true <nil>
Matchfile(_tests/big/src/net/http/triv.go) => false <nil>
Ignoring test code in requestwrite_test.go
Matchfile(_tests/big/src/net/http/method.go) => true <nil>
Ignoring test code in sniff_test.go
Ignoring test code in npn_test.go
Matchfile(_tests/big/src/net/http/cookie.go) => true <nil>
Ignoring test code in transport_test.go
Matchfile(_tests/big/src/net/http/filetransport.go) => true <nil>
Matchfile(_tests/big/src/net/http/race.go) => false <nil>
Ignoring test code in filetransport_test.go
Ignoring test code in range_test.go
Matchfile(_tests/big/src/net/http/status.go) => true <nil>
Matchfile(_tests/big/src/net/http/socks_bundle.go) => true <nil>
Ignoring test code in client_test.go
Matchfile(_tests/big/src/net/http/jar.go) => true <nil>
Matchfile(_tests/big/src/net/http/sniff.go) => true <nil>
Ignoring test code in transfer_test.go
Matchfile(_tests/big/src/net/http/doc.go) => true <nil>
Matchfile(_tests/big/src/net/http/h2_bundle.go) => true <nil>
Ignoring test code in http_test.go
Matchfile(_tests/big/src/net/http/http.go) => true <nil>
Matchfile(_tests/big/src/net/http/transfer.go) => true <nil>
Ignoring test code in clientserver_test.go
Ignoring test code in readrequest_test.go
Ignoring test code in serve_test.go
Matchfile(_tests/big/src/net/http/roundtrip_js.go) => false <nil>
Ignoring test code in proxy_test.go
Matchfile(_tests/big/src/net/http/server.go) => true <nil>
Matchfile(_tests/big/src/net/http/response.go) => true <nil>
Processing package=net/http:
Walking from _tests/big/src to _tests/big/src/net/http/cgi
Processing net/http/cgi:
Ignoring test code in child_test.go
Ignoring test code in host_test.go
Ignoring test code in matryoshka_test.go
Ignoring test code in posix_test.go
Ignoring test code in plan9_test.go
Matchfile(_tests/big/src/net/http/cgi/host.go) => true <nil>
Matchfile(_tests/big/src/net/http/cgi/child.go) => true <nil>
Processing package=net/http/cgi:
Excluding _tests/big/src/net/http/cgi/testdata
Walking from _tests/big/src to _tests/big/src/net/http/cookiejar
Processing net/http/cookiejar:
Ignoring test code in example_test.go
Matchfile(_tests/big/src/net/http/cookiejar/punycode.go) => true <nil>
Ignoring test code in punycode_test.go
Ignoring test code in jar_test.go
Ignoring test code in dummy_publicsuffix_test.go
Matchfile(_tests/big/src/net/http/cookiejar/jar.go) => true <nil>
Processing package=net/http/cookiejar:
Walking from _tests/big/src to _tests/big/src/net/http/fcgi
Processing net/http/fcgi:
Matchfile(_tests/big/src/net/http/fcgi/fcgi.go) => true <nil>
Ignoring test code in fcgi_test.go
Matchfile(_tests/big/src/net/http/fcgi/child.go) => true <nil>
Processing package=net/http/fcgi:
Walking from _tests/big/src to _tests/big/src/net/http/httptest
Processing net/http/httptest:
Matchfile(_tests/big/src/net/http/httptest/recorder.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in server_test.go
Matchfile(_tests/big/src/net/http/httptest/httptest.go) => true <nil>
Ignoring test code in httptest_test.go
Ignoring test code in recorder_test.go
Matchfile(_tests/big/src/net/http/httptest/server.go) => true <nil>
Processing package=net/http/httptest:
Walking from _tests/big/src to _tests/big/src/net/http/httptrace
Processing net/http/httptrace:
Ignoring test code in example_test.go
Matchfile(_tests/big/src/net/http/httptrace/trace.go) => true <nil>
Ignoring test code in trace_test.go
Processing package=net/http/httptrace:
Walking from _tests/big/src to _tests/big/src/net/http/httputil
Processing net/http/httputil:
Ignoring test code in example_test.go
Matchfile(_tests/big/src/net/http/httputil/httputil.go) => true <nil>
Matchfile(_tests/big/src/net/http/httputil/dump.go) => true <nil>
Ignoring test code in dump_test.go
Matchfile(_tests/big/src/net/http/httputil/reverseproxy.go) => true <nil>
Ignoring test code in reverseproxy_test.go
Matchfile(_tests/big/src/net/http/httputil/persist.go) => true <nil>
Processing package=net/http/httputil:
Excluding _tests/big/src/net/http/internal
Walking from _tests/big/src to _tests/big/src/net/http/pprof
Processing net/http/pprof:
Ignoring test code in pprof_test.go
Matchfile(_tests/big/src/net/http/pprof/pprof.go) => true <nil>
Processing package=net/http/pprof:
Excluding _tests/big/src/net/http/testdata
Excluding _tests/big/src/net/internal
Walking from _tests/big/src to _tests/big/src/net/mail
Processing net/mail:
Ignoring test code in example_test.go
Ignoring test code in message_test.go
Matchfile(_tests/big/src/net/mail/message.go) => true <nil>
Processing package=net/mail:
Walking from _tests/big/src to _tests/big/src/net/rpc
Processing net/rpc:
Matchfile(_tests/big/src/net/rpc/debug.go) => true <nil>
Matchfile(_tests/big/src/net/rpc/client.go) => true <nil>
Ignoring test code in server_test.go
Ignoring test code in client_test.go
Matchfile(_tests/big/src/net/rpc/server.go) => true <nil>
Processing package=net/rpc:
Walking from _tests/big/src to _tests/big/src/net/rpc/jsonrpc
Processing net/rpc/jsonrpc:
Matchfile(_tests/big/src/net/rpc/jsonrpc/client.go) => true <nil>
Ignoring test code in all_test.go
Matchfile(_tests/big/src/net/rpc/jsonrpc/server.go) => true <nil>
Processing package=net/rpc/jsonrpc:
Walking from _tests/big/src to _tests/big/src/net/smtp
Processing net/smtp:
Ignoring test code in example_test.go
Ignoring test code in smtp_test.go
Matchfile(_tests/big/src/net/smtp/auth.go) => true <nil>
Matchfile(_tests/big/src/net/smtp/smtp.go) => true <nil>
Processing package=net/smtp:
Excluding _tests/big/src/net/testdata
Walking from _tests/big/src to _tests/big/src/net/textproto
Processing net/textproto:
Matchfile(_tests/big/src/net/textproto/header.go) => true <nil>
Ignoring test code in writer_test.go
Matchfile(_tests/big/src/net/textproto/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(_tests/big/src/net/textproto/pipeline.go) => true <nil>
Matchfile(_tests/big/src/net/textproto/writer.go) => true <nil>
Matchfile(_tests/big/src/net/textproto/textproto.go) => true <nil>
Processing package=net/textproto:
Walking from _tests/big/src to _tests/big/src/net/url
Processing net/url:
Ignoring test code in example_test.go
Ignoring test code in url_test.go
Matchfile(_tests/big/src/net/url/url.go) => true <nil>
Processing package=net/url:
TYPE net.Addr:
  _tests/big/src/net/net.go
TYPE net.AddrError:
  _tests/big/src/net/net.go
TYPE net.Buffers:
  _tests/big/src/net/net.go
TYPE net.Conn:
  _tests/big/src/net/net.go
TYPE net.DNSConfigError:
  _tests/big/src/net/net.go
TYPE net.DNSError:
  _tests/big/src/net/net.go
TYPE net.Dialer:
  _tests/big/src/net/dial.go
TYPE net.Error:
  _tests/big/src/net/net.go
TYPE net.Flags:
  _tests/big/src/net/interface.go
TYPE net.HardwareAddr:
  _tests/big/src/net/mac.go
TYPE net.IP:
  _tests/big/src/net/ip.go
TYPE net.IPAddr:
  _tests/big/src/net/iprawsock.go
TYPE net.IPConn:
  _tests/big/src/net/iprawsock.go
TYPE net.IPMask:
  _tests/big/src/net/ip.go
TYPE net.IPNet:
  _tests/big/src/net/ip.go
TYPE net.Interface:
  _tests/big/src/net/interface.go
TYPE net.InvalidAddrError:
  _tests/big/src/net/net.go
TYPE net.ListenConfig:
  _tests/big/src/net/dial.go
TYPE net.Listener:
  _tests/big/src/net/net.go
TYPE net.MX:
  _tests/big/src/net/dnsclient.go
TYPE net.NS:
  _tests/big/src/net/dnsclient.go
TYPE net.OpError:
  _tests/big/src/net/net.go
TYPE net.PacketConn:
  _tests/big/src/net/net.go
TYPE net.ParseError:
  _tests/big/src/net/net.go
TYPE net.Resolver:
  _tests/big/src/net/lookup.go
TYPE net.SRV:
  _tests/big/src/net/dnsclient.go
TYPE net.TCPAddr:
  _tests/big/src/net/tcpsock.go
TYPE net.TCPConn:
  _tests/big/src/net/tcpsock.go
TYPE net.TCPListener:
  _tests/big/src/net/tcpsock.go
TYPE net.UDPAddr:
  _tests/big/src/net/udpsock.go
TYPE net.UDPConn:
  _tests/big/src/net/udpsock.go
TYPE net.UnixAddr:
  _tests/big/src/net/unixsock.go
TYPE net.UnixConn:
  _tests/big/src/net/unixsock.go
TYPE net.UnixListener:
  _tests/big/src/net/unixsock.go
TYPE net.UnknownNetworkError:
  _tests/big/src/net/net.go
TYPE net/http.Client:
  _tests/big/src/net/http/client.go
TYPE net/http.CloseNotifier:
  _tests/big/src/net/http/server.go
TYPE net/http.ConnState:
  _tests/big/src/net/http/server.go
TYPE net/http.Cookie:
  _tests/big/src/net/http/cookie.go
TYPE net/http.CookieJar:
  _tests/big/src/net/http/jar.go
TYPE net/http.Dir:
  _tests/big/src/net/http/fs.go
TYPE net/http.File:
  _tests/big/src/net/http/fs.go
TYPE net/http.FileSystem:
  _tests/big/src/net/http/fs.go
TYPE net/http.Flusher:
  _tests/big/src/net/http/server.go
TYPE net/http.Handler:
  _tests/big/src/net/http/server.go
TYPE net/http.HandlerFunc:
  _tests/big/src/net/http/server.go
TYPE net/http.Header:
  _tests/big/src/net/http/header.go
TYPE net/http.Hijacker:
  _tests/big/src/net/http/server.go
TYPE net/http.ProtocolError:
  _tests/big/src/net/http/request.go
TYPE net/http.PushOptions:
  _tests/big/src/net/http/http.go
TYPE net/http.Pusher:
  _tests/big/src/net/http/http.go
TYPE net/http.Request:
  _tests/big/src/net/http/request.go
TYPE net/http.Response:
  _tests/big/src/net/http/response.go
TYPE net/http.ResponseWriter:
  _tests/big/src/net/http/server.go
TYPE net/http.RoundTripper:
  _tests/big/src/net/http/client.go
TYPE net/http.SameSite:
  _tests/big/src/net/http/cookie.go
TYPE net/http.ServeMux:
  _tests/big/src/net/http/server.go
TYPE net/http.Server:
  _tests/big/src/net/http/server.go
TYPE net/http.Transport:
  _tests/big/src/net/http/transport.go
TYPE net/http/cgi.Handler:
  _tests/big/src/net/http/cgi/host.go
TYPE net/http/cookiejar.Jar:
  _tests/big/src/net/http/cookiejar/jar.go
TYPE net/http/cookiejar.Options:
  _tests/big/src/net/http/cookiejar/jar.go
TYPE net/http/cookiejar.PublicSuffixList:
  _tests/big/src/net/http/cookiejar/jar.go
TYPE net/http/httptest.ResponseRecorder:
  _tests/big/src/net/http/httptest/recorder.go
TYPE net/http/httptest.Server:
  _tests/big/src/net/http/httptest/server.go
TYPE net/http/httptrace.ClientTrace:
  _tests/big/src/net/http/httptrace/trace.go
TYPE net/http/httptrace.DNSDoneInfo:
  _tests/big/src/net/http/httptrace/trace.go
TYPE net/http/httptrace.DNSStartInfo:
  _tests/big/src/net/http/httptrace/trace.go
TYPE net/http/httptrace.GotConnInfo:
  _tests/big/src/net/http/httptrace/trace.go
TYPE net/http/httptrace.WroteRequestInfo:
  _tests/big/src/net/http/httptrace/trace.go
TYPE net/http/httputil.BufferPool:
  _tests/big/src/net/http/httputil/reverseproxy.go
TYPE net/http/httputil.ClientConn:
  _tests/big/src/net/http/httputil/persist.go
TYPE net/http/httputil.ReverseProxy:
  _tests/big/src/net/http/httputil/reverseproxy.go
TYPE net/http/httputil.ServerConn:
  _tests/big/src/net/http/httputil/persist.go
TYPE net/mail.Address:
  _tests/big/src/net/mail/message.go
TYPE net/mail.AddressParser:
  _tests/big/src/net/mail/message.go
TYPE net/mail.Header:
  _tests/big/src/net/mail/message.go
TYPE net/mail.Message:
  _tests/big/src/net/mail/message.go
TYPE net/rpc.Call:
  _tests/big/src/net/rpc/client.go
TYPE net/rpc.Client:
  _tests/big/src/net/rpc/client.go
TYPE net/rpc.ClientCodec:
  _tests/big/src/net/rpc/client.go
TYPE net/rpc.Request:
  _tests/big/src/net/rpc/server.go
TYPE net/rpc.Response:
  _tests/big/src/net/rpc/server.go
TYPE net/rpc.Server:
  _tests/big/src/net/rpc/server.go
TYPE net/rpc.ServerCodec:
  _tests/big/src/net/rpc/server.go
TYPE net/rpc.ServerError:
  _tests/big/src/net/rpc/client.go
TYPE net/smtp.Auth:
  _tests/big/src/net/smtp/auth.go
TYPE net/smtp.Client:
  _tests/big/src/net/smtp/smtp.go
TYPE net/smtp.ServerInfo:
  _tests/big/src/net/smtp/auth.go
TYPE net/textproto.Conn:
  _tests/big/src/net/textproto/textproto.go
TYPE net/textproto.Error:
  _tests/big/src/net/textproto/textproto.go
TYPE net/textproto.MIMEHeader:
  _tests/big/src/net/textproto/header.go
TYPE net/textproto.Pipeline:
  _tests/big/src/net/textproto/pipeline.go
TYPE net/textproto.ProtocolError:
  _tests/big/src/net/textproto/textproto.go
TYPE net/textproto.Reader:
  _tests/big/src/net/textproto/reader.go
TYPE net/textproto.Writer:
  _tests/big/src/net/textproto/writer.go
TYPE net/url.Error:
  _tests/big/src/net/url/url.go
TYPE net/url.EscapeError:
  _tests/big/src/net/url/url.go
TYPE net/url.InvalidHostError:
  _tests/big/src/net/url/url.go
TYPE net/url.URL:
  _tests/big/src/net/url/url.go
TYPE net/url.Userinfo:
  _tests/big/src/net/url/url.go
TYPE net/url.Values:
  _tests/big/src/net/url/url.go
JOKER FUNC net.CIDRMask from net/ip.go:
;; (defn CIDRMask
;;   "CIDRMask returns an IPMask consisting of `ones' 1 bits\nfollowed by 0s up to a total length of `bits' bits.\nFor a mask of this form, CIDRMask is the inverse of IPMask.Size.\n\nGo input arguments: (ones int, bits int)\n\nGo return type: IPMask\n\nJoker input arguments: [^Int ones, ^Int bits]\n\nJoker return type: go.std.net/IPMask"
;;   {:added "1.0"
;;    :go "cIDRMask(_ones, _bits)"}
;;   [^Int _ones, ^Int _bits])

JOKER FUNC net.Dial from net/dial.go:
;; (defn Dial
;;   "Dial connects to the address on the named network.\n\nKnown networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only),\n\"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\"\n(IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and\n\"unixpacket\".\n\nFor TCP and UDP networks, the address has the form \"host:port\".\nThe host must be a literal IP address, or a host name that can be\nresolved to IP addresses.\nThe port must be a literal port number or a service name.\nIf the host is a literal IPv6 address it must be enclosed in square\nbrackets, as in \"[2001:db8::1]:80\" or \"[fe80::1%zone]:80\".\nThe zone specifies the scope of the literal IPv6 address as defined\nin RFC 4007.\nThe functions JoinHostPort and SplitHostPort manipulate a pair of\nhost and port in this form.\nWhen using TCP, and the host resolves to multiple IP addresses,\nDial will try each IP address in order until one succeeds.\n\nExamples:\n\tDial(\"tcp\", \"golang.org:http\")\n\tDial(\"tcp\", \"192.0.2.1:http\")\n\tDial(\"tcp\", \"198.51.100.1:80\")\n\tDial(\"udp\", \"[2001:db8::1]:domain\")\n\tDial(\"udp\", \"[fe80::1%lo0]:53\")\n\tDial(\"tcp\", \":80\")\n\nFor IP networks, the network must be \"ip\", \"ip4\" or \"ip6\" followed\nby a colon and a literal protocol number or a protocol name, and\nthe address has the form \"host\". The host must be a literal IP\naddress or a literal IPv6 address with zone.\nIt depends on each operating system how the operating system\nbehaves with a non-well known protocol number such as \"0\" or \"255\".\n\nExamples:\n\tDial(\"ip4:1\", \"192.0.2.1\")\n\tDial(\"ip6:ipv6-icmp\", \"2001:db8::1\")\n\tDial(\"ip6:58\", \"fe80::1%lo0\")\n\nFor TCP, UDP and IP networks, if the host is empty or a literal\nunspecified IP address, as in \":80\", \"0.0.0.0:80\" or \"[::]:80\" for\nTCP and UDP, \"\", \"0.0.0.0\" or \"::\" for IP, the local system is\nassumed.\n\nFor Unix networks, the address must be a file system path.\n\nGo input arguments: (network string, address string)\n\nGo return type: (Conn, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/Conn Error]"
;;   {:added "1.0"
;;    :go "dial(_network, _address)"}
;;   [^String _network, ^String _address])

JOKER FUNC net.DialIP from net/iprawsock.go:
;; (defn DialIP
;;   "DialIP acts like Dial for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *_net.IPAddr, raddr *_net.IPAddr)\n\nGo return type: (*IPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/IPAddr) laddr, ^(atom-of go.std.net/IPAddr) raddr]\n\nJoker return type: [go.std.net/IPConn Error]"
;;   {:added "1.0"
;;    :go "dialIP(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.IPAddr(_laddr)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.IPAddr(_raddr)))"}
;;   [^String _network, ^Object _laddr, ^Object _raddr])

JOKER FUNC net.DialTCP from net/tcpsock.go:
;; (defn DialTCP
;;   "DialTCP acts like Dial for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *_net.TCPAddr, raddr *_net.TCPAddr)\n\nGo return type: (*TCPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/TCPAddr) laddr, ^(atom-of go.std.net/TCPAddr) raddr]\n\nJoker return type: [go.std.net/TCPConn Error]"
;;   {:added "1.0"
;;    :go "dialTCP(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.TCPAddr(_laddr)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.TCPAddr(_raddr)))"}
;;   [^String _network, ^Object _laddr, ^Object _raddr])

JOKER FUNC net.DialTimeout from net/dial.go:
;; (defn DialTimeout
;;   "DialTimeout acts like Dial but takes a timeout.\n\nThe timeout includes name resolution, if required.\nWhen using TCP, and the host in the address parameter resolves to\nmultiple IP addresses, the timeout is spread over each consecutive\ndial, such that each is given an appropriate fraction of the time\nto connect.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string, timeout time.Duration)\n\nGo return type: (Conn, error)\n\nJoker input arguments: [^String network, ^String address, ^go.std.time/Duration timeout]\n\nJoker return type: [go.std.net/Conn Error]"
;;   {:added "1.0"
;;    :go "dialTimeout(_network, _address, _timeout)"}
;;   [^String _network, ^String _address, ^Native _timeout])

JOKER FUNC net.DialUDP from net/udpsock.go:
;; (defn DialUDP
;;   "DialUDP acts like Dial for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *_net.UDPAddr, raddr *_net.UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UDPAddr) laddr, ^(atom-of go.std.net/UDPAddr) raddr]\n\nJoker return type: [go.std.net/UDPConn Error]"
;;   {:added "1.0"
;;    :go "dialUDP(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.UDPAddr(_laddr)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.UDPAddr(_raddr)))"}
;;   [^String _network, ^Object _laddr, ^Object _raddr])

JOKER FUNC net.DialUnix from net/unixsock.go:
;; (defn DialUnix
;;   "DialUnix acts like Dial for Unix networks.\n\nThe network must be a Unix network name; see func Dial for details.\n\nIf laddr is non-nil, it is used as the local address for the\nconnection.\n\nGo input arguments: (network string, laddr *_net.UnixAddr, raddr *_net.UnixAddr)\n\nGo return type: (*UnixConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr, ^(atom-of go.std.net/UnixAddr) raddr]\n\nJoker return type: [go.std.net/UnixConn Error]"
;;   {:added "1.0"
;;    :go "dialUnix(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.UnixAddr(_laddr)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.UnixAddr(_raddr)))"}
;;   [^String _network, ^Object _laddr, ^Object _raddr])

JOKER FUNC net.FileConn from net/file.go:
;; (defn FileConn
;;   "FileConn returns a copy of the network connection corresponding to\nthe open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo input arguments: (f *_net.File)\n\nGo return type: (c Conn, err error)\n\nJoker input arguments: [^(atom-of go.std.os/File) f]\n\nJoker return type: [go.std.net/Conn Error]"
;;   {:added "1.0"
;;    :go "fileConn(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.File(_f)))"}
;;   [^Object _f])

JOKER FUNC net.FileListener from net/file.go:
;; (defn FileListener
;;   "FileListener returns a copy of the network listener corresponding\nto the open file f.\nIt is the caller's responsibility to close ln when finished.\nClosing ln does not affect f, and closing f does not affect ln.\n\nGo input arguments: (f *_net.File)\n\nGo return type: (ln Listener, err error)\n\nJoker input arguments: [^(atom-of go.std.os/File) f]\n\nJoker return type: [go.std.net/Listener Error]"
;;   {:added "1.0"
;;    :go "fileListener(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.File(_f)))"}
;;   [^Object _f])

JOKER FUNC net.FilePacketConn from net/file.go:
;; (defn FilePacketConn
;;   "FilePacketConn returns a copy of the packet network connection\ncorresponding to the open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo input arguments: (f *_net.File)\n\nGo return type: (c PacketConn, err error)\n\nJoker input arguments: [^(atom-of go.std.os/File) f]\n\nJoker return type: [go.std.net/PacketConn Error]"
;;   {:added "1.0"
;;    :go "filePacketConn(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.File(_f)))"}
;;   [^Object _f])

JOKER FUNC net.IPv4 from net/ip.go:
;; (defn IPv4
;;   "IPv4 returns the IP address (in 16-byte form) of the\nIPv4 address a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo return type: IP\n\nJoker input arguments: [^Byte a, ^Byte b, ^Byte c, ^Byte d]\n\nJoker return type: go.std.net/IP"
;;   {:added "1.0"
;;    :go "iPv4(_a, _b, _c, _d)"}
;;   [^Byte _a, ^Byte _b, ^Byte _c, ^Byte _d])

JOKER FUNC net.IPv4Mask from net/ip.go:
;; (defn IPv4Mask
;;   "IPv4Mask returns the IP mask (in 4-byte form) of the\nIPv4 mask a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo return type: IPMask\n\nJoker input arguments: [^Byte a, ^Byte b, ^Byte c, ^Byte d]\n\nJoker return type: go.std.net/IPMask"
;;   {:added "1.0"
;;    :go "iPv4Mask(_a, _b, _c, _d)"}
;;   [^Byte _a, ^Byte _b, ^Byte _c, ^Byte _d])

JOKER FUNC net.InterfaceAddrs from net/interface.go:
;; (defn InterfaceAddrs
;;   "InterfaceAddrs returns a list of the system's unicast interface\naddresses.\n\nThe returned list does not identify the associated interface; use\nInterfaces and Interface.Addrs for more detail.\n\nGo return type: ([]Addr, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of go.std.net/Addr) Error]"
;;   {:added "1.0"
;;    :go "interfaceAddrs()"}
;;   [])

JOKER FUNC net.InterfaceByIndex from net/interface.go:
;; (defn InterfaceByIndex
;;   "InterfaceByIndex returns the interface specified by index.\n\nOn Solaris, it returns one of the logical network interfaces\nsharing the logical data link; for more precision use\nInterfaceByName.\n\nGo input arguments: (index int)\n\nGo return type: (*Interface, error)\n\nJoker input arguments: [^Int index]\n\nJoker return type: [go.std.net/Interface Error]"
;;   {:added "1.0"
;;    :go "interfaceByIndex(_index)"}
;;   [^Int _index])

JOKER FUNC net.InterfaceByName from net/interface.go:
;; (defn InterfaceByName
;;   "InterfaceByName returns the interface specified by name.\n\nGo input arguments: (name string)\n\nGo return type: (*Interface, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [go.std.net/Interface Error]"
;;   {:added "1.0"
;;    :go "interfaceByName(_name)"}
;;   [^String _name])

JOKER FUNC net.Interfaces from net/interface.go:
;; (defn Interfaces
;;   "Interfaces returns a list of the system's network interfaces.\n\nGo return type: ([]Interface, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of go.std.net/Interface) Error]"
;;   {:added "1.0"
;;    :go "interfaces()"}
;;   [])

JOKER FUNC net.JoinHostPort from net/ipsock.go:
(defn ^"String" JoinHostPort
  "JoinHostPort combines host and port into a network address of the\nform \"host:port\". If host contains a colon, as found in literal\nIPv6 addresses, then JoinHostPort returns \"[host]:port\".\n\nSee func Dial for a description of the host and port parameters.\n\nGo input arguments: (host string, port string)\n\nGo return type: string\n\nJoker input arguments: [^String host, ^String port]\n\nJoker return type: String"
  {:added "1.0"
   :go "net.JoinHostPort(_host, _port)"}
  [^String _host, ^String _port])

JOKER FUNC net.Listen from net/dial.go:
;; (defn Listen
;;   "Listen announces on the local network address.\n\nThe network must be \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\".\n\nFor TCP networks, if the host in the address parameter is empty or\na literal unspecified IP address, Listen listens on all available\nunicast and anycast IP addresses of the local system.\nTo only use IPv4, use network \"tcp4\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe Addr method of Listener can be used to discover the chosen\nport.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (Listener, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/Listener Error]"
;;   {:added "1.0"
;;    :go "listen(_network, _address)"}
;;   [^String _network, ^String _address])

JOKER FUNC net.ListenIP from net/iprawsock.go:
;; (defn ListenIP
;;   "ListenIP acts like ListenPacket for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenIP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\n\nGo input arguments: (network string, laddr *_net.IPAddr)\n\nGo return type: (*IPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/IPAddr) laddr]\n\nJoker return type: [go.std.net/IPConn Error]"
;;   {:added "1.0"
;;    :go "listenIP(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.IPAddr(_laddr)))"}
;;   [^String _network, ^Object _laddr])

JOKER FUNC net.ListenMulticastUDP from net/udpsock.go:
;; (defn ListenMulticastUDP
;;   "ListenMulticastUDP acts like ListenPacket for UDP networks but\ntakes a group address on a specific network interface.\n\nThe network must be a UDP network name; see func Dial for details.\n\nListenMulticastUDP listens on all available IP addresses of the\nlocal system including the group, multicast IP address.\nIf ifi is nil, ListenMulticastUDP uses the system-assigned\nmulticast interface, although this is not recommended because the\nassignment depends on platforms and sometimes it might require\nrouting configuration.\nIf the Port field of gaddr is 0, a port number is automatically\nchosen.\n\nListenMulticastUDP is just for convenience of simple, small\napplications. There are golang.org/x/net/ipv4 and\ngolang.org/x/net/ipv6 packages for general purpose uses.\n\nGo input arguments: (network string, ifi *_net.Interface, gaddr *_net.UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/Interface) ifi, ^(atom-of go.std.net/UDPAddr) gaddr]\n\nJoker return type: [go.std.net/UDPConn Error]"
;;   {:added "1.0"
;;    :go "listenMulticastUDP(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.Interface(_ifi)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.UDPAddr(_gaddr)))"}
;;   [^String _network, ^Object _ifi, ^Object _gaddr])

JOKER FUNC net.ListenPacket from net/dial.go:
;; (defn ListenPacket
;;   "ListenPacket announces on the local network address.\n\nThe network must be \"udp\", \"udp4\", \"udp6\", \"unixgram\", or an IP\ntransport. The IP transports are \"ip\", \"ip4\", or \"ip6\" followed by\na colon and a literal protocol number or a protocol name, as in\n\"ip:1\" or \"ip:icmp\".\n\nFor UDP and IP networks, if the host in the address parameter is\nempty or a literal unspecified IP address, ListenPacket listens on\nall available IP addresses of the local system except multicast IP\naddresses.\nTo only use IPv4, use network \"udp4\" or \"ip4:proto\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe LocalAddr method of PacketConn can be used to discover the\nchosen port.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (PacketConn, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/PacketConn Error]"
;;   {:added "1.0"
;;    :go "listenPacket(_network, _address)"}
;;   [^String _network, ^String _address])

JOKER FUNC net.ListenTCP from net/tcpsock.go:
;; (defn ListenTCP
;;   "ListenTCP acts like Listen for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenTCP listens on all available unicast and anycast IP addresses\nof the local system.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo input arguments: (network string, laddr *_net.TCPAddr)\n\nGo return type: (*TCPListener, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/TCPAddr) laddr]\n\nJoker return type: [go.std.net/TCPListener Error]"
;;   {:added "1.0"
;;    :go "listenTCP(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.TCPAddr(_laddr)))"}
;;   [^String _network, ^Object _laddr])

JOKER FUNC net.ListenUDP from net/udpsock.go:
;; (defn ListenUDP
;;   "ListenUDP acts like ListenPacket for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenUDP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo input arguments: (network string, laddr *_net.UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UDPAddr) laddr]\n\nJoker return type: [go.std.net/UDPConn Error]"
;;   {:added "1.0"
;;    :go "listenUDP(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.UDPAddr(_laddr)))"}
;;   [^String _network, ^Object _laddr])

JOKER FUNC net.ListenUnix from net/unixsock.go:
;; (defn ListenUnix
;;   "ListenUnix acts like Listen for Unix networks.\n\nThe network must be \"unix\" or \"unixpacket\".\n\nGo input arguments: (network string, laddr *_net.UnixAddr)\n\nGo return type: (*UnixListener, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr]\n\nJoker return type: [go.std.net/UnixListener Error]"
;;   {:added "1.0"
;;    :go "listenUnix(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.UnixAddr(_laddr)))"}
;;   [^String _network, ^Object _laddr])

JOKER FUNC net.ListenUnixgram from net/unixsock.go:
;; (defn ListenUnixgram
;;   "ListenUnixgram acts like ListenPacket for Unix networks.\n\nThe network must be \"unixgram\".\n\nGo input arguments: (network string, laddr *_net.UnixAddr)\n\nGo return type: (*UnixConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr]\n\nJoker return type: [go.std.net/UnixConn Error]"
;;   {:added "1.0"
;;    :go "listenUnixgram(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.UnixAddr(_laddr)))"}
;;   [^String _network, ^Object _laddr])

JOKER FUNC net.LookupAddr from net/lookup.go:
(defn LookupAddr
  "LookupAddr performs a reverse lookup for the given address, returning a list\nof names mapping to that address.\n\nWhen using the host C library resolver, at most one result will be\nreturned. To bypass the host resolver, use a custom Resolver.\n\nGo input arguments: (addr string)\n\nGo return type: (names []string, err error)\n\nJoker input arguments: [^String addr]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "lookupAddr(_addr)"}
  [^String _addr])

JOKER FUNC net.LookupCNAME from net/lookup.go:
(defn LookupCNAME
  "LookupCNAME returns the canonical name for the given host.\nCallers that do not care about the canonical name can call\nLookupHost or LookupIP directly; both take care of resolving\nthe canonical name as part of the lookup.\n\nA canonical name is the final name after following zero\nor more CNAME records.\nLookupCNAME does not return an error if host does not\ncontain DNS \"CNAME\" records, as long as host resolves to\naddress records.\n\nGo input arguments: (host string)\n\nGo return type: (cname string, err error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "lookupCNAME(_host)"}
  [^String _host])

JOKER FUNC net.LookupHost from net/lookup.go:
(defn LookupHost
  "LookupHost looks up the given host using the local resolver.\nIt returns a slice of that host's addresses.\n\nGo input arguments: (host string)\n\nGo return type: (addrs []string, err error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "lookupHost(_host)"}
  [^String _host])

JOKER FUNC net.LookupIP from net/lookup.go:
;; (defn LookupIP
;;   "LookupIP looks up host using the local resolver.\nIt returns a slice of that host's IPv4 and IPv6 addresses.\n\nGo input arguments: (host string)\n\nGo return type: ([]IP, error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [(vector-of go.std.net/IP) Error]"
;;   {:added "1.0"
;;    :go "lookupIP(_host)"}
;;   [^String _host])

JOKER FUNC net.LookupMX from net/lookup.go:
;; (defn LookupMX
;;   "LookupMX returns the DNS MX records for the given domain name sorted by preference.\n\nGo input arguments: (name string)\n\nGo return type: ([]*MX, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of go.std.net/MX) Error]"
;;   {:added "1.0"
;;    :go "lookupMX(_name)"}
;;   [^String _name])

JOKER FUNC net.LookupNS from net/lookup.go:
;; (defn LookupNS
;;   "LookupNS returns the DNS NS records for the given domain name.\n\nGo input arguments: (name string)\n\nGo return type: ([]*NS, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of go.std.net/NS) Error]"
;;   {:added "1.0"
;;    :go "lookupNS(_name)"}
;;   [^String _name])

JOKER FUNC net.LookupPort from net/lookup.go:
(defn LookupPort
  "LookupPort looks up the port for the given network and service.\n\nGo input arguments: (network string, service string)\n\nGo return type: (port int, err error)\n\nJoker input arguments: [^String network, ^String service]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "lookupPort(_network, _service)"}
  [^String _network, ^String _service])

JOKER FUNC net.LookupSRV from net/lookup.go:
;; (defn LookupSRV
;;   "LookupSRV tries to resolve an SRV query of the given service,\nprotocol, and domain name. The proto is \"tcp\" or \"udp\".\nThe returned records are sorted by priority and randomized\nby weight within a priority.\n\nLookupSRV constructs the DNS name to look up following RFC 2782.\nThat is, it looks up _service._proto.name. To accommodate services\npublishing SRV records under non-standard names, if both service\nand proto are empty strings, LookupSRV looks up name directly.\n\nGo input arguments: (service string, proto string, name string)\n\nGo return type: (cname string, addrs []*SRV, err error)\n\nJoker input arguments: [^String service, ^String proto, ^String name]\n\nJoker return type: [String (vector-of go.std.net/SRV) Error]"
;;   {:added "1.0"
;;    :go "lookupSRV(_service, _proto, _name)"}
;;   [^String _service, ^String _proto, ^String _name])

JOKER FUNC net.LookupTXT from net/lookup.go:
(defn LookupTXT
  "LookupTXT returns the DNS TXT records for the given domain name.\n\nGo input arguments: (name string)\n\nGo return type: ([]string, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "lookupTXT(_name)"}
  [^String _name])

JOKER FUNC net.ParseCIDR from net/ip.go:
;; (defn ParseCIDR
;;   "ParseCIDR parses s as a CIDR notation IP address and prefix length,\nlike \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in\nRFC 4632 and RFC 4291.\n\nIt returns the IP address and the network implied by the IP and\nprefix length.\nFor example, ParseCIDR(\"192.0.2.1/24\") returns the IP address\n192.0.2.1 and the network 192.0.2.0/24.\n\nGo input arguments: (s string)\n\nGo return type: (IP, *IPNet, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [go.std.net/IP go.std.net/IPNet Error]"
;;   {:added "1.0"
;;    :go "parseCIDR(_s)"}
;;   [^String _s])

JOKER FUNC net.ParseIP from net/ip.go:
;; (defn ParseIP
;;   "ParseIP parses s as an IP address, returning the result.\nThe string s can be in dotted decimal (\"192.0.2.1\")\nor IPv6 (\"2001:db8::68\") form.\nIf s is not a valid textual representation of an IP address,\nParseIP returns nil.\n\nGo input arguments: (s string)\n\nGo return type: IP\n\nJoker input arguments: [^String s]\n\nJoker return type: go.std.net/IP"
;;   {:added "1.0"
;;    :go "parseIP(_s)"}
;;   [^String _s])

JOKER FUNC net.ParseMAC from net/mac.go:
;; (defn ParseMAC
;;   "ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet\nIP over InfiniBand link-layer address using one of the following formats:\n  01:23:45:67:89:ab\n  01:23:45:67:89:ab:cd:ef\n  01:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00\n  01-23-45-67-89-ab\n  01-23-45-67-89-ab-cd-ef\n  01-23-45-67-89-ab-cd-ef-00-00-01-23-45-67-89-ab-cd-ef-00-00\n  0123.4567.89ab\n  0123.4567.89ab.cdef\n  0123.4567.89ab.cdef.0000.0123.4567.89ab.cdef.0000\n\nGo input arguments: (s string)\n\nGo return type: (hw HardwareAddr, err error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [go.std.net/HardwareAddr Error]"
;;   {:added "1.0"
;;    :go "parseMAC(_s)"}
;;   [^String _s])

JOKER FUNC net.Pipe from net/pipe.go:
;; (defn Pipe
;;   "Pipe creates a synchronous, in-memory, full duplex\nnetwork connection; both ends implement the Conn interface.\nReads on one end are matched with writes on the other,\ncopying data directly between the two; there is no internal\nbuffering.\n\nGo return type: (Conn, Conn)\n\nJoker input arguments: []\n\nJoker return type: [go.std.net/Conn go.std.net/Conn]"
;;   {:added "1.0"
;;    :go "pipe()"}
;;   [])

JOKER FUNC net.ResolveIPAddr from net/iprawsock.go:
;; (defn ResolveIPAddr
;;   "ResolveIPAddr returns an address of IP end point.\n\nThe network must be an IP network name.\n\nIf the host in the address parameter is not a literal IP address,\nResolveIPAddr resolves the address to an address of IP end point.\nOtherwise, it parses the address as a literal IP address.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*IPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/IPAddr Error]"
;;   {:added "1.0"
;;    :go "resolveIPAddr(_network, _address)"}
;;   [^String _network, ^String _address])

JOKER FUNC net.ResolveTCPAddr from net/tcpsock.go:
;; (defn ResolveTCPAddr
;;   "ResolveTCPAddr returns an address of TCP end point.\n\nThe network must be a TCP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveTCPAddr resolves the\naddress to an address of TCP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*TCPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/TCPAddr Error]"
;;   {:added "1.0"
;;    :go "resolveTCPAddr(_network, _address)"}
;;   [^String _network, ^String _address])

JOKER FUNC net.ResolveUDPAddr from net/udpsock.go:
;; (defn ResolveUDPAddr
;;   "ResolveUDPAddr returns an address of UDP end point.\n\nThe network must be a UDP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveUDPAddr resolves the\naddress to an address of UDP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*UDPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/UDPAddr Error]"
;;   {:added "1.0"
;;    :go "resolveUDPAddr(_network, _address)"}
;;   [^String _network, ^String _address])

JOKER FUNC net.ResolveUnixAddr from net/unixsock.go:
;; (defn ResolveUnixAddr
;;   "ResolveUnixAddr returns an address of Unix domain socket end point.\n\nThe network must be a Unix network name.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*UnixAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/UnixAddr Error]"
;;   {:added "1.0"
;;    :go "resolveUnixAddr(_network, _address)"}
;;   [^String _network, ^String _address])

JOKER FUNC net.SplitHostPort from net/ipsock.go:
(defn SplitHostPort
  "SplitHostPort splits a network address of the form \"host:port\",\n\"host%zone:port\", \"[host]:port\" or \"[host%zone]:port\" into host or\nhost%zone and port.\n\nA literal IPv6 address in hostport must be enclosed in square\nbrackets, as in \"[::1]:80\", \"[::1%lo0]:80\".\n\nSee func Dial for a description of the hostport parameter, and host\nand port results.\n\nGo input arguments: (hostport string)\n\nGo return type: (host string, port string, err error)\n\nJoker input arguments: [^String hostport]\n\nJoker return type: [String String Error]"
  {:added "1.0"
   :go "splitHostPort(_hostport)"}
  [^String _hostport])

JOKER FUNC net/http.CanonicalHeaderKey from net/http/header.go:
(defn ^"String" CanonicalHeaderKey
  "CanonicalHeaderKey returns the canonical format of the\nheader key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.CanonicalHeaderKey(_s)"}
  [^String _s])

JOKER FUNC net/http.DetectContentType from net/http/sniff.go:
;; (defn ^"String" DetectContentType
;;   "DetectContentType implements the algorithm described\nat https://mimesniff.spec.whatwg.org/ to determine the\nContent-Type of the given data. It considers at most the\nfirst 512 bytes of data. DetectContentType always returns\na valid MIME type: if it cannot determine a more specific one, it\nreturns \"application/octet-stream\".\n\nGo input arguments: (data []byte)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "http.DetectContentType(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC net/http.Error from net/http/server.go:
;; (defn Error
;;   "Error replies to the request with the specified error message and HTTP code.\nIt does not otherwise end the request; the caller should ensure no further\nwrites are done to w.\nThe error message should be plain text.\n\nGo input arguments: (w net/http.ResponseWriter, error string, code int)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^String error, ^Int code]"
;;   {:added "1.0"
;;    :go "error(_w, _error, _code)"}
;;   [^Native _w, ^String _error, ^Int _code])

JOKER FUNC net/http.FileServer from net/http/fs.go:
;; (defn FileServer
;;   "FileServer returns a handler that serves HTTP requests\nwith the contents of the file system rooted at root.\n\nTo use the operating system's file system implementation,\nuse http.Dir:\n\n    http.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))\n\nAs a special case, the returned file server redirects any request\nending in \"/index.html\" to the same path, without the final\n\"index.html\".\n\nGo input arguments: (root net/http.FileSystem)\n\nGo return type: Handler\n\nJoker input arguments: [^go.std.net.http/FileSystem root]\n\nJoker return type: go.std.net.http/Handler"
;;   {:added "1.0"
;;    :go "fileServer(_root)"}
;;   [^Native _root])

JOKER FUNC net/http.Get from net/http/client.go:
;; (defn Get
;;   "Get issues a GET to the specified URL. If the response is one of\nthe following redirect codes, Get follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nAn error is returned if there were too many redirects or if there\nwas an HTTP protocol error. A non-2xx response doesn't cause an\nerror. Any returned error will be of type *url.Error. The url.Error\nvalue's Timeout method will report true if request timed out or was\ncanceled.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nGet is a wrapper around DefaultClient.Get.\n\nTo make a request with custom headers, use NewRequest and\nDefaultClient.Do.\n\nGo input arguments: (url string)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker return type: [go.std.net.http/Response Error]"
;;   {:added "1.0"
;;    :go "get(_url)"}
;;   [^String _url])

JOKER FUNC net/http.Handle from net/http/server.go:
;; (defn Handle
;;   "Handle registers the handler for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler net/http.Handler)\n\nJoker input arguments: [^String pattern, ^go.std.net.http/Handler handler]"
;;   {:added "1.0"
;;    :go "handle(_pattern, _handler)"}
;;   [^String _pattern, ^Native _handler])

JOKER FUNC net/http.HandleFunc from net/http/server.go:
;; (defn HandleFunc
;;   "HandleFunc registers the handler function for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler func)\n\nJoker input arguments: [^String pattern, ^fn handler]"
;;   {:added "1.0"
;;    :go "handleFunc(_pattern, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String _pattern, ^fn _handler])

JOKER FUNC net/http.Head from net/http/client.go:
;; (defn Head
;;   "Head issues a HEAD to the specified URL. If the response is one of\nthe following redirect codes, Head follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nHead is a wrapper around DefaultClient.Head\n\nGo input arguments: (url string)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker return type: [go.std.net.http/Response Error]"
;;   {:added "1.0"
;;    :go "head(_url)"}
;;   [^String _url])

JOKER FUNC net/http.ListenAndServe from net/http/server.go:
(defn ^"Error" ListenAndServe
  "ListenAndServe listens on the TCP network address addr and then calls\nServe with handler to handle requests on incoming connections.\nAccepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error.\n\nGo input arguments: (addr string, handler net/http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
  {:added "1.0"
   :go "http.ListenAndServe(_addr, _handler)"}
  [^String _addr, ^Native _handler])

JOKER FUNC net/http.ListenAndServeTLS from net/http/server.go:
(defn ^"Error" ListenAndServeTLS
  "ListenAndServeTLS acts identically to ListenAndServe, except that it\nexpects HTTPS connections. Additionally, files containing a certificate and\nmatching private key for the server must be provided. If the certificate\nis signed by a certificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nGo input arguments: (addr string, certFile string, keyFile string, handler net/http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^String certFile, ^String keyFile, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
  {:added "1.0"
   :go "http.ListenAndServeTLS(_addr, _certFile, _keyFile, _handler)"}
  [^String _addr, ^String _certFile, ^String _keyFile, ^Native _handler])

JOKER FUNC net/http.MaxBytesReader from net/http/request.go:
;; (defn MaxBytesReader
;;   "MaxBytesReader is similar to io.LimitReader but is intended for\nlimiting the size of incoming request bodies. In contrast to\nio.LimitReader, MaxBytesReader's result is a ReadCloser, returns a\nnon-EOF error for a Read beyond the limit, and closes the\nunderlying reader when its Close method is called.\n\nMaxBytesReader prevents clients from accidentally or maliciously\nsending a large request and wasting server resources.\n\nGo input arguments: (w net/http.ResponseWriter, r io.ReadCloser, n int64)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^go.std.io/ReadCloser r, ^Int64 n]\n\nJoker return type: ABEND042(cannot find typename io.ReadCloser)"
;;   {:added "1.0"
;;    :go "maxBytesReader(_w, _r, _n)"}
;;   [^Native _w, ^Native _r, ^Int64 _n])

JOKER FUNC net/http.NewFileTransport from net/http/filetransport.go:
;; (defn NewFileTransport
;;   "NewFileTransport returns a new RoundTripper, serving the provided\nFileSystem. The returned RoundTripper ignores the URL host in its\nincoming requests, as well as most other properties of the\nrequest.\n\nThe typical use case for NewFileTransport is to register the \"file\"\nprotocol with a Transport, as in:\n\n  t := &http.Transport{}\n  t.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))\n  c := &http.Client{Transport: t}\n  res, err := c.Get(\"file:///etc/passwd\")\n  ...\n\nGo input arguments: (fs net/http.FileSystem)\n\nGo return type: RoundTripper\n\nJoker input arguments: [^go.std.net.http/FileSystem fs]\n\nJoker return type: go.std.net.http/RoundTripper"
;;   {:added "1.0"
;;    :go "newFileTransport(_fs)"}
;;   [^Native _fs])

JOKER FUNC net/http.NewRequest from net/http/request.go:
;; (defn NewRequest
;;   "NewRequest returns a new Request given a method, URL, and optional body.\n\nIf the provided body is also an io.Closer, the returned\nRequest.Body is set to body and will be closed by the Client\nmethods Do, Post, and PostForm, and Transport.RoundTrip.\n\nNewRequest returns a Request suitable for use with Client.Do or\nTransport.RoundTrip. To create a request for use with testing a\nServer Handler, either use the NewRequest function in the\nnet/http/httptest package, use ReadRequest, or manually update the\nRequest fields. See the Request type's documentation for the\ndifference between inbound and outbound request fields.\n\nIf body is of type *bytes.Buffer, *bytes.Reader, or\n*strings.Reader, the returned request's ContentLength is set to its\nexact value (instead of -1), GetBody is populated (so 307 and 308\nredirects can replay the body), and Body is set to NoBody if the\nContentLength is 0.\n\nGo input arguments: (method string, url string, body io.Reader)\n\nGo return type: (*Request, error)\n\nJoker input arguments: [^String method, ^String url, ^go.std.io/Reader body]\n\nJoker return type: [go.std.net.http/Request Error]"
;;   {:added "1.0"
;;    :go "newRequest(_method, _url, _body)"}
;;   [^String _method, ^String _url, ^Native _body])

JOKER FUNC net/http.NewServeMux from net/http/server.go:
;; (defn NewServeMux
;;   "NewServeMux allocates and returns a new ServeMux.\n\nGo return type: *ServeMux\n\nJoker input arguments: []\n\nJoker return type: go.std.net.http/ServeMux"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newServeMux())"}
;;   [])

JOKER FUNC net/http.NotFound from net/http/server.go:
;; (defn NotFound
;;   "NotFound replies to the request with an HTTP 404 not found error.\n\nGo input arguments: (w net/http.ResponseWriter, r *_http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "notFound(_w, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_http.Request(_r)))"}
;;   [^Native _w, ^Object _r])

JOKER FUNC net/http.NotFoundHandler from net/http/server.go:
;; (defn NotFoundHandler
;;   "NotFoundHandler returns a simple request handler\nthat replies to each request with a ``404 page not found'' reply.\n\nGo return type: Handler\n\nJoker input arguments: []\n\nJoker return type: go.std.net.http/Handler"
;;   {:added "1.0"
;;    :go "notFoundHandler()"}
;;   [])

JOKER FUNC net/http.ParseHTTPVersion from net/http/request.go:
(defn ParseHTTPVersion
  "ParseHTTPVersion parses a HTTP version string.\n\"HTTP/1.0\" returns (1, 0, true).\n\nGo input arguments: (vers string)\n\nGo return type: (major int, minor int, ok bool)\n\nJoker input arguments: [^String vers]\n\nJoker return type: [Int Int Bool]"
  {:added "1.0"
   :go "parseHTTPVersion(_vers)"}
  [^String _vers])

JOKER FUNC net/http.ParseTime from net/http/header.go:
;; (defn ParseTime
;;   "ParseTime parses a time header (such as the Date: header),\ntrying each of the three formats allowed by HTTP/1.1:\nTimeFormat, time.RFC850, and time.ANSIC.\n\nGo input arguments: (text string)\n\nGo return type: (t ..., err error)\n\nJoker input arguments: [^String text]\n\nJoker return type: [ABEND042(cannot find typename time.Time) Error]"
;;   {:added "1.0"
;;    :go "parseTime(_text)"}
;;   [^String _text])

JOKER FUNC net/http.Post from net/http/client.go:
;; (defn Post
;;   "Post issues a POST to the specified URL.\n\nCaller should close resp.Body when done reading from it.\n\nIf the provided body is an io.Closer, it is closed after the\nrequest.\n\nPost is a wrapper around DefaultClient.Post.\n\nTo set custom headers, use NewRequest and DefaultClient.Do.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, contentType string, body io.Reader)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^String contentType, ^go.std.io/Reader body]\n\nJoker return type: [go.std.net.http/Response Error]"
;;   {:added "1.0"
;;    :go "post(_url, _contentType, _body)"}
;;   [^String _url, ^String _contentType, ^Native _body])

JOKER FUNC net/http.PostForm from net/http/client.go:
;; (defn PostForm
;;   "PostForm issues a POST to the specified URL, with data's keys and\nvalues URL-encoded as the request body.\n\nThe Content-Type header is set to application/x-www-form-urlencoded.\nTo set other headers, use NewRequest and DefaultClient.Do.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nPostForm is a wrapper around DefaultClient.PostForm.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, data net/url.Values)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^go.std.net.url/Values data]\n\nJoker return type: [go.std.net.http/Response Error]"
;;   {:added "1.0"
;;    :go "postForm(_url, _data)"}
;;   [^String _url, ^Native _data])

JOKER FUNC net/http.ProxyFromEnvironment from net/http/transport.go:
;; (defn ProxyFromEnvironment
;;   "ProxyFromEnvironment returns the URL of the proxy to use for a\ngiven request, as indicated by the environment variables\nHTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions\nthereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https\nrequests.\n\nThe environment values may be either a complete URL or a\n\"host[:port]\", in which case the \"http\" scheme is assumed.\nAn error is returned if the value is a different form.\n\nA nil URL and nil error are returned if no proxy is defined in the\nenvironment, or a proxy should not be used for the given request,\nas defined by NO_PROXY.\n\nAs a special case, if req.URL.Host is \"localhost\" (with or without\na port number), then a nil URL and nil error will be returned.\n\nGo input arguments: (req *_http.Request)\n\nGo return type: (*net/url.URL, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req]\n\nJoker return type: [go.std.net.url/URL Error]"
;;   {:added "1.0"
;;    :go "proxyFromEnvironment(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_http.Request(_req)))"}
;;   [^Object _req])

JOKER FUNC net/http.ProxyURL from net/http/transport.go:
;; (defn ProxyURL
;;   "ProxyURL returns a proxy function (for use in a Transport)\nthat always returns the same URL.\n\nGo input arguments: (fixedURL *_http.URL)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of go.std.net.url/URL) fixedURL]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/transport.go:351:34)"
;;   {:added "1.0"
;;    :go "proxyURL(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_http.URL(_fixedURL)))"}
;;   [^Object _fixedURL])

JOKER FUNC net/http.ReadRequest from net/http/request.go:
;; (defn ReadRequest
;;   "ReadRequest reads and parses an incoming request from b.\n\nReadRequest is a low-level function and should only be used for\nspecialized applications; most code should use the Server to read\nrequests and handle them via the Handler interface. ReadRequest\nonly supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.\n\nGo input arguments: (b *_http.Reader)\n\nGo return type: (*Request, error)\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) b]\n\nJoker return type: [go.std.net.http/Request Error]"
;;   {:added "1.0"
;;    :go "readRequest(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_http.Reader(_b)))"}
;;   [^Object _b])

JOKER FUNC net/http.ReadResponse from net/http/response.go:
;; (defn ReadResponse
;;   "ReadResponse reads and returns an HTTP response from r.\nThe req parameter optionally specifies the Request that corresponds\nto this Response. If nil, a GET request is assumed.\nClients must call resp.Body.Close when finished reading resp.Body.\nAfter that call, clients can inspect resp.Trailer to find key/value\npairs included in the response trailer.\n\nGo input arguments: (r *_http.Reader, req *_http.Request)\n\nGo return type: (*Response, error)\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) r, ^(atom-of go.std.net.http/Request) req]\n\nJoker return type: [go.std.net.http/Response Error]"
;;   {:added "1.0"
;;    :go "readResponse(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_http.Reader(_r)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_http.Request(_req)))"}
;;   [^Object _r, ^Object _req])

JOKER FUNC net/http.Redirect from net/http/server.go:
;; (defn Redirect
;;   "Redirect replies to the request with a redirect to url,\nwhich may be a path relative to the request path.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nIf the Content-Type header has not been set, Redirect sets it\nto \"text/html; charset=utf-8\" and writes a small HTML body.\nSetting the Content-Type header to any value, including nil,\ndisables that behavior.\n\nGo input arguments: (w net/http.ResponseWriter, r *_http.Request, url string, code int)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r, ^String url, ^Int code]"
;;   {:added "1.0"
;;    :go "redirect(_w, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_http.Request(_r)), _url, _code)"}
;;   [^Native _w, ^Object _r, ^String _url, ^Int _code])

JOKER FUNC net/http.RedirectHandler from net/http/server.go:
;; (defn RedirectHandler
;;   "RedirectHandler returns a request handler that redirects\neach request it receives to the given url using the given\nstatus code.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nGo input arguments: (url string, code int)\n\nGo return type: Handler\n\nJoker input arguments: [^String url, ^Int code]\n\nJoker return type: go.std.net.http/Handler"
;;   {:added "1.0"
;;    :go "redirectHandler(_url, _code)"}
;;   [^String _url, ^Int _code])

JOKER FUNC net/http.Serve from net/http/server.go:
(defn ^"Error" Serve
  "Serve accepts incoming HTTP connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nHTTP/2 support is only enabled if the Listener returns *tls.Conn\nconnections and they were configured with \"h2\" in the TLS\nConfig.NextProtos.\n\nServe always returns a non-nil error.\n\nGo input arguments: (l net.Listener, handler net/http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
  {:added "1.0"
   :go "http.Serve(_l, _handler)"}
  [^Native _l, ^Native _handler])

JOKER FUNC net/http.ServeContent from net/http/fs.go:
;; (defn ServeContent
;;   "ServeContent replies to the request using the content in the\nprovided ReadSeeker. The main benefit of ServeContent over io.Copy\nis that it handles Range requests properly, sets the MIME type, and\nhandles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,\nand If-Range requests.\n\nIf the response's Content-Type header is not set, ServeContent\nfirst tries to deduce the type from name's file extension and,\nif that fails, falls back to reading the first block of the content\nand passing it to DetectContentType.\nThe name is otherwise unused; in particular it can be empty and is\nnever sent in the response.\n\nIf modtime is not the zero time or Unix epoch, ServeContent\nincludes it in a Last-Modified header in the response. If the\nrequest includes an If-Modified-Since header, ServeContent uses\nmodtime to decide whether the content needs to be sent at all.\n\nThe content's Seek method must work: ServeContent uses\na seek to the end of the content to determine its size.\n\nIf the caller has set w's ETag header formatted per RFC 7232, section 2.3,\nServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.\n\nNote that *os.File implements the io.ReadSeeker interface.\n\nGo input arguments: (w net/http.ResponseWriter, req *_http.Request, name string, modtime time.Time, content io.ReadSeeker)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) req, ^String name, ^go.std.time/Time modtime, ^go.std.io/ReadSeeker content]"
;;   {:added "1.0"
;;    :go "serveContent(_w, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_http.Request(_req)), _name, _modtime, _content)"}
;;   [^Native _w, ^Object _req, ^String _name, ^Native _modtime, ^Native _content])

JOKER FUNC net/http.ServeFile from net/http/fs.go:
;; (defn ServeFile
;;   "ServeFile replies to the request with the contents of the named\nfile or directory.\n\nIf the provided file or directory name is a relative path, it is\ninterpreted relative to the current directory and may ascend to\nparent directories. If the provided name is constructed from user\ninput, it should be sanitized before calling ServeFile.\n\nAs a precaution, ServeFile will reject requests where r.URL.Path\ncontains a \"..\" path element; this protects against callers who\nmight unsafely use filepath.Join on r.URL.Path without sanitizing\nit and then use that filepath.Join result as the name argument.\n\nAs another special case, ServeFile redirects any request where r.URL.Path\nends in \"/index.html\" to the same path, without the final\n\"index.html\". To avoid such redirects either modify the path or\nuse ServeContent.\n\nOutside of those two special cases, ServeFile does not use\nr.URL.Path for selecting the file or directory to serve; only the\nfile or directory provided in the name argument is used.\n\nGo input arguments: (w net/http.ResponseWriter, r *_http.Request, name string)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r, ^String name]"
;;   {:added "1.0"
;;    :go "serveFile(_w, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_http.Request(_r)), _name)"}
;;   [^Native _w, ^Object _r, ^String _name])

JOKER FUNC net/http.ServeTLS from net/http/server.go:
(defn ^"Error" ServeTLS
  "ServeTLS accepts incoming HTTPS connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nAdditionally, files containing a certificate and matching private key\nfor the server must be provided. If the certificate is signed by a\ncertificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nServeTLS always returns a non-nil error.\n\nGo input arguments: (l net.Listener, handler net/http.Handler, certFile string, keyFile string)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler, ^String certFile, ^String keyFile]\n\nJoker return type: Error"
  {:added "1.0"
   :go "http.ServeTLS(_l, _handler, _certFile, _keyFile)"}
  [^Native _l, ^Native _handler, ^String _certFile, ^String _keyFile])

JOKER FUNC net/http.SetCookie from net/http/cookie.go:
;; (defn SetCookie
;;   "SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.\nThe provided cookie must have a valid Name. Invalid cookies may be\nsilently dropped.\n\nGo input arguments: (w net/http.ResponseWriter, cookie *_http.Cookie)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Cookie) cookie]"
;;   {:added "1.0"
;;    :go "setCookie(_w, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_http.Cookie(_cookie)))"}
;;   [^Native _w, ^Object _cookie])

JOKER FUNC net/http.StatusText from net/http/status.go:
(defn ^"String" StatusText
  "StatusText returns a text for the HTTP status code. It returns the empty\nstring if the code is unknown.\n\nGo input arguments: (code int)\n\nGo return type: string\n\nJoker input arguments: [^Int code]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.StatusText(_code)"}
  [^Int _code])

JOKER FUNC net/http.StripPrefix from net/http/server.go:
;; (defn StripPrefix
;;   "StripPrefix returns a handler that serves HTTP requests\nby removing the given prefix from the request URL's Path\nand invoking the handler h. StripPrefix handles a\nrequest for a path that doesn't begin with prefix by\nreplying with an HTTP 404 not found error.\n\nGo input arguments: (prefix string, h net/http.Handler)\n\nGo return type: Handler\n\nJoker input arguments: [^String prefix, ^go.std.net.http/Handler h]\n\nJoker return type: go.std.net.http/Handler"
;;   {:added "1.0"
;;    :go "stripPrefix(_prefix, _h)"}
;;   [^String _prefix, ^Native _h])

JOKER FUNC net/http.TimeoutHandler from net/http/server.go:
;; (defn TimeoutHandler
;;   "TimeoutHandler returns a Handler that runs h with the given time limit.\n\nThe new Handler calls h.ServeHTTP to handle each request, but if a\ncall runs for longer than its time limit, the handler responds with\na 503 Service Unavailable error and the given message in its body.\n(If msg is empty, a suitable default message will be sent.)\nAfter such a timeout, writes by h to its ResponseWriter will return\nErrHandlerTimeout.\n\nTimeoutHandler buffers all Handler writes to memory and does not\nsupport the Hijacker or Flusher interfaces.\n\nGo input arguments: (h net/http.Handler, dt time.Duration, msg string)\n\nGo return type: Handler\n\nJoker input arguments: [^go.std.net.http/Handler h, ^go.std.time/Duration dt, ^String msg]\n\nJoker return type: go.std.net.http/Handler"
;;   {:added "1.0"
;;    :go "timeoutHandler(_h, _dt, _msg)"}
;;   [^Native _h, ^Native _dt, ^String _msg])

JOKER FUNC net/http/cgi.Request from net/http/cgi/child.go:
;; (defn Request
;;   "Request returns the HTTP request as represented in the current\nenvironment. This assumes the current program is being run\nby a web server in a CGI environment.\nThe returned Request's Body is populated, if applicable.\n\nGo return type: (*net/http.Request, error)\n\nJoker input arguments: []\n\nJoker return type: [go.std.net.http/Request Error]"
;;   {:added "1.0"
;;    :go "request()"}
;;   [])

JOKER FUNC net/http/cgi.RequestFromMap from net/http/cgi/child.go:
;; (defn RequestFromMap
;;   "RequestFromMap creates an http.Request from CGI variables.\nThe returned Request's Body field is not populated.\n\nGo input arguments: (params map[])\n\nGo return type: (*net/http.Request, error)\n\nJoker input arguments: [^{} params]\n\nJoker return type: [go.std.net.http/Request Error]"
;;   {:added "1.0"
;;    :go "requestFromMap(ABEND908(custom-runtime routine not implemented: ConvertToMapTypeHaHa()))"}
;;   [^{} _params])

JOKER FUNC net/http/cgi.Serve from net/http/cgi/child.go:
(defn ^"Error" Serve
  "Serve executes the provided Handler on the currently active CGI\nrequest, if any. If there's no current CGI environment\nan error is returned. The provided handler may be nil to use\nhttp.DefaultServeMux.\n\nGo input arguments: (handler net/http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: Error"
  {:added "1.0"
   :go "cgi.Serve(_handler)"}
  [^Native _handler])

JOKER FUNC net/http/cookiejar.New from net/http/cookiejar/jar.go:
;; (defn New
;;   "New returns a new cookie jar. A nil *Options is equivalent to a zero\nOptions.\n\nGo input arguments: (o *_cookiejar.Options)\n\nGo return type: (*Jar, error)\n\nJoker input arguments: [^(atom-of go.std.net.http.cookiejar/Options) o]\n\nJoker return type: [go.std.net.http.cookiejar/Jar Error]"
;;   {:added "1.0"
;;    :go "new(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_cookiejar.Options(_o)))"}
;;   [^Object _o])

JOKER FUNC net/http/fcgi.ProcessEnv from net/http/fcgi/child.go:
;; (defn ProcessEnv
;;   "ProcessEnv returns FastCGI environment variables associated with the request r\nfor which no effort was made to be included in the request itself - the data\nis hidden in the request's context. As an example, if REMOTE_USER is set for a\nrequest, it will not be found anywhere in r, but it will be included in\nProcessEnv's response (via r's context).\n\nGo input arguments: (r *_fcgi.Request)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) r]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/fcgi/child.go:358:34)"
;;   {:added "1.0"
;;    :go "processEnv(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_fcgi.Request(_r)))"}
;;   [^Object _r])

JOKER FUNC net/http/fcgi.Serve from net/http/fcgi/child.go:
(defn ^"Error" Serve
  "Serve accepts incoming FastCGI connections on the listener l, creating a new\ngoroutine for each. The goroutine reads requests and then calls handler\nto reply to them.\nIf l is nil, Serve accepts connections from os.Stdin.\nIf handler is nil, http.DefaultServeMux is used.\n\nGo input arguments: (l net.Listener, handler net/http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
  {:added "1.0"
   :go "fcgi.Serve(_l, _handler)"}
  [^Native _l, ^Native _handler])

JOKER FUNC net/http/httptest.NewRecorder from net/http/httptest/recorder.go:
;; (defn NewRecorder
;;   "NewRecorder returns an initialized ResponseRecorder.\n\nGo return type: *ResponseRecorder\n\nJoker input arguments: []\n\nJoker return type: go.std.net.http.httptest/ResponseRecorder"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newRecorder())"}
;;   [])

JOKER FUNC net/http/httptest.NewRequest from net/http/httptest/httptest.go:
;; (defn NewRequest
;;   "NewRequest returns a new incoming server Request, suitable\nfor passing to an http.Handler for testing.\n\nThe target is the RFC 7230 \"request-target\": it may be either a\npath or an absolute URL. If target is an absolute URL, the host name\nfrom the URL is used. Otherwise, \"example.com\" is used.\n\nThe TLS field is set to a non-nil dummy value if target has scheme\n\"https\".\n\nThe Request.Proto is always HTTP/1.1.\n\nAn empty method means \"GET\".\n\nThe provided body may be nil. If the body is of type *bytes.Reader,\n*strings.Reader, or *bytes.Buffer, the Request.ContentLength is\nset.\n\nNewRequest panics on error for ease of use in testing, where a\npanic is acceptable.\n\nTo generate a client HTTP request instead of a server request, see\nthe NewRequest function in the net/http package.\n\nGo input arguments: (method string, target string, body io.Reader)\n\nGo return type: *net/http.Request\n\nJoker input arguments: [^String method, ^String target, ^go.std.io/Reader body]\n\nJoker return type: go.std.net.http/Request"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newRequest(_method, _target, _body))"}
;;   [^String _method, ^String _target, ^Native _body])

JOKER FUNC net/http/httptest.NewServer from net/http/httptest/server.go:
;; (defn NewServer
;;   "NewServer starts and returns a new Server.\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler net/http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: go.std.net.http.httptest/Server"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newServer(_handler))"}
;;   [^Native _handler])

JOKER FUNC net/http/httptest.NewTLSServer from net/http/httptest/server.go:
;; (defn NewTLSServer
;;   "NewTLSServer starts and returns a new Server using TLS.\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler net/http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: go.std.net.http.httptest/Server"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newTLSServer(_handler))"}
;;   [^Native _handler])

JOKER FUNC net/http/httptest.NewUnstartedServer from net/http/httptest/server.go:
;; (defn NewUnstartedServer
;;   "NewUnstartedServer returns a new Server but doesn't start it.\n\nAfter changing its configuration, the caller should call Start or\nStartTLS.\n\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler net/http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: go.std.net.http.httptest/Server"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newUnstartedServer(_handler))"}
;;   [^Native _handler])

JOKER FUNC net/http/httptrace.ContextClientTrace from net/http/httptrace/trace.go:
;; (defn ContextClientTrace
;;   "ContextClientTrace returns the ClientTrace associated with the\nprovided context. If none, it returns nil.\n\nGo input arguments: (ctx context.Context)\n\nGo return type: *ClientTrace\n\nJoker input arguments: [^go.std.context/Context ctx]\n\nJoker return type: go.std.net.http.httptrace/ClientTrace"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: contextClientTrace(_ctx))"}
;;   [^Native _ctx])

JOKER FUNC net/http/httptrace.WithClientTrace from net/http/httptrace/trace.go:
;; (defn WithClientTrace
;;   "WithClientTrace returns a new context based on the provided parent\nctx. HTTP client requests made with the returned context will use\nthe provided trace hooks, in addition to any previous hooks\nregistered with ctx. Any hooks defined in the provided trace will\nbe called first.\n\nGo input arguments: (ctx context.Context, trace *_httptrace.ClientTrace)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.context/Context ctx, ^(atom-of go.std.net.http.httptrace/ClientTrace) trace]\n\nJoker return type: ABEND042(cannot find typename context.Context)"
;;   {:added "1.0"
;;    :go "withClientTrace(_ctx, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_httptrace.ClientTrace(_trace)))"}
;;   [^Native _ctx, ^Object _trace])

JOKER FUNC net/http/httputil.DumpRequest from net/http/httputil/dump.go:
;; (defn DumpRequest
;;   "DumpRequest returns the given request in its HTTP/1.x wire\nrepresentation. It should only be used by servers to debug client\nrequests. The returned representation is an approximation only;\nsome details of the initial request are lost while parsing it into\nan http.Request. In particular, the order and case of header field\nnames are lost. The order of values in multi-valued headers is kept\nintact. HTTP/2 requests are dumped in HTTP/1.x form, not in their\noriginal binary representations.\n\nIf body is true, DumpRequest also returns the body. To do so, it\nconsumes req.Body and then replaces it with a new io.ReadCloser\nthat yields the same bytes. If DumpRequest returns an error,\nthe state of req is undefined.\n\nThe documentation for http.Request.Write details which fields\nof req are included in the dump.\n\nGo input arguments: (req *_httputil.Request, body bool)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req, ^Bool body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "dumpRequest(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_httputil.Request(_req)), _body)"}
;;   [^Object _req, ^Bool _body])

JOKER FUNC net/http/httputil.DumpRequestOut from net/http/httputil/dump.go:
;; (defn DumpRequestOut
;;   "DumpRequestOut is like DumpRequest but for outgoing client requests. It\nincludes any headers that the standard http.Transport adds, such as\nUser-Agent.\n\nGo input arguments: (req *_httputil.Request, body bool)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req, ^Bool body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "dumpRequestOut(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_httputil.Request(_req)), _body)"}
;;   [^Object _req, ^Bool _body])

JOKER FUNC net/http/httputil.DumpResponse from net/http/httputil/dump.go:
;; (defn DumpResponse
;;   "DumpResponse is like DumpRequest but dumps a response.\n\nGo input arguments: (resp *_httputil.Response, body bool)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Response) resp, ^Bool body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "dumpResponse(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_httputil.Response(_resp)), _body)"}
;;   [^Object _resp, ^Bool _body])

JOKER FUNC net/http/httputil.NewChunkedReader from net/http/httputil/httputil.go:
;; (defn NewChunkedReader
;;   "NewChunkedReader returns a new chunkedReader that translates the data read from r\nout of HTTP \"chunked\" format before returning it.\nThe chunkedReader returns io.EOF when the final 0-length chunk is read.\n\nNewChunkedReader is not needed by normal applications. The http package\nautomatically decodes chunking when reading response bodies.\n\nGo input arguments: (r io.Reader)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: ABEND042(cannot find typename io.Reader)"
;;   {:added "1.0"
;;    :go "newChunkedReader(_r)"}
;;   [^Native _r])

JOKER FUNC net/http/httputil.NewChunkedWriter from net/http/httputil/httputil.go:
;; (defn NewChunkedWriter
;;   "NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP\n\"chunked\" format before writing them to w. Closing the returned chunkedWriter\nsends the final 0-length chunk that marks the end of the stream but does\nnot send the final CRLF that appears after trailers; trailers and the last\nCRLF must be written separately.\n\nNewChunkedWriter is not needed by normal applications. The http\npackage adds chunking automatically if handlers don't set a\nContent-Length header. Using NewChunkedWriter inside a handler\nwould result in double chunking or chunking with a Content-Length\nlength, both of which are wrong.\n\nGo input arguments: (w io.Writer)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: ABEND042(cannot find typename io.WriteCloser)"
;;   {:added "1.0"
;;    :go "newChunkedWriter(_w)"}
;;   [^Native _w])

JOKER FUNC net/http/httputil.NewClientConn from net/http/httputil/persist.go:
;; (defn NewClientConn
;;   "NewClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo input arguments: (c net.Conn, r *_httputil.Reader)\n\nGo return type: *ClientConn\n\nJoker input arguments: [^go.std.net/Conn c, ^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: go.std.net.http.httputil/ClientConn"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newClientConn(_c, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_httputil.Reader(_r))))"}
;;   [^Native _c, ^Object _r])

JOKER FUNC net/http/httputil.NewProxyClientConn from net/http/httputil/persist.go:
;; (defn NewProxyClientConn
;;   "NewProxyClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo input arguments: (c net.Conn, r *_httputil.Reader)\n\nGo return type: *ClientConn\n\nJoker input arguments: [^go.std.net/Conn c, ^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: go.std.net.http.httputil/ClientConn"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newProxyClientConn(_c, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_httputil.Reader(_r))))"}
;;   [^Native _c, ^Object _r])

JOKER FUNC net/http/httputil.NewServerConn from net/http/httputil/persist.go:
;; (defn NewServerConn
;;   "NewServerConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Server in package net/http instead.\n\nGo input arguments: (c net.Conn, r *_httputil.Reader)\n\nGo return type: *ServerConn\n\nJoker input arguments: [^go.std.net/Conn c, ^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: go.std.net.http.httputil/ServerConn"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newServerConn(_c, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_httputil.Reader(_r))))"}
;;   [^Native _c, ^Object _r])

JOKER FUNC net/http/httputil.NewSingleHostReverseProxy from net/http/httputil/reverseproxy.go:
;; (defn NewSingleHostReverseProxy
;;   "NewSingleHostReverseProxy returns a new ReverseProxy that routes\nURLs to the scheme, host, and base path provided in target. If the\ntarget's path is \"/base\" and the incoming request was for \"/dir\",\nthe target request will be for /base/dir.\nNewSingleHostReverseProxy does not rewrite the Host header.\nTo rewrite Host headers, use ReverseProxy directly with a custom\nDirector policy.\n\nGo input arguments: (target *_httputil.URL)\n\nGo return type: *ReverseProxy\n\nJoker input arguments: [^(atom-of go.std.net.url/URL) target]\n\nJoker return type: go.std.net.http.httputil/ReverseProxy"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newSingleHostReverseProxy(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_httputil.URL(_target))))"}
;;   [^Object _target])

JOKER FUNC net/http/pprof.Cmdline from net/http/pprof/pprof.go:
;; (defn Cmdline
;;   "Cmdline responds with the running program's\ncommand line, with arguments separated by NUL bytes.\nThe package initialization registers it as /debug/pprof/cmdline.\n\nGo input arguments: (w net/http.ResponseWriter, r *_pprof.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "cmdline(_w, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_pprof.Request(_r)))"}
;;   [^Native _w, ^Object _r])

JOKER FUNC net/http/pprof.Handler from net/http/pprof/pprof.go:
;; (defn Handler
;;   "Handler returns an HTTP handler that serves the named profile.\n\nGo input arguments: (name string)\n\nGo return type: net/http.Handler\n\nJoker input arguments: [^String name]\n\nJoker return type: go.std.net.http/Handler"
;;   {:added "1.0"
;;    :go "handler(_name)"}
;;   [^String _name])

JOKER FUNC net/http/pprof.Index from net/http/pprof/pprof.go:
;; (defn Index
;;   "Index responds with the pprof-formatted profile named by the request.\nFor example, \"/debug/pprof/heap\" serves the \"heap\" profile.\nIndex responds to a request for \"/debug/pprof/\" with an HTML page\nlisting the available profiles.\n\nGo input arguments: (w net/http.ResponseWriter, r *_pprof.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "index(_w, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_pprof.Request(_r)))"}
;;   [^Native _w, ^Object _r])

JOKER FUNC net/http/pprof.Profile from net/http/pprof/pprof.go:
;; (defn Profile
;;   "Profile responds with the pprof-formatted cpu profile.\nProfiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.\nThe package initialization registers it as /debug/pprof/profile.\n\nGo input arguments: (w net/http.ResponseWriter, r *_pprof.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "profile(_w, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_pprof.Request(_r)))"}
;;   [^Native _w, ^Object _r])

JOKER FUNC net/http/pprof.Symbol from net/http/pprof/pprof.go:
;; (defn Symbol
;;   "Symbol looks up the program counters listed in the request,\nresponding with a table mapping program counters to function names.\nThe package initialization registers it as /debug/pprof/symbol.\n\nGo input arguments: (w net/http.ResponseWriter, r *_pprof.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "symbol(_w, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_pprof.Request(_r)))"}
;;   [^Native _w, ^Object _r])

JOKER FUNC net/http/pprof.Trace from net/http/pprof/pprof.go:
;; (defn Trace
;;   "Trace responds with the execution trace in binary form.\nTracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.\nThe package initialization registers it as /debug/pprof/trace.\n\nGo input arguments: (w net/http.ResponseWriter, r *_pprof.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "trace(_w, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_pprof.Request(_r)))"}
;;   [^Native _w, ^Object _r])

JOKER FUNC net/mail.ParseAddress from net/mail/message.go:
;; (defn ParseAddress
;;   "Parses a single RFC 5322 address, e.g. \"Barry Gibbs <bg@example.com>\"\n\nGo input arguments: (address string)\n\nGo return type: (*Address, error)\n\nJoker input arguments: [^String address]\n\nJoker return type: [go.std.net.mail/Address Error]"
;;   {:added "1.0"
;;    :go "parseAddress(_address)"}
;;   [^String _address])

JOKER FUNC net/mail.ParseAddressList from net/mail/message.go:
;; (defn ParseAddressList
;;   "ParseAddressList parses the given string as a list of addresses.\n\nGo input arguments: (list string)\n\nGo return type: ([]*Address, error)\n\nJoker input arguments: [^String list]\n\nJoker return type: [(vector-of go.std.net.mail/Address) Error]"
;;   {:added "1.0"
;;    :go "parseAddressList(_list)"}
;;   [^String _list])

JOKER FUNC net/mail.ParseDate from net/mail/message.go:
;; (defn ParseDate
;;   "ParseDate parses an RFC 5322 date string.\n\nGo input arguments: (date string)\n\nGo return type: (..., error)\n\nJoker input arguments: [^String date]\n\nJoker return type: [ABEND042(cannot find typename time.Time) Error]"
;;   {:added "1.0"
;;    :go "parseDate(_date)"}
;;   [^String _date])

JOKER FUNC net/mail.ReadMessage from net/mail/message.go:
;; (defn ReadMessage
;;   "ReadMessage reads a message from r.\nThe headers are parsed, and the body of the message will be available\nfor reading from msg.Body.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (msg *Message, err error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.net.mail/Message Error]"
;;   {:added "1.0"
;;    :go "readMessage(_r)"}
;;   [^Native _r])

JOKER FUNC net/rpc.Accept from net/rpc/server.go:
;; (defn Accept
;;   "Accept accepts connections on the listener and serves requests\nto DefaultServer for each incoming connection.\nAccept blocks; the caller typically invokes it in a go statement.\n\nGo input arguments: (lis net.Listener)\n\nJoker input arguments: [^go.std.net/Listener lis]"
;;   {:added "1.0"
;;    :go "accept(_lis)"}
;;   [^Native _lis])

JOKER FUNC net/rpc.Dial from net/rpc/client.go:
;; (defn Dial
;;   "Dial connects to an RPC server at the specified network address.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net.rpc/Client Error]"
;;   {:added "1.0"
;;    :go "dial(_network, _address)"}
;;   [^String _network, ^String _address])

JOKER FUNC net/rpc.DialHTTP from net/rpc/client.go:
;; (defn DialHTTP
;;   "DialHTTP connects to an HTTP RPC server at the specified network address\nlistening on the default HTTP RPC path.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net.rpc/Client Error]"
;;   {:added "1.0"
;;    :go "dialHTTP(_network, _address)"}
;;   [^String _network, ^String _address])

JOKER FUNC net/rpc.DialHTTPPath from net/rpc/client.go:
;; (defn DialHTTPPath
;;   "DialHTTPPath connects to an HTTP RPC server\nat the specified network address and path.\n\nGo input arguments: (network string, address string, path string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address, ^String path]\n\nJoker return type: [go.std.net.rpc/Client Error]"
;;   {:added "1.0"
;;    :go "dialHTTPPath(_network, _address, _path)"}
;;   [^String _network, ^String _address, ^String _path])

JOKER FUNC net/rpc.HandleHTTP from net/rpc/server.go:
;; (defn HandleHTTP
;;   "HandleHTTP registers an HTTP handler for RPC messages to DefaultServer\non DefaultRPCPath and a debugging handler on DefaultDebugPath.\nIt is still necessary to invoke http.Serve(), typically in a go statement.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "handleHTTP()"}
;;   [])

JOKER FUNC net/rpc.NewClient from net/rpc/client.go:
;; (defn NewClient
;;   "NewClient returns a new Client to handle requests to the\nset of services at the other end of the connection.\nIt adds a buffer to the write side of the connection so\nthe header and payload are sent as a unit.\n\nThe read and write halves of the connection are serialized independently,\nso no interlocking is required. However each half may be accessed\nconcurrently so the implementation of conn should protect against\nconcurrent reads or concurrent writes.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *Client\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: go.std.net.rpc/Client"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newClient(_conn))"}
;;   [^Native _conn])

JOKER FUNC net/rpc.NewClientWithCodec from net/rpc/client.go:
;; (defn NewClientWithCodec
;;   "NewClientWithCodec is like NewClient but uses the specified\ncodec to encode requests and decode responses.\n\nGo input arguments: (codec net/rpc.ClientCodec)\n\nGo return type: *Client\n\nJoker input arguments: [^go.std.net.rpc/ClientCodec codec]\n\nJoker return type: go.std.net.rpc/Client"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newClientWithCodec(_codec))"}
;;   [^Native _codec])

JOKER FUNC net/rpc.NewServer from net/rpc/server.go:
;; (defn NewServer
;;   "NewServer returns a new Server.\n\nGo return type: *Server\n\nJoker input arguments: []\n\nJoker return type: go.std.net.rpc/Server"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newServer())"}
;;   [])

JOKER FUNC net/rpc.Register from net/rpc/server.go:
;; (defn ^"Error" Register
;;   "Register publishes the receiver's methods in the DefaultServer.\n\nGo input arguments: (rcvr interface {})\n\nGo return type: error\n\nJoker input arguments: [^<protocol-or-something> rcvr]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.Register(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _rcvr])

JOKER FUNC net/rpc.RegisterName from net/rpc/server.go:
;; (defn ^"Error" RegisterName
;;   "RegisterName is like Register but uses the provided name for the type\ninstead of the receiver's concrete type.\n\nGo input arguments: (name string, rcvr interface {})\n\nGo return type: error\n\nJoker input arguments: [^String name, ^<protocol-or-something> rcvr]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.RegisterName(_name, ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^String _name, ^<protocol-or-something> _rcvr])

JOKER FUNC net/rpc.ServeCodec from net/rpc/server.go:
;; (defn ServeCodec
;;   "ServeCodec is like ServeConn but uses the specified codec to\ndecode requests and encode responses.\n\nGo input arguments: (codec net/rpc.ServerCodec)\n\nJoker input arguments: [^go.std.net.rpc/ServerCodec codec]"
;;   {:added "1.0"
;;    :go "serveCodec(_codec)"}
;;   [^Native _codec])

JOKER FUNC net/rpc.ServeConn from net/rpc/server.go:
;; (defn ServeConn
;;   "ServeConn runs the DefaultServer on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\nServeConn uses the gob wire format (see package gob) on the\nconnection. To use an alternate codec, use ServeCodec.\nSee NewClient's comment for information about concurrent access.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]"
;;   {:added "1.0"
;;    :go "serveConn(_conn)"}
;;   [^Native _conn])

JOKER FUNC net/rpc.ServeRequest from net/rpc/server.go:
(defn ^"Error" ServeRequest
  "ServeRequest is like ServeCodec but synchronously serves a single request.\nIt does not close the codec upon completion.\n\nGo input arguments: (codec net/rpc.ServerCodec)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net.rpc/ServerCodec codec]\n\nJoker return type: Error"
  {:added "1.0"
   :go "rpc.ServeRequest(_codec)"}
  [^Native _codec])

JOKER FUNC net/rpc/jsonrpc.Dial from net/rpc/jsonrpc/client.go:
;; (defn Dial
;;   "Dial connects to a JSON-RPC server at the specified network address.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*net/rpc.Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net.rpc/Client Error]"
;;   {:added "1.0"
;;    :go "dial(_network, _address)"}
;;   [^String _network, ^String _address])

JOKER FUNC net/rpc/jsonrpc.NewClient from net/rpc/jsonrpc/client.go:
;; (defn NewClient
;;   "NewClient returns a new rpc.Client to handle requests to the\nset of services at the other end of the connection.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *net/rpc.Client\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: go.std.net.rpc/Client"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newClient(_conn))"}
;;   [^Native _conn])

JOKER FUNC net/rpc/jsonrpc.NewClientCodec from net/rpc/jsonrpc/client.go:
;; (defn NewClientCodec
;;   "NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: net/rpc.ClientCodec\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: go.std.net.rpc/ClientCodec"
;;   {:added "1.0"
;;    :go "newClientCodec(_conn)"}
;;   [^Native _conn])

JOKER FUNC net/rpc/jsonrpc.NewServerCodec from net/rpc/jsonrpc/server.go:
;; (defn NewServerCodec
;;   "NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: net/rpc.ServerCodec\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: go.std.net.rpc/ServerCodec"
;;   {:added "1.0"
;;    :go "newServerCodec(_conn)"}
;;   [^Native _conn])

JOKER FUNC net/rpc/jsonrpc.ServeConn from net/rpc/jsonrpc/server.go:
;; (defn ServeConn
;;   "ServeConn runs the JSON-RPC server on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]"
;;   {:added "1.0"
;;    :go "serveConn(_conn)"}
;;   [^Native _conn])

JOKER FUNC net/smtp.CRAMMD5Auth from net/smtp/auth.go:
;; (defn CRAMMD5Auth
;;   "CRAMMD5Auth returns an Auth that implements the CRAM-MD5 authentication\nmechanism as defined in RFC 2195.\nThe returned Auth uses the given username and secret to authenticate\nto the server using the challenge-response mechanism.\n\nGo input arguments: (username string, secret string)\n\nGo return type: Auth\n\nJoker input arguments: [^String username, ^String secret]\n\nJoker return type: go.std.net.smtp/Auth"
;;   {:added "1.0"
;;    :go "cRAMMD5Auth(_username, _secret)"}
;;   [^String _username, ^String _secret])

JOKER FUNC net/smtp.Dial from net/smtp/smtp.go:
;; (defn Dial
;;   "Dial returns a new Client connected to an SMTP server at addr.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nGo input arguments: (addr string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String addr]\n\nJoker return type: [go.std.net.smtp/Client Error]"
;;   {:added "1.0"
;;    :go "dial(_addr)"}
;;   [^String _addr])

JOKER FUNC net/smtp.NewClient from net/smtp/smtp.go:
;; (defn NewClient
;;   "NewClient returns a new Client using an existing connection and host as a\nserver name to be used when authenticating.\n\nGo input arguments: (conn net.Conn, host string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^go.std.net/Conn conn, ^String host]\n\nJoker return type: [go.std.net.smtp/Client Error]"
;;   {:added "1.0"
;;    :go "newClient(_conn, _host)"}
;;   [^Native _conn, ^String _host])

JOKER FUNC net/smtp.PlainAuth from net/smtp/auth.go:
;; (defn PlainAuth
;;   "PlainAuth returns an Auth that implements the PLAIN authentication\nmechanism as defined in RFC 4616. The returned Auth uses the given\nusername and password to authenticate to host and act as identity.\nUsually identity should be the empty string, to act as username.\n\nPlainAuth will only send the credentials if the connection is using TLS\nor is connected to localhost. Otherwise authentication will fail with an\nerror, without sending the credentials.\n\nGo input arguments: (identity string, username string, password string, host string)\n\nGo return type: Auth\n\nJoker input arguments: [^String identity, ^String username, ^String password, ^String host]\n\nJoker return type: go.std.net.smtp/Auth"
;;   {:added "1.0"
;;    :go "plainAuth(_identity, _username, _password, _host)"}
;;   [^String _identity, ^String _username, ^String _password, ^String _host])

JOKER FUNC net/smtp.SendMail from net/smtp/smtp.go:
;; (defn ^"Error" SendMail
;;   "SendMail connects to the server at addr, switches to TLS if\npossible, authenticates with the optional mechanism a if possible,\nand then sends an email from address from, to addresses to, with\nmessage msg.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nThe addresses in the to parameter are the SMTP RCPT addresses.\n\nThe msg parameter should be an RFC 822-style email with headers\nfirst, a blank line, and then the message body. The lines of msg\nshould be CRLF terminated. The msg headers should usually include\nfields such as \"From\", \"To\", \"Subject\", and \"Cc\".  Sending \"Bcc\"\nmessages is accomplished by including an email address in the to\nparameter but not including it in the msg headers.\n\nThe SendMail function and the net/smtp package are low-level\nmechanisms and provide no support for DKIM signing, MIME\nattachments (see the mime/multipart package), or other mail\nfunctionality. Higher-level packages exist outside of the standard\nlibrary.\n\nGo input arguments: (addr string, a net/smtp.Auth, from string, to []string, msg []byte)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^go.std.net.smtp/Auth a, ^String from, ^(vector-of String) to, ^(vector-of Byte) msg]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "smtp.SendMail(_addr, _a, _from, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfstring(_to)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_msg)))"}
;;   [^String _addr, ^Native _a, ^String _from, ^Object _to, ^Object _msg])

JOKER FUNC net/textproto.CanonicalMIMEHeaderKey from net/textproto/reader.go:
(defn ^"String" CanonicalMIMEHeaderKey
  "CanonicalMIMEHeaderKey returns the canonical format of the\nMIME header key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nMIME header keys are assumed to be ASCII only.\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "textproto.CanonicalMIMEHeaderKey(_s)"}
  [^String _s])

JOKER FUNC net/textproto.Dial from net/textproto/textproto.go:
;; (defn Dial
;;   "Dial connects to the given address on the given network using net.Dial\nand then returns a new Conn for the connection.\n\nGo input arguments: (network string, addr string)\n\nGo return type: (*Conn, error)\n\nJoker input arguments: [^String network, ^String addr]\n\nJoker return type: [go.std.net.textproto/Conn Error]"
;;   {:added "1.0"
;;    :go "dial(_network, _addr)"}
;;   [^String _network, ^String _addr])

JOKER FUNC net/textproto.NewConn from net/textproto/textproto.go:
;; (defn NewConn
;;   "NewConn returns a new Conn using conn for I/O.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *Conn\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: go.std.net.textproto/Conn"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newConn(_conn))"}
;;   [^Native _conn])

JOKER FUNC net/textproto.NewReader from net/textproto/reader.go:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from r.\n\nTo avoid denial of service attacks, the provided bufio.Reader\nshould be reading from an io.LimitReader or similar Reader to bound\nthe size of responses.\n\nGo input arguments: (r *_textproto.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: go.std.net.textproto/Reader"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newReader(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_textproto.Reader(_r))))"}
;;   [^Object _r])

JOKER FUNC net/textproto.NewWriter from net/textproto/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer writing to w.\n\nGo input arguments: (w *_textproto.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^(atom-of go.std.bufio/Writer) w]\n\nJoker return type: go.std.net.textproto/Writer"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newWriter(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_textproto.Writer(_w))))"}
;;   [^Object _w])

JOKER FUNC net/textproto.TrimBytes from net/textproto/textproto.go:
;; (defn TrimBytes
;;   "TrimBytes returns b without leading and trailing ASCII space.\n\nGo input arguments: (b []byte)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimBytes(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _b])

JOKER FUNC net/textproto.TrimString from net/textproto/textproto.go:
(defn ^"String" TrimString
  "TrimString returns s without leading and trailing ASCII space.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "textproto.TrimString(_s)"}
  [^String _s])

JOKER FUNC net/url.Parse from net/url/url.go:
;; (defn Parse
;;   "Parse parses rawurl into a URL structure.\n\nThe rawurl may be relative (a path, without a host) or absolute\n(starting with a scheme). Trying to parse a hostname and path\nwithout a scheme is invalid but may not necessarily return an\nerror, due to parsing ambiguities.\n\nGo input arguments: (rawurl string)\n\nGo return type: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker return type: [go.std.net.url/URL Error]"
;;   {:added "1.0"
;;    :go "parse(_rawurl)"}
;;   [^String _rawurl])

JOKER FUNC net/url.ParseQuery from net/url/url.go:
;; (defn ParseQuery
;;   "ParseQuery parses the URL-encoded query string and returns\na map listing the values specified for each key.\nParseQuery always returns a non-nil map containing all the\nvalid query parameters found; err describes the first decoding error\nencountered, if any.\n\nQuery is expected to be a list of key=value settings separated by\nampersands or semicolons. A setting without an equals sign is\ninterpreted as a key set to an empty value.\n\nGo input arguments: (query string)\n\nGo return type: (Values, error)\n\nJoker input arguments: [^String query]\n\nJoker return type: [go.std.net.url/Values Error]"
;;   {:added "1.0"
;;    :go "parseQuery(_query)"}
;;   [^String _query])

JOKER FUNC net/url.ParseRequestURI from net/url/url.go:
;; (defn ParseRequestURI
;;   "ParseRequestURI parses rawurl into a URL structure. It assumes that\nrawurl was received in an HTTP request, so the rawurl is interpreted\nonly as an absolute URI or an absolute path.\nThe string rawurl is assumed not to have a #fragment suffix.\n(Web browsers strip #fragment before sending the URL to a web server.)\n\nGo input arguments: (rawurl string)\n\nGo return type: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker return type: [go.std.net.url/URL Error]"
;;   {:added "1.0"
;;    :go "parseRequestURI(_rawurl)"}
;;   [^String _rawurl])

JOKER FUNC net/url.PathEscape from net/url/url.go:
(defn ^"String" PathEscape
  "PathEscape escapes the string so it can be safely placed\ninside a URL path segment.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "url.PathEscape(_s)"}
  [^String _s])

JOKER FUNC net/url.PathUnescape from net/url/url.go:
(defn PathUnescape
  "PathUnescape does the inverse transformation of PathEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB. It returns an error if any % is not followed\nby two hexadecimal digits.\n\nPathUnescape is identical to QueryUnescape except that it does not\nunescape '+' to ' ' (space).\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "pathUnescape(_s)"}
  [^String _s])

JOKER FUNC net/url.QueryEscape from net/url/url.go:
(defn ^"String" QueryEscape
  "QueryEscape escapes the string so it can be safely placed\ninside a URL query.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "url.QueryEscape(_s)"}
  [^String _s])

JOKER FUNC net/url.QueryUnescape from net/url/url.go:
(defn QueryUnescape
  "QueryUnescape does the inverse transformation of QueryEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB.\nIt returns an error if any % is not followed by two hexadecimal\ndigits.\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "queryUnescape(_s)"}
  [^String _s])

JOKER FUNC net/url.User from net/url/url.go:
;; (defn User
;;   "User returns a Userinfo containing the provided username\nand no password set.\n\nGo input arguments: (username string)\n\nGo return type: *Userinfo\n\nJoker input arguments: [^String username]\n\nJoker return type: go.std.net.url/Userinfo"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: user(_username))"}
;;   [^String _username])

JOKER FUNC net/url.UserPassword from net/url/url.go:
;; (defn UserPassword
;;   "UserPassword returns a Userinfo containing the provided username\nand password.\n\nThis functionality should only be used with legacy web sites.\nRFC 2396 warns that interpreting Userinfo this way\n``is NOT RECOMMENDED, because the passing of authentication\ninformation in clear text (such as URI) has proven to be a\nsecurity risk in almost every case where it has been used.''\n\nGo input arguments: (username string, password string)\n\nGo return type: *Userinfo\n\nJoker input arguments: [^String username, ^String password]\n\nJoker return type: go.std.net.url/Userinfo"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: userPassword(_username, _password))"}
;;   [^String _username, ^String _password])

GO FUNC net.CIDRMask from net/ip.go:
// func cIDRMask(ones int, bits int) Object {
// 	_res := _net.CIDRMask(ones, bits)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet.IPMask(_res))
// }

GO FUNC net.Dial from net/dial.go:
// func dial(network string, address string) Object {
// 	_res1, _res2 := _net.Dial(network, address)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.Conn(_res1)))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialIP from net/iprawsock.go:
// func dialIP(network string, laddr *_net.IPAddr, raddr *_net.IPAddr) Object {
// 	_res1, _res2 := _net.DialIP(network, laddr, raddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.IPConn((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialTCP from net/tcpsock.go:
// func dialTCP(network string, laddr *_net.TCPAddr, raddr *_net.TCPAddr) Object {
// 	_res1, _res2 := _net.DialTCP(network, laddr, raddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.TCPConn((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialTimeout from net/dial.go:
// func dialTimeout(network string, address string, timeout _net.Duration) Object {
// 	_res1, _res2 := _net.DialTimeout(network, address, timeout)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.Conn(_res1)))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialUDP from net/udpsock.go:
// func dialUDP(network string, laddr *_net.UDPAddr, raddr *_net.UDPAddr) Object {
// 	_res1, _res2 := _net.DialUDP(network, laddr, raddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.UDPConn((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialUnix from net/unixsock.go:
// func dialUnix(network string, laddr *_net.UnixAddr, raddr *_net.UnixAddr) Object {
// 	_res1, _res2 := _net.DialUnix(network, laddr, raddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.UnixConn((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.FileConn from net/file.go:
// func fileConn(f *_net.File) Object {
// 	c, err := _net.FileConn(f)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.Conn(c)))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.FileListener from net/file.go:
// func fileListener(f *_net.File) Object {
// 	ln, err := _net.FileListener(f)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.Listener(ln)))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.FilePacketConn from net/file.go:
// func filePacketConn(f *_net.File) Object {
// 	c, err := _net.FilePacketConn(f)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.PacketConn(c)))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.IPv4 from net/ip.go:
// func iPv4(a byte, b byte, c byte, d byte) Object {
// 	_res := _net.IPv4(a, b, c, d)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet.IP(_res))
// }

GO FUNC net.IPv4Mask from net/ip.go:
// func iPv4Mask(a byte, b byte, c byte, d byte) Object {
// 	_res := _net.IPv4Mask(a, b, c, d)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet.IPMask(_res))
// }

GO FUNC net.InterfaceAddrs from net/interface.go:
// func interfaceAddrs() Object {
// 	_res1, _res2 := _net.InterfaceAddrs()
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.Addr(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.InterfaceByIndex from net/interface.go:
// func interfaceByIndex(index int) Object {
// 	_res1, _res2 := _net.InterfaceByIndex(index)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.Interface((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.InterfaceByName from net/interface.go:
// func interfaceByName(name string) Object {
// 	_res1, _res2 := _net.InterfaceByName(name)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.Interface((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.Interfaces from net/interface.go:
// func interfaces() Object {
// 	_res1, _res2 := _net.Interfaces()
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.Interface(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.Listen from net/dial.go:
// func listen(network string, address string) Object {
// 	_res1, _res2 := _net.Listen(network, address)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.Listener(_res1)))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenIP from net/iprawsock.go:
// func listenIP(network string, laddr *_net.IPAddr) Object {
// 	_res1, _res2 := _net.ListenIP(network, laddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.IPConn((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenMulticastUDP from net/udpsock.go:
// func listenMulticastUDP(network string, ifi *_net.Interface, gaddr *_net.UDPAddr) Object {
// 	_res1, _res2 := _net.ListenMulticastUDP(network, ifi, gaddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.UDPConn((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenPacket from net/dial.go:
// func listenPacket(network string, address string) Object {
// 	_res1, _res2 := _net.ListenPacket(network, address)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.PacketConn(_res1)))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenTCP from net/tcpsock.go:
// func listenTCP(network string, laddr *_net.TCPAddr) Object {
// 	_res1, _res2 := _net.ListenTCP(network, laddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.TCPListener((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenUDP from net/udpsock.go:
// func listenUDP(network string, laddr *_net.UDPAddr) Object {
// 	_res1, _res2 := _net.ListenUDP(network, laddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.UDPConn((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenUnix from net/unixsock.go:
// func listenUnix(network string, laddr *_net.UnixAddr) Object {
// 	_res1, _res2 := _net.ListenUnix(network, laddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.UnixListener((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenUnixgram from net/unixsock.go:
// func listenUnixgram(network string, laddr *_net.UnixAddr) Object {
// 	_res1, _res2 := _net.ListenUnixgram(network, laddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.UnixConn((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.LookupAddr from net/lookup.go:
func lookupAddr(addr string) Object {
	names, err := _net.LookupAddr(addr)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range names {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupCNAME from net/lookup.go:
func lookupCNAME(host string) Object {
	cname, err := _net.LookupCNAME(host)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(cname))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupHost from net/lookup.go:
func lookupHost(host string) Object {
	addrs, err := _net.LookupHost(host)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range addrs {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupIP from net/lookup.go:
// func lookupIP(host string) Object {
// 	_res1, _res2 := _net.LookupIP(host)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.IP(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.LookupMX from net/lookup.go:
// func lookupMX(name string) Object {
// 	_res1, _res2 := _net.LookupMX(name)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.MX((*_elem1))))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.LookupNS from net/lookup.go:
// func lookupNS(name string) Object {
// 	_res1, _res2 := _net.LookupNS(name)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.NS((*_elem1))))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.LookupPort from net/lookup.go:
func lookupPort(network string, service string) Object {
	port, err := _net.LookupPort(network, service)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(port))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupSRV from net/lookup.go:
// func lookupSRV(service string, proto string, name string) Object {
// 	cname, addrs, err := _net.LookupSRV(service, proto, name)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeString(cname))
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range addrs {
// 		_vec1 = _vec1.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.SRV((*_elem1))))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.LookupTXT from net/lookup.go:
func lookupTXT(name string) Object {
	_res1, _res2 := _net.LookupTXT(name)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ParseCIDR from net/ip.go:
// func parseCIDR(s string) Object {
// 	_res1, _res2, _res3 := _net.ParseCIDR(s)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.IP(_res1)))
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.IPNet((*_res2))))
// 	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
// 	return _res
// }

GO FUNC net.ParseIP from net/ip.go:
// func parseIP(s string) Object {
// 	_res := _net.ParseIP(s)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet.IP(_res))
// }

GO FUNC net.ParseMAC from net/mac.go:
// func parseMAC(s string) Object {
// 	hw, err := _net.ParseMAC(s)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.HardwareAddr(hw)))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.Pipe from net/pipe.go:
// func pipe() Object {
// 	_res1, _res2 := _net.Pipe()
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.Conn(_res1)))
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.Conn(_res2)))
// 	return _res
// }

GO FUNC net.ResolveIPAddr from net/iprawsock.go:
// func resolveIPAddr(network string, address string) Object {
// 	_res1, _res2 := _net.ResolveIPAddr(network, address)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.IPAddr((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ResolveTCPAddr from net/tcpsock.go:
// func resolveTCPAddr(network string, address string) Object {
// 	_res1, _res2 := _net.ResolveTCPAddr(network, address)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.TCPAddr((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ResolveUDPAddr from net/udpsock.go:
// func resolveUDPAddr(network string, address string) Object {
// 	_res1, _res2 := _net.ResolveUDPAddr(network, address)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.UDPAddr((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ResolveUnixAddr from net/unixsock.go:
// func resolveUnixAddr(network string, address string) Object {
// 	_res1, _res2 := _net.ResolveUnixAddr(network, address)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet.UnixAddr((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.SplitHostPort from net/ipsock.go:
func splitHostPort(hostport string) Object {
	host, port, err := _net.SplitHostPort(hostport)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(host))
	_res = _res.Conjoin(MakeString(port))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.Error from net/http/server.go:
// func error(w _http.ResponseWriter, error string, code int) Object {
// 	_http.Error(w, error, code)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.FileServer from net/http/fs.go:
// func fileServer(root _http.FileSystem) Object {
// 	_res := _http.FileServer(root)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/http.Handler(_res))
// }

GO FUNC net/http.Get from net/http/client.go:
// func get(url string) Object {
// 	resp, err := _http.Get(url)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/http.Response((*resp))))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.Handle from net/http/server.go:
// func handle(pattern string, handler _http.Handler) Object {
// 	_http.Handle(pattern, handler)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.HandleFunc from net/http/server.go:
// func handleFunc(pattern string, handler func) Object {
// 	_http.HandleFunc(pattern, handler)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.Head from net/http/client.go:
// func head(url string) Object {
// 	resp, err := _http.Head(url)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/http.Response((*resp))))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.MaxBytesReader from net/http/request.go:
// func maxBytesReader(w _http.ResponseWriter, r _http.ReadCloser, n int64) Object {
// 	return _http.MaxBytesReader(w, r, n)
// }

GO FUNC net/http.NewFileTransport from net/http/filetransport.go:
// func newFileTransport(fs _http.FileSystem) Object {
// 	_res := _http.NewFileTransport(fs)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/http.RoundTripper(_res))
// }

GO FUNC net/http.NewRequest from net/http/request.go:
// func newRequest(method string, url string, body _http.Reader) Object {
// 	_res1, _res2 := _http.NewRequest(method, url, body)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/http.Request((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.NewServeMux from net/http/server.go:
// func newServeMux() Object {
// 	_res := _http.NewServeMux()
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/http.ServeMux((*_res)))
// }

GO FUNC net/http.NotFound from net/http/server.go:
// func notFound(w _http.ResponseWriter, r *_http.Request) Object {
// 	_http.NotFound(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.NotFoundHandler from net/http/server.go:
// func notFoundHandler() Object {
// 	_res := _http.NotFoundHandler()
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/http.Handler(_res))
// }

GO FUNC net/http.ParseHTTPVersion from net/http/request.go:
func parseHTTPVersion(vers string) Object {
	major, minor, ok := _http.ParseHTTPVersion(vers)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(major))
	_res = _res.Conjoin(MakeInt(minor))
	_res = _res.Conjoin(MakeBool(ok))
	return _res
}

GO FUNC net/http.ParseTime from net/http/header.go:
// func parseTime(text string) Object {
// 	t, err := _http.ParseTime(text)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(t)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.Post from net/http/client.go:
// func post(url string, contentType string, body _http.Reader) Object {
// 	resp, err := _http.Post(url, contentType, body)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/http.Response((*resp))))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.PostForm from net/http/client.go:
// func postForm(url string, data _http.Values) Object {
// 	resp, err := _http.PostForm(url, data)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/http.Response((*resp))))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.ProxyFromEnvironment from net/http/transport.go:
// func proxyFromEnvironment(req *_http.Request) Object {
// 	_res1, _res2 := _http.ProxyFromEnvironment(req)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/url.URL((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.ProxyURL from net/http/transport.go:
// func proxyURL(fixedURL *_http.URL) Object {
// 	return _http.ProxyURL(fixedURL)
// }

GO FUNC net/http.ReadRequest from net/http/request.go:
// func readRequest(b *_http.Reader) Object {
// 	_res1, _res2 := _http.ReadRequest(b)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/http.Request((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.ReadResponse from net/http/response.go:
// func readResponse(r *_http.Reader, req *_http.Request) Object {
// 	_res1, _res2 := _http.ReadResponse(r, req)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/http.Response((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.Redirect from net/http/server.go:
// func redirect(w _http.ResponseWriter, r *_http.Request, url string, code int) Object {
// 	_http.Redirect(w, r, url, code)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.RedirectHandler from net/http/server.go:
// func redirectHandler(url string, code int) Object {
// 	_res := _http.RedirectHandler(url, code)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/http.Handler(_res))
// }

GO FUNC net/http.ServeContent from net/http/fs.go:
// func serveContent(w _http.ResponseWriter, req *_http.Request, name string, modtime _http.Time, content _http.ReadSeeker) Object {
// 	_http.ServeContent(w, req, name, modtime, content)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.ServeFile from net/http/fs.go:
// func serveFile(w _http.ResponseWriter, r *_http.Request, name string) Object {
// 	_http.ServeFile(w, r, name)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.SetCookie from net/http/cookie.go:
// func setCookie(w _http.ResponseWriter, cookie *_http.Cookie) Object {
// 	_http.SetCookie(w, cookie)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.StripPrefix from net/http/server.go:
// func stripPrefix(prefix string, h _http.Handler) Object {
// 	_res := _http.StripPrefix(prefix, h)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/http.Handler(_res))
// }

GO FUNC net/http.TimeoutHandler from net/http/server.go:
// func timeoutHandler(h _http.Handler, dt _http.Duration, msg string) Object {
// 	_res := _http.TimeoutHandler(h, dt, msg)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/http.Handler(_res))
// }

GO FUNC net/http/cgi.Request from net/http/cgi/child.go:
// func request() Object {
// 	_res1, _res2 := _cgi.Request()
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/http.Request((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/cgi.RequestFromMap from net/http/cgi/child.go:
// func requestFromMap(params map[]) Object {
// 	_res1, _res2 := _cgi.RequestFromMap(params)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/http.Request((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/cookiejar.New from net/http/cookiejar/jar.go:
// func new(o *_cookiejar.Options) Object {
// 	_res1, _res2 := _cookiejar.New(o)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/http/cookiejar.Jar((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/fcgi.ProcessEnv from net/http/fcgi/child.go:
// func processEnv(r *_fcgi.Request) Object {
// 	return _fcgi.ProcessEnv(r)
// }

GO FUNC net/http/httptest.NewRecorder from net/http/httptest/recorder.go:
// func newRecorder() Object {
// 	_res := _httptest.NewRecorder()
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/http/httptest.ResponseRecorder((*_res)))
// }

GO FUNC net/http/httptest.NewRequest from net/http/httptest/httptest.go:
// func newRequest(method string, target string, body _httptest.Reader) Object {
// 	_res := _httptest.NewRequest(method, target, body)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/http.Request((*_res)))
// }

GO FUNC net/http/httptest.NewServer from net/http/httptest/server.go:
// func newServer(handler _httptest.Handler) Object {
// 	_res := _httptest.NewServer(handler)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/http/httptest.Server((*_res)))
// }

GO FUNC net/http/httptest.NewTLSServer from net/http/httptest/server.go:
// func newTLSServer(handler _httptest.Handler) Object {
// 	_res := _httptest.NewTLSServer(handler)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/http/httptest.Server((*_res)))
// }

GO FUNC net/http/httptest.NewUnstartedServer from net/http/httptest/server.go:
// func newUnstartedServer(handler _httptest.Handler) Object {
// 	_res := _httptest.NewUnstartedServer(handler)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/http/httptest.Server((*_res)))
// }

GO FUNC net/http/httptrace.ContextClientTrace from net/http/httptrace/trace.go:
// func contextClientTrace(ctx _httptrace.Context) Object {
// 	_res := _httptrace.ContextClientTrace(ctx)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/http/httptrace.ClientTrace((*_res)))
// }

GO FUNC net/http/httptrace.WithClientTrace from net/http/httptrace/trace.go:
// func withClientTrace(ctx _httptrace.Context, trace *_httptrace.ClientTrace) Object {
// 	return _httptrace.WithClientTrace(ctx, trace)
// }

GO FUNC net/http/httputil.DumpRequest from net/http/httputil/dump.go:
// func dumpRequest(req *_httputil.Request, body bool) Object {
// 	_res1, _res2 := _httputil.DumpRequest(req, body)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.DumpRequestOut from net/http/httputil/dump.go:
// func dumpRequestOut(req *_httputil.Request, body bool) Object {
// 	_res1, _res2 := _httputil.DumpRequestOut(req, body)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.DumpResponse from net/http/httputil/dump.go:
// func dumpResponse(resp *_httputil.Response, body bool) Object {
// 	_res1, _res2 := _httputil.DumpResponse(resp, body)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.NewChunkedReader from net/http/httputil/httputil.go:
// func newChunkedReader(r _httputil.Reader) Object {
// 	return _httputil.NewChunkedReader(r)
// }

GO FUNC net/http/httputil.NewChunkedWriter from net/http/httputil/httputil.go:
// func newChunkedWriter(w _httputil.Writer) Object {
// 	return _httputil.NewChunkedWriter(w)
// }

GO FUNC net/http/httputil.NewClientConn from net/http/httputil/persist.go:
// func newClientConn(c _httputil.Conn, r *_httputil.Reader) Object {
// 	_res := _httputil.NewClientConn(c, r)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/http/httputil.ClientConn((*_res)))
// }

GO FUNC net/http/httputil.NewProxyClientConn from net/http/httputil/persist.go:
// func newProxyClientConn(c _httputil.Conn, r *_httputil.Reader) Object {
// 	_res := _httputil.NewProxyClientConn(c, r)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/http/httputil.ClientConn((*_res)))
// }

GO FUNC net/http/httputil.NewServerConn from net/http/httputil/persist.go:
// func newServerConn(c _httputil.Conn, r *_httputil.Reader) Object {
// 	_res := _httputil.NewServerConn(c, r)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/http/httputil.ServerConn((*_res)))
// }

GO FUNC net/http/httputil.NewSingleHostReverseProxy from net/http/httputil/reverseproxy.go:
// func newSingleHostReverseProxy(target *_httputil.URL) Object {
// 	_res := _httputil.NewSingleHostReverseProxy(target)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/http/httputil.ReverseProxy((*_res)))
// }

GO FUNC net/http/pprof.Cmdline from net/http/pprof/pprof.go:
// func cmdline(w _pprof.ResponseWriter, r *_pprof.Request) Object {
// 	_pprof.Cmdline(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Handler from net/http/pprof/pprof.go:
// func handler(name string) Object {
// 	_res := _pprof.Handler(name)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/http.Handler(_res))
// }

GO FUNC net/http/pprof.Index from net/http/pprof/pprof.go:
// func index(w _pprof.ResponseWriter, r *_pprof.Request) Object {
// 	_pprof.Index(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Profile from net/http/pprof/pprof.go:
// func profile(w _pprof.ResponseWriter, r *_pprof.Request) Object {
// 	_pprof.Profile(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Symbol from net/http/pprof/pprof.go:
// func symbol(w _pprof.ResponseWriter, r *_pprof.Request) Object {
// 	_pprof.Symbol(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Trace from net/http/pprof/pprof.go:
// func trace(w _pprof.ResponseWriter, r *_pprof.Request) Object {
// 	_pprof.Trace(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/mail.ParseAddress from net/mail/message.go:
// func parseAddress(address string) Object {
// 	_res1, _res2 := _mail.ParseAddress(address)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/mail.Address((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/mail.ParseAddressList from net/mail/message.go:
// func parseAddressList(list string) Object {
// 	_res1, _res2 := _mail.ParseAddressList(list)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/mail.Address((*_elem1))))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/mail.ParseDate from net/mail/message.go:
// func parseDate(date string) Object {
// 	_res1, _res2 := _mail.ParseDate(date)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/mail.ReadMessage from net/mail/message.go:
// func readMessage(r _mail.Reader) Object {
// 	msg, err := _mail.ReadMessage(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/mail.Message((*msg))))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/rpc.Accept from net/rpc/server.go:
// func accept(lis _rpc.Listener) Object {
// 	_rpc.Accept(lis)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.Dial from net/rpc/client.go:
// func dial(network string, address string) Object {
// 	_res1, _res2 := _rpc.Dial(network, address)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/rpc.Client((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/rpc.DialHTTP from net/rpc/client.go:
// func dialHTTP(network string, address string) Object {
// 	_res1, _res2 := _rpc.DialHTTP(network, address)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/rpc.Client((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/rpc.DialHTTPPath from net/rpc/client.go:
// func dialHTTPPath(network string, address string, path string) Object {
// 	_res1, _res2 := _rpc.DialHTTPPath(network, address, path)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/rpc.Client((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/rpc.HandleHTTP from net/rpc/server.go:
// func handleHTTP() Object {
// 	_rpc.HandleHTTP()
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.NewClient from net/rpc/client.go:
// func newClient(conn _rpc.ReadWriteCloser) Object {
// 	_res := _rpc.NewClient(conn)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/rpc.Client((*_res)))
// }

GO FUNC net/rpc.NewClientWithCodec from net/rpc/client.go:
// func newClientWithCodec(codec _rpc.ClientCodec) Object {
// 	_res := _rpc.NewClientWithCodec(codec)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/rpc.Client((*_res)))
// }

GO FUNC net/rpc.NewServer from net/rpc/server.go:
// func newServer() Object {
// 	_res := _rpc.NewServer()
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/rpc.Server((*_res)))
// }

GO FUNC net/rpc.ServeCodec from net/rpc/server.go:
// func serveCodec(codec _rpc.ServerCodec) Object {
// 	_rpc.ServeCodec(codec)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.ServeConn from net/rpc/server.go:
// func serveConn(conn _rpc.ReadWriteCloser) Object {
// 	_rpc.ServeConn(conn)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc/jsonrpc.Dial from net/rpc/jsonrpc/client.go:
// func dial(network string, address string) Object {
// 	_res1, _res2 := _jsonrpc.Dial(network, address)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/rpc.Client((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/rpc/jsonrpc.NewClient from net/rpc/jsonrpc/client.go:
// func newClient(conn _jsonrpc.ReadWriteCloser) Object {
// 	_res := _jsonrpc.NewClient(conn)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/rpc.Client((*_res)))
// }

GO FUNC net/rpc/jsonrpc.NewClientCodec from net/rpc/jsonrpc/client.go:
// func newClientCodec(conn _jsonrpc.ReadWriteCloser) Object {
// 	_res := _jsonrpc.NewClientCodec(conn)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/rpc.ClientCodec(_res))
// }

GO FUNC net/rpc/jsonrpc.NewServerCodec from net/rpc/jsonrpc/server.go:
// func newServerCodec(conn _jsonrpc.ReadWriteCloser) Object {
// 	_res := _jsonrpc.NewServerCodec(conn)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/rpc.ServerCodec(_res))
// }

GO FUNC net/rpc/jsonrpc.ServeConn from net/rpc/jsonrpc/server.go:
// func serveConn(conn _jsonrpc.ReadWriteCloser) Object {
// 	_jsonrpc.ServeConn(conn)
// 	...ABEND675: TODO...
// }

GO FUNC net/smtp.CRAMMD5Auth from net/smtp/auth.go:
// func cRAMMD5Auth(username string, secret string) Object {
// 	_res := _smtp.CRAMMD5Auth(username, secret)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/smtp.Auth(_res))
// }

GO FUNC net/smtp.Dial from net/smtp/smtp.go:
// func dial(addr string) Object {
// 	_res1, _res2 := _smtp.Dial(addr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/smtp.Client((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/smtp.NewClient from net/smtp/smtp.go:
// func newClient(conn _smtp.Conn, host string) Object {
// 	_res1, _res2 := _smtp.NewClient(conn, host)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/smtp.Client((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/smtp.PlainAuth from net/smtp/auth.go:
// func plainAuth(identity string, username string, password string, host string) Object {
// 	_res := _smtp.PlainAuth(identity, username, password, host)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/smtp.Auth(_res))
// }

GO FUNC net/textproto.Dial from net/textproto/textproto.go:
// func dial(network string, addr string) Object {
// 	_res1, _res2 := _textproto.Dial(network, addr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/textproto.Conn((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/textproto.NewConn from net/textproto/textproto.go:
// func newConn(conn _textproto.ReadWriteCloser) Object {
// 	_res := _textproto.NewConn(conn)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/textproto.Conn((*_res)))
// }

GO FUNC net/textproto.NewReader from net/textproto/reader.go:
// func newReader(r *_textproto.Reader) Object {
// 	_res := _textproto.NewReader(r)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/textproto.Reader((*_res)))
// }

GO FUNC net/textproto.NewWriter from net/textproto/writer.go:
// func newWriter(w *_textproto.Writer) Object {
// 	_res := _textproto.NewWriter(w)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/textproto.Writer((*_res)))
// }

GO FUNC net/textproto.TrimBytes from net/textproto/textproto.go:
// func trimBytes(b []byte) Object {
// 	_res := _textproto.TrimBytes(b)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC net/url.Parse from net/url/url.go:
// func parse(rawurl string) Object {
// 	_res1, _res2 := _url.Parse(rawurl)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/url.URL((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/url.ParseQuery from net/url/url.go:
// func parseQuery(query string) Object {
// 	_res1, _res2 := _url.ParseQuery(query)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/url.Values(_res1)))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/url.ParseRequestURI from net/url/url.go:
// func parseRequestURI(rawurl string) Object {
// 	_res1, _res2 := _url.ParseRequestURI(rawurl)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ABEND911(custom-runtime routine not implemented: ConvertFromnet/url.URL((*_res1))))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/url.PathUnescape from net/url/url.go:
func pathUnescape(s string) Object {
	_res1, _res2 := _url.PathUnescape(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.QueryUnescape from net/url/url.go:
func queryUnescape(s string) Object {
	_res1, _res2 := _url.QueryUnescape(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.User from net/url/url.go:
// func user(username string) Object {
// 	_res := _url.User(username)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/url.Userinfo((*_res)))
// }

GO FUNC net/url.UserPassword from net/url/url.go:
// func userPassword(username string, password string) Object {
// 	_res := _url.UserPassword(username, password)
// 	return ABEND911(custom-runtime routine not implemented: ConvertFromnet/url.Userinfo((*_res)))
// }

Adding custom imports to _tests/gold/amd64-linux/joker/custom.go
Adding custom loaded libraries to _tests/gold/amd64-linux/joker/core/data/core.joke
Adding custom loaded libraries to _tests/gold/amd64-linux/joker/std/generate-custom.joke
ABENDs: 911(93) 903(45) 401(20) 675(18) 042(6) 902(4) 883(2) 907(2) 906(1) 908(1)
Totals: types=102 functions=1348 methods=1200 (89.02%) standalone=148 (10.98%) generated=23 (15.54%)
