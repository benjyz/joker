goSourceDir: _tests/small/src
goSourcePath: /Users/craig/go/src
Matchfile(_tests/small/src/net/dnsclient.go) => true <nil>
Matchfile(_tests/small/src/net/ip.go) => true <nil>
Matchfile(_tests/small/src/net/iprawsock.go) => true <nil>
Matchfile(_tests/small/src/net/lookup.go) => true <nil>
Matchfile(_tests/small/src/net/net.go) => true <nil>
Matchfile(_tests/small/src/net/url/url.go) => true <nil>
Processing go:
Processing net/url:
Processing net:
Processing package=net/url:
Processing package=net:
JOKER CONSTANT IPv4len from net/ip.go:
(def
  ^{:doc "IP address lengths (bytes).\n"
    :added "1.0"
    :tag "Int"
    :go "net.IPv4len"}
  IPv4len)

JOKER CONSTANT IPv6len from net/ip.go:
(def
  ^{:doc "IP address lengths (bytes).\n"
    :added "1.0"
    :tag "Int"
    :go "net.IPv6len"}
  IPv6len)

JOKER VARIABLE DefaultResolver from net/lookup.go:
(def
  ^{:doc "DefaultResolver is the resolver used by the package-level Lookup\nfunctions and by Dialers without a specified Resolver.\n"
    :added "1.0"
    :tag "Var"
    :go "net.DefaultResolver"}
  DefaultResolver)

JOKER VARIABLE ErrWriteToConnected from net/net.go:
(def
  ^{:doc "Various errors contained in OpError.\n"
    :added "1.0"
    :tag "Var"
    :go "net.ErrWriteToConnected"}
  ErrWriteToConnected)

JOKER VARIABLE IPv4allrouter from net/ip.go:
(def
  ^{:doc "all routers\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv4allrouter"}
  IPv4allrouter)

JOKER VARIABLE IPv4allsys from net/ip.go:
(def
  ^{:doc "all systems\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv4allsys"}
  IPv4allsys)

JOKER VARIABLE IPv4bcast from net/ip.go:
(def
  ^{:doc "limited broadcast\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv4bcast"}
  IPv4bcast)

JOKER VARIABLE IPv4zero from net/ip.go:
(def
  ^{:doc "all zeros\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv4zero"}
  IPv4zero)

JOKER VARIABLE IPv6interfacelocalallnodes from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6interfacelocalallnodes"}
  IPv6interfacelocalallnodes)

JOKER VARIABLE IPv6linklocalallnodes from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6linklocalallnodes"}
  IPv6linklocalallnodes)

JOKER VARIABLE IPv6linklocalallrouters from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6linklocalallrouters"}
  IPv6linklocalallrouters)

JOKER VARIABLE IPv6loopback from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6loopback"}
  IPv6loopback)

JOKER VARIABLE IPv6unspecified from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6unspecified"}
  IPv6unspecified)

JOKER VARIABLE IPv6zero from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6zero"}
  IPv6zero)

JOKER TYPE net.Addr from net/net.go:
JOKER TYPE net.AddrError from net/net.go:
JOKER TYPE net.Buffers from net/net.go:
JOKER TYPE net.Conn from net/net.go:
JOKER TYPE net.DNSConfigError from net/net.go:
JOKER TYPE net.DNSError from net/net.go:
JOKER TYPE net.Error from net/net.go:
JOKER TYPE net.IP from net/ip.go:
JOKER TYPE net.IPAddr from net/iprawsock.go:
JOKER TYPE net.IPConn from net/iprawsock.go:
JOKER TYPE net.IPMask from net/ip.go:
JOKER TYPE net.IPNet from net/ip.go:
JOKER TYPE net.InvalidAddrError from net/net.go:
JOKER TYPE net.Listener from net/net.go:
JOKER TYPE net.MX from net/dnsclient.go:
JOKER TYPE net.NS from net/dnsclient.go:
JOKER TYPE net.OpError from net/net.go:
JOKER TYPE net.PacketConn from net/net.go:
JOKER TYPE net.ParseError from net/net.go:
JOKER TYPE net.Resolver from net/lookup.go:
JOKER TYPE net.SRV from net/dnsclient.go:
JOKER TYPE net.UnknownNetworkError from net/net.go:
JOKER FUNC net.CIDRMask from net/ip.go:
(defn CIDRMask
  "CIDRMask returns an IPMask consisting of `ones' 1 bits\nfollowed by 0s up to a total length of `bits' bits.\nFor a mask of this form, CIDRMask is the inverse of IPMask.Size.\n\nGo input arguments: (ones int, bits int)\n\nGo return type: IPMask\n\nJoker input arguments: [^Int ones, ^Int bits]\n\nJoker return type: go.std.net/IPMask"
  {:added "1.0"
   :go "__cIDRMask(__ones, __bits)"}
  [^Int __ones, ^Int __bits])

JOKER FUNC net.DialIP from net/iprawsock.go:
(defn DialIP
  "DialIP acts like Dial for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *IPAddr, raddr *IPAddr)\n\nGo return type: (*IPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/IPAddr) laddr, ^(atom-of go.std.net/IPAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/IPConn) Error]"
  {:added "1.0"
   :go "__dialIP(__network, __laddr, __raddr)"}
  [^String __network, ^net/IPAddr __laddr, ^net/IPAddr __raddr])

JOKER FUNC net.IPv4 from net/ip.go:
(defn IPv4
  "IPv4 returns the IP address (in 16-byte form) of the\nIPv4 address a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo return type: IP\n\nJoker input arguments: [^Int a, ^Int b, ^Int c, ^Int d]\n\nJoker return type: go.std.net/IP"
  {:added "1.0"
   :go "__iPv4(__a, __b, __c, __d)"}
  [^Byte __a, ^Byte __b, ^Byte __c, ^Byte __d])

JOKER FUNC net.IPv4Mask from net/ip.go:
(defn IPv4Mask
  "IPv4Mask returns the IP mask (in 4-byte form) of the\nIPv4 mask a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo return type: IPMask\n\nJoker input arguments: [^Int a, ^Int b, ^Int c, ^Int d]\n\nJoker return type: go.std.net/IPMask"
  {:added "1.0"
   :go "__iPv4Mask(__a, __b, __c, __d)"}
  [^Byte __a, ^Byte __b, ^Byte __c, ^Byte __d])

JOKER FUNC net.ListenIP from net/iprawsock.go:
(defn ListenIP
  "ListenIP acts like ListenPacket for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenIP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\n\nGo input arguments: (network string, laddr *IPAddr)\n\nGo return type: (*IPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/IPAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/IPConn) Error]"
  {:added "1.0"
   :go "__listenIP(__network, __laddr)"}
  [^String __network, ^net/IPAddr __laddr])

JOKER FUNC net.LookupAddr from net/lookup.go:
(defn LookupAddr
  "LookupAddr performs a reverse lookup for the given address, returning a list\nof names mapping to that address.\n\nWhen using the host C library resolver, at most one result will be\nreturned. To bypass the host resolver, use a custom Resolver.\n\nGo input arguments: (addr string)\n\nGo return type: (names []string, err error)\n\nJoker input arguments: [^String addr]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__lookupAddr(__addr)"}
  [^String __addr])

JOKER FUNC net.LookupCNAME from net/lookup.go:
(defn LookupCNAME
  "LookupCNAME returns the canonical name for the given host.\nCallers that do not care about the canonical name can call\nLookupHost or LookupIP directly; both take care of resolving\nthe canonical name as part of the lookup.\n\nA canonical name is the final name after following zero\nor more CNAME records.\nLookupCNAME does not return an error if host does not\ncontain DNS \"CNAME\" records, as long as host resolves to\naddress records.\n\nGo input arguments: (host string)\n\nGo return type: (cname string, err error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__lookupCNAME(__host)"}
  [^String __host])

JOKER FUNC net.LookupHost from net/lookup.go:
(defn LookupHost
  "LookupHost looks up the given host using the local resolver.\nIt returns a slice of that host's addresses.\n\nGo input arguments: (host string)\n\nGo return type: (addrs []string, err error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__lookupHost(__host)"}
  [^String __host])

JOKER FUNC net.LookupIP from net/lookup.go:
(defn LookupIP
  "LookupIP looks up host using the local resolver.\nIt returns a slice of that host's IPv4 and IPv6 addresses.\n\nGo input arguments: (host string)\n\nGo return type: ([]IP, error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [(vector-of go.std.net/IP) Error]"
  {:added "1.0"
   :go "__lookupIP(__host)"}
  [^String __host])

JOKER FUNC net.LookupMX from net/lookup.go:
(defn LookupMX
  "LookupMX returns the DNS MX records for the given domain name sorted by preference.\n\nGo input arguments: (name string)\n\nGo return type: ([]*MX, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of (atom-of go.std.net/MX)) Error]"
  {:added "1.0"
   :go "__lookupMX(__name)"}
  [^String __name])

JOKER FUNC net.LookupNS from net/lookup.go:
(defn LookupNS
  "LookupNS returns the DNS NS records for the given domain name.\n\nGo input arguments: (name string)\n\nGo return type: ([]*NS, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of (atom-of go.std.net/NS)) Error]"
  {:added "1.0"
   :go "__lookupNS(__name)"}
  [^String __name])

JOKER FUNC net.LookupPort from net/lookup.go:
(defn LookupPort
  "LookupPort looks up the port for the given network and service.\n\nGo input arguments: (network string, service string)\n\nGo return type: (port int, err error)\n\nJoker input arguments: [^String network, ^String service]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__lookupPort(__network, __service)"}
  [^String __network, ^String __service])

JOKER FUNC net.LookupSRV from net/lookup.go:
(defn LookupSRV
  "LookupSRV tries to resolve an SRV query of the given service,\nprotocol, and domain name. The proto is \"tcp\" or \"udp\".\nThe returned records are sorted by priority and randomized\nby weight within a priority.\n\nLookupSRV constructs the DNS name to look up following RFC 2782.\nThat is, it looks up _service._proto.name. To accommodate services\npublishing SRV records under non-standard names, if both service\nand proto are empty strings, LookupSRV looks up name directly.\n\nGo input arguments: (service string, proto string, name string)\n\nGo return type: (cname string, addrs []*SRV, err error)\n\nJoker input arguments: [^String service, ^String proto, ^String name]\n\nJoker return type: [String (vector-of (atom-of go.std.net/SRV)) Error]"
  {:added "1.0"
   :go "__lookupSRV(__service, __proto, __name)"}
  [^String __service, ^String __proto, ^String __name])

JOKER FUNC net.LookupTXT from net/lookup.go:
(defn LookupTXT
  "LookupTXT returns the DNS TXT records for the given domain name.\n\nGo input arguments: (name string)\n\nGo return type: ([]string, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__lookupTXT(__name)"}
  [^String __name])

JOKER FUNC net.ParseCIDR from net/ip.go:
(defn ParseCIDR
  "ParseCIDR parses s as a CIDR notation IP address and prefix length,\nlike \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in\nRFC 4632 and RFC 4291.\n\nIt returns the IP address and the network implied by the IP and\nprefix length.\nFor example, ParseCIDR(\"192.0.2.1/24\") returns the IP address\n192.0.2.1 and the network 192.0.2.0/24.\n\nGo input arguments: (s string)\n\nGo return type: (IP, *IPNet, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [go.std.net/IP (atom-of go.std.net/IPNet) Error]"
  {:added "1.0"
   :go "__parseCIDR(__s)"}
  [^String __s])

JOKER FUNC net.ParseIP from net/ip.go:
(defn ParseIP
  "ParseIP parses s as an IP address, returning the result.\nThe string s can be in dotted decimal (\"192.0.2.1\")\nor IPv6 (\"2001:db8::68\") form.\nIf s is not a valid textual representation of an IP address,\nParseIP returns nil.\n\nGo input arguments: (s string)\n\nGo return type: IP\n\nJoker input arguments: [^String s]\n\nJoker return type: go.std.net/IP"
  {:added "1.0"
   :go "__parseIP(__s)"}
  [^String __s])

JOKER FUNC net.ResolveIPAddr from net/iprawsock.go:
(defn ResolveIPAddr
  "ResolveIPAddr returns an address of IP end point.\n\nThe network must be an IP network name.\n\nIf the host in the address parameter is not a literal IP address,\nResolveIPAddr resolves the address to an address of IP end point.\nOtherwise, it parses the address as a literal IP address.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*IPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/IPAddr) Error]"
  {:added "1.0"
   :go "__resolveIPAddr(__network, __address)"}
  [^String __network, ^String __address])

JOKER TYPE go.std.net/Addr:
(def
  ^{:doc "Addr represents a network end point address.\n\nThe two methods Network and String conventionally return strings\nthat can be passed as the arguments to Dial, but the exact form\nand meaning of the strings is up to the implementation.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Addr"}
  Addr)

JOKER TYPE go.std.net/AddrError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_AddrError"}
  AddrError)

JOKER TYPE *go.std.net/AddrError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_AddrError"}
  *AddrError)

JOKER TYPE go.std.net/Buffers:
(def
  ^{:doc "Buffers contains zero or more runs of bytes to write.\n\nOn certain machines, for certain types of connections, this is\noptimized into an OS-specific batch write operation (such as\n\"writev\").\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Buffers"}
  Buffers)

JOKER TYPE *go.std.net/Buffers:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Buffers"}
  *Buffers)

JOKER TYPE go.std.net/Conn:
(def
  ^{:doc "Conn is a generic stream-oriented network connection.\n\nMultiple goroutines may invoke methods on a Conn simultaneously.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Conn"}
  Conn)

JOKER TYPE go.std.net/DNSConfigError:
(def
  ^{:doc "DNSConfigError represents an error reading the machine's DNS configuration.\n(No longer used; kept for compatibility.)\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DNSConfigError"}
  DNSConfigError)

JOKER TYPE *go.std.net/DNSConfigError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_DNSConfigError"}
  *DNSConfigError)

JOKER TYPE go.std.net/DNSError:
(def
  ^{:doc "DNSError represents a DNS lookup error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DNSError"}
  DNSError)

JOKER TYPE *go.std.net/DNSError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_DNSError"}
  *DNSError)

JOKER TYPE go.std.net/Error:
(def
  ^{:doc "An Error represents a network error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Error"}
  Error)

JOKER TYPE go.std.net/IP:
(def
  ^{:doc "An IP is a single IP address, a slice of bytes.\nFunctions in this package accept either 4-byte (IPv4)\nor 16-byte (IPv6) slices as input.\n\nNote that in this documentation, referring to an\nIP address as an IPv4 address or an IPv6 address\nis a semantic property of the address, not just the\nlength of the byte slice: a 16-byte slice can still\nbe an IPv4 address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IP"}
  IP)

JOKER TYPE *go.std.net/IP:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_IP"}
  *IP)

JOKER TYPE go.std.net/IPAddr:
(def
  ^{:doc "IPAddr represents the address of an IP end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IPAddr"}
  IPAddr)

JOKER TYPE *go.std.net/IPAddr:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_IPAddr"}
  *IPAddr)

JOKER TYPE go.std.net/IPConn:
(def
  ^{:doc "IPConn is the implementation of the Conn and PacketConn interfaces\nfor IP network connections.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IPConn"}
  IPConn)

JOKER TYPE *go.std.net/IPConn:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_IPConn"}
  *IPConn)

JOKER TYPE go.std.net/IPMask:
(def
  ^{:doc "An IP mask is an IP address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IPMask"}
  IPMask)

JOKER TYPE *go.std.net/IPMask:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_IPMask"}
  *IPMask)

JOKER TYPE go.std.net/IPNet:
(def
  ^{:doc "An IPNet represents an IP network.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IPNet"}
  IPNet)

JOKER TYPE *go.std.net/IPNet:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_IPNet"}
  *IPNet)

JOKER TYPE go.std.net/InvalidAddrError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_InvalidAddrError"}
  InvalidAddrError)

JOKER TYPE *go.std.net/InvalidAddrError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_InvalidAddrError"}
  *InvalidAddrError)

JOKER TYPE go.std.net/Listener:
(def
  ^{:doc "A Listener is a generic network listener for stream-oriented protocols.\n\nMultiple goroutines may invoke methods on a Listener simultaneously.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Listener"}
  Listener)

JOKER TYPE go.std.net/MX:
(def
  ^{:doc "An MX represents a single DNS MX record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_MX"}
  MX)

JOKER TYPE *go.std.net/MX:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_MX"}
  *MX)

JOKER TYPE go.std.net/NS:
(def
  ^{:doc "An NS represents a single DNS NS record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NS"}
  NS)

JOKER TYPE *go.std.net/NS:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_NS"}
  *NS)

JOKER TYPE go.std.net/OpError:
(def
  ^{:doc "OpError is the error type usually returned by functions in the net\npackage. It describes the operation, network type, and address of\nan error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_OpError"}
  OpError)

JOKER TYPE *go.std.net/OpError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_OpError"}
  *OpError)

JOKER TYPE go.std.net/PacketConn:
(def
  ^{:doc "PacketConn is a generic packet-oriented network connection.\n\nMultiple goroutines may invoke methods on a PacketConn simultaneously.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PacketConn"}
  PacketConn)

JOKER TYPE go.std.net/ParseError:
(def
  ^{:doc "A ParseError is the error type of literal network address parsers.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ParseError"}
  ParseError)

JOKER TYPE *go.std.net/ParseError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ParseError"}
  *ParseError)

JOKER TYPE go.std.net/Resolver:
(def
  ^{:doc "A Resolver looks up names and numbers.\n\nA nil *Resolver is equivalent to a zero Resolver.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Resolver"}
  Resolver)

JOKER TYPE *go.std.net/Resolver:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Resolver"}
  *Resolver)

JOKER TYPE go.std.net/SRV:
(def
  ^{:doc "An SRV represents a single DNS SRV record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SRV"}
  SRV)

JOKER TYPE *go.std.net/SRV:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_SRV"}
  *SRV)

JOKER TYPE go.std.net/UnknownNetworkError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_UnknownNetworkError"}
  UnknownNetworkError)

JOKER TYPE *go.std.net/UnknownNetworkError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_UnknownNetworkError"}
  *UnknownNetworkError)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net"]
    :doc "Provides a low-level interface to the net package.\n\nPackage net provides a portable interface for network I/O, including\nTCP/IP, UDP, domain name resolution, and Unix domain sockets.\n\nAlthough the package provides access to low-level networking\nprimitives, most clients will need only the basic interface provided\nby the Dial, Listen, and Accept functions and the associated\nConn and Listener interfaces. The crypto/tls package uses\nthe same interfaces and similar Dial and Listen functions.\n\nThe Dial function connects to a server:\n\n\tconn, err := net.Dial(\"tcp\", \"golang.org:80\")\n\tif err != nil {\n\t\t// handle error\n\t}\n\tfmt.Fprintf(conn, \"GET / HTTP/1.0\\r\\n\\r\\n\")\n\tstatus, err := bufio.NewReader(conn).ReadString('\\n')\n\t// ...\n\nThe Listen function creates servers:\n\n\tln, err := net.Listen(\"tcp\", \":8080\")\n\tif err != nil {\n\t\t// handle error\n\t}\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\t// handle error\n\t\t}\n\t\tgo handleConnection(conn)\n\t}\n\nName Resolution\n\nThe method for resolving domain names, whether indirectly with functions like Dial\nor directly with functions like LookupHost and LookupAddr, varies by operating system.\n\nOn Unix systems, the resolver has two options for resolving names.\nIt can use a pure Go resolver that sends DNS requests directly to the servers\nlisted in /etc/resolv.conf, or it can use a cgo-based resolver that calls C\nlibrary routines such as getaddrinfo and getnameinfo.\n\nBy default the pure Go resolver is used, because a blocked DNS request consumes\nonly a goroutine, while a blocked C call consumes an operating system thread.\nWhen cgo is available, the cgo-based resolver is used instead under a variety of\nconditions: on systems that do not let programs make direct DNS requests (OS X),\nwhen the LOCALDOMAIN environment variable is present (even if empty),\nwhen the RES_OPTIONS or HOSTALIASES environment variable is non-empty,\nwhen the ASR_CONFIG environment variable is non-empty (OpenBSD only),\nwhen /etc/resolv.conf or /etc/nsswitch.conf specify the use of features that the\nGo resolver does not implement, and when the name being looked up ends in .local\nor is an mDNS name.\n\nThe resolver decision can be overridden by setting the netdns value of the\nGODEBUG environment variable (see package runtime) to go or cgo, as in:\n\n\texport GODEBUG=netdns=go    # force pure Go resolver\n\texport GODEBUG=netdns=cgo   # force cgo resolver\n\nThe decision can also be forced while building the Go source tree\nby setting the netgo or netcgo build tag.\n\nA numeric netdns setting, as in GODEBUG=netdns=1, causes the resolver\nto print debugging information about its decisions.\nTo force a particular resolver while also printing debugging information,\njoin the two settings by a plus sign, as in GODEBUG=netdns=go+1.\n\nOn Plan 9, the resolver always accesses /net/cs and /net/dns.\n\nOn Windows, the resolver always uses C library functions, such as GetAddrInfo and DnsQuery.\n"
    :empty false}
  go.std.net)
JOKER TYPE net/url.Error from net/url/url.go:
JOKER TYPE net/url.EscapeError from net/url/url.go:
JOKER TYPE net/url.InvalidHostError from net/url/url.go:
JOKER TYPE net/url.URL from net/url/url.go:
JOKER TYPE net/url.Userinfo from net/url/url.go:
JOKER TYPE net/url.Values from net/url/url.go:
JOKER FUNC net/url.Parse from net/url/url.go:
(defn Parse
  "Parse parses rawurl into a URL structure.\n\nThe rawurl may be relative (a path, without a host) or absolute\n(starting with a scheme). Trying to parse a hostname and path\nwithout a scheme is invalid but may not necessarily return an\nerror, due to parsing ambiguities.\n\nGo input arguments: (rawurl string)\n\nGo return type: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker return type: [(atom-of go.std.net.url/URL) Error]"
  {:added "1.0"
   :go "__parse(__rawurl)"}
  [^String __rawurl])

JOKER FUNC net/url.ParseQuery from net/url/url.go:
(defn ParseQuery
  "ParseQuery parses the URL-encoded query string and returns\na map listing the values specified for each key.\nParseQuery always returns a non-nil map containing all the\nvalid query parameters found; err describes the first decoding error\nencountered, if any.\n\nQuery is expected to be a list of key=value settings separated by\nampersands or semicolons. A setting without an equals sign is\ninterpreted as a key set to an empty value.\n\nGo input arguments: (query string)\n\nGo return type: (Values, error)\n\nJoker input arguments: [^String query]\n\nJoker return type: [go.std.net.url/Values Error]"
  {:added "1.0"
   :go "__parseQuery(__query)"}
  [^String __query])

JOKER FUNC net/url.ParseRequestURI from net/url/url.go:
(defn ParseRequestURI
  "ParseRequestURI parses rawurl into a URL structure. It assumes that\nrawurl was received in an HTTP request, so the rawurl is interpreted\nonly as an absolute URI or an absolute path.\nThe string rawurl is assumed not to have a #fragment suffix.\n(Web browsers strip #fragment before sending the URL to a web server.)\n\nGo input arguments: (rawurl string)\n\nGo return type: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker return type: [(atom-of go.std.net.url/URL) Error]"
  {:added "1.0"
   :go "__parseRequestURI(__rawurl)"}
  [^String __rawurl])

JOKER FUNC net/url.PathEscape from net/url/url.go:
(defn ^"String" PathEscape
  "PathEscape escapes the string so it can be safely placed\ninside a URL path segment.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "url.PathEscape(__s)"}
  [^String __s])

JOKER FUNC net/url.PathUnescape from net/url/url.go:
(defn PathUnescape
  "PathUnescape does the inverse transformation of PathEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB. It returns an error if any % is not followed\nby two hexadecimal digits.\n\nPathUnescape is identical to QueryUnescape except that it does not\nunescape '+' to ' ' (space).\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__pathUnescape(__s)"}
  [^String __s])

JOKER FUNC net/url.QueryEscape from net/url/url.go:
(defn ^"String" QueryEscape
  "QueryEscape escapes the string so it can be safely placed\ninside a URL query.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "url.QueryEscape(__s)"}
  [^String __s])

JOKER FUNC net/url.QueryUnescape from net/url/url.go:
(defn QueryUnescape
  "QueryUnescape does the inverse transformation of QueryEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB.\nIt returns an error if any % is not followed by two hexadecimal\ndigits.\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__queryUnescape(__s)"}
  [^String __s])

JOKER FUNC net/url.User from net/url/url.go:
(defn User
  "User returns a Userinfo containing the provided username\nand no password set.\n\nGo input arguments: (username string)\n\nGo return type: *Userinfo\n\nJoker input arguments: [^String username]\n\nJoker return type: (atom-of go.std.net.url/Userinfo)"
  {:added "1.0"
   :go "__user(__username)"}
  [^String __username])

JOKER FUNC net/url.UserPassword from net/url/url.go:
(defn UserPassword
  "UserPassword returns a Userinfo containing the provided username\nand password.\n\nThis functionality should only be used with legacy web sites.\nRFC 2396 warns that interpreting Userinfo this way\n``is NOT RECOMMENDED, because the passing of authentication\ninformation in clear text (such as URI) has proven to be a\nsecurity risk in almost every case where it has been used.''\n\nGo input arguments: (username string, password string)\n\nGo return type: *Userinfo\n\nJoker input arguments: [^String username, ^String password]\n\nJoker return type: (atom-of go.std.net.url/Userinfo)"
  {:added "1.0"
   :go "__userPassword(__username, __password)"}
  [^String __username, ^String __password])

JOKER TYPE go.std.net.url/Error:
(def
  ^{:doc "Error reports an error and the operation and URL that caused it.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Error"}
  Error)

JOKER TYPE *go.std.net.url/Error:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Error"}
  *Error)

JOKER TYPE go.std.net.url/EscapeError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_EscapeError"}
  EscapeError)

JOKER TYPE *go.std.net.url/EscapeError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_EscapeError"}
  *EscapeError)

JOKER TYPE go.std.net.url/InvalidHostError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_InvalidHostError"}
  InvalidHostError)

JOKER TYPE *go.std.net.url/InvalidHostError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_InvalidHostError"}
  *InvalidHostError)

JOKER TYPE go.std.net.url/URL:
(def
  ^{:doc "A URL represents a parsed URL (technically, a URI reference).\n\nThe general form represented is:\n\n\t[scheme:][//[userinfo@]host][/]path[?query][#fragment]\n\nURLs that do not start with a slash after the scheme are interpreted as:\n\n\tscheme:opaque[?query][#fragment]\n\nNote that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.\nA consequence is that it is impossible to tell which slashes in the Path were\nslashes in the raw URL and which were %2f. This distinction is rarely important,\nbut when it is, code must not use Path directly.\nThe Parse function sets both Path and RawPath in the URL it returns,\nand URL's String method uses RawPath if it is a valid encoding of Path,\nby calling the EscapedPath method.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_URL"}
  URL)

JOKER TYPE *go.std.net.url/URL:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_URL"}
  *URL)

JOKER TYPE go.std.net.url/Userinfo:
(def
  ^{:doc "The Userinfo type is an immutable encapsulation of username and\npassword details for a URL. An existing Userinfo value is guaranteed\nto have a username set (potentially empty, as allowed by RFC 2396),\nand optionally a password.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Userinfo"}
  Userinfo)

JOKER TYPE *go.std.net.url/Userinfo:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Userinfo"}
  *Userinfo)

JOKER TYPE go.std.net.url/Values:
(def
  ^{:doc "Values maps a string key to a list of values.\nIt is typically used for query parameters and form values.\nUnlike in the http.Header map, the keys in a Values map\nare case-sensitive.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Values"}
  Values)

JOKER TYPE *go.std.net.url/Values:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Values"}
  *Values)

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net/url"]
    :doc "Provides a low-level interface to the net/url package.\n\nPackage url parses URLs and implements query escaping.\n"
    :empty false}
  go.std.net.url)
GO TYPE net.Addr from net/net.go:
func ExtractGoObjectAddr(args []Object, index int) *_net.Addr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Addr:
			return &r
		case *_net.Addr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Addr]"))
}

func ExtractGo_go_std_net__Addr(rcvr, arg string, args *ArraySeq, n int) (res _net.Addr) {
	a := CheckGoNth(rcvr, "go.std.net/Addr", arg, args, n).O
	res, ok := a.(_net.Addr)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Addr], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.AddrError from net/net.go:
func ExtractGoObjectAddrError(args []Object, index int) *_net.AddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.AddrError:
			return &r
		case *_net.AddrError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.AddrError]"))
}

func ExtractGo_go_std_net__AddrError(rcvr, arg string, args *ArraySeq, n int) (res _net.AddrError) {
	a := CheckGoNth(rcvr, "go.std.net/AddrError", arg, args, n).O
	res, ok := a.(_net.AddrError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/AddrError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func _mapToAddrError(o Map) *_net.AddrError {
	return &_net.AddrError{
		Err: FieldAsString(o, "Err"),
		Addr: FieldAsString(o, "Addr"),
	}
}

func _Ctor_AddrError(_v Object) *_net.AddrError {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToAddrError(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.AddrError] or: Map"))
}

func _Wrapped_Ctor_AddrError(_o Object) Object {
	return MakeGoObject(_Ctor_AddrError(_o))
}

GO TYPE net.Buffers from net/net.go:
func ExtractGoObjectBuffers(args []Object, index int) *_net.Buffers {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Buffers:
			return &r
		case *_net.Buffers:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Buffers]"))
}

func ExtractGo_go_std_net__Buffers(rcvr, arg string, args *ArraySeq, n int) (res _net.Buffers) {
	a := CheckGoNth(rcvr, "go.std.net/Buffers", arg, args, n).O
	res, ok := a.(_net.Buffers)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Buffers], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

// func _Ctor_Buffers(_v Object) _net.Buffers {
// 	switch _o := _v.(type) {
// 	default:
// 		return _net.Buffers(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for Buffers))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Buffers] or: whatever"))
// }

// func _Wrapped_Ctor_Buffers(_o Object) Object {
// 	return MakeGoObject(_Ctor_Buffers(_o))
// }

GO TYPE net.Conn from net/net.go:
func ExtractGoObjectConn(args []Object, index int) *_net.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Conn:
			return &r
		case *_net.Conn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Conn]"))
}

func ExtractGo_go_std_net__Conn(rcvr, arg string, args *ArraySeq, n int) (res _net.Conn) {
	a := CheckGoNth(rcvr, "go.std.net/Conn", arg, args, n).O
	res, ok := a.(_net.Conn)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Conn], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.DNSConfigError from net/net.go:
func ExtractGoObjectDNSConfigError(args []Object, index int) *_net.DNSConfigError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.DNSConfigError:
			return &r
		case *_net.DNSConfigError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.DNSConfigError]"))
}

func ExtractGo_go_std_net__DNSConfigError(rcvr, arg string, args *ArraySeq, n int) (res _net.DNSConfigError) {
	a := CheckGoNth(rcvr, "go.std.net/DNSConfigError", arg, args, n).O
	res, ok := a.(_net.DNSConfigError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/DNSConfigError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func _mapToDNSConfigError(o Map) *_net.DNSConfigError {
	return &_net.DNSConfigError{
		Err: FieldAsError(o, "Err"),
	}
}

func _Ctor_DNSConfigError(_v Object) *_net.DNSConfigError {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToDNSConfigError(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.DNSConfigError] or: Map"))
}

func _Wrapped_Ctor_DNSConfigError(_o Object) Object {
	return MakeGoObject(_Ctor_DNSConfigError(_o))
}

GO TYPE net.DNSError from net/net.go:
func ExtractGoObjectDNSError(args []Object, index int) *_net.DNSError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.DNSError:
			return &r
		case *_net.DNSError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.DNSError]"))
}

func ExtractGo_go_std_net__DNSError(rcvr, arg string, args *ArraySeq, n int) (res _net.DNSError) {
	a := CheckGoNth(rcvr, "go.std.net/DNSError", arg, args, n).O
	res, ok := a.(_net.DNSError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/DNSError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func _mapToDNSError(o Map) *_net.DNSError {
	return &_net.DNSError{
		Err: FieldAsString(o, "Err"),
		Name: FieldAsString(o, "Name"),
		Server: FieldAsString(o, "Server"),
		IsTimeout: FieldAsBoolean(o, "IsTimeout"),
		IsTemporary: FieldAsBoolean(o, "IsTemporary"),
	}
}

func _Ctor_DNSError(_v Object) *_net.DNSError {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToDNSError(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.DNSError] or: Map"))
}

func _Wrapped_Ctor_DNSError(_o Object) Object {
	return MakeGoObject(_Ctor_DNSError(_o))
}

GO TYPE net.Error from net/net.go:
func ExtractGoObjectError(args []Object, index int) *_net.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Error:
			return &r
		case *_net.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Error]"))
}

func ExtractGo_go_std_net__Error(rcvr, arg string, args *ArraySeq, n int) (res _net.Error) {
	a := CheckGoNth(rcvr, "go.std.net/Error", arg, args, n).O
	res, ok := a.(_net.Error)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Error], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.IP from net/ip.go:
func ExtractGoObjectIP(args []Object, index int) *_net.IP {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IP:
			return &r
		case *_net.IP:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IP]"))
}

func ExtractGo_go_std_net__IP(rcvr, arg string, args *ArraySeq, n int) (res _net.IP) {
	a := CheckGoNth(rcvr, "go.std.net/IP", arg, args, n).O
	res, ok := a.(_net.IP)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/IP], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

// func _Ctor_IP(_v Object) _net.IP {
// 	switch _o := _v.(type) {
// 	default:
// 		return _net.IP(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for IP))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IP] or: whatever"))
// }

// func _Wrapped_Ctor_IP(_o Object) Object {
// 	return MakeGoObject(_Ctor_IP(_o))
// }

GO TYPE net.IPAddr from net/iprawsock.go:
func ExtractGoObjectIPAddr(args []Object, index int) *_net.IPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPAddr:
			return &r
		case *_net.IPAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPAddr]"))
}

func ExtractGo_go_std_net__IPAddr(rcvr, arg string, args *ArraySeq, n int) (res _net.IPAddr) {
	a := CheckGoNth(rcvr, "go.std.net/IPAddr", arg, args, n).O
	res, ok := a.(_net.IPAddr)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/IPAddr], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

// func _mapToIPAddr(o Map) *_net.IPAddr {
// 	return &_net.IPAddr{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Zone: FieldAsString(o, "Zone"),
// 	}
// }

// func _Ctor_IPAddr(_v Object) *_net.IPAddr {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToIPAddr(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPAddr] or: Map"))
// }

// func _Wrapped_Ctor_IPAddr(_o Object) Object {
// 	return MakeGoObject(_Ctor_IPAddr(_o))
// }

GO TYPE net.IPConn from net/iprawsock.go:
func ExtractGoObjectIPConn(args []Object, index int) *_net.IPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPConn:
			return &r
		case *_net.IPConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPConn]"))
}

func ExtractGo_go_std_net__IPConn(rcvr, arg string, args *ArraySeq, n int) (res _net.IPConn) {
	a := CheckGoNth(rcvr, "go.std.net/IPConn", arg, args, n).O
	res, ok := a.(_net.IPConn)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/IPConn], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func _mapToIPConn(o Map) *_net.IPConn {
	return &_net.IPConn{}
}

func _Ctor_IPConn(_v Object) *_net.IPConn {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToIPConn(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPConn] or: Map"))
}

func _Wrapped_Ctor_IPConn(_o Object) Object {
	return MakeGoObject(_Ctor_IPConn(_o))
}

GO TYPE net.IPMask from net/ip.go:
func ExtractGoObjectIPMask(args []Object, index int) *_net.IPMask {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPMask:
			return &r
		case *_net.IPMask:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPMask]"))
}

func ExtractGo_go_std_net__IPMask(rcvr, arg string, args *ArraySeq, n int) (res _net.IPMask) {
	a := CheckGoNth(rcvr, "go.std.net/IPMask", arg, args, n).O
	res, ok := a.(_net.IPMask)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/IPMask], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

// func _Ctor_IPMask(_v Object) _net.IPMask {
// 	switch _o := _v.(type) {
// 	default:
// 		return _net.IPMask(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for IPMask))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPMask] or: whatever"))
// }

// func _Wrapped_Ctor_IPMask(_o Object) Object {
// 	return MakeGoObject(_Ctor_IPMask(_o))
// }

GO TYPE net.IPNet from net/ip.go:
func ExtractGoObjectIPNet(args []Object, index int) *_net.IPNet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPNet:
			return &r
		case *_net.IPNet:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPNet]"))
}

func ExtractGo_go_std_net__IPNet(rcvr, arg string, args *ArraySeq, n int) (res _net.IPNet) {
	a := CheckGoNth(rcvr, "go.std.net/IPNet", arg, args, n).O
	res, ok := a.(_net.IPNet)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/IPNet], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

// func _mapToIPNet(o Map) *_net.IPNet {
// 	return &_net.IPNet{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Mask: ABEND048(codegen.go: no conversion from Clojure for net.IPMask ([]byte)),
// 	}
// }

// func _Ctor_IPNet(_v Object) *_net.IPNet {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToIPNet(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPNet] or: Map"))
// }

// func _Wrapped_Ctor_IPNet(_o Object) Object {
// 	return MakeGoObject(_Ctor_IPNet(_o))
// }

GO TYPE net.InvalidAddrError from net/net.go:
func ExtractGoObjectInvalidAddrError(args []Object, index int) *_net.InvalidAddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.InvalidAddrError:
			return &r
		case *_net.InvalidAddrError:
			return r
		}
	case String:
		v := _net.InvalidAddrError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.InvalidAddrError]"))
}

func ExtractGo_go_std_net__InvalidAddrError(rcvr, arg string, args *ArraySeq, n int) (res _net.InvalidAddrError) {
	a := CheckGoNth(rcvr, "go.std.net/InvalidAddrError", arg, args, n).O
	res, ok := a.(_net.InvalidAddrError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/InvalidAddrError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func _Ctor_InvalidAddrError(_v Object) _net.InvalidAddrError {
	switch _o := _v.(type) {
	case String:
		return _net.InvalidAddrError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.InvalidAddrError] or: String"))
}

func _Wrapped_Ctor_InvalidAddrError(_o Object) Object {
	return MakeGoObject(_Ctor_InvalidAddrError(_o))
}

GO TYPE net.Listener from net/net.go:
func ExtractGoObjectListener(args []Object, index int) *_net.Listener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Listener:
			return &r
		case *_net.Listener:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Listener]"))
}

func ExtractGo_go_std_net__Listener(rcvr, arg string, args *ArraySeq, n int) (res _net.Listener) {
	a := CheckGoNth(rcvr, "go.std.net/Listener", arg, args, n).O
	res, ok := a.(_net.Listener)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Listener], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.MX from net/dnsclient.go:
func ExtractGoObjectMX(args []Object, index int) *_net.MX {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.MX:
			return &r
		case *_net.MX:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.MX]"))
}

func ExtractGo_go_std_net__MX(rcvr, arg string, args *ArraySeq, n int) (res _net.MX) {
	a := CheckGoNth(rcvr, "go.std.net/MX", arg, args, n).O
	res, ok := a.(_net.MX)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/MX], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func _mapToMX(o Map) *_net.MX {
	return &_net.MX{
		Host: FieldAsString(o, "Host"),
		Pref: FieldAsUint16(o, "Pref"),
	}
}

func _Ctor_MX(_v Object) *_net.MX {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToMX(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.MX] or: Map"))
}

func _Wrapped_Ctor_MX(_o Object) Object {
	return MakeGoObject(_Ctor_MX(_o))
}

GO TYPE net.NS from net/dnsclient.go:
func ExtractGoObjectNS(args []Object, index int) *_net.NS {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.NS:
			return &r
		case *_net.NS:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.NS]"))
}

func ExtractGo_go_std_net__NS(rcvr, arg string, args *ArraySeq, n int) (res _net.NS) {
	a := CheckGoNth(rcvr, "go.std.net/NS", arg, args, n).O
	res, ok := a.(_net.NS)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/NS], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func _mapToNS(o Map) *_net.NS {
	return &_net.NS{
		Host: FieldAsString(o, "Host"),
	}
}

func _Ctor_NS(_v Object) *_net.NS {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToNS(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.NS] or: Map"))
}

func _Wrapped_Ctor_NS(_o Object) Object {
	return MakeGoObject(_Ctor_NS(_o))
}

GO TYPE net.OpError from net/net.go:
func ExtractGoObjectOpError(args []Object, index int) *_net.OpError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.OpError:
			return &r
		case *_net.OpError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.OpError]"))
}

func ExtractGo_go_std_net__OpError(rcvr, arg string, args *ArraySeq, n int) (res _net.OpError) {
	a := CheckGoNth(rcvr, "go.std.net/OpError", arg, args, n).O
	res, ok := a.(_net.OpError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/OpError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

// func _mapToOpError(o Map) *_net.OpError {
// 	return &_net.OpError{
// 		Op: FieldAsString(o, "Op"),
// 		Net: FieldAsString(o, "Net"),
// 		Source: ABEND048(codegen.go: no conversion from Clojure for net.Addr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Addr: ABEND048(codegen.go: no conversion from Clojure for net.Addr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Err: FieldAsError(o, "Err"),
// 	}
// }

// func _Ctor_OpError(_v Object) *_net.OpError {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToOpError(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.OpError] or: Map"))
// }

// func _Wrapped_Ctor_OpError(_o Object) Object {
// 	return MakeGoObject(_Ctor_OpError(_o))
// }

GO TYPE net.PacketConn from net/net.go:
func ExtractGoObjectPacketConn(args []Object, index int) *_net.PacketConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.PacketConn:
			return &r
		case *_net.PacketConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.PacketConn]"))
}

func ExtractGo_go_std_net__PacketConn(rcvr, arg string, args *ArraySeq, n int) (res _net.PacketConn) {
	a := CheckGoNth(rcvr, "go.std.net/PacketConn", arg, args, n).O
	res, ok := a.(_net.PacketConn)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/PacketConn], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.ParseError from net/net.go:
func ExtractGoObjectParseError(args []Object, index int) *_net.ParseError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.ParseError:
			return &r
		case *_net.ParseError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.ParseError]"))
}

func ExtractGo_go_std_net__ParseError(rcvr, arg string, args *ArraySeq, n int) (res _net.ParseError) {
	a := CheckGoNth(rcvr, "go.std.net/ParseError", arg, args, n).O
	res, ok := a.(_net.ParseError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/ParseError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func _mapToParseError(o Map) *_net.ParseError {
	return &_net.ParseError{
		Type: FieldAsString(o, "Type"),
		Text: FieldAsString(o, "Text"),
	}
}

func _Ctor_ParseError(_v Object) *_net.ParseError {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToParseError(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.ParseError] or: Map"))
}

func _Wrapped_Ctor_ParseError(_o Object) Object {
	return MakeGoObject(_Ctor_ParseError(_o))
}

GO TYPE net.Resolver from net/lookup.go:
func ExtractGoObjectResolver(args []Object, index int) *_net.Resolver {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Resolver:
			return &r
		case *_net.Resolver:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Resolver]"))
}

func ExtractGo_go_std_net__Resolver(rcvr, arg string, args *ArraySeq, n int) (res _net.Resolver) {
	a := CheckGoNth(rcvr, "go.std.net/Resolver", arg, args, n).O
	res, ok := a.(_net.Resolver)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Resolver], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

// func _mapToResolver(o Map) *_net.Resolver {
// 	return &_net.Resolver{
// 		PreferGo: FieldAsBoolean(o, "PreferGo"),
// 		StrictErrors: FieldAsBoolean(o, "StrictErrors"),
// 		Dial: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _Ctor_Resolver(_v Object) *_net.Resolver {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToResolver(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Resolver] or: Map"))
// }

// func _Wrapped_Ctor_Resolver(_o Object) Object {
// 	return MakeGoObject(_Ctor_Resolver(_o))
// }

GO TYPE net.SRV from net/dnsclient.go:
func ExtractGoObjectSRV(args []Object, index int) *_net.SRV {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.SRV:
			return &r
		case *_net.SRV:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.SRV]"))
}

func ExtractGo_go_std_net__SRV(rcvr, arg string, args *ArraySeq, n int) (res _net.SRV) {
	a := CheckGoNth(rcvr, "go.std.net/SRV", arg, args, n).O
	res, ok := a.(_net.SRV)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/SRV], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func _mapToSRV(o Map) *_net.SRV {
	return &_net.SRV{
		Target: FieldAsString(o, "Target"),
		Port: FieldAsUint16(o, "Port"),
		Priority: FieldAsUint16(o, "Priority"),
		Weight: FieldAsUint16(o, "Weight"),
	}
}

func _Ctor_SRV(_v Object) *_net.SRV {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToSRV(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.SRV] or: Map"))
}

func _Wrapped_Ctor_SRV(_o Object) Object {
	return MakeGoObject(_Ctor_SRV(_o))
}

GO TYPE net.UnknownNetworkError from net/net.go:
func ExtractGoObjectUnknownNetworkError(args []Object, index int) *_net.UnknownNetworkError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UnknownNetworkError:
			return &r
		case *_net.UnknownNetworkError:
			return r
		}
	case String:
		v := _net.UnknownNetworkError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnknownNetworkError]"))
}

func ExtractGo_go_std_net__UnknownNetworkError(rcvr, arg string, args *ArraySeq, n int) (res _net.UnknownNetworkError) {
	a := CheckGoNth(rcvr, "go.std.net/UnknownNetworkError", arg, args, n).O
	res, ok := a.(_net.UnknownNetworkError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/UnknownNetworkError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func _Ctor_UnknownNetworkError(_v Object) _net.UnknownNetworkError {
	switch _o := _v.(type) {
	case String:
		return _net.UnknownNetworkError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnknownNetworkError] or: String"))
}

func _Wrapped_Ctor_UnknownNetworkError(_o Object) Object {
	return MakeGoObject(_Ctor_UnknownNetworkError(_o))
}

GO FUNC net.CIDRMask from net/ip.go:
func __cIDRMask(__ones int, __bits int) Object {
	_res := _net.CIDRMask(__ones, __bits)
	return MakeGoObject(_res)
}

GO FUNC net.DialIP from net/iprawsock.go:
func __dialIP(__network string, __laddr *_net.IPAddr, __raddr *_net.IPAddr) Object {
	_res1, _res2 := _net.DialIP(__network, __laddr, __raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.IPv4 from net/ip.go:
func __iPv4(__a byte, __b byte, __c byte, __d byte) Object {
	_res := _net.IPv4(__a, __b, __c, __d)
	return MakeGoObject(_res)
}

GO FUNC net.IPv4Mask from net/ip.go:
func __iPv4Mask(__a byte, __b byte, __c byte, __d byte) Object {
	_res := _net.IPv4Mask(__a, __b, __c, __d)
	return MakeGoObject(_res)
}

GO FUNC net.ListenIP from net/iprawsock.go:
func __listenIP(__network string, __laddr *_net.IPAddr) Object {
	_res1, _res2 := _net.ListenIP(__network, __laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupAddr from net/lookup.go:
func __lookupAddr(__addr string) Object {
	names, err := _net.LookupAddr(__addr)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range names {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupCNAME from net/lookup.go:
func __lookupCNAME(__host string) Object {
	cname, err := _net.LookupCNAME(__host)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(cname))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupHost from net/lookup.go:
func __lookupHost(__host string) Object {
	addrs, err := _net.LookupHost(__host)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range addrs {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupIP from net/lookup.go:
func __lookupIP(__host string) Object {
	_res1, _res2 := _net.LookupIP(__host)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupMX from net/lookup.go:
func __lookupMX(__name string) Object {
	_res1, _res2 := _net.LookupMX(__name)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupNS from net/lookup.go:
func __lookupNS(__name string) Object {
	_res1, _res2 := _net.LookupNS(__name)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupPort from net/lookup.go:
func __lookupPort(__network string, __service string) Object {
	port, err := _net.LookupPort(__network, __service)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(port))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupSRV from net/lookup.go:
func __lookupSRV(__service string, __proto string, __name string) Object {
	cname, addrs, err := _net.LookupSRV(__service, __proto, __name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(cname))
	_vec1 := EmptyVector()
	for _, _elem1 := range addrs {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupTXT from net/lookup.go:
func __lookupTXT(__name string) Object {
	_res1, _res2 := _net.LookupTXT(__name)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ParseCIDR from net/ip.go:
func __parseCIDR(__s string) Object {
	_res1, _res2, _res3 := _net.ParseCIDR(__s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
	return _res
}

GO FUNC net.ParseIP from net/ip.go:
func __parseIP(__s string) Object {
	_res := _net.ParseIP(__s)
	return MakeGoObject(_res)
}

GO FUNC net.ResolveIPAddr from net/iprawsock.go:
func __resolveIPAddr(__network string, __address string) Object {
	_res1, _res2 := _net.ResolveIPAddr(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__addr_Network from net/net.go:
func __addr_Network(o GoObject, args Object) Object {  // Method
	CheckGoArity("(net.Addr)Network()", args, 0, 0)
	_res := o.O.(_net.Addr).Network()
	return MakeString(_res)
}

GO FUNC net.__addr_String from net/net.go:
func __addr_String(o GoObject, args Object) Object {  // Method
	CheckGoArity("(net.Addr)String()", args, 0, 0)
	_res := o.O.(_net.Addr).String()
	return MakeString(_res)
}

GO FUNC net.__conn_Close from net/net.go:
func __conn_Close(o GoObject, args Object) Object {  // Method
	CheckGoArity("(net.Conn)Close()", args, 0, 0)
	_res := o.O.(_net.Conn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__conn_LocalAddr from net/net.go:
func __conn_LocalAddr(o GoObject, args Object) Object {  // Method
	CheckGoArity("(net.Conn)LocalAddr()", args, 0, 0)
	_res := o.O.(_net.Conn).LocalAddr()
	return MakeGoObject(_res)
}

GO FUNC net.__conn_Read from net/net.go:
// func __conn_Read(o GoObject, args Object) Object {  // Method
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))}

GO FUNC net.__conn_RemoteAddr from net/net.go:
func __conn_RemoteAddr(o GoObject, args Object) Object {  // Method
	CheckGoArity("(net.Conn)RemoteAddr()", args, 0, 0)
	_res := o.O.(_net.Conn).RemoteAddr()
	return MakeGoObject(_res)
}

GO FUNC net.__conn_SetDeadline from net/net.go:
// func __conn_SetDeadline(o GoObject, args Object) Object {  // Method
// __t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC net.__conn_SetReadDeadline from net/net.go:
// func __conn_SetReadDeadline(o GoObject, args Object) Object {  // Method
// __t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC net.__conn_SetWriteDeadline from net/net.go:
// func __conn_SetWriteDeadline(o GoObject, args Object) Object {  // Method
// __t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC net.__conn_Write from net/net.go:
// func __conn_Write(o GoObject, args Object) Object {  // Method
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))}

GO FUNC net.__error_Error from net/net.go:
// func __error_Error(o GoObject, args Object) Object {  // Method
// 	CheckGoArity("(net.Error)Error()", args, 0, 0)
// 	return o.O.(_net.Error).Error()
// 	ABEND124(post.go: no public information returned)
// }

GO FUNC net.__error_Temporary from net/net.go:
func __error_Temporary(o GoObject, args Object) Object {  // Method
	CheckGoArity("(net.Error)Temporary()", args, 0, 0)
	_res := o.O.(_net.Error).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net.__error_Timeout from net/net.go:
func __error_Timeout(o GoObject, args Object) Object {  // Method
	CheckGoArity("(net.Error)Timeout()", args, 0, 0)
	_res := o.O.(_net.Error).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net.__iPMask_Size from net/ip.go:
func __iPMask_Size(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net.IPMask)Size()", args, 0, 0)
	ones, bits := o.O.(_net.IPMask).Size()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(ones))
	_res = _res.Conjoin(MakeInt(bits))
	return _res
}

GO FUNC net.__iPMask_String from net/ip.go:
func __iPMask_String(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net.IPMask)String()", args, 0, 0)
	_res := o.O.(_net.IPMask).String()
	return MakeString(_res)
}

GO FUNC net.__iP_DefaultMask from net/ip.go:
func __iP_DefaultMask(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net.IP)DefaultMask()", args, 0, 0)
	_res := o.O.(_net.IP).DefaultMask()
	return MakeGoObject(_res)
}

GO FUNC net.__iP_Equal from net/ip.go:
func __iP_Equal(o GoObject, args Object) Object {  // Receiver
	_argList := CheckGoArity("(_net.IP)Equal()", args, 1, 1)
	__x := ExtractGo_go_std_net__IP("(_net.IP)Equal()", "__x", _argList, 0)
	_res := o.O.(_net.IP).Equal(__x)
	return MakeBoolean(_res)
}

GO FUNC net.__iP_IsGlobalUnicast from net/ip.go:
func __iP_IsGlobalUnicast(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net.IP)IsGlobalUnicast()", args, 0, 0)
	_res := o.O.(_net.IP).IsGlobalUnicast()
	return MakeBoolean(_res)
}

GO FUNC net.__iP_IsInterfaceLocalMulticast from net/ip.go:
func __iP_IsInterfaceLocalMulticast(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net.IP)IsInterfaceLocalMulticast()", args, 0, 0)
	_res := o.O.(_net.IP).IsInterfaceLocalMulticast()
	return MakeBoolean(_res)
}

GO FUNC net.__iP_IsLinkLocalMulticast from net/ip.go:
func __iP_IsLinkLocalMulticast(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net.IP)IsLinkLocalMulticast()", args, 0, 0)
	_res := o.O.(_net.IP).IsLinkLocalMulticast()
	return MakeBoolean(_res)
}

GO FUNC net.__iP_IsLinkLocalUnicast from net/ip.go:
func __iP_IsLinkLocalUnicast(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net.IP)IsLinkLocalUnicast()", args, 0, 0)
	_res := o.O.(_net.IP).IsLinkLocalUnicast()
	return MakeBoolean(_res)
}

GO FUNC net.__iP_IsLoopback from net/ip.go:
func __iP_IsLoopback(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net.IP)IsLoopback()", args, 0, 0)
	_res := o.O.(_net.IP).IsLoopback()
	return MakeBoolean(_res)
}

GO FUNC net.__iP_IsMulticast from net/ip.go:
func __iP_IsMulticast(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net.IP)IsMulticast()", args, 0, 0)
	_res := o.O.(_net.IP).IsMulticast()
	return MakeBoolean(_res)
}

GO FUNC net.__iP_IsUnspecified from net/ip.go:
func __iP_IsUnspecified(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net.IP)IsUnspecified()", args, 0, 0)
	_res := o.O.(_net.IP).IsUnspecified()
	return MakeBoolean(_res)
}

GO FUNC net.__iP_MarshalText from net/ip.go:
func __iP_MarshalText(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net.IP)MarshalText()", args, 0, 0)
	_res1, _res2 := o.O.(_net.IP).MarshalText()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__iP_Mask from net/ip.go:
func __iP_Mask(o GoObject, args Object) Object {  // Receiver
	_argList := CheckGoArity("(_net.IP)Mask()", args, 1, 1)
	__mask := ExtractGo_go_std_net__IPMask("(_net.IP)Mask()", "__mask", _argList, 0)
	_res := o.O.(_net.IP).Mask(__mask)
	return MakeGoObject(_res)
}

GO FUNC net.__iP_String from net/ip.go:
func __iP_String(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net.IP)String()", args, 0, 0)
	_res := o.O.(_net.IP).String()
	return MakeString(_res)
}

GO FUNC net.__iP_To16 from net/ip.go:
func __iP_To16(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net.IP)To16()", args, 0, 0)
	_res := o.O.(_net.IP).To16()
	return MakeGoObject(_res)
}

GO FUNC net.__iP_To4 from net/ip.go:
func __iP_To4(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net.IP)To4()", args, 0, 0)
	_res := o.O.(_net.IP).To4()
	return MakeGoObject(_res)
}

GO FUNC net.__invalidAddrError_Error from net/net.go:
func __invalidAddrError_Error(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net.InvalidAddrError)Error()", args, 0, 0)
	_res := o.O.(_net.InvalidAddrError).Error()
	return MakeString(_res)
}

GO FUNC net.__invalidAddrError_Temporary from net/net.go:
func __invalidAddrError_Temporary(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net.InvalidAddrError)Temporary()", args, 0, 0)
	_res := o.O.(_net.InvalidAddrError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net.__invalidAddrError_Timeout from net/net.go:
func __invalidAddrError_Timeout(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net.InvalidAddrError)Timeout()", args, 0, 0)
	_res := o.O.(_net.InvalidAddrError).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net.__listener_Accept from net/net.go:
func __listener_Accept(o GoObject, args Object) Object {  // Method
	CheckGoArity("(net.Listener)Accept()", args, 0, 0)
	_res1, _res2 := o.O.(_net.Listener).Accept()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__listener_Addr from net/net.go:
func __listener_Addr(o GoObject, args Object) Object {  // Method
	CheckGoArity("(net.Listener)Addr()", args, 0, 0)
	_res := o.O.(_net.Listener).Addr()
	return MakeGoObject(_res)
}

GO FUNC net.__listener_Close from net/net.go:
func __listener_Close(o GoObject, args Object) Object {  // Method
	CheckGoArity("(net.Listener)Close()", args, 0, 0)
	_res := o.O.(_net.Listener).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__packetConn_Close from net/net.go:
func __packetConn_Close(o GoObject, args Object) Object {  // Method
	CheckGoArity("(net.PacketConn)Close()", args, 0, 0)
	_res := o.O.(_net.PacketConn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__packetConn_LocalAddr from net/net.go:
func __packetConn_LocalAddr(o GoObject, args Object) Object {  // Method
	CheckGoArity("(net.PacketConn)LocalAddr()", args, 0, 0)
	_res := o.O.(_net.PacketConn).LocalAddr()
	return MakeGoObject(_res)
}

GO FUNC net.__packetConn_ReadFrom from net/net.go:
// func __packetConn_ReadFrom(o GoObject, args Object) Object {  // Method
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)))}

GO FUNC net.__packetConn_SetDeadline from net/net.go:
// func __packetConn_SetDeadline(o GoObject, args Object) Object {  // Method
// __t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC net.__packetConn_SetReadDeadline from net/net.go:
// func __packetConn_SetReadDeadline(o GoObject, args Object) Object {  // Method
// __t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC net.__packetConn_SetWriteDeadline from net/net.go:
// func __packetConn_SetWriteDeadline(o GoObject, args Object) Object {  // Method
// __t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC net.__packetConn_WriteTo from net/net.go:
// func __packetConn_WriteTo(o GoObject, args Object) Object {  // Method
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)), *__addr)}

GO FUNC net.__ptrTo_AddrError_Error from net/net.go:
func __ptrTo_AddrError_Error(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net.AddrError)Error()", args, 0, 0)
	_res := o.O.(*_net.AddrError).Error()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_AddrError_Temporary from net/net.go:
func __ptrTo_AddrError_Temporary(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net.AddrError)Temporary()", args, 0, 0)
	_res := o.O.(*_net.AddrError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_AddrError_Timeout from net/net.go:
func __ptrTo_AddrError_Timeout(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net.AddrError)Timeout()", args, 0, 0)
	_res := o.O.(*_net.AddrError).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_Buffers_Read from net/net.go:
// func __ptrTo_Buffers_Read(o GoObject, args Object) Object {  // Receiver
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)))}

GO FUNC net.__ptrTo_Buffers_WriteTo from net/net.go:
// func __ptrTo_Buffers_WriteTo(o GoObject, args Object) Object {  // Receiver
// __w ABEND987(genutils.go: imports not yet supported: io.Writer)}

GO FUNC net.__ptrTo_DNSConfigError_Error from net/net.go:
func __ptrTo_DNSConfigError_Error(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net.DNSConfigError)Error()", args, 0, 0)
	_res := o.O.(*_net.DNSConfigError).Error()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_DNSConfigError_Temporary from net/net.go:
func __ptrTo_DNSConfigError_Temporary(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net.DNSConfigError)Temporary()", args, 0, 0)
	_res := o.O.(*_net.DNSConfigError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_DNSConfigError_Timeout from net/net.go:
func __ptrTo_DNSConfigError_Timeout(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net.DNSConfigError)Timeout()", args, 0, 0)
	_res := o.O.(*_net.DNSConfigError).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_DNSError_Error from net/net.go:
func __ptrTo_DNSError_Error(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net.DNSError)Error()", args, 0, 0)
	_res := o.O.(*_net.DNSError).Error()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_DNSError_Temporary from net/net.go:
func __ptrTo_DNSError_Temporary(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net.DNSError)Temporary()", args, 0, 0)
	_res := o.O.(*_net.DNSError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_DNSError_Timeout from net/net.go:
func __ptrTo_DNSError_Timeout(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net.DNSError)Timeout()", args, 0, 0)
	_res := o.O.(*_net.DNSError).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_IPAddr_Network from net/iprawsock.go:
func __ptrTo_IPAddr_Network(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net.IPAddr)Network()", args, 0, 0)
	_res := o.O.(*_net.IPAddr).Network()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_IPAddr_String from net/iprawsock.go:
func __ptrTo_IPAddr_String(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net.IPAddr)String()", args, 0, 0)
	_res := o.O.(*_net.IPAddr).String()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_IPConn_ReadFrom from net/iprawsock.go:
// func __ptrTo_IPConn_ReadFrom(o GoObject, args Object) Object {  // Receiver
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))}

GO FUNC net.__ptrTo_IPConn_ReadFromIP from net/iprawsock.go:
// func __ptrTo_IPConn_ReadFromIP(o GoObject, args Object) Object {  // Receiver
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))}

GO FUNC net.__ptrTo_IPConn_ReadMsgIP from net/iprawsock.go:
// func __ptrTo_IPConn_ReadMsgIP(o GoObject, args Object) Object {  // Receiver
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__oob)))}

GO FUNC net.__ptrTo_IPConn_SyscallConn from net/iprawsock.go:
// func __ptrTo_IPConn_SyscallConn(o GoObject, args Object) Object {  // Receiver
// [ABEND042(post.go: cannot find typename syscall.RawConn) Error]}

GO FUNC net.__ptrTo_IPConn_WriteMsgIP from net/iprawsock.go:
// func __ptrTo_IPConn_WriteMsgIP(o GoObject, args Object) Object {  // Receiver
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__oob)), __addr)}

GO FUNC net.__ptrTo_IPConn_WriteTo from net/iprawsock.go:
// func __ptrTo_IPConn_WriteTo(o GoObject, args Object) Object {  // Receiver
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), *__addr)}

GO FUNC net.__ptrTo_IPConn_WriteToIP from net/iprawsock.go:
// func __ptrTo_IPConn_WriteToIP(o GoObject, args Object) Object {  // Receiver
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), __addr)}

GO FUNC net.__ptrTo_IPNet_Contains from net/ip.go:
func __ptrTo_IPNet_Contains(o GoObject, args Object) Object {  // Receiver
	_argList := CheckGoArity("(*_net.IPNet)Contains()", args, 1, 1)
	__ip := ExtractGo_go_std_net__IP("(*_net.IPNet)Contains()", "__ip", _argList, 0)
	_res := o.O.(*_net.IPNet).Contains(__ip)
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_IPNet_Network from net/ip.go:
func __ptrTo_IPNet_Network(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net.IPNet)Network()", args, 0, 0)
	_res := o.O.(*_net.IPNet).Network()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_IPNet_String from net/ip.go:
func __ptrTo_IPNet_String(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net.IPNet)String()", args, 0, 0)
	_res := o.O.(*_net.IPNet).String()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_IP_UnmarshalText from net/ip.go:
// func __ptrTo_IP_UnmarshalText(o GoObject, args Object) Object {  // Receiver
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__text)))}

GO FUNC net.__ptrTo_OpError_Error from net/net.go:
func __ptrTo_OpError_Error(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net.OpError)Error()", args, 0, 0)
	_res := o.O.(*_net.OpError).Error()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_OpError_Temporary from net/net.go:
func __ptrTo_OpError_Temporary(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net.OpError)Temporary()", args, 0, 0)
	_res := o.O.(*_net.OpError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_OpError_Timeout from net/net.go:
func __ptrTo_OpError_Timeout(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net.OpError)Timeout()", args, 0, 0)
	_res := o.O.(*_net.OpError).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_ParseError_Error from net/net.go:
func __ptrTo_ParseError_Error(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net.ParseError)Error()", args, 0, 0)
	_res := o.O.(*_net.ParseError).Error()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_Resolver_LookupAddr from net/lookup.go:
// func __ptrTo_Resolver_LookupAddr(o GoObject, args Object) Object {  // Receiver
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __addr string}

GO FUNC net.__ptrTo_Resolver_LookupCNAME from net/lookup.go:
// func __ptrTo_Resolver_LookupCNAME(o GoObject, args Object) Object {  // Receiver
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __host string}

GO FUNC net.__ptrTo_Resolver_LookupHost from net/lookup.go:
// func __ptrTo_Resolver_LookupHost(o GoObject, args Object) Object {  // Receiver
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __host string}

GO FUNC net.__ptrTo_Resolver_LookupIPAddr from net/lookup.go:
// func __ptrTo_Resolver_LookupIPAddr(o GoObject, args Object) Object {  // Receiver
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __host string}

GO FUNC net.__ptrTo_Resolver_LookupMX from net/lookup.go:
// func __ptrTo_Resolver_LookupMX(o GoObject, args Object) Object {  // Receiver
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __name string}

GO FUNC net.__ptrTo_Resolver_LookupNS from net/lookup.go:
// func __ptrTo_Resolver_LookupNS(o GoObject, args Object) Object {  // Receiver
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __name string}

GO FUNC net.__ptrTo_Resolver_LookupPort from net/lookup.go:
// func __ptrTo_Resolver_LookupPort(o GoObject, args Object) Object {  // Receiver
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __network string, __service string}

GO FUNC net.__ptrTo_Resolver_LookupSRV from net/lookup.go:
// func __ptrTo_Resolver_LookupSRV(o GoObject, args Object) Object {  // Receiver
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __service string, __proto string, __name string}

GO FUNC net.__ptrTo_Resolver_LookupTXT from net/lookup.go:
// func __ptrTo_Resolver_LookupTXT(o GoObject, args Object) Object {  // Receiver
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __name string}

GO FUNC net.__unknownNetworkError_Error from net/net.go:
func __unknownNetworkError_Error(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net.UnknownNetworkError)Error()", args, 0, 0)
	_res := o.O.(_net.UnknownNetworkError).Error()
	return MakeString(_res)
}

GO FUNC net.__unknownNetworkError_Temporary from net/net.go:
func __unknownNetworkError_Temporary(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net.UnknownNetworkError)Temporary()", args, 0, 0)
	_res := o.O.(_net.UnknownNetworkError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net.__unknownNetworkError_Timeout from net/net.go:
func __unknownNetworkError_Timeout(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net.UnknownNetworkError)Timeout()", args, 0, 0)
	_res := o.O.(_net.UnknownNetworkError).Timeout()
	return MakeBoolean(_res)
}

GO VARDEF FOR TYPE go.std.net/Addr from _tests/small/src/net/net.go:105:6:
var info_Addr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/AddrError from _tests/small/src/net/net.go:529:6:
var info_AddrError GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/AddrError from -:
var info_PtrTo_AddrError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/Buffers from _tests/small/src/net/net.go:651:6:
var info_Buffers GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/Buffers from -:
var info_PtrTo_Buffers GoTypeInfo

GO VARDEF FOR TYPE go.std.net/Conn from _tests/small/src/net/net.go:113:6:
var info_Conn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/DNSConfigError from _tests/small/src/net/net.go:562:6:
var info_DNSConfigError GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/DNSConfigError from -:
var info_PtrTo_DNSConfigError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/DNSError from _tests/small/src/net/net.go:576:6:
var info_DNSError GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/DNSError from -:
var info_PtrTo_DNSError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/Error from _tests/small/src/net/net.go:387:6:
var info_Error GoTypeInfo

GO VARDEF FOR TYPE go.std.net/IP from _tests/small/src/net/ip.go:32:6:
var info_IP GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/IP from -:
var info_PtrTo_IP GoTypeInfo

GO VARDEF FOR TYPE go.std.net/IPAddr from _tests/small/src/net/iprawsock.go:31:6:
var info_IPAddr GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/IPAddr from -:
var info_PtrTo_IPAddr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/IPConn from _tests/small/src/net/iprawsock.go:99:6:
var info_IPConn GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/IPConn from -:
var info_PtrTo_IPConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/IPMask from _tests/small/src/net/ip.go:35:6:
var info_IPMask GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/IPMask from -:
var info_PtrTo_IPMask GoTypeInfo

GO VARDEF FOR TYPE go.std.net/IPNet from _tests/small/src/net/ip.go:38:6:
var info_IPNet GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/IPNet from -:
var info_PtrTo_IPNet GoTypeInfo

GO VARDEF FOR TYPE go.std.net/InvalidAddrError from _tests/small/src/net/net.go:554:6:
var info_InvalidAddrError GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/InvalidAddrError from -:
var info_PtrTo_InvalidAddrError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/Listener from _tests/small/src/net/net.go:374:6:
var info_Listener GoTypeInfo

GO VARDEF FOR TYPE go.std.net/MX from _tests/small/src/net/dnsclient.go:193:6:
var info_MX GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/MX from -:
var info_PtrTo_MX GoTypeInfo

GO VARDEF FOR TYPE go.std.net/NS from _tests/small/src/net/dnsclient.go:215:6:
var info_NS GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/NS from -:
var info_PtrTo_NS GoTypeInfo

GO VARDEF FOR TYPE go.std.net/OpError from _tests/small/src/net/net.go:425:6:
var info_OpError GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/OpError from -:
var info_PtrTo_OpError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/PacketConn from _tests/small/src/net/net.go:303:6:
var info_PacketConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/ParseError from _tests/small/src/net/net.go:518:6:
var info_ParseError GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/ParseError from -:
var info_PtrTo_ParseError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/Resolver from _tests/small/src/net/lookup.go:107:6:
var info_Resolver GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/Resolver from -:
var info_PtrTo_Resolver GoTypeInfo

GO VARDEF FOR TYPE go.std.net/SRV from _tests/small/src/net/dnsclient.go:139:6:
var info_SRV GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/SRV from -:
var info_PtrTo_SRV GoTypeInfo

GO VARDEF FOR TYPE go.std.net/UnknownNetworkError from _tests/small/src/net/net.go:548:6:
var info_UnknownNetworkError GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/UnknownNetworkError from -:
var info_PtrTo_UnknownNetworkError GoTypeInfo

GO INFO FOR TYPE go.std.net/Addr from _tests/small/src/net/net.go:105:6:
	info_Addr = GoTypeInfo{Name: "go.std.net/Addr",
		GoType: &GoType{T: &info_Addr},
		Members: GoMembers{
			"Network": MakeGoReceiver("Network", __addr_Network, "name of the network (for example, \"tcp\", \"udp\")\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", __addr_String, "string form of address (for example, \"192.0.2.1:25\", \"[2001:db8::1]:80\")\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/AddrError from _tests/small/src/net/net.go:529:6:
	info_AddrError = GoTypeInfo{Name: "go.std.net/AddrError",
		GoType: &GoType{T: &info_AddrError},
		Ctor: _Wrapped_Ctor_AddrError,
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/AddrError from -:
	info_PtrTo_AddrError = GoTypeInfo{Name: "*go.std.net/AddrError",
		GoType: &GoType{T: &info_PtrTo_AddrError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __ptrTo_AddrError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", __ptrTo_AddrError_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", __ptrTo_AddrError_Timeout, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/Buffers from _tests/small/src/net/net.go:651:6:
	info_Buffers = GoTypeInfo{Name: "go.std.net/Buffers",
		GoType: &GoType{T: &info_Buffers},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/Buffers from -:
	info_PtrTo_Buffers = GoTypeInfo{Name: "*go.std.net/Buffers",
		GoType: &GoType{T: &info_PtrTo_Buffers},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/Conn from _tests/small/src/net/net.go:113:6:
	info_Conn = GoTypeInfo{Name: "go.std.net/Conn",
		GoType: &GoType{T: &info_Conn},
		Members: GoMembers{
			"Close": MakeGoReceiver("Close", __conn_Close, "Close closes the connection.\nAny blocked Read or Write operations will be unblocked and return errors.\n", "1.0", NewVectorFrom()),
			"LocalAddr": MakeGoReceiver("LocalAddr", __conn_LocalAddr, "LocalAddr returns the local network address.\n", "1.0", NewVectorFrom()),
			"RemoteAddr": MakeGoReceiver("RemoteAddr", __conn_RemoteAddr, "RemoteAddr returns the remote network address.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/DNSConfigError from _tests/small/src/net/net.go:562:6:
	info_DNSConfigError = GoTypeInfo{Name: "go.std.net/DNSConfigError",
		GoType: &GoType{T: &info_DNSConfigError},
		Ctor: _Wrapped_Ctor_DNSConfigError,
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/DNSConfigError from -:
	info_PtrTo_DNSConfigError = GoTypeInfo{Name: "*go.std.net/DNSConfigError",
		GoType: &GoType{T: &info_PtrTo_DNSConfigError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __ptrTo_DNSConfigError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", __ptrTo_DNSConfigError_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", __ptrTo_DNSConfigError_Timeout, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/DNSError from _tests/small/src/net/net.go:576:6:
	info_DNSError = GoTypeInfo{Name: "go.std.net/DNSError",
		GoType: &GoType{T: &info_DNSError},
		Ctor: _Wrapped_Ctor_DNSError,
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/DNSError from -:
	info_PtrTo_DNSError = GoTypeInfo{Name: "*go.std.net/DNSError",
		GoType: &GoType{T: &info_PtrTo_DNSError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __ptrTo_DNSError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", __ptrTo_DNSError_Temporary, "Temporary reports whether the DNS error is known to be temporary.\nThis is not always known; a DNS lookup may fail due to a temporary\nerror and return a DNSError for which Temporary returns false.\n", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", __ptrTo_DNSError_Timeout, "Timeout reports whether the DNS lookup is known to have timed out.\nThis is not always known; a DNS lookup may fail due to a timeout\nand return a DNSError for which Timeout returns false.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/Error from _tests/small/src/net/net.go:387:6:
	info_Error = GoTypeInfo{Name: "go.std.net/Error",
		GoType: &GoType{T: &info_Error},
		Members: GoMembers{
			"Temporary": MakeGoReceiver("Temporary", __error_Temporary, "Is the error temporary?\n", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", __error_Timeout, "Is the error a timeout?\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/IP from _tests/small/src/net/ip.go:32:6:
	info_IP = GoTypeInfo{Name: "go.std.net/IP",
		GoType: &GoType{T: &info_IP},
		Members: GoMembers{
			"DefaultMask": MakeGoReceiver("DefaultMask", __iP_DefaultMask, "DefaultMask returns the default IP mask for the IP address ip.\nOnly IPv4 addresses have default masks; DefaultMask returns\nnil if ip is not a valid IPv4 address.\n", "1.0", NewVectorFrom()),
			"Equal": MakeGoReceiver("Equal", __iP_Equal, "Equal reports whether ip and x are the same IP address.\nAn IPv4 address and that same address in IPv6 form are\nconsidered to be equal.\n", "1.0", NewVectorFrom(MakeSymbol("x"))),
			"IsGlobalUnicast": MakeGoReceiver("IsGlobalUnicast", __iP_IsGlobalUnicast, "IsGlobalUnicast reports whether ip is a global unicast\naddress.\n\nThe identification of global unicast addresses uses address type\nidentification as defined in RFC 1122, RFC 4632 and RFC 4291 with\nthe exception of IPv4 directed broadcast addresses.\nIt returns true even if ip is in IPv4 private address space or\nlocal IPv6 unicast address space.\n", "1.0", NewVectorFrom()),
			"IsInterfaceLocalMulticast": MakeGoReceiver("IsInterfaceLocalMulticast", __iP_IsInterfaceLocalMulticast, "IsInterfaceLocalMulticast reports whether ip is\nan interface-local multicast address.\n", "1.0", NewVectorFrom()),
			"IsLinkLocalMulticast": MakeGoReceiver("IsLinkLocalMulticast", __iP_IsLinkLocalMulticast, "IsLinkLocalMulticast reports whether ip is a link-local\nmulticast address.\n", "1.0", NewVectorFrom()),
			"IsLinkLocalUnicast": MakeGoReceiver("IsLinkLocalUnicast", __iP_IsLinkLocalUnicast, "IsLinkLocalUnicast reports whether ip is a link-local\nunicast address.\n", "1.0", NewVectorFrom()),
			"IsLoopback": MakeGoReceiver("IsLoopback", __iP_IsLoopback, "IsLoopback reports whether ip is a loopback address.\n", "1.0", NewVectorFrom()),
			"IsMulticast": MakeGoReceiver("IsMulticast", __iP_IsMulticast, "IsMulticast reports whether ip is a multicast address.\n", "1.0", NewVectorFrom()),
			"IsUnspecified": MakeGoReceiver("IsUnspecified", __iP_IsUnspecified, "IsUnspecified reports whether ip is an unspecified address, either\nthe IPv4 address \"0.0.0.0\" or the IPv6 address \"::\".\n", "1.0", NewVectorFrom()),
			"MarshalText": MakeGoReceiver("MarshalText", __iP_MarshalText, "MarshalText implements the encoding.TextMarshaler interface.\nThe encoding is the same as returned by String, with one exception:\nWhen len(ip) is zero, it returns an empty slice.\n", "1.0", NewVectorFrom()),
			"Mask": MakeGoReceiver("Mask", __iP_Mask, "Mask returns the result of masking the IP address ip with mask.\n", "1.0", NewVectorFrom(MakeSymbol("mask"))),
			"String": MakeGoReceiver("String", __iP_String, "String returns the string form of the IP address ip.\nIt returns one of 4 forms:\n  - \"<nil>\", if ip has length 0\n  - dotted decimal (\"192.0.2.1\"), if ip is an IPv4 or IP4-mapped IPv6 address\n  - IPv6 (\"2001:db8::1\"), if ip is a valid IPv6 address\n  - the hexadecimal form of ip, without punctuation, if no other cases apply\n", "1.0", NewVectorFrom()),
			"To16": MakeGoReceiver("To16", __iP_To16, "To16 converts the IP address ip to a 16-byte representation.\nIf ip is not an IP address (it is the wrong length), To16 returns nil.\n", "1.0", NewVectorFrom()),
			"To4": MakeGoReceiver("To4", __iP_To4, "To4 converts the IPv4 address ip to a 4-byte representation.\nIf ip is not an IPv4 address, To4 returns nil.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE *go.std.net/IP from -:
	info_PtrTo_IP = GoTypeInfo{Name: "*go.std.net/IP",
		GoType: &GoType{T: &info_PtrTo_IP},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/IPAddr from _tests/small/src/net/iprawsock.go:31:6:
	info_IPAddr = GoTypeInfo{Name: "go.std.net/IPAddr",
		GoType: &GoType{T: &info_IPAddr},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/IPAddr from -:
	info_PtrTo_IPAddr = GoTypeInfo{Name: "*go.std.net/IPAddr",
		GoType: &GoType{T: &info_PtrTo_IPAddr},
		Members: GoMembers{
			"Network": MakeGoReceiver("Network", __ptrTo_IPAddr_Network, "Network returns the address's network name, \"ip\".\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", __ptrTo_IPAddr_String, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/IPConn from _tests/small/src/net/iprawsock.go:99:6:
	info_IPConn = GoTypeInfo{Name: "go.std.net/IPConn",
		GoType: &GoType{T: &info_IPConn},
		Ctor: _Wrapped_Ctor_IPConn,
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/IPConn from -:
	info_PtrTo_IPConn = GoTypeInfo{Name: "*go.std.net/IPConn",
		GoType: &GoType{T: &info_PtrTo_IPConn},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/IPMask from _tests/small/src/net/ip.go:35:6:
	info_IPMask = GoTypeInfo{Name: "go.std.net/IPMask",
		GoType: &GoType{T: &info_IPMask},
		Members: GoMembers{
			"Size": MakeGoReceiver("Size", __iPMask_Size, "Size returns the number of leading ones and total bits in the mask.\nIf the mask is not in the canonical form--ones followed by zeros--then\nSize returns 0, 0.\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", __iPMask_String, "String returns the hexadecimal form of m, with no punctuation.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE *go.std.net/IPMask from -:
	info_PtrTo_IPMask = GoTypeInfo{Name: "*go.std.net/IPMask",
		GoType: &GoType{T: &info_PtrTo_IPMask},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/IPNet from _tests/small/src/net/ip.go:38:6:
	info_IPNet = GoTypeInfo{Name: "go.std.net/IPNet",
		GoType: &GoType{T: &info_IPNet},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/IPNet from -:
	info_PtrTo_IPNet = GoTypeInfo{Name: "*go.std.net/IPNet",
		GoType: &GoType{T: &info_PtrTo_IPNet},
		Members: GoMembers{
			"Contains": MakeGoReceiver("Contains", __ptrTo_IPNet_Contains, "Contains reports whether the network includes ip.\n", "1.0", NewVectorFrom(MakeSymbol("ip"))),
			"Network": MakeGoReceiver("Network", __ptrTo_IPNet_Network, "Network returns the address's network name, \"ip+net\".\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", __ptrTo_IPNet_String, "String returns the CIDR notation of n like \"192.0.2.1/24\"\nor \"2001:db8::/48\" as defined in RFC 4632 and RFC 4291.\nIf the mask is not in the canonical form, it returns the\nstring which consists of an IP address, followed by a slash\ncharacter and a mask expressed as hexadecimal form with no\npunctuation like \"198.51.100.1/c000ff00\".\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/InvalidAddrError from _tests/small/src/net/net.go:554:6:
	info_InvalidAddrError = GoTypeInfo{Name: "go.std.net/InvalidAddrError",
		GoType: &GoType{T: &info_InvalidAddrError},
		Ctor: _Wrapped_Ctor_InvalidAddrError,
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __invalidAddrError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", __invalidAddrError_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", __invalidAddrError_Timeout, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE *go.std.net/InvalidAddrError from -:
	info_PtrTo_InvalidAddrError = GoTypeInfo{Name: "*go.std.net/InvalidAddrError",
		GoType: &GoType{T: &info_PtrTo_InvalidAddrError},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/Listener from _tests/small/src/net/net.go:374:6:
	info_Listener = GoTypeInfo{Name: "go.std.net/Listener",
		GoType: &GoType{T: &info_Listener},
		Members: GoMembers{
			"Accept": MakeGoReceiver("Accept", __listener_Accept, "Accept waits for and returns the next connection to the listener.\n", "1.0", NewVectorFrom()),
			"Addr": MakeGoReceiver("Addr", __listener_Addr, "Addr returns the listener's network address.\n", "1.0", NewVectorFrom()),
			"Close": MakeGoReceiver("Close", __listener_Close, "Close closes the listener.\nAny blocked Accept operations will be unblocked and return errors.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/MX from _tests/small/src/net/dnsclient.go:193:6:
	info_MX = GoTypeInfo{Name: "go.std.net/MX",
		GoType: &GoType{T: &info_MX},
		Ctor: _Wrapped_Ctor_MX,
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/MX from -:
	info_PtrTo_MX = GoTypeInfo{Name: "*go.std.net/MX",
		GoType: &GoType{T: &info_PtrTo_MX},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/NS from _tests/small/src/net/dnsclient.go:215:6:
	info_NS = GoTypeInfo{Name: "go.std.net/NS",
		GoType: &GoType{T: &info_NS},
		Ctor: _Wrapped_Ctor_NS,
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/NS from -:
	info_PtrTo_NS = GoTypeInfo{Name: "*go.std.net/NS",
		GoType: &GoType{T: &info_PtrTo_NS},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/OpError from _tests/small/src/net/net.go:425:6:
	info_OpError = GoTypeInfo{Name: "go.std.net/OpError",
		GoType: &GoType{T: &info_OpError},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/OpError from -:
	info_PtrTo_OpError = GoTypeInfo{Name: "*go.std.net/OpError",
		GoType: &GoType{T: &info_PtrTo_OpError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __ptrTo_OpError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", __ptrTo_OpError_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", __ptrTo_OpError_Timeout, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/PacketConn from _tests/small/src/net/net.go:303:6:
	info_PacketConn = GoTypeInfo{Name: "go.std.net/PacketConn",
		GoType: &GoType{T: &info_PacketConn},
		Members: GoMembers{
			"Close": MakeGoReceiver("Close", __packetConn_Close, "Close closes the connection.\nAny blocked ReadFrom or WriteTo operations will be unblocked and return errors.\n", "1.0", NewVectorFrom()),
			"LocalAddr": MakeGoReceiver("LocalAddr", __packetConn_LocalAddr, "LocalAddr returns the local network address.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/ParseError from _tests/small/src/net/net.go:518:6:
	info_ParseError = GoTypeInfo{Name: "go.std.net/ParseError",
		GoType: &GoType{T: &info_ParseError},
		Ctor: _Wrapped_Ctor_ParseError,
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/ParseError from -:
	info_PtrTo_ParseError = GoTypeInfo{Name: "*go.std.net/ParseError",
		GoType: &GoType{T: &info_PtrTo_ParseError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __ptrTo_ParseError_Error, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/Resolver from _tests/small/src/net/lookup.go:107:6:
	info_Resolver = GoTypeInfo{Name: "go.std.net/Resolver",
		GoType: &GoType{T: &info_Resolver},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/Resolver from -:
	info_PtrTo_Resolver = GoTypeInfo{Name: "*go.std.net/Resolver",
		GoType: &GoType{T: &info_PtrTo_Resolver},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/SRV from _tests/small/src/net/dnsclient.go:139:6:
	info_SRV = GoTypeInfo{Name: "go.std.net/SRV",
		GoType: &GoType{T: &info_SRV},
		Ctor: _Wrapped_Ctor_SRV,
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/SRV from -:
	info_PtrTo_SRV = GoTypeInfo{Name: "*go.std.net/SRV",
		GoType: &GoType{T: &info_PtrTo_SRV},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/UnknownNetworkError from _tests/small/src/net/net.go:548:6:
	info_UnknownNetworkError = GoTypeInfo{Name: "go.std.net/UnknownNetworkError",
		GoType: &GoType{T: &info_UnknownNetworkError},
		Ctor: _Wrapped_Ctor_UnknownNetworkError,
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __unknownNetworkError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", __unknownNetworkError_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", __unknownNetworkError_Timeout, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE *go.std.net/UnknownNetworkError from -:
	info_PtrTo_UnknownNetworkError = GoTypeInfo{Name: "*go.std.net/UnknownNetworkError",
		GoType: &GoType{T: &info_PtrTo_UnknownNetworkError},
		Members: GoMembers{
		}}


GO VECSET FOR TYPE go.std.net/Addr from _tests/small/src/net/net.go:105:6:
	GoTypesVec[50] = &info_Addr

GO VECSET FOR TYPE go.std.net/AddrError from _tests/small/src/net/net.go:529:6:
	GoTypesVec[29] = &info_AddrError

GO VECSET FOR TYPE *go.std.net/AddrError from -:
	GoTypesVec[6] = &info_PtrTo_AddrError

GO VECSET FOR TYPE go.std.net/Buffers from _tests/small/src/net/net.go:651:6:
	GoTypesVec[30] = &info_Buffers

GO VECSET FOR TYPE *go.std.net/Buffers from -:
	GoTypesVec[7] = &info_PtrTo_Buffers

GO VECSET FOR TYPE go.std.net/Conn from _tests/small/src/net/net.go:113:6:
	GoTypesVec[46] = &info_Conn

GO VECSET FOR TYPE go.std.net/DNSConfigError from _tests/small/src/net/net.go:562:6:
	GoTypesVec[31] = &info_DNSConfigError

GO VECSET FOR TYPE *go.std.net/DNSConfigError from -:
	GoTypesVec[8] = &info_PtrTo_DNSConfigError

GO VECSET FOR TYPE go.std.net/DNSError from _tests/small/src/net/net.go:576:6:
	GoTypesVec[32] = &info_DNSError

GO VECSET FOR TYPE *go.std.net/DNSError from -:
	GoTypesVec[9] = &info_PtrTo_DNSError

GO VECSET FOR TYPE go.std.net/Error from _tests/small/src/net/net.go:387:6:
	GoTypesVec[48] = &info_Error

GO VECSET FOR TYPE go.std.net/IP from _tests/small/src/net/ip.go:32:6:
	GoTypesVec[33] = &info_IP

GO VECSET FOR TYPE *go.std.net/IP from -:
	GoTypesVec[10] = &info_PtrTo_IP

GO VECSET FOR TYPE go.std.net/IPAddr from _tests/small/src/net/iprawsock.go:31:6:
	GoTypesVec[34] = &info_IPAddr

GO VECSET FOR TYPE *go.std.net/IPAddr from -:
	GoTypesVec[11] = &info_PtrTo_IPAddr

GO VECSET FOR TYPE go.std.net/IPConn from _tests/small/src/net/iprawsock.go:99:6:
	GoTypesVec[35] = &info_IPConn

GO VECSET FOR TYPE *go.std.net/IPConn from -:
	GoTypesVec[12] = &info_PtrTo_IPConn

GO VECSET FOR TYPE go.std.net/IPMask from _tests/small/src/net/ip.go:35:6:
	GoTypesVec[36] = &info_IPMask

GO VECSET FOR TYPE *go.std.net/IPMask from -:
	GoTypesVec[13] = &info_PtrTo_IPMask

GO VECSET FOR TYPE go.std.net/IPNet from _tests/small/src/net/ip.go:38:6:
	GoTypesVec[37] = &info_IPNet

GO VECSET FOR TYPE *go.std.net/IPNet from -:
	GoTypesVec[14] = &info_PtrTo_IPNet

GO VECSET FOR TYPE go.std.net/InvalidAddrError from _tests/small/src/net/net.go:554:6:
	GoTypesVec[38] = &info_InvalidAddrError

GO VECSET FOR TYPE *go.std.net/InvalidAddrError from -:
	GoTypesVec[15] = &info_PtrTo_InvalidAddrError

GO VECSET FOR TYPE go.std.net/Listener from _tests/small/src/net/net.go:374:6:
	GoTypesVec[49] = &info_Listener

GO VECSET FOR TYPE go.std.net/MX from _tests/small/src/net/dnsclient.go:193:6:
	GoTypesVec[39] = &info_MX

GO VECSET FOR TYPE *go.std.net/MX from -:
	GoTypesVec[16] = &info_PtrTo_MX

GO VECSET FOR TYPE go.std.net/NS from _tests/small/src/net/dnsclient.go:215:6:
	GoTypesVec[40] = &info_NS

GO VECSET FOR TYPE *go.std.net/NS from -:
	GoTypesVec[17] = &info_PtrTo_NS

GO VECSET FOR TYPE go.std.net/OpError from _tests/small/src/net/net.go:425:6:
	GoTypesVec[41] = &info_OpError

GO VECSET FOR TYPE *go.std.net/OpError from -:
	GoTypesVec[18] = &info_PtrTo_OpError

GO VECSET FOR TYPE go.std.net/PacketConn from _tests/small/src/net/net.go:303:6:
	GoTypesVec[47] = &info_PacketConn

GO VECSET FOR TYPE go.std.net/ParseError from _tests/small/src/net/net.go:518:6:
	GoTypesVec[42] = &info_ParseError

GO VECSET FOR TYPE *go.std.net/ParseError from -:
	GoTypesVec[19] = &info_PtrTo_ParseError

GO VECSET FOR TYPE go.std.net/Resolver from _tests/small/src/net/lookup.go:107:6:
	GoTypesVec[43] = &info_Resolver

GO VECSET FOR TYPE *go.std.net/Resolver from -:
	GoTypesVec[20] = &info_PtrTo_Resolver

GO VECSET FOR TYPE go.std.net/SRV from _tests/small/src/net/dnsclient.go:139:6:
	GoTypesVec[44] = &info_SRV

GO VECSET FOR TYPE *go.std.net/SRV from -:
	GoTypesVec[21] = &info_PtrTo_SRV

GO VECSET FOR TYPE go.std.net/UnknownNetworkError from _tests/small/src/net/net.go:548:6:
	GoTypesVec[45] = &info_UnknownNetworkError

GO VECSET FOR TYPE *go.std.net/UnknownNetworkError from -:
	GoTypesVec[22] = &info_PtrTo_UnknownNetworkError

GO ENSURE-LOADED FOR net:
	EnsureLoaded("go.std.context")  // E.g. from: _tests/small/src/net/iprawsock.go:8:2
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/small/src/net/net.go:83:2
	EnsureLoaded("go.std.golang_org.x.net.dns.dnsmessage")  // E.g. from: _tests/small/src/net/dnsclient.go:11:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/small/src/net/net.go:85:2
	EnsureLoaded("go.std.math.rand")  // E.g. from: _tests/small/src/net/dnsclient.go:8:2
	EnsureLoaded("go.std.os")  // E.g. from: _tests/small/src/net/net.go:86:2
	EnsureLoaded("go.std.sort")  // E.g. from: _tests/small/src/net/dnsclient.go:9:2
	EnsureLoaded("go.std.sync")  // E.g. from: _tests/small/src/net/net.go:87:2
	EnsureLoaded("go.std.syscall")  // E.g. from: _tests/small/src/net/iprawsock.go:9:2
	EnsureLoaded("go.std.time")  // E.g. from: _tests/small/src/net/net.go:89:2

// Auto-generated by gostd at (omitted for testing), do not edit!!

package net

import (
	"fmt"
	. "github.com/candid82/joker/core"
	_net "net"
	_reflect "reflect"
)

func initNative() {
}

GO TYPE net/url.Error from net/url/url.go:
func ExtractGoObjectError(args []Object, index int) *_url.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.Error:
			return &r
		case *_url.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Error]"))
}

func ExtractGo_go_std_net_url__Error(rcvr, arg string, args *ArraySeq, n int) (res _url.Error) {
	a := CheckGoNth(rcvr, "go.std.net.url/Error", arg, args, n).O
	res, ok := a.(_url.Error)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.url/Error], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func _mapToError(o Map) *_url.Error {
	return &_url.Error{
		Op: FieldAsString(o, "Op"),
		URL: FieldAsString(o, "URL"),
		Err: FieldAsError(o, "Err"),
	}
}

func _Ctor_Error(_v Object) *_url.Error {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToError(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Error] or: Map"))
}

func _Wrapped_Ctor_Error(_o Object) Object {
	return MakeGoObject(_Ctor_Error(_o))
}

GO TYPE net/url.EscapeError from net/url/url.go:
func ExtractGoObjectEscapeError(args []Object, index int) *_url.EscapeError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.EscapeError:
			return &r
		case *_url.EscapeError:
			return r
		}
	case String:
		v := _url.EscapeError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.EscapeError]"))
}

func ExtractGo_go_std_net_url__EscapeError(rcvr, arg string, args *ArraySeq, n int) (res _url.EscapeError) {
	a := CheckGoNth(rcvr, "go.std.net.url/EscapeError", arg, args, n).O
	res, ok := a.(_url.EscapeError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.url/EscapeError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func _Ctor_EscapeError(_v Object) _url.EscapeError {
	switch _o := _v.(type) {
	case String:
		return _url.EscapeError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.EscapeError] or: String"))
}

func _Wrapped_Ctor_EscapeError(_o Object) Object {
	return MakeGoObject(_Ctor_EscapeError(_o))
}

GO TYPE net/url.InvalidHostError from net/url/url.go:
func ExtractGoObjectInvalidHostError(args []Object, index int) *_url.InvalidHostError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.InvalidHostError:
			return &r
		case *_url.InvalidHostError:
			return r
		}
	case String:
		v := _url.InvalidHostError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.InvalidHostError]"))
}

func ExtractGo_go_std_net_url__InvalidHostError(rcvr, arg string, args *ArraySeq, n int) (res _url.InvalidHostError) {
	a := CheckGoNth(rcvr, "go.std.net.url/InvalidHostError", arg, args, n).O
	res, ok := a.(_url.InvalidHostError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.url/InvalidHostError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func _Ctor_InvalidHostError(_v Object) _url.InvalidHostError {
	switch _o := _v.(type) {
	case String:
		return _url.InvalidHostError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.InvalidHostError] or: String"))
}

func _Wrapped_Ctor_InvalidHostError(_o Object) Object {
	return MakeGoObject(_Ctor_InvalidHostError(_o))
}

GO TYPE net/url.URL from net/url/url.go:
func ExtractGoObjectURL(args []Object, index int) *_url.URL {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.URL:
			return &r
		case *_url.URL:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.URL]"))
}

func ExtractGo_go_std_net_url__URL(rcvr, arg string, args *ArraySeq, n int) (res _url.URL) {
	a := CheckGoNth(rcvr, "go.std.net.url/URL", arg, args, n).O
	res, ok := a.(_url.URL)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.url/URL], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

// func _mapToURL(o Map) *_url.URL {
// 	return &_url.URL{
// 		Scheme: FieldAsString(o, "Scheme"),
// 		Opaque: FieldAsString(o, "Opaque"),
// 		User: ABEND048(codegen.go: no conversion from Clojure for *net/url.Userinfo (net/url.Userinfo)),
// 		Host: FieldAsString(o, "Host"),
// 		Path: FieldAsString(o, "Path"),
// 		RawPath: FieldAsString(o, "RawPath"),
// 		ForceQuery: FieldAsBoolean(o, "ForceQuery"),
// 		RawQuery: FieldAsString(o, "RawQuery"),
// 		Fragment: FieldAsString(o, "Fragment"),
// 	}
// }

// func _Ctor_URL(_v Object) *_url.URL {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToURL(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[url.URL] or: Map"))
// }

// func _Wrapped_Ctor_URL(_o Object) Object {
// 	return MakeGoObject(_Ctor_URL(_o))
// }

GO TYPE net/url.Userinfo from net/url/url.go:
func ExtractGoObjectUserinfo(args []Object, index int) *_url.Userinfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.Userinfo:
			return &r
		case *_url.Userinfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Userinfo]"))
}

func ExtractGo_go_std_net_url__Userinfo(rcvr, arg string, args *ArraySeq, n int) (res _url.Userinfo) {
	a := CheckGoNth(rcvr, "go.std.net.url/Userinfo", arg, args, n).O
	res, ok := a.(_url.Userinfo)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.url/Userinfo], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func _mapToUserinfo(o Map) *_url.Userinfo {
	return &_url.Userinfo{}
}

func _Ctor_Userinfo(_v Object) *_url.Userinfo {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToUserinfo(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Userinfo] or: Map"))
}

func _Wrapped_Ctor_Userinfo(_o Object) Object {
	return MakeGoObject(_Ctor_Userinfo(_o))
}

GO TYPE net/url.Values from net/url/url.go:
func ExtractGoObjectValues(args []Object, index int) *_url.Values {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.Values:
			return &r
		case *_url.Values:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Values]"))
}

func ExtractGo_go_std_net_url__Values(rcvr, arg string, args *ArraySeq, n int) (res _url.Values) {
	a := CheckGoNth(rcvr, "go.std.net.url/Values", arg, args, n).O
	res, ok := a.(_url.Values)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.url/Values], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

// func _Ctor_Values(_v Object) _url.Values {
// 	switch _o := _v.(type) {
// 	default:
// 		return _url.Values(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for Values))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Values] or: whatever"))
// }

// func _Wrapped_Ctor_Values(_o Object) Object {
// 	return MakeGoObject(_Ctor_Values(_o))
// }

GO FUNC net/url.Parse from net/url/url.go:
func __parse(__rawurl string) Object {
	_res1, _res2 := _url.Parse(__rawurl)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.ParseQuery from net/url/url.go:
func __parseQuery(__query string) Object {
	_res1, _res2 := _url.ParseQuery(__query)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.ParseRequestURI from net/url/url.go:
func __parseRequestURI(__rawurl string) Object {
	_res1, _res2 := _url.ParseRequestURI(__rawurl)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.PathUnescape from net/url/url.go:
func __pathUnescape(__s string) Object {
	_res1, _res2 := _url.PathUnescape(__s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.QueryUnescape from net/url/url.go:
func __queryUnescape(__s string) Object {
	_res1, _res2 := _url.QueryUnescape(__s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.User from net/url/url.go:
func __user(__username string) Object {
	_res := _url.User(__username)
	return MakeGoObject(_res)
}

GO FUNC net/url.UserPassword from net/url/url.go:
func __userPassword(__username string, __password string) Object {
	_res := _url.UserPassword(__username, __password)
	return MakeGoObject(_res)
}

GO FUNC net/url.__escapeError_Error from net/url/url.go:
func __escapeError_Error(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net/url.EscapeError)Error()", args, 0, 0)
	_res := o.O.(_url.EscapeError).Error()
	return MakeString(_res)
}

GO FUNC net/url.__invalidHostError_Error from net/url/url.go:
func __invalidHostError_Error(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net/url.InvalidHostError)Error()", args, 0, 0)
	_res := o.O.(_url.InvalidHostError).Error()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_Error_Error from net/url/url.go:
func __ptrTo_Error_Error(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net/url.Error)Error()", args, 0, 0)
	_res := o.O.(*_url.Error).Error()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_Error_Temporary from net/url/url.go:
func __ptrTo_Error_Temporary(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net/url.Error)Temporary()", args, 0, 0)
	_res := o.O.(*_url.Error).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net/url.__ptrTo_Error_Timeout from net/url/url.go:
func __ptrTo_Error_Timeout(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net/url.Error)Timeout()", args, 0, 0)
	_res := o.O.(*_url.Error).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net/url.__ptrTo_URL_EscapedPath from net/url/url.go:
func __ptrTo_URL_EscapedPath(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net/url.URL)EscapedPath()", args, 0, 0)
	_res := o.O.(*_url.URL).EscapedPath()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_URL_Hostname from net/url/url.go:
func __ptrTo_URL_Hostname(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net/url.URL)Hostname()", args, 0, 0)
	_res := o.O.(*_url.URL).Hostname()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_URL_IsAbs from net/url/url.go:
func __ptrTo_URL_IsAbs(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net/url.URL)IsAbs()", args, 0, 0)
	_res := o.O.(*_url.URL).IsAbs()
	return MakeBoolean(_res)
}

GO FUNC net/url.__ptrTo_URL_MarshalBinary from net/url/url.go:
func __ptrTo_URL_MarshalBinary(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net/url.URL)MarshalBinary()", args, 0, 0)
	text, err := o.O.(*_url.URL).MarshalBinary()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range text {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/url.__ptrTo_URL_Parse from net/url/url.go:
func __ptrTo_URL_Parse(o GoObject, args Object) Object {  // Receiver
	_argList := CheckGoArity("(*_net/url.URL)Parse()", args, 1, 1)
	__ref := ExtractGoString("(*_net/url.URL)Parse()", "__ref", _argList, 0)
	_res1, _res2 := o.O.(*_url.URL).Parse(__ref)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.__ptrTo_URL_Port from net/url/url.go:
func __ptrTo_URL_Port(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net/url.URL)Port()", args, 0, 0)
	_res := o.O.(*_url.URL).Port()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_URL_Query from net/url/url.go:
func __ptrTo_URL_Query(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net/url.URL)Query()", args, 0, 0)
	_res := o.O.(*_url.URL).Query()
	return MakeGoObject(_res)
}

GO FUNC net/url.__ptrTo_URL_RequestURI from net/url/url.go:
func __ptrTo_URL_RequestURI(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net/url.URL)RequestURI()", args, 0, 0)
	_res := o.O.(*_url.URL).RequestURI()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_URL_ResolveReference from net/url/url.go:
// func __ptrTo_URL_ResolveReference(o GoObject, args Object) Object {  // Receiver
// 	_argList := CheckGoArity("(*_net/url.URL)ResolveReference()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for __ref at: _tests/small/src/net/url/url.go:973:36)
// 	_res := o.O.(*_url.URL).ResolveReference(__ref)
// 	return MakeGoObject(_res)
// }

GO FUNC net/url.__ptrTo_URL_String from net/url/url.go:
func __ptrTo_URL_String(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net/url.URL)String()", args, 0, 0)
	_res := o.O.(*_url.URL).String()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_URL_UnmarshalBinary from net/url/url.go:
// func __ptrTo_URL_UnmarshalBinary(o GoObject, args Object) Object {  // Receiver
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__text)))}

GO FUNC net/url.__ptrTo_Userinfo_Password from net/url/url.go:
func __ptrTo_Userinfo_Password(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net/url.Userinfo)Password()", args, 0, 0)
	_res1, _res2 := o.O.(*_url.Userinfo).Password()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(MakeBoolean(_res2))
	return _res
}

GO FUNC net/url.__ptrTo_Userinfo_String from net/url/url.go:
func __ptrTo_Userinfo_String(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net/url.Userinfo)String()", args, 0, 0)
	_res := o.O.(*_url.Userinfo).String()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_Userinfo_Username from net/url/url.go:
func __ptrTo_Userinfo_Username(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(*_net/url.Userinfo)Username()", args, 0, 0)
	_res := o.O.(*_url.Userinfo).Username()
	return MakeString(_res)
}

GO FUNC net/url.__values_Add from net/url/url.go:
// func __values_Add(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/url.__values_Del from net/url/url.go:
// func __values_Del(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/url.__values_Encode from net/url/url.go:
func __values_Encode(o GoObject, args Object) Object {  // Receiver
	CheckGoArity("(_net/url.Values)Encode()", args, 0, 0)
	_res := o.O.(_url.Values).Encode()
	return MakeString(_res)
}

GO FUNC net/url.__values_Get from net/url/url.go:
func __values_Get(o GoObject, args Object) Object {  // Receiver
	_argList := CheckGoArity("(_net/url.Values)Get()", args, 1, 1)
	__key := ExtractGoString("(_net/url.Values)Get()", "__key", _argList, 0)
	_res := o.O.(_url.Values).Get(__key)
	return MakeString(_res)
}

GO FUNC net/url.__values_Set from net/url/url.go:
// func __values_Set(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO VARDEF FOR TYPE go.std.net.url/Error from _tests/small/src/net/url/url.go:22:6:
var info_Error GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.url/Error from -:
var info_PtrTo_Error GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/EscapeError from _tests/small/src/net/url/url.go:84:6:
var info_EscapeError GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.url/EscapeError from -:
var info_PtrTo_EscapeError GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/InvalidHostError from _tests/small/src/net/url/url.go:90:6:
var info_InvalidHostError GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.url/InvalidHostError from -:
var info_PtrTo_InvalidHostError GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/URL from _tests/small/src/net/url/url.go:344:6:
var info_URL GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.url/URL from -:
var info_PtrTo_URL GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/Userinfo from _tests/small/src/net/url/url.go:378:6:
var info_Userinfo GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.url/Userinfo from -:
var info_PtrTo_Userinfo GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/Values from _tests/small/src/net/url/url.go:804:6:
var info_Values GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.url/Values from -:
var info_PtrTo_Values GoTypeInfo

GO INFO FOR TYPE go.std.net.url/Error from _tests/small/src/net/url/url.go:22:6:
	info_Error = GoTypeInfo{Name: "go.std.net.url/Error",
		GoType: &GoType{T: &info_Error},
		Ctor: _Wrapped_Ctor_Error,
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.url/Error from -:
	info_PtrTo_Error = GoTypeInfo{Name: "*go.std.net.url/Error",
		GoType: &GoType{T: &info_PtrTo_Error},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __ptrTo_Error_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", __ptrTo_Error_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", __ptrTo_Error_Timeout, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net.url/EscapeError from _tests/small/src/net/url/url.go:84:6:
	info_EscapeError = GoTypeInfo{Name: "go.std.net.url/EscapeError",
		GoType: &GoType{T: &info_EscapeError},
		Ctor: _Wrapped_Ctor_EscapeError,
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __escapeError_Error, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE *go.std.net.url/EscapeError from -:
	info_PtrTo_EscapeError = GoTypeInfo{Name: "*go.std.net.url/EscapeError",
		GoType: &GoType{T: &info_PtrTo_EscapeError},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.url/InvalidHostError from _tests/small/src/net/url/url.go:90:6:
	info_InvalidHostError = GoTypeInfo{Name: "go.std.net.url/InvalidHostError",
		GoType: &GoType{T: &info_InvalidHostError},
		Ctor: _Wrapped_Ctor_InvalidHostError,
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __invalidHostError_Error, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE *go.std.net.url/InvalidHostError from -:
	info_PtrTo_InvalidHostError = GoTypeInfo{Name: "*go.std.net.url/InvalidHostError",
		GoType: &GoType{T: &info_PtrTo_InvalidHostError},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.url/URL from _tests/small/src/net/url/url.go:344:6:
	info_URL = GoTypeInfo{Name: "go.std.net.url/URL",
		GoType: &GoType{T: &info_URL},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.url/URL from -:
	info_PtrTo_URL = GoTypeInfo{Name: "*go.std.net.url/URL",
		GoType: &GoType{T: &info_PtrTo_URL},
		Members: GoMembers{
			"EscapedPath": MakeGoReceiver("EscapedPath", __ptrTo_URL_EscapedPath, "EscapedPath returns the escaped form of u.Path.\nIn general there are multiple possible escaped forms of any path.\nEscapedPath returns u.RawPath when it is a valid escaping of u.Path.\nOtherwise EscapedPath ignores u.RawPath and computes an escaped\nform on its own.\nThe String and RequestURI methods use EscapedPath to construct\ntheir results.\nIn general, code should call EscapedPath instead of\nreading u.RawPath directly.\n", "1.0", NewVectorFrom()),
			"Hostname": MakeGoReceiver("Hostname", __ptrTo_URL_Hostname, "Hostname returns u.Host, without any port number.\n\nIf Host is an IPv6 literal with a port number, Hostname returns the\nIPv6 literal without the square brackets. IPv6 literals may include\na zone identifier.\n", "1.0", NewVectorFrom()),
			"IsAbs": MakeGoReceiver("IsAbs", __ptrTo_URL_IsAbs, "IsAbs reports whether the URL is absolute.\nAbsolute means that it has a non-empty scheme.\n", "1.0", NewVectorFrom()),
			"MarshalBinary": MakeGoReceiver("MarshalBinary", __ptrTo_URL_MarshalBinary, "", "1.0", NewVectorFrom()),
			"Parse": MakeGoReceiver("Parse", __ptrTo_URL_Parse, "Parse parses a URL in the context of the receiver. The provided URL\nmay be relative or absolute. Parse returns nil, err on parse\nfailure, otherwise its return value is the same as ResolveReference.\n", "1.0", NewVectorFrom(MakeSymbol("ref"))),
			"Port": MakeGoReceiver("Port", __ptrTo_URL_Port, "Port returns the port part of u.Host, without the leading colon.\nIf u.Host doesn't contain a port, Port returns an empty string.\n", "1.0", NewVectorFrom()),
			"Query": MakeGoReceiver("Query", __ptrTo_URL_Query, "Query parses RawQuery and returns the corresponding values.\nIt silently discards malformed value pairs.\nTo check errors use ParseQuery.\n", "1.0", NewVectorFrom()),
			"RequestURI": MakeGoReceiver("RequestURI", __ptrTo_URL_RequestURI, "RequestURI returns the encoded path?query or opaque?query\nstring that would be used in an HTTP request for u.\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", __ptrTo_URL_String, "String reassembles the URL into a valid URL string.\nThe general form of the result is one of:\n\n\tscheme:opaque?query#fragment\n\tscheme://userinfo@host/path?query#fragment\n\nIf u.Opaque is non-empty, String uses the first form;\notherwise it uses the second form.\nTo obtain the path, String uses u.EscapedPath().\n\nIn the second form, the following rules apply:\n\t- if u.Scheme is empty, scheme: is omitted.\n\t- if u.User is nil, userinfo@ is omitted.\n\t- if u.Host is empty, host/ is omitted.\n\t- if u.Scheme and u.Host are empty and u.User is nil,\n\t   the entire scheme://userinfo@host/ is omitted.\n\t- if u.Host is non-empty and u.Path begins with a /,\n\t   the form host/path does not add its own /.\n\t- if u.RawQuery is empty, ?query is omitted.\n\t- if u.Fragment is empty, #fragment is omitted.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net.url/Userinfo from _tests/small/src/net/url/url.go:378:6:
	info_Userinfo = GoTypeInfo{Name: "go.std.net.url/Userinfo",
		GoType: &GoType{T: &info_Userinfo},
		Ctor: _Wrapped_Ctor_Userinfo,
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.url/Userinfo from -:
	info_PtrTo_Userinfo = GoTypeInfo{Name: "*go.std.net.url/Userinfo",
		GoType: &GoType{T: &info_PtrTo_Userinfo},
		Members: GoMembers{
			"Password": MakeGoReceiver("Password", __ptrTo_Userinfo_Password, "Password returns the password in case it is set, and whether it is set.\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", __ptrTo_Userinfo_String, "String returns the encoded userinfo information in the standard form\nof \"username[:password]\".\n", "1.0", NewVectorFrom()),
			"Username": MakeGoReceiver("Username", __ptrTo_Userinfo_Username, "Username returns the username.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net.url/Values from _tests/small/src/net/url/url.go:804:6:
	info_Values = GoTypeInfo{Name: "go.std.net.url/Values",
		GoType: &GoType{T: &info_Values},
		Members: GoMembers{
			"Encode": MakeGoReceiver("Encode", __values_Encode, "Encode encodes the values into ``URL encoded'' form\n(\"bar=baz&foo=quux\") sorted by key.\n", "1.0", NewVectorFrom()),
			"Get": MakeGoReceiver("Get", __values_Get, "Get gets the first value associated with the given key.\nIf there are no values associated with the key, Get returns\nthe empty string. To access multiple values, use the map\ndirectly.\n", "1.0", NewVectorFrom(MakeSymbol("key"))),
		}}


GO INFO FOR TYPE *go.std.net.url/Values from -:
	info_PtrTo_Values = GoTypeInfo{Name: "*go.std.net.url/Values",
		GoType: &GoType{T: &info_PtrTo_Values},
		Members: GoMembers{
		}}


GO VECSET FOR TYPE go.std.net.url/Error from _tests/small/src/net/url/url.go:22:6:
	GoTypesVec[23] = &info_Error

GO VECSET FOR TYPE *go.std.net.url/Error from -:
	GoTypesVec[0] = &info_PtrTo_Error

GO VECSET FOR TYPE go.std.net.url/EscapeError from _tests/small/src/net/url/url.go:84:6:
	GoTypesVec[24] = &info_EscapeError

GO VECSET FOR TYPE *go.std.net.url/EscapeError from -:
	GoTypesVec[1] = &info_PtrTo_EscapeError

GO VECSET FOR TYPE go.std.net.url/InvalidHostError from _tests/small/src/net/url/url.go:90:6:
	GoTypesVec[25] = &info_InvalidHostError

GO VECSET FOR TYPE *go.std.net.url/InvalidHostError from -:
	GoTypesVec[2] = &info_PtrTo_InvalidHostError

GO VECSET FOR TYPE go.std.net.url/URL from _tests/small/src/net/url/url.go:344:6:
	GoTypesVec[26] = &info_URL

GO VECSET FOR TYPE *go.std.net.url/URL from -:
	GoTypesVec[3] = &info_PtrTo_URL

GO VECSET FOR TYPE go.std.net.url/Userinfo from _tests/small/src/net/url/url.go:378:6:
	GoTypesVec[27] = &info_Userinfo

GO VECSET FOR TYPE *go.std.net.url/Userinfo from -:
	GoTypesVec[4] = &info_PtrTo_Userinfo

GO VECSET FOR TYPE go.std.net.url/Values from _tests/small/src/net/url/url.go:804:6:
	GoTypesVec[28] = &info_Values

GO VECSET FOR TYPE *go.std.net.url/Values from -:
	GoTypesVec[5] = &info_PtrTo_Values

GO ENSURE-LOADED FOR url:
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/small/src/net/url/url.go:14:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/small/src/net/url/url.go:15:2
	EnsureLoaded("go.std.sort")  // E.g. from: _tests/small/src/net/url/url.go:16:2
	EnsureLoaded("go.std.strconv")  // E.g. from: _tests/small/src/net/url/url.go:17:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/small/src/net/url/url.go:18:2

// Auto-generated by gostd at (omitted for testing), do not edit!!

package url

import (
	"fmt"
	. "github.com/candid82/joker/core"
	_url "net/url"
	_reflect "reflect"
)

func initNative() {
}

Adding 51 types to core/goswitch.go
Generated file goswitch.go:
// Auto-modified by gostd at (omitted for testing)

package core

import (
	"net"
	"net/url"
)

var GoTypesVec [51]*GoTypeInfo

func SwitchGoType(g interface{}) int {
	switch g.(type) {
	case *url.Error:
		return 0
	case *url.EscapeError:
		return 1
	case *url.InvalidHostError:
		return 2
	case *url.URL:
		return 3
	case *url.Userinfo:
		return 4
	case *url.Values:
		return 5
	case *net.AddrError:
		return 6
	case *net.Buffers:
		return 7
	case *net.DNSConfigError:
		return 8
	case *net.DNSError:
		return 9
	case *net.IP:
		return 10
	case *net.IPAddr:
		return 11
	case *net.IPConn:
		return 12
	case *net.IPMask:
		return 13
	case *net.IPNet:
		return 14
	case *net.InvalidAddrError:
		return 15
	case *net.MX:
		return 16
	case *net.NS:
		return 17
	case *net.OpError:
		return 18
	case *net.ParseError:
		return 19
	case *net.Resolver:
		return 20
	case *net.SRV:
		return 21
	case *net.UnknownNetworkError:
		return 22
	case url.Error:
		return 23
	case url.EscapeError:
		return 24
	case url.InvalidHostError:
		return 25
	case url.URL:
		return 26
	case url.Userinfo:
		return 27
	case url.Values:
		return 28
	case net.AddrError:
		return 29
	case net.Buffers:
		return 30
	case net.DNSConfigError:
		return 31
	case net.DNSError:
		return 32
	case net.IP:
		return 33
	case net.IPAddr:
		return 34
	case net.IPConn:
		return 35
	case net.IPMask:
		return 36
	case net.IPNet:
		return 37
	case net.InvalidAddrError:
		return 38
	case net.MX:
		return 39
	case net.NS:
		return 40
	case net.OpError:
		return 41
	case net.ParseError:
		return 42
	case net.Resolver:
		return 43
	case net.SRV:
		return 44
	case net.UnknownNetworkError:
		return 45
	case net.Conn:  // Specificity=8
		return 46
	case net.PacketConn:  // Specificity=7
		return 47
	case net.Error:  // Specificity=3
		return 48
	case net.Listener:  // Specificity=3
		return 49
	case net.Addr:  // Specificity=2
		return 50
	}
	return -1
}
ABENDs: 987(16) 902(15) 048(6) 674(4) 047(3) 275(3) 042(1) 124(1) 644(1)
Totals: functions=132 generated=97 (73.48%)
          non-receivers=26 (19.70%) generated=26 (100.00%)
          receivers=83 (62.88%) generated=59 (71.08%)
          methods=23 (17.42%) generated=12 (52.17%)
        types=28
          constructable=23 ctors=14 (60.87%)
          hits expr=0 alias=0 fullname=59
        constants=2 generated=2 (100.00%)
        variables=12 generated=12 (100.00%)
