goSrcDir: _tests/small/src
goSourcePath: /Users/craig/go/src
ClojureSourceDir (for import line): github.com/candid82/joker
JokerSourceDir: ../..
The list of core APIs is missing; file 'core-apis.dat' does not exist.
Writing Core APIs found at ../../core to core-apis.dat.
; defined templates are: "clojure-code.tmpl", "clojure-typedef.tmpl", "custom-libs-clojure.tmpl", "custom-libs-go.tmpl", "go-code.tmpl", "go-func-init.tmpl", "go-type-switch.tmpl"
Matchfile(_tests/small/src/net/dnsclient.go) => true <nil>
Matchfile(_tests/small/src/net/ip.go) => true <nil>
Matchfile(_tests/small/src/net/iprawsock.go) => true <nil>
Matchfile(_tests/small/src/net/lookup.go) => true <nil>
Matchfile(_tests/small/src/net/net.go) => true <nil>
Matchfile(_tests/small/src/net/url/url.go) => true <nil>
Processing go:
Processing net/url:
Processing net:
Processing package=net/url:
Processing package=net:
;;;; Auto-generated by gostd at (omitted for testing)

(ns
  ^{:go-imports {"go.std.net" ["net" "net"]}
    :doc "Provides a low-level interface to the net package.\n\nPackage net provides a portable interface for network I/O, including\nTCP/IP, UDP, domain name resolution, and Unix domain sockets.\n\nAlthough the package provides access to low-level networking\nprimitives, most clients will need only the basic interface provided\nby the Dial, Listen, and Accept functions and the associated\nConn and Listener interfaces. The crypto/tls package uses\nthe same interfaces and similar Dial and Listen functions.\n\nThe Dial function connects to a server:\n\n\tconn, err := net.Dial(\"tcp\", \"golang.org:80\")\n\tif err != nil {\n\t\t// handle error\n\t}\n\tfmt.Fprintf(conn, \"GET / HTTP/1.0\\r\\n\\r\\n\")\n\tstatus, err := bufio.NewReader(conn).ReadString('\\n')\n\t// ...\n\nThe Listen function creates servers:\n\n\tln, err := net.Listen(\"tcp\", \":8080\")\n\tif err != nil {\n\t\t// handle error\n\t}\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\t// handle error\n\t\t}\n\t\tgo handleConnection(conn)\n\t}\n\nName Resolution\n\nThe method for resolving domain names, whether indirectly with functions like Dial\nor directly with functions like LookupHost and LookupAddr, varies by operating system.\n\nOn Unix systems, the resolver has two options for resolving names.\nIt can use a pure Go resolver that sends DNS requests directly to the servers\nlisted in /etc/resolv.conf, or it can use a cgo-based resolver that calls C\nlibrary routines such as getaddrinfo and getnameinfo.\n\nBy default the pure Go resolver is used, because a blocked DNS request consumes\nonly a goroutine, while a blocked C call consumes an operating system thread.\nWhen cgo is available, the cgo-based resolver is used instead under a variety of\nconditions: on systems that do not let programs make direct DNS requests (OS X),\nwhen the LOCALDOMAIN environment variable is present (even if empty),\nwhen the RES_OPTIONS or HOSTALIASES environment variable is non-empty,\nwhen the ASR_CONFIG environment variable is non-empty (OpenBSD only),\nwhen /etc/resolv.conf or /etc/nsswitch.conf specify the use of features that the\nGo resolver does not implement, and when the name being looked up ends in .local\nor is an mDNS name.\n\nThe resolver decision can be overridden by setting the netdns value of the\nGODEBUG environment variable (see package runtime) to go or cgo, as in:\n\n\texport GODEBUG=netdns=go    # force pure Go resolver\n\texport GODEBUG=netdns=cgo   # force cgo resolver\n\nThe decision can also be forced while building the Go source tree\nby setting the netgo or netcgo build tag.\n\nA numeric netdns setting, as in GODEBUG=netdns=1, causes the resolver\nto print debugging information about its decisions.\nTo force a particular resolver while also printing debugging information,\njoin the two settings by a plus sign, as in GODEBUG=netdns=go+1.\n\nOn Plan 9, the resolver always accesses /net/cs and /net/dns.\n\nOn Windows, the resolver always uses C library functions, such as GetAddrInfo and DnsQuery.\n"
    :empty false}
  go.std.net)

(def
  ^{:doc "IP address lengths (bytes).\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "net.IPv4len"}
  IPv4len)

(def
  ^{:doc "IP address lengths (bytes).\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "net.IPv6len"}
  IPv6len)

(def
  ^{:doc "DefaultResolver is the resolver used by the package-level Lookup\nfunctions and by Dialers without a specified Resolver.\n"
    :added "1.0"
    :tag "Var"
    :go "net.DefaultResolver"}
  DefaultResolver)

(def
  ^{:doc "Various errors contained in OpError.\n"
    :added "1.0"
    :tag "Var"
    :go "net.ErrWriteToConnected"}
  ErrWriteToConnected)

(def
  ^{:doc "all routers\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv4allrouter"}
  IPv4allrouter)

(def
  ^{:doc "all systems\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv4allsys"}
  IPv4allsys)

(def
  ^{:doc "limited broadcast\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv4bcast"}
  IPv4bcast)

(def
  ^{:doc "all zeros\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv4zero"}
  IPv4zero)

(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6interfacelocalallnodes"}
  IPv6interfacelocalallnodes)

(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6linklocalallnodes"}
  IPv6linklocalallnodes)

(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6linklocalallrouters"}
  IPv6linklocalallrouters)

(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6loopback"}
  IPv6loopback)

(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6unspecified"}
  IPv6unspecified)

(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6zero"}
  IPv6zero)

(defn CIDRMask
  "CIDRMask returns an IPMask consisting of `ones' 1 bits\nfollowed by 0s up to a total length of `bits' bits.\nFor a mask of this form, CIDRMask is the inverse of IPMask.Size.\n\nGo input arguments: (ones int, bits int)\n\nGo returns: IPMask\n\nJoker input arguments: [^Int ones, ^Int bits]\n\nJoker returns: ^IPMask"
  {:added "1.0"
   :go "_f_cIDRMask(_v_ones, _v_bits)"}
  [^Int _v_ones, ^Int _v_bits])

(defn DialIP
  "DialIP acts like Dial for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *IPAddr, raddr *IPAddr)\n\nGo returns: (*IPConn, error)\n\nJoker input arguments: [^String network, ^refToIPAddr laddr, ^refToIPAddr raddr]\n\nJoker returns: [^refToIPConn, ^Error]"
  {:added "1.0"
   :go "_f_dialIP(_v_network, _v_laddr, _v_raddr)"}
  [^String _v_network, ^go.std.net/refToIPAddr _v_laddr, ^go.std.net/refToIPAddr _v_raddr])

(defn IPv4
  "IPv4 returns the IP address (in 16-byte form) of the\nIPv4 address a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo returns: IP\n\nJoker input arguments: [^Byte a, ^Byte b, ^Byte c, ^Byte d]\n\nJoker returns: ^IP"
  {:added "1.0"
   :go "_f_iPv4(_v_a, _v_b, _v_c, _v_d)"}
  [^Byte _v_a, ^Byte _v_b, ^Byte _v_c, ^Byte _v_d])

(defn IPv4Mask
  "IPv4Mask returns the IP mask (in 4-byte form) of the\nIPv4 mask a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo returns: IPMask\n\nJoker input arguments: [^Byte a, ^Byte b, ^Byte c, ^Byte d]\n\nJoker returns: ^IPMask"
  {:added "1.0"
   :go "_f_iPv4Mask(_v_a, _v_b, _v_c, _v_d)"}
  [^Byte _v_a, ^Byte _v_b, ^Byte _v_c, ^Byte _v_d])

(defn ListenIP
  "ListenIP acts like ListenPacket for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenIP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\n\nGo input arguments: (network string, laddr *IPAddr)\n\nGo returns: (*IPConn, error)\n\nJoker input arguments: [^String network, ^refToIPAddr laddr]\n\nJoker returns: [^refToIPConn, ^Error]"
  {:added "1.0"
   :go "_f_listenIP(_v_network, _v_laddr)"}
  [^String _v_network, ^go.std.net/refToIPAddr _v_laddr])

(defn LookupAddr
  "LookupAddr performs a reverse lookup for the given address, returning a list\nof names mapping to that address.\n\nWhen using the host C library resolver, at most one result will be\nreturned. To bypass the host resolver, use a custom Resolver.\n\nGo input arguments: (addr string)\n\nGo returns: (names []string, err error)\n\nJoker input arguments: [^String addr]\n\nJoker returns: [^arrayOfString names, ^Error err]"
  {:added "1.0"
   :go "_f_lookupAddr(_v_addr)"}
  [^String _v_addr])

(defn LookupCNAME
  "LookupCNAME returns the canonical name for the given host.\nCallers that do not care about the canonical name can call\nLookupHost or LookupIP directly; both take care of resolving\nthe canonical name as part of the lookup.\n\nA canonical name is the final name after following zero\nor more CNAME records.\nLookupCNAME does not return an error if host does not\ncontain DNS \"CNAME\" records, as long as host resolves to\naddress records.\n\nGo input arguments: (host string)\n\nGo returns: (cname string, err error)\n\nJoker input arguments: [^String host]\n\nJoker returns: [^String cname, ^Error err]"
  {:added "1.0"
   :go "_f_lookupCNAME(_v_host)"}
  [^String _v_host])

(defn LookupHost
  "LookupHost looks up the given host using the local resolver.\nIt returns a slice of that host's addresses.\n\nGo input arguments: (host string)\n\nGo returns: (addrs []string, err error)\n\nJoker input arguments: [^String host]\n\nJoker returns: [^arrayOfString addrs, ^Error err]"
  {:added "1.0"
   :go "_f_lookupHost(_v_host)"}
  [^String _v_host])

(defn LookupIP
  "LookupIP looks up host using the local resolver.\nIt returns a slice of that host's IPv4 and IPv6 addresses.\n\nGo input arguments: (host string)\n\nGo returns: ([]IP, error)\n\nJoker input arguments: [^String host]\n\nJoker returns: [^arrayOfIP, ^Error]"
  {:added "1.0"
   :go "_f_lookupIP(_v_host)"}
  [^String _v_host])

(defn LookupMX
  "LookupMX returns the DNS MX records for the given domain name sorted by preference.\n\nGo input arguments: (name string)\n\nGo returns: ([]*MX, error)\n\nJoker input arguments: [^String name]\n\nJoker returns: [^arrayOfrefToMX, ^Error]"
  {:added "1.0"
   :go "_f_lookupMX(_v_name)"}
  [^String _v_name])

(defn LookupNS
  "LookupNS returns the DNS NS records for the given domain name.\n\nGo input arguments: (name string)\n\nGo returns: ([]*NS, error)\n\nJoker input arguments: [^String name]\n\nJoker returns: [^arrayOfrefToNS, ^Error]"
  {:added "1.0"
   :go "_f_lookupNS(_v_name)"}
  [^String _v_name])

(defn LookupPort
  "LookupPort looks up the port for the given network and service.\n\nGo input arguments: (network string, service string)\n\nGo returns: (port int, err error)\n\nJoker input arguments: [^String network, ^String service]\n\nJoker returns: [^Int port, ^Error err]"
  {:added "1.0"
   :go "_f_lookupPort(_v_network, _v_service)"}
  [^String _v_network, ^String _v_service])

(defn LookupSRV
  "LookupSRV tries to resolve an SRV query of the given service,\nprotocol, and domain name. The proto is \"tcp\" or \"udp\".\nThe returned records are sorted by priority and randomized\nby weight within a priority.\n\nLookupSRV constructs the DNS name to look up following RFC 2782.\nThat is, it looks up _service._proto.name. To accommodate services\npublishing SRV records under non-standard names, if both service\nand proto are empty strings, LookupSRV looks up name directly.\n\nGo input arguments: (service string, proto string, name string)\n\nGo returns: (cname string, addrs []*SRV, err error)\n\nJoker input arguments: [^String service, ^String proto, ^String name]\n\nJoker returns: [^String cname, ^arrayOfrefToSRV addrs, ^Error err]"
  {:added "1.0"
   :go "_f_lookupSRV(_v_service, _v_proto, _v_name)"}
  [^String _v_service, ^String _v_proto, ^String _v_name])

(defn LookupTXT
  "LookupTXT returns the DNS TXT records for the given domain name.\n\nGo input arguments: (name string)\n\nGo returns: ([]string, error)\n\nJoker input arguments: [^String name]\n\nJoker returns: [^arrayOfString, ^Error]"
  {:added "1.0"
   :go "_f_lookupTXT(_v_name)"}
  [^String _v_name])

(defn ParseCIDR
  "ParseCIDR parses s as a CIDR notation IP address and prefix length,\nlike \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in\nRFC 4632 and RFC 4291.\n\nIt returns the IP address and the network implied by the IP and\nprefix length.\nFor example, ParseCIDR(\"192.0.2.1/24\") returns the IP address\n192.0.2.1 and the network 192.0.2.0/24.\n\nGo input arguments: (s string)\n\nGo returns: (IP, *IPNet, error)\n\nJoker input arguments: [^String s]\n\nJoker returns: [^IP, ^refToIPNet, ^Error]"
  {:added "1.0"
   :go "_f_parseCIDR(_v_s)"}
  [^String _v_s])

(defn ParseIP
  "ParseIP parses s as an IP address, returning the result.\nThe string s can be in dotted decimal (\"192.0.2.1\")\nor IPv6 (\"2001:db8::68\") form.\nIf s is not a valid textual representation of an IP address,\nParseIP returns nil.\n\nGo input arguments: (s string)\n\nGo returns: IP\n\nJoker input arguments: [^String s]\n\nJoker returns: ^IP"
  {:added "1.0"
   :go "_f_parseIP(_v_s)"}
  [^String _v_s])

(defn ResolveIPAddr
  "ResolveIPAddr returns an address of IP end point.\n\nThe network must be an IP network name.\n\nIf the host in the address parameter is not a literal IP address,\nResolveIPAddr resolves the address to an address of IP end point.\nOtherwise, it parses the address as a literal IP address.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo returns: (*IPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker returns: [^refToIPAddr, ^Error]"
  {:added "1.0"
   :go "_f_resolveIPAddr(_v_network, _v_address)"}
  [^String _v_network, ^String _v_address])
(def
  ^{:doc "Addr represents a network end point address.\n\nThe two methods Network and String conventionally return strings\nthat can be passed as the arguments to Dial, but the exact form\nand meaning of the strings is up to the implementation.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 2
    :go "&info_Addr"}
  Addr)

(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_AddrError"}
  AddrError)

(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_AddrError"}
  refToAddrError)

(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_AddrError"}
  arrayOfAddrError)

(def
  ^{:doc "Buffers contains zero or more runs of bytes to write.\n\nOn certain machines, for certain types of connections, this is\noptimized into an OS-specific batch write operation (such as\n\"writev\").\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Buffers"}
  Buffers)

(def
  ^{:doc "Buffers contains zero or more runs of bytes to write.\n\nOn certain machines, for certain types of connections, this is\noptimized into an OS-specific batch write operation (such as\n\"writev\").\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Buffers"}
  refToBuffers)

(def
  ^{:doc "Buffers contains zero or more runs of bytes to write.\n\nOn certain machines, for certain types of connections, this is\noptimized into an OS-specific batch write operation (such as\n\"writev\").\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Buffers"}
  arrayOfBuffers)

(def
  ^{:doc "Conn is a generic stream-oriented network connection.\n\nMultiple goroutines may invoke methods on a Conn simultaneously.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 8
    :go "&info_Conn"}
  Conn)

(def
  ^{:doc "DNSConfigError represents an error reading the machine's DNS configuration.\n(No longer used; kept for compatibility.)\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DNSConfigError"}
  DNSConfigError)

(def
  ^{:doc "DNSConfigError represents an error reading the machine's DNS configuration.\n(No longer used; kept for compatibility.)\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_DNSConfigError"}
  refToDNSConfigError)

(def
  ^{:doc "DNSConfigError represents an error reading the machine's DNS configuration.\n(No longer used; kept for compatibility.)\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_DNSConfigError"}
  arrayOfDNSConfigError)

(def
  ^{:doc "DNSError represents a DNS lookup error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DNSError"}
  DNSError)

(def
  ^{:doc "DNSError represents a DNS lookup error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_DNSError"}
  refToDNSError)

(def
  ^{:doc "DNSError represents a DNS lookup error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_DNSError"}
  arrayOfDNSError)

(def
  ^{:doc "An Error represents a network error.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 3
    :go "&info_Error"}
  Error)

(def
  ^{:doc "An IP is a single IP address, a slice of bytes.\nFunctions in this package accept either 4-byte (IPv4)\nor 16-byte (IPv6) slices as input.\n\nNote that in this documentation, referring to an\nIP address as an IPv4 address or an IPv6 address\nis a semantic property of the address, not just the\nlength of the byte slice: a 16-byte slice can still\nbe an IPv4 address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IP"}
  IP)

(def
  ^{:doc "An IP is a single IP address, a slice of bytes.\nFunctions in this package accept either 4-byte (IPv4)\nor 16-byte (IPv6) slices as input.\n\nNote that in this documentation, referring to an\nIP address as an IPv4 address or an IPv6 address\nis a semantic property of the address, not just the\nlength of the byte slice: a 16-byte slice can still\nbe an IPv4 address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_IP"}
  refToIP)

(def
  ^{:doc "IPAddr represents the address of an IP end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IPAddr"}
  IPAddr)

(def
  ^{:doc "IPAddr represents the address of an IP end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_IPAddr"}
  refToIPAddr)

(def
  ^{:doc "IPAddr represents the address of an IP end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_IPAddr"}
  arrayOfIPAddr)

(def
  ^{:doc "IPConn is the implementation of the Conn and PacketConn interfaces\nfor IP network connections.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IPConn"}
  IPConn)

(def
  ^{:doc "IPConn is the implementation of the Conn and PacketConn interfaces\nfor IP network connections.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_IPConn"}
  refToIPConn)

(def
  ^{:doc "IPConn is the implementation of the Conn and PacketConn interfaces\nfor IP network connections.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_IPConn"}
  arrayOfIPConn)

(def
  ^{:doc "An IP mask is an IP address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IPMask"}
  IPMask)

(def
  ^{:doc "An IP mask is an IP address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_IPMask"}
  refToIPMask)

(def
  ^{:doc "An IP mask is an IP address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_IPMask"}
  arrayOfIPMask)

(def
  ^{:doc "An IPNet represents an IP network.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IPNet"}
  IPNet)

(def
  ^{:doc "An IPNet represents an IP network.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_IPNet"}
  refToIPNet)

(def
  ^{:doc "An IPNet represents an IP network.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_IPNet"}
  arrayOfIPNet)

(def
  ^{:doc "An IP is a single IP address, a slice of bytes.\nFunctions in this package accept either 4-byte (IPv4)\nor 16-byte (IPv6) slices as input.\n\nNote that in this documentation, referring to an\nIP address as an IPv4 address or an IPv6 address\nis a semantic property of the address, not just the\nlength of the byte slice: a 16-byte slice can still\nbe an IPv4 address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_IP"}
  arrayOfIP)

(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_InvalidAddrError"}
  InvalidAddrError)

(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_InvalidAddrError"}
  refToInvalidAddrError)

(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_InvalidAddrError"}
  arrayOfInvalidAddrError)

(def
  ^{:doc "A Listener is a generic network listener for stream-oriented protocols.\n\nMultiple goroutines may invoke methods on a Listener simultaneously.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 3
    :go "&info_Listener"}
  Listener)

(def
  ^{:doc "An MX represents a single DNS MX record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_MX"}
  MX)

(def
  ^{:doc "An MX represents a single DNS MX record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_MX"}
  refToMX)

(def
  ^{:doc "An MX represents a single DNS MX record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_MX"}
  arrayOfMX)

(def
  ^{:doc "An NS represents a single DNS NS record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NS"}
  NS)

(def
  ^{:doc "An NS represents a single DNS NS record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_NS"}
  refToNS)

(def
  ^{:doc "An NS represents a single DNS NS record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_NS"}
  arrayOfNS)

(def
  ^{:doc "OpError is the error type usually returned by functions in the net\npackage. It describes the operation, network type, and address of\nan error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_OpError"}
  OpError)

(def
  ^{:doc "OpError is the error type usually returned by functions in the net\npackage. It describes the operation, network type, and address of\nan error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_OpError"}
  refToOpError)

(def
  ^{:doc "OpError is the error type usually returned by functions in the net\npackage. It describes the operation, network type, and address of\nan error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_OpError"}
  arrayOfOpError)

(def
  ^{:doc "PacketConn is a generic packet-oriented network connection.\n\nMultiple goroutines may invoke methods on a PacketConn simultaneously.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 7
    :go "&info_PacketConn"}
  PacketConn)

(def
  ^{:doc "A ParseError is the error type of literal network address parsers.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ParseError"}
  ParseError)

(def
  ^{:doc "A ParseError is the error type of literal network address parsers.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ParseError"}
  refToParseError)

(def
  ^{:doc "A ParseError is the error type of literal network address parsers.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_ParseError"}
  arrayOfParseError)

(def
  ^{:doc "A Resolver looks up names and numbers.\n\nA nil *Resolver is equivalent to a zero Resolver.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Resolver"}
  Resolver)

(def
  ^{:doc "A Resolver looks up names and numbers.\n\nA nil *Resolver is equivalent to a zero Resolver.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Resolver"}
  refToResolver)

(def
  ^{:doc "A Resolver looks up names and numbers.\n\nA nil *Resolver is equivalent to a zero Resolver.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Resolver"}
  arrayOfResolver)

(def
  ^{:doc "An SRV represents a single DNS SRV record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SRV"}
  SRV)

(def
  ^{:doc "An SRV represents a single DNS SRV record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_SRV"}
  refToSRV)

(def
  ^{:doc "An SRV represents a single DNS SRV record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_SRV"}
  arrayOfSRV)

(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_UnknownNetworkError"}
  UnknownNetworkError)

(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_UnknownNetworkError"}
  refToUnknownNetworkError)

(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_UnknownNetworkError"}
  arrayOfUnknownNetworkError)

;;;; Auto-generated by gostd at (omitted for testing)

(ns
  ^{:go-imports {"go.std.net.url" ["url" "net/url"]}
    :doc "Provides a low-level interface to the net/url package.\n\nPackage url parses URLs and implements query escaping.\n"
    :empty false}
  go.std.net.url)

(defn Parse
  "Parse parses rawurl into a URL structure.\n\nThe rawurl may be relative (a path, without a host) or absolute\n(starting with a scheme). Trying to parse a hostname and path\nwithout a scheme is invalid but may not necessarily return an\nerror, due to parsing ambiguities.\n\nGo input arguments: (rawurl string)\n\nGo returns: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker returns: [^refToURL, ^Error]"
  {:added "1.0"
   :go "_f_parse(_v_rawurl)"}
  [^String _v_rawurl])

(defn ParseQuery
  "ParseQuery parses the URL-encoded query string and returns\na map listing the values specified for each key.\nParseQuery always returns a non-nil map containing all the\nvalid query parameters found; err describes the first decoding error\nencountered, if any.\n\nQuery is expected to be a list of key=value settings separated by\nampersands or semicolons. A setting without an equals sign is\ninterpreted as a key set to an empty value.\n\nGo input arguments: (query string)\n\nGo returns: (Values, error)\n\nJoker input arguments: [^String query]\n\nJoker returns: [^Values, ^Error]"
  {:added "1.0"
   :go "_f_parseQuery(_v_query)"}
  [^String _v_query])

(defn ParseRequestURI
  "ParseRequestURI parses rawurl into a URL structure. It assumes that\nrawurl was received in an HTTP request, so the rawurl is interpreted\nonly as an absolute URI or an absolute path.\nThe string rawurl is assumed not to have a #fragment suffix.\n(Web browsers strip #fragment before sending the URL to a web server.)\n\nGo input arguments: (rawurl string)\n\nGo returns: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker returns: [^refToURL, ^Error]"
  {:added "1.0"
   :go "_f_parseRequestURI(_v_rawurl)"}
  [^String _v_rawurl])

(defn ^"String" PathEscape
  "PathEscape escapes the string so it can be safely placed\ninside a URL path segment.\n\nGo input arguments: (s string)\n\nGo returns: string\n\nJoker input arguments: [^String s]\n\nJoker returns: ^String"
  {:added "1.0"
   :go "url.PathEscape(_v_s)"}
  [^String _v_s])

(defn PathUnescape
  "PathUnescape does the inverse transformation of PathEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB. It returns an error if any % is not followed\nby two hexadecimal digits.\n\nPathUnescape is identical to QueryUnescape except that it does not\nunescape '+' to ' ' (space).\n\nGo input arguments: (s string)\n\nGo returns: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker returns: [^String, ^Error]"
  {:added "1.0"
   :go "_f_pathUnescape(_v_s)"}
  [^String _v_s])

(defn ^"String" QueryEscape
  "QueryEscape escapes the string so it can be safely placed\ninside a URL query.\n\nGo input arguments: (s string)\n\nGo returns: string\n\nJoker input arguments: [^String s]\n\nJoker returns: ^String"
  {:added "1.0"
   :go "url.QueryEscape(_v_s)"}
  [^String _v_s])

(defn QueryUnescape
  "QueryUnescape does the inverse transformation of QueryEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB.\nIt returns an error if any % is not followed by two hexadecimal\ndigits.\n\nGo input arguments: (s string)\n\nGo returns: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker returns: [^String, ^Error]"
  {:added "1.0"
   :go "_f_queryUnescape(_v_s)"}
  [^String _v_s])

(defn User
  "User returns a Userinfo containing the provided username\nand no password set.\n\nGo input arguments: (username string)\n\nGo returns: *Userinfo\n\nJoker input arguments: [^String username]\n\nJoker returns: ^refToUserinfo"
  {:added "1.0"
   :go "_f_user(_v_username)"}
  [^String _v_username])

(defn UserPassword
  "UserPassword returns a Userinfo containing the provided username\nand password.\n\nThis functionality should only be used with legacy web sites.\nRFC 2396 warns that interpreting Userinfo this way\n``is NOT RECOMMENDED, because the passing of authentication\ninformation in clear text (such as URI) has proven to be a\nsecurity risk in almost every case where it has been used.''\n\nGo input arguments: (username string, password string)\n\nGo returns: *Userinfo\n\nJoker input arguments: [^String username, ^String password]\n\nJoker returns: ^refToUserinfo"
  {:added "1.0"
   :go "_f_userPassword(_v_username, _v_password)"}
  [^String _v_username, ^String _v_password])
(def
  ^{:doc "Error reports an error and the operation and URL that caused it.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Error"}
  Error)

(def
  ^{:doc "Error reports an error and the operation and URL that caused it.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Error"}
  refToError)

(def
  ^{:doc "Error reports an error and the operation and URL that caused it.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Error"}
  arrayOfError)

(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_EscapeError"}
  EscapeError)

(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_EscapeError"}
  refToEscapeError)

(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_EscapeError"}
  arrayOfEscapeError)

(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_InvalidHostError"}
  InvalidHostError)

(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_InvalidHostError"}
  refToInvalidHostError)

(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_InvalidHostError"}
  arrayOfInvalidHostError)

(def
  ^{:doc "A URL represents a parsed URL (technically, a URI reference).\n\nThe general form represented is:\n\n\t[scheme:][//[userinfo@]host][/]path[?query][#fragment]\n\nURLs that do not start with a slash after the scheme are interpreted as:\n\n\tscheme:opaque[?query][#fragment]\n\nNote that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.\nA consequence is that it is impossible to tell which slashes in the Path were\nslashes in the raw URL and which were %2f. This distinction is rarely important,\nbut when it is, code must not use Path directly.\nThe Parse function sets both Path and RawPath in the URL it returns,\nand URL's String method uses RawPath if it is a valid encoding of Path,\nby calling the EscapedPath method.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_URL"}
  URL)

(def
  ^{:doc "A URL represents a parsed URL (technically, a URI reference).\n\nThe general form represented is:\n\n\t[scheme:][//[userinfo@]host][/]path[?query][#fragment]\n\nURLs that do not start with a slash after the scheme are interpreted as:\n\n\tscheme:opaque[?query][#fragment]\n\nNote that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.\nA consequence is that it is impossible to tell which slashes in the Path were\nslashes in the raw URL and which were %2f. This distinction is rarely important,\nbut when it is, code must not use Path directly.\nThe Parse function sets both Path and RawPath in the URL it returns,\nand URL's String method uses RawPath if it is a valid encoding of Path,\nby calling the EscapedPath method.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_URL"}
  refToURL)

(def
  ^{:doc "A URL represents a parsed URL (technically, a URI reference).\n\nThe general form represented is:\n\n\t[scheme:][//[userinfo@]host][/]path[?query][#fragment]\n\nURLs that do not start with a slash after the scheme are interpreted as:\n\n\tscheme:opaque[?query][#fragment]\n\nNote that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.\nA consequence is that it is impossible to tell which slashes in the Path were\nslashes in the raw URL and which were %2f. This distinction is rarely important,\nbut when it is, code must not use Path directly.\nThe Parse function sets both Path and RawPath in the URL it returns,\nand URL's String method uses RawPath if it is a valid encoding of Path,\nby calling the EscapedPath method.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_URL"}
  arrayOfURL)

(def
  ^{:doc "The Userinfo type is an immutable encapsulation of username and\npassword details for a URL. An existing Userinfo value is guaranteed\nto have a username set (potentially empty, as allowed by RFC 2396),\nand optionally a password.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Userinfo"}
  Userinfo)

(def
  ^{:doc "The Userinfo type is an immutable encapsulation of username and\npassword details for a URL. An existing Userinfo value is guaranteed\nto have a username set (potentially empty, as allowed by RFC 2396),\nand optionally a password.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Userinfo"}
  refToUserinfo)

(def
  ^{:doc "The Userinfo type is an immutable encapsulation of username and\npassword details for a URL. An existing Userinfo value is guaranteed\nto have a username set (potentially empty, as allowed by RFC 2396),\nand optionally a password.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Userinfo"}
  arrayOfUserinfo)

(def
  ^{:doc "Values maps a string key to a list of values.\nIt is typically used for query parameters and form values.\nUnlike in the http.Header map, the keys in a Values map\nare case-sensitive.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Values"}
  Values)

(def
  ^{:doc "Values maps a string key to a list of values.\nIt is typically used for query parameters and form values.\nUnlike in the http.Header map, the keys in a Values map\nare case-sensitive.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Values"}
  refToValues)

(def
  ^{:doc "Values maps a string key to a list of values.\nIt is typically used for query parameters and form values.\nUnlike in the http.Header map, the keys in a Values map\nare case-sensitive.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Values"}
  arrayOfValues)

// Auto-generated by gostd at (omitted for testing)

package net

import (
	. "github.com/candid82/joker/core"
	"net"
)

func Extract_ns_arrayOfrefToMX(args []Object, index int) []*net.MX {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []*net.MX:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]*net.MX]"))
}

func Extract_ns_arrayOfrefToNS(args []Object, index int) []*net.NS {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []*net.NS:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]*net.NS]"))
}

func Extract_ns_arrayOfrefToSRV(args []Object, index int) []*net.SRV {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []*net.SRV:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]*net.SRV]"))
}

func Extract_ns_arrayOfAddrError(args []Object, index int) []net.AddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.AddrError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.AddrError]"))
}

func Extract_ns_arrayOfBuffers(args []Object, index int) []net.Buffers {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.Buffers:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.Buffers]"))
}

func Extract_ns_arrayOfDNSConfigError(args []Object, index int) []net.DNSConfigError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.DNSConfigError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.DNSConfigError]"))
}

func Extract_ns_arrayOfDNSError(args []Object, index int) []net.DNSError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.DNSError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.DNSError]"))
}

func Extract_ns_arrayOfIP(args []Object, index int) []net.IP {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.IP:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.IP]"))
}

func Extract_ns_arrayOfIPAddr(args []Object, index int) []net.IPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.IPAddr:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.IPAddr]"))
}

func Extract_ns_arrayOfIPConn(args []Object, index int) []net.IPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.IPConn:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.IPConn]"))
}

func Extract_ns_arrayOfIPMask(args []Object, index int) []net.IPMask {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.IPMask:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.IPMask]"))
}

func Extract_ns_arrayOfIPNet(args []Object, index int) []net.IPNet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.IPNet:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.IPNet]"))
}

func Extract_ns_arrayOfInvalidAddrError(args []Object, index int) []net.InvalidAddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.InvalidAddrError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.InvalidAddrError]"))
}

func Extract_ns_arrayOfMX(args []Object, index int) []net.MX {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.MX:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.MX]"))
}

func Extract_ns_arrayOfNS(args []Object, index int) []net.NS {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.NS:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.NS]"))
}

func Extract_ns_arrayOfOpError(args []Object, index int) []net.OpError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.OpError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.OpError]"))
}

func Extract_ns_arrayOfParseError(args []Object, index int) []net.ParseError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.ParseError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.ParseError]"))
}

func Extract_ns_arrayOfResolver(args []Object, index int) []net.Resolver {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.Resolver:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.Resolver]"))
}

func Extract_ns_arrayOfSRV(args []Object, index int) []net.SRV {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.SRV:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.SRV]"))
}

func Extract_ns_arrayOfUnknownNetworkError(args []Object, index int) []net.UnknownNetworkError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.UnknownNetworkError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.UnknownNetworkError]"))
}

func Extract_ns_Addr(args []Object, index int) net.Addr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case net.Addr:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Addr]"))
}

func Extract_ns_AddrError(args []Object, index int) *net.AddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.AddrError:
			return r
		case net.AddrError:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.AddrError]"))
}

func _mapToAddrError(o Map) *net.AddrError {
	return &net.AddrError{
		Err: FieldAsString(o, "Err"),
		Addr: FieldAsString(o, "Addr"),
	}
}

func _Ctor_AddrError(_v Object) *net.AddrError {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToAddrError(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.AddrError] or: Map"))
}

func _Wrapped_Ctor_AddrError(_o Object) Object {
	return MakeGoObject(_Ctor_AddrError(_o))
}

func Extract_ns_refToAddrError(args []Object, index int) *net.AddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.AddrError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.AddrError]"))
}

func Extract_ns_Buffers(args []Object, index int) net.Buffers {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case net.Buffers:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Buffers]"))
}

// func _Ctor_Buffers(_v Object) net.Buffers {
// 	switch _o := _v.(type) {
// 	default:
// 		return _net.Buffers(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for Buffers))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Buffers] or: whatever"))
// }

// func _Wrapped_Ctor_Buffers(_o Object) Object {
// 	return MakeGoObject(_Ctor_Buffers(_o))
// }

func Extract_ns_refToBuffers(args []Object, index int) *net.Buffers {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.Buffers:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.Buffers]"))
}

func Extract_ns_Conn(args []Object, index int) net.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case net.Conn:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Conn]"))
}

func Extract_ns_DNSConfigError(args []Object, index int) *net.DNSConfigError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.DNSConfigError:
			return r
		case net.DNSConfigError:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.DNSConfigError]"))
}

func _mapToDNSConfigError(o Map) *net.DNSConfigError {
	return &net.DNSConfigError{
		Err: FieldAsError(o, "Err"),
	}
}

func _Ctor_DNSConfigError(_v Object) *net.DNSConfigError {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToDNSConfigError(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.DNSConfigError] or: Map"))
}

func _Wrapped_Ctor_DNSConfigError(_o Object) Object {
	return MakeGoObject(_Ctor_DNSConfigError(_o))
}

func Extract_ns_refToDNSConfigError(args []Object, index int) *net.DNSConfigError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.DNSConfigError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.DNSConfigError]"))
}

func Extract_ns_DNSError(args []Object, index int) *net.DNSError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.DNSError:
			return r
		case net.DNSError:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.DNSError]"))
}

func _mapToDNSError(o Map) *net.DNSError {
	return &net.DNSError{
		Err: FieldAsString(o, "Err"),
		Name: FieldAsString(o, "Name"),
		Server: FieldAsString(o, "Server"),
		IsTimeout: FieldAsBoolean(o, "IsTimeout"),
		IsTemporary: FieldAsBoolean(o, "IsTemporary"),
	}
}

func _Ctor_DNSError(_v Object) *net.DNSError {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToDNSError(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.DNSError] or: Map"))
}

func _Wrapped_Ctor_DNSError(_o Object) Object {
	return MakeGoObject(_Ctor_DNSError(_o))
}

func Extract_ns_refToDNSError(args []Object, index int) *net.DNSError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.DNSError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.DNSError]"))
}

func Extract_ns_Error(args []Object, index int) net.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case net.Error:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Error]"))
}

func Extract_ns_IP(args []Object, index int) net.IP {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case net.IP:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IP]"))
}

// func _Ctor_IP(_v Object) net.IP {
// 	switch _o := _v.(type) {
// 	default:
// 		return _net.IP(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for IP))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IP] or: whatever"))
// }

// func _Wrapped_Ctor_IP(_o Object) Object {
// 	return MakeGoObject(_Ctor_IP(_o))
// }

func Extract_ns_refToIP(args []Object, index int) *net.IP {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.IP:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.IP]"))
}

func Extract_ns_IPAddr(args []Object, index int) *net.IPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.IPAddr:
			return r
		case net.IPAddr:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPAddr]"))
}

// func _mapToIPAddr(o Map) *net.IPAddr {
// 	return &net.IPAddr{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Zone: FieldAsString(o, "Zone"),
// 	}
// }

// func _Ctor_IPAddr(_v Object) *net.IPAddr {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToIPAddr(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPAddr] or: Map"))
// }

// func _Wrapped_Ctor_IPAddr(_o Object) Object {
// 	return MakeGoObject(_Ctor_IPAddr(_o))
// }

func Extract_ns_refToIPAddr(args []Object, index int) *net.IPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.IPAddr:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.IPAddr]"))
}

func Extract_ns_IPConn(args []Object, index int) *net.IPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.IPConn:
			return r
		case net.IPConn:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPConn]"))
}

func _mapToIPConn(o Map) *net.IPConn {
	return &net.IPConn{}
}

func _Ctor_IPConn(_v Object) *net.IPConn {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToIPConn(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPConn] or: Map"))
}

func _Wrapped_Ctor_IPConn(_o Object) Object {
	return MakeGoObject(_Ctor_IPConn(_o))
}

func Extract_ns_refToIPConn(args []Object, index int) *net.IPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.IPConn:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.IPConn]"))
}

func Extract_ns_IPMask(args []Object, index int) net.IPMask {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case net.IPMask:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPMask]"))
}

// func _Ctor_IPMask(_v Object) net.IPMask {
// 	switch _o := _v.(type) {
// 	default:
// 		return _net.IPMask(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for IPMask))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPMask] or: whatever"))
// }

// func _Wrapped_Ctor_IPMask(_o Object) Object {
// 	return MakeGoObject(_Ctor_IPMask(_o))
// }

func Extract_ns_refToIPMask(args []Object, index int) *net.IPMask {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.IPMask:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.IPMask]"))
}

func Extract_ns_IPNet(args []Object, index int) *net.IPNet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.IPNet:
			return r
		case net.IPNet:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPNet]"))
}

// func _mapToIPNet(o Map) *net.IPNet {
// 	return &net.IPNet{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Mask: ABEND048(codegen.go: no conversion from Clojure for net.IPMask ([]byte)),
// 	}
// }

// func _Ctor_IPNet(_v Object) *net.IPNet {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToIPNet(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPNet] or: Map"))
// }

// func _Wrapped_Ctor_IPNet(_o Object) Object {
// 	return MakeGoObject(_Ctor_IPNet(_o))
// }

func Extract_ns_refToIPNet(args []Object, index int) *net.IPNet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.IPNet:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.IPNet]"))
}

func Extract_ns_InvalidAddrError(args []Object, index int) *net.InvalidAddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.InvalidAddrError:
			return r
		case net.InvalidAddrError:
			return &r  // refTo
		}
	case String:
		v := net.InvalidAddrError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.InvalidAddrError]"))
}

func _Ctor_InvalidAddrError(_v Object) net.InvalidAddrError {
	switch _o := _v.(type) {
	case String:
		return net.InvalidAddrError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.InvalidAddrError] or: String"))
}

func _Wrapped_Ctor_InvalidAddrError(_o Object) Object {
	return MakeGoObject(_Ctor_InvalidAddrError(_o))
}

func Extract_ns_refToInvalidAddrError(args []Object, index int) *net.InvalidAddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.InvalidAddrError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.InvalidAddrError]"))
}

func Extract_ns_Listener(args []Object, index int) net.Listener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case net.Listener:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Listener]"))
}

func Extract_ns_MX(args []Object, index int) *net.MX {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.MX:
			return r
		case net.MX:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.MX]"))
}

func _mapToMX(o Map) *net.MX {
	return &net.MX{
		Host: FieldAsString(o, "Host"),
		Pref: FieldAsUint16(o, "Pref"),
	}
}

func _Ctor_MX(_v Object) *net.MX {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToMX(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.MX] or: Map"))
}

func _Wrapped_Ctor_MX(_o Object) Object {
	return MakeGoObject(_Ctor_MX(_o))
}

func Extract_ns_refToMX(args []Object, index int) *net.MX {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.MX:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.MX]"))
}

func Extract_ns_NS(args []Object, index int) *net.NS {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.NS:
			return r
		case net.NS:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.NS]"))
}

func _mapToNS(o Map) *net.NS {
	return &net.NS{
		Host: FieldAsString(o, "Host"),
	}
}

func _Ctor_NS(_v Object) *net.NS {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToNS(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.NS] or: Map"))
}

func _Wrapped_Ctor_NS(_o Object) Object {
	return MakeGoObject(_Ctor_NS(_o))
}

func Extract_ns_refToNS(args []Object, index int) *net.NS {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.NS:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.NS]"))
}

func Extract_ns_OpError(args []Object, index int) *net.OpError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.OpError:
			return r
		case net.OpError:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.OpError]"))
}

// func _mapToOpError(o Map) *net.OpError {
// 	return &net.OpError{
// 		Op: FieldAsString(o, "Op"),
// 		Net: FieldAsString(o, "Net"),
// 		Source: ABEND048(codegen.go: no conversion from Clojure for net.Addr (ABEND320(gtypes.go: interface{Network func()string,String func()string} not supported))),
// 		Addr: ABEND048(codegen.go: no conversion from Clojure for net.Addr (ABEND320(gtypes.go: interface{Network func()string,String func()string} not supported))),
// 		Err: FieldAsError(o, "Err"),
// 	}
// }

// func _Ctor_OpError(_v Object) *net.OpError {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToOpError(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.OpError] or: Map"))
// }

// func _Wrapped_Ctor_OpError(_o Object) Object {
// 	return MakeGoObject(_Ctor_OpError(_o))
// }

func Extract_ns_refToOpError(args []Object, index int) *net.OpError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.OpError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.OpError]"))
}

func Extract_ns_PacketConn(args []Object, index int) net.PacketConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case net.PacketConn:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.PacketConn]"))
}

func Extract_ns_ParseError(args []Object, index int) *net.ParseError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.ParseError:
			return r
		case net.ParseError:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.ParseError]"))
}

func _mapToParseError(o Map) *net.ParseError {
	return &net.ParseError{
		Type: FieldAsString(o, "Type"),
		Text: FieldAsString(o, "Text"),
	}
}

func _Ctor_ParseError(_v Object) *net.ParseError {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToParseError(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.ParseError] or: Map"))
}

func _Wrapped_Ctor_ParseError(_o Object) Object {
	return MakeGoObject(_Ctor_ParseError(_o))
}

func Extract_ns_refToParseError(args []Object, index int) *net.ParseError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.ParseError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.ParseError]"))
}

func Extract_ns_Resolver(args []Object, index int) *net.Resolver {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.Resolver:
			return r
		case net.Resolver:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Resolver]"))
}

// func _mapToResolver(o Map) *net.Resolver {
// 	return &net.Resolver{
// 		PreferGo: FieldAsBoolean(o, "PreferGo"),
// 		StrictErrors: FieldAsBoolean(o, "StrictErrors"),
// 		Dial: ABEND727(gtypes.go: func(ctx context.Context,network string,address string)(Conn,error) not supported),
// 	}
// }

// func _Ctor_Resolver(_v Object) *net.Resolver {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToResolver(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Resolver] or: Map"))
// }

// func _Wrapped_Ctor_Resolver(_o Object) Object {
// 	return MakeGoObject(_Ctor_Resolver(_o))
// }

func Extract_ns_refToResolver(args []Object, index int) *net.Resolver {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.Resolver:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.Resolver]"))
}

func Extract_ns_SRV(args []Object, index int) *net.SRV {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.SRV:
			return r
		case net.SRV:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.SRV]"))
}

func _mapToSRV(o Map) *net.SRV {
	return &net.SRV{
		Target: FieldAsString(o, "Target"),
		Port: FieldAsUint16(o, "Port"),
		Priority: FieldAsUint16(o, "Priority"),
		Weight: FieldAsUint16(o, "Weight"),
	}
}

func _Ctor_SRV(_v Object) *net.SRV {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToSRV(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.SRV] or: Map"))
}

func _Wrapped_Ctor_SRV(_o Object) Object {
	return MakeGoObject(_Ctor_SRV(_o))
}

func Extract_ns_refToSRV(args []Object, index int) *net.SRV {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.SRV:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.SRV]"))
}

func Extract_ns_UnknownNetworkError(args []Object, index int) *net.UnknownNetworkError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.UnknownNetworkError:
			return r
		case net.UnknownNetworkError:
			return &r  // refTo
		}
	case String:
		v := net.UnknownNetworkError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnknownNetworkError]"))
}

func _Ctor_UnknownNetworkError(_v Object) net.UnknownNetworkError {
	switch _o := _v.(type) {
	case String:
		return net.UnknownNetworkError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnknownNetworkError] or: String"))
}

func _Wrapped_Ctor_UnknownNetworkError(_o Object) Object {
	return MakeGoObject(_Ctor_UnknownNetworkError(_o))
}

func Extract_ns_refToUnknownNetworkError(args []Object, index int) *net.UnknownNetworkError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.UnknownNetworkError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.UnknownNetworkError]"))
}

func _f_cIDRMask(_v_ones int, _v_bits int) Object {
	_res := net.CIDRMask(_v_ones, _v_bits)
	return MakeGoObject(_res)
}

func _f_dialIP(_v_network string, _v_laddr *net.IPAddr, _v_raddr *net.IPAddr) Object {
	_res1, _res2 := net.DialIP(_v_network, _v_laddr, _v_raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func _f_iPv4(_v_a byte, _v_b byte, _v_c byte, _v_d byte) Object {
	_res := net.IPv4(_v_a, _v_b, _v_c, _v_d)
	return MakeGoObject(_res)
}

func _f_iPv4Mask(_v_a byte, _v_b byte, _v_c byte, _v_d byte) Object {
	_res := net.IPv4Mask(_v_a, _v_b, _v_c, _v_d)
	return MakeGoObject(_res)
}

func _f_listenIP(_v_network string, _v_laddr *net.IPAddr) Object {
	_res1, _res2 := net.ListenIP(_v_network, _v_laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func _f_lookupAddr(_v_addr string) Object {
	names, err := net.LookupAddr(_v_addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(names))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

func _f_lookupCNAME(_v_host string) Object {
	cname, err := net.LookupCNAME(_v_host)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(cname))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

func _f_lookupHost(_v_host string) Object {
	addrs, err := net.LookupHost(_v_host)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(addrs))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

func _f_lookupIP(_v_host string) Object {
	_res1, _res2 := net.LookupIP(_v_host)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func _f_lookupMX(_v_name string) Object {
	_res1, _res2 := net.LookupMX(_v_name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func _f_lookupNS(_v_name string) Object {
	_res1, _res2 := net.LookupNS(_v_name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func _f_lookupPort(_v_network string, _v_service string) Object {
	port, err := net.LookupPort(_v_network, _v_service)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(port))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

func _f_lookupSRV(_v_service string, _v_proto string, _v_name string) Object {
	cname, addrs, err := net.LookupSRV(_v_service, _v_proto, _v_name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(cname))
	_res = _res.Conjoin(MakeGoObject(addrs))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

func _f_lookupTXT(_v_name string) Object {
	_res1, _res2 := net.LookupTXT(_v_name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func _f_parseCIDR(_v_s string) Object {
	_res1, _res2, _res3 := net.ParseCIDR(_v_s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
	return _res
}

func _f_parseIP(_v_s string) Object {
	_res := net.ParseIP(_v_s)
	return MakeGoObject(_res)
}

func _f_resolveIPAddr(_v_network string, _v_address string) Object {
	_res1, _res2 := net.ResolveIPAddr(_v_network, _v_address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func _f_addr_Network(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.Addr)Network()", args, 0, 0)
	_res := o.O.(net.Addr).Network()
	return MakeString(_res)
}

func _f_addr_String(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.Addr)String()", args, 0, 0)
	_res := o.O.(net.Addr).String()
	return MakeString(_res)
}

func _f_conn_Close(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.Conn)Close()", args, 0, 0)
	_res := o.O.(net.Conn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

func _f_conn_LocalAddr(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.Conn)LocalAddr()", args, 0, 0)
	_res := o.O.(net.Conn).LocalAddr()
	return MakeGoObject(_res)
}

func _f_conn_Read(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net.Conn)Read()", args, 1, 1)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	n, err := o.O.(net.Conn).Read(_v_b)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

func _f_conn_RemoteAddr(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.Conn)RemoteAddr()", args, 0, 0)
	_res := o.O.(net.Conn).RemoteAddr()
	return MakeGoObject(_res)
}

// func _f_conn_SetDeadline(o GoObject, args Object) Object {  // Method
// (t ABEND002(reference to unavailable package `time' looking for type `Time'))}

// func _f_conn_SetReadDeadline(o GoObject, args Object) Object {  // Method
// (t ABEND002(reference to unavailable package `time' looking for type `Time'))}

// func _f_conn_SetWriteDeadline(o GoObject, args Object) Object {  // Method
// (t ABEND002(reference to unavailable package `time' looking for type `Time'))}

func _f_conn_Write(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net.Conn)Write()", args, 1, 1)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	n, err := o.O.(net.Conn).Write(_v_b)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

// func _f_error_Error(o GoObject, args Object) Object {  // Method
// 	CheckReceiverArity("(net.Error)Error()", args, 0, 0)
// 	return o.O.(net.Error).Error()
// 	ABEND124(post.go: no public information returned)
// }

func _f_error_Temporary(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.Error)Temporary()", args, 0, 0)
	_res := o.O.(net.Error).Temporary()
	return MakeBoolean(_res)
}

func _f_error_Timeout(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.Error)Timeout()", args, 0, 0)
	_res := o.O.(net.Error).Timeout()
	return MakeBoolean(_res)
}

func _f_iPMask_Size(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IPMask)Size()", args, 0, 0)
	ones, bits := o.O.(net.IPMask).Size()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(ones))
	_res = _res.Conjoin(MakeInt(bits))
	return _res
}

func _f_iPMask_String(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IPMask)String()", args, 0, 0)
	_res := o.O.(net.IPMask).String()
	return MakeString(_res)
}

func _f_iP_DefaultMask(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)DefaultMask()", args, 0, 0)
	_res := o.O.(net.IP).DefaultMask()
	return MakeGoObject(_res)
}

func _f_iP_Equal(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(net.IP)Equal()", args, 1, 1)
	_v_x := SeqNth(_argList, 0).(GoObject).O.(net.IP)
	_res := o.O.(net.IP).Equal(_v_x)
	return MakeBoolean(_res)
}

func _f_iP_IsGlobalUnicast(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)IsGlobalUnicast()", args, 0, 0)
	_res := o.O.(net.IP).IsGlobalUnicast()
	return MakeBoolean(_res)
}

func _f_iP_IsInterfaceLocalMulticast(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)IsInterfaceLocalMulticast()", args, 0, 0)
	_res := o.O.(net.IP).IsInterfaceLocalMulticast()
	return MakeBoolean(_res)
}

func _f_iP_IsLinkLocalMulticast(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)IsLinkLocalMulticast()", args, 0, 0)
	_res := o.O.(net.IP).IsLinkLocalMulticast()
	return MakeBoolean(_res)
}

func _f_iP_IsLinkLocalUnicast(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)IsLinkLocalUnicast()", args, 0, 0)
	_res := o.O.(net.IP).IsLinkLocalUnicast()
	return MakeBoolean(_res)
}

func _f_iP_IsLoopback(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)IsLoopback()", args, 0, 0)
	_res := o.O.(net.IP).IsLoopback()
	return MakeBoolean(_res)
}

func _f_iP_IsMulticast(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)IsMulticast()", args, 0, 0)
	_res := o.O.(net.IP).IsMulticast()
	return MakeBoolean(_res)
}

func _f_iP_IsUnspecified(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)IsUnspecified()", args, 0, 0)
	_res := o.O.(net.IP).IsUnspecified()
	return MakeBoolean(_res)
}

func _f_iP_MarshalText(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)MarshalText()", args, 0, 0)
	_res1, _res2 := o.O.(net.IP).MarshalText()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func _f_iP_Mask(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(net.IP)Mask()", args, 1, 1)
	_v_mask := SeqNth(_argList, 0).(GoObject).O.(net.IPMask)
	_res := o.O.(net.IP).Mask(_v_mask)
	return MakeGoObject(_res)
}

func _f_iP_String(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)String()", args, 0, 0)
	_res := o.O.(net.IP).String()
	return MakeString(_res)
}

func _f_iP_To16(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)To16()", args, 0, 0)
	_res := o.O.(net.IP).To16()
	return MakeGoObject(_res)
}

func _f_iP_To4(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)To4()", args, 0, 0)
	_res := o.O.(net.IP).To4()
	return MakeGoObject(_res)
}

func _f_invalidAddrError_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.InvalidAddrError)Error()", args, 0, 0)
	_res := o.O.(net.InvalidAddrError).Error()
	return MakeString(_res)
}

func _f_invalidAddrError_Temporary(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.InvalidAddrError)Temporary()", args, 0, 0)
	_res := o.O.(net.InvalidAddrError).Temporary()
	return MakeBoolean(_res)
}

func _f_invalidAddrError_Timeout(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.InvalidAddrError)Timeout()", args, 0, 0)
	_res := o.O.(net.InvalidAddrError).Timeout()
	return MakeBoolean(_res)
}

func _f_listener_Accept(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.Listener)Accept()", args, 0, 0)
	_res1, _res2 := o.O.(net.Listener).Accept()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func _f_listener_Addr(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.Listener)Addr()", args, 0, 0)
	_res := o.O.(net.Listener).Addr()
	return MakeGoObject(_res)
}

func _f_listener_Close(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.Listener)Close()", args, 0, 0)
	_res := o.O.(net.Listener).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

func _f_packetConn_Close(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.PacketConn)Close()", args, 0, 0)
	_res := o.O.(net.PacketConn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

func _f_packetConn_LocalAddr(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.PacketConn)LocalAddr()", args, 0, 0)
	_res := o.O.(net.PacketConn).LocalAddr()
	return MakeGoObject(_res)
}

func _f_packetConn_ReadFrom(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net.PacketConn)ReadFrom()", args, 1, 1)
	_v_p := SeqNth(_argList, 0).(GoObject).O.([]byte)
	n, addr, err := o.O.(net.PacketConn).ReadFrom(_v_p)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(MakeGoObject(addr))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

// func _f_packetConn_SetDeadline(o GoObject, args Object) Object {  // Method
// (t ABEND002(reference to unavailable package `time' looking for type `Time'))}

// func _f_packetConn_SetReadDeadline(o GoObject, args Object) Object {  // Method
// (t ABEND002(reference to unavailable package `time' looking for type `Time'))}

// func _f_packetConn_SetWriteDeadline(o GoObject, args Object) Object {  // Method
// (t ABEND002(reference to unavailable package `time' looking for type `Time'))}

func _f_packetConn_WriteTo(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net.PacketConn)WriteTo()", args, 2, 2)
	_v_p := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_v_addr := SeqNth(_argList, 1).(GoObject).O.(net.Addr)
	n, err := o.O.(net.PacketConn).WriteTo(_v_p, _v_addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

func _f_ptrTo_AddrError_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.AddrError)Error()", args, 0, 0)
	_res := o.O.(*net.AddrError).Error()
	return MakeString(_res)
}

func _f_ptrTo_AddrError_Temporary(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.AddrError)Temporary()", args, 0, 0)
	_res := o.O.(*net.AddrError).Temporary()
	return MakeBoolean(_res)
}

func _f_ptrTo_AddrError_Timeout(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.AddrError)Timeout()", args, 0, 0)
	_res := o.O.(*net.AddrError).Timeout()
	return MakeBoolean(_res)
}

func _f_ptrTo_Buffers_Read(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.Buffers)Read()", args, 1, 1)
	_v_p := SeqNth(_argList, 0).(GoObject).O.([]byte)
	n, err := o.O.(*net.Buffers).Read(_v_p)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

// func _f_ptrTo_Buffers_WriteTo(o GoObject, args Object) Object {  // Receiver
// (w ABEND002(reference to unavailable package `io' looking for type `Writer'))}

func _f_ptrTo_DNSConfigError_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.DNSConfigError)Error()", args, 0, 0)
	_res := o.O.(*net.DNSConfigError).Error()
	return MakeString(_res)
}

func _f_ptrTo_DNSConfigError_Temporary(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.DNSConfigError)Temporary()", args, 0, 0)
	_res := o.O.(*net.DNSConfigError).Temporary()
	return MakeBoolean(_res)
}

func _f_ptrTo_DNSConfigError_Timeout(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.DNSConfigError)Timeout()", args, 0, 0)
	_res := o.O.(*net.DNSConfigError).Timeout()
	return MakeBoolean(_res)
}

func _f_ptrTo_DNSError_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.DNSError)Error()", args, 0, 0)
	_res := o.O.(*net.DNSError).Error()
	return MakeString(_res)
}

func _f_ptrTo_DNSError_Temporary(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.DNSError)Temporary()", args, 0, 0)
	_res := o.O.(*net.DNSError).Temporary()
	return MakeBoolean(_res)
}

func _f_ptrTo_DNSError_Timeout(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.DNSError)Timeout()", args, 0, 0)
	_res := o.O.(*net.DNSError).Timeout()
	return MakeBoolean(_res)
}

func _f_ptrTo_IPAddr_Network(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.IPAddr)Network()", args, 0, 0)
	_res := o.O.(*net.IPAddr).Network()
	return MakeString(_res)
}

func _f_ptrTo_IPAddr_String(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.IPAddr)String()", args, 0, 0)
	_res := o.O.(*net.IPAddr).String()
	return MakeString(_res)
}

func _f_ptrTo_IPConn_ReadFrom(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.IPConn)ReadFrom()", args, 1, 1)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_res1, _res2, _res3 := o.O.(*net.IPConn).ReadFrom(_v_b)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
	return _res
}

func _f_ptrTo_IPConn_ReadFromIP(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.IPConn)ReadFromIP()", args, 1, 1)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_res1, _res2, _res3 := o.O.(*net.IPConn).ReadFromIP(_v_b)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
	return _res
}

func _f_ptrTo_IPConn_ReadMsgIP(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.IPConn)ReadMsgIP()", args, 2, 2)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_v_oob := SeqNth(_argList, 1).(GoObject).O.([]byte)
	n, oobn, flags, addr, err := o.O.(*net.IPConn).ReadMsgIP(_v_b, _v_oob)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(MakeInt(oobn))
	_res = _res.Conjoin(MakeInt(flags))
	_res = _res.Conjoin(MakeGoObject(addr))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

// func _f_ptrTo_IPConn_SyscallConn(o GoObject, args Object) Object {  // Receiver
// (ABEND002(reference to unavailable package `syscall' looking for type `RawConn'), error)}

func _f_ptrTo_IPConn_WriteMsgIP(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.IPConn)WriteMsgIP()", args, 3, 3)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_v_oob := SeqNth(_argList, 1).(GoObject).O.([]byte)
	_v_addr := SeqNth(_argList, 2).(GoObject).O.(*net.IPAddr)
	n, oobn, err := o.O.(*net.IPConn).WriteMsgIP(_v_b, _v_oob, _v_addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(MakeInt(oobn))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

func _f_ptrTo_IPConn_WriteTo(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.IPConn)WriteTo()", args, 2, 2)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_v_addr := SeqNth(_argList, 1).(GoObject).O.(net.Addr)
	_res1, _res2 := o.O.(*net.IPConn).WriteTo(_v_b, _v_addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func _f_ptrTo_IPConn_WriteToIP(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.IPConn)WriteToIP()", args, 2, 2)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_v_addr := SeqNth(_argList, 1).(GoObject).O.(*net.IPAddr)
	_res1, _res2 := o.O.(*net.IPConn).WriteToIP(_v_b, _v_addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func _f_ptrTo_IPNet_Contains(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.IPNet)Contains()", args, 1, 1)
	_v_ip := SeqNth(_argList, 0).(GoObject).O.(net.IP)
	_res := o.O.(*net.IPNet).Contains(_v_ip)
	return MakeBoolean(_res)
}

func _f_ptrTo_IPNet_Network(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.IPNet)Network()", args, 0, 0)
	_res := o.O.(*net.IPNet).Network()
	return MakeString(_res)
}

func _f_ptrTo_IPNet_String(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.IPNet)String()", args, 0, 0)
	_res := o.O.(*net.IPNet).String()
	return MakeString(_res)
}

func _f_ptrTo_IP_UnmarshalText(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.IP)UnmarshalText()", args, 1, 1)
	_v_text := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_res := o.O.(*net.IP).UnmarshalText(_v_text)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

func _f_ptrTo_OpError_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.OpError)Error()", args, 0, 0)
	_res := o.O.(*net.OpError).Error()
	return MakeString(_res)
}

func _f_ptrTo_OpError_Temporary(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.OpError)Temporary()", args, 0, 0)
	_res := o.O.(*net.OpError).Temporary()
	return MakeBoolean(_res)
}

func _f_ptrTo_OpError_Timeout(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.OpError)Timeout()", args, 0, 0)
	_res := o.O.(*net.OpError).Timeout()
	return MakeBoolean(_res)
}

func _f_ptrTo_ParseError_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.ParseError)Error()", args, 0, 0)
	_res := o.O.(*net.ParseError).Error()
	return MakeString(_res)
}

// func _f_ptrTo_Resolver_LookupAddr(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), addr string)}

// func _f_ptrTo_Resolver_LookupCNAME(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), host string)}

// func _f_ptrTo_Resolver_LookupHost(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), host string)}

// func _f_ptrTo_Resolver_LookupIPAddr(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), host string)}

// func _f_ptrTo_Resolver_LookupMX(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), name string)}

// func _f_ptrTo_Resolver_LookupNS(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), name string)}

// func _f_ptrTo_Resolver_LookupPort(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), network string, service string)}

// func _f_ptrTo_Resolver_LookupSRV(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), service string, proto string, name string)}

// func _f_ptrTo_Resolver_LookupTXT(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), name string)}

func _f_unknownNetworkError_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.UnknownNetworkError)Error()", args, 0, 0)
	_res := o.O.(net.UnknownNetworkError).Error()
	return MakeString(_res)
}

func _f_unknownNetworkError_Temporary(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.UnknownNetworkError)Temporary()", args, 0, 0)
	_res := o.O.(net.UnknownNetworkError).Temporary()
	return MakeBoolean(_res)
}

func _f_unknownNetworkError_Timeout(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.UnknownNetworkError)Timeout()", args, 0, 0)
	_res := o.O.(net.UnknownNetworkError).Timeout()
	return MakeBoolean(_res)
}
var info_Addr GoTypeInfo

var info_AddrError GoTypeInfo

var info_PtrTo_AddrError GoTypeInfo

var info_ArrayOf_AddrError GoTypeInfo

var info_Buffers GoTypeInfo

var info_PtrTo_Buffers GoTypeInfo

var info_ArrayOf_Buffers GoTypeInfo

var info_Conn GoTypeInfo

var info_DNSConfigError GoTypeInfo

var info_PtrTo_DNSConfigError GoTypeInfo

var info_ArrayOf_DNSConfigError GoTypeInfo

var info_DNSError GoTypeInfo

var info_PtrTo_DNSError GoTypeInfo

var info_ArrayOf_DNSError GoTypeInfo

var info_Error GoTypeInfo

var info_IP GoTypeInfo

var info_PtrTo_IP GoTypeInfo

var info_IPAddr GoTypeInfo

var info_PtrTo_IPAddr GoTypeInfo

var info_ArrayOf_IPAddr GoTypeInfo

var info_IPConn GoTypeInfo

var info_PtrTo_IPConn GoTypeInfo

var info_ArrayOf_IPConn GoTypeInfo

var info_IPMask GoTypeInfo

var info_PtrTo_IPMask GoTypeInfo

var info_ArrayOf_IPMask GoTypeInfo

var info_IPNet GoTypeInfo

var info_PtrTo_IPNet GoTypeInfo

var info_ArrayOf_IPNet GoTypeInfo

var info_ArrayOf_IP GoTypeInfo

var info_InvalidAddrError GoTypeInfo

var info_PtrTo_InvalidAddrError GoTypeInfo

var info_ArrayOf_InvalidAddrError GoTypeInfo

var info_Listener GoTypeInfo

var info_MX GoTypeInfo

var info_PtrTo_MX GoTypeInfo

var info_ArrayOf_MX GoTypeInfo

var info_NS GoTypeInfo

var info_PtrTo_NS GoTypeInfo

var info_ArrayOf_NS GoTypeInfo

var info_OpError GoTypeInfo

var info_PtrTo_OpError GoTypeInfo

var info_ArrayOf_OpError GoTypeInfo

var info_PacketConn GoTypeInfo

var info_ParseError GoTypeInfo

var info_PtrTo_ParseError GoTypeInfo

var info_ArrayOf_ParseError GoTypeInfo

var info_Resolver GoTypeInfo

var info_PtrTo_Resolver GoTypeInfo

var info_ArrayOf_Resolver GoTypeInfo

var info_SRV GoTypeInfo

var info_PtrTo_SRV GoTypeInfo

var info_ArrayOf_SRV GoTypeInfo

var info_UnknownNetworkError GoTypeInfo

var info_PtrTo_UnknownNetworkError GoTypeInfo

var info_ArrayOf_UnknownNetworkError GoTypeInfo


func initNative() {
	info_Addr = GoTypeInfo{Name: "go.std.net/Addr",
		GoType: &GoType{T: &info_Addr},
		Members: GoMembers{
			"Network": MakeGoReceiver("Network", _f_addr_Network, "name of the network (for example, \"tcp\", \"udp\")\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", _f_addr_String, "string form of address (for example, \"192.0.2.1:25\", \"[2001:db8::1]:80\")\n", "1.0", NewVectorFrom()),
		},
	}


	info_AddrError = GoTypeInfo{Name: "go.std.net/AddrError",
		GoType: &GoType{T: &info_AddrError},
		Ctor: _Wrapped_Ctor_AddrError,
		Members: GoMembers{
		},
	}


	info_PtrTo_AddrError = GoTypeInfo{Name: "go.std.net/refToAddrError",
		GoType: &GoType{T: &info_PtrTo_AddrError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_ptrTo_AddrError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", _f_ptrTo_AddrError_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", _f_ptrTo_AddrError_Timeout, "", "1.0", NewVectorFrom()),
		},
	}


	info_ArrayOf_AddrError = GoTypeInfo{Name: "go.std.net/arrayOfAddrError",
		GoType: &GoType{T: &info_ArrayOf_AddrError},
		Members: GoMembers{
		},
	}


	info_Buffers = GoTypeInfo{Name: "go.std.net/Buffers",
		GoType: &GoType{T: &info_Buffers},
		Members: GoMembers{
		},
	}


	info_PtrTo_Buffers = GoTypeInfo{Name: "go.std.net/refToBuffers",
		GoType: &GoType{T: &info_PtrTo_Buffers},
		Members: GoMembers{
			"Read": MakeGoReceiver("Read", _f_ptrTo_Buffers_Read, "", "1.0", NewVectorFrom(MakeSymbol("p"))),
		},
	}


	info_ArrayOf_Buffers = GoTypeInfo{Name: "go.std.net/arrayOfBuffers",
		GoType: &GoType{T: &info_ArrayOf_Buffers},
		Members: GoMembers{
		},
	}


	info_Conn = GoTypeInfo{Name: "go.std.net/Conn",
		GoType: &GoType{T: &info_Conn},
		Members: GoMembers{
			"Close": MakeGoReceiver("Close", _f_conn_Close, "Close closes the connection.\nAny blocked Read or Write operations will be unblocked and return errors.\n", "1.0", NewVectorFrom()),
			"LocalAddr": MakeGoReceiver("LocalAddr", _f_conn_LocalAddr, "LocalAddr returns the local network address.\n", "1.0", NewVectorFrom()),
			"Read": MakeGoReceiver("Read", _f_conn_Read, "Read reads data from the connection.\nRead can be made to time out and return an Error with Timeout() == true\nafter a fixed time limit; see SetDeadline and SetReadDeadline.\n", "1.0", NewVectorFrom(MakeSymbol("b"))),
			"RemoteAddr": MakeGoReceiver("RemoteAddr", _f_conn_RemoteAddr, "RemoteAddr returns the remote network address.\n", "1.0", NewVectorFrom()),
			"Write": MakeGoReceiver("Write", _f_conn_Write, "Write writes data to the connection.\nWrite can be made to time out and return an Error with Timeout() == true\nafter a fixed time limit; see SetDeadline and SetWriteDeadline.\n", "1.0", NewVectorFrom(MakeSymbol("b"))),
		},
	}


	info_DNSConfigError = GoTypeInfo{Name: "go.std.net/DNSConfigError",
		GoType: &GoType{T: &info_DNSConfigError},
		Ctor: _Wrapped_Ctor_DNSConfigError,
		Members: GoMembers{
		},
	}


	info_PtrTo_DNSConfigError = GoTypeInfo{Name: "go.std.net/refToDNSConfigError",
		GoType: &GoType{T: &info_PtrTo_DNSConfigError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_ptrTo_DNSConfigError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", _f_ptrTo_DNSConfigError_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", _f_ptrTo_DNSConfigError_Timeout, "", "1.0", NewVectorFrom()),
		},
	}


	info_ArrayOf_DNSConfigError = GoTypeInfo{Name: "go.std.net/arrayOfDNSConfigError",
		GoType: &GoType{T: &info_ArrayOf_DNSConfigError},
		Members: GoMembers{
		},
	}


	info_DNSError = GoTypeInfo{Name: "go.std.net/DNSError",
		GoType: &GoType{T: &info_DNSError},
		Ctor: _Wrapped_Ctor_DNSError,
		Members: GoMembers{
		},
	}


	info_PtrTo_DNSError = GoTypeInfo{Name: "go.std.net/refToDNSError",
		GoType: &GoType{T: &info_PtrTo_DNSError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_ptrTo_DNSError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", _f_ptrTo_DNSError_Temporary, "Temporary reports whether the DNS error is known to be temporary.\nThis is not always known; a DNS lookup may fail due to a temporary\nerror and return a DNSError for which Temporary returns false.\n", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", _f_ptrTo_DNSError_Timeout, "Timeout reports whether the DNS lookup is known to have timed out.\nThis is not always known; a DNS lookup may fail due to a timeout\nand return a DNSError for which Timeout returns false.\n", "1.0", NewVectorFrom()),
		},
	}


	info_ArrayOf_DNSError = GoTypeInfo{Name: "go.std.net/arrayOfDNSError",
		GoType: &GoType{T: &info_ArrayOf_DNSError},
		Members: GoMembers{
		},
	}


	info_Error = GoTypeInfo{Name: "go.std.net/Error",
		GoType: &GoType{T: &info_Error},
		Members: GoMembers{
			"Temporary": MakeGoReceiver("Temporary", _f_error_Temporary, "Is the error temporary?\n", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", _f_error_Timeout, "Is the error a timeout?\n", "1.0", NewVectorFrom()),
		},
	}


	info_IP = GoTypeInfo{Name: "go.std.net/IP",
		GoType: &GoType{T: &info_IP},
		Members: GoMembers{
			"DefaultMask": MakeGoReceiver("DefaultMask", _f_iP_DefaultMask, "DefaultMask returns the default IP mask for the IP address ip.\nOnly IPv4 addresses have default masks; DefaultMask returns\nnil if ip is not a valid IPv4 address.\n", "1.0", NewVectorFrom()),
			"Equal": MakeGoReceiver("Equal", _f_iP_Equal, "Equal reports whether ip and x are the same IP address.\nAn IPv4 address and that same address in IPv6 form are\nconsidered to be equal.\n", "1.0", NewVectorFrom(MakeSymbol("x"))),
			"IsGlobalUnicast": MakeGoReceiver("IsGlobalUnicast", _f_iP_IsGlobalUnicast, "IsGlobalUnicast reports whether ip is a global unicast\naddress.\n\nThe identification of global unicast addresses uses address type\nidentification as defined in RFC 1122, RFC 4632 and RFC 4291 with\nthe exception of IPv4 directed broadcast addresses.\nIt returns true even if ip is in IPv4 private address space or\nlocal IPv6 unicast address space.\n", "1.0", NewVectorFrom()),
			"IsInterfaceLocalMulticast": MakeGoReceiver("IsInterfaceLocalMulticast", _f_iP_IsInterfaceLocalMulticast, "IsInterfaceLocalMulticast reports whether ip is\nan interface-local multicast address.\n", "1.0", NewVectorFrom()),
			"IsLinkLocalMulticast": MakeGoReceiver("IsLinkLocalMulticast", _f_iP_IsLinkLocalMulticast, "IsLinkLocalMulticast reports whether ip is a link-local\nmulticast address.\n", "1.0", NewVectorFrom()),
			"IsLinkLocalUnicast": MakeGoReceiver("IsLinkLocalUnicast", _f_iP_IsLinkLocalUnicast, "IsLinkLocalUnicast reports whether ip is a link-local\nunicast address.\n", "1.0", NewVectorFrom()),
			"IsLoopback": MakeGoReceiver("IsLoopback", _f_iP_IsLoopback, "IsLoopback reports whether ip is a loopback address.\n", "1.0", NewVectorFrom()),
			"IsMulticast": MakeGoReceiver("IsMulticast", _f_iP_IsMulticast, "IsMulticast reports whether ip is a multicast address.\n", "1.0", NewVectorFrom()),
			"IsUnspecified": MakeGoReceiver("IsUnspecified", _f_iP_IsUnspecified, "IsUnspecified reports whether ip is an unspecified address, either\nthe IPv4 address \"0.0.0.0\" or the IPv6 address \"::\".\n", "1.0", NewVectorFrom()),
			"MarshalText": MakeGoReceiver("MarshalText", _f_iP_MarshalText, "MarshalText implements the encoding.TextMarshaler interface.\nThe encoding is the same as returned by String, with one exception:\nWhen len(ip) is zero, it returns an empty slice.\n", "1.0", NewVectorFrom()),
			"Mask": MakeGoReceiver("Mask", _f_iP_Mask, "Mask returns the result of masking the IP address ip with mask.\n", "1.0", NewVectorFrom(MakeSymbol("mask"))),
			"String": MakeGoReceiver("String", _f_iP_String, "String returns the string form of the IP address ip.\nIt returns one of 4 forms:\n  - \"<nil>\", if ip has length 0\n  - dotted decimal (\"192.0.2.1\"), if ip is an IPv4 or IP4-mapped IPv6 address\n  - IPv6 (\"2001:db8::1\"), if ip is a valid IPv6 address\n  - the hexadecimal form of ip, without punctuation, if no other cases apply\n", "1.0", NewVectorFrom()),
			"To16": MakeGoReceiver("To16", _f_iP_To16, "To16 converts the IP address ip to a 16-byte representation.\nIf ip is not an IP address (it is the wrong length), To16 returns nil.\n", "1.0", NewVectorFrom()),
			"To4": MakeGoReceiver("To4", _f_iP_To4, "To4 converts the IPv4 address ip to a 4-byte representation.\nIf ip is not an IPv4 address, To4 returns nil.\n", "1.0", NewVectorFrom()),
		},
	}


	info_PtrTo_IP = GoTypeInfo{Name: "go.std.net/refToIP",
		GoType: &GoType{T: &info_PtrTo_IP},
		Members: GoMembers{
			"UnmarshalText": MakeGoReceiver("UnmarshalText", _f_ptrTo_IP_UnmarshalText, "UnmarshalText implements the encoding.TextUnmarshaler interface.\nThe IP address is expected in a form accepted by ParseIP.\n", "1.0", NewVectorFrom(MakeSymbol("text"))),
		},
	}


	info_IPAddr = GoTypeInfo{Name: "go.std.net/IPAddr",
		GoType: &GoType{T: &info_IPAddr},
		Members: GoMembers{
		},
	}


	info_PtrTo_IPAddr = GoTypeInfo{Name: "go.std.net/refToIPAddr",
		GoType: &GoType{T: &info_PtrTo_IPAddr},
		Members: GoMembers{
			"Network": MakeGoReceiver("Network", _f_ptrTo_IPAddr_Network, "Network returns the address's network name, \"ip\".\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", _f_ptrTo_IPAddr_String, "", "1.0", NewVectorFrom()),
		},
	}


	info_ArrayOf_IPAddr = GoTypeInfo{Name: "go.std.net/arrayOfIPAddr",
		GoType: &GoType{T: &info_ArrayOf_IPAddr},
		Members: GoMembers{
		},
	}


	info_IPConn = GoTypeInfo{Name: "go.std.net/IPConn",
		GoType: &GoType{T: &info_IPConn},
		Ctor: _Wrapped_Ctor_IPConn,
		Members: GoMembers{
		},
	}


	info_PtrTo_IPConn = GoTypeInfo{Name: "go.std.net/refToIPConn",
		GoType: &GoType{T: &info_PtrTo_IPConn},
		Members: GoMembers{
			"ReadFrom": MakeGoReceiver("ReadFrom", _f_ptrTo_IPConn_ReadFrom, "ReadFrom implements the PacketConn ReadFrom method.\n", "1.0", NewVectorFrom(MakeSymbol("b"))),
			"ReadFromIP": MakeGoReceiver("ReadFromIP", _f_ptrTo_IPConn_ReadFromIP, "ReadFromIP acts like ReadFrom but returns an IPAddr.\n", "1.0", NewVectorFrom(MakeSymbol("b"))),
			"ReadMsgIP": MakeGoReceiver("ReadMsgIP", _f_ptrTo_IPConn_ReadMsgIP, "ReadMsgIP reads a message from c, copying the payload into b and\nthe associated out-of-band data into oob. It returns the number of\nbytes copied into b, the number of bytes copied into oob, the flags\nthat were set on the message and the source address of the message.\n\nThe packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be\nused to manipulate IP-level socket options in oob.\n", "1.0", NewVectorFrom(MakeSymbol("b"), MakeSymbol("oob"))),
			"WriteMsgIP": MakeGoReceiver("WriteMsgIP", _f_ptrTo_IPConn_WriteMsgIP, "WriteMsgIP writes a message to addr via c, copying the payload from\nb and the associated out-of-band data from oob. It returns the\nnumber of payload and out-of-band bytes written.\n\nThe packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be\nused to manipulate IP-level socket options in oob.\n", "1.0", NewVectorFrom(MakeSymbol("b"), MakeSymbol("oob"), MakeSymbol("addr"))),
			"WriteTo": MakeGoReceiver("WriteTo", _f_ptrTo_IPConn_WriteTo, "WriteTo implements the PacketConn WriteTo method.\n", "1.0", NewVectorFrom(MakeSymbol("b"), MakeSymbol("addr"))),
			"WriteToIP": MakeGoReceiver("WriteToIP", _f_ptrTo_IPConn_WriteToIP, "WriteToIP acts like WriteTo but takes an IPAddr.\n", "1.0", NewVectorFrom(MakeSymbol("b"), MakeSymbol("addr"))),
		},
	}


	info_ArrayOf_IPConn = GoTypeInfo{Name: "go.std.net/arrayOfIPConn",
		GoType: &GoType{T: &info_ArrayOf_IPConn},
		Members: GoMembers{
		},
	}


	info_IPMask = GoTypeInfo{Name: "go.std.net/IPMask",
		GoType: &GoType{T: &info_IPMask},
		Members: GoMembers{
			"Size": MakeGoReceiver("Size", _f_iPMask_Size, "Size returns the number of leading ones and total bits in the mask.\nIf the mask is not in the canonical form--ones followed by zeros--then\nSize returns 0, 0.\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", _f_iPMask_String, "String returns the hexadecimal form of m, with no punctuation.\n", "1.0", NewVectorFrom()),
		},
	}


	info_PtrTo_IPMask = GoTypeInfo{Name: "go.std.net/refToIPMask",
		GoType: &GoType{T: &info_PtrTo_IPMask},
		Members: GoMembers{
		},
	}


	info_ArrayOf_IPMask = GoTypeInfo{Name: "go.std.net/arrayOfIPMask",
		GoType: &GoType{T: &info_ArrayOf_IPMask},
		Members: GoMembers{
		},
	}


	info_IPNet = GoTypeInfo{Name: "go.std.net/IPNet",
		GoType: &GoType{T: &info_IPNet},
		Members: GoMembers{
		},
	}


	info_PtrTo_IPNet = GoTypeInfo{Name: "go.std.net/refToIPNet",
		GoType: &GoType{T: &info_PtrTo_IPNet},
		Members: GoMembers{
			"Contains": MakeGoReceiver("Contains", _f_ptrTo_IPNet_Contains, "Contains reports whether the network includes ip.\n", "1.0", NewVectorFrom(MakeSymbol("ip"))),
			"Network": MakeGoReceiver("Network", _f_ptrTo_IPNet_Network, "Network returns the address's network name, \"ip+net\".\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", _f_ptrTo_IPNet_String, "String returns the CIDR notation of n like \"192.0.2.1/24\"\nor \"2001:db8::/48\" as defined in RFC 4632 and RFC 4291.\nIf the mask is not in the canonical form, it returns the\nstring which consists of an IP address, followed by a slash\ncharacter and a mask expressed as hexadecimal form with no\npunctuation like \"198.51.100.1/c000ff00\".\n", "1.0", NewVectorFrom()),
		},
	}


	info_ArrayOf_IPNet = GoTypeInfo{Name: "go.std.net/arrayOfIPNet",
		GoType: &GoType{T: &info_ArrayOf_IPNet},
		Members: GoMembers{
		},
	}


	info_ArrayOf_IP = GoTypeInfo{Name: "go.std.net/arrayOfIP",
		GoType: &GoType{T: &info_ArrayOf_IP},
		Members: GoMembers{
		},
	}


	info_InvalidAddrError = GoTypeInfo{Name: "go.std.net/InvalidAddrError",
		GoType: &GoType{T: &info_InvalidAddrError},
		Ctor: _Wrapped_Ctor_InvalidAddrError,
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_invalidAddrError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", _f_invalidAddrError_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", _f_invalidAddrError_Timeout, "", "1.0", NewVectorFrom()),
		},
	}


	info_PtrTo_InvalidAddrError = GoTypeInfo{Name: "go.std.net/refToInvalidAddrError",
		GoType: &GoType{T: &info_PtrTo_InvalidAddrError},
		Members: GoMembers{
		},
	}


	info_ArrayOf_InvalidAddrError = GoTypeInfo{Name: "go.std.net/arrayOfInvalidAddrError",
		GoType: &GoType{T: &info_ArrayOf_InvalidAddrError},
		Members: GoMembers{
		},
	}


	info_Listener = GoTypeInfo{Name: "go.std.net/Listener",
		GoType: &GoType{T: &info_Listener},
		Members: GoMembers{
			"Accept": MakeGoReceiver("Accept", _f_listener_Accept, "Accept waits for and returns the next connection to the listener.\n", "1.0", NewVectorFrom()),
			"Addr": MakeGoReceiver("Addr", _f_listener_Addr, "Addr returns the listener's network address.\n", "1.0", NewVectorFrom()),
			"Close": MakeGoReceiver("Close", _f_listener_Close, "Close closes the listener.\nAny blocked Accept operations will be unblocked and return errors.\n", "1.0", NewVectorFrom()),
		},
	}


	info_MX = GoTypeInfo{Name: "go.std.net/MX",
		GoType: &GoType{T: &info_MX},
		Ctor: _Wrapped_Ctor_MX,
		Members: GoMembers{
		},
	}


	info_PtrTo_MX = GoTypeInfo{Name: "go.std.net/refToMX",
		GoType: &GoType{T: &info_PtrTo_MX},
		Members: GoMembers{
		},
	}


	info_ArrayOf_MX = GoTypeInfo{Name: "go.std.net/arrayOfMX",
		GoType: &GoType{T: &info_ArrayOf_MX},
		Members: GoMembers{
		},
	}


	info_NS = GoTypeInfo{Name: "go.std.net/NS",
		GoType: &GoType{T: &info_NS},
		Ctor: _Wrapped_Ctor_NS,
		Members: GoMembers{
		},
	}


	info_PtrTo_NS = GoTypeInfo{Name: "go.std.net/refToNS",
		GoType: &GoType{T: &info_PtrTo_NS},
		Members: GoMembers{
		},
	}


	info_ArrayOf_NS = GoTypeInfo{Name: "go.std.net/arrayOfNS",
		GoType: &GoType{T: &info_ArrayOf_NS},
		Members: GoMembers{
		},
	}


	info_OpError = GoTypeInfo{Name: "go.std.net/OpError",
		GoType: &GoType{T: &info_OpError},
		Members: GoMembers{
		},
	}


	info_PtrTo_OpError = GoTypeInfo{Name: "go.std.net/refToOpError",
		GoType: &GoType{T: &info_PtrTo_OpError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_ptrTo_OpError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", _f_ptrTo_OpError_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", _f_ptrTo_OpError_Timeout, "", "1.0", NewVectorFrom()),
		},
	}


	info_ArrayOf_OpError = GoTypeInfo{Name: "go.std.net/arrayOfOpError",
		GoType: &GoType{T: &info_ArrayOf_OpError},
		Members: GoMembers{
		},
	}


	info_PacketConn = GoTypeInfo{Name: "go.std.net/PacketConn",
		GoType: &GoType{T: &info_PacketConn},
		Members: GoMembers{
			"Close": MakeGoReceiver("Close", _f_packetConn_Close, "Close closes the connection.\nAny blocked ReadFrom or WriteTo operations will be unblocked and return errors.\n", "1.0", NewVectorFrom()),
			"LocalAddr": MakeGoReceiver("LocalAddr", _f_packetConn_LocalAddr, "LocalAddr returns the local network address.\n", "1.0", NewVectorFrom()),
			"ReadFrom": MakeGoReceiver("ReadFrom", _f_packetConn_ReadFrom, "ReadFrom reads a packet from the connection,\ncopying the payload into p. It returns the number of\nbytes copied into p and the return address that\nwas on the packet.\nIt returns the number of bytes read (0 <= n <= len(p))\nand any error encountered. Callers should always process\nthe n > 0 bytes returned before considering the error err.\nReadFrom can be made to time out and return\nan Error with Timeout() == true after a fixed time limit;\nsee SetDeadline and SetReadDeadline.\n", "1.0", NewVectorFrom(MakeSymbol("p"))),
			"WriteTo": MakeGoReceiver("WriteTo", _f_packetConn_WriteTo, "WriteTo writes a packet with payload p to addr.\nWriteTo can be made to time out and return\nan Error with Timeout() == true after a fixed time limit;\nsee SetDeadline and SetWriteDeadline.\nOn packet-oriented connections, write timeouts are rare.\n", "1.0", NewVectorFrom(MakeSymbol("p"), MakeSymbol("addr"))),
		},
	}


	info_ParseError = GoTypeInfo{Name: "go.std.net/ParseError",
		GoType: &GoType{T: &info_ParseError},
		Ctor: _Wrapped_Ctor_ParseError,
		Members: GoMembers{
		},
	}


	info_PtrTo_ParseError = GoTypeInfo{Name: "go.std.net/refToParseError",
		GoType: &GoType{T: &info_PtrTo_ParseError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_ptrTo_ParseError_Error, "", "1.0", NewVectorFrom()),
		},
	}


	info_ArrayOf_ParseError = GoTypeInfo{Name: "go.std.net/arrayOfParseError",
		GoType: &GoType{T: &info_ArrayOf_ParseError},
		Members: GoMembers{
		},
	}


	info_Resolver = GoTypeInfo{Name: "go.std.net/Resolver",
		GoType: &GoType{T: &info_Resolver},
		Members: GoMembers{
		},
	}


	info_PtrTo_Resolver = GoTypeInfo{Name: "go.std.net/refToResolver",
		GoType: &GoType{T: &info_PtrTo_Resolver},
		Members: GoMembers{
		},
	}


	info_ArrayOf_Resolver = GoTypeInfo{Name: "go.std.net/arrayOfResolver",
		GoType: &GoType{T: &info_ArrayOf_Resolver},
		Members: GoMembers{
		},
	}


	info_SRV = GoTypeInfo{Name: "go.std.net/SRV",
		GoType: &GoType{T: &info_SRV},
		Ctor: _Wrapped_Ctor_SRV,
		Members: GoMembers{
		},
	}


	info_PtrTo_SRV = GoTypeInfo{Name: "go.std.net/refToSRV",
		GoType: &GoType{T: &info_PtrTo_SRV},
		Members: GoMembers{
		},
	}


	info_ArrayOf_SRV = GoTypeInfo{Name: "go.std.net/arrayOfSRV",
		GoType: &GoType{T: &info_ArrayOf_SRV},
		Members: GoMembers{
		},
	}


	info_UnknownNetworkError = GoTypeInfo{Name: "go.std.net/UnknownNetworkError",
		GoType: &GoType{T: &info_UnknownNetworkError},
		Ctor: _Wrapped_Ctor_UnknownNetworkError,
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_unknownNetworkError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", _f_unknownNetworkError_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", _f_unknownNetworkError_Timeout, "", "1.0", NewVectorFrom()),
		},
	}


	info_PtrTo_UnknownNetworkError = GoTypeInfo{Name: "go.std.net/refToUnknownNetworkError",
		GoType: &GoType{T: &info_PtrTo_UnknownNetworkError},
		Members: GoMembers{
		},
	}


	info_ArrayOf_UnknownNetworkError = GoTypeInfo{Name: "go.std.net/arrayOfUnknownNetworkError",
		GoType: &GoType{T: &info_ArrayOf_UnknownNetworkError},
		Members: GoMembers{
		},
	}


	GoTypesVec[78] = &info_Addr

	GoTypesVec[51] = &info_AddrError

	GoTypesVec[0] = &info_PtrTo_AddrError

	GoTypesVec[27] = &info_ArrayOf_AddrError

	GoTypesVec[52] = &info_Buffers

	GoTypesVec[1] = &info_PtrTo_Buffers

	GoTypesVec[28] = &info_ArrayOf_Buffers

	GoTypesVec[74] = &info_Conn

	GoTypesVec[53] = &info_DNSConfigError

	GoTypesVec[2] = &info_PtrTo_DNSConfigError

	GoTypesVec[29] = &info_ArrayOf_DNSConfigError

	GoTypesVec[54] = &info_DNSError

	GoTypesVec[3] = &info_PtrTo_DNSError

	GoTypesVec[30] = &info_ArrayOf_DNSError

	GoTypesVec[76] = &info_Error

	GoTypesVec[55] = &info_IP

	GoTypesVec[4] = &info_PtrTo_IP

	GoTypesVec[56] = &info_IPAddr

	GoTypesVec[5] = &info_PtrTo_IPAddr

	GoTypesVec[32] = &info_ArrayOf_IPAddr

	GoTypesVec[57] = &info_IPConn

	GoTypesVec[6] = &info_PtrTo_IPConn

	GoTypesVec[33] = &info_ArrayOf_IPConn

	GoTypesVec[58] = &info_IPMask

	GoTypesVec[7] = &info_PtrTo_IPMask

	GoTypesVec[34] = &info_ArrayOf_IPMask

	GoTypesVec[59] = &info_IPNet

	GoTypesVec[8] = &info_PtrTo_IPNet

	GoTypesVec[35] = &info_ArrayOf_IPNet

	GoTypesVec[31] = &info_ArrayOf_IP

	GoTypesVec[60] = &info_InvalidAddrError

	GoTypesVec[9] = &info_PtrTo_InvalidAddrError

	GoTypesVec[36] = &info_ArrayOf_InvalidAddrError

	GoTypesVec[77] = &info_Listener

	GoTypesVec[61] = &info_MX

	GoTypesVec[10] = &info_PtrTo_MX

	GoTypesVec[37] = &info_ArrayOf_MX

	GoTypesVec[62] = &info_NS

	GoTypesVec[11] = &info_PtrTo_NS

	GoTypesVec[38] = &info_ArrayOf_NS

	GoTypesVec[63] = &info_OpError

	GoTypesVec[12] = &info_PtrTo_OpError

	GoTypesVec[39] = &info_ArrayOf_OpError

	GoTypesVec[75] = &info_PacketConn

	GoTypesVec[64] = &info_ParseError

	GoTypesVec[13] = &info_PtrTo_ParseError

	GoTypesVec[40] = &info_ArrayOf_ParseError

	GoTypesVec[65] = &info_Resolver

	GoTypesVec[14] = &info_PtrTo_Resolver

	GoTypesVec[41] = &info_ArrayOf_Resolver

	GoTypesVec[66] = &info_SRV

	GoTypesVec[15] = &info_PtrTo_SRV

	GoTypesVec[42] = &info_ArrayOf_SRV

	GoTypesVec[67] = &info_UnknownNetworkError

	GoTypesVec[16] = &info_PtrTo_UnknownNetworkError

	GoTypesVec[43] = &info_ArrayOf_UnknownNetworkError

	EnsureLoaded("go.std.context")  // E.g. from: _tests/small/src/net/iprawsock.go:8:2
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/small/src/net/net.go:83:2
	EnsureLoaded("go.std.golang_org.x.net.dns.dnsmessage")  // E.g. from: _tests/small/src/net/dnsclient.go:11:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/small/src/net/net.go:85:2
	EnsureLoaded("go.std.math.rand")  // E.g. from: _tests/small/src/net/dnsclient.go:8:2
	EnsureLoaded("go.std.os")  // E.g. from: _tests/small/src/net/net.go:86:2
	EnsureLoaded("go.std.sort")  // E.g. from: _tests/small/src/net/dnsclient.go:9:2
	EnsureLoaded("go.std.sync")  // E.g. from: _tests/small/src/net/lookup.go:11:2
	EnsureLoaded("go.std.syscall")  // E.g. from: _tests/small/src/net/iprawsock.go:9:2
	EnsureLoaded("go.std.time")  // E.g. from: _tests/small/src/net/net.go:89:2

}

// Auto-generated by gostd at (omitted for testing)

package url

import (
	. "github.com/candid82/joker/core"
	"net/url"
)

func Extract_ns_arrayOfError(args []Object, index int) []url.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []url.Error:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/url.Error]"))
}

func Extract_ns_arrayOfEscapeError(args []Object, index int) []url.EscapeError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []url.EscapeError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/url.EscapeError]"))
}

func Extract_ns_arrayOfInvalidHostError(args []Object, index int) []url.InvalidHostError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []url.InvalidHostError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/url.InvalidHostError]"))
}

func Extract_ns_arrayOfURL(args []Object, index int) []url.URL {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []url.URL:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/url.URL]"))
}

func Extract_ns_arrayOfUserinfo(args []Object, index int) []url.Userinfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []url.Userinfo:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/url.Userinfo]"))
}

func Extract_ns_arrayOfValues(args []Object, index int) []url.Values {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []url.Values:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/url.Values]"))
}

func Extract_ns_Error(args []Object, index int) *url.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.Error:
			return r
		case url.Error:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Error]"))
}

func _mapToError(o Map) *url.Error {
	return &url.Error{
		Op: FieldAsString(o, "Op"),
		URL: FieldAsString(o, "URL"),
		Err: FieldAsError(o, "Err"),
	}
}

func _Ctor_Error(_v Object) *url.Error {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToError(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Error] or: Map"))
}

func _Wrapped_Ctor_Error(_o Object) Object {
	return MakeGoObject(_Ctor_Error(_o))
}

func Extract_ns_refToError(args []Object, index int) *url.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.Error:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/url.Error]"))
}

func Extract_ns_EscapeError(args []Object, index int) *url.EscapeError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.EscapeError:
			return r
		case url.EscapeError:
			return &r  // refTo
		}
	case String:
		v := url.EscapeError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.EscapeError]"))
}

func _Ctor_EscapeError(_v Object) url.EscapeError {
	switch _o := _v.(type) {
	case String:
		return url.EscapeError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.EscapeError] or: String"))
}

func _Wrapped_Ctor_EscapeError(_o Object) Object {
	return MakeGoObject(_Ctor_EscapeError(_o))
}

func Extract_ns_refToEscapeError(args []Object, index int) *url.EscapeError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.EscapeError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/url.EscapeError]"))
}

func Extract_ns_InvalidHostError(args []Object, index int) *url.InvalidHostError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.InvalidHostError:
			return r
		case url.InvalidHostError:
			return &r  // refTo
		}
	case String:
		v := url.InvalidHostError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.InvalidHostError]"))
}

func _Ctor_InvalidHostError(_v Object) url.InvalidHostError {
	switch _o := _v.(type) {
	case String:
		return url.InvalidHostError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.InvalidHostError] or: String"))
}

func _Wrapped_Ctor_InvalidHostError(_o Object) Object {
	return MakeGoObject(_Ctor_InvalidHostError(_o))
}

func Extract_ns_refToInvalidHostError(args []Object, index int) *url.InvalidHostError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.InvalidHostError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/url.InvalidHostError]"))
}

func Extract_ns_URL(args []Object, index int) *url.URL {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.URL:
			return r
		case url.URL:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.URL]"))
}

// func _mapToURL(o Map) *url.URL {
// 	return &url.URL{
// 		Scheme: FieldAsString(o, "Scheme"),
// 		Opaque: FieldAsString(o, "Opaque"),
// 		User: ABEND048(codegen.go: no conversion from Clojure for *net/url.Userinfo (net/url.Userinfo)),
// 		Host: FieldAsString(o, "Host"),
// 		Path: FieldAsString(o, "Path"),
// 		RawPath: FieldAsString(o, "RawPath"),
// 		ForceQuery: FieldAsBoolean(o, "ForceQuery"),
// 		RawQuery: FieldAsString(o, "RawQuery"),
// 		Fragment: FieldAsString(o, "Fragment"),
// 	}
// }

// func _Ctor_URL(_v Object) *url.URL {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToURL(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[url.URL] or: Map"))
// }

// func _Wrapped_Ctor_URL(_o Object) Object {
// 	return MakeGoObject(_Ctor_URL(_o))
// }

func Extract_ns_refToURL(args []Object, index int) *url.URL {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.URL:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/url.URL]"))
}

func Extract_ns_Userinfo(args []Object, index int) *url.Userinfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.Userinfo:
			return r
		case url.Userinfo:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Userinfo]"))
}

func _mapToUserinfo(o Map) *url.Userinfo {
	return &url.Userinfo{}
}

func _Ctor_Userinfo(_v Object) *url.Userinfo {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToUserinfo(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Userinfo] or: Map"))
}

func _Wrapped_Ctor_Userinfo(_o Object) Object {
	return MakeGoObject(_Ctor_Userinfo(_o))
}

func Extract_ns_refToUserinfo(args []Object, index int) *url.Userinfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.Userinfo:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/url.Userinfo]"))
}

func Extract_ns_Values(args []Object, index int) *url.Values {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.Values:
			return r
		case url.Values:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Values]"))
}

// func _Ctor_Values(_v Object) url.Values {
// 	switch _o := _v.(type) {
// 	default:
// 		return _url.Values(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for Values))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Values] or: whatever"))
// }

// func _Wrapped_Ctor_Values(_o Object) Object {
// 	return MakeGoObject(_Ctor_Values(_o))
// }

func Extract_ns_refToValues(args []Object, index int) *url.Values {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.Values:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/url.Values]"))
}

func _f_parse(_v_rawurl string) Object {
	_res1, _res2 := url.Parse(_v_rawurl)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func _f_parseQuery(_v_query string) Object {
	_res1, _res2 := url.ParseQuery(_v_query)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func _f_parseRequestURI(_v_rawurl string) Object {
	_res1, _res2 := url.ParseRequestURI(_v_rawurl)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func _f_pathUnescape(_v_s string) Object {
	_res1, _res2 := url.PathUnescape(_v_s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func _f_queryUnescape(_v_s string) Object {
	_res1, _res2 := url.QueryUnescape(_v_s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func _f_user(_v_username string) Object {
	_res := url.User(_v_username)
	return MakeGoObject(_res)
}

func _f_userPassword(_v_username string, _v_password string) Object {
	_res := url.UserPassword(_v_username, _v_password)
	return MakeGoObject(_res)
}

func _f_escapeError_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(url.EscapeError)Error()", args, 0, 0)
	_res := o.O.(url.EscapeError).Error()
	return MakeString(_res)
}

func _f_invalidHostError_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(url.InvalidHostError)Error()", args, 0, 0)
	_res := o.O.(url.InvalidHostError).Error()
	return MakeString(_res)
}

func _f_ptrTo_Error_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.Error)Error()", args, 0, 0)
	_res := o.O.(*url.Error).Error()
	return MakeString(_res)
}

func _f_ptrTo_Error_Temporary(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.Error)Temporary()", args, 0, 0)
	_res := o.O.(*url.Error).Temporary()
	return MakeBoolean(_res)
}

func _f_ptrTo_Error_Timeout(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.Error)Timeout()", args, 0, 0)
	_res := o.O.(*url.Error).Timeout()
	return MakeBoolean(_res)
}

func _f_ptrTo_URL_EscapedPath(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.URL)EscapedPath()", args, 0, 0)
	_res := o.O.(*url.URL).EscapedPath()
	return MakeString(_res)
}

func _f_ptrTo_URL_Hostname(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.URL)Hostname()", args, 0, 0)
	_res := o.O.(*url.URL).Hostname()
	return MakeString(_res)
}

func _f_ptrTo_URL_IsAbs(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.URL)IsAbs()", args, 0, 0)
	_res := o.O.(*url.URL).IsAbs()
	return MakeBoolean(_res)
}

func _f_ptrTo_URL_MarshalBinary(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.URL)MarshalBinary()", args, 0, 0)
	text, err := o.O.(*url.URL).MarshalBinary()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(text))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

func _f_ptrTo_URL_Parse(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*url.URL)Parse()", args, 1, 1)
	_v_ref := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_ref): %s")
	_res1, _res2 := o.O.(*url.URL).Parse(_v_ref)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func _f_ptrTo_URL_Port(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.URL)Port()", args, 0, 0)
	_res := o.O.(*url.URL).Port()
	return MakeString(_res)
}

func _f_ptrTo_URL_Query(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.URL)Query()", args, 0, 0)
	_res := o.O.(*url.URL).Query()
	return MakeGoObject(_res)
}

func _f_ptrTo_URL_RequestURI(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.URL)RequestURI()", args, 0, 0)
	_res := o.O.(*url.URL).RequestURI()
	return MakeString(_res)
}

func _f_ptrTo_URL_ResolveReference(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*url.URL)ResolveReference()", args, 1, 1)
	_v_ref := SeqNth(_argList, 0).(GoObject).O.(*url.URL)
	_res := o.O.(*url.URL).ResolveReference(_v_ref)
	return MakeGoObject(_res)
}

func _f_ptrTo_URL_String(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.URL)String()", args, 0, 0)
	_res := o.O.(*url.URL).String()
	return MakeString(_res)
}

func _f_ptrTo_URL_UnmarshalBinary(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*url.URL)UnmarshalBinary()", args, 1, 1)
	_v_text := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_res := o.O.(*url.URL).UnmarshalBinary(_v_text)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

func _f_ptrTo_Userinfo_Password(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.Userinfo)Password()", args, 0, 0)
	_res1, _res2 := o.O.(*url.Userinfo).Password()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(MakeBoolean(_res2))
	return _res
}

func _f_ptrTo_Userinfo_String(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.Userinfo)String()", args, 0, 0)
	_res := o.O.(*url.Userinfo).String()
	return MakeString(_res)
}

func _f_ptrTo_Userinfo_Username(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.Userinfo)Username()", args, 0, 0)
	_res := o.O.(*url.Userinfo).Username()
	return MakeString(_res)
}

// func _f_values_Add(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

// func _f_values_Del(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

func _f_values_Encode(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(url.Values)Encode()", args, 0, 0)
	_res := o.O.(url.Values).Encode()
	return MakeString(_res)
}

func _f_values_Get(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(url.Values)Get()", args, 1, 1)
	_v_key := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_key): %s")
	_res := o.O.(url.Values).Get(_v_key)
	return MakeString(_res)
}

// func _f_values_Set(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }
var info_Error GoTypeInfo

var info_PtrTo_Error GoTypeInfo

var info_ArrayOf_Error GoTypeInfo

var info_EscapeError GoTypeInfo

var info_PtrTo_EscapeError GoTypeInfo

var info_ArrayOf_EscapeError GoTypeInfo

var info_InvalidHostError GoTypeInfo

var info_PtrTo_InvalidHostError GoTypeInfo

var info_ArrayOf_InvalidHostError GoTypeInfo

var info_URL GoTypeInfo

var info_PtrTo_URL GoTypeInfo

var info_ArrayOf_URL GoTypeInfo

var info_Userinfo GoTypeInfo

var info_PtrTo_Userinfo GoTypeInfo

var info_ArrayOf_Userinfo GoTypeInfo

var info_Values GoTypeInfo

var info_PtrTo_Values GoTypeInfo

var info_ArrayOf_Values GoTypeInfo


func initNative() {
	info_Error = GoTypeInfo{Name: "go.std.net.url/Error",
		GoType: &GoType{T: &info_Error},
		Ctor: _Wrapped_Ctor_Error,
		Members: GoMembers{
		},
	}


	info_PtrTo_Error = GoTypeInfo{Name: "go.std.net.url/refToError",
		GoType: &GoType{T: &info_PtrTo_Error},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_ptrTo_Error_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", _f_ptrTo_Error_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", _f_ptrTo_Error_Timeout, "", "1.0", NewVectorFrom()),
		},
	}


	info_ArrayOf_Error = GoTypeInfo{Name: "go.std.net.url/arrayOfError",
		GoType: &GoType{T: &info_ArrayOf_Error},
		Members: GoMembers{
		},
	}


	info_EscapeError = GoTypeInfo{Name: "go.std.net.url/EscapeError",
		GoType: &GoType{T: &info_EscapeError},
		Ctor: _Wrapped_Ctor_EscapeError,
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_escapeError_Error, "", "1.0", NewVectorFrom()),
		},
	}


	info_PtrTo_EscapeError = GoTypeInfo{Name: "go.std.net.url/refToEscapeError",
		GoType: &GoType{T: &info_PtrTo_EscapeError},
		Members: GoMembers{
		},
	}


	info_ArrayOf_EscapeError = GoTypeInfo{Name: "go.std.net.url/arrayOfEscapeError",
		GoType: &GoType{T: &info_ArrayOf_EscapeError},
		Members: GoMembers{
		},
	}


	info_InvalidHostError = GoTypeInfo{Name: "go.std.net.url/InvalidHostError",
		GoType: &GoType{T: &info_InvalidHostError},
		Ctor: _Wrapped_Ctor_InvalidHostError,
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_invalidHostError_Error, "", "1.0", NewVectorFrom()),
		},
	}


	info_PtrTo_InvalidHostError = GoTypeInfo{Name: "go.std.net.url/refToInvalidHostError",
		GoType: &GoType{T: &info_PtrTo_InvalidHostError},
		Members: GoMembers{
		},
	}


	info_ArrayOf_InvalidHostError = GoTypeInfo{Name: "go.std.net.url/arrayOfInvalidHostError",
		GoType: &GoType{T: &info_ArrayOf_InvalidHostError},
		Members: GoMembers{
		},
	}


	info_URL = GoTypeInfo{Name: "go.std.net.url/URL",
		GoType: &GoType{T: &info_URL},
		Members: GoMembers{
		},
	}


	info_PtrTo_URL = GoTypeInfo{Name: "go.std.net.url/refToURL",
		GoType: &GoType{T: &info_PtrTo_URL},
		Members: GoMembers{
			"EscapedPath": MakeGoReceiver("EscapedPath", _f_ptrTo_URL_EscapedPath, "EscapedPath returns the escaped form of u.Path.\nIn general there are multiple possible escaped forms of any path.\nEscapedPath returns u.RawPath when it is a valid escaping of u.Path.\nOtherwise EscapedPath ignores u.RawPath and computes an escaped\nform on its own.\nThe String and RequestURI methods use EscapedPath to construct\ntheir results.\nIn general, code should call EscapedPath instead of\nreading u.RawPath directly.\n", "1.0", NewVectorFrom()),
			"Hostname": MakeGoReceiver("Hostname", _f_ptrTo_URL_Hostname, "Hostname returns u.Host, without any port number.\n\nIf Host is an IPv6 literal with a port number, Hostname returns the\nIPv6 literal without the square brackets. IPv6 literals may include\na zone identifier.\n", "1.0", NewVectorFrom()),
			"IsAbs": MakeGoReceiver("IsAbs", _f_ptrTo_URL_IsAbs, "IsAbs reports whether the URL is absolute.\nAbsolute means that it has a non-empty scheme.\n", "1.0", NewVectorFrom()),
			"MarshalBinary": MakeGoReceiver("MarshalBinary", _f_ptrTo_URL_MarshalBinary, "", "1.0", NewVectorFrom()),
			"Parse": MakeGoReceiver("Parse", _f_ptrTo_URL_Parse, "Parse parses a URL in the context of the receiver. The provided URL\nmay be relative or absolute. Parse returns nil, err on parse\nfailure, otherwise its return value is the same as ResolveReference.\n", "1.0", NewVectorFrom(MakeSymbol("ref"))),
			"Port": MakeGoReceiver("Port", _f_ptrTo_URL_Port, "Port returns the port part of u.Host, without the leading colon.\nIf u.Host doesn't contain a port, Port returns an empty string.\n", "1.0", NewVectorFrom()),
			"Query": MakeGoReceiver("Query", _f_ptrTo_URL_Query, "Query parses RawQuery and returns the corresponding values.\nIt silently discards malformed value pairs.\nTo check errors use ParseQuery.\n", "1.0", NewVectorFrom()),
			"RequestURI": MakeGoReceiver("RequestURI", _f_ptrTo_URL_RequestURI, "RequestURI returns the encoded path?query or opaque?query\nstring that would be used in an HTTP request for u.\n", "1.0", NewVectorFrom()),
			"ResolveReference": MakeGoReceiver("ResolveReference", _f_ptrTo_URL_ResolveReference, "ResolveReference resolves a URI reference to an absolute URI from\nan absolute base URI u, per RFC 3986 Section 5.2. The URI reference\nmay be relative or absolute. ResolveReference always returns a new\nURL instance, even if the returned URL is identical to either the\nbase or reference. If ref is an absolute URL, then ResolveReference\nignores base and returns a copy of ref.\n", "1.0", NewVectorFrom(MakeSymbol("ref"))),
			"String": MakeGoReceiver("String", _f_ptrTo_URL_String, "String reassembles the URL into a valid URL string.\nThe general form of the result is one of:\n\n\tscheme:opaque?query#fragment\n\tscheme://userinfo@host/path?query#fragment\n\nIf u.Opaque is non-empty, String uses the first form;\notherwise it uses the second form.\nTo obtain the path, String uses u.EscapedPath().\n\nIn the second form, the following rules apply:\n\t- if u.Scheme is empty, scheme: is omitted.\n\t- if u.User is nil, userinfo@ is omitted.\n\t- if u.Host is empty, host/ is omitted.\n\t- if u.Scheme and u.Host are empty and u.User is nil,\n\t   the entire scheme://userinfo@host/ is omitted.\n\t- if u.Host is non-empty and u.Path begins with a /,\n\t   the form host/path does not add its own /.\n\t- if u.RawQuery is empty, ?query is omitted.\n\t- if u.Fragment is empty, #fragment is omitted.\n", "1.0", NewVectorFrom()),
			"UnmarshalBinary": MakeGoReceiver("UnmarshalBinary", _f_ptrTo_URL_UnmarshalBinary, "", "1.0", NewVectorFrom(MakeSymbol("text"))),
		},
	}


	info_ArrayOf_URL = GoTypeInfo{Name: "go.std.net.url/arrayOfURL",
		GoType: &GoType{T: &info_ArrayOf_URL},
		Members: GoMembers{
		},
	}


	info_Userinfo = GoTypeInfo{Name: "go.std.net.url/Userinfo",
		GoType: &GoType{T: &info_Userinfo},
		Ctor: _Wrapped_Ctor_Userinfo,
		Members: GoMembers{
		},
	}


	info_PtrTo_Userinfo = GoTypeInfo{Name: "go.std.net.url/refToUserinfo",
		GoType: &GoType{T: &info_PtrTo_Userinfo},
		Members: GoMembers{
			"Password": MakeGoReceiver("Password", _f_ptrTo_Userinfo_Password, "Password returns the password in case it is set, and whether it is set.\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", _f_ptrTo_Userinfo_String, "String returns the encoded userinfo information in the standard form\nof \"username[:password]\".\n", "1.0", NewVectorFrom()),
			"Username": MakeGoReceiver("Username", _f_ptrTo_Userinfo_Username, "Username returns the username.\n", "1.0", NewVectorFrom()),
		},
	}


	info_ArrayOf_Userinfo = GoTypeInfo{Name: "go.std.net.url/arrayOfUserinfo",
		GoType: &GoType{T: &info_ArrayOf_Userinfo},
		Members: GoMembers{
		},
	}


	info_Values = GoTypeInfo{Name: "go.std.net.url/Values",
		GoType: &GoType{T: &info_Values},
		Members: GoMembers{
			"Encode": MakeGoReceiver("Encode", _f_values_Encode, "Encode encodes the values into ``URL encoded'' form\n(\"bar=baz&foo=quux\") sorted by key.\n", "1.0", NewVectorFrom()),
			"Get": MakeGoReceiver("Get", _f_values_Get, "Get gets the first value associated with the given key.\nIf there are no values associated with the key, Get returns\nthe empty string. To access multiple values, use the map\ndirectly.\n", "1.0", NewVectorFrom(MakeSymbol("key"))),
		},
	}


	info_PtrTo_Values = GoTypeInfo{Name: "go.std.net.url/refToValues",
		GoType: &GoType{T: &info_PtrTo_Values},
		Members: GoMembers{
		},
	}


	info_ArrayOf_Values = GoTypeInfo{Name: "go.std.net.url/arrayOfValues",
		GoType: &GoType{T: &info_ArrayOf_Values},
		Members: GoMembers{
		},
	}


	GoTypesVec[68] = &info_Error

	GoTypesVec[17] = &info_PtrTo_Error

	GoTypesVec[44] = &info_ArrayOf_Error

	GoTypesVec[69] = &info_EscapeError

	GoTypesVec[18] = &info_PtrTo_EscapeError

	GoTypesVec[45] = &info_ArrayOf_EscapeError

	GoTypesVec[70] = &info_InvalidHostError

	GoTypesVec[19] = &info_PtrTo_InvalidHostError

	GoTypesVec[46] = &info_ArrayOf_InvalidHostError

	GoTypesVec[71] = &info_URL

	GoTypesVec[20] = &info_PtrTo_URL

	GoTypesVec[47] = &info_ArrayOf_URL

	GoTypesVec[72] = &info_Userinfo

	GoTypesVec[21] = &info_PtrTo_Userinfo

	GoTypesVec[48] = &info_ArrayOf_Userinfo

	GoTypesVec[73] = &info_Values

	GoTypesVec[22] = &info_PtrTo_Values

	GoTypesVec[49] = &info_ArrayOf_Values

	EnsureLoaded("go.std.errors")  // E.g. from: _tests/small/src/net/url/url.go:14:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/small/src/net/url/url.go:15:2
	EnsureLoaded("go.std.sort")  // E.g. from: _tests/small/src/net/url/url.go:16:2
	EnsureLoaded("go.std.strconv")  // E.g. from: _tests/small/src/net/url/url.go:17:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/small/src/net/url/url.go:18:2

}

Adding 2 custom imports to g_custom.go

-------- BEGIN generated file g_custom.go:
// Auto-generated by gostd at (omitted for testing)

package main

import (
	_ "github.com/candid82/joker/std/go/std/net"
	_ "github.com/candid82/joker/std/go/std/net/url"
)
-------- END generated file g_custom.go.

Adding 2 custom loaded libraries to core/data/g_customlibs.joke

-------- BEGIN generated file core/data/g_customlibs.joke:
;;;; Auto-generated by gostd at (omitted for testing)

(def ^:dynamic
  ^{:private true
    :doc "A set of symbols representing loaded custom libs"}
  *custom-libs* #{
     'go.std.net
     'go.std.net.url
    })

(var-set #'*loaded-libs* (into *loaded-libs* *custom-libs*))
-------- END generated file core/data/g_customlibs.joke.

Adding only 79 types (out of 85) to core/g_goswitch.go

-------- BEGIN generated file core/g_goswitch.go:
// Auto-generated by gostd at (omitted for testing)

package core

import (
	"net"
	"net/url"
)

var GoTypesVec [79]*GoTypeInfo

func SwitchGoType(g interface{}) int {
	switch g.(type) {
	case *net.AddrError:
		return 0
	case *net.Buffers:
		return 1
	case *net.DNSConfigError:
		return 2
	case *net.DNSError:
		return 3
	case *net.IP:
		return 4
	case *net.IPAddr:
		return 5
	case *net.IPConn:
		return 6
	case *net.IPMask:
		return 7
	case *net.IPNet:
		return 8
	case *net.InvalidAddrError:
		return 9
	case *net.MX:
		return 10
	case *net.NS:
		return 11
	case *net.OpError:
		return 12
	case *net.ParseError:
		return 13
	case *net.Resolver:
		return 14
	case *net.SRV:
		return 15
	case *net.UnknownNetworkError:
		return 16
	case *url.Error:
		return 17
	case *url.EscapeError:
		return 18
	case *url.InvalidHostError:
		return 19
	case *url.URL:
		return 20
	case *url.Userinfo:
		return 21
	case *url.Values:
		return 22
	case []*net.MX:
		return 23
	case []*net.NS:
		return 24
	case []*net.SRV:
		return 25
	case []byte:
		return 26
	case []net.AddrError:
		return 27
	case []net.Buffers:
		return 28
	case []net.DNSConfigError:
		return 29
	case []net.DNSError:
		return 30
	case []net.IP:
		return 31
	case []net.IPAddr:
		return 32
	case []net.IPConn:
		return 33
	case []net.IPMask:
		return 34
	case []net.IPNet:
		return 35
	case []net.InvalidAddrError:
		return 36
	case []net.MX:
		return 37
	case []net.NS:
		return 38
	case []net.OpError:
		return 39
	case []net.ParseError:
		return 40
	case []net.Resolver:
		return 41
	case []net.SRV:
		return 42
	case []net.UnknownNetworkError:
		return 43
	case []url.Error:
		return 44
	case []url.EscapeError:
		return 45
	case []url.InvalidHostError:
		return 46
	case []url.URL:
		return 47
	case []url.Userinfo:
		return 48
	case []url.Values:
		return 49
	case []string:
		return 50
	case net.AddrError:
		return 51
	case net.Buffers:
		return 52
	case net.DNSConfigError:
		return 53
	case net.DNSError:
		return 54
	case net.IP:
		return 55
	case net.IPAddr:
		return 56
	case net.IPConn:
		return 57
	case net.IPMask:
		return 58
	case net.IPNet:
		return 59
	case net.InvalidAddrError:
		return 60
	case net.MX:
		return 61
	case net.NS:
		return 62
	case net.OpError:
		return 63
	case net.ParseError:
		return 64
	case net.Resolver:
		return 65
	case net.SRV:
		return 66
	case net.UnknownNetworkError:
		return 67
	case url.Error:
		return 68
	case url.EscapeError:
		return 69
	case url.InvalidHostError:
		return 70
	case url.URL:
		return 71
	case url.Userinfo:
		return 72
	case url.Values:
		return 73
	case net.Conn:  // Specificity=8
		return 74
	case net.PacketConn:  // Specificity=7
		return 75
	case net.Error:  // Specificity=3
		return 76
	case net.Listener:  // Specificity=3
		return 77
	case net.Addr:  // Specificity=2
		return 78
	}
	return -1
}
-------- END generated file core/g_goswitch.go.

ABENDs: 002(17) 048(6) 674(4) 275(3) 320(2) 124(1) 727(1)
Totals: functions=132 generated=111 (84.09%)
          non-receivers=26 (19.70%) generated=26 (100.00%)
          receivers=83 (62.88%) generated=69 (83.13%)
          methods=23 (17.42%) generated=16 (69.57%)
        types=74
          constructable=69 ctors=14 (20.29%)
        constants=2 generated=2 (100.00%)
        variables=12 generated=12 (100.00%)
