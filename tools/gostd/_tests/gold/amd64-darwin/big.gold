Walking from _tests/big/src to _tests/big/src/go
Processing go:
Walking from _tests/big/src to _tests/big/src/net
Processing net:
Matchfile(_tests/big/src/net/fd_windows.go) => false <nil>
Ignoring test code in ipsock_test.go
Matchfile(_tests/big/src/net/fd_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_openbsd.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_unix.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_solaris.go) => false <nil>
Matchfile(_tests/big/src/net/fd_unix.go) => true <nil>
Matchfile(_tests/big/src/net/error_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/sockopt_stub.go) => false <nil>
Ignoring test code in mac_test.go
Ignoring test code in tcpsock_test.go
Ignoring test code in lookup_test.go
Matchfile(_tests/big/src/net/sockoptip_stub.go) => false <nil>
Matchfile(_tests/big/src/net/sock_cloexec.go) => false <nil>
Ignoring test code in main_cloexec_test.go
Matchfile(_tests/big/src/net/error_windows.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_unix.go) => false <nil>
Matchfile(_tests/big/src/net/sockaddr_posix.go) => true <nil>
Ignoring test code in dnsclient_test.go
Ignoring test code in example_test.go
Matchfile(_tests/big/src/net/interface_freebsd.go) => false <nil>
Ignoring test code in iprawsock_test.go
Ignoring test code in dnsconfig_unix_test.go
Matchfile(_tests/big/src/net/cgo_socknew.go) => false <nil>
Matchfile(_tests/big/src/net/error_nacl.go) => false <nil>
Matchfile(_tests/big/src/net/sockoptip_windows.go) => false <nil>
Matchfile(_tests/big/src/net/udpsock.go) => true <nil>
Matchfile(_tests/big/src/net/udpsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/sock_linux.go) => false <nil>
Matchfile(_tests/big/src/net/sendfile_linux.go) => false <nil>
Ignoring test code in hosts_test.go
Matchfile(_tests/big/src/net/cgo_resold.go) => false <nil>
Matchfile(_tests/big/src/net/splice_linux.go) => false <nil>
Ignoring test code in main_windows_test.go
Matchfile(_tests/big/src/net/unixsock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/rawconn.go) => true <nil>
Matchfile(_tests/big/src/net/hook_windows.go) => false <nil>
Ignoring test code in interface_test.go
Matchfile(_tests/big/src/net/iprawsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_linux.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_android.go) => false <nil>
Matchfile(_tests/big/src/net/addrselect.go) => true <nil>
Matchfile(_tests/big/src/net/net_fake.go) => false <nil>
Ignoring test code in interface_bsd_test.go
Matchfile(_tests/big/src/net/file_unix.go) => true <nil>
Matchfile(_tests/big/src/net/interface_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/port.go) => true <nil>
Matchfile(_tests/big/src/net/sock_posix.go) => true <nil>
Ignoring test code in lookup_windows_test.go
Matchfile(_tests/big/src/net/sockopt_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/sendfile_stub.go) => true <nil>
Ignoring test code in tcpsock_unix_test.go
Matchfile(_tests/big/src/net/lookup_unix.go) => true <nil>
Matchfile(_tests/big/src/net/dnsclient_unix.go) => true <nil>
Ignoring test code in rawconn_windows_test.go
Ignoring test code in error_plan9_test.go
Matchfile(_tests/big/src/net/lookup_windows.go) => false <nil>
Ignoring test code in timeout_test.go
Matchfile(_tests/big/src/net/dnsconfig_unix.go) => true <nil>
Ignoring test code in dial_test.go
Matchfile(_tests/big/src/net/hosts.go) => true <nil>
Matchfile(_tests/big/src/net/lookup_fake.go) => false <nil>
Matchfile(_tests/big/src/net/interface_bsdvar.go) => false <nil>
Ignoring test code in error_unix_test.go
Ignoring test code in interface_unix_test.go
Ignoring test code in platform_test.go
Matchfile(_tests/big/src/net/sock_stub.go) => false <nil>
Matchfile(_tests/big/src/net/error_posix.go) => true <nil>
Matchfile(_tests/big/src/net/hook.go) => true <nil>
Matchfile(_tests/big/src/net/ipsock.go) => true <nil>
Ignoring test code in cgo_unix_test.go
Ignoring test code in parse_test.go
Matchfile(_tests/big/src/net/iprawsock.go) => true <nil>
Matchfile(_tests/big/src/net/sock_windows.go) => false <nil>
Matchfile(_tests/big/src/net/net.go) => true <nil>
Ignoring test code in error_posix_test.go
Matchfile(_tests/big/src/net/lookup.go) => true <nil>
Matchfile(_tests/big/src/net/interface.go) => true <nil>
Matchfile(_tests/big/src/net/sys_cloexec.go) => true <nil>
Ignoring test code in file_test.go
Matchfile(_tests/big/src/net/conf.go) => true <nil>
Matchfile(_tests/big/src/net/sockopt_posix.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_windows.go) => false <nil>
Matchfile(_tests/big/src/net/splice_stub.go) => true <nil>
Matchfile(_tests/big/src/net/sock_plan9.go) => false <nil>
Ignoring test code in interface_linux_test.go
Ignoring test code in net_test.go
Matchfile(_tests/big/src/net/udpsock_posix.go) => true <nil>
Ignoring test code in packetconn_test.go
Matchfile(_tests/big/src/net/sockopt_linux.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsock_posix.go) => true <nil>
Ignoring test code in nss_test.go
Matchfile(_tests/big/src/net/sendfile_windows.go) => false <nil>
Matchfile(_tests/big/src/net/interface_linux.go) => false <nil>
Matchfile(_tests/big/src/net/iprawsock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/unixsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/sockopt_bsd.go) => true <nil>
Ignoring test code in protoconn_test.go
Ignoring test code in dnsname_test.go
Ignoring test code in main_posix_test.go
Matchfile(_tests/big/src/net/interface_windows.go) => false <nil>
Ignoring test code in udpsock_plan9_test.go
Matchfile(_tests/big/src/net/file_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_dragonfly.go) => false <nil>
Ignoring test code in port_test.go
Matchfile(_tests/big/src/net/dnsclient.go) => true <nil>
Matchfile(_tests/big/src/net/error_unix.go) => true <nil>
Ignoring test code in error_windows_test.go
Matchfile(_tests/big/src/net/tcpsockopt_posix.go) => true <nil>
Ignoring test code in conf_test.go
Matchfile(_tests/big/src/net/ip.go) => true <nil>
Matchfile(_tests/big/src/net/nss.go) => true <nil>
Matchfile(_tests/big/src/net/ipsock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_bsd.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_sockold.go) => true <nil>
Ignoring test code in sendfile_test.go
Matchfile(_tests/big/src/net/sendfile_unix_alt.go) => false <nil>
Matchfile(_tests/big/src/net/writev_unix.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_netbsd.go) => false <nil>
Matchfile(_tests/big/src/net/file.go) => true <nil>
Matchfile(_tests/big/src/net/interface_bsd.go) => true <nil>
Ignoring test code in ip_test.go
Ignoring test code in main_plan9_test.go
Matchfile(_tests/big/src/net/cgo_resnew.go) => true <nil>
Ignoring test code in rawconn_test.go
Matchfile(_tests/big/src/net/sockopt_solaris.go) => false <nil>
Matchfile(_tests/big/src/net/interface_stub.go) => false <nil>
Ignoring test code in conn_test.go
Matchfile(_tests/big/src/net/tcpsock.go) => true <nil>
Matchfile(_tests/big/src/net/hook_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_solaris.go) => false <nil>
Ignoring test code in main_conf_test.go
Matchfile(_tests/big/src/net/cgo_openbsd.go) => false <nil>
Ignoring test code in rawconn_unix_test.go
Ignoring test code in main_noconf_test.go
Ignoring test code in external_test.go
Ignoring test code in mockserver_test.go
Ignoring test code in pipe_test.go
Ignoring test code in rawconn_stub_test.go
Ignoring test code in net_windows_test.go
Matchfile(_tests/big/src/net/port_unix.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_stub.go) => false <nil>
Ignoring test code in main_unix_test.go
Matchfile(_tests/big/src/net/mac.go) => true <nil>
Ignoring test code in unixsock_test.go
Ignoring test code in dial_unix_test.go
Ignoring test code in error_test.go
Matchfile(_tests/big/src/net/tcpsockopt_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/sockoptip_linux.go) => false <nil>
Matchfile(_tests/big/src/net/unixsock.go) => true <nil>
Matchfile(_tests/big/src/net/lookup_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/sockopt_windows.go) => false <nil>
Matchfile(_tests/big/src/net/sockoptip_posix.go) => true <nil>
Matchfile(_tests/big/src/net/sockoptip_bsdvar.go) => true <nil>
Matchfile(_tests/big/src/net/pipe.go) => true <nil>
Matchfile(_tests/big/src/net/tcpsockopt_windows.go) => false <nil>
Matchfile(_tests/big/src/net/hook_unix.go) => true <nil>
Matchfile(_tests/big/src/net/tcpsockopt_stub.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_darwin.go) => true <nil>
Ignoring test code in udpsock_test.go
Matchfile(_tests/big/src/net/interface_solaris.go) => false <nil>
Ignoring test code in listen_test.go
Matchfile(_tests/big/src/net/sock_bsd.go) => true <nil>
Matchfile(_tests/big/src/net/interface_darwin.go) => true <nil>
Matchfile(_tests/big/src/net/dial.go) => true <nil>
Ignoring test code in server_test.go
Matchfile(_tests/big/src/net/file_windows.go) => false <nil>
Ignoring test code in splice_test.go
Ignoring test code in addrselect_test.go
Matchfile(_tests/big/src/net/ipsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/parse.go) => true <nil>
Ignoring test code in unixsock_linux_test.go
Matchfile(_tests/big/src/net/conf_netcgo.go) => false <nil>
Ignoring test code in writev_test.go
Ignoring test code in netgo_unix_test.go
Ignoring test code in write_unix_test.go
Ignoring test code in main_test.go
Ignoring test code in dnsclient_unix_test.go
Matchfile(_tests/big/src/net/file_stub.go) => false <nil>
Processing package=net:
Walking from _tests/big/src to _tests/big/src/net/http
Processing net/http:
Matchfile(_tests/big/src/net/http/jar.go) => true <nil>
Ignoring test code in cookie_test.go
Matchfile(_tests/big/src/net/http/transport.go) => true <nil>
Matchfile(_tests/big/src/net/http/header.go) => true <nil>
Ignoring test code in requestwrite_test.go
Ignoring test code in range_test.go
Ignoring test code in example_test.go
Ignoring test code in transfer_test.go
Matchfile(_tests/big/src/net/http/server.go) => true <nil>
Ignoring test code in transport_internal_test.go
Ignoring test code in fs_test.go
Ignoring test code in http_test.go
Matchfile(_tests/big/src/net/http/h2_bundle.go) => true <nil>
Ignoring test code in header_test.go
Matchfile(_tests/big/src/net/http/response.go) => true <nil>
Ignoring test code in request_test.go
Matchfile(_tests/big/src/net/http/request.go) => true <nil>
Ignoring test code in serve_test.go
Ignoring test code in response_test.go
Matchfile(_tests/big/src/net/http/client.go) => true <nil>
Matchfile(_tests/big/src/net/http/race.go) => false <nil>
Matchfile(_tests/big/src/net/http/roundtrip_js.go) => false <nil>
Ignoring test code in responsewrite_test.go
Matchfile(_tests/big/src/net/http/method.go) => true <nil>
Ignoring test code in clientserver_test.go
Matchfile(_tests/big/src/net/http/http.go) => true <nil>
Ignoring test code in filetransport_test.go
Matchfile(_tests/big/src/net/http/doc.go) => true <nil>
Matchfile(_tests/big/src/net/http/fs.go) => true <nil>
Matchfile(_tests/big/src/net/http/triv.go) => false <nil>
Ignoring test code in export_test.go
Matchfile(_tests/big/src/net/http/transfer.go) => true <nil>
Matchfile(_tests/big/src/net/http/cookie.go) => true <nil>
Ignoring test code in proxy_test.go
Matchfile(_tests/big/src/net/http/sniff.go) => true <nil>
Ignoring test code in transport_test.go
Matchfile(_tests/big/src/net/http/status.go) => true <nil>
Ignoring test code in sniff_test.go
Ignoring test code in client_test.go
Matchfile(_tests/big/src/net/http/socks_bundle.go) => true <nil>
Ignoring test code in npn_test.go
Ignoring test code in readrequest_test.go
Matchfile(_tests/big/src/net/http/roundtrip.go) => true <nil>
Ignoring test code in main_test.go
Matchfile(_tests/big/src/net/http/filetransport.go) => true <nil>
Processing package=net/http:
Walking from _tests/big/src to _tests/big/src/net/http/cgi
Processing net/http/cgi:
Ignoring test code in plan9_test.go
Ignoring test code in child_test.go
Ignoring test code in posix_test.go
Ignoring test code in host_test.go
Ignoring test code in matryoshka_test.go
Matchfile(_tests/big/src/net/http/cgi/host.go) => true <nil>
Matchfile(_tests/big/src/net/http/cgi/child.go) => true <nil>
Processing package=net/http/cgi:
Excluding _tests/big/src/net/http/cgi/testdata
Walking from _tests/big/src to _tests/big/src/net/http/cookiejar
Processing net/http/cookiejar:
Matchfile(_tests/big/src/net/http/cookiejar/jar.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(_tests/big/src/net/http/cookiejar/punycode.go) => true <nil>
Ignoring test code in punycode_test.go
Ignoring test code in jar_test.go
Ignoring test code in dummy_publicsuffix_test.go
Processing package=net/http/cookiejar:
Walking from _tests/big/src to _tests/big/src/net/http/fcgi
Processing net/http/fcgi:
Matchfile(_tests/big/src/net/http/fcgi/child.go) => true <nil>
Matchfile(_tests/big/src/net/http/fcgi/fcgi.go) => true <nil>
Ignoring test code in fcgi_test.go
Processing package=net/http/fcgi:
Walking from _tests/big/src to _tests/big/src/net/http/httptest
Processing net/http/httptest:
Ignoring test code in example_test.go
Matchfile(_tests/big/src/net/http/httptest/server.go) => true <nil>
Matchfile(_tests/big/src/net/http/httptest/recorder.go) => true <nil>
Ignoring test code in httptest_test.go
Matchfile(_tests/big/src/net/http/httptest/httptest.go) => true <nil>
Ignoring test code in recorder_test.go
Ignoring test code in server_test.go
Processing package=net/http/httptest:
Walking from _tests/big/src to _tests/big/src/net/http/httptrace
Processing net/http/httptrace:
Ignoring test code in trace_test.go
Ignoring test code in example_test.go
Matchfile(_tests/big/src/net/http/httptrace/trace.go) => true <nil>
Processing package=net/http/httptrace:
Walking from _tests/big/src to _tests/big/src/net/http/httputil
Processing net/http/httputil:
Ignoring test code in example_test.go
Matchfile(_tests/big/src/net/http/httputil/httputil.go) => true <nil>
Matchfile(_tests/big/src/net/http/httputil/persist.go) => true <nil>
Ignoring test code in dump_test.go
Matchfile(_tests/big/src/net/http/httputil/dump.go) => true <nil>
Ignoring test code in reverseproxy_test.go
Matchfile(_tests/big/src/net/http/httputil/reverseproxy.go) => true <nil>
Processing package=net/http/httputil:
Excluding _tests/big/src/net/http/internal
Walking from _tests/big/src to _tests/big/src/net/http/pprof
Processing net/http/pprof:
Matchfile(_tests/big/src/net/http/pprof/pprof.go) => true <nil>
Ignoring test code in pprof_test.go
Processing package=net/http/pprof:
Excluding _tests/big/src/net/http/testdata
Excluding _tests/big/src/net/internal
Walking from _tests/big/src to _tests/big/src/net/mail
Processing net/mail:
Ignoring test code in example_test.go
Matchfile(_tests/big/src/net/mail/message.go) => true <nil>
Ignoring test code in message_test.go
Processing package=net/mail:
Walking from _tests/big/src to _tests/big/src/net/rpc
Processing net/rpc:
Matchfile(_tests/big/src/net/rpc/server.go) => true <nil>
Matchfile(_tests/big/src/net/rpc/client.go) => true <nil>
Matchfile(_tests/big/src/net/rpc/debug.go) => true <nil>
Ignoring test code in client_test.go
Ignoring test code in server_test.go
Processing package=net/rpc:
Walking from _tests/big/src to _tests/big/src/net/rpc/jsonrpc
Processing net/rpc/jsonrpc:
Matchfile(_tests/big/src/net/rpc/jsonrpc/server.go) => true <nil>
Matchfile(_tests/big/src/net/rpc/jsonrpc/client.go) => true <nil>
Ignoring test code in all_test.go
Processing package=net/rpc/jsonrpc:
Walking from _tests/big/src to _tests/big/src/net/smtp
Processing net/smtp:
Ignoring test code in example_test.go
Matchfile(_tests/big/src/net/smtp/auth.go) => true <nil>
Ignoring test code in smtp_test.go
Matchfile(_tests/big/src/net/smtp/smtp.go) => true <nil>
Processing package=net/smtp:
Excluding _tests/big/src/net/testdata
Walking from _tests/big/src to _tests/big/src/net/textproto
Processing net/textproto:
Matchfile(_tests/big/src/net/textproto/header.go) => true <nil>
Matchfile(_tests/big/src/net/textproto/textproto.go) => true <nil>
Ignoring test code in writer_test.go
Matchfile(_tests/big/src/net/textproto/writer.go) => true <nil>
Matchfile(_tests/big/src/net/textproto/pipeline.go) => true <nil>
Matchfile(_tests/big/src/net/textproto/reader.go) => true <nil>
Ignoring test code in reader_test.go
Processing package=net/textproto:
Walking from _tests/big/src to _tests/big/src/net/url
Processing net/url:
Ignoring test code in example_test.go
Matchfile(_tests/big/src/net/url/url.go) => true <nil>
Ignoring test code in url_test.go
Processing package=net/url:
JOKER TYPE net.Addr from net/net.go:
;; (defn ^"GoObject" Addr.
;;   "Constructor for net.Addr"
;;   {:added "1.0"
;;    :go "_ConstructAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.AddrError from net/net.go:
(defn ^"GoObject" AddrError.
  "Constructor for net.AddrError"
  {:added "1.0"
   :go "_ConstructAddrError(_v)"}
  [^Object _v])

JOKER TYPE net.Buffers from net/net.go:
;; (defn ^"GoObject" Buffers.
;;   "Constructor for net.Buffers"
;;   {:added "1.0"
;;    :go "_ConstructBuffers(_v)"}
;;   [^Object _v])

JOKER TYPE net.Conn from net/net.go:
;; (defn ^"GoObject" Conn.
;;   "Constructor for net.Conn"
;;   {:added "1.0"
;;    :go "_ConstructConn(_v)"}
;;   [^Object _v])

JOKER TYPE net.DNSConfigError from net/net.go:
(defn ^"GoObject" DNSConfigError.
  "Constructor for net.DNSConfigError"
  {:added "1.0"
   :go "_ConstructDNSConfigError(_v)"}
  [^Object _v])

JOKER TYPE net.DNSError from net/net.go:
(defn ^"GoObject" DNSError.
  "Constructor for net.DNSError"
  {:added "1.0"
   :go "_ConstructDNSError(_v)"}
  [^Object _v])

JOKER TYPE net.Dialer from net/dial.go:
;; (defn ^"GoObject" Dialer.
;;   "Constructor for net.Dialer"
;;   {:added "1.0"
;;    :go "_ConstructDialer(_v)"}
;;   [^Object _v])

JOKER TYPE net.Error from net/net.go:
;; (defn ^"GoObject" Error.
;;   "Constructor for net.Error"
;;   {:added "1.0"
;;    :go "_ConstructError(_v)"}
;;   [^Object _v])

JOKER TYPE net.Flags from net/interface.go:
(defn ^"GoObject" Flags.
  "Constructor for net.Flags"
  {:added "1.0"
   :go "_ConstructFlags(_v)"}
  [^Object _v])

JOKER TYPE net.HardwareAddr from net/mac.go:
;; (defn ^"GoObject" HardwareAddr.
;;   "Constructor for net.HardwareAddr"
;;   {:added "1.0"
;;    :go "_ConstructHardwareAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.IP from net/ip.go:
;; (defn ^"GoObject" IP.
;;   "Constructor for net.IP"
;;   {:added "1.0"
;;    :go "_ConstructIP(_v)"}
;;   [^Object _v])

JOKER TYPE net.IPAddr from net/iprawsock.go:
;; (defn ^"GoObject" IPAddr.
;;   "Constructor for net.IPAddr"
;;   {:added "1.0"
;;    :go "_ConstructIPAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.IPConn from net/iprawsock.go:
(defn ^"GoObject" IPConn.
  "Constructor for net.IPConn"
  {:added "1.0"
   :go "_ConstructIPConn(_v)"}
  [^Object _v])

JOKER TYPE net.IPMask from net/ip.go:
;; (defn ^"GoObject" IPMask.
;;   "Constructor for net.IPMask"
;;   {:added "1.0"
;;    :go "_ConstructIPMask(_v)"}
;;   [^Object _v])

JOKER TYPE net.IPNet from net/ip.go:
;; (defn ^"GoObject" IPNet.
;;   "Constructor for net.IPNet"
;;   {:added "1.0"
;;    :go "_ConstructIPNet(_v)"}
;;   [^Object _v])

JOKER TYPE net.Interface from net/interface.go:
;; (defn ^"GoObject" Interface.
;;   "Constructor for net.Interface"
;;   {:added "1.0"
;;    :go "_ConstructInterface(_v)"}
;;   [^Object _v])

JOKER TYPE net.InvalidAddrError from net/net.go:
(defn ^"GoObject" InvalidAddrError.
  "Constructor for net.InvalidAddrError"
  {:added "1.0"
   :go "_ConstructInvalidAddrError(_v)"}
  [^Object _v])

JOKER TYPE net.ListenConfig from net/dial.go:
;; (defn ^"GoObject" ListenConfig.
;;   "Constructor for net.ListenConfig"
;;   {:added "1.0"
;;    :go "_ConstructListenConfig(_v)"}
;;   [^Object _v])

JOKER TYPE net.Listener from net/net.go:
;; (defn ^"GoObject" Listener.
;;   "Constructor for net.Listener"
;;   {:added "1.0"
;;    :go "_ConstructListener(_v)"}
;;   [^Object _v])

JOKER TYPE net.MX from net/dnsclient.go:
(defn ^"GoObject" MX.
  "Constructor for net.MX"
  {:added "1.0"
   :go "_ConstructMX(_v)"}
  [^Object _v])

JOKER TYPE net.NS from net/dnsclient.go:
(defn ^"GoObject" NS.
  "Constructor for net.NS"
  {:added "1.0"
   :go "_ConstructNS(_v)"}
  [^Object _v])

JOKER TYPE net.OpError from net/net.go:
;; (defn ^"GoObject" OpError.
;;   "Constructor for net.OpError"
;;   {:added "1.0"
;;    :go "_ConstructOpError(_v)"}
;;   [^Object _v])

JOKER TYPE net.PacketConn from net/net.go:
;; (defn ^"GoObject" PacketConn.
;;   "Constructor for net.PacketConn"
;;   {:added "1.0"
;;    :go "_ConstructPacketConn(_v)"}
;;   [^Object _v])

JOKER TYPE net.ParseError from net/net.go:
(defn ^"GoObject" ParseError.
  "Constructor for net.ParseError"
  {:added "1.0"
   :go "_ConstructParseError(_v)"}
  [^Object _v])

JOKER TYPE net.Resolver from net/lookup.go:
;; (defn ^"GoObject" Resolver.
;;   "Constructor for net.Resolver"
;;   {:added "1.0"
;;    :go "_ConstructResolver(_v)"}
;;   [^Object _v])

JOKER TYPE net.SRV from net/dnsclient.go:
(defn ^"GoObject" SRV.
  "Constructor for net.SRV"
  {:added "1.0"
   :go "_ConstructSRV(_v)"}
  [^Object _v])

JOKER TYPE net.TCPAddr from net/tcpsock.go:
;; (defn ^"GoObject" TCPAddr.
;;   "Constructor for net.TCPAddr"
;;   {:added "1.0"
;;    :go "_ConstructTCPAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.TCPConn from net/tcpsock.go:
(defn ^"GoObject" TCPConn.
  "Constructor for net.TCPConn"
  {:added "1.0"
   :go "_ConstructTCPConn(_v)"}
  [^Object _v])

JOKER TYPE net.TCPListener from net/tcpsock.go:
(defn ^"GoObject" TCPListener.
  "Constructor for net.TCPListener"
  {:added "1.0"
   :go "_ConstructTCPListener(_v)"}
  [^Object _v])

JOKER TYPE net.UDPAddr from net/udpsock.go:
;; (defn ^"GoObject" UDPAddr.
;;   "Constructor for net.UDPAddr"
;;   {:added "1.0"
;;    :go "_ConstructUDPAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.UDPConn from net/udpsock.go:
(defn ^"GoObject" UDPConn.
  "Constructor for net.UDPConn"
  {:added "1.0"
   :go "_ConstructUDPConn(_v)"}
  [^Object _v])

JOKER TYPE net.UnixAddr from net/unixsock.go:
(defn ^"GoObject" UnixAddr.
  "Constructor for net.UnixAddr"
  {:added "1.0"
   :go "_ConstructUnixAddr(_v)"}
  [^Object _v])

JOKER TYPE net.UnixConn from net/unixsock.go:
(defn ^"GoObject" UnixConn.
  "Constructor for net.UnixConn"
  {:added "1.0"
   :go "_ConstructUnixConn(_v)"}
  [^Object _v])

JOKER TYPE net.UnixListener from net/unixsock.go:
(defn ^"GoObject" UnixListener.
  "Constructor for net.UnixListener"
  {:added "1.0"
   :go "_ConstructUnixListener(_v)"}
  [^Object _v])

JOKER TYPE net.UnknownNetworkError from net/net.go:
(defn ^"GoObject" UnknownNetworkError.
  "Constructor for net.UnknownNetworkError"
  {:added "1.0"
   :go "_ConstructUnknownNetworkError(_v)"}
  [^Object _v])

JOKER FUNC net.CIDRMask from net/ip.go:
(defn CIDRMask
  "CIDRMask returns an IPMask consisting of `ones' 1 bits\nfollowed by 0s up to a total length of `bits' bits.\nFor a mask of this form, CIDRMask is the inverse of IPMask.Size.\n\nGo input arguments: (ones int, bits int)\n\nGo return type: IPMask\n\nJoker input arguments: [^Int ones, ^Int bits]\n\nJoker return type: go.std.net/IPMask"
  {:added "1.0"
   :go "__cIDRMask(_ones, _bits)"}
  [^Int _ones, ^Int _bits])

JOKER FUNC net.Dial from net/dial.go:
(defn Dial
  "Dial connects to the address on the named network.\n\nKnown networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only),\n\"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\"\n(IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and\n\"unixpacket\".\n\nFor TCP and UDP networks, the address has the form \"host:port\".\nThe host must be a literal IP address, or a host name that can be\nresolved to IP addresses.\nThe port must be a literal port number or a service name.\nIf the host is a literal IPv6 address it must be enclosed in square\nbrackets, as in \"[2001:db8::1]:80\" or \"[fe80::1%zone]:80\".\nThe zone specifies the scope of the literal IPv6 address as defined\nin RFC 4007.\nThe functions JoinHostPort and SplitHostPort manipulate a pair of\nhost and port in this form.\nWhen using TCP, and the host resolves to multiple IP addresses,\nDial will try each IP address in order until one succeeds.\n\nExamples:\n\tDial(\"tcp\", \"golang.org:http\")\n\tDial(\"tcp\", \"192.0.2.1:http\")\n\tDial(\"tcp\", \"198.51.100.1:80\")\n\tDial(\"udp\", \"[2001:db8::1]:domain\")\n\tDial(\"udp\", \"[fe80::1%lo0]:53\")\n\tDial(\"tcp\", \":80\")\n\nFor IP networks, the network must be \"ip\", \"ip4\" or \"ip6\" followed\nby a colon and a literal protocol number or a protocol name, and\nthe address has the form \"host\". The host must be a literal IP\naddress or a literal IPv6 address with zone.\nIt depends on each operating system how the operating system\nbehaves with a non-well known protocol number such as \"0\" or \"255\".\n\nExamples:\n\tDial(\"ip4:1\", \"192.0.2.1\")\n\tDial(\"ip6:ipv6-icmp\", \"2001:db8::1\")\n\tDial(\"ip6:58\", \"fe80::1%lo0\")\n\nFor TCP, UDP and IP networks, if the host is empty or a literal\nunspecified IP address, as in \":80\", \"0.0.0.0:80\" or \"[::]:80\" for\nTCP and UDP, \"\", \"0.0.0.0\" or \"::\" for IP, the local system is\nassumed.\n\nFor Unix networks, the address must be a file system path.\n\nGo input arguments: (network string, address string)\n\nGo return type: (Conn, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/Conn Error]"
  {:added "1.0"
   :go "__dial(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.DialIP from net/iprawsock.go:
(defn DialIP
  "DialIP acts like Dial for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *IPAddr, raddr *IPAddr)\n\nGo return type: (*IPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/IPAddr) laddr, ^(atom-of go.std.net/IPAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/IPConn) Error]"
  {:added "1.0"
   :go "__dialIP(_network, _laddr, _raddr)"}
  [^String _network, ^net/IPAddr _laddr, ^net/IPAddr _raddr])

JOKER FUNC net.DialTCP from net/tcpsock.go:
(defn DialTCP
  "DialTCP acts like Dial for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *TCPAddr, raddr *TCPAddr)\n\nGo return type: (*TCPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/TCPAddr) laddr, ^(atom-of go.std.net/TCPAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/TCPConn) Error]"
  {:added "1.0"
   :go "__dialTCP(_network, _laddr, _raddr)"}
  [^String _network, ^net/TCPAddr _laddr, ^net/TCPAddr _raddr])

JOKER FUNC net.DialTimeout from net/dial.go:
;; (defn DialTimeout
;;   "DialTimeout acts like Dial but takes a timeout.\n\nThe timeout includes name resolution, if required.\nWhen using TCP, and the host in the address parameter resolves to\nmultiple IP addresses, the timeout is spread over each consecutive\ndial, such that each is given an appropriate fraction of the time\nto connect.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string, timeout time.Duration)\n\nGo return type: (Conn, error)\n\nJoker input arguments: [^String network, ^String address, ^go.std.time/Duration timeout]\n\nJoker return type: [go.std.net/Conn Error]"
;;   {:added "1.0"
;;    :go "__dialTimeout(_network, _address, *_timeout)"}
;;   [^String _network, ^String _address, ^time/Duration _timeout])

JOKER FUNC net.DialUDP from net/udpsock.go:
(defn DialUDP
  "DialUDP acts like Dial for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *UDPAddr, raddr *UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UDPAddr) laddr, ^(atom-of go.std.net/UDPAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/UDPConn) Error]"
  {:added "1.0"
   :go "__dialUDP(_network, _laddr, _raddr)"}
  [^String _network, ^net/UDPAddr _laddr, ^net/UDPAddr _raddr])

JOKER FUNC net.DialUnix from net/unixsock.go:
(defn DialUnix
  "DialUnix acts like Dial for Unix networks.\n\nThe network must be a Unix network name; see func Dial for details.\n\nIf laddr is non-nil, it is used as the local address for the\nconnection.\n\nGo input arguments: (network string, laddr *UnixAddr, raddr *UnixAddr)\n\nGo return type: (*UnixConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr, ^(atom-of go.std.net/UnixAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/UnixConn) Error]"
  {:added "1.0"
   :go "__dialUnix(_network, _laddr, _raddr)"}
  [^String _network, ^net/UnixAddr _laddr, ^net/UnixAddr _raddr])

JOKER FUNC net.FileConn from net/file.go:
;; (defn FileConn
;;   "FileConn returns a copy of the network connection corresponding to\nthe open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo input arguments: (f *os.File)\n\nGo return type: (c Conn, err error)\n\nJoker input arguments: [^(atom-of go.std.os/File) f]\n\nJoker return type: [go.std.net/Conn Error]"
;;   {:added "1.0"
;;    :go "__fileConn(_f)"}
;;   [^os/File _f])

JOKER FUNC net.FileListener from net/file.go:
;; (defn FileListener
;;   "FileListener returns a copy of the network listener corresponding\nto the open file f.\nIt is the caller's responsibility to close ln when finished.\nClosing ln does not affect f, and closing f does not affect ln.\n\nGo input arguments: (f *os.File)\n\nGo return type: (ln Listener, err error)\n\nJoker input arguments: [^(atom-of go.std.os/File) f]\n\nJoker return type: [go.std.net/Listener Error]"
;;   {:added "1.0"
;;    :go "__fileListener(_f)"}
;;   [^os/File _f])

JOKER FUNC net.FilePacketConn from net/file.go:
;; (defn FilePacketConn
;;   "FilePacketConn returns a copy of the packet network connection\ncorresponding to the open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo input arguments: (f *os.File)\n\nGo return type: (c PacketConn, err error)\n\nJoker input arguments: [^(atom-of go.std.os/File) f]\n\nJoker return type: [go.std.net/PacketConn Error]"
;;   {:added "1.0"
;;    :go "__filePacketConn(_f)"}
;;   [^os/File _f])

JOKER FUNC net.IPv4 from net/ip.go:
(defn IPv4
  "IPv4 returns the IP address (in 16-byte form) of the\nIPv4 address a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo return type: IP\n\nJoker input arguments: [^Byte a, ^Byte b, ^Byte c, ^Byte d]\n\nJoker return type: go.std.net/IP"
  {:added "1.0"
   :go "__iPv4(_a, _b, _c, _d)"}
  [^Byte _a, ^Byte _b, ^Byte _c, ^Byte _d])

JOKER FUNC net.IPv4Mask from net/ip.go:
(defn IPv4Mask
  "IPv4Mask returns the IP mask (in 4-byte form) of the\nIPv4 mask a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo return type: IPMask\n\nJoker input arguments: [^Byte a, ^Byte b, ^Byte c, ^Byte d]\n\nJoker return type: go.std.net/IPMask"
  {:added "1.0"
   :go "__iPv4Mask(_a, _b, _c, _d)"}
  [^Byte _a, ^Byte _b, ^Byte _c, ^Byte _d])

JOKER FUNC net.InterfaceAddrs from net/interface.go:
(defn InterfaceAddrs
  "InterfaceAddrs returns a list of the system's unicast interface\naddresses.\n\nThe returned list does not identify the associated interface; use\nInterfaces and Interface.Addrs for more detail.\n\nGo return type: ([]Addr, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of go.std.net/Addr) Error]"
  {:added "1.0"
   :go "__interfaceAddrs()"}
  [])

JOKER FUNC net.InterfaceByIndex from net/interface.go:
(defn InterfaceByIndex
  "InterfaceByIndex returns the interface specified by index.\n\nOn Solaris, it returns one of the logical network interfaces\nsharing the logical data link; for more precision use\nInterfaceByName.\n\nGo input arguments: (index int)\n\nGo return type: (*Interface, error)\n\nJoker input arguments: [^Int index]\n\nJoker return type: [(atom-of go.std.net/Interface) Error]"
  {:added "1.0"
   :go "__interfaceByIndex(_index)"}
  [^Int _index])

JOKER FUNC net.InterfaceByName from net/interface.go:
(defn InterfaceByName
  "InterfaceByName returns the interface specified by name.\n\nGo input arguments: (name string)\n\nGo return type: (*Interface, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.net/Interface) Error]"
  {:added "1.0"
   :go "__interfaceByName(_name)"}
  [^String _name])

JOKER FUNC net.Interfaces from net/interface.go:
(defn Interfaces
  "Interfaces returns a list of the system's network interfaces.\n\nGo return type: ([]Interface, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of go.std.net/Interface) Error]"
  {:added "1.0"
   :go "__interfaces()"}
  [])

JOKER FUNC net.JoinHostPort from net/ipsock.go:
(defn ^"String" JoinHostPort
  "JoinHostPort combines host and port into a network address of the\nform \"host:port\". If host contains a colon, as found in literal\nIPv6 addresses, then JoinHostPort returns \"[host]:port\".\n\nSee func Dial for a description of the host and port parameters.\n\nGo input arguments: (host string, port string)\n\nGo return type: string\n\nJoker input arguments: [^String host, ^String port]\n\nJoker return type: String"
  {:added "1.0"
   :go "net.JoinHostPort(_host, _port)"}
  [^String _host, ^String _port])

JOKER FUNC net.Listen from net/dial.go:
(defn Listen
  "Listen announces on the local network address.\n\nThe network must be \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\".\n\nFor TCP networks, if the host in the address parameter is empty or\na literal unspecified IP address, Listen listens on all available\nunicast and anycast IP addresses of the local system.\nTo only use IPv4, use network \"tcp4\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe Addr method of Listener can be used to discover the chosen\nport.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (Listener, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/Listener Error]"
  {:added "1.0"
   :go "__listen(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.ListenIP from net/iprawsock.go:
(defn ListenIP
  "ListenIP acts like ListenPacket for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenIP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\n\nGo input arguments: (network string, laddr *IPAddr)\n\nGo return type: (*IPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/IPAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/IPConn) Error]"
  {:added "1.0"
   :go "__listenIP(_network, _laddr)"}
  [^String _network, ^net/IPAddr _laddr])

JOKER FUNC net.ListenMulticastUDP from net/udpsock.go:
(defn ListenMulticastUDP
  "ListenMulticastUDP acts like ListenPacket for UDP networks but\ntakes a group address on a specific network interface.\n\nThe network must be a UDP network name; see func Dial for details.\n\nListenMulticastUDP listens on all available IP addresses of the\nlocal system including the group, multicast IP address.\nIf ifi is nil, ListenMulticastUDP uses the system-assigned\nmulticast interface, although this is not recommended because the\nassignment depends on platforms and sometimes it might require\nrouting configuration.\nIf the Port field of gaddr is 0, a port number is automatically\nchosen.\n\nListenMulticastUDP is just for convenience of simple, small\napplications. There are golang.org/x/net/ipv4 and\ngolang.org/x/net/ipv6 packages for general purpose uses.\n\nGo input arguments: (network string, ifi *Interface, gaddr *UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/Interface) ifi, ^(atom-of go.std.net/UDPAddr) gaddr]\n\nJoker return type: [(atom-of go.std.net/UDPConn) Error]"
  {:added "1.0"
   :go "__listenMulticastUDP(_network, _ifi, _gaddr)"}
  [^String _network, ^net/Interface _ifi, ^net/UDPAddr _gaddr])

JOKER FUNC net.ListenPacket from net/dial.go:
(defn ListenPacket
  "ListenPacket announces on the local network address.\n\nThe network must be \"udp\", \"udp4\", \"udp6\", \"unixgram\", or an IP\ntransport. The IP transports are \"ip\", \"ip4\", or \"ip6\" followed by\na colon and a literal protocol number or a protocol name, as in\n\"ip:1\" or \"ip:icmp\".\n\nFor UDP and IP networks, if the host in the address parameter is\nempty or a literal unspecified IP address, ListenPacket listens on\nall available IP addresses of the local system except multicast IP\naddresses.\nTo only use IPv4, use network \"udp4\" or \"ip4:proto\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe LocalAddr method of PacketConn can be used to discover the\nchosen port.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (PacketConn, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/PacketConn Error]"
  {:added "1.0"
   :go "__listenPacket(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.ListenTCP from net/tcpsock.go:
(defn ListenTCP
  "ListenTCP acts like Listen for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenTCP listens on all available unicast and anycast IP addresses\nof the local system.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo input arguments: (network string, laddr *TCPAddr)\n\nGo return type: (*TCPListener, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/TCPAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/TCPListener) Error]"
  {:added "1.0"
   :go "__listenTCP(_network, _laddr)"}
  [^String _network, ^net/TCPAddr _laddr])

JOKER FUNC net.ListenUDP from net/udpsock.go:
(defn ListenUDP
  "ListenUDP acts like ListenPacket for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenUDP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo input arguments: (network string, laddr *UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UDPAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/UDPConn) Error]"
  {:added "1.0"
   :go "__listenUDP(_network, _laddr)"}
  [^String _network, ^net/UDPAddr _laddr])

JOKER FUNC net.ListenUnix from net/unixsock.go:
(defn ListenUnix
  "ListenUnix acts like Listen for Unix networks.\n\nThe network must be \"unix\" or \"unixpacket\".\n\nGo input arguments: (network string, laddr *UnixAddr)\n\nGo return type: (*UnixListener, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/UnixListener) Error]"
  {:added "1.0"
   :go "__listenUnix(_network, _laddr)"}
  [^String _network, ^net/UnixAddr _laddr])

JOKER FUNC net.ListenUnixgram from net/unixsock.go:
(defn ListenUnixgram
  "ListenUnixgram acts like ListenPacket for Unix networks.\n\nThe network must be \"unixgram\".\n\nGo input arguments: (network string, laddr *UnixAddr)\n\nGo return type: (*UnixConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/UnixConn) Error]"
  {:added "1.0"
   :go "__listenUnixgram(_network, _laddr)"}
  [^String _network, ^net/UnixAddr _laddr])

JOKER FUNC net.LookupAddr from net/lookup.go:
(defn LookupAddr
  "LookupAddr performs a reverse lookup for the given address, returning a list\nof names mapping to that address.\n\nWhen using the host C library resolver, at most one result will be\nreturned. To bypass the host resolver, use a custom Resolver.\n\nGo input arguments: (addr string)\n\nGo return type: (names []string, err error)\n\nJoker input arguments: [^String addr]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__lookupAddr(_addr)"}
  [^String _addr])

JOKER FUNC net.LookupCNAME from net/lookup.go:
(defn LookupCNAME
  "LookupCNAME returns the canonical name for the given host.\nCallers that do not care about the canonical name can call\nLookupHost or LookupIP directly; both take care of resolving\nthe canonical name as part of the lookup.\n\nA canonical name is the final name after following zero\nor more CNAME records.\nLookupCNAME does not return an error if host does not\ncontain DNS \"CNAME\" records, as long as host resolves to\naddress records.\n\nGo input arguments: (host string)\n\nGo return type: (cname string, err error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__lookupCNAME(_host)"}
  [^String _host])

JOKER FUNC net.LookupHost from net/lookup.go:
(defn LookupHost
  "LookupHost looks up the given host using the local resolver.\nIt returns a slice of that host's addresses.\n\nGo input arguments: (host string)\n\nGo return type: (addrs []string, err error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__lookupHost(_host)"}
  [^String _host])

JOKER FUNC net.LookupIP from net/lookup.go:
(defn LookupIP
  "LookupIP looks up host using the local resolver.\nIt returns a slice of that host's IPv4 and IPv6 addresses.\n\nGo input arguments: (host string)\n\nGo return type: ([]IP, error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [(vector-of go.std.net/IP) Error]"
  {:added "1.0"
   :go "__lookupIP(_host)"}
  [^String _host])

JOKER FUNC net.LookupMX from net/lookup.go:
(defn LookupMX
  "LookupMX returns the DNS MX records for the given domain name sorted by preference.\n\nGo input arguments: (name string)\n\nGo return type: ([]*MX, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of (atom-of go.std.net/MX)) Error]"
  {:added "1.0"
   :go "__lookupMX(_name)"}
  [^String _name])

JOKER FUNC net.LookupNS from net/lookup.go:
(defn LookupNS
  "LookupNS returns the DNS NS records for the given domain name.\n\nGo input arguments: (name string)\n\nGo return type: ([]*NS, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of (atom-of go.std.net/NS)) Error]"
  {:added "1.0"
   :go "__lookupNS(_name)"}
  [^String _name])

JOKER FUNC net.LookupPort from net/lookup.go:
(defn LookupPort
  "LookupPort looks up the port for the given network and service.\n\nGo input arguments: (network string, service string)\n\nGo return type: (port int, err error)\n\nJoker input arguments: [^String network, ^String service]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__lookupPort(_network, _service)"}
  [^String _network, ^String _service])

JOKER FUNC net.LookupSRV from net/lookup.go:
(defn LookupSRV
  "LookupSRV tries to resolve an SRV query of the given service,\nprotocol, and domain name. The proto is \"tcp\" or \"udp\".\nThe returned records are sorted by priority and randomized\nby weight within a priority.\n\nLookupSRV constructs the DNS name to look up following RFC 2782.\nThat is, it looks up _service._proto.name. To accommodate services\npublishing SRV records under non-standard names, if both service\nand proto are empty strings, LookupSRV looks up name directly.\n\nGo input arguments: (service string, proto string, name string)\n\nGo return type: (cname string, addrs []*SRV, err error)\n\nJoker input arguments: [^String service, ^String proto, ^String name]\n\nJoker return type: [String (vector-of (atom-of go.std.net/SRV)) Error]"
  {:added "1.0"
   :go "__lookupSRV(_service, _proto, _name)"}
  [^String _service, ^String _proto, ^String _name])

JOKER FUNC net.LookupTXT from net/lookup.go:
(defn LookupTXT
  "LookupTXT returns the DNS TXT records for the given domain name.\n\nGo input arguments: (name string)\n\nGo return type: ([]string, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__lookupTXT(_name)"}
  [^String _name])

JOKER FUNC net.ParseCIDR from net/ip.go:
(defn ParseCIDR
  "ParseCIDR parses s as a CIDR notation IP address and prefix length,\nlike \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in\nRFC 4632 and RFC 4291.\n\nIt returns the IP address and the network implied by the IP and\nprefix length.\nFor example, ParseCIDR(\"192.0.2.1/24\") returns the IP address\n192.0.2.1 and the network 192.0.2.0/24.\n\nGo input arguments: (s string)\n\nGo return type: (IP, *IPNet, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [go.std.net/IP (atom-of go.std.net/IPNet) Error]"
  {:added "1.0"
   :go "__parseCIDR(_s)"}
  [^String _s])

JOKER FUNC net.ParseIP from net/ip.go:
(defn ParseIP
  "ParseIP parses s as an IP address, returning the result.\nThe string s can be in dotted decimal (\"192.0.2.1\")\nor IPv6 (\"2001:db8::68\") form.\nIf s is not a valid textual representation of an IP address,\nParseIP returns nil.\n\nGo input arguments: (s string)\n\nGo return type: IP\n\nJoker input arguments: [^String s]\n\nJoker return type: go.std.net/IP"
  {:added "1.0"
   :go "__parseIP(_s)"}
  [^String _s])

JOKER FUNC net.ParseMAC from net/mac.go:
(defn ParseMAC
  "ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet\nIP over InfiniBand link-layer address using one of the following formats:\n  01:23:45:67:89:ab\n  01:23:45:67:89:ab:cd:ef\n  01:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00\n  01-23-45-67-89-ab\n  01-23-45-67-89-ab-cd-ef\n  01-23-45-67-89-ab-cd-ef-00-00-01-23-45-67-89-ab-cd-ef-00-00\n  0123.4567.89ab\n  0123.4567.89ab.cdef\n  0123.4567.89ab.cdef.0000.0123.4567.89ab.cdef.0000\n\nGo input arguments: (s string)\n\nGo return type: (hw HardwareAddr, err error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [go.std.net/HardwareAddr Error]"
  {:added "1.0"
   :go "__parseMAC(_s)"}
  [^String _s])

JOKER FUNC net.Pipe from net/pipe.go:
(defn Pipe
  "Pipe creates a synchronous, in-memory, full duplex\nnetwork connection; both ends implement the Conn interface.\nReads on one end are matched with writes on the other,\ncopying data directly between the two; there is no internal\nbuffering.\n\nGo return type: (Conn, Conn)\n\nJoker input arguments: []\n\nJoker return type: [go.std.net/Conn go.std.net/Conn]"
  {:added "1.0"
   :go "__pipe()"}
  [])

JOKER FUNC net.ResolveIPAddr from net/iprawsock.go:
(defn ResolveIPAddr
  "ResolveIPAddr returns an address of IP end point.\n\nThe network must be an IP network name.\n\nIf the host in the address parameter is not a literal IP address,\nResolveIPAddr resolves the address to an address of IP end point.\nOtherwise, it parses the address as a literal IP address.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*IPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/IPAddr) Error]"
  {:added "1.0"
   :go "__resolveIPAddr(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.ResolveTCPAddr from net/tcpsock.go:
(defn ResolveTCPAddr
  "ResolveTCPAddr returns an address of TCP end point.\n\nThe network must be a TCP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveTCPAddr resolves the\naddress to an address of TCP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*TCPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/TCPAddr) Error]"
  {:added "1.0"
   :go "__resolveTCPAddr(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.ResolveUDPAddr from net/udpsock.go:
(defn ResolveUDPAddr
  "ResolveUDPAddr returns an address of UDP end point.\n\nThe network must be a UDP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveUDPAddr resolves the\naddress to an address of UDP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*UDPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/UDPAddr) Error]"
  {:added "1.0"
   :go "__resolveUDPAddr(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.ResolveUnixAddr from net/unixsock.go:
(defn ResolveUnixAddr
  "ResolveUnixAddr returns an address of Unix domain socket end point.\n\nThe network must be a Unix network name.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*UnixAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/UnixAddr) Error]"
  {:added "1.0"
   :go "__resolveUnixAddr(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.SplitHostPort from net/ipsock.go:
(defn SplitHostPort
  "SplitHostPort splits a network address of the form \"host:port\",\n\"host%zone:port\", \"[host]:port\" or \"[host%zone]:port\" into host or\nhost%zone and port.\n\nA literal IPv6 address in hostport must be enclosed in square\nbrackets, as in \"[::1]:80\", \"[::1%lo0]:80\".\n\nSee func Dial for a description of the hostport parameter, and host\nand port results.\n\nGo input arguments: (hostport string)\n\nGo return type: (host string, port string, err error)\n\nJoker input arguments: [^String hostport]\n\nJoker return type: [String String Error]"
  {:added "1.0"
   :go "__splitHostPort(_hostport)"}
  [^String _hostport])

JOKER TYPE net/http.Client from net/http/client.go:
;; (defn ^"GoObject" Client.
;;   "Constructor for http.Client"
;;   {:added "1.0"
;;    :go "_ConstructClient(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.CloseNotifier from net/http/server.go:
;; (defn ^"GoObject" CloseNotifier.
;;   "Constructor for http.CloseNotifier"
;;   {:added "1.0"
;;    :go "_ConstructCloseNotifier(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.ConnState from net/http/server.go:
(defn ^"GoObject" ConnState.
  "Constructor for http.ConnState"
  {:added "1.0"
   :go "_ConstructConnState(_v)"}
  [^Object _v])

JOKER TYPE net/http.Cookie from net/http/cookie.go:
;; (defn ^"GoObject" Cookie.
;;   "Constructor for http.Cookie"
;;   {:added "1.0"
;;    :go "_ConstructCookie(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.CookieJar from net/http/jar.go:
;; (defn ^"GoObject" CookieJar.
;;   "Constructor for http.CookieJar"
;;   {:added "1.0"
;;    :go "_ConstructCookieJar(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Dir from net/http/fs.go:
(defn ^"GoObject" Dir.
  "Constructor for http.Dir"
  {:added "1.0"
   :go "_ConstructDir(_v)"}
  [^Object _v])

JOKER TYPE net/http.File from net/http/fs.go:
;; (defn ^"GoObject" File.
;;   "Constructor for http.File"
;;   {:added "1.0"
;;    :go "_ConstructFile(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.FileSystem from net/http/fs.go:
;; (defn ^"GoObject" FileSystem.
;;   "Constructor for http.FileSystem"
;;   {:added "1.0"
;;    :go "_ConstructFileSystem(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Flusher from net/http/server.go:
;; (defn ^"GoObject" Flusher.
;;   "Constructor for http.Flusher"
;;   {:added "1.0"
;;    :go "_ConstructFlusher(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Handler from net/http/server.go:
;; (defn ^"GoObject" Handler.
;;   "Constructor for http.Handler"
;;   {:added "1.0"
;;    :go "_ConstructHandler(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.HandlerFunc from net/http/server.go:
;; (defn ^"GoObject" HandlerFunc.
;;   "Constructor for http.HandlerFunc"
;;   {:added "1.0"
;;    :go "_ConstructHandlerFunc(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Header from net/http/header.go:
;; (defn ^"GoObject" Header.
;;   "Constructor for http.Header"
;;   {:added "1.0"
;;    :go "_ConstructHeader(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Hijacker from net/http/server.go:
;; (defn ^"GoObject" Hijacker.
;;   "Constructor for http.Hijacker"
;;   {:added "1.0"
;;    :go "_ConstructHijacker(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.ProtocolError from net/http/request.go:
(defn ^"GoObject" ProtocolError.
  "Constructor for http.ProtocolError"
  {:added "1.0"
   :go "_ConstructProtocolError(_v)"}
  [^Object _v])

JOKER TYPE net/http.PushOptions from net/http/http.go:
;; (defn ^"GoObject" PushOptions.
;;   "Constructor for http.PushOptions"
;;   {:added "1.0"
;;    :go "_ConstructPushOptions(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Pusher from net/http/http.go:
;; (defn ^"GoObject" Pusher.
;;   "Constructor for http.Pusher"
;;   {:added "1.0"
;;    :go "_ConstructPusher(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Request from net/http/request.go:
;; (defn ^"GoObject" Request.
;;   "Constructor for http.Request"
;;   {:added "1.0"
;;    :go "_ConstructRequest(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Response from net/http/response.go:
;; (defn ^"GoObject" Response.
;;   "Constructor for http.Response"
;;   {:added "1.0"
;;    :go "_ConstructResponse(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.ResponseWriter from net/http/server.go:
;; (defn ^"GoObject" ResponseWriter.
;;   "Constructor for http.ResponseWriter"
;;   {:added "1.0"
;;    :go "_ConstructResponseWriter(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.RoundTripper from net/http/client.go:
;; (defn ^"GoObject" RoundTripper.
;;   "Constructor for http.RoundTripper"
;;   {:added "1.0"
;;    :go "_ConstructRoundTripper(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.SameSite from net/http/cookie.go:
(defn ^"GoObject" SameSite.
  "Constructor for http.SameSite"
  {:added "1.0"
   :go "_ConstructSameSite(_v)"}
  [^Object _v])

JOKER TYPE net/http.ServeMux from net/http/server.go:
(defn ^"GoObject" ServeMux.
  "Constructor for http.ServeMux"
  {:added "1.0"
   :go "_ConstructServeMux(_v)"}
  [^Object _v])

JOKER TYPE net/http.Server from net/http/server.go:
;; (defn ^"GoObject" Server.
;;   "Constructor for http.Server"
;;   {:added "1.0"
;;    :go "_ConstructServer(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Transport from net/http/transport.go:
;; (defn ^"GoObject" Transport.
;;   "Constructor for http.Transport"
;;   {:added "1.0"
;;    :go "_ConstructTransport(_v)"}
;;   [^Object _v])

JOKER FUNC net/http.CanonicalHeaderKey from net/http/header.go:
(defn ^"String" CanonicalHeaderKey
  "CanonicalHeaderKey returns the canonical format of the\nheader key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.CanonicalHeaderKey(_s)"}
  [^String _s])

JOKER FUNC net/http.DetectContentType from net/http/sniff.go:
;; (defn ^"String" DetectContentType
;;   "DetectContentType implements the algorithm described\nat https://mimesniff.spec.whatwg.org/ to determine the\nContent-Type of the given data. It considers at most the\nfirst 512 bytes of data. DetectContentType always returns\na valid MIME type: if it cannot determine a more specific one, it\nreturns \"application/octet-stream\".\n\nGo input arguments: (data []byte)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "http.DetectContentType(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC net/http.Error from net/http/server.go:
;; (defn Error
;;   "Error replies to the request with the specified error message and HTTP code.\nIt does not otherwise end the request; the caller should ensure no further\nwrites are done to w.\nThe error message should be plain text.\n\nGo input arguments: (w ResponseWriter, error string, code int)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^String error, ^Int code]"
;;   {:added "1.0"
;;    :go "__error(*_w, _error, _code)"}
;;   [^http/ResponseWriter _w, ^String _error, ^Int _code])

JOKER FUNC net/http.FileServer from net/http/fs.go:
(defn FileServer
  "FileServer returns a handler that serves HTTP requests\nwith the contents of the file system rooted at root.\n\nTo use the operating system's file system implementation,\nuse http.Dir:\n\n    http.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))\n\nAs a special case, the returned file server redirects any request\nending in \"/index.html\" to the same path, without the final\n\"index.html\".\n\nGo input arguments: (root FileSystem)\n\nGo return type: Handler\n\nJoker input arguments: [^go.std.net.http/FileSystem root]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__fileServer(*_root)"}
  [^http/FileSystem _root])

JOKER FUNC net/http.Get from net/http/client.go:
(defn Get
  "Get issues a GET to the specified URL. If the response is one of\nthe following redirect codes, Get follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nAn error is returned if there were too many redirects or if there\nwas an HTTP protocol error. A non-2xx response doesn't cause an\nerror. Any returned error will be of type *url.Error. The url.Error\nvalue's Timeout method will report true if request timed out or was\ncanceled.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nGet is a wrapper around DefaultClient.Get.\n\nTo make a request with custom headers, use NewRequest and\nDefaultClient.Do.\n\nGo input arguments: (url string)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
  {:added "1.0"
   :go "__get(_url)"}
  [^String _url])

JOKER FUNC net/http.Handle from net/http/server.go:
;; (defn Handle
;;   "Handle registers the handler for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler Handler)\n\nJoker input arguments: [^String pattern, ^go.std.net.http/Handler handler]"
;;   {:added "1.0"
;;    :go "__handle(_pattern, *_handler)"}
;;   [^String _pattern, ^http/Handler _handler])

JOKER FUNC net/http.HandleFunc from net/http/server.go:
;; (defn HandleFunc
;;   "HandleFunc registers the handler function for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler func)\n\nJoker input arguments: [^String pattern, ^fn handler]"
;;   {:added "1.0"
;;    :go "__handleFunc(_pattern, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String _pattern, ^fn _handler])

JOKER FUNC net/http.Head from net/http/client.go:
(defn Head
  "Head issues a HEAD to the specified URL. If the response is one of\nthe following redirect codes, Head follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nHead is a wrapper around DefaultClient.Head\n\nGo input arguments: (url string)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
  {:added "1.0"
   :go "__head(_url)"}
  [^String _url])

JOKER FUNC net/http.ListenAndServe from net/http/server.go:
(defn ^"Error" ListenAndServe
  "ListenAndServe listens on the TCP network address addr and then calls\nServe with handler to handle requests on incoming connections.\nAccepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error.\n\nGo input arguments: (addr string, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
  {:added "1.0"
   :go "http.ListenAndServe(_addr, *_handler)"}
  [^String _addr, ^http/Handler _handler])

JOKER FUNC net/http.ListenAndServeTLS from net/http/server.go:
(defn ^"Error" ListenAndServeTLS
  "ListenAndServeTLS acts identically to ListenAndServe, except that it\nexpects HTTPS connections. Additionally, files containing a certificate and\nmatching private key for the server must be provided. If the certificate\nis signed by a certificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nGo input arguments: (addr string, certFile string, keyFile string, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^String certFile, ^String keyFile, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
  {:added "1.0"
   :go "http.ListenAndServeTLS(_addr, _certFile, _keyFile, *_handler)"}
  [^String _addr, ^String _certFile, ^String _keyFile, ^http/Handler _handler])

JOKER FUNC net/http.MaxBytesReader from net/http/request.go:
;; (defn MaxBytesReader
;;   "MaxBytesReader is similar to io.LimitReader but is intended for\nlimiting the size of incoming request bodies. In contrast to\nio.LimitReader, MaxBytesReader's result is a ReadCloser, returns a\nnon-EOF error for a Read beyond the limit, and closes the\nunderlying reader when its Close method is called.\n\nMaxBytesReader prevents clients from accidentally or maliciously\nsending a large request and wasting server resources.\n\nGo input arguments: (w ResponseWriter, r io.ReadCloser, n int64)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^go.std.io/ReadCloser r, ^Int64 n]\n\nJoker return type: ABEND042(post.go: cannot find typename io.ReadCloser)"
;;   {:added "1.0"
;;    :go "__maxBytesReader(*_w, *_r, _n)"}
;;   [^http/ResponseWriter _w, ^io/ReadCloser _r, ^Int64 _n])

JOKER FUNC net/http.NewFileTransport from net/http/filetransport.go:
(defn NewFileTransport
  "NewFileTransport returns a new RoundTripper, serving the provided\nFileSystem. The returned RoundTripper ignores the URL host in its\nincoming requests, as well as most other properties of the\nrequest.\n\nThe typical use case for NewFileTransport is to register the \"file\"\nprotocol with a Transport, as in:\n\n  t := &http.Transport{}\n  t.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))\n  c := &http.Client{Transport: t}\n  res, err := c.Get(\"file:///etc/passwd\")\n  ...\n\nGo input arguments: (fs FileSystem)\n\nGo return type: RoundTripper\n\nJoker input arguments: [^go.std.net.http/FileSystem fs]\n\nJoker return type: go.std.net.http/RoundTripper"
  {:added "1.0"
   :go "__newFileTransport(*_fs)"}
  [^http/FileSystem _fs])

JOKER FUNC net/http.NewRequest from net/http/request.go:
;; (defn NewRequest
;;   "NewRequest returns a new Request given a method, URL, and optional body.\n\nIf the provided body is also an io.Closer, the returned\nRequest.Body is set to body and will be closed by the Client\nmethods Do, Post, and PostForm, and Transport.RoundTrip.\n\nNewRequest returns a Request suitable for use with Client.Do or\nTransport.RoundTrip. To create a request for use with testing a\nServer Handler, either use the NewRequest function in the\nnet/http/httptest package, use ReadRequest, or manually update the\nRequest fields. See the Request type's documentation for the\ndifference between inbound and outbound request fields.\n\nIf body is of type *bytes.Buffer, *bytes.Reader, or\n*strings.Reader, the returned request's ContentLength is set to its\nexact value (instead of -1), GetBody is populated (so 307 and 308\nredirects can replay the body), and Body is set to NoBody if the\nContentLength is 0.\n\nGo input arguments: (method string, url string, body io.Reader)\n\nGo return type: (*Request, error)\n\nJoker input arguments: [^String method, ^String url, ^go.std.io/Reader body]\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
;;   {:added "1.0"
;;    :go "__newRequest(_method, _url, *_body)"}
;;   [^String _method, ^String _url, ^io/Reader _body])

JOKER FUNC net/http.NewServeMux from net/http/server.go:
(defn NewServeMux
  "NewServeMux allocates and returns a new ServeMux.\n\nGo return type: *ServeMux\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.net.http/ServeMux)"
  {:added "1.0"
   :go "__newServeMux()"}
  [])

JOKER FUNC net/http.NotFound from net/http/server.go:
;; (defn NotFound
;;   "NotFound replies to the request with an HTTP 404 not found error.\n\nGo input arguments: (w ResponseWriter, r *Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__notFound(*_w, _r)"}
;;   [^http/ResponseWriter _w, ^http/Request _r])

JOKER FUNC net/http.NotFoundHandler from net/http/server.go:
(defn NotFoundHandler
  "NotFoundHandler returns a simple request handler\nthat replies to each request with a ``404 page not found'' reply.\n\nGo return type: Handler\n\nJoker input arguments: []\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__notFoundHandler()"}
  [])

JOKER FUNC net/http.ParseHTTPVersion from net/http/request.go:
(defn ParseHTTPVersion
  "ParseHTTPVersion parses a HTTP version string.\n\"HTTP/1.0\" returns (1, 0, true).\n\nGo input arguments: (vers string)\n\nGo return type: (major int, minor int, ok bool)\n\nJoker input arguments: [^String vers]\n\nJoker return type: [Int Int Boolean]"
  {:added "1.0"
   :go "__parseHTTPVersion(_vers)"}
  [^String _vers])

JOKER FUNC net/http.ParseTime from net/http/header.go:
;; (defn ParseTime
;;   "ParseTime parses a time header (such as the Date: header),\ntrying each of the three formats allowed by HTTP/1.1:\nTimeFormat, time.RFC850, and time.ANSIC.\n\nGo input arguments: (text string)\n\nGo return type: (t ..., err error)\n\nJoker input arguments: [^String text]\n\nJoker return type: [ABEND042(post.go: cannot find typename time.Time) Error]"
;;   {:added "1.0"
;;    :go "__parseTime(_text)"}
;;   [^String _text])

JOKER FUNC net/http.Post from net/http/client.go:
;; (defn Post
;;   "Post issues a POST to the specified URL.\n\nCaller should close resp.Body when done reading from it.\n\nIf the provided body is an io.Closer, it is closed after the\nrequest.\n\nPost is a wrapper around DefaultClient.Post.\n\nTo set custom headers, use NewRequest and DefaultClient.Do.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, contentType string, body io.Reader)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^String contentType, ^go.std.io/Reader body]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
;;   {:added "1.0"
;;    :go "__post(_url, _contentType, *_body)"}
;;   [^String _url, ^String _contentType, ^io/Reader _body])

JOKER FUNC net/http.PostForm from net/http/client.go:
;; (defn PostForm
;;   "PostForm issues a POST to the specified URL, with data's keys and\nvalues URL-encoded as the request body.\n\nThe Content-Type header is set to application/x-www-form-urlencoded.\nTo set other headers, use NewRequest and DefaultClient.Do.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nPostForm is a wrapper around DefaultClient.PostForm.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, data url.Values)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^go.std.net.url/Values data]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
;;   {:added "1.0"
;;    :go "__postForm(_url, *_data)"}
;;   [^String _url, ^url/Values _data])

JOKER FUNC net/http.ProxyFromEnvironment from net/http/transport.go:
(defn ProxyFromEnvironment
  "ProxyFromEnvironment returns the URL of the proxy to use for a\ngiven request, as indicated by the environment variables\nHTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions\nthereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https\nrequests.\n\nThe environment values may be either a complete URL or a\n\"host[:port]\", in which case the \"http\" scheme is assumed.\nAn error is returned if the value is a different form.\n\nA nil URL and nil error are returned if no proxy is defined in the\nenvironment, or a proxy should not be used for the given request,\nas defined by NO_PROXY.\n\nAs a special case, if req.URL.Host is \"localhost\" (with or without\na port number), then a nil URL and nil error will be returned.\n\nGo input arguments: (req *Request)\n\nGo return type: (*net/url.URL, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req]\n\nJoker return type: [(atom-of go.std.net.url/URL) Error]"
  {:added "1.0"
   :go "__proxyFromEnvironment(_req)"}
  [^http/Request _req])

JOKER FUNC net/http.ProxyURL from net/http/transport.go:
;; (defn ProxyURL
;;   "ProxyURL returns a proxy function (for use in a Transport)\nthat always returns the same URL.\n\nGo input arguments: (fixedURL *url.URL)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of go.std.net.url/URL) fixedURL]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/transport.go:351:34)"
;;   {:added "1.0"
;;    :go "__proxyURL(_fixedURL)"}
;;   [^url/URL _fixedURL])

JOKER FUNC net/http.ReadRequest from net/http/request.go:
;; (defn ReadRequest
;;   "ReadRequest reads and parses an incoming request from b.\n\nReadRequest is a low-level function and should only be used for\nspecialized applications; most code should use the Server to read\nrequests and handle them via the Handler interface. ReadRequest\nonly supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.\n\nGo input arguments: (b *bufio.Reader)\n\nGo return type: (*Request, error)\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) b]\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
;;   {:added "1.0"
;;    :go "__readRequest(_b)"}
;;   [^bufio/Reader _b])

JOKER FUNC net/http.ReadResponse from net/http/response.go:
;; (defn ReadResponse
;;   "ReadResponse reads and returns an HTTP response from r.\nThe req parameter optionally specifies the Request that corresponds\nto this Response. If nil, a GET request is assumed.\nClients must call resp.Body.Close when finished reading resp.Body.\nAfter that call, clients can inspect resp.Trailer to find key/value\npairs included in the response trailer.\n\nGo input arguments: (r *bufio.Reader, req *Request)\n\nGo return type: (*Response, error)\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) r, ^(atom-of go.std.net.http/Request) req]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
;;   {:added "1.0"
;;    :go "__readResponse(_r, _req)"}
;;   [^bufio/Reader _r, ^http/Request _req])

JOKER FUNC net/http.Redirect from net/http/server.go:
;; (defn Redirect
;;   "Redirect replies to the request with a redirect to url,\nwhich may be a path relative to the request path.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nIf the Content-Type header has not been set, Redirect sets it\nto \"text/html; charset=utf-8\" and writes a small HTML body.\nSetting the Content-Type header to any value, including nil,\ndisables that behavior.\n\nGo input arguments: (w ResponseWriter, r *Request, url string, code int)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r, ^String url, ^Int code]"
;;   {:added "1.0"
;;    :go "__redirect(*_w, _r, _url, _code)"}
;;   [^http/ResponseWriter _w, ^http/Request _r, ^String _url, ^Int _code])

JOKER FUNC net/http.RedirectHandler from net/http/server.go:
(defn RedirectHandler
  "RedirectHandler returns a request handler that redirects\neach request it receives to the given url using the given\nstatus code.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nGo input arguments: (url string, code int)\n\nGo return type: Handler\n\nJoker input arguments: [^String url, ^Int code]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__redirectHandler(_url, _code)"}
  [^String _url, ^Int _code])

JOKER FUNC net/http.Serve from net/http/server.go:
;; (defn ^"Error" Serve
;;   "Serve accepts incoming HTTP connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nHTTP/2 support is only enabled if the Listener returns *tls.Conn\nconnections and they were configured with \"h2\" in the TLS\nConfig.NextProtos.\n\nServe always returns a non-nil error.\n\nGo input arguments: (l net.Listener, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.Serve(*_l, *_handler)"}
;;   [^net/Listener _l, ^http/Handler _handler])

JOKER FUNC net/http.ServeContent from net/http/fs.go:
;; (defn ServeContent
;;   "ServeContent replies to the request using the content in the\nprovided ReadSeeker. The main benefit of ServeContent over io.Copy\nis that it handles Range requests properly, sets the MIME type, and\nhandles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,\nand If-Range requests.\n\nIf the response's Content-Type header is not set, ServeContent\nfirst tries to deduce the type from name's file extension and,\nif that fails, falls back to reading the first block of the content\nand passing it to DetectContentType.\nThe name is otherwise unused; in particular it can be empty and is\nnever sent in the response.\n\nIf modtime is not the zero time or Unix epoch, ServeContent\nincludes it in a Last-Modified header in the response. If the\nrequest includes an If-Modified-Since header, ServeContent uses\nmodtime to decide whether the content needs to be sent at all.\n\nThe content's Seek method must work: ServeContent uses\na seek to the end of the content to determine its size.\n\nIf the caller has set w's ETag header formatted per RFC 7232, section 2.3,\nServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.\n\nNote that *os.File implements the io.ReadSeeker interface.\n\nGo input arguments: (w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) req, ^String name, ^go.std.time/Time modtime, ^go.std.io/ReadSeeker content]"
;;   {:added "1.0"
;;    :go "__serveContent(*_w, _req, _name, *_modtime, *_content)"}
;;   [^http/ResponseWriter _w, ^http/Request _req, ^String _name, ^time/Time _modtime, ^io/ReadSeeker _content])

JOKER FUNC net/http.ServeFile from net/http/fs.go:
;; (defn ServeFile
;;   "ServeFile replies to the request with the contents of the named\nfile or directory.\n\nIf the provided file or directory name is a relative path, it is\ninterpreted relative to the current directory and may ascend to\nparent directories. If the provided name is constructed from user\ninput, it should be sanitized before calling ServeFile.\n\nAs a precaution, ServeFile will reject requests where r.URL.Path\ncontains a \"..\" path element; this protects against callers who\nmight unsafely use filepath.Join on r.URL.Path without sanitizing\nit and then use that filepath.Join result as the name argument.\n\nAs another special case, ServeFile redirects any request where r.URL.Path\nends in \"/index.html\" to the same path, without the final\n\"index.html\". To avoid such redirects either modify the path or\nuse ServeContent.\n\nOutside of those two special cases, ServeFile does not use\nr.URL.Path for selecting the file or directory to serve; only the\nfile or directory provided in the name argument is used.\n\nGo input arguments: (w ResponseWriter, r *Request, name string)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r, ^String name]"
;;   {:added "1.0"
;;    :go "__serveFile(*_w, _r, _name)"}
;;   [^http/ResponseWriter _w, ^http/Request _r, ^String _name])

JOKER FUNC net/http.ServeTLS from net/http/server.go:
;; (defn ^"Error" ServeTLS
;;   "ServeTLS accepts incoming HTTPS connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nAdditionally, files containing a certificate and matching private key\nfor the server must be provided. If the certificate is signed by a\ncertificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nServeTLS always returns a non-nil error.\n\nGo input arguments: (l net.Listener, handler Handler, certFile string, keyFile string)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler, ^String certFile, ^String keyFile]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.ServeTLS(*_l, *_handler, _certFile, _keyFile)"}
;;   [^net/Listener _l, ^http/Handler _handler, ^String _certFile, ^String _keyFile])

JOKER FUNC net/http.SetCookie from net/http/cookie.go:
;; (defn SetCookie
;;   "SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.\nThe provided cookie must have a valid Name. Invalid cookies may be\nsilently dropped.\n\nGo input arguments: (w ResponseWriter, cookie *Cookie)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Cookie) cookie]"
;;   {:added "1.0"
;;    :go "__setCookie(*_w, _cookie)"}
;;   [^http/ResponseWriter _w, ^http/Cookie _cookie])

JOKER FUNC net/http.StatusText from net/http/status.go:
(defn ^"String" StatusText
  "StatusText returns a text for the HTTP status code. It returns the empty\nstring if the code is unknown.\n\nGo input arguments: (code int)\n\nGo return type: string\n\nJoker input arguments: [^Int code]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.StatusText(_code)"}
  [^Int _code])

JOKER FUNC net/http.StripPrefix from net/http/server.go:
(defn StripPrefix
  "StripPrefix returns a handler that serves HTTP requests\nby removing the given prefix from the request URL's Path\nand invoking the handler h. StripPrefix handles a\nrequest for a path that doesn't begin with prefix by\nreplying with an HTTP 404 not found error.\n\nGo input arguments: (prefix string, h Handler)\n\nGo return type: Handler\n\nJoker input arguments: [^String prefix, ^go.std.net.http/Handler h]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__stripPrefix(_prefix, *_h)"}
  [^String _prefix, ^http/Handler _h])

JOKER FUNC net/http.TimeoutHandler from net/http/server.go:
;; (defn TimeoutHandler
;;   "TimeoutHandler returns a Handler that runs h with the given time limit.\n\nThe new Handler calls h.ServeHTTP to handle each request, but if a\ncall runs for longer than its time limit, the handler responds with\na 503 Service Unavailable error and the given message in its body.\n(If msg is empty, a suitable default message will be sent.)\nAfter such a timeout, writes by h to its ResponseWriter will return\nErrHandlerTimeout.\n\nTimeoutHandler buffers all Handler writes to memory and does not\nsupport the Hijacker or Flusher interfaces.\n\nGo input arguments: (h Handler, dt time.Duration, msg string)\n\nGo return type: Handler\n\nJoker input arguments: [^go.std.net.http/Handler h, ^go.std.time/Duration dt, ^String msg]\n\nJoker return type: go.std.net.http/Handler"
;;   {:added "1.0"
;;    :go "__timeoutHandler(*_h, *_dt, _msg)"}
;;   [^http/Handler _h, ^time/Duration _dt, ^String _msg])

JOKER TYPE net/http/cgi.Handler from net/http/cgi/host.go:
;; (defn ^"GoObject" Handler.
;;   "Constructor for cgi.Handler"
;;   {:added "1.0"
;;    :go "_ConstructHandler(_v)"}
;;   [^Object _v])

JOKER FUNC net/http/cgi.Request from net/http/cgi/child.go:
(defn Request
  "Request returns the HTTP request as represented in the current\nenvironment. This assumes the current program is being run\nby a web server in a CGI environment.\nThe returned Request's Body is populated, if applicable.\n\nGo return type: (*net/http.Request, error)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
  {:added "1.0"
   :go "__request()"}
  [])

JOKER FUNC net/http/cgi.RequestFromMap from net/http/cgi/child.go:
;; (defn RequestFromMap
;;   "RequestFromMap creates an http.Request from CGI variables.\nThe returned Request's Body field is not populated.\n\nGo input arguments: (params map[])\n\nGo return type: (*net/http.Request, error)\n\nJoker input arguments: [^{} params]\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
;;   {:added "1.0"
;;    :go "__requestFromMap(ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa()))"}
;;   [^{} _params])

JOKER FUNC net/http/cgi.Serve from net/http/cgi/child.go:
;; (defn ^"Error" Serve
;;   "Serve executes the provided Handler on the currently active CGI\nrequest, if any. If there's no current CGI environment\nan error is returned. The provided handler may be nil to use\nhttp.DefaultServeMux.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "cgi.Serve(*_handler)"}
;;   [^http/Handler _handler])

JOKER TYPE net/http/cookiejar.Jar from net/http/cookiejar/jar.go:
(defn ^"GoObject" Jar.
  "Constructor for cookiejar.Jar"
  {:added "1.0"
   :go "_ConstructJar(_v)"}
  [^Object _v])

JOKER TYPE net/http/cookiejar.Options from net/http/cookiejar/jar.go:
;; (defn ^"GoObject" Options.
;;   "Constructor for cookiejar.Options"
;;   {:added "1.0"
;;    :go "_ConstructOptions(_v)"}
;;   [^Object _v])

JOKER TYPE net/http/cookiejar.PublicSuffixList from net/http/cookiejar/jar.go:
;; (defn ^"GoObject" PublicSuffixList.
;;   "Constructor for cookiejar.PublicSuffixList"
;;   {:added "1.0"
;;    :go "_ConstructPublicSuffixList(_v)"}
;;   [^Object _v])

JOKER FUNC net/http/cookiejar.New from net/http/cookiejar/jar.go:
(defn New
  "New returns a new cookie jar. A nil *Options is equivalent to a zero\nOptions.\n\nGo input arguments: (o *Options)\n\nGo return type: (*Jar, error)\n\nJoker input arguments: [^(atom-of go.std.net.http.cookiejar/Options) o]\n\nJoker return type: [(atom-of go.std.net.http.cookiejar/Jar) Error]"
  {:added "1.0"
   :go "__new(_o)"}
  [^cookiejar/Options _o])

JOKER FUNC net/http/fcgi.ProcessEnv from net/http/fcgi/child.go:
;; (defn ProcessEnv
;;   "ProcessEnv returns FastCGI environment variables associated with the request r\nfor which no effort was made to be included in the request itself - the data\nis hidden in the request's context. As an example, if REMOTE_USER is set for a\nrequest, it will not be found anywhere in r, but it will be included in\nProcessEnv's response (via r's context).\n\nGo input arguments: (r *http.Request)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) r]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/fcgi/child.go:358:34)"
;;   {:added "1.0"
;;    :go "__processEnv(_r)"}
;;   [^http/Request _r])

JOKER FUNC net/http/fcgi.Serve from net/http/fcgi/child.go:
;; (defn ^"Error" Serve
;;   "Serve accepts incoming FastCGI connections on the listener l, creating a new\ngoroutine for each. The goroutine reads requests and then calls handler\nto reply to them.\nIf l is nil, Serve accepts connections from os.Stdin.\nIf handler is nil, http.DefaultServeMux is used.\n\nGo input arguments: (l net.Listener, handler http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "fcgi.Serve(*_l, *_handler)"}
;;   [^net/Listener _l, ^http/Handler _handler])

JOKER TYPE net/http/httptest.ResponseRecorder from net/http/httptest/recorder.go:
;; (defn ^"GoObject" ResponseRecorder.
;;   "Constructor for httptest.ResponseRecorder"
;;   {:added "1.0"
;;    :go "_ConstructResponseRecorder(_v)"}
;;   [^Object _v])

JOKER TYPE net/http/httptest.Server from net/http/httptest/server.go:
;; (defn ^"GoObject" Server.
;;   "Constructor for httptest.Server"
;;   {:added "1.0"
;;    :go "_ConstructServer(_v)"}
;;   [^Object _v])

JOKER FUNC net/http/httptest.NewRecorder from net/http/httptest/recorder.go:
(defn NewRecorder
  "NewRecorder returns an initialized ResponseRecorder.\n\nGo return type: *ResponseRecorder\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.net.http.httptest/ResponseRecorder)"
  {:added "1.0"
   :go "__newRecorder()"}
  [])

JOKER FUNC net/http/httptest.NewRequest from net/http/httptest/httptest.go:
;; (defn NewRequest
;;   "NewRequest returns a new incoming server Request, suitable\nfor passing to an http.Handler for testing.\n\nThe target is the RFC 7230 \"request-target\": it may be either a\npath or an absolute URL. If target is an absolute URL, the host name\nfrom the URL is used. Otherwise, \"example.com\" is used.\n\nThe TLS field is set to a non-nil dummy value if target has scheme\n\"https\".\n\nThe Request.Proto is always HTTP/1.1.\n\nAn empty method means \"GET\".\n\nThe provided body may be nil. If the body is of type *bytes.Reader,\n*strings.Reader, or *bytes.Buffer, the Request.ContentLength is\nset.\n\nNewRequest panics on error for ease of use in testing, where a\npanic is acceptable.\n\nTo generate a client HTTP request instead of a server request, see\nthe NewRequest function in the net/http package.\n\nGo input arguments: (method string, target string, body io.Reader)\n\nGo return type: *net/http.Request\n\nJoker input arguments: [^String method, ^String target, ^go.std.io/Reader body]\n\nJoker return type: (atom-of go.std.net.http/Request)"
;;   {:added "1.0"
;;    :go "__newRequest(_method, _target, *_body)"}
;;   [^String _method, ^String _target, ^io/Reader _body])

JOKER FUNC net/http/httptest.NewServer from net/http/httptest/server.go:
;; (defn NewServer
;;   "NewServer starts and returns a new Server.\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: (atom-of go.std.net.http.httptest/Server)"
;;   {:added "1.0"
;;    :go "__newServer(*_handler)"}
;;   [^http/Handler _handler])

JOKER FUNC net/http/httptest.NewTLSServer from net/http/httptest/server.go:
;; (defn NewTLSServer
;;   "NewTLSServer starts and returns a new Server using TLS.\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: (atom-of go.std.net.http.httptest/Server)"
;;   {:added "1.0"
;;    :go "__newTLSServer(*_handler)"}
;;   [^http/Handler _handler])

JOKER FUNC net/http/httptest.NewUnstartedServer from net/http/httptest/server.go:
;; (defn NewUnstartedServer
;;   "NewUnstartedServer returns a new Server but doesn't start it.\n\nAfter changing its configuration, the caller should call Start or\nStartTLS.\n\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: (atom-of go.std.net.http.httptest/Server)"
;;   {:added "1.0"
;;    :go "__newUnstartedServer(*_handler)"}
;;   [^http/Handler _handler])

JOKER FUNC net/http/httptrace.ContextClientTrace from net/http/httptrace/trace.go:
;; (defn ContextClientTrace
;;   "ContextClientTrace returns the ClientTrace associated with the\nprovided context. If none, it returns nil.\n\nGo input arguments: (ctx context.Context)\n\nGo return type: *ClientTrace\n\nJoker input arguments: [^go.std.context/Context ctx]\n\nJoker return type: (atom-of go.std.net.http.httptrace/ClientTrace)"
;;   {:added "1.0"
;;    :go "__contextClientTrace(*_ctx)"}
;;   [^context/Context _ctx])

JOKER FUNC net/http/httptrace.WithClientTrace from net/http/httptrace/trace.go:
;; (defn WithClientTrace
;;   "WithClientTrace returns a new context based on the provided parent\nctx. HTTP client requests made with the returned context will use\nthe provided trace hooks, in addition to any previous hooks\nregistered with ctx. Any hooks defined in the provided trace will\nbe called first.\n\nGo input arguments: (ctx context.Context, trace *ClientTrace)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.context/Context ctx, ^(atom-of go.std.net.http.httptrace/ClientTrace) trace]\n\nJoker return type: ABEND042(post.go: cannot find typename context.Context)"
;;   {:added "1.0"
;;    :go "__withClientTrace(*_ctx, _trace)"}
;;   [^context/Context _ctx, ^httptrace/ClientTrace _trace])

JOKER FUNC net/http/httputil.DumpRequest from net/http/httputil/dump.go:
;; (defn DumpRequest
;;   "DumpRequest returns the given request in its HTTP/1.x wire\nrepresentation. It should only be used by servers to debug client\nrequests. The returned representation is an approximation only;\nsome details of the initial request are lost while parsing it into\nan http.Request. In particular, the order and case of header field\nnames are lost. The order of values in multi-valued headers is kept\nintact. HTTP/2 requests are dumped in HTTP/1.x form, not in their\noriginal binary representations.\n\nIf body is true, DumpRequest also returns the body. To do so, it\nconsumes req.Body and then replaces it with a new io.ReadCloser\nthat yields the same bytes. If DumpRequest returns an error,\nthe state of req is undefined.\n\nThe documentation for http.Request.Write details which fields\nof req are included in the dump.\n\nGo input arguments: (req *http.Request, body bool)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req, ^Boolean body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__dumpRequest(_req, _body)"}
;;   [^http/Request _req, ^Boolean _body])

JOKER FUNC net/http/httputil.DumpRequestOut from net/http/httputil/dump.go:
;; (defn DumpRequestOut
;;   "DumpRequestOut is like DumpRequest but for outgoing client requests. It\nincludes any headers that the standard http.Transport adds, such as\nUser-Agent.\n\nGo input arguments: (req *http.Request, body bool)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req, ^Boolean body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__dumpRequestOut(_req, _body)"}
;;   [^http/Request _req, ^Boolean _body])

JOKER FUNC net/http/httputil.DumpResponse from net/http/httputil/dump.go:
;; (defn DumpResponse
;;   "DumpResponse is like DumpRequest but dumps a response.\n\nGo input arguments: (resp *http.Response, body bool)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Response) resp, ^Boolean body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__dumpResponse(_resp, _body)"}
;;   [^http/Response _resp, ^Boolean _body])

JOKER FUNC net/http/httputil.NewChunkedReader from net/http/httputil/httputil.go:
;; (defn NewChunkedReader
;;   "NewChunkedReader returns a new chunkedReader that translates the data read from r\nout of HTTP \"chunked\" format before returning it.\nThe chunkedReader returns io.EOF when the final 0-length chunk is read.\n\nNewChunkedReader is not needed by normal applications. The http package\nautomatically decodes chunking when reading response bodies.\n\nGo input arguments: (r io.Reader)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: ABEND042(post.go: cannot find typename io.Reader)"
;;   {:added "1.0"
;;    :go "__newChunkedReader(*_r)"}
;;   [^io/Reader _r])

JOKER FUNC net/http/httputil.NewChunkedWriter from net/http/httputil/httputil.go:
;; (defn NewChunkedWriter
;;   "NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP\n\"chunked\" format before writing them to w. Closing the returned chunkedWriter\nsends the final 0-length chunk that marks the end of the stream but does\nnot send the final CRLF that appears after trailers; trailers and the last\nCRLF must be written separately.\n\nNewChunkedWriter is not needed by normal applications. The http\npackage adds chunking automatically if handlers don't set a\nContent-Length header. Using NewChunkedWriter inside a handler\nwould result in double chunking or chunking with a Content-Length\nlength, both of which are wrong.\n\nGo input arguments: (w io.Writer)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: ABEND042(post.go: cannot find typename io.WriteCloser)"
;;   {:added "1.0"
;;    :go "__newChunkedWriter(*_w)"}
;;   [^io/Writer _w])

JOKER FUNC net/http/httputil.NewClientConn from net/http/httputil/persist.go:
;; (defn NewClientConn
;;   "NewClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo input arguments: (c net.Conn, r *bufio.Reader)\n\nGo return type: *ClientConn\n\nJoker input arguments: [^go.std.net/Conn c, ^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.http.httputil/ClientConn)"
;;   {:added "1.0"
;;    :go "__newClientConn(*_c, _r)"}
;;   [^net/Conn _c, ^bufio/Reader _r])

JOKER FUNC net/http/httputil.NewProxyClientConn from net/http/httputil/persist.go:
;; (defn NewProxyClientConn
;;   "NewProxyClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo input arguments: (c net.Conn, r *bufio.Reader)\n\nGo return type: *ClientConn\n\nJoker input arguments: [^go.std.net/Conn c, ^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.http.httputil/ClientConn)"
;;   {:added "1.0"
;;    :go "__newProxyClientConn(*_c, _r)"}
;;   [^net/Conn _c, ^bufio/Reader _r])

JOKER FUNC net/http/httputil.NewServerConn from net/http/httputil/persist.go:
;; (defn NewServerConn
;;   "NewServerConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Server in package net/http instead.\n\nGo input arguments: (c net.Conn, r *bufio.Reader)\n\nGo return type: *ServerConn\n\nJoker input arguments: [^go.std.net/Conn c, ^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.http.httputil/ServerConn)"
;;   {:added "1.0"
;;    :go "__newServerConn(*_c, _r)"}
;;   [^net/Conn _c, ^bufio/Reader _r])

JOKER FUNC net/http/httputil.NewSingleHostReverseProxy from net/http/httputil/reverseproxy.go:
;; (defn NewSingleHostReverseProxy
;;   "NewSingleHostReverseProxy returns a new ReverseProxy that routes\nURLs to the scheme, host, and base path provided in target. If the\ntarget's path is \"/base\" and the incoming request was for \"/dir\",\nthe target request will be for /base/dir.\nNewSingleHostReverseProxy does not rewrite the Host header.\nTo rewrite Host headers, use ReverseProxy directly with a custom\nDirector policy.\n\nGo input arguments: (target *url.URL)\n\nGo return type: *ReverseProxy\n\nJoker input arguments: [^(atom-of go.std.net.url/URL) target]\n\nJoker return type: (atom-of go.std.net.http.httputil/ReverseProxy)"
;;   {:added "1.0"
;;    :go "__newSingleHostReverseProxy(_target)"}
;;   [^url/URL _target])

JOKER FUNC net/http/pprof.Cmdline from net/http/pprof/pprof.go:
;; (defn Cmdline
;;   "Cmdline responds with the running program's\ncommand line, with arguments separated by NUL bytes.\nThe package initialization registers it as /debug/pprof/cmdline.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__cmdline(*_w, _r)"}
;;   [^http/ResponseWriter _w, ^http/Request _r])

JOKER FUNC net/http/pprof.Handler from net/http/pprof/pprof.go:
(defn Handler
  "Handler returns an HTTP handler that serves the named profile.\n\nGo input arguments: (name string)\n\nGo return type: net/http.Handler\n\nJoker input arguments: [^String name]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__handler(_name)"}
  [^String _name])

JOKER FUNC net/http/pprof.Index from net/http/pprof/pprof.go:
;; (defn Index
;;   "Index responds with the pprof-formatted profile named by the request.\nFor example, \"/debug/pprof/heap\" serves the \"heap\" profile.\nIndex responds to a request for \"/debug/pprof/\" with an HTML page\nlisting the available profiles.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__index(*_w, _r)"}
;;   [^http/ResponseWriter _w, ^http/Request _r])

JOKER FUNC net/http/pprof.Profile from net/http/pprof/pprof.go:
;; (defn Profile
;;   "Profile responds with the pprof-formatted cpu profile.\nProfiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.\nThe package initialization registers it as /debug/pprof/profile.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__profile(*_w, _r)"}
;;   [^http/ResponseWriter _w, ^http/Request _r])

JOKER FUNC net/http/pprof.Symbol from net/http/pprof/pprof.go:
;; (defn Symbol
;;   "Symbol looks up the program counters listed in the request,\nresponding with a table mapping program counters to function names.\nThe package initialization registers it as /debug/pprof/symbol.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__symbol(*_w, _r)"}
;;   [^http/ResponseWriter _w, ^http/Request _r])

JOKER FUNC net/http/pprof.Trace from net/http/pprof/pprof.go:
;; (defn Trace
;;   "Trace responds with the execution trace in binary form.\nTracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.\nThe package initialization registers it as /debug/pprof/trace.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__trace(*_w, _r)"}
;;   [^http/ResponseWriter _w, ^http/Request _r])

JOKER TYPE net/mail.Address from net/mail/message.go:
(defn ^"GoObject" Address.
  "Constructor for mail.Address"
  {:added "1.0"
   :go "_ConstructAddress(_v)"}
  [^Object _v])

JOKER TYPE net/mail.AddressParser from net/mail/message.go:
;; (defn ^"GoObject" AddressParser.
;;   "Constructor for mail.AddressParser"
;;   {:added "1.0"
;;    :go "_ConstructAddressParser(_v)"}
;;   [^Object _v])

JOKER TYPE net/mail.Header from net/mail/message.go:
;; (defn ^"GoObject" Header.
;;   "Constructor for mail.Header"
;;   {:added "1.0"
;;    :go "_ConstructHeader(_v)"}
;;   [^Object _v])

JOKER TYPE net/mail.Message from net/mail/message.go:
;; (defn ^"GoObject" Message.
;;   "Constructor for mail.Message"
;;   {:added "1.0"
;;    :go "_ConstructMessage(_v)"}
;;   [^Object _v])

JOKER FUNC net/mail.ParseAddress from net/mail/message.go:
(defn ParseAddress
  "Parses a single RFC 5322 address, e.g. \"Barry Gibbs <bg@example.com>\"\n\nGo input arguments: (address string)\n\nGo return type: (*Address, error)\n\nJoker input arguments: [^String address]\n\nJoker return type: [(atom-of go.std.net.mail/Address) Error]"
  {:added "1.0"
   :go "__parseAddress(_address)"}
  [^String _address])

JOKER FUNC net/mail.ParseAddressList from net/mail/message.go:
(defn ParseAddressList
  "ParseAddressList parses the given string as a list of addresses.\n\nGo input arguments: (list string)\n\nGo return type: ([]*Address, error)\n\nJoker input arguments: [^String list]\n\nJoker return type: [(vector-of (atom-of go.std.net.mail/Address)) Error]"
  {:added "1.0"
   :go "__parseAddressList(_list)"}
  [^String _list])

JOKER FUNC net/mail.ParseDate from net/mail/message.go:
;; (defn ParseDate
;;   "ParseDate parses an RFC 5322 date string.\n\nGo input arguments: (date string)\n\nGo return type: (..., error)\n\nJoker input arguments: [^String date]\n\nJoker return type: [ABEND042(post.go: cannot find typename time.Time) Error]"
;;   {:added "1.0"
;;    :go "__parseDate(_date)"}
;;   [^String _date])

JOKER FUNC net/mail.ReadMessage from net/mail/message.go:
;; (defn ReadMessage
;;   "ReadMessage reads a message from r.\nThe headers are parsed, and the body of the message will be available\nfor reading from msg.Body.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (msg *Message, err error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [(atom-of go.std.net.mail/Message) Error]"
;;   {:added "1.0"
;;    :go "__readMessage(*_r)"}
;;   [^io/Reader _r])

JOKER TYPE net/rpc.Call from net/rpc/client.go:
;; (defn ^"GoObject" Call.
;;   "Constructor for rpc.Call"
;;   {:added "1.0"
;;    :go "_ConstructCall(_v)"}
;;   [^Object _v])

JOKER TYPE net/rpc.Client from net/rpc/client.go:
(defn ^"GoObject" Client.
  "Constructor for rpc.Client"
  {:added "1.0"
   :go "_ConstructClient(_v)"}
  [^Object _v])

JOKER TYPE net/rpc.ClientCodec from net/rpc/client.go:
;; (defn ^"GoObject" ClientCodec.
;;   "Constructor for rpc.ClientCodec"
;;   {:added "1.0"
;;    :go "_ConstructClientCodec(_v)"}
;;   [^Object _v])

JOKER TYPE net/rpc.Request from net/rpc/server.go:
(defn ^"GoObject" Request.
  "Constructor for rpc.Request"
  {:added "1.0"
   :go "_ConstructRequest(_v)"}
  [^Object _v])

JOKER TYPE net/rpc.Response from net/rpc/server.go:
(defn ^"GoObject" Response.
  "Constructor for rpc.Response"
  {:added "1.0"
   :go "_ConstructResponse(_v)"}
  [^Object _v])

JOKER TYPE net/rpc.Server from net/rpc/server.go:
(defn ^"GoObject" Server.
  "Constructor for rpc.Server"
  {:added "1.0"
   :go "_ConstructServer(_v)"}
  [^Object _v])

JOKER TYPE net/rpc.ServerCodec from net/rpc/server.go:
;; (defn ^"GoObject" ServerCodec.
;;   "Constructor for rpc.ServerCodec"
;;   {:added "1.0"
;;    :go "_ConstructServerCodec(_v)"}
;;   [^Object _v])

JOKER TYPE net/rpc.ServerError from net/rpc/client.go:
(defn ^"GoObject" ServerError.
  "Constructor for rpc.ServerError"
  {:added "1.0"
   :go "_ConstructServerError(_v)"}
  [^Object _v])

JOKER FUNC net/rpc.Accept from net/rpc/server.go:
;; (defn Accept
;;   "Accept accepts connections on the listener and serves requests\nto DefaultServer for each incoming connection.\nAccept blocks; the caller typically invokes it in a go statement.\n\nGo input arguments: (lis net.Listener)\n\nJoker input arguments: [^go.std.net/Listener lis]"
;;   {:added "1.0"
;;    :go "__accept(*_lis)"}
;;   [^net/Listener _lis])

JOKER FUNC net/rpc.Dial from net/rpc/client.go:
(defn Dial
  "Dial connects to an RPC server at the specified network address.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dial(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net/rpc.DialHTTP from net/rpc/client.go:
(defn DialHTTP
  "DialHTTP connects to an HTTP RPC server at the specified network address\nlistening on the default HTTP RPC path.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dialHTTP(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net/rpc.DialHTTPPath from net/rpc/client.go:
(defn DialHTTPPath
  "DialHTTPPath connects to an HTTP RPC server\nat the specified network address and path.\n\nGo input arguments: (network string, address string, path string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address, ^String path]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dialHTTPPath(_network, _address, _path)"}
  [^String _network, ^String _address, ^String _path])

JOKER FUNC net/rpc.HandleHTTP from net/rpc/server.go:
;; (defn HandleHTTP
;;   "HandleHTTP registers an HTTP handler for RPC messages to DefaultServer\non DefaultRPCPath and a debugging handler on DefaultDebugPath.\nIt is still necessary to invoke http.Serve(), typically in a go statement.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__handleHTTP()"}
;;   [])

JOKER FUNC net/rpc.NewClient from net/rpc/client.go:
;; (defn NewClient
;;   "NewClient returns a new Client to handle requests to the\nset of services at the other end of the connection.\nIt adds a buffer to the write side of the connection so\nthe header and payload are sent as a unit.\n\nThe read and write halves of the connection are serialized independently,\nso no interlocking is required. However each half may be accessed\nconcurrently so the implementation of conn should protect against\nconcurrent reads or concurrent writes.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *Client\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: (atom-of go.std.net.rpc/Client)"
;;   {:added "1.0"
;;    :go "__newClient(*_conn)"}
;;   [^io/ReadWriteCloser _conn])

JOKER FUNC net/rpc.NewClientWithCodec from net/rpc/client.go:
(defn NewClientWithCodec
  "NewClientWithCodec is like NewClient but uses the specified\ncodec to encode requests and decode responses.\n\nGo input arguments: (codec ClientCodec)\n\nGo return type: *Client\n\nJoker input arguments: [^go.std.net.rpc/ClientCodec codec]\n\nJoker return type: (atom-of go.std.net.rpc/Client)"
  {:added "1.0"
   :go "__newClientWithCodec(*_codec)"}
  [^rpc/ClientCodec _codec])

JOKER FUNC net/rpc.NewServer from net/rpc/server.go:
(defn NewServer
  "NewServer returns a new Server.\n\nGo return type: *Server\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.net.rpc/Server)"
  {:added "1.0"
   :go "__newServer()"}
  [])

JOKER FUNC net/rpc.Register from net/rpc/server.go:
;; (defn ^"Error" Register
;;   "Register publishes the receiver's methods in the DefaultServer.\n\nGo input arguments: (rcvr interface {})\n\nGo return type: error\n\nJoker input arguments: [^<protocol-or-something> rcvr]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.Register(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _rcvr])

JOKER FUNC net/rpc.RegisterName from net/rpc/server.go:
;; (defn ^"Error" RegisterName
;;   "RegisterName is like Register but uses the provided name for the type\ninstead of the receiver's concrete type.\n\nGo input arguments: (name string, rcvr interface {})\n\nGo return type: error\n\nJoker input arguments: [^String name, ^<protocol-or-something> rcvr]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.RegisterName(_name, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^String _name, ^<protocol-or-something> _rcvr])

JOKER FUNC net/rpc.ServeCodec from net/rpc/server.go:
;; (defn ServeCodec
;;   "ServeCodec is like ServeConn but uses the specified codec to\ndecode requests and encode responses.\n\nGo input arguments: (codec ServerCodec)\n\nJoker input arguments: [^go.std.net.rpc/ServerCodec codec]"
;;   {:added "1.0"
;;    :go "__serveCodec(*_codec)"}
;;   [^rpc/ServerCodec _codec])

JOKER FUNC net/rpc.ServeConn from net/rpc/server.go:
;; (defn ServeConn
;;   "ServeConn runs the DefaultServer on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\nServeConn uses the gob wire format (see package gob) on the\nconnection. To use an alternate codec, use ServeCodec.\nSee NewClient's comment for information about concurrent access.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]"
;;   {:added "1.0"
;;    :go "__serveConn(*_conn)"}
;;   [^io/ReadWriteCloser _conn])

JOKER FUNC net/rpc.ServeRequest from net/rpc/server.go:
(defn ^"Error" ServeRequest
  "ServeRequest is like ServeCodec but synchronously serves a single request.\nIt does not close the codec upon completion.\n\nGo input arguments: (codec ServerCodec)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net.rpc/ServerCodec codec]\n\nJoker return type: Error"
  {:added "1.0"
   :go "rpc.ServeRequest(*_codec)"}
  [^rpc/ServerCodec _codec])

JOKER FUNC net/rpc/jsonrpc.Dial from net/rpc/jsonrpc/client.go:
(defn Dial
  "Dial connects to a JSON-RPC server at the specified network address.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*net/rpc.Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dial(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net/rpc/jsonrpc.NewClient from net/rpc/jsonrpc/client.go:
;; (defn NewClient
;;   "NewClient returns a new rpc.Client to handle requests to the\nset of services at the other end of the connection.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *net/rpc.Client\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: (atom-of go.std.net.rpc/Client)"
;;   {:added "1.0"
;;    :go "__newClient(*_conn)"}
;;   [^io/ReadWriteCloser _conn])

JOKER FUNC net/rpc/jsonrpc.NewClientCodec from net/rpc/jsonrpc/client.go:
;; (defn NewClientCodec
;;   "NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: net/rpc.ClientCodec\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: go.std.net.rpc/ClientCodec"
;;   {:added "1.0"
;;    :go "__newClientCodec(*_conn)"}
;;   [^io/ReadWriteCloser _conn])

JOKER FUNC net/rpc/jsonrpc.NewServerCodec from net/rpc/jsonrpc/server.go:
;; (defn NewServerCodec
;;   "NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: net/rpc.ServerCodec\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: go.std.net.rpc/ServerCodec"
;;   {:added "1.0"
;;    :go "__newServerCodec(*_conn)"}
;;   [^io/ReadWriteCloser _conn])

JOKER FUNC net/rpc/jsonrpc.ServeConn from net/rpc/jsonrpc/server.go:
;; (defn ServeConn
;;   "ServeConn runs the JSON-RPC server on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]"
;;   {:added "1.0"
;;    :go "__serveConn(*_conn)"}
;;   [^io/ReadWriteCloser _conn])

JOKER TYPE net/smtp.Auth from net/smtp/auth.go:
;; (defn ^"GoObject" Auth.
;;   "Constructor for smtp.Auth"
;;   {:added "1.0"
;;    :go "_ConstructAuth(_v)"}
;;   [^Object _v])

JOKER TYPE net/smtp.Client from net/smtp/smtp.go:
;; (defn ^"GoObject" Client.
;;   "Constructor for smtp.Client"
;;   {:added "1.0"
;;    :go "_ConstructClient(_v)"}
;;   [^Object _v])

JOKER TYPE net/smtp.ServerInfo from net/smtp/auth.go:
;; (defn ^"GoObject" ServerInfo.
;;   "Constructor for smtp.ServerInfo"
;;   {:added "1.0"
;;    :go "_ConstructServerInfo(_v)"}
;;   [^Object _v])

JOKER FUNC net/smtp.CRAMMD5Auth from net/smtp/auth.go:
(defn CRAMMD5Auth
  "CRAMMD5Auth returns an Auth that implements the CRAM-MD5 authentication\nmechanism as defined in RFC 2195.\nThe returned Auth uses the given username and secret to authenticate\nto the server using the challenge-response mechanism.\n\nGo input arguments: (username string, secret string)\n\nGo return type: Auth\n\nJoker input arguments: [^String username, ^String secret]\n\nJoker return type: go.std.net.smtp/Auth"
  {:added "1.0"
   :go "__cRAMMD5Auth(_username, _secret)"}
  [^String _username, ^String _secret])

JOKER FUNC net/smtp.Dial from net/smtp/smtp.go:
(defn Dial
  "Dial returns a new Client connected to an SMTP server at addr.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nGo input arguments: (addr string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String addr]\n\nJoker return type: [(atom-of go.std.net.smtp/Client) Error]"
  {:added "1.0"
   :go "__dial(_addr)"}
  [^String _addr])

JOKER FUNC net/smtp.NewClient from net/smtp/smtp.go:
;; (defn NewClient
;;   "NewClient returns a new Client using an existing connection and host as a\nserver name to be used when authenticating.\n\nGo input arguments: (conn net.Conn, host string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^go.std.net/Conn conn, ^String host]\n\nJoker return type: [(atom-of go.std.net.smtp/Client) Error]"
;;   {:added "1.0"
;;    :go "__newClient(*_conn, _host)"}
;;   [^net/Conn _conn, ^String _host])

JOKER FUNC net/smtp.PlainAuth from net/smtp/auth.go:
(defn PlainAuth
  "PlainAuth returns an Auth that implements the PLAIN authentication\nmechanism as defined in RFC 4616. The returned Auth uses the given\nusername and password to authenticate to host and act as identity.\nUsually identity should be the empty string, to act as username.\n\nPlainAuth will only send the credentials if the connection is using TLS\nor is connected to localhost. Otherwise authentication will fail with an\nerror, without sending the credentials.\n\nGo input arguments: (identity string, username string, password string, host string)\n\nGo return type: Auth\n\nJoker input arguments: [^String identity, ^String username, ^String password, ^String host]\n\nJoker return type: go.std.net.smtp/Auth"
  {:added "1.0"
   :go "__plainAuth(_identity, _username, _password, _host)"}
  [^String _identity, ^String _username, ^String _password, ^String _host])

JOKER FUNC net/smtp.SendMail from net/smtp/smtp.go:
;; (defn ^"Error" SendMail
;;   "SendMail connects to the server at addr, switches to TLS if\npossible, authenticates with the optional mechanism a if possible,\nand then sends an email from address from, to addresses to, with\nmessage msg.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nThe addresses in the to parameter are the SMTP RCPT addresses.\n\nThe msg parameter should be an RFC 822-style email with headers\nfirst, a blank line, and then the message body. The lines of msg\nshould be CRLF terminated. The msg headers should usually include\nfields such as \"From\", \"To\", \"Subject\", and \"Cc\".  Sending \"Bcc\"\nmessages is accomplished by including an email address in the to\nparameter but not including it in the msg headers.\n\nThe SendMail function and the net/smtp package are low-level\nmechanisms and provide no support for DKIM signing, MIME\nattachments (see the mime/multipart package), or other mail\nfunctionality. Higher-level packages exist outside of the standard\nlibrary.\n\nGo input arguments: (addr string, a Auth, from string, to []string, msg []byte)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^go.std.net.smtp/Auth a, ^String from, ^(vector-of String) to, ^(vector-of Byte) msg]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "smtp.SendMail(_addr, *_a, _from, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(_to)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_msg)))"}
;;   [^String _addr, ^smtp/Auth _a, ^String _from, ^Object _to, ^Object _msg])

JOKER TYPE net/textproto.Conn from net/textproto/textproto.go:
(defn ^"GoObject" Conn.
  "Constructor for textproto.Conn"
  {:added "1.0"
   :go "_ConstructConn(_v)"}
  [^Object _v])

JOKER TYPE net/textproto.Error from net/textproto/textproto.go:
(defn ^"GoObject" Error.
  "Constructor for textproto.Error"
  {:added "1.0"
   :go "_ConstructError(_v)"}
  [^Object _v])

JOKER TYPE net/textproto.MIMEHeader from net/textproto/header.go:
;; (defn ^"GoObject" MIMEHeader.
;;   "Constructor for textproto.MIMEHeader"
;;   {:added "1.0"
;;    :go "_ConstructMIMEHeader(_v)"}
;;   [^Object _v])

JOKER TYPE net/textproto.Pipeline from net/textproto/pipeline.go:
(defn ^"GoObject" Pipeline.
  "Constructor for textproto.Pipeline"
  {:added "1.0"
   :go "_ConstructPipeline(_v)"}
  [^Object _v])

JOKER TYPE net/textproto.ProtocolError from net/textproto/textproto.go:
(defn ^"GoObject" ProtocolError.
  "Constructor for textproto.ProtocolError"
  {:added "1.0"
   :go "_ConstructProtocolError(_v)"}
  [^Object _v])

JOKER TYPE net/textproto.Reader from net/textproto/reader.go:
;; (defn ^"GoObject" Reader.
;;   "Constructor for textproto.Reader"
;;   {:added "1.0"
;;    :go "_ConstructReader(_v)"}
;;   [^Object _v])

JOKER TYPE net/textproto.Writer from net/textproto/writer.go:
;; (defn ^"GoObject" Writer.
;;   "Constructor for textproto.Writer"
;;   {:added "1.0"
;;    :go "_ConstructWriter(_v)"}
;;   [^Object _v])

JOKER FUNC net/textproto.CanonicalMIMEHeaderKey from net/textproto/reader.go:
(defn ^"String" CanonicalMIMEHeaderKey
  "CanonicalMIMEHeaderKey returns the canonical format of the\nMIME header key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nMIME header keys are assumed to be ASCII only.\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "textproto.CanonicalMIMEHeaderKey(_s)"}
  [^String _s])

JOKER FUNC net/textproto.Dial from net/textproto/textproto.go:
(defn Dial
  "Dial connects to the given address on the given network using net.Dial\nand then returns a new Conn for the connection.\n\nGo input arguments: (network string, addr string)\n\nGo return type: (*Conn, error)\n\nJoker input arguments: [^String network, ^String addr]\n\nJoker return type: [(atom-of go.std.net.textproto/Conn) Error]"
  {:added "1.0"
   :go "__dial(_network, _addr)"}
  [^String _network, ^String _addr])

JOKER FUNC net/textproto.NewConn from net/textproto/textproto.go:
;; (defn NewConn
;;   "NewConn returns a new Conn using conn for I/O.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *Conn\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: (atom-of go.std.net.textproto/Conn)"
;;   {:added "1.0"
;;    :go "__newConn(*_conn)"}
;;   [^io/ReadWriteCloser _conn])

JOKER FUNC net/textproto.NewReader from net/textproto/reader.go:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from r.\n\nTo avoid denial of service attacks, the provided bufio.Reader\nshould be reading from an io.LimitReader or similar Reader to bound\nthe size of responses.\n\nGo input arguments: (r *bufio.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.textproto/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(_r)"}
;;   [^bufio/Reader _r])

JOKER FUNC net/textproto.NewWriter from net/textproto/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer writing to w.\n\nGo input arguments: (w *bufio.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^(atom-of go.std.bufio/Writer) w]\n\nJoker return type: (atom-of go.std.net.textproto/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(_w)"}
;;   [^bufio/Writer _w])

JOKER FUNC net/textproto.TrimBytes from net/textproto/textproto.go:
;; (defn TrimBytes
;;   "TrimBytes returns b without leading and trailing ASCII space.\n\nGo input arguments: (b []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimBytes(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _b])

JOKER FUNC net/textproto.TrimString from net/textproto/textproto.go:
(defn ^"String" TrimString
  "TrimString returns s without leading and trailing ASCII space.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "textproto.TrimString(_s)"}
  [^String _s])

JOKER TYPE net/url.Error from net/url/url.go:
(defn ^"GoObject" Error.
  "Constructor for url.Error"
  {:added "1.0"
   :go "_ConstructError(_v)"}
  [^Object _v])

JOKER TYPE net/url.EscapeError from net/url/url.go:
(defn ^"GoObject" EscapeError.
  "Constructor for url.EscapeError"
  {:added "1.0"
   :go "_ConstructEscapeError(_v)"}
  [^Object _v])

JOKER TYPE net/url.InvalidHostError from net/url/url.go:
(defn ^"GoObject" InvalidHostError.
  "Constructor for url.InvalidHostError"
  {:added "1.0"
   :go "_ConstructInvalidHostError(_v)"}
  [^Object _v])

JOKER TYPE net/url.URL from net/url/url.go:
;; (defn ^"GoObject" URL.
;;   "Constructor for url.URL"
;;   {:added "1.0"
;;    :go "_ConstructURL(_v)"}
;;   [^Object _v])

JOKER TYPE net/url.Userinfo from net/url/url.go:
(defn ^"GoObject" Userinfo.
  "Constructor for url.Userinfo"
  {:added "1.0"
   :go "_ConstructUserinfo(_v)"}
  [^Object _v])

JOKER TYPE net/url.Values from net/url/url.go:
;; (defn ^"GoObject" Values.
;;   "Constructor for url.Values"
;;   {:added "1.0"
;;    :go "_ConstructValues(_v)"}
;;   [^Object _v])

JOKER FUNC net/url.Parse from net/url/url.go:
(defn Parse
  "Parse parses rawurl into a URL structure.\n\nThe rawurl may be relative (a path, without a host) or absolute\n(starting with a scheme). Trying to parse a hostname and path\nwithout a scheme is invalid but may not necessarily return an\nerror, due to parsing ambiguities.\n\nGo input arguments: (rawurl string)\n\nGo return type: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker return type: [(atom-of go.std.net.url/URL) Error]"
  {:added "1.0"
   :go "__parse(_rawurl)"}
  [^String _rawurl])

JOKER FUNC net/url.ParseQuery from net/url/url.go:
(defn ParseQuery
  "ParseQuery parses the URL-encoded query string and returns\na map listing the values specified for each key.\nParseQuery always returns a non-nil map containing all the\nvalid query parameters found; err describes the first decoding error\nencountered, if any.\n\nQuery is expected to be a list of key=value settings separated by\nampersands or semicolons. A setting without an equals sign is\ninterpreted as a key set to an empty value.\n\nGo input arguments: (query string)\n\nGo return type: (Values, error)\n\nJoker input arguments: [^String query]\n\nJoker return type: [go.std.net.url/Values Error]"
  {:added "1.0"
   :go "__parseQuery(_query)"}
  [^String _query])

JOKER FUNC net/url.ParseRequestURI from net/url/url.go:
(defn ParseRequestURI
  "ParseRequestURI parses rawurl into a URL structure. It assumes that\nrawurl was received in an HTTP request, so the rawurl is interpreted\nonly as an absolute URI or an absolute path.\nThe string rawurl is assumed not to have a #fragment suffix.\n(Web browsers strip #fragment before sending the URL to a web server.)\n\nGo input arguments: (rawurl string)\n\nGo return type: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker return type: [(atom-of go.std.net.url/URL) Error]"
  {:added "1.0"
   :go "__parseRequestURI(_rawurl)"}
  [^String _rawurl])

JOKER FUNC net/url.PathEscape from net/url/url.go:
(defn ^"String" PathEscape
  "PathEscape escapes the string so it can be safely placed\ninside a URL path segment.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "url.PathEscape(_s)"}
  [^String _s])

JOKER FUNC net/url.PathUnescape from net/url/url.go:
(defn PathUnescape
  "PathUnescape does the inverse transformation of PathEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB. It returns an error if any % is not followed\nby two hexadecimal digits.\n\nPathUnescape is identical to QueryUnescape except that it does not\nunescape '+' to ' ' (space).\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__pathUnescape(_s)"}
  [^String _s])

JOKER FUNC net/url.QueryEscape from net/url/url.go:
(defn ^"String" QueryEscape
  "QueryEscape escapes the string so it can be safely placed\ninside a URL query.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "url.QueryEscape(_s)"}
  [^String _s])

JOKER FUNC net/url.QueryUnescape from net/url/url.go:
(defn QueryUnescape
  "QueryUnescape does the inverse transformation of QueryEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB.\nIt returns an error if any % is not followed by two hexadecimal\ndigits.\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__queryUnescape(_s)"}
  [^String _s])

JOKER FUNC net/url.User from net/url/url.go:
(defn User
  "User returns a Userinfo containing the provided username\nand no password set.\n\nGo input arguments: (username string)\n\nGo return type: *Userinfo\n\nJoker input arguments: [^String username]\n\nJoker return type: (atom-of go.std.net.url/Userinfo)"
  {:added "1.0"
   :go "__user(_username)"}
  [^String _username])

JOKER FUNC net/url.UserPassword from net/url/url.go:
(defn UserPassword
  "UserPassword returns a Userinfo containing the provided username\nand password.\n\nThis functionality should only be used with legacy web sites.\nRFC 2396 warns that interpreting Userinfo this way\n``is NOT RECOMMENDED, because the passing of authentication\ninformation in clear text (such as URI) has proven to be a\nsecurity risk in almost every case where it has been used.''\n\nGo input arguments: (username string, password string)\n\nGo return type: *Userinfo\n\nJoker input arguments: [^String username, ^String password]\n\nJoker return type: (atom-of go.std.net.url/Userinfo)"
  {:added "1.0"
   :go "__userPassword(_username, _password)"}
  [^String _username, ^String _password])

GO TYPE net.Addr from net/net.go:
func ExtractGoObjectAddr(args []Object, index int) *_net.Addr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Addr:
			return &r
		case *_net.Addr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Addr]"))
}

// func _ConstructAddr(_v Object) _net.Addr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Addr:
// 			return _g
// 		case *_net.Addr:
// 			return *_g
// 		}
// 	default:
// 		return _net.Addr(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Addr))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Addr] or: whatever"))
// }

GO TYPE net.AddrError from net/net.go:
func ExtractGoObjectAddrError(args []Object, index int) *_net.AddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.AddrError:
			return &r
		case *_net.AddrError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.AddrError]"))
}

func _mapToAddrError(o Map) *_net.AddrError {
	return &_net.AddrError{}
}

func _vectorToAddrError(o *Vector) *_net.AddrError {
	return &_net.AddrError{
		Err: AssertString(o.Nth(0), "").S,
		Addr: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructAddrError(_v Object) *_net.AddrError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.AddrError:
			return &_g
		case *_net.AddrError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToAddrError(_o.(Map))
	case *Vector:
		return _vectorToAddrError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.AddrError] or: Map or Vector"))
}

GO TYPE net.Buffers from net/net.go:
func ExtractGoObjectBuffers(args []Object, index int) *_net.Buffers {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Buffers:
			return &r
		case *_net.Buffers:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Buffers]"))
}

// func _ConstructBuffers(_v Object) _net.Buffers {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Buffers:
// 			return _g
// 		case *_net.Buffers:
// 			return *_g
// 		}
// 	default:
// 		return _net.Buffers(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for Buffers))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Buffers] or: whatever"))
// }

GO TYPE net.Conn from net/net.go:
func ExtractGoObjectConn(args []Object, index int) *_net.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Conn:
			return &r
		case *_net.Conn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Conn]"))
}

// func _ConstructConn(_v Object) _net.Conn {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Conn:
// 			return _g
// 		case *_net.Conn:
// 			return *_g
// 		}
// 	default:
// 		return _net.Conn(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Conn))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Conn] or: whatever"))
// }

GO TYPE net.DNSConfigError from net/net.go:
func ExtractGoObjectDNSConfigError(args []Object, index int) *_net.DNSConfigError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.DNSConfigError:
			return &r
		case *_net.DNSConfigError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.DNSConfigError]"))
}

func _mapToDNSConfigError(o Map) *_net.DNSConfigError {
	return &_net.DNSConfigError{}
}

func _vectorToDNSConfigError(o *Vector) *_net.DNSConfigError {
	return &_net.DNSConfigError{
		Err: _errors.New(AssertString(o.Nth(0), "").S),
	}
}

func _ConstructDNSConfigError(_v Object) *_net.DNSConfigError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.DNSConfigError:
			return &_g
		case *_net.DNSConfigError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDNSConfigError(_o.(Map))
	case *Vector:
		return _vectorToDNSConfigError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.DNSConfigError] or: Map or Vector"))
}

GO TYPE net.DNSError from net/net.go:
func ExtractGoObjectDNSError(args []Object, index int) *_net.DNSError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.DNSError:
			return &r
		case *_net.DNSError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.DNSError]"))
}

func _mapToDNSError(o Map) *_net.DNSError {
	return &_net.DNSError{}
}

func _vectorToDNSError(o *Vector) *_net.DNSError {
	return &_net.DNSError{
		Err: AssertString(o.Nth(0), "").S,
		Name: AssertString(o.Nth(1), "").S,
		Server: AssertString(o.Nth(2), "").S,
		IsTimeout: ToBool(o.Nth(3)),
		IsTemporary: ToBool(o.Nth(4)),
	}
}

func _ConstructDNSError(_v Object) *_net.DNSError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.DNSError:
			return &_g
		case *_net.DNSError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDNSError(_o.(Map))
	case *Vector:
		return _vectorToDNSError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.DNSError] or: Map or Vector"))
}

GO TYPE net.Dialer from net/dial.go:
func ExtractGoObjectDialer(args []Object, index int) *_net.Dialer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Dialer:
			return &r
		case *_net.Dialer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Dialer]"))
}

// func _mapToDialer(o Map) *_net.Dialer {
// 	return &_net.Dialer{}
// }

// func _vectorToDialer(o *Vector) *_net.Dialer {
// 	return &_net.Dialer{
// 		Timeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Deadline: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		LocalAddr: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		DualStack: ToBool(o.Nth(3)),
// 		FallbackDelay: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		KeepAlive: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Resolver: *ABEND047(gotypes.go: unsupported type *ast.StructType),
// 		Cancel: ABEND047(gotypes.go: unsupported type *ast.ChanType),
// 		Control: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructDialer(_v Object) *_net.Dialer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Dialer:
// 			return &_g
// 		case *_net.Dialer:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToDialer(_o.(Map))
// 	case *Vector:
// 		return _vectorToDialer(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Dialer] or: Map or Vector"))
// }

GO TYPE net.Error from net/net.go:
func ExtractGoObjectError(args []Object, index int) *_net.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Error:
			return &r
		case *_net.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Error]"))
}

// func _ConstructError(_v Object) _net.Error {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Error:
// 			return _g
// 		case *_net.Error:
// 			return *_g
// 		}
// 	default:
// 		return _net.Error(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Error))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Error] or: whatever"))
// }

GO TYPE net.Flags from net/interface.go:
func ExtractGoObjectFlags(args []Object, index int) *_net.Flags {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Flags:
			return &r
		case *_net.Flags:
			return r
		}
	case Number:
		v := _net.Flags(ExtractUInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Flags]"))
}

func _ConstructFlags(_v Object) _net.Flags {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.Flags:
			return _g
		case *_net.Flags:
			return *_g
		}
	case Number:
		return _net.Flags(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Flags] or: Number"))
}

GO TYPE net.HardwareAddr from net/mac.go:
func ExtractGoObjectHardwareAddr(args []Object, index int) *_net.HardwareAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.HardwareAddr:
			return &r
		case *_net.HardwareAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.HardwareAddr]"))
}

// func _ConstructHardwareAddr(_v Object) _net.HardwareAddr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.HardwareAddr:
// 			return _g
// 		case *_net.HardwareAddr:
// 			return *_g
// 		}
// 	default:
// 		return _net.HardwareAddr(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for HardwareAddr))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.HardwareAddr] or: whatever"))
// }

GO TYPE net.IP from net/ip.go:
func ExtractGoObjectIP(args []Object, index int) *_net.IP {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IP:
			return &r
		case *_net.IP:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IP]"))
}

// func _ConstructIP(_v Object) _net.IP {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.IP:
// 			return _g
// 		case *_net.IP:
// 			return *_g
// 		}
// 	default:
// 		return _net.IP(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for IP))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IP] or: whatever"))
// }

GO TYPE net.IPAddr from net/iprawsock.go:
func ExtractGoObjectIPAddr(args []Object, index int) *_net.IPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPAddr:
			return &r
		case *_net.IPAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPAddr]"))
}

// func _mapToIPAddr(o Map) *_net.IPAddr {
// 	return &_net.IPAddr{}
// }

// func _vectorToIPAddr(o *Vector) *_net.IPAddr {
// 	return &_net.IPAddr{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Zone: AssertString(o.Nth(1), "").S,
// 	}
// }

// func _ConstructIPAddr(_v Object) *_net.IPAddr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.IPAddr:
// 			return &_g
// 		case *_net.IPAddr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToIPAddr(_o.(Map))
// 	case *Vector:
// 		return _vectorToIPAddr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPAddr] or: Map or Vector"))
// }

GO TYPE net.IPConn from net/iprawsock.go:
func ExtractGoObjectIPConn(args []Object, index int) *_net.IPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPConn:
			return &r
		case *_net.IPConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPConn]"))
}

func _mapToIPConn(o Map) *_net.IPConn {
	return &_net.IPConn{}
}

func _vectorToIPConn(o *Vector) *_net.IPConn {
	return &_net.IPConn{}
}

func _ConstructIPConn(_v Object) *_net.IPConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.IPConn:
			return &_g
		case *_net.IPConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIPConn(_o.(Map))
	case *Vector:
		return _vectorToIPConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPConn] or: Map or Vector"))
}

GO TYPE net.IPMask from net/ip.go:
func ExtractGoObjectIPMask(args []Object, index int) *_net.IPMask {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPMask:
			return &r
		case *_net.IPMask:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPMask]"))
}

// func _ConstructIPMask(_v Object) _net.IPMask {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.IPMask:
// 			return _g
// 		case *_net.IPMask:
// 			return *_g
// 		}
// 	default:
// 		return _net.IPMask(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for IPMask))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPMask] or: whatever"))
// }

GO TYPE net.IPNet from net/ip.go:
func ExtractGoObjectIPNet(args []Object, index int) *_net.IPNet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPNet:
			return &r
		case *_net.IPNet:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPNet]"))
}

// func _mapToIPNet(o Map) *_net.IPNet {
// 	return &_net.IPNet{}
// }

// func _vectorToIPNet(o *Vector) *_net.IPNet {
// 	return &_net.IPNet{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Mask: ABEND048(codegen.go: no conversion from Clojure for net.IPMask ([]byte)),
// 	}
// }

// func _ConstructIPNet(_v Object) *_net.IPNet {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.IPNet:
// 			return &_g
// 		case *_net.IPNet:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToIPNet(_o.(Map))
// 	case *Vector:
// 		return _vectorToIPNet(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPNet] or: Map or Vector"))
// }

GO TYPE net.Interface from net/interface.go:
func ExtractGoObjectInterface(args []Object, index int) *_net.Interface {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Interface:
			return &r
		case *_net.Interface:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Interface]"))
}

// func _mapToInterface(o Map) *_net.Interface {
// 	return &_net.Interface{}
// }

// func _vectorToInterface(o *Vector) *_net.Interface {
// 	return &_net.Interface{
// 		Index: AssertInt(o.Nth(0), "").I,
// 		MTU: AssertInt(o.Nth(1), "").I,
// 		Name: AssertString(o.Nth(2), "").S,
// 		HardwareAddr: ABEND048(codegen.go: no conversion from Clojure for net.HardwareAddr ([]byte)),
// 		Flags: _net.Flags(uint(AssertInt(o.Nth(4), "").I)),
// 	}
// }

// func _ConstructInterface(_v Object) *_net.Interface {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Interface:
// 			return &_g
// 		case *_net.Interface:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToInterface(_o.(Map))
// 	case *Vector:
// 		return _vectorToInterface(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Interface] or: Map or Vector"))
// }

GO TYPE net.InvalidAddrError from net/net.go:
func ExtractGoObjectInvalidAddrError(args []Object, index int) *_net.InvalidAddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.InvalidAddrError:
			return &r
		case *_net.InvalidAddrError:
			return r
		}
	case String:
		v := _net.InvalidAddrError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.InvalidAddrError]"))
}

func _ConstructInvalidAddrError(_v Object) _net.InvalidAddrError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.InvalidAddrError:
			return _g
		case *_net.InvalidAddrError:
			return *_g
		}
	case String:
		return _net.InvalidAddrError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.InvalidAddrError] or: String"))
}

GO TYPE net.ListenConfig from net/dial.go:
func ExtractGoObjectListenConfig(args []Object, index int) *_net.ListenConfig {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.ListenConfig:
			return &r
		case *_net.ListenConfig:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.ListenConfig]"))
}

// func _mapToListenConfig(o Map) *_net.ListenConfig {
// 	return &_net.ListenConfig{}
// }

// func _vectorToListenConfig(o *Vector) *_net.ListenConfig {
// 	return &_net.ListenConfig{
// 		Control: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructListenConfig(_v Object) *_net.ListenConfig {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.ListenConfig:
// 			return &_g
// 		case *_net.ListenConfig:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToListenConfig(_o.(Map))
// 	case *Vector:
// 		return _vectorToListenConfig(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.ListenConfig] or: Map or Vector"))
// }

GO TYPE net.Listener from net/net.go:
func ExtractGoObjectListener(args []Object, index int) *_net.Listener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Listener:
			return &r
		case *_net.Listener:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Listener]"))
}

// func _ConstructListener(_v Object) _net.Listener {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Listener:
// 			return _g
// 		case *_net.Listener:
// 			return *_g
// 		}
// 	default:
// 		return _net.Listener(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Listener))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Listener] or: whatever"))
// }

GO TYPE net.MX from net/dnsclient.go:
func ExtractGoObjectMX(args []Object, index int) *_net.MX {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.MX:
			return &r
		case *_net.MX:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.MX]"))
}

func _mapToMX(o Map) *_net.MX {
	return &_net.MX{}
}

func _vectorToMX(o *Vector) *_net.MX {
	return &_net.MX{
		Host: AssertString(o.Nth(0), "").S,
		Pref: uint16(AssertInt(o.Nth(1), "").I),
	}
}

func _ConstructMX(_v Object) *_net.MX {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.MX:
			return &_g
		case *_net.MX:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMX(_o.(Map))
	case *Vector:
		return _vectorToMX(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.MX] or: Map or Vector"))
}

GO TYPE net.NS from net/dnsclient.go:
func ExtractGoObjectNS(args []Object, index int) *_net.NS {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.NS:
			return &r
		case *_net.NS:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.NS]"))
}

func _mapToNS(o Map) *_net.NS {
	return &_net.NS{}
}

func _vectorToNS(o *Vector) *_net.NS {
	return &_net.NS{
		Host: AssertString(o.Nth(0), "").S,
	}
}

func _ConstructNS(_v Object) *_net.NS {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.NS:
			return &_g
		case *_net.NS:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNS(_o.(Map))
	case *Vector:
		return _vectorToNS(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.NS] or: Map or Vector"))
}

GO TYPE net.OpError from net/net.go:
func ExtractGoObjectOpError(args []Object, index int) *_net.OpError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.OpError:
			return &r
		case *_net.OpError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.OpError]"))
}

// func _mapToOpError(o Map) *_net.OpError {
// 	return &_net.OpError{}
// }

// func _vectorToOpError(o *Vector) *_net.OpError {
// 	return &_net.OpError{
// 		Op: AssertString(o.Nth(0), "").S,
// 		Net: AssertString(o.Nth(1), "").S,
// 		Source: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		Addr: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		Err: _errors.New(AssertString(o.Nth(4), "").S),
// 	}
// }

// func _ConstructOpError(_v Object) *_net.OpError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.OpError:
// 			return &_g
// 		case *_net.OpError:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToOpError(_o.(Map))
// 	case *Vector:
// 		return _vectorToOpError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.OpError] or: Map or Vector"))
// }

GO TYPE net.PacketConn from net/net.go:
func ExtractGoObjectPacketConn(args []Object, index int) *_net.PacketConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.PacketConn:
			return &r
		case *_net.PacketConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.PacketConn]"))
}

// func _ConstructPacketConn(_v Object) _net.PacketConn {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.PacketConn:
// 			return _g
// 		case *_net.PacketConn:
// 			return *_g
// 		}
// 	default:
// 		return _net.PacketConn(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for PacketConn))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.PacketConn] or: whatever"))
// }

GO TYPE net.ParseError from net/net.go:
func ExtractGoObjectParseError(args []Object, index int) *_net.ParseError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.ParseError:
			return &r
		case *_net.ParseError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.ParseError]"))
}

func _mapToParseError(o Map) *_net.ParseError {
	return &_net.ParseError{}
}

func _vectorToParseError(o *Vector) *_net.ParseError {
	return &_net.ParseError{
		Type: AssertString(o.Nth(0), "").S,
		Text: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructParseError(_v Object) *_net.ParseError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.ParseError:
			return &_g
		case *_net.ParseError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToParseError(_o.(Map))
	case *Vector:
		return _vectorToParseError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.ParseError] or: Map or Vector"))
}

GO TYPE net.Resolver from net/lookup.go:
func ExtractGoObjectResolver(args []Object, index int) *_net.Resolver {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Resolver:
			return &r
		case *_net.Resolver:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Resolver]"))
}

// func _mapToResolver(o Map) *_net.Resolver {
// 	return &_net.Resolver{}
// }

// func _vectorToResolver(o *Vector) *_net.Resolver {
// 	return &_net.Resolver{
// 		PreferGo: ToBool(o.Nth(0)),
// 		StrictErrors: ToBool(o.Nth(1)),
// 		Dial: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructResolver(_v Object) *_net.Resolver {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Resolver:
// 			return &_g
// 		case *_net.Resolver:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToResolver(_o.(Map))
// 	case *Vector:
// 		return _vectorToResolver(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Resolver] or: Map or Vector"))
// }

GO TYPE net.SRV from net/dnsclient.go:
func ExtractGoObjectSRV(args []Object, index int) *_net.SRV {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.SRV:
			return &r
		case *_net.SRV:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.SRV]"))
}

func _mapToSRV(o Map) *_net.SRV {
	return &_net.SRV{}
}

func _vectorToSRV(o *Vector) *_net.SRV {
	return &_net.SRV{
		Target: AssertString(o.Nth(0), "").S,
		Port: uint16(AssertInt(o.Nth(1), "").I),
		Priority: uint16(AssertInt(o.Nth(2), "").I),
		Weight: uint16(AssertInt(o.Nth(3), "").I),
	}
}

func _ConstructSRV(_v Object) *_net.SRV {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.SRV:
			return &_g
		case *_net.SRV:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSRV(_o.(Map))
	case *Vector:
		return _vectorToSRV(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.SRV] or: Map or Vector"))
}

GO TYPE net.TCPAddr from net/tcpsock.go:
func ExtractGoObjectTCPAddr(args []Object, index int) *_net.TCPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.TCPAddr:
			return &r
		case *_net.TCPAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.TCPAddr]"))
}

// func _mapToTCPAddr(o Map) *_net.TCPAddr {
// 	return &_net.TCPAddr{}
// }

// func _vectorToTCPAddr(o *Vector) *_net.TCPAddr {
// 	return &_net.TCPAddr{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Port: AssertInt(o.Nth(1), "").I,
// 		Zone: AssertString(o.Nth(2), "").S,
// 	}
// }

// func _ConstructTCPAddr(_v Object) *_net.TCPAddr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.TCPAddr:
// 			return &_g
// 		case *_net.TCPAddr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTCPAddr(_o.(Map))
// 	case *Vector:
// 		return _vectorToTCPAddr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.TCPAddr] or: Map or Vector"))
// }

GO TYPE net.TCPConn from net/tcpsock.go:
func ExtractGoObjectTCPConn(args []Object, index int) *_net.TCPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.TCPConn:
			return &r
		case *_net.TCPConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.TCPConn]"))
}

func _mapToTCPConn(o Map) *_net.TCPConn {
	return &_net.TCPConn{}
}

func _vectorToTCPConn(o *Vector) *_net.TCPConn {
	return &_net.TCPConn{}
}

func _ConstructTCPConn(_v Object) *_net.TCPConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.TCPConn:
			return &_g
		case *_net.TCPConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTCPConn(_o.(Map))
	case *Vector:
		return _vectorToTCPConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.TCPConn] or: Map or Vector"))
}

GO TYPE net.TCPListener from net/tcpsock.go:
func ExtractGoObjectTCPListener(args []Object, index int) *_net.TCPListener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.TCPListener:
			return &r
		case *_net.TCPListener:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.TCPListener]"))
}

func _mapToTCPListener(o Map) *_net.TCPListener {
	return &_net.TCPListener{}
}

func _vectorToTCPListener(o *Vector) *_net.TCPListener {
	return &_net.TCPListener{}
}

func _ConstructTCPListener(_v Object) *_net.TCPListener {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.TCPListener:
			return &_g
		case *_net.TCPListener:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTCPListener(_o.(Map))
	case *Vector:
		return _vectorToTCPListener(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.TCPListener] or: Map or Vector"))
}

GO TYPE net.UDPAddr from net/udpsock.go:
func ExtractGoObjectUDPAddr(args []Object, index int) *_net.UDPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UDPAddr:
			return &r
		case *_net.UDPAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UDPAddr]"))
}

// func _mapToUDPAddr(o Map) *_net.UDPAddr {
// 	return &_net.UDPAddr{}
// }

// func _vectorToUDPAddr(o *Vector) *_net.UDPAddr {
// 	return &_net.UDPAddr{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Port: AssertInt(o.Nth(1), "").I,
// 		Zone: AssertString(o.Nth(2), "").S,
// 	}
// }

// func _ConstructUDPAddr(_v Object) *_net.UDPAddr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.UDPAddr:
// 			return &_g
// 		case *_net.UDPAddr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToUDPAddr(_o.(Map))
// 	case *Vector:
// 		return _vectorToUDPAddr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UDPAddr] or: Map or Vector"))
// }

GO TYPE net.UDPConn from net/udpsock.go:
func ExtractGoObjectUDPConn(args []Object, index int) *_net.UDPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UDPConn:
			return &r
		case *_net.UDPConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UDPConn]"))
}

func _mapToUDPConn(o Map) *_net.UDPConn {
	return &_net.UDPConn{}
}

func _vectorToUDPConn(o *Vector) *_net.UDPConn {
	return &_net.UDPConn{}
}

func _ConstructUDPConn(_v Object) *_net.UDPConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UDPConn:
			return &_g
		case *_net.UDPConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUDPConn(_o.(Map))
	case *Vector:
		return _vectorToUDPConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UDPConn] or: Map or Vector"))
}

GO TYPE net.UnixAddr from net/unixsock.go:
func ExtractGoObjectUnixAddr(args []Object, index int) *_net.UnixAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UnixAddr:
			return &r
		case *_net.UnixAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnixAddr]"))
}

func _mapToUnixAddr(o Map) *_net.UnixAddr {
	return &_net.UnixAddr{}
}

func _vectorToUnixAddr(o *Vector) *_net.UnixAddr {
	return &_net.UnixAddr{
		Name: AssertString(o.Nth(0), "").S,
		Net: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructUnixAddr(_v Object) *_net.UnixAddr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UnixAddr:
			return &_g
		case *_net.UnixAddr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnixAddr(_o.(Map))
	case *Vector:
		return _vectorToUnixAddr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnixAddr] or: Map or Vector"))
}

GO TYPE net.UnixConn from net/unixsock.go:
func ExtractGoObjectUnixConn(args []Object, index int) *_net.UnixConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UnixConn:
			return &r
		case *_net.UnixConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnixConn]"))
}

func _mapToUnixConn(o Map) *_net.UnixConn {
	return &_net.UnixConn{}
}

func _vectorToUnixConn(o *Vector) *_net.UnixConn {
	return &_net.UnixConn{}
}

func _ConstructUnixConn(_v Object) *_net.UnixConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UnixConn:
			return &_g
		case *_net.UnixConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnixConn(_o.(Map))
	case *Vector:
		return _vectorToUnixConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnixConn] or: Map or Vector"))
}

GO TYPE net.UnixListener from net/unixsock.go:
func ExtractGoObjectUnixListener(args []Object, index int) *_net.UnixListener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UnixListener:
			return &r
		case *_net.UnixListener:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnixListener]"))
}

func _mapToUnixListener(o Map) *_net.UnixListener {
	return &_net.UnixListener{}
}

func _vectorToUnixListener(o *Vector) *_net.UnixListener {
	return &_net.UnixListener{}
}

func _ConstructUnixListener(_v Object) *_net.UnixListener {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UnixListener:
			return &_g
		case *_net.UnixListener:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnixListener(_o.(Map))
	case *Vector:
		return _vectorToUnixListener(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnixListener] or: Map or Vector"))
}

GO TYPE net.UnknownNetworkError from net/net.go:
func ExtractGoObjectUnknownNetworkError(args []Object, index int) *_net.UnknownNetworkError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UnknownNetworkError:
			return &r
		case *_net.UnknownNetworkError:
			return r
		}
	case String:
		v := _net.UnknownNetworkError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnknownNetworkError]"))
}

func _ConstructUnknownNetworkError(_v Object) _net.UnknownNetworkError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UnknownNetworkError:
			return _g
		case *_net.UnknownNetworkError:
			return *_g
		}
	case String:
		return _net.UnknownNetworkError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnknownNetworkError] or: String"))
}

GO FUNC net.CIDRMask from net/ip.go:
func __cIDRMask(ones int, bits int) Object {
	_res := _net.CIDRMask(ones, bits)
	return MakeGoObject(_res)
}

GO FUNC net.Dial from net/dial.go:
func __dial(network string, address string) Object {
	_res1, _res2 := _net.Dial(network, address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.DialIP from net/iprawsock.go:
func __dialIP(network string, laddr *_net.IPAddr, raddr *_net.IPAddr) Object {
	_res1, _res2 := _net.DialIP(network, laddr, raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.DialTCP from net/tcpsock.go:
func __dialTCP(network string, laddr *_net.TCPAddr, raddr *_net.TCPAddr) Object {
	_res1, _res2 := _net.DialTCP(network, laddr, raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.DialTimeout from net/dial.go:
// func __dialTimeout(network string, address string, timeout ABEND987(genutils.go: imports not yet supported: time.Duration)) Object {
// 	_res1, _res2 := _net.DialTimeout(network, address, timeout)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialUDP from net/udpsock.go:
func __dialUDP(network string, laddr *_net.UDPAddr, raddr *_net.UDPAddr) Object {
	_res1, _res2 := _net.DialUDP(network, laddr, raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.DialUnix from net/unixsock.go:
func __dialUnix(network string, laddr *_net.UnixAddr, raddr *_net.UnixAddr) Object {
	_res1, _res2 := _net.DialUnix(network, laddr, raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.FileConn from net/file.go:
// func __fileConn(f *ABEND987(genutils.go: imports not yet supported: os.File)) Object {
// 	c, err := _net.FileConn(f)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(c))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.FileListener from net/file.go:
// func __fileListener(f *ABEND987(genutils.go: imports not yet supported: os.File)) Object {
// 	ln, err := _net.FileListener(f)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(ln))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.FilePacketConn from net/file.go:
// func __filePacketConn(f *ABEND987(genutils.go: imports not yet supported: os.File)) Object {
// 	c, err := _net.FilePacketConn(f)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(c))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.IPv4 from net/ip.go:
func __iPv4(a byte, b byte, c byte, d byte) Object {
	_res := _net.IPv4(a, b, c, d)
	return MakeGoObject(_res)
}

GO FUNC net.IPv4Mask from net/ip.go:
func __iPv4Mask(a byte, b byte, c byte, d byte) Object {
	_res := _net.IPv4Mask(a, b, c, d)
	return MakeGoObject(_res)
}

GO FUNC net.InterfaceAddrs from net/interface.go:
func __interfaceAddrs() Object {
	_res1, _res2 := _net.InterfaceAddrs()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.InterfaceByIndex from net/interface.go:
func __interfaceByIndex(index int) Object {
	_res1, _res2 := _net.InterfaceByIndex(index)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.InterfaceByName from net/interface.go:
func __interfaceByName(name string) Object {
	_res1, _res2 := _net.InterfaceByName(name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.Interfaces from net/interface.go:
func __interfaces() Object {
	_res1, _res2 := _net.Interfaces()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.Listen from net/dial.go:
func __listen(network string, address string) Object {
	_res1, _res2 := _net.Listen(network, address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenIP from net/iprawsock.go:
func __listenIP(network string, laddr *_net.IPAddr) Object {
	_res1, _res2 := _net.ListenIP(network, laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenMulticastUDP from net/udpsock.go:
func __listenMulticastUDP(network string, ifi *_net.Interface, gaddr *_net.UDPAddr) Object {
	_res1, _res2 := _net.ListenMulticastUDP(network, ifi, gaddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenPacket from net/dial.go:
func __listenPacket(network string, address string) Object {
	_res1, _res2 := _net.ListenPacket(network, address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenTCP from net/tcpsock.go:
func __listenTCP(network string, laddr *_net.TCPAddr) Object {
	_res1, _res2 := _net.ListenTCP(network, laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenUDP from net/udpsock.go:
func __listenUDP(network string, laddr *_net.UDPAddr) Object {
	_res1, _res2 := _net.ListenUDP(network, laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenUnix from net/unixsock.go:
func __listenUnix(network string, laddr *_net.UnixAddr) Object {
	_res1, _res2 := _net.ListenUnix(network, laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenUnixgram from net/unixsock.go:
func __listenUnixgram(network string, laddr *_net.UnixAddr) Object {
	_res1, _res2 := _net.ListenUnixgram(network, laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupAddr from net/lookup.go:
func __lookupAddr(addr string) Object {
	names, err := _net.LookupAddr(addr)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range names {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupCNAME from net/lookup.go:
func __lookupCNAME(host string) Object {
	cname, err := _net.LookupCNAME(host)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(cname))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupHost from net/lookup.go:
func __lookupHost(host string) Object {
	addrs, err := _net.LookupHost(host)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range addrs {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupIP from net/lookup.go:
func __lookupIP(host string) Object {
	_res1, _res2 := _net.LookupIP(host)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupMX from net/lookup.go:
func __lookupMX(name string) Object {
	_res1, _res2 := _net.LookupMX(name)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupNS from net/lookup.go:
func __lookupNS(name string) Object {
	_res1, _res2 := _net.LookupNS(name)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupPort from net/lookup.go:
func __lookupPort(network string, service string) Object {
	port, err := _net.LookupPort(network, service)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(port))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupSRV from net/lookup.go:
func __lookupSRV(service string, proto string, name string) Object {
	cname, addrs, err := _net.LookupSRV(service, proto, name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(cname))
	_vec1 := EmptyVector()
	for _, _elem1 := range addrs {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupTXT from net/lookup.go:
func __lookupTXT(name string) Object {
	_res1, _res2 := _net.LookupTXT(name)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ParseCIDR from net/ip.go:
func __parseCIDR(s string) Object {
	_res1, _res2, _res3 := _net.ParseCIDR(s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
	return _res
}

GO FUNC net.ParseIP from net/ip.go:
func __parseIP(s string) Object {
	_res := _net.ParseIP(s)
	return MakeGoObject(_res)
}

GO FUNC net.ParseMAC from net/mac.go:
func __parseMAC(s string) Object {
	hw, err := _net.ParseMAC(s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(hw))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.Pipe from net/pipe.go:
func __pipe() Object {
	_res1, _res2 := _net.Pipe()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	return _res
}

GO FUNC net.ResolveIPAddr from net/iprawsock.go:
func __resolveIPAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveIPAddr(network, address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveTCPAddr from net/tcpsock.go:
func __resolveTCPAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveTCPAddr(network, address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveUDPAddr from net/udpsock.go:
func __resolveUDPAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveUDPAddr(network, address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveUnixAddr from net/unixsock.go:
func __resolveUnixAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveUnixAddr(network, address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.SplitHostPort from net/ipsock.go:
func __splitHostPort(hostport string) Object {
	host, port, err := _net.SplitHostPort(hostport)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(host))
	_res = _res.Conjoin(MakeString(port))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO TYPE net/http.Client from net/http/client.go:
func ExtractGoObjectClient(args []Object, index int) *_http.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Client:
			return &r
		case *_http.Client:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Client]"))
}

// func _mapToClient(o Map) *_http.Client {
// 	return &_http.Client{}
// }

// func _vectorToClient(o *Vector) *_http.Client {
// 	return &_http.Client{
// 		Transport: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		CheckRedirect: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		Jar: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		Timeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructClient(_v Object) *_http.Client {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Client:
// 			return &_g
// 		case *_http.Client:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToClient(_o.(Map))
// 	case *Vector:
// 		return _vectorToClient(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Client] or: Map or Vector"))
// }

GO TYPE net/http.CloseNotifier from net/http/server.go:
func ExtractGoObjectCloseNotifier(args []Object, index int) *_http.CloseNotifier {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.CloseNotifier:
			return &r
		case *_http.CloseNotifier:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.CloseNotifier]"))
}

// func _ConstructCloseNotifier(_v Object) _http.CloseNotifier {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.CloseNotifier:
// 			return _g
// 		case *_http.CloseNotifier:
// 			return *_g
// 		}
// 	default:
// 		return _http.CloseNotifier(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for CloseNotifier))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.CloseNotifier] or: whatever"))
// }

GO TYPE net/http.ConnState from net/http/server.go:
func ExtractGoObjectConnState(args []Object, index int) *_http.ConnState {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.ConnState:
			return &r
		case *_http.ConnState:
			return r
		}
	case Int:
		v := _http.ConnState(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ConnState]"))
}

func _ConstructConnState(_v Object) _http.ConnState {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.ConnState:
			return _g
		case *_http.ConnState:
			return *_g
		}
	case Number:
		return _http.ConnState(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ConnState] or: Number"))
}

GO TYPE net/http.Cookie from net/http/cookie.go:
func ExtractGoObjectCookie(args []Object, index int) *_http.Cookie {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Cookie:
			return &r
		case *_http.Cookie:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Cookie]"))
}

// func _mapToCookie(o Map) *_http.Cookie {
// 	return &_http.Cookie{}
// }

// func _vectorToCookie(o *Vector) *_http.Cookie {
// 	return &_http.Cookie{
// 		Name: AssertString(o.Nth(0), "").S,
// 		Value: AssertString(o.Nth(1), "").S,
// 		Path: AssertString(o.Nth(2), "").S,
// 		Domain: AssertString(o.Nth(3), "").S,
// 		Expires: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		RawExpires: AssertString(o.Nth(5), "").S,
// 		MaxAge: AssertInt(o.Nth(6), "").I,
// 		Secure: ToBool(o.Nth(7)),
// 		HttpOnly: ToBool(o.Nth(8)),
// 		SameSite: _http.SameSite(AssertInt(o.Nth(9), "").I),
// 		Raw: AssertString(o.Nth(10), "").S,
// 		Unparsed: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 	}
// }

// func _ConstructCookie(_v Object) *_http.Cookie {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Cookie:
// 			return &_g
// 		case *_http.Cookie:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCookie(_o.(Map))
// 	case *Vector:
// 		return _vectorToCookie(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Cookie] or: Map or Vector"))
// }

GO TYPE net/http.CookieJar from net/http/jar.go:
func ExtractGoObjectCookieJar(args []Object, index int) *_http.CookieJar {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.CookieJar:
			return &r
		case *_http.CookieJar:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.CookieJar]"))
}

// func _ConstructCookieJar(_v Object) _http.CookieJar {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.CookieJar:
// 			return _g
// 		case *_http.CookieJar:
// 			return *_g
// 		}
// 	default:
// 		return _http.CookieJar(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for CookieJar))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.CookieJar] or: whatever"))
// }

GO TYPE net/http.Dir from net/http/fs.go:
func ExtractGoObjectDir(args []Object, index int) *_http.Dir {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Dir:
			return &r
		case *_http.Dir:
			return r
		}
	case String:
		v := _http.Dir(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Dir]"))
}

func _ConstructDir(_v Object) _http.Dir {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.Dir:
			return _g
		case *_http.Dir:
			return *_g
		}
	case String:
		return _http.Dir(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Dir] or: String"))
}

GO TYPE net/http.File from net/http/fs.go:
func ExtractGoObjectFile(args []Object, index int) *_http.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.File:
			return &r
		case *_http.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.File]"))
}

// func _ConstructFile(_v Object) _http.File {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.File:
// 			return _g
// 		case *_http.File:
// 			return *_g
// 		}
// 	default:
// 		return _http.File(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for File))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.File] or: whatever"))
// }

GO TYPE net/http.FileSystem from net/http/fs.go:
func ExtractGoObjectFileSystem(args []Object, index int) *_http.FileSystem {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.FileSystem:
			return &r
		case *_http.FileSystem:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.FileSystem]"))
}

// func _ConstructFileSystem(_v Object) _http.FileSystem {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.FileSystem:
// 			return _g
// 		case *_http.FileSystem:
// 			return *_g
// 		}
// 	default:
// 		return _http.FileSystem(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for FileSystem))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.FileSystem] or: whatever"))
// }

GO TYPE net/http.Flusher from net/http/server.go:
func ExtractGoObjectFlusher(args []Object, index int) *_http.Flusher {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Flusher:
			return &r
		case *_http.Flusher:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Flusher]"))
}

// func _ConstructFlusher(_v Object) _http.Flusher {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Flusher:
// 			return _g
// 		case *_http.Flusher:
// 			return *_g
// 		}
// 	default:
// 		return _http.Flusher(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Flusher))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Flusher] or: whatever"))
// }

GO TYPE net/http.Handler from net/http/server.go:
func ExtractGoObjectHandler(args []Object, index int) *_http.Handler {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Handler:
			return &r
		case *_http.Handler:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Handler]"))
}

// func _ConstructHandler(_v Object) _http.Handler {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Handler:
// 			return _g
// 		case *_http.Handler:
// 			return *_g
// 		}
// 	default:
// 		return _http.Handler(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Handler))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Handler] or: whatever"))
// }

GO TYPE net/http.HandlerFunc from net/http/server.go:
func ExtractGoObjectHandlerFunc(args []Object, index int) *_http.HandlerFunc {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.HandlerFunc:
			return &r
		case *_http.HandlerFunc:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.HandlerFunc]"))
}

// func _ConstructHandlerFunc(_v Object) _http.HandlerFunc {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.HandlerFunc:
// 			return _g
// 		case *_http.HandlerFunc:
// 			return *_g
// 		}
// 	default:
// 		return _http.HandlerFunc(_o.ABEND674(codegen.go: unknown underlying type *ast.FuncType for HandlerFunc))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.HandlerFunc] or: whatever"))
// }

GO TYPE net/http.Header from net/http/header.go:
func ExtractGoObjectHeader(args []Object, index int) *_http.Header {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Header:
			return &r
		case *_http.Header:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Header]"))
}

// func _ConstructHeader(_v Object) _http.Header {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Header:
// 			return _g
// 		case *_http.Header:
// 			return *_g
// 		}
// 	default:
// 		return _http.Header(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for Header))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Header] or: whatever"))
// }

GO TYPE net/http.Hijacker from net/http/server.go:
func ExtractGoObjectHijacker(args []Object, index int) *_http.Hijacker {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Hijacker:
			return &r
		case *_http.Hijacker:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Hijacker]"))
}

// func _ConstructHijacker(_v Object) _http.Hijacker {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Hijacker:
// 			return _g
// 		case *_http.Hijacker:
// 			return *_g
// 		}
// 	default:
// 		return _http.Hijacker(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Hijacker))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Hijacker] or: whatever"))
// }

GO TYPE net/http.ProtocolError from net/http/request.go:
func ExtractGoObjectProtocolError(args []Object, index int) *_http.ProtocolError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.ProtocolError:
			return &r
		case *_http.ProtocolError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ProtocolError]"))
}

func _mapToProtocolError(o Map) *_http.ProtocolError {
	return &_http.ProtocolError{}
}

func _vectorToProtocolError(o *Vector) *_http.ProtocolError {
	return &_http.ProtocolError{
		ErrorString: AssertString(o.Nth(0), "").S,
	}
}

func _ConstructProtocolError(_v Object) *_http.ProtocolError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.ProtocolError:
			return &_g
		case *_http.ProtocolError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProtocolError(_o.(Map))
	case *Vector:
		return _vectorToProtocolError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ProtocolError] or: Map or Vector"))
}

GO TYPE net/http.PushOptions from net/http/http.go:
func ExtractGoObjectPushOptions(args []Object, index int) *_http.PushOptions {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.PushOptions:
			return &r
		case *_http.PushOptions:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.PushOptions]"))
}

// func _mapToPushOptions(o Map) *_http.PushOptions {
// 	return &_http.PushOptions{}
// }

// func _vectorToPushOptions(o *Vector) *_http.PushOptions {
// 	return &_http.PushOptions{
// 		Method: AssertString(o.Nth(0), "").S,
// 		Header: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 	}
// }

// func _ConstructPushOptions(_v Object) *_http.PushOptions {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.PushOptions:
// 			return &_g
// 		case *_http.PushOptions:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToPushOptions(_o.(Map))
// 	case *Vector:
// 		return _vectorToPushOptions(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.PushOptions] or: Map or Vector"))
// }

GO TYPE net/http.Pusher from net/http/http.go:
func ExtractGoObjectPusher(args []Object, index int) *_http.Pusher {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Pusher:
			return &r
		case *_http.Pusher:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Pusher]"))
}

// func _ConstructPusher(_v Object) _http.Pusher {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Pusher:
// 			return _g
// 		case *_http.Pusher:
// 			return *_g
// 		}
// 	default:
// 		return _http.Pusher(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Pusher))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Pusher] or: whatever"))
// }

GO TYPE net/http.Request from net/http/request.go:
func ExtractGoObjectRequest(args []Object, index int) *_http.Request {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Request:
			return &r
		case *_http.Request:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Request]"))
}

// func _mapToRequest(o Map) *_http.Request {
// 	return &_http.Request{}
// }

// func _vectorToRequest(o *Vector) *_http.Request {
// 	return &_http.Request{
// 		Method: AssertString(o.Nth(0), "").S,
// 		URL: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Proto: AssertString(o.Nth(2), "").S,
// 		ProtoMajor: AssertInt(o.Nth(3), "").I,
// 		ProtoMinor: AssertInt(o.Nth(4), "").I,
// 		Header: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		Body: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		GetBody: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		ContentLength: AssertNumber(o.Nth(8), "").BigInt().Int64(),
// 		TransferEncoding: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Close: ToBool(o.Nth(10)),
// 		Host: AssertString(o.Nth(11), "").S,
// 		Form: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		PostForm: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		MultipartForm: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Trailer: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		RemoteAddr: AssertString(o.Nth(16), "").S,
// 		RequestURI: AssertString(o.Nth(17), "").S,
// 		TLS: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Cancel: ABEND047(gotypes.go: unsupported type *ast.ChanType),
// 		Response: *ABEND047(gotypes.go: unsupported type *ast.StructType),
// 	}
// }

// func _ConstructRequest(_v Object) *_http.Request {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Request:
// 			return &_g
// 		case *_http.Request:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRequest(_o.(Map))
// 	case *Vector:
// 		return _vectorToRequest(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Request] or: Map or Vector"))
// }

GO TYPE net/http.Response from net/http/response.go:
func ExtractGoObjectResponse(args []Object, index int) *_http.Response {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Response:
			return &r
		case *_http.Response:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Response]"))
}

// func _mapToResponse(o Map) *_http.Response {
// 	return &_http.Response{}
// }

// func _vectorToResponse(o *Vector) *_http.Response {
// 	return &_http.Response{
// 		Status: AssertString(o.Nth(0), "").S,
// 		StatusCode: AssertInt(o.Nth(1), "").I,
// 		Proto: AssertString(o.Nth(2), "").S,
// 		ProtoMajor: AssertInt(o.Nth(3), "").I,
// 		ProtoMinor: AssertInt(o.Nth(4), "").I,
// 		Header: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		Body: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ContentLength: AssertNumber(o.Nth(7), "").BigInt().Int64(),
// 		TransferEncoding: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Close: ToBool(o.Nth(9)),
// 		Uncompressed: ToBool(o.Nth(10)),
// 		Trailer: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		Request: *ABEND047(gotypes.go: unsupported type *ast.StructType),
// 		TLS: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructResponse(_v Object) *_http.Response {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Response:
// 			return &_g
// 		case *_http.Response:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToResponse(_o.(Map))
// 	case *Vector:
// 		return _vectorToResponse(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Response] or: Map or Vector"))
// }

GO TYPE net/http.ResponseWriter from net/http/server.go:
func ExtractGoObjectResponseWriter(args []Object, index int) *_http.ResponseWriter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.ResponseWriter:
			return &r
		case *_http.ResponseWriter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ResponseWriter]"))
}

// func _ConstructResponseWriter(_v Object) _http.ResponseWriter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.ResponseWriter:
// 			return _g
// 		case *_http.ResponseWriter:
// 			return *_g
// 		}
// 	default:
// 		return _http.ResponseWriter(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ResponseWriter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ResponseWriter] or: whatever"))
// }

GO TYPE net/http.RoundTripper from net/http/client.go:
func ExtractGoObjectRoundTripper(args []Object, index int) *_http.RoundTripper {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.RoundTripper:
			return &r
		case *_http.RoundTripper:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.RoundTripper]"))
}

// func _ConstructRoundTripper(_v Object) _http.RoundTripper {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.RoundTripper:
// 			return _g
// 		case *_http.RoundTripper:
// 			return *_g
// 		}
// 	default:
// 		return _http.RoundTripper(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for RoundTripper))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.RoundTripper] or: whatever"))
// }

GO TYPE net/http.SameSite from net/http/cookie.go:
func ExtractGoObjectSameSite(args []Object, index int) *_http.SameSite {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.SameSite:
			return &r
		case *_http.SameSite:
			return r
		}
	case Int:
		v := _http.SameSite(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.SameSite]"))
}

func _ConstructSameSite(_v Object) _http.SameSite {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.SameSite:
			return _g
		case *_http.SameSite:
			return *_g
		}
	case Number:
		return _http.SameSite(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.SameSite] or: Number"))
}

GO TYPE net/http.ServeMux from net/http/server.go:
func ExtractGoObjectServeMux(args []Object, index int) *_http.ServeMux {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.ServeMux:
			return &r
		case *_http.ServeMux:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ServeMux]"))
}

func _mapToServeMux(o Map) *_http.ServeMux {
	return &_http.ServeMux{}
}

func _vectorToServeMux(o *Vector) *_http.ServeMux {
	return &_http.ServeMux{}
}

func _ConstructServeMux(_v Object) *_http.ServeMux {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.ServeMux:
			return &_g
		case *_http.ServeMux:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToServeMux(_o.(Map))
	case *Vector:
		return _vectorToServeMux(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ServeMux] or: Map or Vector"))
}

GO TYPE net/http.Server from net/http/server.go:
func ExtractGoObjectServer(args []Object, index int) *_http.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Server:
			return &r
		case *_http.Server:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Server]"))
}

// func _mapToServer(o Map) *_http.Server {
// 	return &_http.Server{}
// }

// func _vectorToServer(o *Vector) *_http.Server {
// 	return &_http.Server{
// 		Addr: AssertString(o.Nth(0), "").S,
// 		Handler: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		TLSConfig: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ReadTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ReadHeaderTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		WriteTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		IdleTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		MaxHeaderBytes: AssertInt(o.Nth(7), "").I,
// 		TLSNextProto: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		ConnState: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		ErrorLog: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructServer(_v Object) *_http.Server {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Server:
// 			return &_g
// 		case *_http.Server:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToServer(_o.(Map))
// 	case *Vector:
// 		return _vectorToServer(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Server] or: Map or Vector"))
// }

GO TYPE net/http.Transport from net/http/transport.go:
func ExtractGoObjectTransport(args []Object, index int) *_http.Transport {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Transport:
			return &r
		case *_http.Transport:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Transport]"))
}

// func _mapToTransport(o Map) *_http.Transport {
// 	return &_http.Transport{}
// }

// func _vectorToTransport(o *Vector) *_http.Transport {
// 	return &_http.Transport{
// 		Proxy: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		DialContext: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		Dial: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		DialTLS: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		TLSClientConfig: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		TLSHandshakeTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		DisableKeepAlives: ToBool(o.Nth(6)),
// 		DisableCompression: ToBool(o.Nth(7)),
// 		MaxIdleConns: AssertInt(o.Nth(8), "").I,
// 		MaxIdleConnsPerHost: AssertInt(o.Nth(9), "").I,
// 		MaxConnsPerHost: AssertInt(o.Nth(10), "").I,
// 		IdleConnTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ResponseHeaderTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ExpectContinueTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		TLSNextProto: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		ProxyConnectHeader: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		MaxResponseHeaderBytes: AssertNumber(o.Nth(16), "").BigInt().Int64(),
// 	}
// }

// func _ConstructTransport(_v Object) *_http.Transport {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Transport:
// 			return &_g
// 		case *_http.Transport:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTransport(_o.(Map))
// 	case *Vector:
// 		return _vectorToTransport(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Transport] or: Map or Vector"))
// }

GO FUNC net/http.DetectContentType from net/http/sniff.go:
// func __detectContentType(data []byte)  {
// 	_res := _http.DetectContentType(data)
// 	return MakeString(_res)
// }

GO FUNC net/http.Error from net/http/server.go:
// func __error(w _http.ResponseWriter, error string, code int) Object {
// 	_http.Error(w, error, code)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.FileServer from net/http/fs.go:
func __fileServer(root _http.FileSystem) Object {
	_res := _http.FileServer(root)
	return MakeGoObject(_res)
}

GO FUNC net/http.Get from net/http/client.go:
func __get(url string) Object {
	resp, err := _http.Get(url)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.Handle from net/http/server.go:
// func __handle(pattern string, handler _http.Handler) Object {
// 	_http.Handle(pattern, handler)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.HandleFunc from net/http/server.go:
// func __handleFunc(pattern string, handler func) Object {
// 	_http.HandleFunc(pattern, handler)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.Head from net/http/client.go:
func __head(url string) Object {
	resp, err := _http.Head(url)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.MaxBytesReader from net/http/request.go:
// func __maxBytesReader(w _http.ResponseWriter, r ABEND987(genutils.go: imports not yet supported: io.ReadCloser), n int64) Object {
// 	return _http.MaxBytesReader(w, r, n)
// }

GO FUNC net/http.NewFileTransport from net/http/filetransport.go:
func __newFileTransport(fs _http.FileSystem) Object {
	_res := _http.NewFileTransport(fs)
	return MakeGoObject(_res)
}

GO FUNC net/http.NewRequest from net/http/request.go:
// func __newRequest(method string, url string, body ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _http.NewRequest(method, url, body)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.NewServeMux from net/http/server.go:
func __newServeMux() Object {
	_res := _http.NewServeMux()
	return MakeGoObject(_res)
}

GO FUNC net/http.NotFound from net/http/server.go:
// func __notFound(w _http.ResponseWriter, r *_http.Request) Object {
// 	_http.NotFound(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.NotFoundHandler from net/http/server.go:
func __notFoundHandler() Object {
	_res := _http.NotFoundHandler()
	return MakeGoObject(_res)
}

GO FUNC net/http.ParseHTTPVersion from net/http/request.go:
func __parseHTTPVersion(vers string) Object {
	major, minor, ok := _http.ParseHTTPVersion(vers)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(major))
	_res = _res.Conjoin(MakeInt(minor))
	_res = _res.Conjoin(MakeBoolean(ok))
	return _res
}

GO FUNC net/http.ParseTime from net/http/header.go:
// func __parseTime(text string) Object {
// 	t, err := _http.ParseTime(text)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(t)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.Post from net/http/client.go:
// func __post(url string, contentType string, body ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	resp, err := _http.Post(url, contentType, body)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(resp))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.PostForm from net/http/client.go:
// func __postForm(url string, data ABEND987(genutils.go: imports not yet supported: url.Values)) Object {
// 	resp, err := _http.PostForm(url, data)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(resp))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.ProxyFromEnvironment from net/http/transport.go:
func __proxyFromEnvironment(req *_http.Request) Object {
	_res1, _res2 := _http.ProxyFromEnvironment(req)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http.ProxyURL from net/http/transport.go:
// func __proxyURL(fixedURL *ABEND987(genutils.go: imports not yet supported: url.URL)) Object {
// 	return _http.ProxyURL(fixedURL)
// }

GO FUNC net/http.ReadRequest from net/http/request.go:
// func __readRequest(b *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res1, _res2 := _http.ReadRequest(b)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.ReadResponse from net/http/response.go:
// func __readResponse(r *ABEND987(genutils.go: imports not yet supported: bufio.Reader), req *_http.Request) Object {
// 	_res1, _res2 := _http.ReadResponse(r, req)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.Redirect from net/http/server.go:
// func __redirect(w _http.ResponseWriter, r *_http.Request, url string, code int) Object {
// 	_http.Redirect(w, r, url, code)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.RedirectHandler from net/http/server.go:
func __redirectHandler(url string, code int) Object {
	_res := _http.RedirectHandler(url, code)
	return MakeGoObject(_res)
}

GO FUNC net/http.Serve from net/http/server.go:
// func __serve(l ABEND987(genutils.go: imports not yet supported: net.Listener), handler _http.Handler)  {
// 	_res := _http.Serve(l, handler)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/http.ServeContent from net/http/fs.go:
// func __serveContent(w _http.ResponseWriter, req *_http.Request, name string, modtime ABEND987(genutils.go: imports not yet supported: time.Time), content ABEND987(genutils.go: imports not yet supported: io.ReadSeeker)) Object {
// 	_http.ServeContent(w, req, name, modtime, content)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.ServeFile from net/http/fs.go:
// func __serveFile(w _http.ResponseWriter, r *_http.Request, name string) Object {
// 	_http.ServeFile(w, r, name)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.ServeTLS from net/http/server.go:
// func __serveTLS(l ABEND987(genutils.go: imports not yet supported: net.Listener), handler _http.Handler, certFile string, keyFile string)  {
// 	_res := _http.ServeTLS(l, handler, certFile, keyFile)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/http.SetCookie from net/http/cookie.go:
// func __setCookie(w _http.ResponseWriter, cookie *_http.Cookie) Object {
// 	_http.SetCookie(w, cookie)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.StripPrefix from net/http/server.go:
func __stripPrefix(prefix string, h _http.Handler) Object {
	_res := _http.StripPrefix(prefix, h)
	return MakeGoObject(_res)
}

GO FUNC net/http.TimeoutHandler from net/http/server.go:
// func __timeoutHandler(h _http.Handler, dt ABEND987(genutils.go: imports not yet supported: time.Duration), msg string) Object {
// 	_res := _http.TimeoutHandler(h, dt, msg)
// 	return MakeGoObject(_res)
// }

GO TYPE net/http/cgi.Handler from net/http/cgi/host.go:
func ExtractGoObjectHandler(args []Object, index int) *_cgi.Handler {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cgi.Handler:
			return &r
		case *_cgi.Handler:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cgi.Handler]"))
}

// func _mapToHandler(o Map) *_cgi.Handler {
// 	return &_cgi.Handler{}
// }

// func _vectorToHandler(o *Vector) *_cgi.Handler {
// 	return &_cgi.Handler{
// 		Path: AssertString(o.Nth(0), "").S,
// 		Root: AssertString(o.Nth(1), "").S,
// 		Dir: AssertString(o.Nth(2), "").S,
// 		Env: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		InheritEnv: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Logger: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Args: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Stderr: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		PathLocationHandler: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructHandler(_v Object) *_cgi.Handler {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cgi.Handler:
// 			return &_g
// 		case *_cgi.Handler:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToHandler(_o.(Map))
// 	case *Vector:
// 		return _vectorToHandler(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cgi.Handler] or: Map or Vector"))
// }

GO FUNC net/http/cgi.Request from net/http/cgi/child.go:
func __request() Object {
	_res1, _res2 := _cgi.Request()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http/cgi.RequestFromMap from net/http/cgi/child.go:
// func __requestFromMap(params map[]) Object {
// 	_res1, _res2 := _cgi.RequestFromMap(params)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/cgi.Serve from net/http/cgi/child.go:
// func __serve(handler ABEND987(genutils.go: imports not yet supported: http.Handler))  {
// 	_res := _cgi.Serve(handler)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO TYPE net/http/cookiejar.Jar from net/http/cookiejar/jar.go:
func ExtractGoObjectJar(args []Object, index int) *_cookiejar.Jar {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cookiejar.Jar:
			return &r
		case *_cookiejar.Jar:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cookiejar.Jar]"))
}

func _mapToJar(o Map) *_cookiejar.Jar {
	return &_cookiejar.Jar{}
}

func _vectorToJar(o *Vector) *_cookiejar.Jar {
	return &_cookiejar.Jar{}
}

func _ConstructJar(_v Object) *_cookiejar.Jar {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _cookiejar.Jar:
			return &_g
		case *_cookiejar.Jar:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToJar(_o.(Map))
	case *Vector:
		return _vectorToJar(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[cookiejar.Jar] or: Map or Vector"))
}

GO TYPE net/http/cookiejar.Options from net/http/cookiejar/jar.go:
func ExtractGoObjectOptions(args []Object, index int) *_cookiejar.Options {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cookiejar.Options:
			return &r
		case *_cookiejar.Options:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cookiejar.Options]"))
}

// func _mapToOptions(o Map) *_cookiejar.Options {
// 	return &_cookiejar.Options{}
// }

// func _vectorToOptions(o *Vector) *_cookiejar.Options {
// 	return &_cookiejar.Options{
// 		PublicSuffixList: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 	}
// }

// func _ConstructOptions(_v Object) *_cookiejar.Options {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cookiejar.Options:
// 			return &_g
// 		case *_cookiejar.Options:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToOptions(_o.(Map))
// 	case *Vector:
// 		return _vectorToOptions(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cookiejar.Options] or: Map or Vector"))
// }

GO TYPE net/http/cookiejar.PublicSuffixList from net/http/cookiejar/jar.go:
func ExtractGoObjectPublicSuffixList(args []Object, index int) *_cookiejar.PublicSuffixList {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cookiejar.PublicSuffixList:
			return &r
		case *_cookiejar.PublicSuffixList:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cookiejar.PublicSuffixList]"))
}

// func _ConstructPublicSuffixList(_v Object) _cookiejar.PublicSuffixList {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cookiejar.PublicSuffixList:
// 			return _g
// 		case *_cookiejar.PublicSuffixList:
// 			return *_g
// 		}
// 	default:
// 		return _cookiejar.PublicSuffixList(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for PublicSuffixList))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cookiejar.PublicSuffixList] or: whatever"))
// }

GO FUNC net/http/cookiejar.New from net/http/cookiejar/jar.go:
func __new(o *_cookiejar.Options) Object {
	_res1, _res2 := _cookiejar.New(o)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http/fcgi.ProcessEnv from net/http/fcgi/child.go:
// func __processEnv(r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	return _fcgi.ProcessEnv(r)
// }

GO FUNC net/http/fcgi.Serve from net/http/fcgi/child.go:
// func __serve(l ABEND987(genutils.go: imports not yet supported: net.Listener), handler ABEND987(genutils.go: imports not yet supported: http.Handler))  {
// 	_res := _fcgi.Serve(l, handler)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO TYPE net/http/httptest.ResponseRecorder from net/http/httptest/recorder.go:
func ExtractGoObjectResponseRecorder(args []Object, index int) *_httptest.ResponseRecorder {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httptest.ResponseRecorder:
			return &r
		case *_httptest.ResponseRecorder:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httptest.ResponseRecorder]"))
}

// func _mapToResponseRecorder(o Map) *_httptest.ResponseRecorder {
// 	return &_httptest.ResponseRecorder{}
// }

// func _vectorToResponseRecorder(o *Vector) *_httptest.ResponseRecorder {
// 	return &_httptest.ResponseRecorder{
// 		Code: AssertInt(o.Nth(0), "").I,
// 		HeaderMap: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Body: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Flushed: ToBool(o.Nth(3)),
// 	}
// }

// func _ConstructResponseRecorder(_v Object) *_httptest.ResponseRecorder {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _httptest.ResponseRecorder:
// 			return &_g
// 		case *_httptest.ResponseRecorder:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToResponseRecorder(_o.(Map))
// 	case *Vector:
// 		return _vectorToResponseRecorder(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[httptest.ResponseRecorder] or: Map or Vector"))
// }

GO TYPE net/http/httptest.Server from net/http/httptest/server.go:
func ExtractGoObjectServer(args []Object, index int) *_httptest.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httptest.Server:
			return &r
		case *_httptest.Server:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httptest.Server]"))
}

// func _mapToServer(o Map) *_httptest.Server {
// 	return &_httptest.Server{}
// }

// func _vectorToServer(o *Vector) *_httptest.Server {
// 	return &_httptest.Server{
// 		URL: AssertString(o.Nth(0), "").S,
// 		Listener: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		TLS: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Config: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructServer(_v Object) *_httptest.Server {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _httptest.Server:
// 			return &_g
// 		case *_httptest.Server:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToServer(_o.(Map))
// 	case *Vector:
// 		return _vectorToServer(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[httptest.Server] or: Map or Vector"))
// }

GO FUNC net/http/httptest.NewRecorder from net/http/httptest/recorder.go:
func __newRecorder() Object {
	_res := _httptest.NewRecorder()
	return MakeGoObject(_res)
}

GO FUNC net/http/httptest.NewRequest from net/http/httptest/httptest.go:
// func __newRequest(method string, target string, body ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _httptest.NewRequest(method, target, body)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptest.NewServer from net/http/httptest/server.go:
// func __newServer(handler ABEND987(genutils.go: imports not yet supported: http.Handler)) Object {
// 	_res := _httptest.NewServer(handler)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptest.NewTLSServer from net/http/httptest/server.go:
// func __newTLSServer(handler ABEND987(genutils.go: imports not yet supported: http.Handler)) Object {
// 	_res := _httptest.NewTLSServer(handler)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptest.NewUnstartedServer from net/http/httptest/server.go:
// func __newUnstartedServer(handler ABEND987(genutils.go: imports not yet supported: http.Handler)) Object {
// 	_res := _httptest.NewUnstartedServer(handler)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptrace.ContextClientTrace from net/http/httptrace/trace.go:
// func __contextClientTrace(ctx ABEND987(genutils.go: imports not yet supported: context.Context)) Object {
// 	_res := _httptrace.ContextClientTrace(ctx)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptrace.WithClientTrace from net/http/httptrace/trace.go:
// func __withClientTrace(ctx ABEND987(genutils.go: imports not yet supported: context.Context), trace *_httptrace.ClientTrace) Object {
// 	return _httptrace.WithClientTrace(ctx, trace)
// }

GO FUNC net/http/httputil.DumpRequest from net/http/httputil/dump.go:
// func __dumpRequest(req *ABEND987(genutils.go: imports not yet supported: http.Request), body bool) Object {
// 	_res1, _res2 := _httputil.DumpRequest(req, body)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.DumpRequestOut from net/http/httputil/dump.go:
// func __dumpRequestOut(req *ABEND987(genutils.go: imports not yet supported: http.Request), body bool) Object {
// 	_res1, _res2 := _httputil.DumpRequestOut(req, body)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.DumpResponse from net/http/httputil/dump.go:
// func __dumpResponse(resp *ABEND987(genutils.go: imports not yet supported: http.Response), body bool) Object {
// 	_res1, _res2 := _httputil.DumpResponse(resp, body)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.NewChunkedReader from net/http/httputil/httputil.go:
// func __newChunkedReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	return _httputil.NewChunkedReader(r)
// }

GO FUNC net/http/httputil.NewChunkedWriter from net/http/httputil/httputil.go:
// func __newChunkedWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	return _httputil.NewChunkedWriter(w)
// }

GO FUNC net/http/httputil.NewClientConn from net/http/httputil/persist.go:
// func __newClientConn(c ABEND987(genutils.go: imports not yet supported: net.Conn), r *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res := _httputil.NewClientConn(c, r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewProxyClientConn from net/http/httputil/persist.go:
// func __newProxyClientConn(c ABEND987(genutils.go: imports not yet supported: net.Conn), r *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res := _httputil.NewProxyClientConn(c, r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewServerConn from net/http/httputil/persist.go:
// func __newServerConn(c ABEND987(genutils.go: imports not yet supported: net.Conn), r *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res := _httputil.NewServerConn(c, r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewSingleHostReverseProxy from net/http/httputil/reverseproxy.go:
// func __newSingleHostReverseProxy(target *ABEND987(genutils.go: imports not yet supported: url.URL)) Object {
// 	_res := _httputil.NewSingleHostReverseProxy(target)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/pprof.Cmdline from net/http/pprof/pprof.go:
// func __cmdline(w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	_pprof.Cmdline(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Handler from net/http/pprof/pprof.go:
func __handler(name string) Object {
	_res := _pprof.Handler(name)
	return MakeGoObject(_res)
}

GO FUNC net/http/pprof.Index from net/http/pprof/pprof.go:
// func __index(w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	_pprof.Index(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Profile from net/http/pprof/pprof.go:
// func __profile(w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	_pprof.Profile(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Symbol from net/http/pprof/pprof.go:
// func __symbol(w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	_pprof.Symbol(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Trace from net/http/pprof/pprof.go:
// func __trace(w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	_pprof.Trace(w, r)
// 	...ABEND675: TODO...
// }

GO TYPE net/mail.Address from net/mail/message.go:
func ExtractGoObjectAddress(args []Object, index int) *_mail.Address {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mail.Address:
			return &r
		case *_mail.Address:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.Address]"))
}

func _mapToAddress(o Map) *_mail.Address {
	return &_mail.Address{}
}

func _vectorToAddress(o *Vector) *_mail.Address {
	return &_mail.Address{
		Name: AssertString(o.Nth(0), "").S,
		Address: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructAddress(_v Object) *_mail.Address {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _mail.Address:
			return &_g
		case *_mail.Address:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToAddress(_o.(Map))
	case *Vector:
		return _vectorToAddress(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.Address] or: Map or Vector"))
}

GO TYPE net/mail.AddressParser from net/mail/message.go:
func ExtractGoObjectAddressParser(args []Object, index int) *_mail.AddressParser {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mail.AddressParser:
			return &r
		case *_mail.AddressParser:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.AddressParser]"))
}

// func _mapToAddressParser(o Map) *_mail.AddressParser {
// 	return &_mail.AddressParser{}
// }

// func _vectorToAddressParser(o *Vector) *_mail.AddressParser {
// 	return &_mail.AddressParser{
// 		WordDecoder: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructAddressParser(_v Object) *_mail.AddressParser {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _mail.AddressParser:
// 			return &_g
// 		case *_mail.AddressParser:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToAddressParser(_o.(Map))
// 	case *Vector:
// 		return _vectorToAddressParser(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.AddressParser] or: Map or Vector"))
// }

GO TYPE net/mail.Header from net/mail/message.go:
func ExtractGoObjectHeader(args []Object, index int) *_mail.Header {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mail.Header:
			return &r
		case *_mail.Header:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.Header]"))
}

// func _ConstructHeader(_v Object) _mail.Header {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _mail.Header:
// 			return _g
// 		case *_mail.Header:
// 			return *_g
// 		}
// 	default:
// 		return _mail.Header(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for Header))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.Header] or: whatever"))
// }

GO TYPE net/mail.Message from net/mail/message.go:
func ExtractGoObjectMessage(args []Object, index int) *_mail.Message {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mail.Message:
			return &r
		case *_mail.Message:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.Message]"))
}

// func _mapToMessage(o Map) *_mail.Message {
// 	return &_mail.Message{}
// }

// func _vectorToMessage(o *Vector) *_mail.Message {
// 	return &_mail.Message{
// 		Header: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		Body: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructMessage(_v Object) *_mail.Message {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _mail.Message:
// 			return &_g
// 		case *_mail.Message:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToMessage(_o.(Map))
// 	case *Vector:
// 		return _vectorToMessage(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.Message] or: Map or Vector"))
// }

GO FUNC net/mail.ParseAddress from net/mail/message.go:
func __parseAddress(address string) Object {
	_res1, _res2 := _mail.ParseAddress(address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.ParseAddressList from net/mail/message.go:
func __parseAddressList(list string) Object {
	_res1, _res2 := _mail.ParseAddressList(list)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.ParseDate from net/mail/message.go:
// func __parseDate(date string) Object {
// 	_res1, _res2 := _mail.ParseDate(date)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/mail.ReadMessage from net/mail/message.go:
// func __readMessage(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	msg, err := _mail.ReadMessage(r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(msg))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO TYPE net/rpc.Call from net/rpc/client.go:
func ExtractGoObjectCall(args []Object, index int) *_rpc.Call {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Call:
			return &r
		case *_rpc.Call:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Call]"))
}

// func _mapToCall(o Map) *_rpc.Call {
// 	return &_rpc.Call{}
// }

// func _vectorToCall(o *Vector) *_rpc.Call {
// 	return &_rpc.Call{
// 		ServiceMethod: AssertString(o.Nth(0), "").S,
// 		Args: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		Reply: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		Error: _errors.New(AssertString(o.Nth(3), "").S),
// 		Done: ABEND047(gotypes.go: unsupported type *ast.ChanType),
// 	}
// }

// func _ConstructCall(_v Object) *_rpc.Call {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rpc.Call:
// 			return &_g
// 		case *_rpc.Call:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCall(_o.(Map))
// 	case *Vector:
// 		return _vectorToCall(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Call] or: Map or Vector"))
// }

GO TYPE net/rpc.Client from net/rpc/client.go:
func ExtractGoObjectClient(args []Object, index int) *_rpc.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Client:
			return &r
		case *_rpc.Client:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Client]"))
}

func _mapToClient(o Map) *_rpc.Client {
	return &_rpc.Client{}
}

func _vectorToClient(o *Vector) *_rpc.Client {
	return &_rpc.Client{}
}

func _ConstructClient(_v Object) *_rpc.Client {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.Client:
			return &_g
		case *_rpc.Client:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToClient(_o.(Map))
	case *Vector:
		return _vectorToClient(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Client] or: Map or Vector"))
}

GO TYPE net/rpc.ClientCodec from net/rpc/client.go:
func ExtractGoObjectClientCodec(args []Object, index int) *_rpc.ClientCodec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.ClientCodec:
			return &r
		case *_rpc.ClientCodec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.ClientCodec]"))
}

// func _ConstructClientCodec(_v Object) _rpc.ClientCodec {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rpc.ClientCodec:
// 			return _g
// 		case *_rpc.ClientCodec:
// 			return *_g
// 		}
// 	default:
// 		return _rpc.ClientCodec(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ClientCodec))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.ClientCodec] or: whatever"))
// }

GO TYPE net/rpc.Request from net/rpc/server.go:
func ExtractGoObjectRequest(args []Object, index int) *_rpc.Request {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Request:
			return &r
		case *_rpc.Request:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Request]"))
}

func _mapToRequest(o Map) *_rpc.Request {
	return &_rpc.Request{}
}

func _vectorToRequest(o *Vector) *_rpc.Request {
	return &_rpc.Request{
		ServiceMethod: AssertString(o.Nth(0), "").S,
		Seq: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
	}
}

func _ConstructRequest(_v Object) *_rpc.Request {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.Request:
			return &_g
		case *_rpc.Request:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRequest(_o.(Map))
	case *Vector:
		return _vectorToRequest(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Request] or: Map or Vector"))
}

GO TYPE net/rpc.Response from net/rpc/server.go:
func ExtractGoObjectResponse(args []Object, index int) *_rpc.Response {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Response:
			return &r
		case *_rpc.Response:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Response]"))
}

func _mapToResponse(o Map) *_rpc.Response {
	return &_rpc.Response{}
}

func _vectorToResponse(o *Vector) *_rpc.Response {
	return &_rpc.Response{
		ServiceMethod: AssertString(o.Nth(0), "").S,
		Seq: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
		Error: AssertString(o.Nth(2), "").S,
	}
}

func _ConstructResponse(_v Object) *_rpc.Response {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.Response:
			return &_g
		case *_rpc.Response:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToResponse(_o.(Map))
	case *Vector:
		return _vectorToResponse(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Response] or: Map or Vector"))
}

GO TYPE net/rpc.Server from net/rpc/server.go:
func ExtractGoObjectServer(args []Object, index int) *_rpc.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Server:
			return &r
		case *_rpc.Server:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Server]"))
}

func _mapToServer(o Map) *_rpc.Server {
	return &_rpc.Server{}
}

func _vectorToServer(o *Vector) *_rpc.Server {
	return &_rpc.Server{}
}

func _ConstructServer(_v Object) *_rpc.Server {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.Server:
			return &_g
		case *_rpc.Server:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToServer(_o.(Map))
	case *Vector:
		return _vectorToServer(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Server] or: Map or Vector"))
}

GO TYPE net/rpc.ServerCodec from net/rpc/server.go:
func ExtractGoObjectServerCodec(args []Object, index int) *_rpc.ServerCodec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.ServerCodec:
			return &r
		case *_rpc.ServerCodec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.ServerCodec]"))
}

// func _ConstructServerCodec(_v Object) _rpc.ServerCodec {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rpc.ServerCodec:
// 			return _g
// 		case *_rpc.ServerCodec:
// 			return *_g
// 		}
// 	default:
// 		return _rpc.ServerCodec(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ServerCodec))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.ServerCodec] or: whatever"))
// }

GO TYPE net/rpc.ServerError from net/rpc/client.go:
func ExtractGoObjectServerError(args []Object, index int) *_rpc.ServerError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.ServerError:
			return &r
		case *_rpc.ServerError:
			return r
		}
	case String:
		v := _rpc.ServerError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.ServerError]"))
}

func _ConstructServerError(_v Object) _rpc.ServerError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.ServerError:
			return _g
		case *_rpc.ServerError:
			return *_g
		}
	case String:
		return _rpc.ServerError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.ServerError] or: String"))
}

GO FUNC net/rpc.Accept from net/rpc/server.go:
// func __accept(lis ABEND987(genutils.go: imports not yet supported: net.Listener)) Object {
// 	_rpc.Accept(lis)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.Dial from net/rpc/client.go:
func __dial(network string, address string) Object {
	_res1, _res2 := _rpc.Dial(network, address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.DialHTTP from net/rpc/client.go:
func __dialHTTP(network string, address string) Object {
	_res1, _res2 := _rpc.DialHTTP(network, address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.DialHTTPPath from net/rpc/client.go:
func __dialHTTPPath(network string, address string, path string) Object {
	_res1, _res2 := _rpc.DialHTTPPath(network, address, path)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.HandleHTTP from net/rpc/server.go:
// func __handleHTTP() Object {
// 	_rpc.HandleHTTP()
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.NewClient from net/rpc/client.go:
// func __newClient(conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _rpc.NewClient(conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc.NewClientWithCodec from net/rpc/client.go:
func __newClientWithCodec(codec _rpc.ClientCodec) Object {
	_res := _rpc.NewClientWithCodec(codec)
	return MakeGoObject(_res)
}

GO FUNC net/rpc.NewServer from net/rpc/server.go:
func __newServer() Object {
	_res := _rpc.NewServer()
	return MakeGoObject(_res)
}

GO FUNC net/rpc.Register from net/rpc/server.go:
// func __register(rcvr interface {})  {
// 	_res := _rpc.Register(rcvr)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/rpc.RegisterName from net/rpc/server.go:
// func __registerName(name string, rcvr interface {})  {
// 	_res := _rpc.RegisterName(name, rcvr)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/rpc.ServeCodec from net/rpc/server.go:
// func __serveCodec(codec _rpc.ServerCodec) Object {
// 	_rpc.ServeCodec(codec)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.ServeConn from net/rpc/server.go:
// func __serveConn(conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_rpc.ServeConn(conn)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc/jsonrpc.Dial from net/rpc/jsonrpc/client.go:
func __dial(network string, address string) Object {
	_res1, _res2 := _jsonrpc.Dial(network, address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc/jsonrpc.NewClient from net/rpc/jsonrpc/client.go:
// func __newClient(conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _jsonrpc.NewClient(conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc/jsonrpc.NewClientCodec from net/rpc/jsonrpc/client.go:
// func __newClientCodec(conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _jsonrpc.NewClientCodec(conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc/jsonrpc.NewServerCodec from net/rpc/jsonrpc/server.go:
// func __newServerCodec(conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _jsonrpc.NewServerCodec(conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc/jsonrpc.ServeConn from net/rpc/jsonrpc/server.go:
// func __serveConn(conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_jsonrpc.ServeConn(conn)
// 	...ABEND675: TODO...
// }

GO TYPE net/smtp.Auth from net/smtp/auth.go:
func ExtractGoObjectAuth(args []Object, index int) *_smtp.Auth {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _smtp.Auth:
			return &r
		case *_smtp.Auth:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/smtp.Auth]"))
}

// func _ConstructAuth(_v Object) _smtp.Auth {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _smtp.Auth:
// 			return _g
// 		case *_smtp.Auth:
// 			return *_g
// 		}
// 	default:
// 		return _smtp.Auth(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Auth))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[smtp.Auth] or: whatever"))
// }

GO TYPE net/smtp.Client from net/smtp/smtp.go:
func ExtractGoObjectClient(args []Object, index int) *_smtp.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _smtp.Client:
			return &r
		case *_smtp.Client:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/smtp.Client]"))
}

// func _mapToClient(o Map) *_smtp.Client {
// 	return &_smtp.Client{}
// }

// func _vectorToClient(o *Vector) *_smtp.Client {
// 	return &_smtp.Client{
// 		Text: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructClient(_v Object) *_smtp.Client {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _smtp.Client:
// 			return &_g
// 		case *_smtp.Client:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToClient(_o.(Map))
// 	case *Vector:
// 		return _vectorToClient(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[smtp.Client] or: Map or Vector"))
// }

GO TYPE net/smtp.ServerInfo from net/smtp/auth.go:
func ExtractGoObjectServerInfo(args []Object, index int) *_smtp.ServerInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _smtp.ServerInfo:
			return &r
		case *_smtp.ServerInfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/smtp.ServerInfo]"))
}

// func _mapToServerInfo(o Map) *_smtp.ServerInfo {
// 	return &_smtp.ServerInfo{}
// }

// func _vectorToServerInfo(o *Vector) *_smtp.ServerInfo {
// 	return &_smtp.ServerInfo{
// 		Name: AssertString(o.Nth(0), "").S,
// 		TLS: ToBool(o.Nth(1)),
// 		Auth: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 	}
// }

// func _ConstructServerInfo(_v Object) *_smtp.ServerInfo {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _smtp.ServerInfo:
// 			return &_g
// 		case *_smtp.ServerInfo:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToServerInfo(_o.(Map))
// 	case *Vector:
// 		return _vectorToServerInfo(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[smtp.ServerInfo] or: Map or Vector"))
// }

GO FUNC net/smtp.CRAMMD5Auth from net/smtp/auth.go:
func __cRAMMD5Auth(username string, secret string) Object {
	_res := _smtp.CRAMMD5Auth(username, secret)
	return MakeGoObject(_res)
}

GO FUNC net/smtp.Dial from net/smtp/smtp.go:
func __dial(addr string) Object {
	_res1, _res2 := _smtp.Dial(addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/smtp.NewClient from net/smtp/smtp.go:
// func __newClient(conn ABEND987(genutils.go: imports not yet supported: net.Conn), host string) Object {
// 	_res1, _res2 := _smtp.NewClient(conn, host)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/smtp.PlainAuth from net/smtp/auth.go:
func __plainAuth(identity string, username string, password string, host string) Object {
	_res := _smtp.PlainAuth(identity, username, password, host)
	return MakeGoObject(_res)
}

GO FUNC net/smtp.SendMail from net/smtp/smtp.go:
// func __sendMail(addr string, a _smtp.Auth, from string, to []string, msg []byte)  {
// 	_res := _smtp.SendMail(addr, a, from, to, msg)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO TYPE net/textproto.Conn from net/textproto/textproto.go:
func ExtractGoObjectConn(args []Object, index int) *_textproto.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Conn:
			return &r
		case *_textproto.Conn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Conn]"))
}

func _mapToConn(o Map) *_textproto.Conn {
	return &_textproto.Conn{}
}

func _vectorToConn(o *Vector) *_textproto.Conn {
	return &_textproto.Conn{}
}

func _ConstructConn(_v Object) *_textproto.Conn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.Conn:
			return &_g
		case *_textproto.Conn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToConn(_o.(Map))
	case *Vector:
		return _vectorToConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Conn] or: Map or Vector"))
}

GO TYPE net/textproto.Error from net/textproto/textproto.go:
func ExtractGoObjectError(args []Object, index int) *_textproto.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Error:
			return &r
		case *_textproto.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Error]"))
}

func _mapToError(o Map) *_textproto.Error {
	return &_textproto.Error{}
}

func _vectorToError(o *Vector) *_textproto.Error {
	return &_textproto.Error{
		Code: AssertInt(o.Nth(0), "").I,
		Msg: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructError(_v Object) *_textproto.Error {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.Error:
			return &_g
		case *_textproto.Error:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToError(_o.(Map))
	case *Vector:
		return _vectorToError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Error] or: Map or Vector"))
}

GO TYPE net/textproto.MIMEHeader from net/textproto/header.go:
func ExtractGoObjectMIMEHeader(args []Object, index int) *_textproto.MIMEHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.MIMEHeader:
			return &r
		case *_textproto.MIMEHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.MIMEHeader]"))
}

// func _ConstructMIMEHeader(_v Object) _textproto.MIMEHeader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _textproto.MIMEHeader:
// 			return _g
// 		case *_textproto.MIMEHeader:
// 			return *_g
// 		}
// 	default:
// 		return _textproto.MIMEHeader(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for MIMEHeader))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.MIMEHeader] or: whatever"))
// }

GO TYPE net/textproto.Pipeline from net/textproto/pipeline.go:
func ExtractGoObjectPipeline(args []Object, index int) *_textproto.Pipeline {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Pipeline:
			return &r
		case *_textproto.Pipeline:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Pipeline]"))
}

func _mapToPipeline(o Map) *_textproto.Pipeline {
	return &_textproto.Pipeline{}
}

func _vectorToPipeline(o *Vector) *_textproto.Pipeline {
	return &_textproto.Pipeline{}
}

func _ConstructPipeline(_v Object) *_textproto.Pipeline {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.Pipeline:
			return &_g
		case *_textproto.Pipeline:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPipeline(_o.(Map))
	case *Vector:
		return _vectorToPipeline(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Pipeline] or: Map or Vector"))
}

GO TYPE net/textproto.ProtocolError from net/textproto/textproto.go:
func ExtractGoObjectProtocolError(args []Object, index int) *_textproto.ProtocolError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.ProtocolError:
			return &r
		case *_textproto.ProtocolError:
			return r
		}
	case String:
		v := _textproto.ProtocolError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.ProtocolError]"))
}

func _ConstructProtocolError(_v Object) _textproto.ProtocolError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.ProtocolError:
			return _g
		case *_textproto.ProtocolError:
			return *_g
		}
	case String:
		return _textproto.ProtocolError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.ProtocolError] or: String"))
}

GO TYPE net/textproto.Reader from net/textproto/reader.go:
func ExtractGoObjectReader(args []Object, index int) *_textproto.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Reader:
			return &r
		case *_textproto.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Reader]"))
}

// func _mapToReader(o Map) *_textproto.Reader {
// 	return &_textproto.Reader{}
// }

// func _vectorToReader(o *Vector) *_textproto.Reader {
// 	return &_textproto.Reader{
// 		R: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructReader(_v Object) *_textproto.Reader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _textproto.Reader:
// 			return &_g
// 		case *_textproto.Reader:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToReader(_o.(Map))
// 	case *Vector:
// 		return _vectorToReader(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Reader] or: Map or Vector"))
// }

GO TYPE net/textproto.Writer from net/textproto/writer.go:
func ExtractGoObjectWriter(args []Object, index int) *_textproto.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Writer:
			return &r
		case *_textproto.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Writer]"))
}

// func _mapToWriter(o Map) *_textproto.Writer {
// 	return &_textproto.Writer{}
// }

// func _vectorToWriter(o *Vector) *_textproto.Writer {
// 	return &_textproto.Writer{
// 		W: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructWriter(_v Object) *_textproto.Writer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _textproto.Writer:
// 			return &_g
// 		case *_textproto.Writer:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToWriter(_o.(Map))
// 	case *Vector:
// 		return _vectorToWriter(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Writer] or: Map or Vector"))
// }

GO FUNC net/textproto.Dial from net/textproto/textproto.go:
func __dial(network string, addr string) Object {
	_res1, _res2 := _textproto.Dial(network, addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.NewConn from net/textproto/textproto.go:
// func __newConn(conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _textproto.NewConn(conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/textproto.NewReader from net/textproto/reader.go:
// func __newReader(r *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res := _textproto.NewReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/textproto.NewWriter from net/textproto/writer.go:
// func __newWriter(w *ABEND987(genutils.go: imports not yet supported: bufio.Writer)) Object {
// 	_res := _textproto.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC net/textproto.TrimBytes from net/textproto/textproto.go:
// func __trimBytes(b []byte) Object {
// 	_res := _textproto.TrimBytes(b)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO TYPE net/url.Error from net/url/url.go:
func ExtractGoObjectError(args []Object, index int) *_url.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.Error:
			return &r
		case *_url.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Error]"))
}

func _mapToError(o Map) *_url.Error {
	return &_url.Error{}
}

func _vectorToError(o *Vector) *_url.Error {
	return &_url.Error{
		Op: AssertString(o.Nth(0), "").S,
		URL: AssertString(o.Nth(1), "").S,
		Err: _errors.New(AssertString(o.Nth(2), "").S),
	}
}

func _ConstructError(_v Object) *_url.Error {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _url.Error:
			return &_g
		case *_url.Error:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToError(_o.(Map))
	case *Vector:
		return _vectorToError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Error] or: Map or Vector"))
}

GO TYPE net/url.EscapeError from net/url/url.go:
func ExtractGoObjectEscapeError(args []Object, index int) *_url.EscapeError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.EscapeError:
			return &r
		case *_url.EscapeError:
			return r
		}
	case String:
		v := _url.EscapeError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.EscapeError]"))
}

func _ConstructEscapeError(_v Object) _url.EscapeError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _url.EscapeError:
			return _g
		case *_url.EscapeError:
			return *_g
		}
	case String:
		return _url.EscapeError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.EscapeError] or: String"))
}

GO TYPE net/url.InvalidHostError from net/url/url.go:
func ExtractGoObjectInvalidHostError(args []Object, index int) *_url.InvalidHostError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.InvalidHostError:
			return &r
		case *_url.InvalidHostError:
			return r
		}
	case String:
		v := _url.InvalidHostError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.InvalidHostError]"))
}

func _ConstructInvalidHostError(_v Object) _url.InvalidHostError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _url.InvalidHostError:
			return _g
		case *_url.InvalidHostError:
			return *_g
		}
	case String:
		return _url.InvalidHostError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.InvalidHostError] or: String"))
}

GO TYPE net/url.URL from net/url/url.go:
func ExtractGoObjectURL(args []Object, index int) *_url.URL {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.URL:
			return &r
		case *_url.URL:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.URL]"))
}

// func _mapToURL(o Map) *_url.URL {
// 	return &_url.URL{}
// }

// func _vectorToURL(o *Vector) *_url.URL {
// 	return &_url.URL{
// 		Scheme: AssertString(o.Nth(0), "").S,
// 		Opaque: AssertString(o.Nth(1), "").S,
// 		User: *ABEND047(gotypes.go: unsupported type *ast.StructType),
// 		Host: AssertString(o.Nth(3), "").S,
// 		Path: AssertString(o.Nth(4), "").S,
// 		RawPath: AssertString(o.Nth(5), "").S,
// 		ForceQuery: ToBool(o.Nth(6)),
// 		RawQuery: AssertString(o.Nth(7), "").S,
// 		Fragment: AssertString(o.Nth(8), "").S,
// 	}
// }

// func _ConstructURL(_v Object) *_url.URL {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _url.URL:
// 			return &_g
// 		case *_url.URL:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToURL(_o.(Map))
// 	case *Vector:
// 		return _vectorToURL(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[url.URL] or: Map or Vector"))
// }

GO TYPE net/url.Userinfo from net/url/url.go:
func ExtractGoObjectUserinfo(args []Object, index int) *_url.Userinfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.Userinfo:
			return &r
		case *_url.Userinfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Userinfo]"))
}

func _mapToUserinfo(o Map) *_url.Userinfo {
	return &_url.Userinfo{}
}

func _vectorToUserinfo(o *Vector) *_url.Userinfo {
	return &_url.Userinfo{}
}

func _ConstructUserinfo(_v Object) *_url.Userinfo {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _url.Userinfo:
			return &_g
		case *_url.Userinfo:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUserinfo(_o.(Map))
	case *Vector:
		return _vectorToUserinfo(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Userinfo] or: Map or Vector"))
}

GO TYPE net/url.Values from net/url/url.go:
func ExtractGoObjectValues(args []Object, index int) *_url.Values {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.Values:
			return &r
		case *_url.Values:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Values]"))
}

// func _ConstructValues(_v Object) _url.Values {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _url.Values:
// 			return _g
// 		case *_url.Values:
// 			return *_g
// 		}
// 	default:
// 		return _url.Values(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for Values))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Values] or: whatever"))
// }

GO FUNC net/url.Parse from net/url/url.go:
func __parse(rawurl string) Object {
	_res1, _res2 := _url.Parse(rawurl)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.ParseQuery from net/url/url.go:
func __parseQuery(query string) Object {
	_res1, _res2 := _url.ParseQuery(query)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.ParseRequestURI from net/url/url.go:
func __parseRequestURI(rawurl string) Object {
	_res1, _res2 := _url.ParseRequestURI(rawurl)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.PathUnescape from net/url/url.go:
func __pathUnescape(s string) Object {
	_res1, _res2 := _url.PathUnescape(s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.QueryUnescape from net/url/url.go:
func __queryUnescape(s string) Object {
	_res1, _res2 := _url.QueryUnescape(s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.User from net/url/url.go:
func __user(username string) Object {
	_res := _url.User(username)
	return MakeGoObject(_res)
}

GO FUNC net/url.UserPassword from net/url/url.go:
func __userPassword(username string, password string) Object {
	_res := _url.UserPassword(username, password)
	return MakeGoObject(_res)
}

Adding custom imports to _tests/gold/amd64-darwin/joker/custom.go
Adding custom loaded libraries to _tests/gold/amd64-darwin/joker/core/data/core.joke
ABENDs: 047(73) 987(60) 674(28) 675(18) 048(13) 042(6) 902(4) 883(2) 907(2) 906(1) 908(1)
Totals: functions=1348 methods=1200 (89.02%) standalone=148 (10.98%) generated=81 (54.73%)
        types=102 generated=37 (36.27%)
