(require '[joker.string :as s])

(def rpl s/replace)

(defn debug
  [& args]
  (when ((joker.os/env) "JOKER_DEBUG_STD")
    (apply println args)))

;; Discover namespaces dynamically by finding *.joke files.
(def namespaces
  (vec (->> (joker.os/ls ".")
            (remove :dir?)
            (map :name)
            (remove #(= "generate-std.joke" %))
            (remove #(= "generate-custom.joke" %))  ; TODO: remove when generate-custom.joke goes away
            (filter #(s/ends-with? % ".joke"))
            (map #(rpl % #"[.]joke$" ""))
            (map symbol))))

(debug "Namespaces:" namespaces)
(apply require :reload namespaces) ; :reload in case namespaces become 'joker.base64 etc.

(def fn-template
  (slurp "fn.tmpl"))

(def arity-template
  (slurp "arity.tmpl"))

(def package-template
  (slurp "package.tmpl"))

(def intern-template
  (slurp "intern.tmpl"))

(defn q
  [s]
  (str "\"" s "\""))

(defn raw-quoted-string
  "Returns a Go-style backtick-quoted string with backticks handled by appending double-quoted backticks"
  [s]
  (str "`" (rpl s "`" "` + \"`\" + `") "`")
  )

(defn go-name
  [fn-name]
  (let [n (-> fn-name
              (rpl "-" "_")
              (rpl "?" "")
              (str "_"))]
    (cond
      (s/ends-with? fn-name "?")
      (str "is" n)
      (s/ends-with? fn-name ".")
      (rpl n "." "")
      :else n)))

(defn resolve-package
  [pkg ns-name-final]
  (if (= pkg ns-name-final)
    ""  ; it me
    (str pkg ".")))  ; It's up to the *.joke generator to reduce x/y/z package paths to a suitable slashless alias

(defn extract-arg
  [m ns-name-final]
  (let [fulltype (str (:tag m))]
    (if (s/includes? fulltype "/")
      (let [spl (s/split fulltype #"/")
            pkg (spl 0)
            t (spl 1)
            t (cond-> t
                (:varargs m) (str "VarArgs"))]
        (str (resolve-package pkg ns-name-final) "ExtractGoObject" t))
      (let [t (cond-> fulltype
                (:varargs m) (str "s"))]
        (str "Extract" t)))))

(defn extract-args
  [args ns-name-final]
  (s/join
   "\n\t\t"
   (map-indexed
    (fn [i arg]
      (let [m (meta arg)
            extract (extract-arg m ns-name-final)]
        (str arg " := " extract "(_args, " (str i) ")")))
    args)))

(defn handle-varargs
  [args]
  (let [c (count args)]
    (if (and (> c 1)
             (= '& (nth args (- c 2))))
      (let [vargs (vary-meta (last args) assoc :varargs true)]
        (conj (subvec args 0 (- c 2)) vargs))
      args)))

(defn generate-arity
  [args go tag ns-name-final]
  (let [handle-args (handle-varargs args)
        cnt (count handle-args)
        varargs? (< cnt (count args))
        go-expr (cond
                  (string? go) go
                  varargs? (:varargs go)
                  :else (get go cnt))
        go-res (if (s/starts-with? go-expr "!")
                 (subs go-expr 1)
                 (str "_res := " go-expr))]
    (-> arity-template
        (rpl "{arity}" (if varargs? "true" (str "_c == " (count args))))
        (rpl "{arityCheck}" (if varargs?
                              (str "CheckArity(_args, " (dec cnt) ", " 999 ")")
                              "{blank}"))
        (rpl "{args}" (if (empty? args)
                        "{blank}"
                        (extract-args handle-args ns-name-final)))
        (rpl "{goExpr}" (rpl go-res "; " "\n\t\t"))
        (rpl "{return}"
             (if tag
               (str "return Make" tag "(_res)")
               "return _res")))))

(defn generate-arglist
  [args]
  (str "NewVectorFrom("
       (s/join ", " (for [arg args]
                      (str "MakeSymbol(" (q (str arg)) ")")))
       ")"))

(defn generate-fn
  [ns-name ns-name-final k v]
  (debug "Processing function" v)
  (let [m (meta v)
        arglists (:arglists m)
        go-fn-name (go-name (str k))
        arities (s/join "\n\t" (map #(generate-arity % (:go m) (:tag m) ns-name-final) arglists))
        fn-str (-> fn-template
                   (rpl "{fnName}" go-fn-name)
                   (rpl "{arities}" arities))
        intern-str (-> intern-template
                       (rpl "{nsFullName}" ns-name)
                       (rpl "{nsName}" ns-name-final)
                       (rpl "{fnName}" (str k))
                       (rpl "{goName}" go-fn-name)
                       (rpl "{fnDocstring}" (raw-quoted-string (:doc m)))
                       (rpl "{added}" (:added m))
                       (rpl "{args}"
                            (s/join ", " (for [args arglists]
                                           (generate-arglist args)))))]
    [fn-str intern-str]))

(defn comment-out
  [s]
  (-> s
      (rpl "\n// " "\n")
      (rpl "\n" "\n//")
      (rpl "\n// package" "\npackage")))

(defn compare-imports
  [^String l ^String r]
  (cond
    (s/starts-with? l ". ") (if (s/starts-with? r ". ")
                              (compare l r)
                              -1)
    (s/starts-with? r ". ") 1
    :else (compare l r)))

(defn- ns-public-fns
  "Return only publics that are functions."
  [ns]
  (remove #(:macro (meta (val %)))
          (filter #(:arglists (meta (val %))) (ns-publics ns))))

(defn- ns-public-go-fns
  "Return only publics that are functions and have additional Go-specific metadata."
  [ns]
  (filter #(:go (meta (val %))) (ns-public-fns ns)))

(defn- warn-about-skipped-publics
  [skipped]
  (when (> (count skipped) 0)
    (println-err "WARNING: skipping publics that are not Go-calling functions:" skipped)))

(defn generate-ns
  [ns-sym ns-name ns-name-final]
  (let [ns (find-ns ns-sym)
        m (meta ns)
        go-fns (sort-by first (ns-public-go-fns ns))
        fns (for [[k v] go-fns]
              (generate-fn ns-name ns-name-final k v))
        res (-> package-template
                (rpl "{nsFullName}" ns-name)
                (rpl "{nsName}" ns-name-final)
                (rpl "{imports}"
                     (s/join "\n\t" (sort compare-imports (conj
                                                           (mapv q (:go-imports m))
                                                           ". \"github.com/candid82/joker/core\""))))
                (rpl "{fns}" (s/join "\n" (map first fns)))
                (rpl "{nsDocstring}" (:doc m))
                (rpl "{interns}" (s/join "\n\t" (map second fns))))
        res (if (:empty m)
              (comment-out res)
              res)]
    (warn-about-skipped-publics (remove (set (map #(key %) go-fns))
                                        (map #(key %) (ns-publics ns))))
    res))

(defn ns-file-name
  [dir ns-name-final]
  (str dir "/a_" ns-name-final ".go"))

(defn remove-blanky-lines
  [s]
  (-> s
      (rpl #"[[:space:]]*{blank}" "")))

(doseq [ns-sym namespaces]
  (let [ns-name (str "joker." ns-sym)
        dir (rpl (str ns-sym) "." "/")
        ns-name-final (rpl ns-name #".*[.]" "")]
    (debug "Processing namespace" ns-name "in" dir "final name" ns-name-final)
    (spit (ns-file-name dir ns-name-final)
          (remove-blanky-lines (generate-ns ns-sym ns-name ns-name-final)))))

;;; Handle "custom" (gostd-generated) namespaces.

(defn new-custom-namespaces-here
  [dir]
  (->> (joker.os/ls dir)
       (remove :dir?)
       (map :name)
       (filter #(s/ends-with? % ".joke"))
       (map #(rpl % #"[.]joke$" ""))
       (map symbol)
       (map #(str dir "/" %))))

(defn find-dirs
  [dir]
  (->> (joker.os/ls dir)
       (filter :dir?)
       (map :name)))

(defn walk-dirs
  [dir]
  (let [d (find-dirs dir)
        dirs (map #(str dir "/" %) d)
        subdirs (mapcat #(walk-dirs %) dirs)]
    (if (empty? subdirs)
      dirs
      (apply concat (list dirs subdirs)))))

(def custom-namespaces (mapv (comp symbol #(rpl % "/" "."))
                             (sort (mapcat new-custom-namespaces-here (walk-dirs "go")))))

(apply require :reload custom-namespaces)

(doseq [ns-sym custom-namespaces]
  (let [ns-name (str ns-sym)
        dir (rpl ns-name "." "/")
        ns-name-final (rpl ns-name #".*[.]" "")]
    (debug "Processing custom namespace" ns-name "in" dir "final name" ns-name-final)
    (spit (ns-file-name dir ns-name-final)
          (remove-blanky-lines (generate-ns ns-sym ns-name ns-name-final)))))
