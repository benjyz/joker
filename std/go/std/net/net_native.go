// Auto-generated by gostd at 2019-09-17T13:14:28.216621211-04:00 by version 0.1, do not edit!!

package net

import (
	_errors "errors"
	"fmt"
	. "github.com/candid82/joker/core"
	_net "net"
	_reflect "reflect"
)

func ExtractGoObjectAddr(args []Object, index int) *_net.Addr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Addr:
			return &r
		case *_net.Addr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Addr]"))
}

// func _ConstructAddr(_v Object) _net.Addr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Addr:
// 			return _g
// 		case *_net.Addr:
// 			return *_g
// 		}
// 	default:
// 		return _net.Addr(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Addr))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Addr] or: whatever"))
// }

func ExtractGo_go_std_net__Addr(rcvr, arg string, args *ArraySeq, n int) (res _net.Addr) {
	a := CheckGoNth(rcvr, "go.std.net/Addr", arg, args, n).O
	res, ok := a.(_net.Addr)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Addr], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectAddrError(args []Object, index int) *_net.AddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.AddrError:
			return &r
		case *_net.AddrError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.AddrError]"))
}

func _mapToAddrError(o Map) *_net.AddrError {
	return &_net.AddrError{}
}

func _vectorToAddrError(o *Vector) *_net.AddrError {
	return &_net.AddrError{
		Err:  AssertString(o.Nth(0), "").S,
		Addr: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructAddrError(_v Object) *_net.AddrError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.AddrError:
			return &_g
		case *_net.AddrError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToAddrError(_o.(Map))
	case *Vector:
		return _vectorToAddrError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.AddrError] or: Map or Vector"))
}

func ExtractGo_go_std_net__AddrError(rcvr, arg string, args *ArraySeq, n int) (res _net.AddrError) {
	a := CheckGoNth(rcvr, "go.std.net/AddrError", arg, args, n).O
	res, ok := a.(_net.AddrError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/AddrError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectBuffers(args []Object, index int) *_net.Buffers {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Buffers:
			return &r
		case *_net.Buffers:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Buffers]"))
}

// func _ConstructBuffers(_v Object) _net.Buffers {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Buffers:
// 			return _g
// 		case *_net.Buffers:
// 			return *_g
// 		}
// 	default:
// 		return _net.Buffers(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for Buffers))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Buffers] or: whatever"))
// }

func ExtractGo_go_std_net__Buffers(rcvr, arg string, args *ArraySeq, n int) (res _net.Buffers) {
	a := CheckGoNth(rcvr, "go.std.net/Buffers", arg, args, n).O
	res, ok := a.(_net.Buffers)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Buffers], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectConn(args []Object, index int) *_net.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Conn:
			return &r
		case *_net.Conn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Conn]"))
}

// func _ConstructConn(_v Object) _net.Conn {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Conn:
// 			return _g
// 		case *_net.Conn:
// 			return *_g
// 		}
// 	default:
// 		return _net.Conn(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Conn))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Conn] or: whatever"))
// }

func ExtractGo_go_std_net__Conn(rcvr, arg string, args *ArraySeq, n int) (res _net.Conn) {
	a := CheckGoNth(rcvr, "go.std.net/Conn", arg, args, n).O
	res, ok := a.(_net.Conn)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Conn], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectDNSConfigError(args []Object, index int) *_net.DNSConfigError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.DNSConfigError:
			return &r
		case *_net.DNSConfigError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.DNSConfigError]"))
}

func _mapToDNSConfigError(o Map) *_net.DNSConfigError {
	return &_net.DNSConfigError{}
}

func _vectorToDNSConfigError(o *Vector) *_net.DNSConfigError {
	return &_net.DNSConfigError{
		Err: _errors.New(AssertString(o.Nth(0), "").S),
	}
}

func _ConstructDNSConfigError(_v Object) *_net.DNSConfigError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.DNSConfigError:
			return &_g
		case *_net.DNSConfigError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDNSConfigError(_o.(Map))
	case *Vector:
		return _vectorToDNSConfigError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.DNSConfigError] or: Map or Vector"))
}

func ExtractGo_go_std_net__DNSConfigError(rcvr, arg string, args *ArraySeq, n int) (res _net.DNSConfigError) {
	a := CheckGoNth(rcvr, "go.std.net/DNSConfigError", arg, args, n).O
	res, ok := a.(_net.DNSConfigError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/DNSConfigError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectDNSError(args []Object, index int) *_net.DNSError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.DNSError:
			return &r
		case *_net.DNSError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.DNSError]"))
}

func _mapToDNSError(o Map) *_net.DNSError {
	return &_net.DNSError{}
}

func _vectorToDNSError(o *Vector) *_net.DNSError {
	return &_net.DNSError{
		Err:         AssertString(o.Nth(0), "").S,
		Name:        AssertString(o.Nth(1), "").S,
		Server:      AssertString(o.Nth(2), "").S,
		IsTimeout:   ToBool(o.Nth(3)),
		IsTemporary: ToBool(o.Nth(4)),
	}
}

func _ConstructDNSError(_v Object) *_net.DNSError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.DNSError:
			return &_g
		case *_net.DNSError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDNSError(_o.(Map))
	case *Vector:
		return _vectorToDNSError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.DNSError] or: Map or Vector"))
}

func ExtractGo_go_std_net__DNSError(rcvr, arg string, args *ArraySeq, n int) (res _net.DNSError) {
	a := CheckGoNth(rcvr, "go.std.net/DNSError", arg, args, n).O
	res, ok := a.(_net.DNSError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/DNSError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectDialer(args []Object, index int) *_net.Dialer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Dialer:
			return &r
		case *_net.Dialer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Dialer]"))
}

// func _mapToDialer(o Map) *_net.Dialer {
// 	return &_net.Dialer{}
// }

// func _vectorToDialer(o *Vector) *_net.Dialer {
// 	return &_net.Dialer{
// 		Timeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Deadline: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		LocalAddr: ABEND048(codegen.go: no conversion from Clojure for net.Addr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		DualStack: ToBool(o.Nth(3)),
// 		FallbackDelay: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		KeepAlive: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Resolver: ABEND048(codegen.go: no conversion from Clojure for *net.Resolver (net.Resolver)),
// 		Cancel: ABEND047(gotypes.go: unsupported type *ast.ChanType),
// 		Control: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructDialer(_v Object) *_net.Dialer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Dialer:
// 			return &_g
// 		case *_net.Dialer:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToDialer(_o.(Map))
// 	case *Vector:
// 		return _vectorToDialer(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Dialer] or: Map or Vector"))
// }

func ExtractGo_go_std_net__Dialer(rcvr, arg string, args *ArraySeq, n int) (res _net.Dialer) {
	a := CheckGoNth(rcvr, "go.std.net/Dialer", arg, args, n).O
	res, ok := a.(_net.Dialer)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Dialer], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectError(args []Object, index int) *_net.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Error:
			return &r
		case *_net.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Error]"))
}

// func _ConstructError(_v Object) _net.Error {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Error:
// 			return _g
// 		case *_net.Error:
// 			return *_g
// 		}
// 	default:
// 		return _net.Error(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Error))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Error] or: whatever"))
// }

func ExtractGo_go_std_net__Error(rcvr, arg string, args *ArraySeq, n int) (res _net.Error) {
	a := CheckGoNth(rcvr, "go.std.net/Error", arg, args, n).O
	res, ok := a.(_net.Error)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Error], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectFlags(args []Object, index int) *_net.Flags {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Flags:
			return &r
		case *_net.Flags:
			return r
		}
	case Number:
		v := _net.Flags(ExtractUInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Flags]"))
}

func _ConstructFlags(_v Object) _net.Flags {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.Flags:
			return _g
		case *_net.Flags:
			return *_g
		}
	case Number:
		return _net.Flags(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Flags] or: Number"))
}

func ExtractGo_go_std_net__Flags(rcvr, arg string, args *ArraySeq, n int) (res _net.Flags) {
	a := CheckGoNth(rcvr, "go.std.net/Flags", arg, args, n).O
	res, ok := a.(_net.Flags)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Flags], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectHardwareAddr(args []Object, index int) *_net.HardwareAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.HardwareAddr:
			return &r
		case *_net.HardwareAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.HardwareAddr]"))
}

// func _ConstructHardwareAddr(_v Object) _net.HardwareAddr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.HardwareAddr:
// 			return _g
// 		case *_net.HardwareAddr:
// 			return *_g
// 		}
// 	default:
// 		return _net.HardwareAddr(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for HardwareAddr))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.HardwareAddr] or: whatever"))
// }

func ExtractGo_go_std_net__HardwareAddr(rcvr, arg string, args *ArraySeq, n int) (res _net.HardwareAddr) {
	a := CheckGoNth(rcvr, "go.std.net/HardwareAddr", arg, args, n).O
	res, ok := a.(_net.HardwareAddr)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/HardwareAddr], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectIP(args []Object, index int) *_net.IP {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IP:
			return &r
		case *_net.IP:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IP]"))
}

// func _ConstructIP(_v Object) _net.IP {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.IP:
// 			return _g
// 		case *_net.IP:
// 			return *_g
// 		}
// 	default:
// 		return _net.IP(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for IP))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IP] or: whatever"))
// }

func ExtractGo_go_std_net__IP(rcvr, arg string, args *ArraySeq, n int) (res _net.IP) {
	a := CheckGoNth(rcvr, "go.std.net/IP", arg, args, n).O
	res, ok := a.(_net.IP)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/IP], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectIPAddr(args []Object, index int) *_net.IPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPAddr:
			return &r
		case *_net.IPAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPAddr]"))
}

// func _mapToIPAddr(o Map) *_net.IPAddr {
// 	return &_net.IPAddr{}
// }

// func _vectorToIPAddr(o *Vector) *_net.IPAddr {
// 	return &_net.IPAddr{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Zone: AssertString(o.Nth(1), "").S,
// 	}
// }

// func _ConstructIPAddr(_v Object) *_net.IPAddr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.IPAddr:
// 			return &_g
// 		case *_net.IPAddr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToIPAddr(_o.(Map))
// 	case *Vector:
// 		return _vectorToIPAddr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPAddr] or: Map or Vector"))
// }

func ExtractGo_go_std_net__IPAddr(rcvr, arg string, args *ArraySeq, n int) (res _net.IPAddr) {
	a := CheckGoNth(rcvr, "go.std.net/IPAddr", arg, args, n).O
	res, ok := a.(_net.IPAddr)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/IPAddr], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectIPConn(args []Object, index int) *_net.IPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPConn:
			return &r
		case *_net.IPConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPConn]"))
}

func _mapToIPConn(o Map) *_net.IPConn {
	return &_net.IPConn{}
}

func _vectorToIPConn(o *Vector) *_net.IPConn {
	return &_net.IPConn{}
}

func _ConstructIPConn(_v Object) *_net.IPConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.IPConn:
			return &_g
		case *_net.IPConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIPConn(_o.(Map))
	case *Vector:
		return _vectorToIPConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPConn] or: Map or Vector"))
}

func ExtractGo_go_std_net__IPConn(rcvr, arg string, args *ArraySeq, n int) (res _net.IPConn) {
	a := CheckGoNth(rcvr, "go.std.net/IPConn", arg, args, n).O
	res, ok := a.(_net.IPConn)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/IPConn], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectIPMask(args []Object, index int) *_net.IPMask {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPMask:
			return &r
		case *_net.IPMask:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPMask]"))
}

// func _ConstructIPMask(_v Object) _net.IPMask {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.IPMask:
// 			return _g
// 		case *_net.IPMask:
// 			return *_g
// 		}
// 	default:
// 		return _net.IPMask(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for IPMask))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPMask] or: whatever"))
// }

func ExtractGo_go_std_net__IPMask(rcvr, arg string, args *ArraySeq, n int) (res _net.IPMask) {
	a := CheckGoNth(rcvr, "go.std.net/IPMask", arg, args, n).O
	res, ok := a.(_net.IPMask)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/IPMask], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectIPNet(args []Object, index int) *_net.IPNet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPNet:
			return &r
		case *_net.IPNet:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPNet]"))
}

// func _mapToIPNet(o Map) *_net.IPNet {
// 	return &_net.IPNet{}
// }

// func _vectorToIPNet(o *Vector) *_net.IPNet {
// 	return &_net.IPNet{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Mask: ABEND048(codegen.go: no conversion from Clojure for net.IPMask ([]byte)),
// 	}
// }

// func _ConstructIPNet(_v Object) *_net.IPNet {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.IPNet:
// 			return &_g
// 		case *_net.IPNet:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToIPNet(_o.(Map))
// 	case *Vector:
// 		return _vectorToIPNet(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPNet] or: Map or Vector"))
// }

func ExtractGo_go_std_net__IPNet(rcvr, arg string, args *ArraySeq, n int) (res _net.IPNet) {
	a := CheckGoNth(rcvr, "go.std.net/IPNet", arg, args, n).O
	res, ok := a.(_net.IPNet)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/IPNet], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectInterface(args []Object, index int) *_net.Interface {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Interface:
			return &r
		case *_net.Interface:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Interface]"))
}

// func _mapToInterface(o Map) *_net.Interface {
// 	return &_net.Interface{}
// }

// func _vectorToInterface(o *Vector) *_net.Interface {
// 	return &_net.Interface{
// 		Index: AssertInt(o.Nth(0), "").I,
// 		MTU: AssertInt(o.Nth(1), "").I,
// 		Name: AssertString(o.Nth(2), "").S,
// 		HardwareAddr: ABEND048(codegen.go: no conversion from Clojure for net.HardwareAddr ([]byte)),
// 		Flags: _net.Flags(uint(AssertInt(o.Nth(4), "").I)),
// 	}
// }

// func _ConstructInterface(_v Object) *_net.Interface {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Interface:
// 			return &_g
// 		case *_net.Interface:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToInterface(_o.(Map))
// 	case *Vector:
// 		return _vectorToInterface(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Interface] or: Map or Vector"))
// }

func ExtractGo_go_std_net__Interface(rcvr, arg string, args *ArraySeq, n int) (res _net.Interface) {
	a := CheckGoNth(rcvr, "go.std.net/Interface", arg, args, n).O
	res, ok := a.(_net.Interface)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Interface], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectInvalidAddrError(args []Object, index int) *_net.InvalidAddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.InvalidAddrError:
			return &r
		case *_net.InvalidAddrError:
			return r
		}
	case String:
		v := _net.InvalidAddrError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.InvalidAddrError]"))
}

func _ConstructInvalidAddrError(_v Object) _net.InvalidAddrError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.InvalidAddrError:
			return _g
		case *_net.InvalidAddrError:
			return *_g
		}
	case String:
		return _net.InvalidAddrError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.InvalidAddrError] or: String"))
}

func ExtractGo_go_std_net__InvalidAddrError(rcvr, arg string, args *ArraySeq, n int) (res _net.InvalidAddrError) {
	a := CheckGoNth(rcvr, "go.std.net/InvalidAddrError", arg, args, n).O
	res, ok := a.(_net.InvalidAddrError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/InvalidAddrError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectListenConfig(args []Object, index int) *_net.ListenConfig {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.ListenConfig:
			return &r
		case *_net.ListenConfig:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.ListenConfig]"))
}

// func _mapToListenConfig(o Map) *_net.ListenConfig {
// 	return &_net.ListenConfig{}
// }

// func _vectorToListenConfig(o *Vector) *_net.ListenConfig {
// 	return &_net.ListenConfig{
// 		Control: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructListenConfig(_v Object) *_net.ListenConfig {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.ListenConfig:
// 			return &_g
// 		case *_net.ListenConfig:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToListenConfig(_o.(Map))
// 	case *Vector:
// 		return _vectorToListenConfig(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.ListenConfig] or: Map or Vector"))
// }

func ExtractGo_go_std_net__ListenConfig(rcvr, arg string, args *ArraySeq, n int) (res _net.ListenConfig) {
	a := CheckGoNth(rcvr, "go.std.net/ListenConfig", arg, args, n).O
	res, ok := a.(_net.ListenConfig)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/ListenConfig], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectListener(args []Object, index int) *_net.Listener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Listener:
			return &r
		case *_net.Listener:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Listener]"))
}

// func _ConstructListener(_v Object) _net.Listener {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Listener:
// 			return _g
// 		case *_net.Listener:
// 			return *_g
// 		}
// 	default:
// 		return _net.Listener(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Listener))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Listener] or: whatever"))
// }

func ExtractGo_go_std_net__Listener(rcvr, arg string, args *ArraySeq, n int) (res _net.Listener) {
	a := CheckGoNth(rcvr, "go.std.net/Listener", arg, args, n).O
	res, ok := a.(_net.Listener)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Listener], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectMX(args []Object, index int) *_net.MX {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.MX:
			return &r
		case *_net.MX:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.MX]"))
}

func _mapToMX(o Map) *_net.MX {
	return &_net.MX{}
}

func _vectorToMX(o *Vector) *_net.MX {
	return &_net.MX{
		Host: AssertString(o.Nth(0), "").S,
		Pref: uint16(AssertInt(o.Nth(1), "").I),
	}
}

func _ConstructMX(_v Object) *_net.MX {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.MX:
			return &_g
		case *_net.MX:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMX(_o.(Map))
	case *Vector:
		return _vectorToMX(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.MX] or: Map or Vector"))
}

func _ConstructMX_(o Object) Object {
	return MakeGoObject(_ConstructMX(o))
}

func ExtractGo_go_std_net__MX(rcvr, arg string, args *ArraySeq, n int) (res _net.MX) {
	a := CheckGoNth(rcvr, "go.std.net/MX", arg, args, n).O
	res, ok := a.(_net.MX)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/MX], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectNS(args []Object, index int) *_net.NS {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.NS:
			return &r
		case *_net.NS:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.NS]"))
}

func _mapToNS(o Map) *_net.NS {
	return &_net.NS{}
}

func _vectorToNS(o *Vector) *_net.NS {
	return &_net.NS{
		Host: AssertString(o.Nth(0), "").S,
	}
}

func _ConstructNS(_v Object) *_net.NS {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.NS:
			return &_g
		case *_net.NS:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNS(_o.(Map))
	case *Vector:
		return _vectorToNS(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.NS] or: Map or Vector"))
}

func ExtractGo_go_std_net__NS(rcvr, arg string, args *ArraySeq, n int) (res _net.NS) {
	a := CheckGoNth(rcvr, "go.std.net/NS", arg, args, n).O
	res, ok := a.(_net.NS)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/NS], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectOpError(args []Object, index int) *_net.OpError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.OpError:
			return &r
		case *_net.OpError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.OpError]"))
}

// func _mapToOpError(o Map) *_net.OpError {
// 	return &_net.OpError{}
// }

// func _vectorToOpError(o *Vector) *_net.OpError {
// 	return &_net.OpError{
// 		Op: AssertString(o.Nth(0), "").S,
// 		Net: AssertString(o.Nth(1), "").S,
// 		Source: ABEND048(codegen.go: no conversion from Clojure for net.Addr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Addr: ABEND048(codegen.go: no conversion from Clojure for net.Addr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Err: _errors.New(AssertString(o.Nth(4), "").S),
// 	}
// }

// func _ConstructOpError(_v Object) *_net.OpError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.OpError:
// 			return &_g
// 		case *_net.OpError:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToOpError(_o.(Map))
// 	case *Vector:
// 		return _vectorToOpError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.OpError] or: Map or Vector"))
// }

func ExtractGo_go_std_net__OpError(rcvr, arg string, args *ArraySeq, n int) (res _net.OpError) {
	a := CheckGoNth(rcvr, "go.std.net/OpError", arg, args, n).O
	res, ok := a.(_net.OpError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/OpError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectPacketConn(args []Object, index int) *_net.PacketConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.PacketConn:
			return &r
		case *_net.PacketConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.PacketConn]"))
}

// func _ConstructPacketConn(_v Object) _net.PacketConn {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.PacketConn:
// 			return _g
// 		case *_net.PacketConn:
// 			return *_g
// 		}
// 	default:
// 		return _net.PacketConn(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for PacketConn))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.PacketConn] or: whatever"))
// }

func ExtractGo_go_std_net__PacketConn(rcvr, arg string, args *ArraySeq, n int) (res _net.PacketConn) {
	a := CheckGoNth(rcvr, "go.std.net/PacketConn", arg, args, n).O
	res, ok := a.(_net.PacketConn)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/PacketConn], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectParseError(args []Object, index int) *_net.ParseError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.ParseError:
			return &r
		case *_net.ParseError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.ParseError]"))
}

func _mapToParseError(o Map) *_net.ParseError {
	return &_net.ParseError{}
}

func _vectorToParseError(o *Vector) *_net.ParseError {
	return &_net.ParseError{
		Type: AssertString(o.Nth(0), "").S,
		Text: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructParseError(_v Object) *_net.ParseError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.ParseError:
			return &_g
		case *_net.ParseError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToParseError(_o.(Map))
	case *Vector:
		return _vectorToParseError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.ParseError] or: Map or Vector"))
}

func ExtractGo_go_std_net__ParseError(rcvr, arg string, args *ArraySeq, n int) (res _net.ParseError) {
	a := CheckGoNth(rcvr, "go.std.net/ParseError", arg, args, n).O
	res, ok := a.(_net.ParseError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/ParseError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectResolver(args []Object, index int) *_net.Resolver {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Resolver:
			return &r
		case *_net.Resolver:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Resolver]"))
}

// func _mapToResolver(o Map) *_net.Resolver {
// 	return &_net.Resolver{}
// }

// func _vectorToResolver(o *Vector) *_net.Resolver {
// 	return &_net.Resolver{
// 		PreferGo: ToBool(o.Nth(0)),
// 		StrictErrors: ToBool(o.Nth(1)),
// 		Dial: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructResolver(_v Object) *_net.Resolver {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Resolver:
// 			return &_g
// 		case *_net.Resolver:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToResolver(_o.(Map))
// 	case *Vector:
// 		return _vectorToResolver(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Resolver] or: Map or Vector"))
// }

func ExtractGo_go_std_net__Resolver(rcvr, arg string, args *ArraySeq, n int) (res _net.Resolver) {
	a := CheckGoNth(rcvr, "go.std.net/Resolver", arg, args, n).O
	res, ok := a.(_net.Resolver)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Resolver], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectSRV(args []Object, index int) *_net.SRV {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.SRV:
			return &r
		case *_net.SRV:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.SRV]"))
}

func _mapToSRV(o Map) *_net.SRV {
	return &_net.SRV{}
}

func _vectorToSRV(o *Vector) *_net.SRV {
	return &_net.SRV{
		Target:   AssertString(o.Nth(0), "").S,
		Port:     uint16(AssertInt(o.Nth(1), "").I),
		Priority: uint16(AssertInt(o.Nth(2), "").I),
		Weight:   uint16(AssertInt(o.Nth(3), "").I),
	}
}

func _ConstructSRV(_v Object) *_net.SRV {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.SRV:
			return &_g
		case *_net.SRV:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSRV(_o.(Map))
	case *Vector:
		return _vectorToSRV(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.SRV] or: Map or Vector"))
}

func ExtractGo_go_std_net__SRV(rcvr, arg string, args *ArraySeq, n int) (res _net.SRV) {
	a := CheckGoNth(rcvr, "go.std.net/SRV", arg, args, n).O
	res, ok := a.(_net.SRV)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/SRV], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectTCPAddr(args []Object, index int) *_net.TCPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.TCPAddr:
			return &r
		case *_net.TCPAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.TCPAddr]"))
}

// func _mapToTCPAddr(o Map) *_net.TCPAddr {
// 	return &_net.TCPAddr{}
// }

// func _vectorToTCPAddr(o *Vector) *_net.TCPAddr {
// 	return &_net.TCPAddr{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Port: AssertInt(o.Nth(1), "").I,
// 		Zone: AssertString(o.Nth(2), "").S,
// 	}
// }

// func _ConstructTCPAddr(_v Object) *_net.TCPAddr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.TCPAddr:
// 			return &_g
// 		case *_net.TCPAddr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTCPAddr(_o.(Map))
// 	case *Vector:
// 		return _vectorToTCPAddr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.TCPAddr] or: Map or Vector"))
// }

func ExtractGo_go_std_net__TCPAddr(rcvr, arg string, args *ArraySeq, n int) (res _net.TCPAddr) {
	a := CheckGoNth(rcvr, "go.std.net/TCPAddr", arg, args, n).O
	res, ok := a.(_net.TCPAddr)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/TCPAddr], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectTCPConn(args []Object, index int) *_net.TCPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.TCPConn:
			return &r
		case *_net.TCPConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.TCPConn]"))
}

func _mapToTCPConn(o Map) *_net.TCPConn {
	return &_net.TCPConn{}
}

func _vectorToTCPConn(o *Vector) *_net.TCPConn {
	return &_net.TCPConn{}
}

func _ConstructTCPConn(_v Object) *_net.TCPConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.TCPConn:
			return &_g
		case *_net.TCPConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTCPConn(_o.(Map))
	case *Vector:
		return _vectorToTCPConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.TCPConn] or: Map or Vector"))
}

func ExtractGo_go_std_net__TCPConn(rcvr, arg string, args *ArraySeq, n int) (res _net.TCPConn) {
	a := CheckGoNth(rcvr, "go.std.net/TCPConn", arg, args, n).O
	res, ok := a.(_net.TCPConn)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/TCPConn], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectTCPListener(args []Object, index int) *_net.TCPListener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.TCPListener:
			return &r
		case *_net.TCPListener:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.TCPListener]"))
}

func _mapToTCPListener(o Map) *_net.TCPListener {
	return &_net.TCPListener{}
}

func _vectorToTCPListener(o *Vector) *_net.TCPListener {
	return &_net.TCPListener{}
}

func _ConstructTCPListener(_v Object) *_net.TCPListener {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.TCPListener:
			return &_g
		case *_net.TCPListener:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTCPListener(_o.(Map))
	case *Vector:
		return _vectorToTCPListener(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.TCPListener] or: Map or Vector"))
}

func ExtractGo_go_std_net__TCPListener(rcvr, arg string, args *ArraySeq, n int) (res _net.TCPListener) {
	a := CheckGoNth(rcvr, "go.std.net/TCPListener", arg, args, n).O
	res, ok := a.(_net.TCPListener)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/TCPListener], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectUDPAddr(args []Object, index int) *_net.UDPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UDPAddr:
			return &r
		case *_net.UDPAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UDPAddr]"))
}

// func _mapToUDPAddr(o Map) *_net.UDPAddr {
// 	return &_net.UDPAddr{}
// }

// func _vectorToUDPAddr(o *Vector) *_net.UDPAddr {
// 	return &_net.UDPAddr{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Port: AssertInt(o.Nth(1), "").I,
// 		Zone: AssertString(o.Nth(2), "").S,
// 	}
// }

// func _ConstructUDPAddr(_v Object) *_net.UDPAddr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.UDPAddr:
// 			return &_g
// 		case *_net.UDPAddr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToUDPAddr(_o.(Map))
// 	case *Vector:
// 		return _vectorToUDPAddr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UDPAddr] or: Map or Vector"))
// }

func ExtractGo_go_std_net__UDPAddr(rcvr, arg string, args *ArraySeq, n int) (res _net.UDPAddr) {
	a := CheckGoNth(rcvr, "go.std.net/UDPAddr", arg, args, n).O
	res, ok := a.(_net.UDPAddr)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/UDPAddr], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectUDPConn(args []Object, index int) *_net.UDPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UDPConn:
			return &r
		case *_net.UDPConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UDPConn]"))
}

func _mapToUDPConn(o Map) *_net.UDPConn {
	return &_net.UDPConn{}
}

func _vectorToUDPConn(o *Vector) *_net.UDPConn {
	return &_net.UDPConn{}
}

func _ConstructUDPConn(_v Object) *_net.UDPConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UDPConn:
			return &_g
		case *_net.UDPConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUDPConn(_o.(Map))
	case *Vector:
		return _vectorToUDPConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UDPConn] or: Map or Vector"))
}

func ExtractGo_go_std_net__UDPConn(rcvr, arg string, args *ArraySeq, n int) (res _net.UDPConn) {
	a := CheckGoNth(rcvr, "go.std.net/UDPConn", arg, args, n).O
	res, ok := a.(_net.UDPConn)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/UDPConn], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectUnixAddr(args []Object, index int) *_net.UnixAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UnixAddr:
			return &r
		case *_net.UnixAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnixAddr]"))
}

func _mapToUnixAddr(o Map) *_net.UnixAddr {
	return &_net.UnixAddr{}
}

func _vectorToUnixAddr(o *Vector) *_net.UnixAddr {
	return &_net.UnixAddr{
		Name: AssertString(o.Nth(0), "").S,
		Net:  AssertString(o.Nth(1), "").S,
	}
}

func _ConstructUnixAddr(_v Object) *_net.UnixAddr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UnixAddr:
			return &_g
		case *_net.UnixAddr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnixAddr(_o.(Map))
	case *Vector:
		return _vectorToUnixAddr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnixAddr] or: Map or Vector"))
}

func ExtractGo_go_std_net__UnixAddr(rcvr, arg string, args *ArraySeq, n int) (res _net.UnixAddr) {
	a := CheckGoNth(rcvr, "go.std.net/UnixAddr", arg, args, n).O
	res, ok := a.(_net.UnixAddr)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/UnixAddr], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectUnixConn(args []Object, index int) *_net.UnixConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UnixConn:
			return &r
		case *_net.UnixConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnixConn]"))
}

func _mapToUnixConn(o Map) *_net.UnixConn {
	return &_net.UnixConn{}
}

func _vectorToUnixConn(o *Vector) *_net.UnixConn {
	return &_net.UnixConn{}
}

func _ConstructUnixConn(_v Object) *_net.UnixConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UnixConn:
			return &_g
		case *_net.UnixConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnixConn(_o.(Map))
	case *Vector:
		return _vectorToUnixConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnixConn] or: Map or Vector"))
}

func ExtractGo_go_std_net__UnixConn(rcvr, arg string, args *ArraySeq, n int) (res _net.UnixConn) {
	a := CheckGoNth(rcvr, "go.std.net/UnixConn", arg, args, n).O
	res, ok := a.(_net.UnixConn)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/UnixConn], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectUnixListener(args []Object, index int) *_net.UnixListener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UnixListener:
			return &r
		case *_net.UnixListener:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnixListener]"))
}

func _mapToUnixListener(o Map) *_net.UnixListener {
	return &_net.UnixListener{}
}

func _vectorToUnixListener(o *Vector) *_net.UnixListener {
	return &_net.UnixListener{}
}

func _ConstructUnixListener(_v Object) *_net.UnixListener {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UnixListener:
			return &_g
		case *_net.UnixListener:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnixListener(_o.(Map))
	case *Vector:
		return _vectorToUnixListener(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnixListener] or: Map or Vector"))
}

func ExtractGo_go_std_net__UnixListener(rcvr, arg string, args *ArraySeq, n int) (res _net.UnixListener) {
	a := CheckGoNth(rcvr, "go.std.net/UnixListener", arg, args, n).O
	res, ok := a.(_net.UnixListener)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/UnixListener], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectUnknownNetworkError(args []Object, index int) *_net.UnknownNetworkError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UnknownNetworkError:
			return &r
		case *_net.UnknownNetworkError:
			return r
		}
	case String:
		v := _net.UnknownNetworkError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnknownNetworkError]"))
}

func _ConstructUnknownNetworkError(_v Object) _net.UnknownNetworkError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UnknownNetworkError:
			return _g
		case *_net.UnknownNetworkError:
			return *_g
		}
	case String:
		return _net.UnknownNetworkError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnknownNetworkError] or: String"))
}

func ExtractGo_go_std_net__UnknownNetworkError(rcvr, arg string, args *ArraySeq, n int) (res _net.UnknownNetworkError) {
	a := CheckGoNth(rcvr, "go.std.net/UnknownNetworkError", arg, args, n).O
	res, ok := a.(_net.UnknownNetworkError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/UnknownNetworkError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func __cIDRMask(__ones int, __bits int) Object {
	_res := _net.CIDRMask(__ones, __bits)
	return MakeGoObject(_res)
}

func __dial(__network string, __address string) Object {
	_res1, _res2 := _net.Dial(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __dialIP(__network string, __laddr *_net.IPAddr, __raddr *_net.IPAddr) Object {
	_res1, _res2 := _net.DialIP(__network, __laddr, __raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __dialTCP(__network string, __laddr *_net.TCPAddr, __raddr *_net.TCPAddr) Object {
	_res1, _res2 := _net.DialTCP(__network, __laddr, __raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

// func __dialTimeout(__network string, __address string, __timeout ABEND987(genutils.go: imports not yet supported: time.Duration)) Object {
// 	_res1, _res2 := _net.DialTimeout(__network, __address, __timeout)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

func __dialUDP(__network string, __laddr *_net.UDPAddr, __raddr *_net.UDPAddr) Object {
	_res1, _res2 := _net.DialUDP(__network, __laddr, __raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __dialUnix(__network string, __laddr *_net.UnixAddr, __raddr *_net.UnixAddr) Object {
	_res1, _res2 := _net.DialUnix(__network, __laddr, __raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

// func __fileConn(__f *ABEND987(genutils.go: imports not yet supported: os.File)) Object {
// 	c, err := _net.FileConn(__f)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(c))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

// func __fileListener(__f *ABEND987(genutils.go: imports not yet supported: os.File)) Object {
// 	ln, err := _net.FileListener(__f)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(ln))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

// func __filePacketConn(__f *ABEND987(genutils.go: imports not yet supported: os.File)) Object {
// 	c, err := _net.FilePacketConn(__f)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(c))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

func __iPv4(__a byte, __b byte, __c byte, __d byte) Object {
	_res := _net.IPv4(__a, __b, __c, __d)
	return MakeGoObject(_res)
}

func __iPv4Mask(__a byte, __b byte, __c byte, __d byte) Object {
	_res := _net.IPv4Mask(__a, __b, __c, __d)
	return MakeGoObject(_res)
}

func __interfaceAddrs() Object {
	_res1, _res2 := _net.InterfaceAddrs()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __interfaceByIndex(__index int) Object {
	_res1, _res2 := _net.InterfaceByIndex(__index)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __interfaceByName(__name string) Object {
	_res1, _res2 := _net.InterfaceByName(__name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __interfaces() Object {
	_res1, _res2 := _net.Interfaces()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __listen(__network string, __address string) Object {
	_res1, _res2 := _net.Listen(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __listenIP(__network string, __laddr *_net.IPAddr) Object {
	_res1, _res2 := _net.ListenIP(__network, __laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __listenMulticastUDP(__network string, __ifi *_net.Interface, __gaddr *_net.UDPAddr) Object {
	_res1, _res2 := _net.ListenMulticastUDP(__network, __ifi, __gaddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __listenPacket(__network string, __address string) Object {
	_res1, _res2 := _net.ListenPacket(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __listenTCP(__network string, __laddr *_net.TCPAddr) Object {
	_res1, _res2 := _net.ListenTCP(__network, __laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __listenUDP(__network string, __laddr *_net.UDPAddr) Object {
	_res1, _res2 := _net.ListenUDP(__network, __laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __listenUnix(__network string, __laddr *_net.UnixAddr) Object {
	_res1, _res2 := _net.ListenUnix(__network, __laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __listenUnixgram(__network string, __laddr *_net.UnixAddr) Object {
	_res1, _res2 := _net.ListenUnixgram(__network, __laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __lookupAddr(__addr string) Object {
	names, err := _net.LookupAddr(__addr)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range names {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func() Object {
		if (err) == nil {
			return NIL
		} else {
			return MakeError(err)
		}
	}())
	return _res
}

func __lookupCNAME(__host string) Object {
	cname, err := _net.LookupCNAME(__host)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(cname))
	_res = _res.Conjoin(func() Object {
		if (err) == nil {
			return NIL
		} else {
			return MakeError(err)
		}
	}())
	return _res
}

func __lookupHost(__host string) Object {
	addrs, err := _net.LookupHost(__host)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range addrs {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func() Object {
		if (err) == nil {
			return NIL
		} else {
			return MakeError(err)
		}
	}())
	return _res
}

func __lookupIP(__host string) Object {
	_res1, _res2 := _net.LookupIP(__host)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __lookupMX(__name string) Object {
	_res1, _res2 := _net.LookupMX(__name)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __lookupNS(__name string) Object {
	_res1, _res2 := _net.LookupNS(__name)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __lookupPort(__network string, __service string) Object {
	port, err := _net.LookupPort(__network, __service)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(port))
	_res = _res.Conjoin(func() Object {
		if (err) == nil {
			return NIL
		} else {
			return MakeError(err)
		}
	}())
	return _res
}

func __lookupSRV(__service string, __proto string, __name string) Object {
	cname, addrs, err := _net.LookupSRV(__service, __proto, __name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(cname))
	_vec1 := EmptyVector()
	for _, _elem1 := range addrs {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func() Object {
		if (err) == nil {
			return NIL
		} else {
			return MakeError(err)
		}
	}())
	return _res
}

func __lookupTXT(__name string) Object {
	_res1, _res2 := _net.LookupTXT(__name)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __parseCIDR(__s string) Object {
	_res1, _res2, _res3 := _net.ParseCIDR(__s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	_res = _res.Conjoin(func() Object {
		if (_res3) == nil {
			return NIL
		} else {
			return MakeError(_res3)
		}
	}())
	return _res
}

func __parseIP(__s string) Object {
	_res := _net.ParseIP(__s)
	return MakeGoObject(_res)
}

func __parseMAC(__s string) Object {
	hw, err := _net.ParseMAC(__s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(hw))
	_res = _res.Conjoin(func() Object {
		if (err) == nil {
			return NIL
		} else {
			return MakeError(err)
		}
	}())
	return _res
}

func __pipe() Object {
	_res1, _res2 := _net.Pipe()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	return _res
}

func __resolveIPAddr(__network string, __address string) Object {
	_res1, _res2 := _net.ResolveIPAddr(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __resolveTCPAddr(__network string, __address string) Object {
	_res1, _res2 := _net.ResolveTCPAddr(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __resolveUDPAddr(__network string, __address string) Object {
	_res1, _res2 := _net.ResolveUDPAddr(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __resolveUnixAddr(__network string, __address string) Object {
	_res1, _res2 := _net.ResolveUnixAddr(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __splitHostPort(__hostport string) Object {
	host, port, err := _net.SplitHostPort(__hostport)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(host))
	_res = _res.Conjoin(MakeString(port))
	_res = _res.Conjoin(func() Object {
		if (err) == nil {
			return NIL
		} else {
			return MakeError(err)
		}
	}())
	return _res
}

func __flags_String(o GoObject, args Object) Object {
	CheckGoArity("(_net.Flags)String()", args, 0, 0)
	_res := o.O.(_net.Flags).String()
	return MakeString(_res)
}

func __hardwareAddr_String(o GoObject, args Object) Object {
	CheckGoArity("(_net.HardwareAddr)String()", args, 0, 0)
	_res := o.O.(_net.HardwareAddr).String()
	return MakeString(_res)
}

func __iPMask_Size(o GoObject, args Object) Object {
	CheckGoArity("(_net.IPMask)Size()", args, 0, 0)
	ones, bits := o.O.(_net.IPMask).Size()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(ones))
	_res = _res.Conjoin(MakeInt(bits))
	return _res
}

func __iPMask_String(o GoObject, args Object) Object {
	CheckGoArity("(_net.IPMask)String()", args, 0, 0)
	_res := o.O.(_net.IPMask).String()
	return MakeString(_res)
}

func __iP_DefaultMask(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)DefaultMask()", args, 0, 0)
	_res := o.O.(_net.IP).DefaultMask()
	return MakeGoObject(_res)
}

func __iP_Equal(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net.IP)Equal()", args, 1, 1)
	__x := ExtractGo_go_std_net__IP("(_net.IP)Equal()", "__x", _argList, 0)
	_res := o.O.(_net.IP).Equal(__x)
	return MakeBoolean(_res)
}

func __iP_IsGlobalUnicast(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)IsGlobalUnicast()", args, 0, 0)
	_res := o.O.(_net.IP).IsGlobalUnicast()
	return MakeBoolean(_res)
}

func __iP_IsInterfaceLocalMulticast(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)IsInterfaceLocalMulticast()", args, 0, 0)
	_res := o.O.(_net.IP).IsInterfaceLocalMulticast()
	return MakeBoolean(_res)
}

func __iP_IsLinkLocalMulticast(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)IsLinkLocalMulticast()", args, 0, 0)
	_res := o.O.(_net.IP).IsLinkLocalMulticast()
	return MakeBoolean(_res)
}

func __iP_IsLinkLocalUnicast(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)IsLinkLocalUnicast()", args, 0, 0)
	_res := o.O.(_net.IP).IsLinkLocalUnicast()
	return MakeBoolean(_res)
}

func __iP_IsLoopback(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)IsLoopback()", args, 0, 0)
	_res := o.O.(_net.IP).IsLoopback()
	return MakeBoolean(_res)
}

func __iP_IsMulticast(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)IsMulticast()", args, 0, 0)
	_res := o.O.(_net.IP).IsMulticast()
	return MakeBoolean(_res)
}

func __iP_IsUnspecified(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)IsUnspecified()", args, 0, 0)
	_res := o.O.(_net.IP).IsUnspecified()
	return MakeBoolean(_res)
}

func __iP_MarshalText(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)MarshalText()", args, 0, 0)
	_res1, _res2 := o.O.(_net.IP).MarshalText()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __iP_Mask(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net.IP)Mask()", args, 1, 1)
	__mask := ExtractGo_go_std_net__IPMask("(_net.IP)Mask()", "__mask", _argList, 0)
	_res := o.O.(_net.IP).Mask(__mask)
	return MakeGoObject(_res)
}

func __iP_String(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)String()", args, 0, 0)
	_res := o.O.(_net.IP).String()
	return MakeString(_res)
}

func __iP_To16(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)To16()", args, 0, 0)
	_res := o.O.(_net.IP).To16()
	return MakeGoObject(_res)
}

func __iP_To4(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)To4()", args, 0, 0)
	_res := o.O.(_net.IP).To4()
	return MakeGoObject(_res)
}

func __invalidAddrError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_net.InvalidAddrError)Error()", args, 0, 0)
	_res := o.O.(_net.InvalidAddrError).Error()
	return MakeString(_res)
}

func __invalidAddrError_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(_net.InvalidAddrError)Temporary()", args, 0, 0)
	_res := o.O.(_net.InvalidAddrError).Temporary()
	return MakeBoolean(_res)
}

func __invalidAddrError_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(_net.InvalidAddrError)Timeout()", args, 0, 0)
	_res := o.O.(_net.InvalidAddrError).Timeout()
	return MakeBoolean(_res)
}

func __ptrTo_AddrError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net.AddrError)Error()", args, 0, 0)
	_res := o.O.(*_net.AddrError).Error()
	return MakeString(_res)
}

func __ptrTo_AddrError_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(*_net.AddrError)Temporary()", args, 0, 0)
	_res := o.O.(*_net.AddrError).Temporary()
	return MakeBoolean(_res)
}

func __ptrTo_AddrError_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(*_net.AddrError)Timeout()", args, 0, 0)
	_res := o.O.(*_net.AddrError).Timeout()
	return MakeBoolean(_res)
}

// func __ptrTo_Buffers_Read(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)))}

// func __ptrTo_Buffers_WriteTo(o GoObject, args Object) Object {
// __w ABEND987(genutils.go: imports not yet supported: io.Writer)}

func __ptrTo_DNSConfigError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net.DNSConfigError)Error()", args, 0, 0)
	_res := o.O.(*_net.DNSConfigError).Error()
	return MakeString(_res)
}

func __ptrTo_DNSConfigError_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(*_net.DNSConfigError)Temporary()", args, 0, 0)
	_res := o.O.(*_net.DNSConfigError).Temporary()
	return MakeBoolean(_res)
}

func __ptrTo_DNSConfigError_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(*_net.DNSConfigError)Timeout()", args, 0, 0)
	_res := o.O.(*_net.DNSConfigError).Timeout()
	return MakeBoolean(_res)
}

func __ptrTo_DNSError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net.DNSError)Error()", args, 0, 0)
	_res := o.O.(*_net.DNSError).Error()
	return MakeString(_res)
}

func __ptrTo_DNSError_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(*_net.DNSError)Temporary()", args, 0, 0)
	_res := o.O.(*_net.DNSError).Temporary()
	return MakeBoolean(_res)
}

func __ptrTo_DNSError_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(*_net.DNSError)Timeout()", args, 0, 0)
	_res := o.O.(*_net.DNSError).Timeout()
	return MakeBoolean(_res)
}

func __ptrTo_Dialer_Dial(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net.Dialer)Dial()", args, 2, 2)
	__network := ExtractGoString("(*_net.Dialer)Dial()", "__network", _argList, 0)
	__address := ExtractGoString("(*_net.Dialer)Dial()", "__address", _argList, 1)
	_res1, _res2 := o.O.(*_net.Dialer).Dial(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

// func __ptrTo_Dialer_DialContext(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __network string, __address string}

func __ptrTo_IPAddr_Network(o GoObject, args Object) Object {
	CheckGoArity("(*_net.IPAddr)Network()", args, 0, 0)
	_res := o.O.(*_net.IPAddr).Network()
	return MakeString(_res)
}

func __ptrTo_IPAddr_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net.IPAddr)String()", args, 0, 0)
	_res := o.O.(*_net.IPAddr).String()
	return MakeString(_res)
}

// func __ptrTo_IPConn_ReadFrom(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))}

// func __ptrTo_IPConn_ReadFromIP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))}

// func __ptrTo_IPConn_ReadMsgIP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__oob)))}

func __ptrTo_IPConn_SyscallConn(o GoObject, args Object) Object {
	CheckGoArity("(*_net.IPConn)SyscallConn()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.IPConn).SyscallConn()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

// func __ptrTo_IPConn_WriteMsgIP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__oob)), __addr)}

// func __ptrTo_IPConn_WriteTo(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), *__addr)}

// func __ptrTo_IPConn_WriteToIP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), __addr)}

func __ptrTo_IPNet_Contains(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net.IPNet)Contains()", args, 1, 1)
	__ip := ExtractGo_go_std_net__IP("(*_net.IPNet)Contains()", "__ip", _argList, 0)
	_res := o.O.(*_net.IPNet).Contains(__ip)
	return MakeBoolean(_res)
}

func __ptrTo_IPNet_Network(o GoObject, args Object) Object {
	CheckGoArity("(*_net.IPNet)Network()", args, 0, 0)
	_res := o.O.(*_net.IPNet).Network()
	return MakeString(_res)
}

func __ptrTo_IPNet_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net.IPNet)String()", args, 0, 0)
	_res := o.O.(*_net.IPNet).String()
	return MakeString(_res)
}

// func __ptrTo_IP_UnmarshalText(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__text)))}

func __ptrTo_Interface_Addrs(o GoObject, args Object) Object {
	CheckGoArity("(*_net.Interface)Addrs()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.Interface).Addrs()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __ptrTo_Interface_MulticastAddrs(o GoObject, args Object) Object {
	CheckGoArity("(*_net.Interface)MulticastAddrs()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.Interface).MulticastAddrs()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

// func __ptrTo_ListenConfig_Listen(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __network string, __address string}

// func __ptrTo_ListenConfig_ListenPacket(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __network string, __address string}

func __ptrTo_OpError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net.OpError)Error()", args, 0, 0)
	_res := o.O.(*_net.OpError).Error()
	return MakeString(_res)
}

func __ptrTo_OpError_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(*_net.OpError)Temporary()", args, 0, 0)
	_res := o.O.(*_net.OpError).Temporary()
	return MakeBoolean(_res)
}

func __ptrTo_OpError_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(*_net.OpError)Timeout()", args, 0, 0)
	_res := o.O.(*_net.OpError).Timeout()
	return MakeBoolean(_res)
}

func __ptrTo_ParseError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net.ParseError)Error()", args, 0, 0)
	_res := o.O.(*_net.ParseError).Error()
	return MakeString(_res)
}

// func __ptrTo_Resolver_LookupAddr(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __addr string}

// func __ptrTo_Resolver_LookupCNAME(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __host string}

// func __ptrTo_Resolver_LookupHost(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __host string}

// func __ptrTo_Resolver_LookupIPAddr(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __host string}

// func __ptrTo_Resolver_LookupMX(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __name string}

// func __ptrTo_Resolver_LookupNS(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __name string}

// func __ptrTo_Resolver_LookupPort(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __network string, __service string}

// func __ptrTo_Resolver_LookupSRV(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __service string, __proto string, __name string}

// func __ptrTo_Resolver_LookupTXT(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __name string}

func __ptrTo_TCPAddr_Network(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPAddr)Network()", args, 0, 0)
	_res := o.O.(*_net.TCPAddr).Network()
	return MakeString(_res)
}

func __ptrTo_TCPAddr_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPAddr)String()", args, 0, 0)
	_res := o.O.(*_net.TCPAddr).String()
	return MakeString(_res)
}

func __ptrTo_TCPConn_CloseRead(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPConn)CloseRead()", args, 0, 0)
	_res := o.O.(*_net.TCPConn).CloseRead()
	return func() Object {
		if (_res) == nil {
			return NIL
		} else {
			return MakeError(_res)
		}
	}()
}

func __ptrTo_TCPConn_CloseWrite(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPConn)CloseWrite()", args, 0, 0)
	_res := o.O.(*_net.TCPConn).CloseWrite()
	return func() Object {
		if (_res) == nil {
			return NIL
		} else {
			return MakeError(_res)
		}
	}()
}

// func __ptrTo_TCPConn_ReadFrom(o GoObject, args Object) Object {
// __r ABEND987(genutils.go: imports not yet supported: io.Reader)}

func __ptrTo_TCPConn_SetKeepAlive(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net.TCPConn)SetKeepAlive()", args, 1, 1)
	__keepalive := ExtractGoBoolean("(*_net.TCPConn)SetKeepAlive()", "__keepalive", _argList, 0)
	_res := o.O.(*_net.TCPConn).SetKeepAlive(__keepalive)
	return func() Object {
		if (_res) == nil {
			return NIL
		} else {
			return MakeError(_res)
		}
	}()
}

// func __ptrTo_TCPConn_SetKeepAlivePeriod(o GoObject, args Object) Object {
// __d ABEND987(genutils.go: imports not yet supported: time.Duration)}

func __ptrTo_TCPConn_SetLinger(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net.TCPConn)SetLinger()", args, 1, 1)
	__sec := ExtractGoInt("(*_net.TCPConn)SetLinger()", "__sec", _argList, 0)
	_res := o.O.(*_net.TCPConn).SetLinger(__sec)
	return func() Object {
		if (_res) == nil {
			return NIL
		} else {
			return MakeError(_res)
		}
	}()
}

func __ptrTo_TCPConn_SetNoDelay(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net.TCPConn)SetNoDelay()", args, 1, 1)
	__noDelay := ExtractGoBoolean("(*_net.TCPConn)SetNoDelay()", "__noDelay", _argList, 0)
	_res := o.O.(*_net.TCPConn).SetNoDelay(__noDelay)
	return func() Object {
		if (_res) == nil {
			return NIL
		} else {
			return MakeError(_res)
		}
	}()
}

func __ptrTo_TCPConn_SyscallConn(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPConn)SyscallConn()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.TCPConn).SyscallConn()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __ptrTo_TCPListener_Accept(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPListener)Accept()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.TCPListener).Accept()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __ptrTo_TCPListener_AcceptTCP(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPListener)AcceptTCP()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.TCPListener).AcceptTCP()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __ptrTo_TCPListener_Addr(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPListener)Addr()", args, 0, 0)
	_res := o.O.(*_net.TCPListener).Addr()
	return MakeGoObject(_res)
}

func __ptrTo_TCPListener_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPListener)Close()", args, 0, 0)
	_res := o.O.(*_net.TCPListener).Close()
	return func() Object {
		if (_res) == nil {
			return NIL
		} else {
			return MakeError(_res)
		}
	}()
}

func __ptrTo_TCPListener_File(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPListener)File()", args, 0, 0)
	f, err := o.O.(*_net.TCPListener).File()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(f))
	_res = _res.Conjoin(func() Object {
		if (err) == nil {
			return NIL
		} else {
			return MakeError(err)
		}
	}())
	return _res
}

// func __ptrTo_TCPListener_SetDeadline(o GoObject, args Object) Object {
// __t ABEND987(genutils.go: imports not yet supported: time.Time)}

func __ptrTo_TCPListener_SyscallConn(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPListener)SyscallConn()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.TCPListener).SyscallConn()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __ptrTo_UDPAddr_Network(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UDPAddr)Network()", args, 0, 0)
	_res := o.O.(*_net.UDPAddr).Network()
	return MakeString(_res)
}

func __ptrTo_UDPAddr_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UDPAddr)String()", args, 0, 0)
	_res := o.O.(*_net.UDPAddr).String()
	return MakeString(_res)
}

// func __ptrTo_UDPConn_ReadFrom(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))}

// func __ptrTo_UDPConn_ReadFromUDP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))}

// func __ptrTo_UDPConn_ReadMsgUDP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__oob)))}

func __ptrTo_UDPConn_SyscallConn(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UDPConn)SyscallConn()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.UDPConn).SyscallConn()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

// func __ptrTo_UDPConn_WriteMsgUDP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__oob)), __addr)}

// func __ptrTo_UDPConn_WriteTo(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), *__addr)}

// func __ptrTo_UDPConn_WriteToUDP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), __addr)}

func __ptrTo_UnixAddr_Network(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixAddr)Network()", args, 0, 0)
	_res := o.O.(*_net.UnixAddr).Network()
	return MakeString(_res)
}

func __ptrTo_UnixAddr_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixAddr)String()", args, 0, 0)
	_res := o.O.(*_net.UnixAddr).String()
	return MakeString(_res)
}

func __ptrTo_UnixConn_CloseRead(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixConn)CloseRead()", args, 0, 0)
	_res := o.O.(*_net.UnixConn).CloseRead()
	return func() Object {
		if (_res) == nil {
			return NIL
		} else {
			return MakeError(_res)
		}
	}()
}

func __ptrTo_UnixConn_CloseWrite(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixConn)CloseWrite()", args, 0, 0)
	_res := o.O.(*_net.UnixConn).CloseWrite()
	return func() Object {
		if (_res) == nil {
			return NIL
		} else {
			return MakeError(_res)
		}
	}()
}

// func __ptrTo_UnixConn_ReadFrom(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))}

// func __ptrTo_UnixConn_ReadFromUnix(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))}

// func __ptrTo_UnixConn_ReadMsgUnix(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__oob)))}

func __ptrTo_UnixConn_SyscallConn(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixConn)SyscallConn()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.UnixConn).SyscallConn()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

// func __ptrTo_UnixConn_WriteMsgUnix(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__oob)), __addr)}

// func __ptrTo_UnixConn_WriteTo(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), *__addr)}

// func __ptrTo_UnixConn_WriteToUnix(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), __addr)}

func __ptrTo_UnixListener_Accept(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixListener)Accept()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.UnixListener).Accept()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __ptrTo_UnixListener_AcceptUnix(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixListener)AcceptUnix()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.UnixListener).AcceptUnix()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __ptrTo_UnixListener_Addr(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixListener)Addr()", args, 0, 0)
	_res := o.O.(*_net.UnixListener).Addr()
	return MakeGoObject(_res)
}

func __ptrTo_UnixListener_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixListener)Close()", args, 0, 0)
	_res := o.O.(*_net.UnixListener).Close()
	return func() Object {
		if (_res) == nil {
			return NIL
		} else {
			return MakeError(_res)
		}
	}()
}

func __ptrTo_UnixListener_File(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixListener)File()", args, 0, 0)
	f, err := o.O.(*_net.UnixListener).File()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(f))
	_res = _res.Conjoin(func() Object {
		if (err) == nil {
			return NIL
		} else {
			return MakeError(err)
		}
	}())
	return _res
}

// func __ptrTo_UnixListener_SetDeadline(o GoObject, args Object) Object {
// __t ABEND987(genutils.go: imports not yet supported: time.Time)}

// func __ptrTo_UnixListener_SetUnlinkOnClose(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

func __ptrTo_UnixListener_SyscallConn(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixListener)SyscallConn()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.UnixListener).SyscallConn()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func() Object {
		if (_res2) == nil {
			return NIL
		} else {
			return MakeError(_res2)
		}
	}())
	return _res
}

func __unknownNetworkError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_net.UnknownNetworkError)Error()", args, 0, 0)
	_res := o.O.(_net.UnknownNetworkError).Error()
	return MakeString(_res)
}

func __unknownNetworkError_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(_net.UnknownNetworkError)Temporary()", args, 0, 0)
	_res := o.O.(_net.UnknownNetworkError).Temporary()
	return MakeBoolean(_res)
}

func __unknownNetworkError_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(_net.UnknownNetworkError)Timeout()", args, 0, 0)
	_res := o.O.(_net.UnknownNetworkError).Timeout()
	return MakeBoolean(_res)
}

func __hey(o GoObject, args Object) Object {
	return MakeString("wow")
}

var members_PtrTo_AddrError GoTypeInfo
var members_PtrTo_DNSConfigError GoTypeInfo
var members_PtrTo_DNSError GoTypeInfo
var members_PtrTo_Dialer GoTypeInfo
var members_Flags GoTypeInfo
var members_HardwareAddr GoTypeInfo
var members_IP GoTypeInfo
var members_PtrTo_IPAddr GoTypeInfo
var members_PtrTo_IPConn GoTypeInfo
var members_IPMask GoTypeInfo
var members_PtrTo_IPNet GoTypeInfo
var members_PtrTo_Interface GoTypeInfo
var members_InvalidAddrError GoTypeInfo
var members_PtrTo_OpError GoTypeInfo
var members_PtrTo_ParseError GoTypeInfo
var members_PtrTo_TCPAddr GoTypeInfo
var members_PtrTo_TCPConn GoTypeInfo
var members_PtrTo_TCPListener GoTypeInfo
var members_PtrTo_UDPAddr GoTypeInfo
var members_PtrTo_UDPConn GoTypeInfo
var members_PtrTo_UnixAddr GoTypeInfo
var members_PtrTo_UnixConn GoTypeInfo
var members_PtrTo_UnixListener GoTypeInfo
var members_UnknownNetworkError GoTypeInfo

var info_MX GoTypeInfo

func initNative() {
	members_PtrTo_AddrError = GoTypeInfo{Members: GoMembers{
		"Error":     __ptrTo_AddrError_Error,
		"Temporary": __ptrTo_AddrError_Temporary,
		"Timeout":   __ptrTo_AddrError_Timeout,
	}}

	members_PtrTo_DNSConfigError = GoTypeInfo{Members: GoMembers{
		"Error":     __ptrTo_DNSConfigError_Error,
		"Temporary": __ptrTo_DNSConfigError_Temporary,
		"Timeout":   __ptrTo_DNSConfigError_Timeout,
	}}

	members_PtrTo_DNSError = GoTypeInfo{Members: GoMembers{
		"Error":     __ptrTo_DNSError_Error,
		"Temporary": __ptrTo_DNSError_Temporary,
		"Timeout":   __ptrTo_DNSError_Timeout,
	}}

	members_PtrTo_Dialer = GoTypeInfo{Members: GoMembers{
		"Dial": __ptrTo_Dialer_Dial,
	}}

	members_Flags = GoTypeInfo{Members: GoMembers{
		"String": __flags_String,
	}}

	members_HardwareAddr = GoTypeInfo{Members: GoMembers{
		"String": __hardwareAddr_String,
	}}

	members_IP = GoTypeInfo{Members: GoMembers{
		"DefaultMask":               __iP_DefaultMask,
		"Equal":                     __iP_Equal,
		"IsGlobalUnicast":           __iP_IsGlobalUnicast,
		"IsInterfaceLocalMulticast": __iP_IsInterfaceLocalMulticast,
		"IsLinkLocalMulticast":      __iP_IsLinkLocalMulticast,
		"IsLinkLocalUnicast":        __iP_IsLinkLocalUnicast,
		"IsLoopback":                __iP_IsLoopback,
		"IsMulticast":               __iP_IsMulticast,
		"IsUnspecified":             __iP_IsUnspecified,
		"MarshalText":               __iP_MarshalText,
		"Mask":                      __iP_Mask,
		"String":                    __iP_String,
		"To16":                      __iP_To16,
		"To4":                       __iP_To4,
	}}

	members_PtrTo_IPAddr = GoTypeInfo{Members: GoMembers{
		"Network": __ptrTo_IPAddr_Network,
		"String":  __ptrTo_IPAddr_String,
	}}

	members_PtrTo_IPConn = GoTypeInfo{Members: GoMembers{
		"SyscallConn": __ptrTo_IPConn_SyscallConn,
	}}

	members_IPMask = GoTypeInfo{Members: GoMembers{
		"Size":   __iPMask_Size,
		"String": __iPMask_String,
	}}

	members_PtrTo_IPNet = GoTypeInfo{Members: GoMembers{
		"Contains": __ptrTo_IPNet_Contains,
		"Network":  __ptrTo_IPNet_Network,
		"String":   __ptrTo_IPNet_String,
	}}

	members_PtrTo_Interface = GoTypeInfo{Members: GoMembers{
		"Addrs":          __ptrTo_Interface_Addrs,
		"MulticastAddrs": __ptrTo_Interface_MulticastAddrs,
	}}

	members_InvalidAddrError = GoTypeInfo{Members: GoMembers{
		"Error":     __invalidAddrError_Error,
		"Temporary": __invalidAddrError_Temporary,
		"Timeout":   __invalidAddrError_Timeout,
	}}

	members_PtrTo_OpError = GoTypeInfo{Members: GoMembers{
		"Error":     __ptrTo_OpError_Error,
		"Temporary": __ptrTo_OpError_Temporary,
		"Timeout":   __ptrTo_OpError_Timeout,
	}}

	members_PtrTo_ParseError = GoTypeInfo{Members: GoMembers{
		"Error": __ptrTo_ParseError_Error,
	}}

	members_PtrTo_TCPAddr = GoTypeInfo{Members: GoMembers{
		"Network": __ptrTo_TCPAddr_Network,
		"String":  __ptrTo_TCPAddr_String,
	}}

	members_PtrTo_TCPConn = GoTypeInfo{Members: GoMembers{
		"CloseRead":    __ptrTo_TCPConn_CloseRead,
		"CloseWrite":   __ptrTo_TCPConn_CloseWrite,
		"SetKeepAlive": __ptrTo_TCPConn_SetKeepAlive,
		"SetLinger":    __ptrTo_TCPConn_SetLinger,
		"SetNoDelay":   __ptrTo_TCPConn_SetNoDelay,
		"SyscallConn":  __ptrTo_TCPConn_SyscallConn,
	}}

	members_PtrTo_TCPListener = GoTypeInfo{Members: GoMembers{
		"Accept":      __ptrTo_TCPListener_Accept,
		"AcceptTCP":   __ptrTo_TCPListener_AcceptTCP,
		"Addr":        __ptrTo_TCPListener_Addr,
		"Close":       __ptrTo_TCPListener_Close,
		"File":        __ptrTo_TCPListener_File,
		"SyscallConn": __ptrTo_TCPListener_SyscallConn,
	}}

	members_PtrTo_UDPAddr = GoTypeInfo{Members: GoMembers{
		"Network": __ptrTo_UDPAddr_Network,
		"String":  __ptrTo_UDPAddr_String,
	}}

	members_PtrTo_UDPConn = GoTypeInfo{Members: GoMembers{
		"SyscallConn": __ptrTo_UDPConn_SyscallConn,
	}}

	members_PtrTo_UnixAddr = GoTypeInfo{Members: GoMembers{
		"Network": __ptrTo_UnixAddr_Network,
		"String":  __ptrTo_UnixAddr_String,
	}}

	members_PtrTo_UnixConn = GoTypeInfo{Members: GoMembers{
		"CloseRead":   __ptrTo_UnixConn_CloseRead,
		"CloseWrite":  __ptrTo_UnixConn_CloseWrite,
		"SyscallConn": __ptrTo_UnixConn_SyscallConn,
	}}

	members_PtrTo_UnixListener = GoTypeInfo{Members: GoMembers{
		"Accept":      __ptrTo_UnixListener_Accept,
		"AcceptUnix":  __ptrTo_UnixListener_AcceptUnix,
		"Addr":        __ptrTo_UnixListener_Addr,
		"Close":       __ptrTo_UnixListener_Close,
		"File":        __ptrTo_UnixListener_File,
		"SyscallConn": __ptrTo_UnixListener_SyscallConn,
	}}

	members_UnknownNetworkError = GoTypeInfo{Members: GoMembers{
		"Error":     __unknownNetworkError_Error,
		"Temporary": __unknownNetworkError_Temporary,
		"Timeout":   __unknownNetworkError_Timeout,
	}}

	info_MX = GoTypeInfo{Name: "go.std.net/MX",
		GoType: GoType{T: &info_MX},
		Ctor:   _ConstructMX_,
		Members: GoMembers{"Hey": __hey,
			"There": __hey},
		Meta: GoMeta{"Hey": MakeMetaHolder(MakeMeta(nil, "wow this works", "1.0")),
			"There": MakeMetaHolder(MakeMeta(nil, "this too!!", "1.0"))}}

	GoTypes[_reflect.TypeOf((*_net.AddrError)(nil))] = &members_PtrTo_AddrError
	GoTypes[_reflect.TypeOf((*_net.DNSConfigError)(nil))] = &members_PtrTo_DNSConfigError
	GoTypes[_reflect.TypeOf((*_net.DNSError)(nil))] = &members_PtrTo_DNSError
	GoTypes[_reflect.TypeOf((*_net.Dialer)(nil))] = &members_PtrTo_Dialer
	GoTypes[_reflect.TypeOf((*_net.Flags)(nil)).Elem()] = &members_Flags
	GoTypes[_reflect.TypeOf((*_net.HardwareAddr)(nil)).Elem()] = &members_HardwareAddr
	GoTypes[_reflect.TypeOf((*_net.IP)(nil)).Elem()] = &members_IP
	GoTypes[_reflect.TypeOf((*_net.IPAddr)(nil))] = &members_PtrTo_IPAddr
	GoTypes[_reflect.TypeOf((*_net.IPConn)(nil))] = &members_PtrTo_IPConn
	GoTypes[_reflect.TypeOf((*_net.IPMask)(nil)).Elem()] = &members_IPMask
	GoTypes[_reflect.TypeOf((*_net.IPNet)(nil))] = &members_PtrTo_IPNet
	GoTypes[_reflect.TypeOf((*_net.Interface)(nil))] = &members_PtrTo_Interface
	GoTypes[_reflect.TypeOf((*_net.InvalidAddrError)(nil)).Elem()] = &members_InvalidAddrError
	GoTypes[_reflect.TypeOf((*_net.OpError)(nil))] = &members_PtrTo_OpError
	GoTypes[_reflect.TypeOf((*_net.ParseError)(nil))] = &members_PtrTo_ParseError
	GoTypes[_reflect.TypeOf((*_net.TCPAddr)(nil))] = &members_PtrTo_TCPAddr
	GoTypes[_reflect.TypeOf((*_net.TCPConn)(nil))] = &members_PtrTo_TCPConn
	GoTypes[_reflect.TypeOf((*_net.TCPListener)(nil))] = &members_PtrTo_TCPListener
	GoTypes[_reflect.TypeOf((*_net.UDPAddr)(nil))] = &members_PtrTo_UDPAddr
	GoTypes[_reflect.TypeOf((*_net.UDPConn)(nil))] = &members_PtrTo_UDPConn
	GoTypes[_reflect.TypeOf((*_net.UnixAddr)(nil))] = &members_PtrTo_UnixAddr
	GoTypes[_reflect.TypeOf((*_net.UnixConn)(nil))] = &members_PtrTo_UnixConn
	GoTypes[_reflect.TypeOf((*_net.UnixListener)(nil))] = &members_PtrTo_UnixListener
	GoTypes[_reflect.TypeOf((*_net.UnknownNetworkError)(nil)).Elem()] = &members_UnknownNetworkError

	GoTypes[_reflect.TypeOf((*_net.MX)(nil)).Elem()] = &info_MX
}
