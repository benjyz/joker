// This file is generated by generate-std.joke script. Do not edit manually!

package net

import (
	. "github.com/candid82/joker/core"
	"net"
)

var netNamespace = GLOBAL_ENV.EnsureNamespace(MakeSymbol("go.std.net"))

var DefaultResolver_ *GoVar
var ErrWriteToConnected_ *GoVar
var FlagBroadcast_ *BigInt
var FlagLoopback_ *BigInt
var FlagMulticast_ *BigInt
var FlagPointToPoint_ *BigInt
var FlagUp_ *BigInt
var IPv4allrouter_ *GoVar
var IPv4allsys_ *GoVar
var IPv4bcast_ *GoVar
var IPv4len_ Int
var IPv4zero_ *GoVar
var IPv6interfacelocalallnodes_ *GoVar
var IPv6len_ Int
var IPv6linklocalallnodes_ *GoVar
var IPv6linklocalallrouters_ *GoVar
var IPv6loopback_ *GoVar
var IPv6unspecified_ *GoVar
var IPv6zero_ *GoVar

var AddrError_ Proc

func __AddrError_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		_v := ExtractObject(_args, 0)
		_res := _ConstructAddrError(_v)
		return MakeGoObject(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var CIDRMask_ Proc

func __CIDRMask_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 2:
		__ones := ExtractInt(_args, 0)
		__bits := ExtractInt(_args, 1)
		_res := __cIDRMask(__ones, __bits)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var DNSConfigError_ Proc

func __DNSConfigError_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		_v := ExtractObject(_args, 0)
		_res := _ConstructDNSConfigError(_v)
		return MakeGoObject(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var DNSError_ Proc

func __DNSError_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		_v := ExtractObject(_args, 0)
		_res := _ConstructDNSError(_v)
		return MakeGoObject(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var Dial_ Proc

func __Dial_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 2:
		__network := ExtractString(_args, 0)
		__address := ExtractString(_args, 1)
		_res := __dial(__network, __address)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var DialIP_ Proc

func __DialIP_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 3:
		__network := ExtractString(_args, 0)
		__laddr := ExtractGoObjectIPAddr(_args, 1)
		__raddr := ExtractGoObjectIPAddr(_args, 2)
		_res := __dialIP(__network, __laddr, __raddr)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var DialTCP_ Proc

func __DialTCP_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 3:
		__network := ExtractString(_args, 0)
		__laddr := ExtractGoObjectTCPAddr(_args, 1)
		__raddr := ExtractGoObjectTCPAddr(_args, 2)
		_res := __dialTCP(__network, __laddr, __raddr)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var DialUDP_ Proc

func __DialUDP_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 3:
		__network := ExtractString(_args, 0)
		__laddr := ExtractGoObjectUDPAddr(_args, 1)
		__raddr := ExtractGoObjectUDPAddr(_args, 2)
		_res := __dialUDP(__network, __laddr, __raddr)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var DialUnix_ Proc

func __DialUnix_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 3:
		__network := ExtractString(_args, 0)
		__laddr := ExtractGoObjectUnixAddr(_args, 1)
		__raddr := ExtractGoObjectUnixAddr(_args, 2)
		_res := __dialUnix(__network, __laddr, __raddr)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var Flags_ Proc

func __Flags_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		_v := ExtractObject(_args, 0)
		_res := _ConstructFlags(_v)
		return MakeGoObject(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var IPConn_ Proc

func __IPConn_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		_v := ExtractObject(_args, 0)
		_res := _ConstructIPConn(_v)
		return MakeGoObject(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var IPv4_ Proc

func __IPv4_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 4:
		__a := ExtractByte(_args, 0)
		__b := ExtractByte(_args, 1)
		__c := ExtractByte(_args, 2)
		__d := ExtractByte(_args, 3)
		_res := __iPv4(__a, __b, __c, __d)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var IPv4Mask_ Proc

func __IPv4Mask_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 4:
		__a := ExtractByte(_args, 0)
		__b := ExtractByte(_args, 1)
		__c := ExtractByte(_args, 2)
		__d := ExtractByte(_args, 3)
		_res := __iPv4Mask(__a, __b, __c, __d)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var InterfaceAddrs_ Proc

func __InterfaceAddrs_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 0:
		_res := __interfaceAddrs()
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var InterfaceByIndex_ Proc

func __InterfaceByIndex_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		__index := ExtractInt(_args, 0)
		_res := __interfaceByIndex(__index)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var InterfaceByName_ Proc

func __InterfaceByName_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		__name := ExtractString(_args, 0)
		_res := __interfaceByName(__name)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var Interfaces_ Proc

func __Interfaces_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 0:
		_res := __interfaces()
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var InvalidAddrError_ Proc

func __InvalidAddrError_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		_v := ExtractObject(_args, 0)
		_res := _ConstructInvalidAddrError(_v)
		return MakeGoObject(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var JoinHostPort_ Proc

func __JoinHostPort_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 2:
		__host := ExtractString(_args, 0)
		__port := ExtractString(_args, 1)
		_res := net.JoinHostPort(__host, __port)
		return MakeString(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var Listen_ Proc

func __Listen_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 2:
		__network := ExtractString(_args, 0)
		__address := ExtractString(_args, 1)
		_res := __listen(__network, __address)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var ListenIP_ Proc

func __ListenIP_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 2:
		__network := ExtractString(_args, 0)
		__laddr := ExtractGoObjectIPAddr(_args, 1)
		_res := __listenIP(__network, __laddr)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var ListenMulticastUDP_ Proc

func __ListenMulticastUDP_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 3:
		__network := ExtractString(_args, 0)
		__ifi := ExtractGoObjectInterface(_args, 1)
		__gaddr := ExtractGoObjectUDPAddr(_args, 2)
		_res := __listenMulticastUDP(__network, __ifi, __gaddr)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var ListenPacket_ Proc

func __ListenPacket_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 2:
		__network := ExtractString(_args, 0)
		__address := ExtractString(_args, 1)
		_res := __listenPacket(__network, __address)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var ListenTCP_ Proc

func __ListenTCP_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 2:
		__network := ExtractString(_args, 0)
		__laddr := ExtractGoObjectTCPAddr(_args, 1)
		_res := __listenTCP(__network, __laddr)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var ListenUDP_ Proc

func __ListenUDP_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 2:
		__network := ExtractString(_args, 0)
		__laddr := ExtractGoObjectUDPAddr(_args, 1)
		_res := __listenUDP(__network, __laddr)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var ListenUnix_ Proc

func __ListenUnix_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 2:
		__network := ExtractString(_args, 0)
		__laddr := ExtractGoObjectUnixAddr(_args, 1)
		_res := __listenUnix(__network, __laddr)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var ListenUnixgram_ Proc

func __ListenUnixgram_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 2:
		__network := ExtractString(_args, 0)
		__laddr := ExtractGoObjectUnixAddr(_args, 1)
		_res := __listenUnixgram(__network, __laddr)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var LookupAddr_ Proc

func __LookupAddr_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		__addr := ExtractString(_args, 0)
		_res := __lookupAddr(__addr)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var LookupCNAME_ Proc

func __LookupCNAME_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		__host := ExtractString(_args, 0)
		_res := __lookupCNAME(__host)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var LookupHost_ Proc

func __LookupHost_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		__host := ExtractString(_args, 0)
		_res := __lookupHost(__host)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var LookupIP_ Proc

func __LookupIP_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		__host := ExtractString(_args, 0)
		_res := __lookupIP(__host)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var LookupMX_ Proc

func __LookupMX_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		__name := ExtractString(_args, 0)
		_res := __lookupMX(__name)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var LookupNS_ Proc

func __LookupNS_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		__name := ExtractString(_args, 0)
		_res := __lookupNS(__name)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var LookupPort_ Proc

func __LookupPort_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 2:
		__network := ExtractString(_args, 0)
		__service := ExtractString(_args, 1)
		_res := __lookupPort(__network, __service)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var LookupSRV_ Proc

func __LookupSRV_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 3:
		__service := ExtractString(_args, 0)
		__proto := ExtractString(_args, 1)
		__name := ExtractString(_args, 2)
		_res := __lookupSRV(__service, __proto, __name)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var LookupTXT_ Proc

func __LookupTXT_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		__name := ExtractString(_args, 0)
		_res := __lookupTXT(__name)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var MX_ Proc

func __MX_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		_v := ExtractObject(_args, 0)
		_res := _ConstructMX(_v)
		return MakeGoObject(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var NS_ Proc

func __NS_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		_v := ExtractObject(_args, 0)
		_res := _ConstructNS(_v)
		return MakeGoObject(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var ParseCIDR_ Proc

func __ParseCIDR_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		__s := ExtractString(_args, 0)
		_res := __parseCIDR(__s)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var ParseError_ Proc

func __ParseError_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		_v := ExtractObject(_args, 0)
		_res := _ConstructParseError(_v)
		return MakeGoObject(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var ParseIP_ Proc

func __ParseIP_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		__s := ExtractString(_args, 0)
		_res := __parseIP(__s)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var ParseMAC_ Proc

func __ParseMAC_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		__s := ExtractString(_args, 0)
		_res := __parseMAC(__s)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var Pipe_ Proc

func __Pipe_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 0:
		_res := __pipe()
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var ResolveIPAddr_ Proc

func __ResolveIPAddr_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 2:
		__network := ExtractString(_args, 0)
		__address := ExtractString(_args, 1)
		_res := __resolveIPAddr(__network, __address)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var ResolveTCPAddr_ Proc

func __ResolveTCPAddr_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 2:
		__network := ExtractString(_args, 0)
		__address := ExtractString(_args, 1)
		_res := __resolveTCPAddr(__network, __address)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var ResolveUDPAddr_ Proc

func __ResolveUDPAddr_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 2:
		__network := ExtractString(_args, 0)
		__address := ExtractString(_args, 1)
		_res := __resolveUDPAddr(__network, __address)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var ResolveUnixAddr_ Proc

func __ResolveUnixAddr_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 2:
		__network := ExtractString(_args, 0)
		__address := ExtractString(_args, 1)
		_res := __resolveUnixAddr(__network, __address)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var SRV_ Proc

func __SRV_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		_v := ExtractObject(_args, 0)
		_res := _ConstructSRV(_v)
		return MakeGoObject(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var SplitHostPort_ Proc

func __SplitHostPort_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		__hostport := ExtractString(_args, 0)
		_res := __splitHostPort(__hostport)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var TCPConn_ Proc

func __TCPConn_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		_v := ExtractObject(_args, 0)
		_res := _ConstructTCPConn(_v)
		return MakeGoObject(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var TCPListener_ Proc

func __TCPListener_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		_v := ExtractObject(_args, 0)
		_res := _ConstructTCPListener(_v)
		return MakeGoObject(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var UDPConn_ Proc

func __UDPConn_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		_v := ExtractObject(_args, 0)
		_res := _ConstructUDPConn(_v)
		return MakeGoObject(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var UnixAddr_ Proc

func __UnixAddr_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		_v := ExtractObject(_args, 0)
		_res := _ConstructUnixAddr(_v)
		return MakeGoObject(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var UnixConn_ Proc

func __UnixConn_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		_v := ExtractObject(_args, 0)
		_res := _ConstructUnixConn(_v)
		return MakeGoObject(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var UnixListener_ Proc

func __UnixListener_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		_v := ExtractObject(_args, 0)
		_res := _ConstructUnixListener(_v)
		return MakeGoObject(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var UnknownNetworkError_ Proc

func __UnknownNetworkError_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		_v := ExtractObject(_args, 0)
		_res := _ConstructUnknownNetworkError(_v)
		return MakeGoObject(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

func Init() {
	DefaultResolver_ = &GoVar{Value: &net.DefaultResolver}
	ErrWriteToConnected_ = &GoVar{Value: &net.ErrWriteToConnected}
	FlagBroadcast_ = MakeNumber(uint64(uint(net.FlagBroadcast)))
	FlagLoopback_ = MakeNumber(uint64(uint(net.FlagLoopback)))
	FlagMulticast_ = MakeNumber(uint64(uint(net.FlagMulticast)))
	FlagPointToPoint_ = MakeNumber(uint64(uint(net.FlagPointToPoint)))
	FlagUp_ = MakeNumber(uint64(uint(net.FlagUp)))
	IPv4allrouter_ = &GoVar{Value: &net.IPv4allrouter}
	IPv4allsys_ = &GoVar{Value: &net.IPv4allsys}
	IPv4bcast_ = &GoVar{Value: &net.IPv4bcast}
	IPv4len_ = MakeInt(net.IPv4len)
	IPv4zero_ = &GoVar{Value: &net.IPv4zero}
	IPv6interfacelocalallnodes_ = &GoVar{Value: &net.IPv6interfacelocalallnodes}
	IPv6len_ = MakeInt(net.IPv6len)
	IPv6linklocalallnodes_ = &GoVar{Value: &net.IPv6linklocalallnodes}
	IPv6linklocalallrouters_ = &GoVar{Value: &net.IPv6linklocalallrouters}
	IPv6loopback_ = &GoVar{Value: &net.IPv6loopback}
	IPv6unspecified_ = &GoVar{Value: &net.IPv6unspecified}
	IPv6zero_ = &GoVar{Value: &net.IPv6zero}
	AddrError_ = __AddrError_
	CIDRMask_ = __CIDRMask_
	DNSConfigError_ = __DNSConfigError_
	DNSError_ = __DNSError_
	Dial_ = __Dial_
	DialIP_ = __DialIP_
	DialTCP_ = __DialTCP_
	DialUDP_ = __DialUDP_
	DialUnix_ = __DialUnix_
	Flags_ = __Flags_
	IPConn_ = __IPConn_
	IPv4_ = __IPv4_
	IPv4Mask_ = __IPv4Mask_
	InterfaceAddrs_ = __InterfaceAddrs_
	InterfaceByIndex_ = __InterfaceByIndex_
	InterfaceByName_ = __InterfaceByName_
	Interfaces_ = __Interfaces_
	InvalidAddrError_ = __InvalidAddrError_
	JoinHostPort_ = __JoinHostPort_
	Listen_ = __Listen_
	ListenIP_ = __ListenIP_
	ListenMulticastUDP_ = __ListenMulticastUDP_
	ListenPacket_ = __ListenPacket_
	ListenTCP_ = __ListenTCP_
	ListenUDP_ = __ListenUDP_
	ListenUnix_ = __ListenUnix_
	ListenUnixgram_ = __ListenUnixgram_
	LookupAddr_ = __LookupAddr_
	LookupCNAME_ = __LookupCNAME_
	LookupHost_ = __LookupHost_
	LookupIP_ = __LookupIP_
	LookupMX_ = __LookupMX_
	LookupNS_ = __LookupNS_
	LookupPort_ = __LookupPort_
	LookupSRV_ = __LookupSRV_
	LookupTXT_ = __LookupTXT_
	MX_ = __MX_
	NS_ = __NS_
	ParseCIDR_ = __ParseCIDR_
	ParseError_ = __ParseError_
	ParseIP_ = __ParseIP_
	ParseMAC_ = __ParseMAC_
	Pipe_ = __Pipe_
	ResolveIPAddr_ = __ResolveIPAddr_
	ResolveTCPAddr_ = __ResolveTCPAddr_
	ResolveUDPAddr_ = __ResolveUDPAddr_
	ResolveUnixAddr_ = __ResolveUnixAddr_
	SRV_ = __SRV_
	SplitHostPort_ = __SplitHostPort_
	TCPConn_ = __TCPConn_
	TCPListener_ = __TCPListener_
	UDPConn_ = __UDPConn_
	UnixAddr_ = __UnixAddr_
	UnixConn_ = __UnixConn_
	UnixListener_ = __UnixListener_
	UnknownNetworkError_ = __UnknownNetworkError_

	initNative()

	netNamespace.ResetMeta(MakeMeta(nil, `Provides a low-level interface to the net package.

Package net provides a portable interface for network I/O, including
TCP/IP, UDP, domain name resolution, and Unix domain sockets.

Although the package provides access to low-level networking
primitives, most clients will need only the basic interface provided
by the Dial, Listen, and Accept functions and the associated
Conn and Listener interfaces. The crypto/tls package uses
the same interfaces and similar Dial and Listen functions.

The Dial function connects to a server:

	conn, err := net.Dial("tcp", "golang.org:80")
	if err != nil {
		// handle error
	}
	fmt.Fprintf(conn, "GET / HTTP/1.0\r\n\r\n")
	status, err := bufio.NewReader(conn).ReadString('\n')
	// ...

The Listen function creates servers:

	ln, err := net.Listen("tcp", ":8080")
	if err != nil {
		// handle error
	}
	for {
		conn, err := ln.Accept()
		if err != nil {
			// handle error
		}
		go handleConnection(conn)
	}

Name Resolution

The method for resolving domain names, whether indirectly with functions like Dial
or directly with functions like LookupHost and LookupAddr, varies by operating system.

On Unix systems, the resolver has two options for resolving names.
It can use a pure Go resolver that sends DNS requests directly to the servers
listed in /etc/resolv.conf, or it can use a cgo-based resolver that calls C
library routines such as getaddrinfo and getnameinfo.

By default the pure Go resolver is used, because a blocked DNS request consumes
only a goroutine, while a blocked C call consumes an operating system thread.
When cgo is available, the cgo-based resolver is used instead under a variety of
conditions: on systems that do not let programs make direct DNS requests (OS X),
when the LOCALDOMAIN environment variable is present (even if empty),
when the RES_OPTIONS or HOSTALIASES environment variable is non-empty,
when the ASR_CONFIG environment variable is non-empty (OpenBSD only),
when /etc/resolv.conf or /etc/nsswitch.conf specify the use of features that the
Go resolver does not implement, and when the name being looked up ends in .local
or is an mDNS name.

The resolver decision can be overridden by setting the netdns value of the
GODEBUG environment variable (see package runtime) to go or cgo, as in:

	export GODEBUG=netdns=go    # force pure Go resolver
	export GODEBUG=netdns=cgo   # force cgo resolver

The decision can also be forced while building the Go source tree
by setting the netgo or netcgo build tag.

A numeric netdns setting, as in GODEBUG=netdns=1, causes the resolver
to print debugging information about its decisions.
To force a particular resolver while also printing debugging information,
join the two settings by a plus sign, as in GODEBUG=netdns=go+1.

On Plan 9, the resolver always accesses /net/cs and /net/dns.

On Windows, the resolver always uses C library functions, such as GetAddrInfo and DnsQuery.
`, "1.0"))

	netNamespace.InternVar("DefaultResolver", DefaultResolver_,
		MakeMeta(
			nil,
			`DefaultResolver is the resolver used by the package-level Lookup
functions and by Dialers without a specified Resolver.
`, "1.0"))

	netNamespace.InternVar("ErrWriteToConnected", ErrWriteToConnected_,
		MakeMeta(
			nil,
			`Various errors contained in OpError.
`, "1.0"))

	netNamespace.InternVar("FlagBroadcast", FlagBroadcast_,
		MakeMeta(
			nil,
			`interface supports broadcast access capability
`, "1.0"))

	netNamespace.InternVar("FlagLoopback", FlagLoopback_,
		MakeMeta(
			nil,
			`interface is a loopback interface
`, "1.0"))

	netNamespace.InternVar("FlagMulticast", FlagMulticast_,
		MakeMeta(
			nil,
			`interface supports multicast access capability
`, "1.0"))

	netNamespace.InternVar("FlagPointToPoint", FlagPointToPoint_,
		MakeMeta(
			nil,
			`interface belongs to a point-to-point link
`, "1.0"))

	netNamespace.InternVar("FlagUp", FlagUp_,
		MakeMeta(
			nil,
			`interface is up
`, "1.0"))

	netNamespace.InternVar("IPv4allrouter", IPv4allrouter_,
		MakeMeta(
			nil,
			`all routers
`, "1.0"))

	netNamespace.InternVar("IPv4allsys", IPv4allsys_,
		MakeMeta(
			nil,
			`all systems
`, "1.0"))

	netNamespace.InternVar("IPv4bcast", IPv4bcast_,
		MakeMeta(
			nil,
			`limited broadcast
`, "1.0"))

	netNamespace.InternVar("IPv4len", IPv4len_,
		MakeMeta(
			nil,
			`IP address lengths (bytes).
`, "1.0"))

	netNamespace.InternVar("IPv4zero", IPv4zero_,
		MakeMeta(
			nil,
			`all zeros
`, "1.0"))

	netNamespace.InternVar("IPv6interfacelocalallnodes", IPv6interfacelocalallnodes_,
		MakeMeta(
			nil,
			`Well-known IPv6 addresses
`, "1.0"))

	netNamespace.InternVar("IPv6len", IPv6len_,
		MakeMeta(
			nil,
			`IP address lengths (bytes).
`, "1.0"))

	netNamespace.InternVar("IPv6linklocalallnodes", IPv6linklocalallnodes_,
		MakeMeta(
			nil,
			`Well-known IPv6 addresses
`, "1.0"))

	netNamespace.InternVar("IPv6linklocalallrouters", IPv6linklocalallrouters_,
		MakeMeta(
			nil,
			`Well-known IPv6 addresses
`, "1.0"))

	netNamespace.InternVar("IPv6loopback", IPv6loopback_,
		MakeMeta(
			nil,
			`Well-known IPv6 addresses
`, "1.0"))

	netNamespace.InternVar("IPv6unspecified", IPv6unspecified_,
		MakeMeta(
			nil,
			`Well-known IPv6 addresses
`, "1.0"))

	netNamespace.InternVar("IPv6zero", IPv6zero_,
		MakeMeta(
			nil,
			`Well-known IPv6 addresses
`, "1.0"))

	netNamespace.InternVar("AddrError.", AddrError_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("_v"))),
			`Constructor for net.AddrError`, "1.0"))

	netNamespace.InternVar("CIDRMask", CIDRMask_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__ones"), MakeSymbol("__bits"))),
			`CIDRMask returns an IPMask consisting of `+"`"+`ones' 1 bits
followed by 0s up to a total length of `+"`"+`bits' bits.
For a mask of this form, CIDRMask is the inverse of IPMask.Size.

Go input arguments: (ones int, bits int)

Go return type: IPMask

Joker input arguments: [^Int ones, ^Int bits]

Joker return type: go.std.net/IPMask`, "1.0"))

	netNamespace.InternVar("DNSConfigError.", DNSConfigError_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("_v"))),
			`Constructor for net.DNSConfigError`, "1.0"))

	netNamespace.InternVar("DNSError.", DNSError_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("_v"))),
			`Constructor for net.DNSError`, "1.0"))

	netNamespace.InternVar("Dial", Dial_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__network"), MakeSymbol("__address"))),
			`Dial connects to the address on the named network.

Known networks are "tcp", "tcp4" (IPv4-only), "tcp6" (IPv6-only),
"udp", "udp4" (IPv4-only), "udp6" (IPv6-only), "ip", "ip4"
(IPv4-only), "ip6" (IPv6-only), "unix", "unixgram" and
"unixpacket".

For TCP and UDP networks, the address has the form "host:port".
The host must be a literal IP address, or a host name that can be
resolved to IP addresses.
The port must be a literal port number or a service name.
If the host is a literal IPv6 address it must be enclosed in square
brackets, as in "[2001:db8::1]:80" or "[fe80::1%zone]:80".
The zone specifies the scope of the literal IPv6 address as defined
in RFC 4007.
The functions JoinHostPort and SplitHostPort manipulate a pair of
host and port in this form.
When using TCP, and the host resolves to multiple IP addresses,
Dial will try each IP address in order until one succeeds.

Examples:
	Dial("tcp", "golang.org:http")
	Dial("tcp", "192.0.2.1:http")
	Dial("tcp", "198.51.100.1:80")
	Dial("udp", "[2001:db8::1]:domain")
	Dial("udp", "[fe80::1%lo0]:53")
	Dial("tcp", ":80")

For IP networks, the network must be "ip", "ip4" or "ip6" followed
by a colon and a literal protocol number or a protocol name, and
the address has the form "host". The host must be a literal IP
address or a literal IPv6 address with zone.
It depends on each operating system how the operating system
behaves with a non-well known protocol number such as "0" or "255".

Examples:
	Dial("ip4:1", "192.0.2.1")
	Dial("ip6:ipv6-icmp", "2001:db8::1")
	Dial("ip6:58", "fe80::1%lo0")

For TCP, UDP and IP networks, if the host is empty or a literal
unspecified IP address, as in ":80", "0.0.0.0:80" or "[::]:80" for
TCP and UDP, "", "0.0.0.0" or "::" for IP, the local system is
assumed.

For Unix networks, the address must be a file system path.

Go input arguments: (network string, address string)

Go return type: (Conn, error)

Joker input arguments: [^String network, ^String address]

Joker return type: [go.std.net/Conn Error]`, "1.0"))

	netNamespace.InternVar("DialIP", DialIP_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__network"), MakeSymbol("__laddr"), MakeSymbol("__raddr"))),
			`DialIP acts like Dial for IP networks.

The network must be an IP network name; see func Dial for details.

If laddr is nil, a local address is automatically chosen.
If the IP field of raddr is nil or an unspecified IP address, the
local system is assumed.

Go input arguments: (network string, laddr *IPAddr, raddr *IPAddr)

Go return type: (*IPConn, error)

Joker input arguments: [^String network, ^(atom-of go.std.net/IPAddr) laddr, ^(atom-of go.std.net/IPAddr) raddr]

Joker return type: [(atom-of go.std.net/IPConn) Error]`, "1.0"))

	netNamespace.InternVar("DialTCP", DialTCP_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__network"), MakeSymbol("__laddr"), MakeSymbol("__raddr"))),
			`DialTCP acts like Dial for TCP networks.

The network must be a TCP network name; see func Dial for details.

If laddr is nil, a local address is automatically chosen.
If the IP field of raddr is nil or an unspecified IP address, the
local system is assumed.

Go input arguments: (network string, laddr *TCPAddr, raddr *TCPAddr)

Go return type: (*TCPConn, error)

Joker input arguments: [^String network, ^(atom-of go.std.net/TCPAddr) laddr, ^(atom-of go.std.net/TCPAddr) raddr]

Joker return type: [(atom-of go.std.net/TCPConn) Error]`, "1.0"))

	netNamespace.InternVar("DialUDP", DialUDP_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__network"), MakeSymbol("__laddr"), MakeSymbol("__raddr"))),
			`DialUDP acts like Dial for UDP networks.

The network must be a UDP network name; see func Dial for details.

If laddr is nil, a local address is automatically chosen.
If the IP field of raddr is nil or an unspecified IP address, the
local system is assumed.

Go input arguments: (network string, laddr *UDPAddr, raddr *UDPAddr)

Go return type: (*UDPConn, error)

Joker input arguments: [^String network, ^(atom-of go.std.net/UDPAddr) laddr, ^(atom-of go.std.net/UDPAddr) raddr]

Joker return type: [(atom-of go.std.net/UDPConn) Error]`, "1.0"))

	netNamespace.InternVar("DialUnix", DialUnix_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__network"), MakeSymbol("__laddr"), MakeSymbol("__raddr"))),
			`DialUnix acts like Dial for Unix networks.

The network must be a Unix network name; see func Dial for details.

If laddr is non-nil, it is used as the local address for the
connection.

Go input arguments: (network string, laddr *UnixAddr, raddr *UnixAddr)

Go return type: (*UnixConn, error)

Joker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr, ^(atom-of go.std.net/UnixAddr) raddr]

Joker return type: [(atom-of go.std.net/UnixConn) Error]`, "1.0"))

	netNamespace.InternVar("Flags.", Flags_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("_v"))),
			`Constructor for net.Flags`, "1.0"))

	netNamespace.InternVar("IPConn.", IPConn_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("_v"))),
			`Constructor for net.IPConn`, "1.0"))

	netNamespace.InternVar("IPv4", IPv4_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__a"), MakeSymbol("__b"), MakeSymbol("__c"), MakeSymbol("__d"))),
			`IPv4 returns the IP address (in 16-byte form) of the
IPv4 address a.b.c.d.

Go input arguments: (a byte, b byte, c byte, d byte)

Go return type: IP

Joker input arguments: [^Int a, ^Int b, ^Int c, ^Int d]

Joker return type: go.std.net/IP`, "1.0"))

	netNamespace.InternVar("IPv4Mask", IPv4Mask_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__a"), MakeSymbol("__b"), MakeSymbol("__c"), MakeSymbol("__d"))),
			`IPv4Mask returns the IP mask (in 4-byte form) of the
IPv4 mask a.b.c.d.

Go input arguments: (a byte, b byte, c byte, d byte)

Go return type: IPMask

Joker input arguments: [^Int a, ^Int b, ^Int c, ^Int d]

Joker return type: go.std.net/IPMask`, "1.0"))

	netNamespace.InternVar("InterfaceAddrs", InterfaceAddrs_,
		MakeMeta(
			NewListFrom(NewVectorFrom()),
			`InterfaceAddrs returns a list of the system's unicast interface
addresses.

The returned list does not identify the associated interface; use
Interfaces and Interface.Addrs for more detail.

Go return type: ([]Addr, error)

Joker input arguments: []

Joker return type: [(vector-of go.std.net/Addr) Error]`, "1.0"))

	netNamespace.InternVar("InterfaceByIndex", InterfaceByIndex_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__index"))),
			`InterfaceByIndex returns the interface specified by index.

On Solaris, it returns one of the logical network interfaces
sharing the logical data link; for more precision use
InterfaceByName.

Go input arguments: (index int)

Go return type: (*Interface, error)

Joker input arguments: [^Int index]

Joker return type: [(atom-of go.std.net/Interface) Error]`, "1.0"))

	netNamespace.InternVar("InterfaceByName", InterfaceByName_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__name"))),
			`InterfaceByName returns the interface specified by name.

Go input arguments: (name string)

Go return type: (*Interface, error)

Joker input arguments: [^String name]

Joker return type: [(atom-of go.std.net/Interface) Error]`, "1.0"))

	netNamespace.InternVar("Interfaces", Interfaces_,
		MakeMeta(
			NewListFrom(NewVectorFrom()),
			`Interfaces returns a list of the system's network interfaces.

Go return type: ([]Interface, error)

Joker input arguments: []

Joker return type: [(vector-of go.std.net/Interface) Error]`, "1.0"))

	netNamespace.InternVar("InvalidAddrError.", InvalidAddrError_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("_v"))),
			`Constructor for net.InvalidAddrError`, "1.0"))

	netNamespace.InternVar("JoinHostPort", JoinHostPort_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__host"), MakeSymbol("__port"))),
			`JoinHostPort combines host and port into a network address of the
form "host:port". If host contains a colon, as found in literal
IPv6 addresses, then JoinHostPort returns "[host]:port".

See func Dial for a description of the host and port parameters.

Go input arguments: (host string, port string)

Go return type: string

Joker input arguments: [^String host, ^String port]

Joker return type: String`, "1.0"))

	netNamespace.InternVar("Listen", Listen_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__network"), MakeSymbol("__address"))),
			`Listen announces on the local network address.

The network must be "tcp", "tcp4", "tcp6", "unix" or "unixpacket".

For TCP networks, if the host in the address parameter is empty or
a literal unspecified IP address, Listen listens on all available
unicast and anycast IP addresses of the local system.
To only use IPv4, use network "tcp4".
The address can use a host name, but this is not recommended,
because it will create a listener for at most one of the host's IP
addresses.
If the port in the address parameter is empty or "0", as in
"127.0.0.1:" or "[::1]:0", a port number is automatically chosen.
The Addr method of Listener can be used to discover the chosen
port.

See func Dial for a description of the network and address
parameters.

Go input arguments: (network string, address string)

Go return type: (Listener, error)

Joker input arguments: [^String network, ^String address]

Joker return type: [go.std.net/Listener Error]`, "1.0"))

	netNamespace.InternVar("ListenIP", ListenIP_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__network"), MakeSymbol("__laddr"))),
			`ListenIP acts like ListenPacket for IP networks.

The network must be an IP network name; see func Dial for details.

If the IP field of laddr is nil or an unspecified IP address,
ListenIP listens on all available IP addresses of the local system
except multicast IP addresses.

Go input arguments: (network string, laddr *IPAddr)

Go return type: (*IPConn, error)

Joker input arguments: [^String network, ^(atom-of go.std.net/IPAddr) laddr]

Joker return type: [(atom-of go.std.net/IPConn) Error]`, "1.0"))

	netNamespace.InternVar("ListenMulticastUDP", ListenMulticastUDP_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__network"), MakeSymbol("__ifi"), MakeSymbol("__gaddr"))),
			`ListenMulticastUDP acts like ListenPacket for UDP networks but
takes a group address on a specific network interface.

The network must be a UDP network name; see func Dial for details.

ListenMulticastUDP listens on all available IP addresses of the
local system including the group, multicast IP address.
If ifi is nil, ListenMulticastUDP uses the system-assigned
multicast interface, although this is not recommended because the
assignment depends on platforms and sometimes it might require
routing configuration.
If the Port field of gaddr is 0, a port number is automatically
chosen.

ListenMulticastUDP is just for convenience of simple, small
applications. There are golang.org/x/net/ipv4 and
golang.org/x/net/ipv6 packages for general purpose uses.

Go input arguments: (network string, ifi *Interface, gaddr *UDPAddr)

Go return type: (*UDPConn, error)

Joker input arguments: [^String network, ^(atom-of go.std.net/Interface) ifi, ^(atom-of go.std.net/UDPAddr) gaddr]

Joker return type: [(atom-of go.std.net/UDPConn) Error]`, "1.0"))

	netNamespace.InternVar("ListenPacket", ListenPacket_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__network"), MakeSymbol("__address"))),
			`ListenPacket announces on the local network address.

The network must be "udp", "udp4", "udp6", "unixgram", or an IP
transport. The IP transports are "ip", "ip4", or "ip6" followed by
a colon and a literal protocol number or a protocol name, as in
"ip:1" or "ip:icmp".

For UDP and IP networks, if the host in the address parameter is
empty or a literal unspecified IP address, ListenPacket listens on
all available IP addresses of the local system except multicast IP
addresses.
To only use IPv4, use network "udp4" or "ip4:proto".
The address can use a host name, but this is not recommended,
because it will create a listener for at most one of the host's IP
addresses.
If the port in the address parameter is empty or "0", as in
"127.0.0.1:" or "[::1]:0", a port number is automatically chosen.
The LocalAddr method of PacketConn can be used to discover the
chosen port.

See func Dial for a description of the network and address
parameters.

Go input arguments: (network string, address string)

Go return type: (PacketConn, error)

Joker input arguments: [^String network, ^String address]

Joker return type: [go.std.net/PacketConn Error]`, "1.0"))

	netNamespace.InternVar("ListenTCP", ListenTCP_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__network"), MakeSymbol("__laddr"))),
			`ListenTCP acts like Listen for TCP networks.

The network must be a TCP network name; see func Dial for details.

If the IP field of laddr is nil or an unspecified IP address,
ListenTCP listens on all available unicast and anycast IP addresses
of the local system.
If the Port field of laddr is 0, a port number is automatically
chosen.

Go input arguments: (network string, laddr *TCPAddr)

Go return type: (*TCPListener, error)

Joker input arguments: [^String network, ^(atom-of go.std.net/TCPAddr) laddr]

Joker return type: [(atom-of go.std.net/TCPListener) Error]`, "1.0"))

	netNamespace.InternVar("ListenUDP", ListenUDP_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__network"), MakeSymbol("__laddr"))),
			`ListenUDP acts like ListenPacket for UDP networks.

The network must be a UDP network name; see func Dial for details.

If the IP field of laddr is nil or an unspecified IP address,
ListenUDP listens on all available IP addresses of the local system
except multicast IP addresses.
If the Port field of laddr is 0, a port number is automatically
chosen.

Go input arguments: (network string, laddr *UDPAddr)

Go return type: (*UDPConn, error)

Joker input arguments: [^String network, ^(atom-of go.std.net/UDPAddr) laddr]

Joker return type: [(atom-of go.std.net/UDPConn) Error]`, "1.0"))

	netNamespace.InternVar("ListenUnix", ListenUnix_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__network"), MakeSymbol("__laddr"))),
			`ListenUnix acts like Listen for Unix networks.

The network must be "unix" or "unixpacket".

Go input arguments: (network string, laddr *UnixAddr)

Go return type: (*UnixListener, error)

Joker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr]

Joker return type: [(atom-of go.std.net/UnixListener) Error]`, "1.0"))

	netNamespace.InternVar("ListenUnixgram", ListenUnixgram_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__network"), MakeSymbol("__laddr"))),
			`ListenUnixgram acts like ListenPacket for Unix networks.

The network must be "unixgram".

Go input arguments: (network string, laddr *UnixAddr)

Go return type: (*UnixConn, error)

Joker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr]

Joker return type: [(atom-of go.std.net/UnixConn) Error]`, "1.0"))

	netNamespace.InternVar("LookupAddr", LookupAddr_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__addr"))),
			`LookupAddr performs a reverse lookup for the given address, returning a list
of names mapping to that address.

When using the host C library resolver, at most one result will be
returned. To bypass the host resolver, use a custom Resolver.

Go input arguments: (addr string)

Go return type: (names []string, err error)

Joker input arguments: [^String addr]

Joker return type: [(vector-of String) Error]`, "1.0"))

	netNamespace.InternVar("LookupCNAME", LookupCNAME_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__host"))),
			`LookupCNAME returns the canonical name for the given host.
Callers that do not care about the canonical name can call
LookupHost or LookupIP directly; both take care of resolving
the canonical name as part of the lookup.

A canonical name is the final name after following zero
or more CNAME records.
LookupCNAME does not return an error if host does not
contain DNS "CNAME" records, as long as host resolves to
address records.

Go input arguments: (host string)

Go return type: (cname string, err error)

Joker input arguments: [^String host]

Joker return type: [String Error]`, "1.0"))

	netNamespace.InternVar("LookupHost", LookupHost_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__host"))),
			`LookupHost looks up the given host using the local resolver.
It returns a slice of that host's addresses.

Go input arguments: (host string)

Go return type: (addrs []string, err error)

Joker input arguments: [^String host]

Joker return type: [(vector-of String) Error]`, "1.0"))

	netNamespace.InternVar("LookupIP", LookupIP_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__host"))),
			`LookupIP looks up host using the local resolver.
It returns a slice of that host's IPv4 and IPv6 addresses.

Go input arguments: (host string)

Go return type: ([]IP, error)

Joker input arguments: [^String host]

Joker return type: [(vector-of go.std.net/IP) Error]`, "1.0"))

	netNamespace.InternVar("LookupMX", LookupMX_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__name"))),
			`LookupMX returns the DNS MX records for the given domain name sorted by preference.

Go input arguments: (name string)

Go return type: ([]*MX, error)

Joker input arguments: [^String name]

Joker return type: [(vector-of (atom-of go.std.net/MX)) Error]`, "1.0"))

	netNamespace.InternVar("LookupNS", LookupNS_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__name"))),
			`LookupNS returns the DNS NS records for the given domain name.

Go input arguments: (name string)

Go return type: ([]*NS, error)

Joker input arguments: [^String name]

Joker return type: [(vector-of (atom-of go.std.net/NS)) Error]`, "1.0"))

	netNamespace.InternVar("LookupPort", LookupPort_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__network"), MakeSymbol("__service"))),
			`LookupPort looks up the port for the given network and service.

Go input arguments: (network string, service string)

Go return type: (port int, err error)

Joker input arguments: [^String network, ^String service]

Joker return type: [Int Error]`, "1.0"))

	netNamespace.InternVar("LookupSRV", LookupSRV_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__service"), MakeSymbol("__proto"), MakeSymbol("__name"))),
			`LookupSRV tries to resolve an SRV query of the given service,
protocol, and domain name. The proto is "tcp" or "udp".
The returned records are sorted by priority and randomized
by weight within a priority.

LookupSRV constructs the DNS name to look up following RFC 2782.
That is, it looks up _service._proto.name. To accommodate services
publishing SRV records under non-standard names, if both service
and proto are empty strings, LookupSRV looks up name directly.

Go input arguments: (service string, proto string, name string)

Go return type: (cname string, addrs []*SRV, err error)

Joker input arguments: [^String service, ^String proto, ^String name]

Joker return type: [String (vector-of (atom-of go.std.net/SRV)) Error]`, "1.0"))

	netNamespace.InternVar("LookupTXT", LookupTXT_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__name"))),
			`LookupTXT returns the DNS TXT records for the given domain name.

Go input arguments: (name string)

Go return type: ([]string, error)

Joker input arguments: [^String name]

Joker return type: [(vector-of String) Error]`, "1.0"))

	netNamespace.InternVar("MX.", MX_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("_v"))),
			`Constructor for net.MX`, "1.0"))

	netNamespace.InternVar("MX", MakeGoType(&info_MX),
		MakeMeta(
			nil, /*NewListFrom(NewVectorFrom(MakeSymbol("_v")))*/
			`GoType[net.MX]`, "1.0"))

	netNamespace.InternVar("NS.", NS_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("_v"))),
			`Constructor for net.NS`, "1.0"))

	netNamespace.InternVar("ParseCIDR", ParseCIDR_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__s"))),
			`ParseCIDR parses s as a CIDR notation IP address and prefix length,
like "192.0.2.0/24" or "2001:db8::/32", as defined in
RFC 4632 and RFC 4291.

It returns the IP address and the network implied by the IP and
prefix length.
For example, ParseCIDR("192.0.2.1/24") returns the IP address
192.0.2.1 and the network 192.0.2.0/24.

Go input arguments: (s string)

Go return type: (IP, *IPNet, error)

Joker input arguments: [^String s]

Joker return type: [go.std.net/IP (atom-of go.std.net/IPNet) Error]`, "1.0"))

	netNamespace.InternVar("ParseError.", ParseError_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("_v"))),
			`Constructor for net.ParseError`, "1.0"))

	netNamespace.InternVar("ParseIP", ParseIP_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__s"))),
			`ParseIP parses s as an IP address, returning the result.
The string s can be in dotted decimal ("192.0.2.1")
or IPv6 ("2001:db8::68") form.
If s is not a valid textual representation of an IP address,
ParseIP returns nil.

Go input arguments: (s string)

Go return type: IP

Joker input arguments: [^String s]

Joker return type: go.std.net/IP`, "1.0"))

	netNamespace.InternVar("ParseMAC", ParseMAC_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__s"))),
			`ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet
IP over InfiniBand link-layer address using one of the following formats:
  01:23:45:67:89:ab
  01:23:45:67:89:ab:cd:ef
  01:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00
  01-23-45-67-89-ab
  01-23-45-67-89-ab-cd-ef
  01-23-45-67-89-ab-cd-ef-00-00-01-23-45-67-89-ab-cd-ef-00-00
  0123.4567.89ab
  0123.4567.89ab.cdef
  0123.4567.89ab.cdef.0000.0123.4567.89ab.cdef.0000

Go input arguments: (s string)

Go return type: (hw HardwareAddr, err error)

Joker input arguments: [^String s]

Joker return type: [go.std.net/HardwareAddr Error]`, "1.0"))

	netNamespace.InternVar("Pipe", Pipe_,
		MakeMeta(
			NewListFrom(NewVectorFrom()),
			`Pipe creates a synchronous, in-memory, full duplex
network connection; both ends implement the Conn interface.
Reads on one end are matched with writes on the other,
copying data directly between the two; there is no internal
buffering.

Go return type: (Conn, Conn)

Joker input arguments: []

Joker return type: [go.std.net/Conn go.std.net/Conn]`, "1.0"))

	netNamespace.InternVar("ResolveIPAddr", ResolveIPAddr_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__network"), MakeSymbol("__address"))),
			`ResolveIPAddr returns an address of IP end point.

The network must be an IP network name.

If the host in the address parameter is not a literal IP address,
ResolveIPAddr resolves the address to an address of IP end point.
Otherwise, it parses the address as a literal IP address.
The address parameter can use a host name, but this is not
recommended, because it will return at most one of the host name's
IP addresses.

See func Dial for a description of the network and address
parameters.

Go input arguments: (network string, address string)

Go return type: (*IPAddr, error)

Joker input arguments: [^String network, ^String address]

Joker return type: [(atom-of go.std.net/IPAddr) Error]`, "1.0"))

	netNamespace.InternVar("ResolveTCPAddr", ResolveTCPAddr_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__network"), MakeSymbol("__address"))),
			`ResolveTCPAddr returns an address of TCP end point.

The network must be a TCP network name.

If the host in the address parameter is not a literal IP address or
the port is not a literal port number, ResolveTCPAddr resolves the
address to an address of TCP end point.
Otherwise, it parses the address as a pair of literal IP address
and port number.
The address parameter can use a host name, but this is not
recommended, because it will return at most one of the host name's
IP addresses.

See func Dial for a description of the network and address
parameters.

Go input arguments: (network string, address string)

Go return type: (*TCPAddr, error)

Joker input arguments: [^String network, ^String address]

Joker return type: [(atom-of go.std.net/TCPAddr) Error]`, "1.0"))

	netNamespace.InternVar("ResolveUDPAddr", ResolveUDPAddr_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__network"), MakeSymbol("__address"))),
			`ResolveUDPAddr returns an address of UDP end point.

The network must be a UDP network name.

If the host in the address parameter is not a literal IP address or
the port is not a literal port number, ResolveUDPAddr resolves the
address to an address of UDP end point.
Otherwise, it parses the address as a pair of literal IP address
and port number.
The address parameter can use a host name, but this is not
recommended, because it will return at most one of the host name's
IP addresses.

See func Dial for a description of the network and address
parameters.

Go input arguments: (network string, address string)

Go return type: (*UDPAddr, error)

Joker input arguments: [^String network, ^String address]

Joker return type: [(atom-of go.std.net/UDPAddr) Error]`, "1.0"))

	netNamespace.InternVar("ResolveUnixAddr", ResolveUnixAddr_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__network"), MakeSymbol("__address"))),
			`ResolveUnixAddr returns an address of Unix domain socket end point.

The network must be a Unix network name.

See func Dial for a description of the network and address
parameters.

Go input arguments: (network string, address string)

Go return type: (*UnixAddr, error)

Joker input arguments: [^String network, ^String address]

Joker return type: [(atom-of go.std.net/UnixAddr) Error]`, "1.0"))

	netNamespace.InternVar("SRV.", SRV_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("_v"))),
			`Constructor for net.SRV`, "1.0"))

	netNamespace.InternVar("SplitHostPort", SplitHostPort_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__hostport"))),
			`SplitHostPort splits a network address of the form "host:port",
"host%zone:port", "[host]:port" or "[host%zone]:port" into host or
host%zone and port.

A literal IPv6 address in hostport must be enclosed in square
brackets, as in "[::1]:80", "[::1%lo0]:80".

See func Dial for a description of the hostport parameter, and host
and port results.

Go input arguments: (hostport string)

Go return type: (host string, port string, err error)

Joker input arguments: [^String hostport]

Joker return type: [String String Error]`, "1.0"))

	netNamespace.InternVar("TCPConn.", TCPConn_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("_v"))),
			`Constructor for net.TCPConn`, "1.0"))

	netNamespace.InternVar("TCPListener.", TCPListener_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("_v"))),
			`Constructor for net.TCPListener`, "1.0"))

	netNamespace.InternVar("UDPConn.", UDPConn_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("_v"))),
			`Constructor for net.UDPConn`, "1.0"))

	netNamespace.InternVar("UnixAddr.", UnixAddr_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("_v"))),
			`Constructor for net.UnixAddr`, "1.0"))

	netNamespace.InternVar("UnixConn.", UnixConn_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("_v"))),
			`Constructor for net.UnixConn`, "1.0"))

	netNamespace.InternVar("UnixListener.", UnixListener_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("_v"))),
			`Constructor for net.UnixListener`, "1.0"))

	netNamespace.InternVar("UnknownNetworkError.", UnknownNetworkError_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("_v"))),
			`Constructor for net.UnknownNetworkError`, "1.0"))

}

func init() {
	netNamespace.Lazy = Init
}
