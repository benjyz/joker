// Auto-generated by gostd at 2019-09-17T13:14:28.216621211-04:00 by version 0.1, do not edit!!

package rpc

import (
	"fmt"
	. "github.com/candid82/joker/core"
	_rpc "net/rpc"
	_reflect "reflect"
)

func ExtractGoObjectCall(args []Object, index int) *_rpc.Call {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Call:
			return &r
		case *_rpc.Call:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Call]"))
}

// func _mapToCall(o Map) *_rpc.Call {
// 	return &_rpc.Call{}
// }

// func _vectorToCall(o *Vector) *_rpc.Call {
// 	return &_rpc.Call{
// 		ServiceMethod: AssertString(o.Nth(0), "").S,
// 		Args: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		Reply: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		Error: _errors.New(AssertString(o.Nth(3), "").S),
// 		Done: ABEND047(gotypes.go: unsupported type *ast.ChanType),
// 	}
// }

// func _ConstructCall(_v Object) *_rpc.Call {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rpc.Call:
// 			return &_g
// 		case *_rpc.Call:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCall(_o.(Map))
// 	case *Vector:
// 		return _vectorToCall(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Call] or: Map or Vector"))
// }

func ExtractGo_go_std_net_rpc__Call(rcvr, arg string, args *ArraySeq, n int) (res _rpc.Call) {
	a := CheckGoNth(rcvr, "go.std.net.rpc/Call", arg, args, n).O
	res, ok := a.(_rpc.Call)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.rpc/Call], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectClient(args []Object, index int) *_rpc.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Client:
			return &r
		case *_rpc.Client:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Client]"))
}

func _mapToClient(o Map) *_rpc.Client {
	return &_rpc.Client{}
}

func _vectorToClient(o *Vector) *_rpc.Client {
	return &_rpc.Client{}
}

func _ConstructClient(_v Object) *_rpc.Client {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.Client:
			return &_g
		case *_rpc.Client:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToClient(_o.(Map))
	case *Vector:
		return _vectorToClient(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Client] or: Map or Vector"))
}

func ExtractGo_go_std_net_rpc__Client(rcvr, arg string, args *ArraySeq, n int) (res _rpc.Client) {
	a := CheckGoNth(rcvr, "go.std.net.rpc/Client", arg, args, n).O
	res, ok := a.(_rpc.Client)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.rpc/Client], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectClientCodec(args []Object, index int) *_rpc.ClientCodec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.ClientCodec:
			return &r
		case *_rpc.ClientCodec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.ClientCodec]"))
}

// func _ConstructClientCodec(_v Object) _rpc.ClientCodec {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rpc.ClientCodec:
// 			return _g
// 		case *_rpc.ClientCodec:
// 			return *_g
// 		}
// 	default:
// 		return _rpc.ClientCodec(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ClientCodec))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.ClientCodec] or: whatever"))
// }

func ExtractGo_go_std_net_rpc__ClientCodec(rcvr, arg string, args *ArraySeq, n int) (res _rpc.ClientCodec) {
	a := CheckGoNth(rcvr, "go.std.net.rpc/ClientCodec", arg, args, n).O
	res, ok := a.(_rpc.ClientCodec)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.rpc/ClientCodec], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectRequest(args []Object, index int) *_rpc.Request {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Request:
			return &r
		case *_rpc.Request:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Request]"))
}

func _mapToRequest(o Map) *_rpc.Request {
	return &_rpc.Request{}
}

func _vectorToRequest(o *Vector) *_rpc.Request {
	return &_rpc.Request{
		ServiceMethod: AssertString(o.Nth(0), "").S,
		Seq: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
	}
}

func _ConstructRequest(_v Object) *_rpc.Request {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.Request:
			return &_g
		case *_rpc.Request:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRequest(_o.(Map))
	case *Vector:
		return _vectorToRequest(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Request] or: Map or Vector"))
}

func ExtractGo_go_std_net_rpc__Request(rcvr, arg string, args *ArraySeq, n int) (res _rpc.Request) {
	a := CheckGoNth(rcvr, "go.std.net.rpc/Request", arg, args, n).O
	res, ok := a.(_rpc.Request)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.rpc/Request], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectResponse(args []Object, index int) *_rpc.Response {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Response:
			return &r
		case *_rpc.Response:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Response]"))
}

func _mapToResponse(o Map) *_rpc.Response {
	return &_rpc.Response{}
}

func _vectorToResponse(o *Vector) *_rpc.Response {
	return &_rpc.Response{
		ServiceMethod: AssertString(o.Nth(0), "").S,
		Seq: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
		Error: AssertString(o.Nth(2), "").S,
	}
}

func _ConstructResponse(_v Object) *_rpc.Response {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.Response:
			return &_g
		case *_rpc.Response:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToResponse(_o.(Map))
	case *Vector:
		return _vectorToResponse(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Response] or: Map or Vector"))
}

func ExtractGo_go_std_net_rpc__Response(rcvr, arg string, args *ArraySeq, n int) (res _rpc.Response) {
	a := CheckGoNth(rcvr, "go.std.net.rpc/Response", arg, args, n).O
	res, ok := a.(_rpc.Response)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.rpc/Response], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectServer(args []Object, index int) *_rpc.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Server:
			return &r
		case *_rpc.Server:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Server]"))
}

func _mapToServer(o Map) *_rpc.Server {
	return &_rpc.Server{}
}

func _vectorToServer(o *Vector) *_rpc.Server {
	return &_rpc.Server{}
}

func _ConstructServer(_v Object) *_rpc.Server {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.Server:
			return &_g
		case *_rpc.Server:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToServer(_o.(Map))
	case *Vector:
		return _vectorToServer(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Server] or: Map or Vector"))
}

func ExtractGo_go_std_net_rpc__Server(rcvr, arg string, args *ArraySeq, n int) (res _rpc.Server) {
	a := CheckGoNth(rcvr, "go.std.net.rpc/Server", arg, args, n).O
	res, ok := a.(_rpc.Server)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.rpc/Server], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectServerCodec(args []Object, index int) *_rpc.ServerCodec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.ServerCodec:
			return &r
		case *_rpc.ServerCodec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.ServerCodec]"))
}

// func _ConstructServerCodec(_v Object) _rpc.ServerCodec {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rpc.ServerCodec:
// 			return _g
// 		case *_rpc.ServerCodec:
// 			return *_g
// 		}
// 	default:
// 		return _rpc.ServerCodec(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ServerCodec))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.ServerCodec] or: whatever"))
// }

func ExtractGo_go_std_net_rpc__ServerCodec(rcvr, arg string, args *ArraySeq, n int) (res _rpc.ServerCodec) {
	a := CheckGoNth(rcvr, "go.std.net.rpc/ServerCodec", arg, args, n).O
	res, ok := a.(_rpc.ServerCodec)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.rpc/ServerCodec], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectServerError(args []Object, index int) *_rpc.ServerError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.ServerError:
			return &r
		case *_rpc.ServerError:
			return r
		}
	case String:
		v := _rpc.ServerError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.ServerError]"))
}

func _ConstructServerError(_v Object) _rpc.ServerError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.ServerError:
			return _g
		case *_rpc.ServerError:
			return *_g
		}
	case String:
		return _rpc.ServerError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.ServerError] or: String"))
}

func ExtractGo_go_std_net_rpc__ServerError(rcvr, arg string, args *ArraySeq, n int) (res _rpc.ServerError) {
	a := CheckGoNth(rcvr, "go.std.net.rpc/ServerError", arg, args, n).O
	res, ok := a.(_rpc.ServerError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.rpc/ServerError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

// func __accept(__lis ABEND987(genutils.go: imports not yet supported: net.Listener)) Object {
// 	_rpc.Accept(__lis)
// 	...ABEND675: TODO...
// }

func __dial(__network string, __address string) Object {
	_res1, _res2 := _rpc.Dial(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __dialHTTP(__network string, __address string) Object {
	_res1, _res2 := _rpc.DialHTTP(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __dialHTTPPath(__network string, __address string, __path string) Object {
	_res1, _res2 := _rpc.DialHTTPPath(__network, __address, __path)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// func __handleHTTP() Object {
// 	_rpc.HandleHTTP()
// 	...ABEND675: TODO...
// }

// func __newClient(__conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _rpc.NewClient(__conn)
// 	return MakeGoObject(_res)
// }

func __newClientWithCodec(__codec _rpc.ClientCodec) Object {
	_res := _rpc.NewClientWithCodec(__codec)
	return MakeGoObject(_res)
}

func __newServer() Object {
	_res := _rpc.NewServer()
	return MakeGoObject(_res)
}

// func __register(__rcvr interface {})  {
// 	_res := _rpc.Register(__rcvr)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

// func __registerName(__name string, __rcvr interface {})  {
// 	_res := _rpc.RegisterName(__name, __rcvr)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

// func __serveCodec(__codec _rpc.ServerCodec) Object {
// 	_rpc.ServeCodec(__codec)
// 	...ABEND675: TODO...
// }

// func __serveConn(__conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_rpc.ServeConn(__conn)
// 	...ABEND675: TODO...
// }

// func __ptrTo_Client_Call(o GoObject, args Object) Object {
// (__serviceMethod, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

func __ptrTo_Client_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net/rpc.Client)Close()", args, 0, 0)
	_res := o.O.(*_rpc.Client).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

// func __ptrTo_Client_Go(o GoObject, args Object) Object {
// (__serviceMethod, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND909(pre.go: custom-runtime routine not implemented: ConvertToChanTypeHaHa()))}

// func __ptrTo_Server_Accept(o GoObject, args Object) Object {
// __lis ABEND987(genutils.go: imports not yet supported: net.Listener)}

// func __ptrTo_Server_HandleHTTP(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// func __ptrTo_Server_Register(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

// func __ptrTo_Server_RegisterName(o GoObject, args Object) Object {
// (__name, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

// func __ptrTo_Server_ServeCodec(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// func __ptrTo_Server_ServeConn(o GoObject, args Object) Object {
// __conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)}

// func __ptrTo_Server_ServeHTTP(o GoObject, args Object) Object {
// __w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), __req *ABEND987(genutils.go: imports not yet supported: http.Request)}

func __ptrTo_Server_ServeRequest(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/rpc.Server)ServeRequest()", args, 1, 1)
	__codec := ExtractGo_go_std_net_rpc__ServerCodec("(*_net/rpc.Server)ServeRequest()", "__codec", _argList, 0)
	_res := o.O.(*_rpc.Server).ServeRequest(__codec)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

func __serverError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_net/rpc.ServerError)Error()", args, 0, 0)
	_res := o.O.(_rpc.ServerError).Error()
	return MakeString(_res)
}
var members_PtrTo_Client GoTypeInfo
var members_PtrTo_Server GoTypeInfo
var members_ServerError GoTypeInfo

func initNative() {
	members_PtrTo_Client = GoTypeInfo{Members: GoMembers{
		"Close": __ptrTo_Client_Close,
	}}

	members_PtrTo_Server = GoTypeInfo{Members: GoMembers{
		"ServeRequest": __ptrTo_Server_ServeRequest,
	}}

	members_ServerError = GoTypeInfo{Members: GoMembers{
		"Error": __serverError_Error,
	}}

	GoTypes[_reflect.TypeOf((*_rpc.Client)(nil))] = &members_PtrTo_Client
	GoTypes[_reflect.TypeOf((*_rpc.Server)(nil))] = &members_PtrTo_Server
	GoTypes[_reflect.TypeOf((*_rpc.ServerError)(nil)).Elem()] = &members_ServerError
}
