// Auto-generated by gostd at 2019-09-17T13:14:28.216621211-04:00 by version 0.1, do not edit!!

package mail

import (
	"fmt"
	. "github.com/candid82/joker/core"
	_mail "net/mail"
	_reflect "reflect"
)

func ExtractGoObjectAddress(args []Object, index int) *_mail.Address {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mail.Address:
			return &r
		case *_mail.Address:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.Address]"))
}

func _mapToAddress(o Map) *_mail.Address {
	return &_mail.Address{}
}

func _vectorToAddress(o *Vector) *_mail.Address {
	return &_mail.Address{
		Name: AssertString(o.Nth(0), "").S,
		Address: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructAddress(_v Object) *_mail.Address {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _mail.Address:
			return &_g
		case *_mail.Address:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToAddress(_o.(Map))
	case *Vector:
		return _vectorToAddress(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.Address] or: Map or Vector"))
}

func ExtractGo_go_std_net_mail__Address(rcvr, arg string, args *ArraySeq, n int) (res _mail.Address) {
	a := CheckGoNth(rcvr, "go.std.net.mail/Address", arg, args, n).O
	res, ok := a.(_mail.Address)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.mail/Address], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectAddressParser(args []Object, index int) *_mail.AddressParser {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mail.AddressParser:
			return &r
		case *_mail.AddressParser:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.AddressParser]"))
}

// func _mapToAddressParser(o Map) *_mail.AddressParser {
// 	return &_mail.AddressParser{}
// }

// func _vectorToAddressParser(o *Vector) *_mail.AddressParser {
// 	return &_mail.AddressParser{
// 		WordDecoder: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructAddressParser(_v Object) *_mail.AddressParser {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _mail.AddressParser:
// 			return &_g
// 		case *_mail.AddressParser:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToAddressParser(_o.(Map))
// 	case *Vector:
// 		return _vectorToAddressParser(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.AddressParser] or: Map or Vector"))
// }

func ExtractGo_go_std_net_mail__AddressParser(rcvr, arg string, args *ArraySeq, n int) (res _mail.AddressParser) {
	a := CheckGoNth(rcvr, "go.std.net.mail/AddressParser", arg, args, n).O
	res, ok := a.(_mail.AddressParser)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.mail/AddressParser], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectHeader(args []Object, index int) *_mail.Header {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mail.Header:
			return &r
		case *_mail.Header:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.Header]"))
}

// func _ConstructHeader(_v Object) _mail.Header {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _mail.Header:
// 			return _g
// 		case *_mail.Header:
// 			return *_g
// 		}
// 	default:
// 		return _mail.Header(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for Header))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.Header] or: whatever"))
// }

func ExtractGo_go_std_net_mail__Header(rcvr, arg string, args *ArraySeq, n int) (res _mail.Header) {
	a := CheckGoNth(rcvr, "go.std.net.mail/Header", arg, args, n).O
	res, ok := a.(_mail.Header)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.mail/Header], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectMessage(args []Object, index int) *_mail.Message {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mail.Message:
			return &r
		case *_mail.Message:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.Message]"))
}

// func _mapToMessage(o Map) *_mail.Message {
// 	return &_mail.Message{}
// }

// func _vectorToMessage(o *Vector) *_mail.Message {
// 	return &_mail.Message{
// 		Header: ABEND048(codegen.go: no conversion from Clojure for net/mail.Header (ABEND047(gotypes.go: unsupported type *ast.MapType))),
// 		Body: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructMessage(_v Object) *_mail.Message {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _mail.Message:
// 			return &_g
// 		case *_mail.Message:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToMessage(_o.(Map))
// 	case *Vector:
// 		return _vectorToMessage(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.Message] or: Map or Vector"))
// }

func ExtractGo_go_std_net_mail__Message(rcvr, arg string, args *ArraySeq, n int) (res _mail.Message) {
	a := CheckGoNth(rcvr, "go.std.net.mail/Message", arg, args, n).O
	res, ok := a.(_mail.Message)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.mail/Message], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func __parseAddress(__address string) Object {
	_res1, _res2 := _mail.ParseAddress(__address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __parseAddressList(__list string) Object {
	_res1, _res2 := _mail.ParseAddressList(__list)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __parseDate(__date string) Object {
	_res1, _res2 := _mail.ParseDate(__date)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// func __readMessage(__r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	msg, err := _mail.ReadMessage(__r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(msg))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

func __header_AddressList(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net/mail.Header)AddressList()", args, 1, 1)
	__key := ExtractGoString("(_net/mail.Header)AddressList()", "__key", _argList, 0)
	_res1, _res2 := o.O.(_mail.Header).AddressList(__key)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __header_Date(o GoObject, args Object) Object {
	CheckGoArity("(_net/mail.Header)Date()", args, 0, 0)
	_res1, _res2 := o.O.(_mail.Header).Date()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __header_Get(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net/mail.Header)Get()", args, 1, 1)
	__key := ExtractGoString("(_net/mail.Header)Get()", "__key", _argList, 0)
	_res := o.O.(_mail.Header).Get(__key)
	return MakeString(_res)
}

func __ptrTo_AddressParser_Parse(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/mail.AddressParser)Parse()", args, 1, 1)
	__address := ExtractGoString("(*_net/mail.AddressParser)Parse()", "__address", _argList, 0)
	_res1, _res2 := o.O.(*_mail.AddressParser).Parse(__address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __ptrTo_AddressParser_ParseList(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/mail.AddressParser)ParseList()", args, 1, 1)
	__list := ExtractGoString("(*_net/mail.AddressParser)ParseList()", "__list", _argList, 0)
	_res1, _res2 := o.O.(*_mail.AddressParser).ParseList(__list)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __ptrTo_Address_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net/mail.Address)String()", args, 0, 0)
	_res := o.O.(*_mail.Address).String()
	return MakeString(_res)
}
var members_PtrTo_Address GoTypeInfo
var members_PtrTo_AddressParser GoTypeInfo
var members_Header GoTypeInfo

func initNative() {
	members_PtrTo_Address = GoTypeInfo{Members: GoMembers{
		"String": __ptrTo_Address_String,
	}}

	members_PtrTo_AddressParser = GoTypeInfo{Members: GoMembers{
		"Parse": __ptrTo_AddressParser_Parse,
		"ParseList": __ptrTo_AddressParser_ParseList,
	}}

	members_Header = GoTypeInfo{Members: GoMembers{
		"AddressList": __header_AddressList,
		"Date": __header_Date,
		"Get": __header_Get,
	}}

	GoTypes[_reflect.TypeOf((*_mail.Address)(nil))] = &members_PtrTo_Address
	GoTypes[_reflect.TypeOf((*_mail.AddressParser)(nil))] = &members_PtrTo_AddressParser
	GoTypes[_reflect.TypeOf((*_mail.Header)(nil)).Elem()] = &members_Header
}
