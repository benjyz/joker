// Auto-generated by gostd at 2019-09-17T13:14:28.216621211-04:00 by version 0.1, do not edit!!

package cookiejar

import (
	"fmt"
	. "github.com/candid82/joker/core"
	_cookiejar "net/http/cookiejar"
	"reflect"
)

func ExtractGoObjectJar(args []Object, index int) *_cookiejar.Jar {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cookiejar.Jar:
			return &r
		case *_cookiejar.Jar:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cookiejar.Jar]"))
}

func _mapToJar(o Map) *_cookiejar.Jar {
	return &_cookiejar.Jar{}
}

func _vectorToJar(o *Vector) *_cookiejar.Jar {
	return &_cookiejar.Jar{}
}

func _ConstructJar(_v Object) *_cookiejar.Jar {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _cookiejar.Jar:
			return &_g
		case *_cookiejar.Jar:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToJar(_o.(Map))
	case *Vector:
		return _vectorToJar(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[cookiejar.Jar] or: Map or Vector"))
}

func ExtractGo_go_std_net_http_cookiejar__Jar(rcvr, arg string, args *ArraySeq, n int) (res _cookiejar.Jar) {
	a := CheckGoNth(rcvr, "go.std.net.http.cookiejar/Jar", arg, args, n).O
	res, ok := a.(_cookiejar.Jar)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.cookiejar/Jar], but is GoObject[%s]",
			n, rcvr, GoTypeToString(reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectOptions(args []Object, index int) *_cookiejar.Options {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cookiejar.Options:
			return &r
		case *_cookiejar.Options:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cookiejar.Options]"))
}

// func _mapToOptions(o Map) *_cookiejar.Options {
// 	return &_cookiejar.Options{}
// }

// func _vectorToOptions(o *Vector) *_cookiejar.Options {
// 	return &_cookiejar.Options{
// 		PublicSuffixList: ABEND048(codegen.go: no conversion from Clojure for net/http/cookiejar.PublicSuffixList (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructOptions(_v Object) *_cookiejar.Options {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cookiejar.Options:
// 			return &_g
// 		case *_cookiejar.Options:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToOptions(_o.(Map))
// 	case *Vector:
// 		return _vectorToOptions(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cookiejar.Options] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http_cookiejar__Options(rcvr, arg string, args *ArraySeq, n int) (res _cookiejar.Options) {
	a := CheckGoNth(rcvr, "go.std.net.http.cookiejar/Options", arg, args, n).O
	res, ok := a.(_cookiejar.Options)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.cookiejar/Options], but is GoObject[%s]",
			n, rcvr, GoTypeToString(reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectPublicSuffixList(args []Object, index int) *_cookiejar.PublicSuffixList {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cookiejar.PublicSuffixList:
			return &r
		case *_cookiejar.PublicSuffixList:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cookiejar.PublicSuffixList]"))
}

// func _ConstructPublicSuffixList(_v Object) _cookiejar.PublicSuffixList {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cookiejar.PublicSuffixList:
// 			return _g
// 		case *_cookiejar.PublicSuffixList:
// 			return *_g
// 		}
// 	default:
// 		return _cookiejar.PublicSuffixList(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for PublicSuffixList))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cookiejar.PublicSuffixList] or: whatever"))
// }

func ExtractGo_go_std_net_http_cookiejar__PublicSuffixList(rcvr, arg string, args *ArraySeq, n int) (res _cookiejar.PublicSuffixList) {
	a := CheckGoNth(rcvr, "go.std.net.http.cookiejar/PublicSuffixList", arg, args, n).O
	res, ok := a.(_cookiejar.PublicSuffixList)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.cookiejar/PublicSuffixList], but is GoObject[%s]",
			n, rcvr, GoTypeToString(reflect.TypeOf(a)))))
	}
	return
}

func __new(__o *_cookiejar.Options) Object {
	_res1, _res2 := _cookiejar.New(__o)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// func __ptrTo_Jar_Cookies(o GoObject, args Object) Object {
// __u *ABEND987(genutils.go: imports not yet supported: url.URL)}

// func __ptrTo_Jar_SetCookies(o GoObject, args Object) Object {
// __u *ABEND987(genutils.go: imports not yet supported: url.URL), __cookies []*ABEND987(genutils.go: imports not yet supported: http.Cookie)}

func initNative() {
}
