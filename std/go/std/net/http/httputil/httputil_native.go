// Auto-generated by gostd at 2019-09-17T13:14:28.216621211-04:00 by version 0.1, do not edit!!

package httputil

import (
	"fmt"
	. "github.com/candid82/joker/core"
	_httputil "net/http/httputil"
	_reflect "reflect"
)

func ExtractGoObjectBufferPool(args []Object, index int) *_httputil.BufferPool {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httputil.BufferPool:
			return &r
		case *_httputil.BufferPool:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httputil.BufferPool]"))
}

// func _ConstructBufferPool(_v Object) _httputil.BufferPool {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _httputil.BufferPool:
// 			return _g
// 		case *_httputil.BufferPool:
// 			return *_g
// 		}
// 	default:
// 		return _httputil.BufferPool(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for BufferPool))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[httputil.BufferPool] or: whatever"))
// }

func ExtractGo_go_std_net_http_httputil__BufferPool(rcvr, arg string, args *ArraySeq, n int) (res _httputil.BufferPool) {
	a := CheckGoNth(rcvr, "go.std.net.http.httputil/BufferPool", arg, args, n).O
	res, ok := a.(_httputil.BufferPool)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.httputil/BufferPool], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectClientConn(args []Object, index int) *_httputil.ClientConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httputil.ClientConn:
			return &r
		case *_httputil.ClientConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httputil.ClientConn]"))
}

func _mapToClientConn(o Map) *_httputil.ClientConn {
	return &_httputil.ClientConn{}
}

func _vectorToClientConn(o *Vector) *_httputil.ClientConn {
	return &_httputil.ClientConn{}
}

func _ConstructClientConn(_v Object) *_httputil.ClientConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _httputil.ClientConn:
			return &_g
		case *_httputil.ClientConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToClientConn(_o.(Map))
	case *Vector:
		return _vectorToClientConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[httputil.ClientConn] or: Map or Vector"))
}

func ExtractGo_go_std_net_http_httputil__ClientConn(rcvr, arg string, args *ArraySeq, n int) (res _httputil.ClientConn) {
	a := CheckGoNth(rcvr, "go.std.net.http.httputil/ClientConn", arg, args, n).O
	res, ok := a.(_httputil.ClientConn)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.httputil/ClientConn], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectReverseProxy(args []Object, index int) *_httputil.ReverseProxy {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httputil.ReverseProxy:
			return &r
		case *_httputil.ReverseProxy:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httputil.ReverseProxy]"))
}

// func _mapToReverseProxy(o Map) *_httputil.ReverseProxy {
// 	return &_httputil.ReverseProxy{}
// }

// func _vectorToReverseProxy(o *Vector) *_httputil.ReverseProxy {
// 	return &_httputil.ReverseProxy{
// 		Director: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		Transport: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		FlushInterval: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ErrorLog: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		BufferPool: ABEND048(codegen.go: no conversion from Clojure for net/http/httputil.BufferPool (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		ModifyResponse: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		ErrorHandler: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructReverseProxy(_v Object) *_httputil.ReverseProxy {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _httputil.ReverseProxy:
// 			return &_g
// 		case *_httputil.ReverseProxy:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToReverseProxy(_o.(Map))
// 	case *Vector:
// 		return _vectorToReverseProxy(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[httputil.ReverseProxy] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http_httputil__ReverseProxy(rcvr, arg string, args *ArraySeq, n int) (res _httputil.ReverseProxy) {
	a := CheckGoNth(rcvr, "go.std.net.http.httputil/ReverseProxy", arg, args, n).O
	res, ok := a.(_httputil.ReverseProxy)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.httputil/ReverseProxy], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectServerConn(args []Object, index int) *_httputil.ServerConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httputil.ServerConn:
			return &r
		case *_httputil.ServerConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httputil.ServerConn]"))
}

func _mapToServerConn(o Map) *_httputil.ServerConn {
	return &_httputil.ServerConn{}
}

func _vectorToServerConn(o *Vector) *_httputil.ServerConn {
	return &_httputil.ServerConn{}
}

func _ConstructServerConn(_v Object) *_httputil.ServerConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _httputil.ServerConn:
			return &_g
		case *_httputil.ServerConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToServerConn(_o.(Map))
	case *Vector:
		return _vectorToServerConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[httputil.ServerConn] or: Map or Vector"))
}

func ExtractGo_go_std_net_http_httputil__ServerConn(rcvr, arg string, args *ArraySeq, n int) (res _httputil.ServerConn) {
	a := CheckGoNth(rcvr, "go.std.net.http.httputil/ServerConn", arg, args, n).O
	res, ok := a.(_httputil.ServerConn)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.httputil/ServerConn], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

// func __dumpRequest(__req *ABEND987(genutils.go: imports not yet supported: http.Request), __body bool) Object {
// 	_res1, _res2 := _httputil.DumpRequest(__req, __body)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

// func __dumpRequestOut(__req *ABEND987(genutils.go: imports not yet supported: http.Request), __body bool) Object {
// 	_res1, _res2 := _httputil.DumpRequestOut(__req, __body)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

// func __dumpResponse(__resp *ABEND987(genutils.go: imports not yet supported: http.Response), __body bool) Object {
// 	_res1, _res2 := _httputil.DumpResponse(__resp, __body)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

// func __newChunkedReader(__r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _httputil.NewChunkedReader(__r)
// 	return MakeGoObject(_res)
// }

// func __newChunkedWriter(__w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _httputil.NewChunkedWriter(__w)
// 	return MakeGoObject(_res)
// }

// func __newClientConn(__c ABEND987(genutils.go: imports not yet supported: net.Conn), __r *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res := _httputil.NewClientConn(__c, __r)
// 	return MakeGoObject(_res)
// }

// func __newProxyClientConn(__c ABEND987(genutils.go: imports not yet supported: net.Conn), __r *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res := _httputil.NewProxyClientConn(__c, __r)
// 	return MakeGoObject(_res)
// }

// func __newServerConn(__c ABEND987(genutils.go: imports not yet supported: net.Conn), __r *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res := _httputil.NewServerConn(__c, __r)
// 	return MakeGoObject(_res)
// }

// func __newSingleHostReverseProxy(__target *ABEND987(genutils.go: imports not yet supported: url.URL)) Object {
// 	_res := _httputil.NewSingleHostReverseProxy(__target)
// 	return MakeGoObject(_res)
// }

func __ptrTo_ClientConn_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httputil.ClientConn)Close()", args, 0, 0)
	_res := o.O.(*_httputil.ClientConn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

// func __ptrTo_ClientConn_Do(o GoObject, args Object) Object {
// __req *ABEND987(genutils.go: imports not yet supported: http.Request)}

func __ptrTo_ClientConn_Hijack(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httputil.ClientConn)Hijack()", args, 0, 0)
	c, r := o.O.(*_httputil.ClientConn).Hijack()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(c))
	_res = _res.Conjoin(MakeGoObject(r))
	return _res
}

func __ptrTo_ClientConn_Pending(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httputil.ClientConn)Pending()", args, 0, 0)
	_res := o.O.(*_httputil.ClientConn).Pending()
	return MakeInt(_res)
}

// func __ptrTo_ClientConn_Read(o GoObject, args Object) Object {
// __req *ABEND987(genutils.go: imports not yet supported: http.Request)}

// func __ptrTo_ClientConn_Write(o GoObject, args Object) Object {
// __req *ABEND987(genutils.go: imports not yet supported: http.Request)}

// func __ptrTo_ReverseProxy_ServeHTTP(o GoObject, args Object) Object {
// __rw ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), __req *ABEND987(genutils.go: imports not yet supported: http.Request)}

func __ptrTo_ServerConn_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httputil.ServerConn)Close()", args, 0, 0)
	_res := o.O.(*_httputil.ServerConn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

func __ptrTo_ServerConn_Hijack(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httputil.ServerConn)Hijack()", args, 0, 0)
	_res1, _res2 := o.O.(*_httputil.ServerConn).Hijack()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	return _res
}

func __ptrTo_ServerConn_Pending(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httputil.ServerConn)Pending()", args, 0, 0)
	_res := o.O.(*_httputil.ServerConn).Pending()
	return MakeInt(_res)
}

func __ptrTo_ServerConn_Read(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httputil.ServerConn)Read()", args, 0, 0)
	_res1, _res2 := o.O.(*_httputil.ServerConn).Read()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// func __ptrTo_ServerConn_Write(o GoObject, args Object) Object {
// __req *ABEND987(genutils.go: imports not yet supported: http.Request), __resp *ABEND987(genutils.go: imports not yet supported: http.Response)}
var members_PtrTo_ClientConn GoTypeInfo
var members_PtrTo_ServerConn GoTypeInfo

func initNative() {
	members_PtrTo_ClientConn = GoTypeInfo{Members: GoMembers{
		"Close": __ptrTo_ClientConn_Close,
		"Hijack": __ptrTo_ClientConn_Hijack,
		"Pending": __ptrTo_ClientConn_Pending,
	}}

	members_PtrTo_ServerConn = GoTypeInfo{Members: GoMembers{
		"Close": __ptrTo_ServerConn_Close,
		"Hijack": __ptrTo_ServerConn_Hijack,
		"Pending": __ptrTo_ServerConn_Pending,
		"Read": __ptrTo_ServerConn_Read,
	}}

	GoTypes[_reflect.TypeOf((*_httputil.ClientConn)(nil))] = &members_PtrTo_ClientConn
	GoTypes[_reflect.TypeOf((*_httputil.ServerConn)(nil))] = &members_PtrTo_ServerConn
}
