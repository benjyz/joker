// Auto-generated by gostd at 2019-09-17T13:14:28.216621211-04:00 by version 0.1, do not edit!!

package http

import (
	"fmt"
	. "github.com/candid82/joker/core"
	_http "net/http"
	_reflect "reflect"
)

func ExtractGoObjectClient(args []Object, index int) *_http.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Client:
			return &r
		case *_http.Client:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Client]"))
}

// func _mapToClient(o Map) *_http.Client {
// 	return &_http.Client{}
// }

// func _vectorToClient(o *Vector) *_http.Client {
// 	return &_http.Client{
// 		Transport: ABEND048(codegen.go: no conversion from Clojure for net/http.RoundTripper (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		CheckRedirect: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		Jar: ABEND048(codegen.go: no conversion from Clojure for net/http.CookieJar (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Timeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructClient(_v Object) *_http.Client {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Client:
// 			return &_g
// 		case *_http.Client:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToClient(_o.(Map))
// 	case *Vector:
// 		return _vectorToClient(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Client] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http__Client(rcvr, arg string, args *ArraySeq, n int) (res _http.Client) {
	a := CheckGoNth(rcvr, "go.std.net.http/Client", arg, args, n).O
	res, ok := a.(_http.Client)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Client], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectCloseNotifier(args []Object, index int) *_http.CloseNotifier {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.CloseNotifier:
			return &r
		case *_http.CloseNotifier:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.CloseNotifier]"))
}

// func _ConstructCloseNotifier(_v Object) _http.CloseNotifier {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.CloseNotifier:
// 			return _g
// 		case *_http.CloseNotifier:
// 			return *_g
// 		}
// 	default:
// 		return _http.CloseNotifier(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for CloseNotifier))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.CloseNotifier] or: whatever"))
// }

func ExtractGo_go_std_net_http__CloseNotifier(rcvr, arg string, args *ArraySeq, n int) (res _http.CloseNotifier) {
	a := CheckGoNth(rcvr, "go.std.net.http/CloseNotifier", arg, args, n).O
	res, ok := a.(_http.CloseNotifier)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/CloseNotifier], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectConnState(args []Object, index int) *_http.ConnState {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.ConnState:
			return &r
		case *_http.ConnState:
			return r
		}
	case Int:
		v := _http.ConnState(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ConnState]"))
}

func _ConstructConnState(_v Object) _http.ConnState {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.ConnState:
			return _g
		case *_http.ConnState:
			return *_g
		}
	case Number:
		return _http.ConnState(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ConnState] or: Number"))
}

func ExtractGo_go_std_net_http__ConnState(rcvr, arg string, args *ArraySeq, n int) (res _http.ConnState) {
	a := CheckGoNth(rcvr, "go.std.net.http/ConnState", arg, args, n).O
	res, ok := a.(_http.ConnState)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/ConnState], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectCookie(args []Object, index int) *_http.Cookie {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Cookie:
			return &r
		case *_http.Cookie:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Cookie]"))
}

// func _mapToCookie(o Map) *_http.Cookie {
// 	return &_http.Cookie{}
// }

// func _vectorToCookie(o *Vector) *_http.Cookie {
// 	return &_http.Cookie{
// 		Name: AssertString(o.Nth(0), "").S,
// 		Value: AssertString(o.Nth(1), "").S,
// 		Path: AssertString(o.Nth(2), "").S,
// 		Domain: AssertString(o.Nth(3), "").S,
// 		Expires: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		RawExpires: AssertString(o.Nth(5), "").S,
// 		MaxAge: AssertInt(o.Nth(6), "").I,
// 		Secure: ToBool(o.Nth(7)),
// 		HttpOnly: ToBool(o.Nth(8)),
// 		SameSite: _http.SameSite(AssertInt(o.Nth(9), "").I),
// 		Raw: AssertString(o.Nth(10), "").S,
// 		Unparsed: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 	}
// }

// func _ConstructCookie(_v Object) *_http.Cookie {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Cookie:
// 			return &_g
// 		case *_http.Cookie:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCookie(_o.(Map))
// 	case *Vector:
// 		return _vectorToCookie(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Cookie] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http__Cookie(rcvr, arg string, args *ArraySeq, n int) (res _http.Cookie) {
	a := CheckGoNth(rcvr, "go.std.net.http/Cookie", arg, args, n).O
	res, ok := a.(_http.Cookie)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Cookie], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectCookieJar(args []Object, index int) *_http.CookieJar {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.CookieJar:
			return &r
		case *_http.CookieJar:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.CookieJar]"))
}

// func _ConstructCookieJar(_v Object) _http.CookieJar {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.CookieJar:
// 			return _g
// 		case *_http.CookieJar:
// 			return *_g
// 		}
// 	default:
// 		return _http.CookieJar(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for CookieJar))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.CookieJar] or: whatever"))
// }

func ExtractGo_go_std_net_http__CookieJar(rcvr, arg string, args *ArraySeq, n int) (res _http.CookieJar) {
	a := CheckGoNth(rcvr, "go.std.net.http/CookieJar", arg, args, n).O
	res, ok := a.(_http.CookieJar)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/CookieJar], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectDir(args []Object, index int) *_http.Dir {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Dir:
			return &r
		case *_http.Dir:
			return r
		}
	case String:
		v := _http.Dir(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Dir]"))
}

func _ConstructDir(_v Object) _http.Dir {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.Dir:
			return _g
		case *_http.Dir:
			return *_g
		}
	case String:
		return _http.Dir(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Dir] or: String"))
}

func ExtractGo_go_std_net_http__Dir(rcvr, arg string, args *ArraySeq, n int) (res _http.Dir) {
	a := CheckGoNth(rcvr, "go.std.net.http/Dir", arg, args, n).O
	res, ok := a.(_http.Dir)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Dir], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectFile(args []Object, index int) *_http.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.File:
			return &r
		case *_http.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.File]"))
}

// func _ConstructFile(_v Object) _http.File {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.File:
// 			return _g
// 		case *_http.File:
// 			return *_g
// 		}
// 	default:
// 		return _http.File(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for File))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.File] or: whatever"))
// }

func ExtractGo_go_std_net_http__File(rcvr, arg string, args *ArraySeq, n int) (res _http.File) {
	a := CheckGoNth(rcvr, "go.std.net.http/File", arg, args, n).O
	res, ok := a.(_http.File)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/File], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectFileSystem(args []Object, index int) *_http.FileSystem {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.FileSystem:
			return &r
		case *_http.FileSystem:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.FileSystem]"))
}

// func _ConstructFileSystem(_v Object) _http.FileSystem {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.FileSystem:
// 			return _g
// 		case *_http.FileSystem:
// 			return *_g
// 		}
// 	default:
// 		return _http.FileSystem(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for FileSystem))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.FileSystem] or: whatever"))
// }

func ExtractGo_go_std_net_http__FileSystem(rcvr, arg string, args *ArraySeq, n int) (res _http.FileSystem) {
	a := CheckGoNth(rcvr, "go.std.net.http/FileSystem", arg, args, n).O
	res, ok := a.(_http.FileSystem)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/FileSystem], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectFlusher(args []Object, index int) *_http.Flusher {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Flusher:
			return &r
		case *_http.Flusher:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Flusher]"))
}

// func _ConstructFlusher(_v Object) _http.Flusher {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Flusher:
// 			return _g
// 		case *_http.Flusher:
// 			return *_g
// 		}
// 	default:
// 		return _http.Flusher(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Flusher))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Flusher] or: whatever"))
// }

func ExtractGo_go_std_net_http__Flusher(rcvr, arg string, args *ArraySeq, n int) (res _http.Flusher) {
	a := CheckGoNth(rcvr, "go.std.net.http/Flusher", arg, args, n).O
	res, ok := a.(_http.Flusher)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Flusher], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectHandler(args []Object, index int) *_http.Handler {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Handler:
			return &r
		case *_http.Handler:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Handler]"))
}

// func _ConstructHandler(_v Object) _http.Handler {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Handler:
// 			return _g
// 		case *_http.Handler:
// 			return *_g
// 		}
// 	default:
// 		return _http.Handler(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Handler))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Handler] or: whatever"))
// }

func ExtractGo_go_std_net_http__Handler(rcvr, arg string, args *ArraySeq, n int) (res _http.Handler) {
	a := CheckGoNth(rcvr, "go.std.net.http/Handler", arg, args, n).O
	res, ok := a.(_http.Handler)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Handler], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectHandlerFunc(args []Object, index int) *_http.HandlerFunc {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.HandlerFunc:
			return &r
		case *_http.HandlerFunc:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.HandlerFunc]"))
}

// func _ConstructHandlerFunc(_v Object) _http.HandlerFunc {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.HandlerFunc:
// 			return _g
// 		case *_http.HandlerFunc:
// 			return *_g
// 		}
// 	default:
// 		return _http.HandlerFunc(_o.ABEND674(codegen.go: unknown underlying type *ast.FuncType for HandlerFunc))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.HandlerFunc] or: whatever"))
// }

func ExtractGo_go_std_net_http__HandlerFunc(rcvr, arg string, args *ArraySeq, n int) (res _http.HandlerFunc) {
	a := CheckGoNth(rcvr, "go.std.net.http/HandlerFunc", arg, args, n).O
	res, ok := a.(_http.HandlerFunc)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/HandlerFunc], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectHeader(args []Object, index int) *_http.Header {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Header:
			return &r
		case *_http.Header:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Header]"))
}

// func _ConstructHeader(_v Object) _http.Header {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Header:
// 			return _g
// 		case *_http.Header:
// 			return *_g
// 		}
// 	default:
// 		return _http.Header(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for Header))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Header] or: whatever"))
// }

func ExtractGo_go_std_net_http__Header(rcvr, arg string, args *ArraySeq, n int) (res _http.Header) {
	a := CheckGoNth(rcvr, "go.std.net.http/Header", arg, args, n).O
	res, ok := a.(_http.Header)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Header], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectHijacker(args []Object, index int) *_http.Hijacker {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Hijacker:
			return &r
		case *_http.Hijacker:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Hijacker]"))
}

// func _ConstructHijacker(_v Object) _http.Hijacker {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Hijacker:
// 			return _g
// 		case *_http.Hijacker:
// 			return *_g
// 		}
// 	default:
// 		return _http.Hijacker(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Hijacker))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Hijacker] or: whatever"))
// }

func ExtractGo_go_std_net_http__Hijacker(rcvr, arg string, args *ArraySeq, n int) (res _http.Hijacker) {
	a := CheckGoNth(rcvr, "go.std.net.http/Hijacker", arg, args, n).O
	res, ok := a.(_http.Hijacker)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Hijacker], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectProtocolError(args []Object, index int) *_http.ProtocolError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.ProtocolError:
			return &r
		case *_http.ProtocolError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ProtocolError]"))
}

func _mapToProtocolError(o Map) *_http.ProtocolError {
	return &_http.ProtocolError{}
}

func _vectorToProtocolError(o *Vector) *_http.ProtocolError {
	return &_http.ProtocolError{
		ErrorString: AssertString(o.Nth(0), "").S,
	}
}

func _ConstructProtocolError(_v Object) *_http.ProtocolError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.ProtocolError:
			return &_g
		case *_http.ProtocolError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProtocolError(_o.(Map))
	case *Vector:
		return _vectorToProtocolError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ProtocolError] or: Map or Vector"))
}

func ExtractGo_go_std_net_http__ProtocolError(rcvr, arg string, args *ArraySeq, n int) (res _http.ProtocolError) {
	a := CheckGoNth(rcvr, "go.std.net.http/ProtocolError", arg, args, n).O
	res, ok := a.(_http.ProtocolError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/ProtocolError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectPushOptions(args []Object, index int) *_http.PushOptions {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.PushOptions:
			return &r
		case *_http.PushOptions:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.PushOptions]"))
}

// func _mapToPushOptions(o Map) *_http.PushOptions {
// 	return &_http.PushOptions{}
// }

// func _vectorToPushOptions(o *Vector) *_http.PushOptions {
// 	return &_http.PushOptions{
// 		Method: AssertString(o.Nth(0), "").S,
// 		Header: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (ABEND047(gotypes.go: unsupported type *ast.MapType))),
// 	}
// }

// func _ConstructPushOptions(_v Object) *_http.PushOptions {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.PushOptions:
// 			return &_g
// 		case *_http.PushOptions:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToPushOptions(_o.(Map))
// 	case *Vector:
// 		return _vectorToPushOptions(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.PushOptions] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http__PushOptions(rcvr, arg string, args *ArraySeq, n int) (res _http.PushOptions) {
	a := CheckGoNth(rcvr, "go.std.net.http/PushOptions", arg, args, n).O
	res, ok := a.(_http.PushOptions)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/PushOptions], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectPusher(args []Object, index int) *_http.Pusher {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Pusher:
			return &r
		case *_http.Pusher:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Pusher]"))
}

// func _ConstructPusher(_v Object) _http.Pusher {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Pusher:
// 			return _g
// 		case *_http.Pusher:
// 			return *_g
// 		}
// 	default:
// 		return _http.Pusher(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Pusher))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Pusher] or: whatever"))
// }

func ExtractGo_go_std_net_http__Pusher(rcvr, arg string, args *ArraySeq, n int) (res _http.Pusher) {
	a := CheckGoNth(rcvr, "go.std.net.http/Pusher", arg, args, n).O
	res, ok := a.(_http.Pusher)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Pusher], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectRequest(args []Object, index int) *_http.Request {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Request:
			return &r
		case *_http.Request:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Request]"))
}

// func _mapToRequest(o Map) *_http.Request {
// 	return &_http.Request{}
// }

// func _vectorToRequest(o *Vector) *_http.Request {
// 	return &_http.Request{
// 		Method: AssertString(o.Nth(0), "").S,
// 		URL: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Proto: AssertString(o.Nth(2), "").S,
// 		ProtoMajor: AssertInt(o.Nth(3), "").I,
// 		ProtoMinor: AssertInt(o.Nth(4), "").I,
// 		Header: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (ABEND047(gotypes.go: unsupported type *ast.MapType))),
// 		Body: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		GetBody: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		ContentLength: AssertNumber(o.Nth(8), "").BigInt().Int64(),
// 		TransferEncoding: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Close: ToBool(o.Nth(10)),
// 		Host: AssertString(o.Nth(11), "").S,
// 		Form: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		PostForm: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		MultipartForm: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Trailer: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (ABEND047(gotypes.go: unsupported type *ast.MapType))),
// 		RemoteAddr: AssertString(o.Nth(16), "").S,
// 		RequestURI: AssertString(o.Nth(17), "").S,
// 		TLS: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Cancel: ABEND047(gotypes.go: unsupported type *ast.ChanType),
// 		Response: ABEND048(codegen.go: no conversion from Clojure for *net/http.Response (net/http.Response)),
// 	}
// }

// func _ConstructRequest(_v Object) *_http.Request {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Request:
// 			return &_g
// 		case *_http.Request:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRequest(_o.(Map))
// 	case *Vector:
// 		return _vectorToRequest(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Request] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http__Request(rcvr, arg string, args *ArraySeq, n int) (res _http.Request) {
	a := CheckGoNth(rcvr, "go.std.net.http/Request", arg, args, n).O
	res, ok := a.(_http.Request)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Request], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectResponse(args []Object, index int) *_http.Response {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Response:
			return &r
		case *_http.Response:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Response]"))
}

// func _mapToResponse(o Map) *_http.Response {
// 	return &_http.Response{}
// }

// func _vectorToResponse(o *Vector) *_http.Response {
// 	return &_http.Response{
// 		Status: AssertString(o.Nth(0), "").S,
// 		StatusCode: AssertInt(o.Nth(1), "").I,
// 		Proto: AssertString(o.Nth(2), "").S,
// 		ProtoMajor: AssertInt(o.Nth(3), "").I,
// 		ProtoMinor: AssertInt(o.Nth(4), "").I,
// 		Header: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (ABEND047(gotypes.go: unsupported type *ast.MapType))),
// 		Body: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ContentLength: AssertNumber(o.Nth(7), "").BigInt().Int64(),
// 		TransferEncoding: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Close: ToBool(o.Nth(9)),
// 		Uncompressed: ToBool(o.Nth(10)),
// 		Trailer: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (ABEND047(gotypes.go: unsupported type *ast.MapType))),
// 		Request: ABEND048(codegen.go: no conversion from Clojure for *net/http.Request (net/http.Request)),
// 		TLS: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructResponse(_v Object) *_http.Response {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Response:
// 			return &_g
// 		case *_http.Response:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToResponse(_o.(Map))
// 	case *Vector:
// 		return _vectorToResponse(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Response] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http__Response(rcvr, arg string, args *ArraySeq, n int) (res _http.Response) {
	a := CheckGoNth(rcvr, "go.std.net.http/Response", arg, args, n).O
	res, ok := a.(_http.Response)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Response], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectResponseWriter(args []Object, index int) *_http.ResponseWriter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.ResponseWriter:
			return &r
		case *_http.ResponseWriter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ResponseWriter]"))
}

// func _ConstructResponseWriter(_v Object) _http.ResponseWriter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.ResponseWriter:
// 			return _g
// 		case *_http.ResponseWriter:
// 			return *_g
// 		}
// 	default:
// 		return _http.ResponseWriter(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ResponseWriter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ResponseWriter] or: whatever"))
// }

func ExtractGo_go_std_net_http__ResponseWriter(rcvr, arg string, args *ArraySeq, n int) (res _http.ResponseWriter) {
	a := CheckGoNth(rcvr, "go.std.net.http/ResponseWriter", arg, args, n).O
	res, ok := a.(_http.ResponseWriter)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/ResponseWriter], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectRoundTripper(args []Object, index int) *_http.RoundTripper {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.RoundTripper:
			return &r
		case *_http.RoundTripper:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.RoundTripper]"))
}

// func _ConstructRoundTripper(_v Object) _http.RoundTripper {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.RoundTripper:
// 			return _g
// 		case *_http.RoundTripper:
// 			return *_g
// 		}
// 	default:
// 		return _http.RoundTripper(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for RoundTripper))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.RoundTripper] or: whatever"))
// }

func ExtractGo_go_std_net_http__RoundTripper(rcvr, arg string, args *ArraySeq, n int) (res _http.RoundTripper) {
	a := CheckGoNth(rcvr, "go.std.net.http/RoundTripper", arg, args, n).O
	res, ok := a.(_http.RoundTripper)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/RoundTripper], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectSameSite(args []Object, index int) *_http.SameSite {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.SameSite:
			return &r
		case *_http.SameSite:
			return r
		}
	case Int:
		v := _http.SameSite(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.SameSite]"))
}

func _ConstructSameSite(_v Object) _http.SameSite {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.SameSite:
			return _g
		case *_http.SameSite:
			return *_g
		}
	case Number:
		return _http.SameSite(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.SameSite] or: Number"))
}

func ExtractGo_go_std_net_http__SameSite(rcvr, arg string, args *ArraySeq, n int) (res _http.SameSite) {
	a := CheckGoNth(rcvr, "go.std.net.http/SameSite", arg, args, n).O
	res, ok := a.(_http.SameSite)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/SameSite], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectServeMux(args []Object, index int) *_http.ServeMux {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.ServeMux:
			return &r
		case *_http.ServeMux:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ServeMux]"))
}

func _mapToServeMux(o Map) *_http.ServeMux {
	return &_http.ServeMux{}
}

func _vectorToServeMux(o *Vector) *_http.ServeMux {
	return &_http.ServeMux{}
}

func _ConstructServeMux(_v Object) *_http.ServeMux {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.ServeMux:
			return &_g
		case *_http.ServeMux:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToServeMux(_o.(Map))
	case *Vector:
		return _vectorToServeMux(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ServeMux] or: Map or Vector"))
}

func ExtractGo_go_std_net_http__ServeMux(rcvr, arg string, args *ArraySeq, n int) (res _http.ServeMux) {
	a := CheckGoNth(rcvr, "go.std.net.http/ServeMux", arg, args, n).O
	res, ok := a.(_http.ServeMux)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/ServeMux], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectServer(args []Object, index int) *_http.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Server:
			return &r
		case *_http.Server:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Server]"))
}

// func _mapToServer(o Map) *_http.Server {
// 	return &_http.Server{}
// }

// func _vectorToServer(o *Vector) *_http.Server {
// 	return &_http.Server{
// 		Addr: AssertString(o.Nth(0), "").S,
// 		Handler: ABEND048(codegen.go: no conversion from Clojure for net/http.Handler (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		TLSConfig: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ReadTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ReadHeaderTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		WriteTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		IdleTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		MaxHeaderBytes: AssertInt(o.Nth(7), "").I,
// 		TLSNextProto: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		ConnState: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		ErrorLog: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructServer(_v Object) *_http.Server {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Server:
// 			return &_g
// 		case *_http.Server:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToServer(_o.(Map))
// 	case *Vector:
// 		return _vectorToServer(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Server] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http__Server(rcvr, arg string, args *ArraySeq, n int) (res _http.Server) {
	a := CheckGoNth(rcvr, "go.std.net.http/Server", arg, args, n).O
	res, ok := a.(_http.Server)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Server], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectTransport(args []Object, index int) *_http.Transport {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Transport:
			return &r
		case *_http.Transport:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Transport]"))
}

// func _mapToTransport(o Map) *_http.Transport {
// 	return &_http.Transport{}
// }

// func _vectorToTransport(o *Vector) *_http.Transport {
// 	return &_http.Transport{
// 		Proxy: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		DialContext: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		Dial: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		DialTLS: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		TLSClientConfig: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		TLSHandshakeTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		DisableKeepAlives: ToBool(o.Nth(6)),
// 		DisableCompression: ToBool(o.Nth(7)),
// 		MaxIdleConns: AssertInt(o.Nth(8), "").I,
// 		MaxIdleConnsPerHost: AssertInt(o.Nth(9), "").I,
// 		MaxConnsPerHost: AssertInt(o.Nth(10), "").I,
// 		IdleConnTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ResponseHeaderTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ExpectContinueTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		TLSNextProto: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		ProxyConnectHeader: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (ABEND047(gotypes.go: unsupported type *ast.MapType))),
// 		MaxResponseHeaderBytes: AssertNumber(o.Nth(16), "").BigInt().Int64(),
// 	}
// }

// func _ConstructTransport(_v Object) *_http.Transport {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Transport:
// 			return &_g
// 		case *_http.Transport:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTransport(_o.(Map))
// 	case *Vector:
// 		return _vectorToTransport(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Transport] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http__Transport(rcvr, arg string, args *ArraySeq, n int) (res _http.Transport) {
	a := CheckGoNth(rcvr, "go.std.net.http/Transport", arg, args, n).O
	res, ok := a.(_http.Transport)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Transport], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

// func __detectContentType(__data []byte)  {
// 	_res := _http.DetectContentType(__data)
// 	return MakeString(_res)
// }

// func __error(__w _http.ResponseWriter, __error string, __code int) Object {
// 	_http.Error(__w, __error, __code)
// 	...ABEND675: TODO...
// }

func __fileServer(__root _http.FileSystem) Object {
	_res := _http.FileServer(__root)
	return MakeGoObject(_res)
}

func __get(__url string) Object {
	resp, err := _http.Get(__url)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

// func __handle(__pattern string, __handler _http.Handler) Object {
// 	_http.Handle(__pattern, __handler)
// 	...ABEND675: TODO...
// }

// func __handleFunc(__pattern string, __handler func) Object {
// 	_http.HandleFunc(__pattern, __handler)
// 	...ABEND675: TODO...
// }

func __head(__url string) Object {
	resp, err := _http.Head(__url)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

// func __maxBytesReader(__w _http.ResponseWriter, __r ABEND987(genutils.go: imports not yet supported: io.ReadCloser), __n int64) Object {
// 	_res := _http.MaxBytesReader(__w, __r, __n)
// 	return MakeGoObject(_res)
// }

func __newFileTransport(__fs _http.FileSystem) Object {
	_res := _http.NewFileTransport(__fs)
	return MakeGoObject(_res)
}

// func __newRequest(__method string, __url string, __body ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _http.NewRequest(__method, __url, __body)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

func __newServeMux() Object {
	_res := _http.NewServeMux()
	return MakeGoObject(_res)
}

// func __notFound(__w _http.ResponseWriter, __r *_http.Request) Object {
// 	_http.NotFound(__w, __r)
// 	...ABEND675: TODO...
// }

func __notFoundHandler() Object {
	_res := _http.NotFoundHandler()
	return MakeGoObject(_res)
}

func __parseHTTPVersion(__vers string) Object {
	major, minor, ok := _http.ParseHTTPVersion(__vers)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(major))
	_res = _res.Conjoin(MakeInt(minor))
	_res = _res.Conjoin(MakeBoolean(ok))
	return _res
}

func __parseTime(__text string) Object {
	t, err := _http.ParseTime(__text)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(t))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

// func __post(__url string, __contentType string, __body ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	resp, err := _http.Post(__url, __contentType, __body)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(resp))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

// func __postForm(__url string, __data ABEND987(genutils.go: imports not yet supported: url.Values)) Object {
// 	resp, err := _http.PostForm(__url, __data)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(resp))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

func __proxyFromEnvironment(__req *_http.Request) Object {
	_res1, _res2 := _http.ProxyFromEnvironment(__req)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// func __proxyURL(__fixedURL *ABEND987(genutils.go: imports not yet supported: url.URL)) Object {
// 	return _http.ProxyURL(__fixedURL)
// }

// func __readRequest(__b *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res1, _res2 := _http.ReadRequest(__b)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

// func __readResponse(__r *ABEND987(genutils.go: imports not yet supported: bufio.Reader), __req *_http.Request) Object {
// 	_res1, _res2 := _http.ReadResponse(__r, __req)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

// func __redirect(__w _http.ResponseWriter, __r *_http.Request, __url string, __code int) Object {
// 	_http.Redirect(__w, __r, __url, __code)
// 	...ABEND675: TODO...
// }

func __redirectHandler(__url string, __code int) Object {
	_res := _http.RedirectHandler(__url, __code)
	return MakeGoObject(_res)
}

// func __serve(__l ABEND987(genutils.go: imports not yet supported: net.Listener), __handler _http.Handler)  {
// 	_res := _http.Serve(__l, __handler)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

// func __serveContent(__w _http.ResponseWriter, __req *_http.Request, __name string, __modtime ABEND987(genutils.go: imports not yet supported: time.Time), __content ABEND987(genutils.go: imports not yet supported: io.ReadSeeker)) Object {
// 	_http.ServeContent(__w, __req, __name, __modtime, __content)
// 	...ABEND675: TODO...
// }

// func __serveFile(__w _http.ResponseWriter, __r *_http.Request, __name string) Object {
// 	_http.ServeFile(__w, __r, __name)
// 	...ABEND675: TODO...
// }

// func __serveTLS(__l ABEND987(genutils.go: imports not yet supported: net.Listener), __handler _http.Handler, __certFile string, __keyFile string)  {
// 	_res := _http.ServeTLS(__l, __handler, __certFile, __keyFile)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

// func __setCookie(__w _http.ResponseWriter, __cookie *_http.Cookie) Object {
// 	_http.SetCookie(__w, __cookie)
// 	...ABEND675: TODO...
// }

func __stripPrefix(__prefix string, __h _http.Handler) Object {
	_res := _http.StripPrefix(__prefix, __h)
	return MakeGoObject(_res)
}

// func __timeoutHandler(__h _http.Handler, __dt ABEND987(genutils.go: imports not yet supported: time.Duration), __msg string) Object {
// 	_res := _http.TimeoutHandler(__h, __dt, __msg)
// 	return MakeGoObject(_res)
// }

func __connState_String(o GoObject, args Object) Object {
	CheckGoArity("(_net/http.ConnState)String()", args, 0, 0)
	_res := o.O.(_http.ConnState).String()
	return MakeString(_res)
}

func __dir_Open(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net/http.Dir)Open()", args, 1, 1)
	__name := ExtractGoString("(_net/http.Dir)Open()", "__name", _argList, 0)
	_res1, _res2 := o.O.(_http.Dir).Open(__name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// func __handlerFunc_ServeHTTP(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// func __header_Add(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// func __header_Del(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

func __header_Get(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net/http.Header)Get()", args, 1, 1)
	__key := ExtractGoString("(_net/http.Header)Get()", "__key", _argList, 0)
	_res := o.O.(_http.Header).Get(__key)
	return MakeString(_res)
}

// func __header_Set(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// func __header_Write(o GoObject, args Object) Object {
// __w ABEND987(genutils.go: imports not yet supported: io.Writer)}

// func __header_WriteSubset(o GoObject, args Object) Object {
// __w ABEND987(genutils.go: imports not yet supported: io.Writer), __exclude map[]}

// func __ptrTo_Client_CloseIdleConnections(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// func __ptrTo_Client_Do(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_net/http.Client)Do()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for __req at: /usr/local/go/src/net/http/client.go:508:25)
// 	_res1, _res2 := o.O.(*_http.Client).Do(__req)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

func __ptrTo_Client_Get(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Client)Get()", args, 1, 1)
	__url := ExtractGoString("(*_net/http.Client)Get()", "__url", _argList, 0)
	resp, err := o.O.(*_http.Client).Get(__url)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

func __ptrTo_Client_Head(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Client)Head()", args, 1, 1)
	__url := ExtractGoString("(*_net/http.Client)Head()", "__url", _argList, 0)
	resp, err := o.O.(*_http.Client).Head(__url)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

// func __ptrTo_Client_Post(o GoObject, args Object) Object {
// __url string, __contentType string, __body ABEND987(genutils.go: imports not yet supported: io.Reader)}

// func __ptrTo_Client_PostForm(o GoObject, args Object) Object {
// __url string, __data ABEND987(genutils.go: imports not yet supported: url.Values)}

func __ptrTo_Cookie_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Cookie)String()", args, 0, 0)
	_res := o.O.(*_http.Cookie).String()
	return MakeString(_res)
}

func __ptrTo_ProtocolError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.ProtocolError)Error()", args, 0, 0)
	_res := o.O.(*_http.ProtocolError).Error()
	return MakeString(_res)
}

// func __ptrTo_Request_AddCookie(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

func __ptrTo_Request_BasicAuth(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Request)BasicAuth()", args, 0, 0)
	username, password, ok := o.O.(*_http.Request).BasicAuth()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(username))
	_res = _res.Conjoin(MakeString(password))
	_res = _res.Conjoin(MakeBoolean(ok))
	return _res
}

func __ptrTo_Request_Context(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Request)Context()", args, 0, 0)
	_res := o.O.(*_http.Request).Context()
	return MakeGoObject(_res)
}

func __ptrTo_Request_Cookie(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Request)Cookie()", args, 1, 1)
	__name := ExtractGoString("(*_net/http.Request)Cookie()", "__name", _argList, 0)
	_res1, _res2 := o.O.(*_http.Request).Cookie(__name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __ptrTo_Request_Cookies(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Request)Cookies()", args, 0, 0)
	_res := o.O.(*_http.Request).Cookies()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	return _vec1
}

func __ptrTo_Request_FormFile(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Request)FormFile()", args, 1, 1)
	__key := ExtractGoString("(*_net/http.Request)FormFile()", "__key", _argList, 0)
	_res1, _res2, _res3 := o.O.(*_http.Request).FormFile(__key)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
	return _res
}

func __ptrTo_Request_FormValue(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Request)FormValue()", args, 1, 1)
	__key := ExtractGoString("(*_net/http.Request)FormValue()", "__key", _argList, 0)
	_res := o.O.(*_http.Request).FormValue(__key)
	return MakeString(_res)
}

func __ptrTo_Request_MultipartReader(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Request)MultipartReader()", args, 0, 0)
	_res1, _res2 := o.O.(*_http.Request).MultipartReader()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __ptrTo_Request_ParseForm(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Request)ParseForm()", args, 0, 0)
	_res := o.O.(*_http.Request).ParseForm()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

func __ptrTo_Request_ParseMultipartForm(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Request)ParseMultipartForm()", args, 1, 1)
	__maxMemory := ExtractGoInt64("(*_net/http.Request)ParseMultipartForm()", "__maxMemory", _argList, 0)
	_res := o.O.(*_http.Request).ParseMultipartForm(__maxMemory)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

func __ptrTo_Request_PostFormValue(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Request)PostFormValue()", args, 1, 1)
	__key := ExtractGoString("(*_net/http.Request)PostFormValue()", "__key", _argList, 0)
	_res := o.O.(*_http.Request).PostFormValue(__key)
	return MakeString(_res)
}

func __ptrTo_Request_ProtoAtLeast(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Request)ProtoAtLeast()", args, 2, 2)
	__major := ExtractGoInt("(*_net/http.Request)ProtoAtLeast()", "__major", _argList, 0)
	__minor := ExtractGoInt("(*_net/http.Request)ProtoAtLeast()", "__minor", _argList, 1)
	_res := o.O.(*_http.Request).ProtoAtLeast(__major, __minor)
	return MakeBoolean(_res)
}

func __ptrTo_Request_Referer(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Request)Referer()", args, 0, 0)
	_res := o.O.(*_http.Request).Referer()
	return MakeString(_res)
}

// func __ptrTo_Request_SetBasicAuth(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

func __ptrTo_Request_UserAgent(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Request)UserAgent()", args, 0, 0)
	_res := o.O.(*_http.Request).UserAgent()
	return MakeString(_res)
}

// func __ptrTo_Request_WithContext(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context)}

// func __ptrTo_Request_Write(o GoObject, args Object) Object {
// __w ABEND987(genutils.go: imports not yet supported: io.Writer)}

// func __ptrTo_Request_WriteProxy(o GoObject, args Object) Object {
// __w ABEND987(genutils.go: imports not yet supported: io.Writer)}

func __ptrTo_Response_Cookies(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Response)Cookies()", args, 0, 0)
	_res := o.O.(*_http.Response).Cookies()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	return _vec1
}

func __ptrTo_Response_Location(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Response)Location()", args, 0, 0)
	_res1, _res2 := o.O.(*_http.Response).Location()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __ptrTo_Response_ProtoAtLeast(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Response)ProtoAtLeast()", args, 2, 2)
	__major := ExtractGoInt("(*_net/http.Response)ProtoAtLeast()", "__major", _argList, 0)
	__minor := ExtractGoInt("(*_net/http.Response)ProtoAtLeast()", "__minor", _argList, 1)
	_res := o.O.(*_http.Response).ProtoAtLeast(__major, __minor)
	return MakeBoolean(_res)
}

// func __ptrTo_Response_Write(o GoObject, args Object) Object {
// __w ABEND987(genutils.go: imports not yet supported: io.Writer)}

// func __ptrTo_ServeMux_Handle(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// func __ptrTo_ServeMux_HandleFunc(o GoObject, args Object) Object {
// (__pattern, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

// func __ptrTo_ServeMux_Handler(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_net/http.ServeMux)Handler()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for __r at: /usr/local/go/src/net/http/server.go:2310:32)
// 	h, pattern := o.O.(*_http.ServeMux).Handler(__r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(h))
// 	_res = _res.Conjoin(MakeString(pattern))
// 	return _res
// }

// func __ptrTo_ServeMux_ServeHTTP(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

func __ptrTo_Server_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Server)Close()", args, 0, 0)
	_res := o.O.(*_http.Server).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

func __ptrTo_Server_ListenAndServe(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Server)ListenAndServe()", args, 0, 0)
	_res := o.O.(*_http.Server).ListenAndServe()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

func __ptrTo_Server_ListenAndServeTLS(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Server)ListenAndServeTLS()", args, 2, 2)
	__certFile := ExtractGoString("(*_net/http.Server)ListenAndServeTLS()", "__certFile", _argList, 0)
	__keyFile := ExtractGoString("(*_net/http.Server)ListenAndServeTLS()", "__keyFile", _argList, 1)
	_res := o.O.(*_http.Server).ListenAndServeTLS(__certFile, __keyFile)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

// func __ptrTo_Server_RegisterOnShutdown(o GoObject, args Object) Object {
// (ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

// func __ptrTo_Server_Serve(o GoObject, args Object) Object {
// __l ABEND987(genutils.go: imports not yet supported: net.Listener)}

// func __ptrTo_Server_ServeTLS(o GoObject, args Object) Object {
// __l ABEND987(genutils.go: imports not yet supported: net.Listener), __certFile string, __keyFile string}

// func __ptrTo_Server_SetKeepAlivesEnabled(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// func __ptrTo_Server_Shutdown(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context)}

// func __ptrTo_Transport_CancelRequest(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// func __ptrTo_Transport_CloseIdleConnections(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// func __ptrTo_Transport_RegisterProtocol(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// func __ptrTo_Transport_RoundTrip(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_net/http.Transport)RoundTrip()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for __req at: /usr/local/go/src/net/http/roundtrip.go:16:35)
// 	_res1, _res2 := o.O.(*_http.Transport).RoundTrip(__req)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }
var members_PtrTo_Client GoTypeInfo
var members_ConnState GoTypeInfo
var members_PtrTo_Cookie GoTypeInfo
var members_Dir GoTypeInfo
var members_Header GoTypeInfo
var members_PtrTo_ProtocolError GoTypeInfo
var members_PtrTo_Request GoTypeInfo
var members_PtrTo_Response GoTypeInfo
var members_PtrTo_Server GoTypeInfo

func initNative() {
	members_PtrTo_Client = GoTypeInfo{Members: GoMembers{
		"Get": __ptrTo_Client_Get,
		"Head": __ptrTo_Client_Head,
	}}

	members_ConnState = GoTypeInfo{Members: GoMembers{
		"String": __connState_String,
	}}

	members_PtrTo_Cookie = GoTypeInfo{Members: GoMembers{
		"String": __ptrTo_Cookie_String,
	}}

	members_Dir = GoTypeInfo{Members: GoMembers{
		"Open": __dir_Open,
	}}

	members_Header = GoTypeInfo{Members: GoMembers{
		"Get": __header_Get,
	}}

	members_PtrTo_ProtocolError = GoTypeInfo{Members: GoMembers{
		"Error": __ptrTo_ProtocolError_Error,
	}}

	members_PtrTo_Request = GoTypeInfo{Members: GoMembers{
		"BasicAuth": __ptrTo_Request_BasicAuth,
		"Context": __ptrTo_Request_Context,
		"Cookie": __ptrTo_Request_Cookie,
		"Cookies": __ptrTo_Request_Cookies,
		"FormFile": __ptrTo_Request_FormFile,
		"FormValue": __ptrTo_Request_FormValue,
		"MultipartReader": __ptrTo_Request_MultipartReader,
		"ParseForm": __ptrTo_Request_ParseForm,
		"ParseMultipartForm": __ptrTo_Request_ParseMultipartForm,
		"PostFormValue": __ptrTo_Request_PostFormValue,
		"ProtoAtLeast": __ptrTo_Request_ProtoAtLeast,
		"Referer": __ptrTo_Request_Referer,
		"UserAgent": __ptrTo_Request_UserAgent,
	}}

	members_PtrTo_Response = GoTypeInfo{Members: GoMembers{
		"Cookies": __ptrTo_Response_Cookies,
		"Location": __ptrTo_Response_Location,
		"ProtoAtLeast": __ptrTo_Response_ProtoAtLeast,
	}}

	members_PtrTo_Server = GoTypeInfo{Members: GoMembers{
		"Close": __ptrTo_Server_Close,
		"ListenAndServe": __ptrTo_Server_ListenAndServe,
		"ListenAndServeTLS": __ptrTo_Server_ListenAndServeTLS,
	}}

	GoTypes[_reflect.TypeOf((*_http.Client)(nil))] = &members_PtrTo_Client
	GoTypes[_reflect.TypeOf((*_http.ConnState)(nil)).Elem()] = &members_ConnState
	GoTypes[_reflect.TypeOf((*_http.Cookie)(nil))] = &members_PtrTo_Cookie
	GoTypes[_reflect.TypeOf((*_http.Dir)(nil)).Elem()] = &members_Dir
	GoTypes[_reflect.TypeOf((*_http.Header)(nil)).Elem()] = &members_Header
	GoTypes[_reflect.TypeOf((*_http.ProtocolError)(nil))] = &members_PtrTo_ProtocolError
	GoTypes[_reflect.TypeOf((*_http.Request)(nil))] = &members_PtrTo_Request
	GoTypes[_reflect.TypeOf((*_http.Response)(nil))] = &members_PtrTo_Response
	GoTypes[_reflect.TypeOf((*_http.Server)(nil))] = &members_PtrTo_Server
}
