// This file is generated by generate-std.joke script. Do not edit manually!

package url

import (
	. "github.com/candid82/joker/core"
	"net/url"
)

var urlNamespace = GLOBAL_ENV.EnsureNamespace(MakeSymbol("go.std.net.url"))



var Error_ Proc

func __Error_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		_v := ExtractObject(_args, 0)
		_res := _ConstructError(_v)
		return MakeGoObject(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var EscapeError_ Proc

func __EscapeError_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		_v := ExtractObject(_args, 0)
		_res := _ConstructEscapeError(_v)
		return MakeGoObject(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var InvalidHostError_ Proc

func __InvalidHostError_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		_v := ExtractObject(_args, 0)
		_res := _ConstructInvalidHostError(_v)
		return MakeGoObject(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var Parse_ Proc

func __Parse_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		__rawurl := ExtractString(_args, 0)
		_res := __parse(__rawurl)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var ParseQuery_ Proc

func __ParseQuery_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		__query := ExtractString(_args, 0)
		_res := __parseQuery(__query)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var ParseRequestURI_ Proc

func __ParseRequestURI_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		__rawurl := ExtractString(_args, 0)
		_res := __parseRequestURI(__rawurl)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var PathEscape_ Proc

func __PathEscape_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		__s := ExtractString(_args, 0)
		_res := url.PathEscape(__s)
		return MakeString(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var PathUnescape_ Proc

func __PathUnescape_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		__s := ExtractString(_args, 0)
		_res := __pathUnescape(__s)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var QueryEscape_ Proc

func __QueryEscape_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		__s := ExtractString(_args, 0)
		_res := url.QueryEscape(__s)
		return MakeString(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

var QueryUnescape_ Proc

func __QueryUnescape_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		__s := ExtractString(_args, 0)
		_res := __queryUnescape(__s)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var User_ Proc

func __User_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		__username := ExtractString(_args, 0)
		_res := __user(__username)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var UserPassword_ Proc

func __UserPassword_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 2:
		__username := ExtractString(_args, 0)
		__password := ExtractString(_args, 1)
		_res := __userPassword(__username, __password)
		return _res

	default:
		PanicArity(_c)
	}
	return NIL
}

var Userinfo_ Proc

func __Userinfo_(_args []Object) Object {
	_c := len(_args)
	switch {
	case _c == 1:
		_v := ExtractObject(_args, 0)
		_res := _ConstructUserinfo(_v)
		return MakeGoObject(_res)

	default:
		PanicArity(_c)
	}
	return NIL
}

func Init() {

	Error_ = __Error_
	EscapeError_ = __EscapeError_
	InvalidHostError_ = __InvalidHostError_
	Parse_ = __Parse_
	ParseQuery_ = __ParseQuery_
	ParseRequestURI_ = __ParseRequestURI_
	PathEscape_ = __PathEscape_
	PathUnescape_ = __PathUnescape_
	QueryEscape_ = __QueryEscape_
	QueryUnescape_ = __QueryUnescape_
	User_ = __User_
	UserPassword_ = __UserPassword_
	Userinfo_ = __Userinfo_

	initNative()

	urlNamespace.ResetMeta(MakeMeta(nil, `Provides a low-level interface to the net/url package.

Package url parses URLs and implements query escaping.
`, "1.0"))

	
	urlNamespace.InternVar("Error.", Error_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("_v"))),
			`Constructor for url.Error`, "1.0"))

	urlNamespace.InternVar("EscapeError.", EscapeError_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("_v"))),
			`Constructor for url.EscapeError`, "1.0"))

	urlNamespace.InternVar("InvalidHostError.", InvalidHostError_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("_v"))),
			`Constructor for url.InvalidHostError`, "1.0"))

	urlNamespace.InternVar("Parse", Parse_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__rawurl"))),
			`Parse parses rawurl into a URL structure.

The rawurl may be relative (a path, without a host) or absolute
(starting with a scheme). Trying to parse a hostname and path
without a scheme is invalid but may not necessarily return an
error, due to parsing ambiguities.

Go input arguments: (rawurl string)

Go return type: (*URL, error)

Joker input arguments: [^String rawurl]

Joker return type: [(atom-of go.std.net.url/URL) Error]`, "1.0"))

	urlNamespace.InternVar("ParseQuery", ParseQuery_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__query"))),
			`ParseQuery parses the URL-encoded query string and returns
a map listing the values specified for each key.
ParseQuery always returns a non-nil map containing all the
valid query parameters found; err describes the first decoding error
encountered, if any.

Query is expected to be a list of key=value settings separated by
ampersands or semicolons. A setting without an equals sign is
interpreted as a key set to an empty value.

Go input arguments: (query string)

Go return type: (Values, error)

Joker input arguments: [^String query]

Joker return type: [go.std.net.url/Values Error]`, "1.0"))

	urlNamespace.InternVar("ParseRequestURI", ParseRequestURI_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__rawurl"))),
			`ParseRequestURI parses rawurl into a URL structure. It assumes that
rawurl was received in an HTTP request, so the rawurl is interpreted
only as an absolute URI or an absolute path.
The string rawurl is assumed not to have a #fragment suffix.
(Web browsers strip #fragment before sending the URL to a web server.)

Go input arguments: (rawurl string)

Go return type: (*URL, error)

Joker input arguments: [^String rawurl]

Joker return type: [(atom-of go.std.net.url/URL) Error]`, "1.0"))

	urlNamespace.InternVar("PathEscape", PathEscape_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__s"))),
			`PathEscape escapes the string so it can be safely placed
inside a URL path segment.

Go input arguments: (s string)

Go return type: string

Joker input arguments: [^String s]

Joker return type: String`, "1.0"))

	urlNamespace.InternVar("PathUnescape", PathUnescape_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__s"))),
			`PathUnescape does the inverse transformation of PathEscape,
converting each 3-byte encoded substring of the form "%AB" into the
hex-decoded byte 0xAB. It returns an error if any % is not followed
by two hexadecimal digits.

PathUnescape is identical to QueryUnescape except that it does not
unescape '+' to ' ' (space).

Go input arguments: (s string)

Go return type: (string, error)

Joker input arguments: [^String s]

Joker return type: [String Error]`, "1.0"))

	urlNamespace.InternVar("QueryEscape", QueryEscape_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__s"))),
			`QueryEscape escapes the string so it can be safely placed
inside a URL query.

Go input arguments: (s string)

Go return type: string

Joker input arguments: [^String s]

Joker return type: String`, "1.0"))

	urlNamespace.InternVar("QueryUnescape", QueryUnescape_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__s"))),
			`QueryUnescape does the inverse transformation of QueryEscape,
converting each 3-byte encoded substring of the form "%AB" into the
hex-decoded byte 0xAB.
It returns an error if any % is not followed by two hexadecimal
digits.

Go input arguments: (s string)

Go return type: (string, error)

Joker input arguments: [^String s]

Joker return type: [String Error]`, "1.0"))

	urlNamespace.InternVar("User", User_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__username"))),
			`User returns a Userinfo containing the provided username
and no password set.

Go input arguments: (username string)

Go return type: *Userinfo

Joker input arguments: [^String username]

Joker return type: (atom-of go.std.net.url/Userinfo)`, "1.0"))

	urlNamespace.InternVar("UserPassword", UserPassword_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("__username"), MakeSymbol("__password"))),
			`UserPassword returns a Userinfo containing the provided username
and password.

This functionality should only be used with legacy web sites.
RFC 2396 warns that interpreting Userinfo this way
` + "`" + `` + "`" + `is NOT RECOMMENDED, because the passing of authentication
information in clear text (such as URI) has proven to be a
security risk in almost every case where it has been used.''

Go input arguments: (username string, password string)

Go return type: *Userinfo

Joker input arguments: [^String username, ^String password]

Joker return type: (atom-of go.std.net.url/Userinfo)`, "1.0"))

	urlNamespace.InternVar("Userinfo.", Userinfo_,
		MakeMeta(
			NewListFrom(NewVectorFrom(MakeSymbol("_v"))),
			`Constructor for url.Userinfo`, "1.0"))

}

func init() {
	urlNamespace.Lazy = Init
}
