// Auto-generated by gostd at 2019-09-17T13:14:28.216621211-04:00 by version 0.1, do not edit!!

package url

import (
	_errors "errors"
	"fmt"
	. "github.com/candid82/joker/core"
	_url "net/url"
	_reflect "reflect"
)

func ExtractGoObjectError(args []Object, index int) *_url.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.Error:
			return &r
		case *_url.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Error]"))
}

func _mapToError(o Map) *_url.Error {
	return &_url.Error{}
}

func _vectorToError(o *Vector) *_url.Error {
	return &_url.Error{
		Op: AssertString(o.Nth(0), "").S,
		URL: AssertString(o.Nth(1), "").S,
		Err: _errors.New(AssertString(o.Nth(2), "").S),
	}
}

func _ConstructError(_v Object) *_url.Error {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _url.Error:
			return &_g
		case *_url.Error:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToError(_o.(Map))
	case *Vector:
		return _vectorToError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Error] or: Map or Vector"))
}

func ExtractGo_go_std_net_url__Error(rcvr, arg string, args *ArraySeq, n int) (res _url.Error) {
	a := CheckGoNth(rcvr, "go.std.net.url/Error", arg, args, n).O
	res, ok := a.(_url.Error)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.url/Error], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectEscapeError(args []Object, index int) *_url.EscapeError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.EscapeError:
			return &r
		case *_url.EscapeError:
			return r
		}
	case String:
		v := _url.EscapeError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.EscapeError]"))
}

func _ConstructEscapeError(_v Object) _url.EscapeError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _url.EscapeError:
			return _g
		case *_url.EscapeError:
			return *_g
		}
	case String:
		return _url.EscapeError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.EscapeError] or: String"))
}

func ExtractGo_go_std_net_url__EscapeError(rcvr, arg string, args *ArraySeq, n int) (res _url.EscapeError) {
	a := CheckGoNth(rcvr, "go.std.net.url/EscapeError", arg, args, n).O
	res, ok := a.(_url.EscapeError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.url/EscapeError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectInvalidHostError(args []Object, index int) *_url.InvalidHostError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.InvalidHostError:
			return &r
		case *_url.InvalidHostError:
			return r
		}
	case String:
		v := _url.InvalidHostError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.InvalidHostError]"))
}

func _ConstructInvalidHostError(_v Object) _url.InvalidHostError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _url.InvalidHostError:
			return _g
		case *_url.InvalidHostError:
			return *_g
		}
	case String:
		return _url.InvalidHostError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.InvalidHostError] or: String"))
}

func ExtractGo_go_std_net_url__InvalidHostError(rcvr, arg string, args *ArraySeq, n int) (res _url.InvalidHostError) {
	a := CheckGoNth(rcvr, "go.std.net.url/InvalidHostError", arg, args, n).O
	res, ok := a.(_url.InvalidHostError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.url/InvalidHostError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectURL(args []Object, index int) *_url.URL {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.URL:
			return &r
		case *_url.URL:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.URL]"))
}

// func _mapToURL(o Map) *_url.URL {
// 	return &_url.URL{}
// }

// func _vectorToURL(o *Vector) *_url.URL {
// 	return &_url.URL{
// 		Scheme: AssertString(o.Nth(0), "").S,
// 		Opaque: AssertString(o.Nth(1), "").S,
// 		User: ABEND048(codegen.go: no conversion from Clojure for *net/url.Userinfo (net/url.Userinfo)),
// 		Host: AssertString(o.Nth(3), "").S,
// 		Path: AssertString(o.Nth(4), "").S,
// 		RawPath: AssertString(o.Nth(5), "").S,
// 		ForceQuery: ToBool(o.Nth(6)),
// 		RawQuery: AssertString(o.Nth(7), "").S,
// 		Fragment: AssertString(o.Nth(8), "").S,
// 	}
// }

// func _ConstructURL(_v Object) *_url.URL {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _url.URL:
// 			return &_g
// 		case *_url.URL:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToURL(_o.(Map))
// 	case *Vector:
// 		return _vectorToURL(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[url.URL] or: Map or Vector"))
// }

func ExtractGo_go_std_net_url__URL(rcvr, arg string, args *ArraySeq, n int) (res _url.URL) {
	a := CheckGoNth(rcvr, "go.std.net.url/URL", arg, args, n).O
	res, ok := a.(_url.URL)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.url/URL], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectUserinfo(args []Object, index int) *_url.Userinfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.Userinfo:
			return &r
		case *_url.Userinfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Userinfo]"))
}

func _mapToUserinfo(o Map) *_url.Userinfo {
	return &_url.Userinfo{}
}

func _vectorToUserinfo(o *Vector) *_url.Userinfo {
	return &_url.Userinfo{}
}

func _ConstructUserinfo(_v Object) *_url.Userinfo {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _url.Userinfo:
			return &_g
		case *_url.Userinfo:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUserinfo(_o.(Map))
	case *Vector:
		return _vectorToUserinfo(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Userinfo] or: Map or Vector"))
}

func ExtractGo_go_std_net_url__Userinfo(rcvr, arg string, args *ArraySeq, n int) (res _url.Userinfo) {
	a := CheckGoNth(rcvr, "go.std.net.url/Userinfo", arg, args, n).O
	res, ok := a.(_url.Userinfo)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.url/Userinfo], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectValues(args []Object, index int) *_url.Values {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.Values:
			return &r
		case *_url.Values:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Values]"))
}

// func _ConstructValues(_v Object) _url.Values {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _url.Values:
// 			return _g
// 		case *_url.Values:
// 			return *_g
// 		}
// 	default:
// 		return _url.Values(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for Values))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Values] or: whatever"))
// }

func ExtractGo_go_std_net_url__Values(rcvr, arg string, args *ArraySeq, n int) (res _url.Values) {
	a := CheckGoNth(rcvr, "go.std.net.url/Values", arg, args, n).O
	res, ok := a.(_url.Values)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.url/Values], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func __parse(__rawurl string) Object {
	_res1, _res2 := _url.Parse(__rawurl)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __parseQuery(__query string) Object {
	_res1, _res2 := _url.ParseQuery(__query)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __parseRequestURI(__rawurl string) Object {
	_res1, _res2 := _url.ParseRequestURI(__rawurl)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __pathUnescape(__s string) Object {
	_res1, _res2 := _url.PathUnescape(__s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __queryUnescape(__s string) Object {
	_res1, _res2 := _url.QueryUnescape(__s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __user(__username string) Object {
	_res := _url.User(__username)
	return MakeGoObject(_res)
}

func __userPassword(__username string, __password string) Object {
	_res := _url.UserPassword(__username, __password)
	return MakeGoObject(_res)
}

func __escapeError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_net/url.EscapeError)Error()", args, 0, 0)
	_res := o.O.(_url.EscapeError).Error()
	return MakeString(_res)
}

func __invalidHostError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_net/url.InvalidHostError)Error()", args, 0, 0)
	_res := o.O.(_url.InvalidHostError).Error()
	return MakeString(_res)
}

func __ptrTo_Error_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.Error)Error()", args, 0, 0)
	_res := o.O.(*_url.Error).Error()
	return MakeString(_res)
}

func __ptrTo_Error_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.Error)Temporary()", args, 0, 0)
	_res := o.O.(*_url.Error).Temporary()
	return MakeBoolean(_res)
}

func __ptrTo_Error_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.Error)Timeout()", args, 0, 0)
	_res := o.O.(*_url.Error).Timeout()
	return MakeBoolean(_res)
}

func __ptrTo_URL_EscapedPath(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)EscapedPath()", args, 0, 0)
	_res := o.O.(*_url.URL).EscapedPath()
	return MakeString(_res)
}

func __ptrTo_URL_Hostname(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)Hostname()", args, 0, 0)
	_res := o.O.(*_url.URL).Hostname()
	return MakeString(_res)
}

func __ptrTo_URL_IsAbs(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)IsAbs()", args, 0, 0)
	_res := o.O.(*_url.URL).IsAbs()
	return MakeBoolean(_res)
}

func __ptrTo_URL_MarshalBinary(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)MarshalBinary()", args, 0, 0)
	text, err := o.O.(*_url.URL).MarshalBinary()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range text {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

func __ptrTo_URL_Parse(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/url.URL)Parse()", args, 1, 1)
	__ref := ExtractGoString("(*_net/url.URL)Parse()", "__ref", _argList, 0)
	_res1, _res2 := o.O.(*_url.URL).Parse(__ref)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __ptrTo_URL_Port(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)Port()", args, 0, 0)
	_res := o.O.(*_url.URL).Port()
	return MakeString(_res)
}

func __ptrTo_URL_Query(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)Query()", args, 0, 0)
	_res := o.O.(*_url.URL).Query()
	return MakeGoObject(_res)
}

func __ptrTo_URL_RequestURI(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)RequestURI()", args, 0, 0)
	_res := o.O.(*_url.URL).RequestURI()
	return MakeString(_res)
}

// func __ptrTo_URL_ResolveReference(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_net/url.URL)ResolveReference()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for __ref at: /usr/local/go/src/net/url/url.go:1002:36)
// 	_res := o.O.(*_url.URL).ResolveReference(__ref)
// 	return MakeGoObject(_res)
// }

func __ptrTo_URL_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)String()", args, 0, 0)
	_res := o.O.(*_url.URL).String()
	return MakeString(_res)
}

// func __ptrTo_URL_UnmarshalBinary(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__text)))}

func __ptrTo_Userinfo_Password(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.Userinfo)Password()", args, 0, 0)
	_res1, _res2 := o.O.(*_url.Userinfo).Password()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(MakeBoolean(_res2))
	return _res
}

func __ptrTo_Userinfo_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.Userinfo)String()", args, 0, 0)
	_res := o.O.(*_url.Userinfo).String()
	return MakeString(_res)
}

func __ptrTo_Userinfo_Username(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.Userinfo)Username()", args, 0, 0)
	_res := o.O.(*_url.Userinfo).Username()
	return MakeString(_res)
}

// func __values_Add(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// func __values_Del(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

func __values_Encode(o GoObject, args Object) Object {
	CheckGoArity("(_net/url.Values)Encode()", args, 0, 0)
	_res := o.O.(_url.Values).Encode()
	return MakeString(_res)
}

func __values_Get(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net/url.Values)Get()", args, 1, 1)
	__key := ExtractGoString("(_net/url.Values)Get()", "__key", _argList, 0)
	_res := o.O.(_url.Values).Get(__key)
	return MakeString(_res)
}

// func __values_Set(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }
var members_PtrTo_Error GoTypeInfo
var members_EscapeError GoTypeInfo
var members_InvalidHostError GoTypeInfo
var members_PtrTo_URL GoTypeInfo
var members_PtrTo_Userinfo GoTypeInfo
var members_Values GoTypeInfo

func initNative() {
	members_PtrTo_Error = GoTypeInfo{Members: GoMembers{
		"Error": __ptrTo_Error_Error,
		"Temporary": __ptrTo_Error_Temporary,
		"Timeout": __ptrTo_Error_Timeout,
	}}

	members_EscapeError = GoTypeInfo{Members: GoMembers{
		"Error": __escapeError_Error,
	}}

	members_InvalidHostError = GoTypeInfo{Members: GoMembers{
		"Error": __invalidHostError_Error,
	}}

	members_PtrTo_URL = GoTypeInfo{Members: GoMembers{
		"EscapedPath": __ptrTo_URL_EscapedPath,
		"Hostname": __ptrTo_URL_Hostname,
		"IsAbs": __ptrTo_URL_IsAbs,
		"MarshalBinary": __ptrTo_URL_MarshalBinary,
		"Parse": __ptrTo_URL_Parse,
		"Port": __ptrTo_URL_Port,
		"Query": __ptrTo_URL_Query,
		"RequestURI": __ptrTo_URL_RequestURI,
		"String": __ptrTo_URL_String,
	}}

	members_PtrTo_Userinfo = GoTypeInfo{Members: GoMembers{
		"Password": __ptrTo_Userinfo_Password,
		"String": __ptrTo_Userinfo_String,
		"Username": __ptrTo_Userinfo_Username,
	}}

	members_Values = GoTypeInfo{Members: GoMembers{
		"Encode": __values_Encode,
		"Get": __values_Get,
	}}

	GoTypes[_reflect.TypeOf((*_url.Error)(nil))] = &members_PtrTo_Error
	GoTypes[_reflect.TypeOf((*_url.EscapeError)(nil)).Elem()] = &members_EscapeError
	GoTypes[_reflect.TypeOf((*_url.InvalidHostError)(nil)).Elem()] = &members_InvalidHostError
	GoTypes[_reflect.TypeOf((*_url.URL)(nil))] = &members_PtrTo_URL
	GoTypes[_reflect.TypeOf((*_url.Userinfo)(nil))] = &members_PtrTo_Userinfo
	GoTypes[_reflect.TypeOf((*_url.Values)(nil)).Elem()] = &members_Values
}
