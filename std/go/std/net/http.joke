;;;; Auto-generated by gostd at 2019-09-17T13:14:28.216621211-04:00 by version 0.1, do not edit!!

(ns
  ^{:go-imports ["net/http"]
    :doc "Provides a low-level interface to the net/http package.\n\nPackage http provides HTTP client and server implementations.\n\nGet, Head, Post, and PostForm make HTTP (or HTTPS) requests:\n\n\tresp, err := http.Get(\"http://example.com/\")\n\t...\n\tresp, err := http.Post(\"http://example.com/upload\", \"image/jpeg\", &buf)\n\t...\n\tresp, err := http.PostForm(\"http://example.com/form\",\n\t\turl.Values{\"key\": {\"Value\"}, \"id\": {\"123\"}})\n\nThe client must close the response body when finished with it:\n\n\tresp, err := http.Get(\"http://example.com/\")\n\tif err != nil {\n\t\t// handle error\n\t}\n\tdefer resp.Body.Close()\n\tbody, err := ioutil.ReadAll(resp.Body)\n\t// ...\n\nFor control over HTTP client headers, redirect policy, and other\nsettings, create a Client:\n\n\tclient := &http.Client{\n\t\tCheckRedirect: redirectPolicyFunc,\n\t}\n\n\tresp, err := client.Get(\"http://example.com\")\n\t// ...\n\n\treq, err := http.NewRequest(\"GET\", \"http://example.com\", nil)\n\t// ...\n\treq.Header.Add(\"If-None-Match\", `W/\"wyzzy\"`)\n\tresp, err := client.Do(req)\n\t// ...\n\nFor control over proxies, TLS configuration, keep-alives,\ncompression, and other settings, create a Transport:\n\n\ttr := &http.Transport{\n\t\tMaxIdleConns:       10,\n\t\tIdleConnTimeout:    30 * time.Second,\n\t\tDisableCompression: true,\n\t}\n\tclient := &http.Client{Transport: tr}\n\tresp, err := client.Get(\"https://example.com\")\n\nClients and Transports are safe for concurrent use by multiple\ngoroutines and for efficiency should only be created once and re-used.\n\nListenAndServe starts an HTTP server with a given address and handler.\nThe handler is usually nil, which means to use DefaultServeMux.\nHandle and HandleFunc add handlers to DefaultServeMux:\n\n\thttp.Handle(\"/foo\", fooHandler)\n\n\thttp.HandleFunc(\"/bar\", func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintf(w, \"Hello, %q\", html.EscapeString(r.URL.Path))\n\t})\n\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n\nMore control over the server's behavior is available by creating a\ncustom Server:\n\n\ts := &http.Server{\n\t\tAddr:           \":8080\",\n\t\tHandler:        myHandler,\n\t\tReadTimeout:    10 * time.Second,\n\t\tWriteTimeout:   10 * time.Second,\n\t\tMaxHeaderBytes: 1 << 20,\n\t}\n\tlog.Fatal(s.ListenAndServe())\n\nStarting with Go 1.6, the http package has transparent support for the\nHTTP/2 protocol when using HTTPS. Programs that must disable HTTP/2\ncan do so by setting Transport.TLSNextProto (for clients) or\nServer.TLSNextProto (for servers) to a non-nil, empty\nmap. Alternatively, the following GODEBUG environment variables are\ncurrently supported:\n\n\tGODEBUG=http2client=0  # disable HTTP/2 client support\n\tGODEBUG=http2server=0  # disable HTTP/2 server support\n\tGODEBUG=http2debug=1   # enable verbose HTTP/2 debug logs\n\tGODEBUG=http2debug=2   # ... even more verbose, with frame dumps\n\nThe GODEBUG variables are not covered by Go's API compatibility\npromise. Please report any issues before disabling HTTP/2\nsupport: https://golang.org/s/http2bug\n\nThe http package's Transport and Server both automatically enable\nHTTP/2 support for simple configurations. To enable HTTP/2 for more\ncomplex configurations, to use lower-level HTTP/2 features, or to use\na newer version of Go's http2 package, import \"golang.org/x/net/http2\"\ndirectly and use its ConfigureTransport and/or ConfigureServer\nfunctions. Manually configuring HTTP/2 via the golang.org/x/net/http2\npackage takes precedence over the net/http package's built-in HTTP/2\nsupport.\n"
    :empty false}
  go.std.net.http)

(def
  ^{:doc "1 MB\n"
    :added "1.0"
    :tag Number
    :go "int64(http.DefaultMaxHeaderBytes)"}
  DefaultMaxHeaderBytes)

(def
  ^{:doc "DefaultMaxIdleConnsPerHost is the default value of Transport's\nMaxIdleConnsPerHost.\n"
    :added "1.0"
    :tag Int
    :go "http.DefaultMaxIdleConnsPerHost"}
  DefaultMaxIdleConnsPerHost)

(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag String
    :go "http.MethodConnect"}
  MethodConnect)

(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag String
    :go "http.MethodDelete"}
  MethodDelete)

(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag String
    :go "http.MethodGet"}
  MethodGet)

(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag String
    :go "http.MethodHead"}
  MethodHead)

(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag String
    :go "http.MethodOptions"}
  MethodOptions)

(def
  ^{:doc "RFC 5789\n"
    :added "1.0"
    :tag String
    :go "http.MethodPatch"}
  MethodPatch)

(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag String
    :go "http.MethodPost"}
  MethodPost)

(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag String
    :go "http.MethodPut"}
  MethodPut)

(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag String
    :go "http.MethodTrace"}
  MethodTrace)

(def
  ^{:doc ""
    :added "1.0"
    :tag Int
    :go "int(http.SameSiteDefaultMode)"}
  SameSiteDefaultMode)

(def
  ^{:doc ""
    :added "1.0"
    :tag Int
    :go "int(http.SameSiteLaxMode)"}
  SameSiteLaxMode)

(def
  ^{:doc ""
    :added "1.0"
    :tag Int
    :go "int(http.SameSiteStrictMode)"}
  SameSiteStrictMode)

(def
  ^{:doc "StateActive represents a connection that has read 1 or more\nbytes of a request. The Server.ConnState hook for\nStateActive fires before the request has entered a handler\nand doesn't fire again until the request has been\nhandled. After the request is handled, the state\ntransitions to StateClosed, StateHijacked, or StateIdle.\nFor HTTP/2, StateActive fires on the transition from zero\nto one active request, and only transitions away once all\nactive requests are complete. That means that ConnState\ncannot be used to do per-request work; ConnState only notes\nthe overall state of the connection.\n"
    :added "1.0"
    :tag Int
    :go "int(http.StateActive)"}
  StateActive)

(def
  ^{:doc "StateClosed represents a closed connection.\nThis is a terminal state. Hijacked connections do not\ntransition to StateClosed.\n"
    :added "1.0"
    :tag Int
    :go "int(http.StateClosed)"}
  StateClosed)

(def
  ^{:doc "StateHijacked represents a hijacked connection.\nThis is a terminal state. It does not transition to StateClosed.\n"
    :added "1.0"
    :tag Int
    :go "int(http.StateHijacked)"}
  StateHijacked)

(def
  ^{:doc "StateIdle represents a connection that has finished\nhandling a request and is in the keep-alive state, waiting\nfor a new request. Connections transition from StateIdle\nto either StateActive or StateClosed.\n"
    :added "1.0"
    :tag Int
    :go "int(http.StateIdle)"}
  StateIdle)

(def
  ^{:doc "StateNew represents a new connection that is expected to\nsend a request immediately. Connections begin at this\nstate and then transition to either StateActive or\nStateClosed.\n"
    :added "1.0"
    :tag Int
    :go "int(http.StateNew)"}
  StateNew)

(def
  ^{:doc "RFC 7231, 6.3.3\n"
    :added "1.0"
    :tag Int
    :go "http.StatusAccepted"}
  StatusAccepted)

(def
  ^{:doc "RFC 5842, 7.1\n"
    :added "1.0"
    :tag Int
    :go "http.StatusAlreadyReported"}
  StatusAlreadyReported)

(def
  ^{:doc "RFC 7231, 6.6.3\n"
    :added "1.0"
    :tag Int
    :go "http.StatusBadGateway"}
  StatusBadGateway)

(def
  ^{:doc "RFC 7231, 6.5.1\n"
    :added "1.0"
    :tag Int
    :go "http.StatusBadRequest"}
  StatusBadRequest)

(def
  ^{:doc "RFC 7231, 6.5.8\n"
    :added "1.0"
    :tag Int
    :go "http.StatusConflict"}
  StatusConflict)

(def
  ^{:doc "RFC 7231, 6.2.1\n"
    :added "1.0"
    :tag Int
    :go "http.StatusContinue"}
  StatusContinue)

(def
  ^{:doc "RFC 7231, 6.3.2\n"
    :added "1.0"
    :tag Int
    :go "http.StatusCreated"}
  StatusCreated)

(def
  ^{:doc "RFC 7231, 6.5.14\n"
    :added "1.0"
    :tag Int
    :go "http.StatusExpectationFailed"}
  StatusExpectationFailed)

(def
  ^{:doc "RFC 4918, 11.4\n"
    :added "1.0"
    :tag Int
    :go "http.StatusFailedDependency"}
  StatusFailedDependency)

(def
  ^{:doc "RFC 7231, 6.5.3\n"
    :added "1.0"
    :tag Int
    :go "http.StatusForbidden"}
  StatusForbidden)

(def
  ^{:doc "RFC 7231, 6.4.3\n"
    :added "1.0"
    :tag Int
    :go "http.StatusFound"}
  StatusFound)

(def
  ^{:doc "RFC 7231, 6.6.5\n"
    :added "1.0"
    :tag Int
    :go "http.StatusGatewayTimeout"}
  StatusGatewayTimeout)

(def
  ^{:doc "RFC 7231, 6.5.9\n"
    :added "1.0"
    :tag Int
    :go "http.StatusGone"}
  StatusGone)

(def
  ^{:doc "RFC 7231, 6.6.6\n"
    :added "1.0"
    :tag Int
    :go "http.StatusHTTPVersionNotSupported"}
  StatusHTTPVersionNotSupported)

(def
  ^{:doc "RFC 3229, 10.4.1\n"
    :added "1.0"
    :tag Int
    :go "http.StatusIMUsed"}
  StatusIMUsed)

(def
  ^{:doc "RFC 4918, 11.5\n"
    :added "1.0"
    :tag Int
    :go "http.StatusInsufficientStorage"}
  StatusInsufficientStorage)

(def
  ^{:doc "RFC 7231, 6.6.1\n"
    :added "1.0"
    :tag Int
    :go "http.StatusInternalServerError"}
  StatusInternalServerError)

(def
  ^{:doc "RFC 7231, 6.5.10\n"
    :added "1.0"
    :tag Int
    :go "http.StatusLengthRequired"}
  StatusLengthRequired)

(def
  ^{:doc "RFC 4918, 11.3\n"
    :added "1.0"
    :tag Int
    :go "http.StatusLocked"}
  StatusLocked)

(def
  ^{:doc "RFC 5842, 7.2\n"
    :added "1.0"
    :tag Int
    :go "http.StatusLoopDetected"}
  StatusLoopDetected)

(def
  ^{:doc "RFC 7231, 6.5.5\n"
    :added "1.0"
    :tag Int
    :go "http.StatusMethodNotAllowed"}
  StatusMethodNotAllowed)

(def
  ^{:doc "RFC 7540, 9.1.2\n"
    :added "1.0"
    :tag Int
    :go "http.StatusMisdirectedRequest"}
  StatusMisdirectedRequest)

(def
  ^{:doc "RFC 7231, 6.4.2\n"
    :added "1.0"
    :tag Int
    :go "http.StatusMovedPermanently"}
  StatusMovedPermanently)

(def
  ^{:doc "RFC 4918, 11.1\n"
    :added "1.0"
    :tag Int
    :go "http.StatusMultiStatus"}
  StatusMultiStatus)

(def
  ^{:doc "RFC 7231, 6.4.1\n"
    :added "1.0"
    :tag Int
    :go "http.StatusMultipleChoices"}
  StatusMultipleChoices)

(def
  ^{:doc "RFC 6585, 6\n"
    :added "1.0"
    :tag Int
    :go "http.StatusNetworkAuthenticationRequired"}
  StatusNetworkAuthenticationRequired)

(def
  ^{:doc "RFC 7231, 6.3.5\n"
    :added "1.0"
    :tag Int
    :go "http.StatusNoContent"}
  StatusNoContent)

(def
  ^{:doc "RFC 7231, 6.3.4\n"
    :added "1.0"
    :tag Int
    :go "http.StatusNonAuthoritativeInfo"}
  StatusNonAuthoritativeInfo)

(def
  ^{:doc "RFC 7231, 6.5.6\n"
    :added "1.0"
    :tag Int
    :go "http.StatusNotAcceptable"}
  StatusNotAcceptable)

(def
  ^{:doc "RFC 2774, 7\n"
    :added "1.0"
    :tag Int
    :go "http.StatusNotExtended"}
  StatusNotExtended)

(def
  ^{:doc "RFC 7231, 6.5.4\n"
    :added "1.0"
    :tag Int
    :go "http.StatusNotFound"}
  StatusNotFound)

(def
  ^{:doc "RFC 7231, 6.6.2\n"
    :added "1.0"
    :tag Int
    :go "http.StatusNotImplemented"}
  StatusNotImplemented)

(def
  ^{:doc "RFC 7232, 4.1\n"
    :added "1.0"
    :tag Int
    :go "http.StatusNotModified"}
  StatusNotModified)

(def
  ^{:doc "RFC 7231, 6.3.1\n"
    :added "1.0"
    :tag Int
    :go "http.StatusOK"}
  StatusOK)

(def
  ^{:doc "RFC 7233, 4.1\n"
    :added "1.0"
    :tag Int
    :go "http.StatusPartialContent"}
  StatusPartialContent)

(def
  ^{:doc "RFC 7231, 6.5.2\n"
    :added "1.0"
    :tag Int
    :go "http.StatusPaymentRequired"}
  StatusPaymentRequired)

(def
  ^{:doc "RFC 7538, 3\n"
    :added "1.0"
    :tag Int
    :go "http.StatusPermanentRedirect"}
  StatusPermanentRedirect)

(def
  ^{:doc "RFC 7232, 4.2\n"
    :added "1.0"
    :tag Int
    :go "http.StatusPreconditionFailed"}
  StatusPreconditionFailed)

(def
  ^{:doc "RFC 6585, 3\n"
    :added "1.0"
    :tag Int
    :go "http.StatusPreconditionRequired"}
  StatusPreconditionRequired)

(def
  ^{:doc "RFC 2518, 10.1\n"
    :added "1.0"
    :tag Int
    :go "http.StatusProcessing"}
  StatusProcessing)

(def
  ^{:doc "RFC 7235, 3.2\n"
    :added "1.0"
    :tag Int
    :go "http.StatusProxyAuthRequired"}
  StatusProxyAuthRequired)

(def
  ^{:doc "RFC 7231, 6.5.11\n"
    :added "1.0"
    :tag Int
    :go "http.StatusRequestEntityTooLarge"}
  StatusRequestEntityTooLarge)

(def
  ^{:doc "RFC 6585, 5\n"
    :added "1.0"
    :tag Int
    :go "http.StatusRequestHeaderFieldsTooLarge"}
  StatusRequestHeaderFieldsTooLarge)

(def
  ^{:doc "RFC 7231, 6.5.7\n"
    :added "1.0"
    :tag Int
    :go "http.StatusRequestTimeout"}
  StatusRequestTimeout)

(def
  ^{:doc "RFC 7231, 6.5.12\n"
    :added "1.0"
    :tag Int
    :go "http.StatusRequestURITooLong"}
  StatusRequestURITooLong)

(def
  ^{:doc "RFC 7233, 4.4\n"
    :added "1.0"
    :tag Int
    :go "http.StatusRequestedRangeNotSatisfiable"}
  StatusRequestedRangeNotSatisfiable)

(def
  ^{:doc "RFC 7231, 6.3.6\n"
    :added "1.0"
    :tag Int
    :go "http.StatusResetContent"}
  StatusResetContent)

(def
  ^{:doc "RFC 7231, 6.4.4\n"
    :added "1.0"
    :tag Int
    :go "http.StatusSeeOther"}
  StatusSeeOther)

(def
  ^{:doc "RFC 7231, 6.6.4\n"
    :added "1.0"
    :tag Int
    :go "http.StatusServiceUnavailable"}
  StatusServiceUnavailable)

(def
  ^{:doc "RFC 7231, 6.2.2\n"
    :added "1.0"
    :tag Int
    :go "http.StatusSwitchingProtocols"}
  StatusSwitchingProtocols)

(def
  ^{:doc "RFC 7168, 2.3.3\n"
    :added "1.0"
    :tag Int
    :go "http.StatusTeapot"}
  StatusTeapot)

(def
  ^{:doc "RFC 7231, 6.4.7\n"
    :added "1.0"
    :tag Int
    :go "http.StatusTemporaryRedirect"}
  StatusTemporaryRedirect)

(def
  ^{:doc "RFC 8470, 5.2.\n"
    :added "1.0"
    :tag Int
    :go "http.StatusTooEarly"}
  StatusTooEarly)

(def
  ^{:doc "RFC 6585, 4\n"
    :added "1.0"
    :tag Int
    :go "http.StatusTooManyRequests"}
  StatusTooManyRequests)

(def
  ^{:doc "RFC 7235, 3.1\n"
    :added "1.0"
    :tag Int
    :go "http.StatusUnauthorized"}
  StatusUnauthorized)

(def
  ^{:doc "RFC 7725, 3\n"
    :added "1.0"
    :tag Int
    :go "http.StatusUnavailableForLegalReasons"}
  StatusUnavailableForLegalReasons)

(def
  ^{:doc "RFC 4918, 11.2\n"
    :added "1.0"
    :tag Int
    :go "http.StatusUnprocessableEntity"}
  StatusUnprocessableEntity)

(def
  ^{:doc "RFC 7231, 6.5.13\n"
    :added "1.0"
    :tag Int
    :go "http.StatusUnsupportedMediaType"}
  StatusUnsupportedMediaType)

(def
  ^{:doc "RFC 7231, 6.5.15\n"
    :added "1.0"
    :tag Int
    :go "http.StatusUpgradeRequired"}
  StatusUpgradeRequired)

(def
  ^{:doc "RFC 7231, 6.4.5\n"
    :added "1.0"
    :tag Int
    :go "http.StatusUseProxy"}
  StatusUseProxy)

(def
  ^{:doc "RFC 2295, 8.1\n"
    :added "1.0"
    :tag Int
    :go "http.StatusVariantAlsoNegotiates"}
  StatusVariantAlsoNegotiates)

(def
  ^{:doc "TimeFormat is the time format to use when generating times in HTTP\nheaders. It is like time.RFC1123 but hard-codes GMT as the time\nzone. The time being formatted must be in UTC for Format to\ngenerate the correct format.\n\nFor parsing this time format, see ParseTime.\n"
    :added "1.0"
    :tag String
    :go "http.TimeFormat"}
  TimeFormat)

(def
  ^{:doc "TrailerPrefix is a magic prefix for ResponseWriter.Header map keys\nthat, if present, signals that the map entry is actually for\nthe response trailers, and not the response headers. The prefix\nis stripped after the ServeHTTP call finishes and the values are\nsent in the trailers.\n\nThis mechanism is intended only for trailers that are not known\nprior to the headers being written. If the set of trailers is fixed\nor known before the header is written, the normal Go trailers mechanism\nis preferred:\n   https://golang.org/pkg/net/http/#ResponseWriter\n   https://golang.org/pkg/net/http/#example_ResponseWriter_trailers\n"
    :added "1.0"
    :tag String
    :go "http.TrailerPrefix"}
  TrailerPrefix)

(def
  ^{:doc "DefaultClient is the default Client and is used by Get, Head, and Post.\n"
    :added "1.0"
    :tag Var
    :go "http.DefaultClient"}
  DefaultClient)

(def
  ^{:doc "DefaultServeMux is the default ServeMux used by Serve.\n"
    :added "1.0"
    :tag Var
    :go "http.DefaultServeMux"}
  DefaultServeMux)

(def
  ^{:doc "DefaultTransport is the default implementation of Transport and is\nused by DefaultClient. It establishes network connections as needed\nand caches them for reuse by subsequent calls. It uses HTTP proxies\nas directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and\n$no_proxy) environment variables.\n"
    :added "1.0"
    :tag Var
    :go "http.DefaultTransport"}
  DefaultTransport)

(def
  ^{:doc "ErrAbortHandler is a sentinel panic value to abort a handler.\nWhile any panic from ServeHTTP aborts the response to the client,\npanicking with ErrAbortHandler also suppresses logging of a stack\ntrace to the server's error log.\n"
    :added "1.0"
    :tag Var
    :go "http.ErrAbortHandler"}
  ErrAbortHandler)

(def
  ^{:doc "ErrBodyNotAllowed is returned by ResponseWriter.Write calls\nwhen the HTTP method or response code does not permit a\nbody.\n"
    :added "1.0"
    :tag Var
    :go "http.ErrBodyNotAllowed"}
  ErrBodyNotAllowed)

(def
  ^{:doc "ErrBodyReadAfterClose is returned when reading a Request or Response\nBody after the body has been closed. This typically happens when the body is\nread after an HTTP Handler calls WriteHeader or Write on its\nResponseWriter.\n"
    :added "1.0"
    :tag Var
    :go "http.ErrBodyReadAfterClose"}
  ErrBodyReadAfterClose)

(def
  ^{:doc "ErrContentLength is returned by ResponseWriter.Write calls\nwhen a Handler set a Content-Length response header with a\ndeclared size and then attempted to write more bytes than\ndeclared.\n"
    :added "1.0"
    :tag Var
    :go "http.ErrContentLength"}
  ErrContentLength)

(def
  ^{:doc "ErrHandlerTimeout is returned on ResponseWriter Write calls\nin handlers which have timed out.\n"
    :added "1.0"
    :tag Var
    :go "http.ErrHandlerTimeout"}
  ErrHandlerTimeout)

(def
  ^{:doc "Deprecated: ErrHeaderTooLong is no longer returned by\nanything in the net/http package. Callers should not\ncompare errors against this variable.\n"
    :added "1.0"
    :tag Var
    :go "http.ErrHeaderTooLong"}
  ErrHeaderTooLong)

(def
  ^{:doc "ErrHijacked is returned by ResponseWriter.Write calls when\nthe underlying connection has been hijacked using the\nHijacker interface. A zero-byte write on a hijacked\nconnection will return ErrHijacked without any other side\neffects.\n"
    :added "1.0"
    :tag Var
    :go "http.ErrHijacked"}
  ErrHijacked)

(def
  ^{:doc "ErrLineTooLong is returned when reading request or response bodies\nwith malformed chunked encoding.\n"
    :added "1.0"
    :tag Var
    :go "http.ErrLineTooLong"}
  ErrLineTooLong)

(def
  ^{:doc "ErrMissingBoundary is returned by Request.MultipartReader when the\nrequest's Content-Type does not include a \"boundary\" parameter.\n"
    :added "1.0"
    :tag Var
    :go "http.ErrMissingBoundary"}
  ErrMissingBoundary)

(def
  ^{:doc "Deprecated: ErrMissingContentLength is no longer returned by\nanything in the net/http package. Callers should not\ncompare errors against this variable.\n"
    :added "1.0"
    :tag Var
    :go "http.ErrMissingContentLength"}
  ErrMissingContentLength)

(def
  ^{:doc "ErrMissingFile is returned by FormFile when the provided file field name\nis either not present in the request or not a file field.\n"
    :added "1.0"
    :tag Var
    :go "http.ErrMissingFile"}
  ErrMissingFile)

(def
  ^{:doc "ErrNoCookie is returned by Request's Cookie method when a cookie is not found.\n"
    :added "1.0"
    :tag Var
    :go "http.ErrNoCookie"}
  ErrNoCookie)

(def
  ^{:doc "ErrNoLocation is returned by Response's Location method\nwhen no Location header is present.\n"
    :added "1.0"
    :tag Var
    :go "http.ErrNoLocation"}
  ErrNoLocation)

(def
  ^{:doc "ErrNotMultipart is returned by Request.MultipartReader when the\nrequest's Content-Type is not multipart/form-data.\n"
    :added "1.0"
    :tag Var
    :go "http.ErrNotMultipart"}
  ErrNotMultipart)

(def
  ^{:doc "ErrNotSupported is returned by the Push method of Pusher\nimplementations to indicate that HTTP/2 Push support is not\navailable.\n"
    :added "1.0"
    :tag Var
    :go "http.ErrNotSupported"}
  ErrNotSupported)

(def
  ^{:doc "ErrServerClosed is returned by the Server's Serve, ServeTLS, ListenAndServe,\nand ListenAndServeTLS methods after a call to Shutdown or Close.\n"
    :added "1.0"
    :tag Var
    :go "http.ErrServerClosed"}
  ErrServerClosed)

(def
  ^{:doc "Deprecated: ErrShortBody is no longer returned by\nanything in the net/http package. Callers should not\ncompare errors against this variable.\n"
    :added "1.0"
    :tag Var
    :go "http.ErrShortBody"}
  ErrShortBody)

(def
  ^{:doc "ErrSkipAltProtocol is a sentinel error value defined by Transport.RegisterProtocol.\n"
    :added "1.0"
    :tag Var
    :go "http.ErrSkipAltProtocol"}
  ErrSkipAltProtocol)

(def
  ^{:doc "Deprecated: ErrUnexpectedTrailer is no longer returned by\nanything in the net/http package. Callers should not\ncompare errors against this variable.\n"
    :added "1.0"
    :tag Var
    :go "http.ErrUnexpectedTrailer"}
  ErrUnexpectedTrailer)

(def
  ^{:doc "ErrUseLastResponse can be returned by Client.CheckRedirect hooks to\ncontrol how redirects are processed. If returned, the next request\nis not sent and the most recent response is returned with its body\nunclosed.\n"
    :added "1.0"
    :tag Var
    :go "http.ErrUseLastResponse"}
  ErrUseLastResponse)

(def
  ^{:doc "Deprecated: ErrWriteAfterFlush is no longer returned by\nanything in the net/http package. Callers should not\ncompare errors against this variable.\n"
    :added "1.0"
    :tag Var
    :go "http.ErrWriteAfterFlush"}
  ErrWriteAfterFlush)

(def
  ^{:doc "LocalAddrContextKey is a context key. It can be used in\nHTTP handlers with context.WithValue to access the local\naddress the connection arrived on.\nThe associated value will be of type net.Addr.\n"
    :added "1.0"
    :tag Var
    :go "http.LocalAddrContextKey"}
  LocalAddrContextKey)

(def
  ^{:doc "NoBody is an io.ReadCloser with no bytes. Read always returns EOF\nand Close always returns nil. It can be used in an outgoing client\nrequest to explicitly signal that a request has zero bytes.\nAn alternative, however, is to simply set Request.Body to nil.\n"
    :added "1.0"
    :tag Var
    :go "http.NoBody"}
  NoBody)

(def
  ^{:doc "ServerContextKey is a context key. It can be used in HTTP\nhandlers with context.WithValue to access the server that\nstarted the handler. The associated value will be of\ntype *Server.\n"
    :added "1.0"
    :tag Var
    :go "http.ServerContextKey"}
  ServerContextKey)

;; (defn ^"GoObject" Client.
;;   "Constructor for http.Client"
;;   {:added "1.0"
;;    :go "_ConstructClient(_v)"}
;;   [^Object _v])

;; (defn ^"GoObject" CloseNotifier.
;;   "Constructor for http.CloseNotifier"
;;   {:added "1.0"
;;    :go "_ConstructCloseNotifier(_v)"}
;;   [^Object _v])

(defn ^"GoObject" ConnState.
  "Constructor for http.ConnState"
  {:added "1.0"
   :go "_ConstructConnState(_v)"}
  [^Object _v])

;; (defn ^"GoObject" Cookie.
;;   "Constructor for http.Cookie"
;;   {:added "1.0"
;;    :go "_ConstructCookie(_v)"}
;;   [^Object _v])

;; (defn ^"GoObject" CookieJar.
;;   "Constructor for http.CookieJar"
;;   {:added "1.0"
;;    :go "_ConstructCookieJar(_v)"}
;;   [^Object _v])

(defn ^"GoObject" Dir.
  "Constructor for http.Dir"
  {:added "1.0"
   :go "_ConstructDir(_v)"}
  [^Object _v])

;; (defn ^"GoObject" File.
;;   "Constructor for http.File"
;;   {:added "1.0"
;;    :go "_ConstructFile(_v)"}
;;   [^Object _v])

;; (defn ^"GoObject" FileSystem.
;;   "Constructor for http.FileSystem"
;;   {:added "1.0"
;;    :go "_ConstructFileSystem(_v)"}
;;   [^Object _v])

;; (defn ^"GoObject" Flusher.
;;   "Constructor for http.Flusher"
;;   {:added "1.0"
;;    :go "_ConstructFlusher(_v)"}
;;   [^Object _v])

;; (defn ^"GoObject" Handler.
;;   "Constructor for http.Handler"
;;   {:added "1.0"
;;    :go "_ConstructHandler(_v)"}
;;   [^Object _v])

;; (defn ^"GoObject" HandlerFunc.
;;   "Constructor for http.HandlerFunc"
;;   {:added "1.0"
;;    :go "_ConstructHandlerFunc(_v)"}
;;   [^Object _v])

;; (defn ^"GoObject" Header.
;;   "Constructor for http.Header"
;;   {:added "1.0"
;;    :go "_ConstructHeader(_v)"}
;;   [^Object _v])

;; (defn ^"GoObject" Hijacker.
;;   "Constructor for http.Hijacker"
;;   {:added "1.0"
;;    :go "_ConstructHijacker(_v)"}
;;   [^Object _v])

(defn ^"GoObject" ProtocolError.
  "Constructor for http.ProtocolError"
  {:added "1.0"
   :go "_ConstructProtocolError(_v)"}
  [^Object _v])

;; (defn ^"GoObject" PushOptions.
;;   "Constructor for http.PushOptions"
;;   {:added "1.0"
;;    :go "_ConstructPushOptions(_v)"}
;;   [^Object _v])

;; (defn ^"GoObject" Pusher.
;;   "Constructor for http.Pusher"
;;   {:added "1.0"
;;    :go "_ConstructPusher(_v)"}
;;   [^Object _v])

;; (defn ^"GoObject" Request.
;;   "Constructor for http.Request"
;;   {:added "1.0"
;;    :go "_ConstructRequest(_v)"}
;;   [^Object _v])

;; (defn ^"GoObject" Response.
;;   "Constructor for http.Response"
;;   {:added "1.0"
;;    :go "_ConstructResponse(_v)"}
;;   [^Object _v])

;; (defn ^"GoObject" ResponseWriter.
;;   "Constructor for http.ResponseWriter"
;;   {:added "1.0"
;;    :go "_ConstructResponseWriter(_v)"}
;;   [^Object _v])

;; (defn ^"GoObject" RoundTripper.
;;   "Constructor for http.RoundTripper"
;;   {:added "1.0"
;;    :go "_ConstructRoundTripper(_v)"}
;;   [^Object _v])

(defn ^"GoObject" SameSite.
  "Constructor for http.SameSite"
  {:added "1.0"
   :go "_ConstructSameSite(_v)"}
  [^Object _v])

(defn ^"GoObject" ServeMux.
  "Constructor for http.ServeMux"
  {:added "1.0"
   :go "_ConstructServeMux(_v)"}
  [^Object _v])

;; (defn ^"GoObject" Server.
;;   "Constructor for http.Server"
;;   {:added "1.0"
;;    :go "_ConstructServer(_v)"}
;;   [^Object _v])

;; (defn ^"GoObject" Transport.
;;   "Constructor for http.Transport"
;;   {:added "1.0"
;;    :go "_ConstructTransport(_v)"}
;;   [^Object _v])

(defn ^"String" CanonicalHeaderKey
  "CanonicalHeaderKey returns the canonical format of the\nheader key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.CanonicalHeaderKey(__s)"}
  [^String __s])

;; (defn ^"String" DetectContentType
;;   "DetectContentType implements the algorithm described\nat https://mimesniff.spec.whatwg.org/ to determine the\nContent-Type of the given data. It considers at most the\nfirst 512 bytes of data. DetectContentType always returns\na valid MIME type: if it cannot determine a more specific one, it\nreturns \"application/octet-stream\".\n\nGo input arguments: (data []byte)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "http.DetectContentType(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)))"}
;;   [^Object __data])

;; (defn Error
;;   "Error replies to the request with the specified error message and HTTP code.\nIt does not otherwise end the request; the caller should ensure no further\nwrites are done to w.\nThe error message should be plain text.\n\nGo input arguments: (w ResponseWriter, error string, code int)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^String error, ^Int code]"
;;   {:added "1.0"
;;    :go "__error(*__w, __error, __code)"}
;;   [^http/ResponseWriter __w, ^String __error, ^Int __code])

(defn FileServer
  "FileServer returns a handler that serves HTTP requests\nwith the contents of the file system rooted at root.\n\nTo use the operating system's file system implementation,\nuse http.Dir:\n\n    http.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))\n\nAs a special case, the returned file server redirects any request\nending in \"/index.html\" to the same path, without the final\n\"index.html\".\n\nGo input arguments: (root FileSystem)\n\nGo return type: Handler\n\nJoker input arguments: [^go.std.net.http/FileSystem root]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__fileServer(*__root)"}
  [^http/FileSystem __root])

(defn Get
  "Get issues a GET to the specified URL. If the response is one of\nthe following redirect codes, Get follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nAn error is returned if there were too many redirects or if there\nwas an HTTP protocol error. A non-2xx response doesn't cause an\nerror. Any returned error will be of type *url.Error. The url.Error\nvalue's Timeout method will report true if request timed out or was\ncanceled.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nGet is a wrapper around DefaultClient.Get.\n\nTo make a request with custom headers, use NewRequest and\nDefaultClient.Do.\n\nGo input arguments: (url string)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
  {:added "1.0"
   :go "__get(__url)"}
  [^String __url])

;; (defn Handle
;;   "Handle registers the handler for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler Handler)\n\nJoker input arguments: [^String pattern, ^go.std.net.http/Handler handler]"
;;   {:added "1.0"
;;    :go "__handle(__pattern, *__handler)"}
;;   [^String __pattern, ^http/Handler __handler])

;; (defn HandleFunc
;;   "HandleFunc registers the handler function for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler func)\n\nJoker input arguments: [^String pattern, ^fn handler]"
;;   {:added "1.0"
;;    :go "__handleFunc(__pattern, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String __pattern, ^fn __handler])

(defn Head
  "Head issues a HEAD to the specified URL. If the response is one of\nthe following redirect codes, Head follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nHead is a wrapper around DefaultClient.Head\n\nGo input arguments: (url string)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
  {:added "1.0"
   :go "__head(__url)"}
  [^String __url])

(defn ^"Error" ListenAndServe
  "ListenAndServe listens on the TCP network address addr and then calls\nServe with handler to handle requests on incoming connections.\nAccepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error.\n\nGo input arguments: (addr string, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
  {:added "1.0"
   :go "http.ListenAndServe(__addr, *__handler)"}
  [^String __addr, ^http/Handler __handler])

(defn ^"Error" ListenAndServeTLS
  "ListenAndServeTLS acts identically to ListenAndServe, except that it\nexpects HTTPS connections. Additionally, files containing a certificate and\nmatching private key for the server must be provided. If the certificate\nis signed by a certificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nGo input arguments: (addr string, certFile string, keyFile string, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^String certFile, ^String keyFile, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
  {:added "1.0"
   :go "http.ListenAndServeTLS(__addr, __certFile, __keyFile, *__handler)"}
  [^String __addr, ^String __certFile, ^String __keyFile, ^http/Handler __handler])

;; (defn MaxBytesReader
;;   "MaxBytesReader is similar to io.LimitReader but is intended for\nlimiting the size of incoming request bodies. In contrast to\nio.LimitReader, MaxBytesReader's result is a ReadCloser, returns a\nnon-EOF error for a Read beyond the limit, and closes the\nunderlying reader when its Close method is called.\n\nMaxBytesReader prevents clients from accidentally or maliciously\nsending a large request and wasting server resources.\n\nGo input arguments: (w ResponseWriter, r io.ReadCloser, n int64)\n\nGo return type: io.ReadCloser\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^go.std.io/ReadCloser r, ^Number n]\n\nJoker return type: go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "__maxBytesReader(*__w, *__r, __n)"}
;;   [^http/ResponseWriter __w, ^io/ReadCloser __r, ^Int64 __n])

(defn NewFileTransport
  "NewFileTransport returns a new RoundTripper, serving the provided\nFileSystem. The returned RoundTripper ignores the URL host in its\nincoming requests, as well as most other properties of the\nrequest.\n\nThe typical use case for NewFileTransport is to register the \"file\"\nprotocol with a Transport, as in:\n\n  t := &http.Transport{}\n  t.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))\n  c := &http.Client{Transport: t}\n  res, err := c.Get(\"file:///etc/passwd\")\n  ...\n\nGo input arguments: (fs FileSystem)\n\nGo return type: RoundTripper\n\nJoker input arguments: [^go.std.net.http/FileSystem fs]\n\nJoker return type: go.std.net.http/RoundTripper"
  {:added "1.0"
   :go "__newFileTransport(*__fs)"}
  [^http/FileSystem __fs])

;; (defn NewRequest
;;   "NewRequest returns a new Request given a method, URL, and optional body.\n\nIf the provided body is also an io.Closer, the returned\nRequest.Body is set to body and will be closed by the Client\nmethods Do, Post, and PostForm, and Transport.RoundTrip.\n\nNewRequest returns a Request suitable for use with Client.Do or\nTransport.RoundTrip. To create a request for use with testing a\nServer Handler, either use the NewRequest function in the\nnet/http/httptest package, use ReadRequest, or manually update the\nRequest fields. See the Request type's documentation for the\ndifference between inbound and outbound request fields.\n\nIf body is of type *bytes.Buffer, *bytes.Reader, or\n*strings.Reader, the returned request's ContentLength is set to its\nexact value (instead of -1), GetBody is populated (so 307 and 308\nredirects can replay the body), and Body is set to NoBody if the\nContentLength is 0.\n\nGo input arguments: (method string, url string, body io.Reader)\n\nGo return type: (*Request, error)\n\nJoker input arguments: [^String method, ^String url, ^go.std.io/Reader body]\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
;;   {:added "1.0"
;;    :go "__newRequest(__method, __url, *__body)"}
;;   [^String __method, ^String __url, ^io/Reader __body])

(defn NewServeMux
  "NewServeMux allocates and returns a new ServeMux.\n\nGo return type: *ServeMux\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.net.http/ServeMux)"
  {:added "1.0"
   :go "__newServeMux()"}
  [])

;; (defn NotFound
;;   "NotFound replies to the request with an HTTP 404 not found error.\n\nGo input arguments: (w ResponseWriter, r *Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__notFound(*__w, __r)"}
;;   [^http/ResponseWriter __w, ^http/Request __r])

(defn NotFoundHandler
  "NotFoundHandler returns a simple request handler\nthat replies to each request with a ``404 page not found'' reply.\n\nGo return type: Handler\n\nJoker input arguments: []\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__notFoundHandler()"}
  [])

(defn ParseHTTPVersion
  "ParseHTTPVersion parses a HTTP version string.\n\"HTTP/1.0\" returns (1, 0, true).\n\nGo input arguments: (vers string)\n\nGo return type: (major int, minor int, ok bool)\n\nJoker input arguments: [^String vers]\n\nJoker return type: [Int Int Boolean]"
  {:added "1.0"
   :go "__parseHTTPVersion(__vers)"}
  [^String __vers])

(defn ParseTime
  "ParseTime parses a time header (such as the Date: header),\ntrying each of the three formats allowed by HTTP/1.1:\nTimeFormat, time.RFC850, and time.ANSIC.\n\nGo input arguments: (text string)\n\nGo return type: (t time.Time, err error)\n\nJoker input arguments: [^String text]\n\nJoker return type: [go.std.time/Time Error]"
  {:added "1.0"
   :go "__parseTime(__text)"}
  [^String __text])

;; (defn Post
;;   "Post issues a POST to the specified URL.\n\nCaller should close resp.Body when done reading from it.\n\nIf the provided body is an io.Closer, it is closed after the\nrequest.\n\nPost is a wrapper around DefaultClient.Post.\n\nTo set custom headers, use NewRequest and DefaultClient.Do.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, contentType string, body io.Reader)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^String contentType, ^go.std.io/Reader body]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
;;   {:added "1.0"
;;    :go "__post(__url, __contentType, *__body)"}
;;   [^String __url, ^String __contentType, ^io/Reader __body])

;; (defn PostForm
;;   "PostForm issues a POST to the specified URL, with data's keys and\nvalues URL-encoded as the request body.\n\nThe Content-Type header is set to application/x-www-form-urlencoded.\nTo set other headers, use NewRequest and DefaultClient.Do.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nPostForm is a wrapper around DefaultClient.PostForm.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, data url.Values)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^go.std.net.url/Values data]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
;;   {:added "1.0"
;;    :go "__postForm(__url, *__data)"}
;;   [^String __url, ^url/Values __data])

(defn ProxyFromEnvironment
  "ProxyFromEnvironment returns the URL of the proxy to use for a\ngiven request, as indicated by the environment variables\nHTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions\nthereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https\nrequests.\n\nThe environment values may be either a complete URL or a\n\"host[:port]\", in which case the \"http\" scheme is assumed.\nAn error is returned if the value is a different form.\n\nA nil URL and nil error are returned if no proxy is defined in the\nenvironment, or a proxy should not be used for the given request,\nas defined by NO_PROXY.\n\nAs a special case, if req.URL.Host is \"localhost\" (with or without\na port number), then a nil URL and nil error will be returned.\n\nGo input arguments: (req *Request)\n\nGo return type: (*net/url.URL, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req]\n\nJoker return type: [(atom-of go.std.net.url/URL) Error]"
  {:added "1.0"
   :go "__proxyFromEnvironment(__req)"}
  [^http/Request __req])

;; (defn ProxyURL
;;   "ProxyURL returns a proxy function (for use in a Transport)\nthat always returns the same URL.\n\nGo input arguments: (fixedURL *url.URL)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of go.std.net.url/URL) fixedURL]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.FuncType at: /usr/local/go/src/net/http/transport.go:352:34)"
;;   {:added "1.0"
;;    :go "__proxyURL(__fixedURL)"}
;;   [^url/URL __fixedURL])

;; (defn ReadRequest
;;   "ReadRequest reads and parses an incoming request from b.\n\nReadRequest is a low-level function and should only be used for\nspecialized applications; most code should use the Server to read\nrequests and handle them via the Handler interface. ReadRequest\nonly supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.\n\nGo input arguments: (b *bufio.Reader)\n\nGo return type: (*Request, error)\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) b]\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
;;   {:added "1.0"
;;    :go "__readRequest(__b)"}
;;   [^bufio/Reader __b])

;; (defn ReadResponse
;;   "ReadResponse reads and returns an HTTP response from r.\nThe req parameter optionally specifies the Request that corresponds\nto this Response. If nil, a GET request is assumed.\nClients must call resp.Body.Close when finished reading resp.Body.\nAfter that call, clients can inspect resp.Trailer to find key/value\npairs included in the response trailer.\n\nGo input arguments: (r *bufio.Reader, req *Request)\n\nGo return type: (*Response, error)\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) r, ^(atom-of go.std.net.http/Request) req]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
;;   {:added "1.0"
;;    :go "__readResponse(__r, __req)"}
;;   [^bufio/Reader __r, ^http/Request __req])

;; (defn Redirect
;;   "Redirect replies to the request with a redirect to url,\nwhich may be a path relative to the request path.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nIf the Content-Type header has not been set, Redirect sets it\nto \"text/html; charset=utf-8\" and writes a small HTML body.\nSetting the Content-Type header to any value, including nil,\ndisables that behavior.\n\nGo input arguments: (w ResponseWriter, r *Request, url string, code int)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r, ^String url, ^Int code]"
;;   {:added "1.0"
;;    :go "__redirect(*__w, __r, __url, __code)"}
;;   [^http/ResponseWriter __w, ^http/Request __r, ^String __url, ^Int __code])

(defn RedirectHandler
  "RedirectHandler returns a request handler that redirects\neach request it receives to the given url using the given\nstatus code.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nGo input arguments: (url string, code int)\n\nGo return type: Handler\n\nJoker input arguments: [^String url, ^Int code]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__redirectHandler(__url, __code)"}
  [^String __url, ^Int __code])

;; (defn ^"Error" Serve
;;   "Serve accepts incoming HTTP connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nHTTP/2 support is only enabled if the Listener returns *tls.Conn\nconnections and they were configured with \"h2\" in the TLS\nConfig.NextProtos.\n\nServe always returns a non-nil error.\n\nGo input arguments: (l net.Listener, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.Serve(*__l, *__handler)"}
;;   [^net/Listener __l, ^http/Handler __handler])

;; (defn ServeContent
;;   "ServeContent replies to the request using the content in the\nprovided ReadSeeker. The main benefit of ServeContent over io.Copy\nis that it handles Range requests properly, sets the MIME type, and\nhandles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,\nand If-Range requests.\n\nIf the response's Content-Type header is not set, ServeContent\nfirst tries to deduce the type from name's file extension and,\nif that fails, falls back to reading the first block of the content\nand passing it to DetectContentType.\nThe name is otherwise unused; in particular it can be empty and is\nnever sent in the response.\n\nIf modtime is not the zero time or Unix epoch, ServeContent\nincludes it in a Last-Modified header in the response. If the\nrequest includes an If-Modified-Since header, ServeContent uses\nmodtime to decide whether the content needs to be sent at all.\n\nThe content's Seek method must work: ServeContent uses\na seek to the end of the content to determine its size.\n\nIf the caller has set w's ETag header formatted per RFC 7232, section 2.3,\nServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.\n\nNote that *os.File implements the io.ReadSeeker interface.\n\nGo input arguments: (w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) req, ^String name, ^go.std.time/Time modtime, ^go.std.io/ReadSeeker content]"
;;   {:added "1.0"
;;    :go "__serveContent(*__w, __req, __name, *__modtime, *__content)"}
;;   [^http/ResponseWriter __w, ^http/Request __req, ^String __name, ^time/Time __modtime, ^io/ReadSeeker __content])

;; (defn ServeFile
;;   "ServeFile replies to the request with the contents of the named\nfile or directory.\n\nIf the provided file or directory name is a relative path, it is\ninterpreted relative to the current directory and may ascend to\nparent directories. If the provided name is constructed from user\ninput, it should be sanitized before calling ServeFile.\n\nAs a precaution, ServeFile will reject requests where r.URL.Path\ncontains a \"..\" path element; this protects against callers who\nmight unsafely use filepath.Join on r.URL.Path without sanitizing\nit and then use that filepath.Join result as the name argument.\n\nAs another special case, ServeFile redirects any request where r.URL.Path\nends in \"/index.html\" to the same path, without the final\n\"index.html\". To avoid such redirects either modify the path or\nuse ServeContent.\n\nOutside of those two special cases, ServeFile does not use\nr.URL.Path for selecting the file or directory to serve; only the\nfile or directory provided in the name argument is used.\n\nGo input arguments: (w ResponseWriter, r *Request, name string)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r, ^String name]"
;;   {:added "1.0"
;;    :go "__serveFile(*__w, __r, __name)"}
;;   [^http/ResponseWriter __w, ^http/Request __r, ^String __name])

;; (defn ^"Error" ServeTLS
;;   "ServeTLS accepts incoming HTTPS connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nAdditionally, files containing a certificate and matching private key\nfor the server must be provided. If the certificate is signed by a\ncertificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nServeTLS always returns a non-nil error.\n\nGo input arguments: (l net.Listener, handler Handler, certFile string, keyFile string)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler, ^String certFile, ^String keyFile]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.ServeTLS(*__l, *__handler, __certFile, __keyFile)"}
;;   [^net/Listener __l, ^http/Handler __handler, ^String __certFile, ^String __keyFile])

;; (defn SetCookie
;;   "SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.\nThe provided cookie must have a valid Name. Invalid cookies may be\nsilently dropped.\n\nGo input arguments: (w ResponseWriter, cookie *Cookie)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Cookie) cookie]"
;;   {:added "1.0"
;;    :go "__setCookie(*__w, __cookie)"}
;;   [^http/ResponseWriter __w, ^http/Cookie __cookie])

(defn ^"String" StatusText
  "StatusText returns a text for the HTTP status code. It returns the empty\nstring if the code is unknown.\n\nGo input arguments: (code int)\n\nGo return type: string\n\nJoker input arguments: [^Int code]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.StatusText(__code)"}
  [^Int __code])

(defn StripPrefix
  "StripPrefix returns a handler that serves HTTP requests\nby removing the given prefix from the request URL's Path\nand invoking the handler h. StripPrefix handles a\nrequest for a path that doesn't begin with prefix by\nreplying with an HTTP 404 not found error.\n\nGo input arguments: (prefix string, h Handler)\n\nGo return type: Handler\n\nJoker input arguments: [^String prefix, ^go.std.net.http/Handler h]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__stripPrefix(__prefix, *__h)"}
  [^String __prefix, ^http/Handler __h])

;; (defn TimeoutHandler
;;   "TimeoutHandler returns a Handler that runs h with the given time limit.\n\nThe new Handler calls h.ServeHTTP to handle each request, but if a\ncall runs for longer than its time limit, the handler responds with\na 503 Service Unavailable error and the given message in its body.\n(If msg is empty, a suitable default message will be sent.)\nAfter such a timeout, writes by h to its ResponseWriter will return\nErrHandlerTimeout.\n\nTimeoutHandler buffers all Handler writes to memory and does not\nsupport the Hijacker or Flusher interfaces.\n\nGo input arguments: (h Handler, dt time.Duration, msg string)\n\nGo return type: Handler\n\nJoker input arguments: [^go.std.net.http/Handler h, ^go.std.time/Duration dt, ^String msg]\n\nJoker return type: go.std.net.http/Handler"
;;   {:added "1.0"
;;    :go "__timeoutHandler(*__h, *__dt, __msg)"}
;;   [^http/Handler __h, ^time/Duration __dt, ^String __msg])
