// Auto-generated by gostd at 2019-09-17T13:14:28.216621211-04:00 by version 0.1, do not edit!!

package textproto

import (
	"fmt"
	. "github.com/candid82/joker/core"
	_textproto "net/textproto"
	_reflect "reflect"
)

func ExtractGoObjectConn(args []Object, index int) *_textproto.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Conn:
			return &r
		case *_textproto.Conn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Conn]"))
}

func _mapToConn(o Map) *_textproto.Conn {
	return &_textproto.Conn{}
}

func _vectorToConn(o *Vector) *_textproto.Conn {
	return &_textproto.Conn{}
}

func _ConstructConn(_v Object) *_textproto.Conn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.Conn:
			return &_g
		case *_textproto.Conn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToConn(_o.(Map))
	case *Vector:
		return _vectorToConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Conn] or: Map or Vector"))
}

func ExtractGo_go_std_net_textproto__Conn(rcvr, arg string, args *ArraySeq, n int) (res _textproto.Conn) {
	a := CheckGoNth(rcvr, "go.std.net.textproto/Conn", arg, args, n).O
	res, ok := a.(_textproto.Conn)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.textproto/Conn], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectError(args []Object, index int) *_textproto.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Error:
			return &r
		case *_textproto.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Error]"))
}

func _mapToError(o Map) *_textproto.Error {
	return &_textproto.Error{}
}

func _vectorToError(o *Vector) *_textproto.Error {
	return &_textproto.Error{
		Code: AssertInt(o.Nth(0), "").I,
		Msg: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructError(_v Object) *_textproto.Error {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.Error:
			return &_g
		case *_textproto.Error:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToError(_o.(Map))
	case *Vector:
		return _vectorToError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Error] or: Map or Vector"))
}

func ExtractGo_go_std_net_textproto__Error(rcvr, arg string, args *ArraySeq, n int) (res _textproto.Error) {
	a := CheckGoNth(rcvr, "go.std.net.textproto/Error", arg, args, n).O
	res, ok := a.(_textproto.Error)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.textproto/Error], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectMIMEHeader(args []Object, index int) *_textproto.MIMEHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.MIMEHeader:
			return &r
		case *_textproto.MIMEHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.MIMEHeader]"))
}

// func _ConstructMIMEHeader(_v Object) _textproto.MIMEHeader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _textproto.MIMEHeader:
// 			return _g
// 		case *_textproto.MIMEHeader:
// 			return *_g
// 		}
// 	default:
// 		return _textproto.MIMEHeader(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for MIMEHeader))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.MIMEHeader] or: whatever"))
// }

func ExtractGo_go_std_net_textproto__MIMEHeader(rcvr, arg string, args *ArraySeq, n int) (res _textproto.MIMEHeader) {
	a := CheckGoNth(rcvr, "go.std.net.textproto/MIMEHeader", arg, args, n).O
	res, ok := a.(_textproto.MIMEHeader)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.textproto/MIMEHeader], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectPipeline(args []Object, index int) *_textproto.Pipeline {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Pipeline:
			return &r
		case *_textproto.Pipeline:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Pipeline]"))
}

func _mapToPipeline(o Map) *_textproto.Pipeline {
	return &_textproto.Pipeline{}
}

func _vectorToPipeline(o *Vector) *_textproto.Pipeline {
	return &_textproto.Pipeline{}
}

func _ConstructPipeline(_v Object) *_textproto.Pipeline {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.Pipeline:
			return &_g
		case *_textproto.Pipeline:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPipeline(_o.(Map))
	case *Vector:
		return _vectorToPipeline(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Pipeline] or: Map or Vector"))
}

func ExtractGo_go_std_net_textproto__Pipeline(rcvr, arg string, args *ArraySeq, n int) (res _textproto.Pipeline) {
	a := CheckGoNth(rcvr, "go.std.net.textproto/Pipeline", arg, args, n).O
	res, ok := a.(_textproto.Pipeline)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.textproto/Pipeline], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectProtocolError(args []Object, index int) *_textproto.ProtocolError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.ProtocolError:
			return &r
		case *_textproto.ProtocolError:
			return r
		}
	case String:
		v := _textproto.ProtocolError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.ProtocolError]"))
}

func _ConstructProtocolError(_v Object) _textproto.ProtocolError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.ProtocolError:
			return _g
		case *_textproto.ProtocolError:
			return *_g
		}
	case String:
		return _textproto.ProtocolError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.ProtocolError] or: String"))
}

func ExtractGo_go_std_net_textproto__ProtocolError(rcvr, arg string, args *ArraySeq, n int) (res _textproto.ProtocolError) {
	a := CheckGoNth(rcvr, "go.std.net.textproto/ProtocolError", arg, args, n).O
	res, ok := a.(_textproto.ProtocolError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.textproto/ProtocolError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectReader(args []Object, index int) *_textproto.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Reader:
			return &r
		case *_textproto.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Reader]"))
}

// func _mapToReader(o Map) *_textproto.Reader {
// 	return &_textproto.Reader{}
// }

// func _vectorToReader(o *Vector) *_textproto.Reader {
// 	return &_textproto.Reader{
// 		R: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructReader(_v Object) *_textproto.Reader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _textproto.Reader:
// 			return &_g
// 		case *_textproto.Reader:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToReader(_o.(Map))
// 	case *Vector:
// 		return _vectorToReader(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Reader] or: Map or Vector"))
// }

func ExtractGo_go_std_net_textproto__Reader(rcvr, arg string, args *ArraySeq, n int) (res _textproto.Reader) {
	a := CheckGoNth(rcvr, "go.std.net.textproto/Reader", arg, args, n).O
	res, ok := a.(_textproto.Reader)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.textproto/Reader], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectWriter(args []Object, index int) *_textproto.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Writer:
			return &r
		case *_textproto.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Writer]"))
}

// func _mapToWriter(o Map) *_textproto.Writer {
// 	return &_textproto.Writer{}
// }

// func _vectorToWriter(o *Vector) *_textproto.Writer {
// 	return &_textproto.Writer{
// 		W: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructWriter(_v Object) *_textproto.Writer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _textproto.Writer:
// 			return &_g
// 		case *_textproto.Writer:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToWriter(_o.(Map))
// 	case *Vector:
// 		return _vectorToWriter(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Writer] or: Map or Vector"))
// }

func ExtractGo_go_std_net_textproto__Writer(rcvr, arg string, args *ArraySeq, n int) (res _textproto.Writer) {
	a := CheckGoNth(rcvr, "go.std.net.textproto/Writer", arg, args, n).O
	res, ok := a.(_textproto.Writer)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.textproto/Writer], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func __dial(__network string, __addr string) Object {
	_res1, _res2 := _textproto.Dial(__network, __addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// func __newConn(__conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _textproto.NewConn(__conn)
// 	return MakeGoObject(_res)
// }

// func __newReader(__r *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res := _textproto.NewReader(__r)
// 	return MakeGoObject(_res)
// }

// func __newWriter(__w *ABEND987(genutils.go: imports not yet supported: bufio.Writer)) Object {
// 	_res := _textproto.NewWriter(__w)
// 	return MakeGoObject(_res)
// }

// func __trimBytes(__b []byte) Object {
// 	_res := _textproto.TrimBytes(__b)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

// func __mIMEHeader_Add(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// func __mIMEHeader_Del(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

func __mIMEHeader_Get(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net/textproto.MIMEHeader)Get()", args, 1, 1)
	__key := ExtractGoString("(_net/textproto.MIMEHeader)Get()", "__key", _argList, 0)
	_res := o.O.(_textproto.MIMEHeader).Get(__key)
	return MakeString(_res)
}

// func __mIMEHeader_Set(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

func __protocolError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_net/textproto.ProtocolError)Error()", args, 0, 0)
	_res := o.O.(_textproto.ProtocolError).Error()
	return MakeString(_res)
}

func __ptrTo_Conn_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Conn)Close()", args, 0, 0)
	_res := o.O.(*_textproto.Conn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

// func __ptrTo_Conn_Cmd(o GoObject, args Object) Object {
// (__format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

func __ptrTo_Error_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Error)Error()", args, 0, 0)
	_res := o.O.(*_textproto.Error).Error()
	return MakeString(_res)
}

// func __ptrTo_Pipeline_EndRequest(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// func __ptrTo_Pipeline_EndResponse(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

func __ptrTo_Pipeline_Next(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Pipeline)Next()", args, 0, 0)
	_res := o.O.(*_textproto.Pipeline).Next()
	return MakeBigIntU(uint64(_res))
}

// func __ptrTo_Pipeline_StartRequest(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// func __ptrTo_Pipeline_StartResponse(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

func __ptrTo_Reader_DotReader(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)DotReader()", args, 0, 0)
	_res := o.O.(*_textproto.Reader).DotReader()
	return MakeGoObject(_res)
}

func __ptrTo_Reader_ReadCodeLine(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/textproto.Reader)ReadCodeLine()", args, 1, 1)
	__expectCode := ExtractGoInt("(*_net/textproto.Reader)ReadCodeLine()", "__expectCode", _argList, 0)
	code, message, err := o.O.(*_textproto.Reader).ReadCodeLine(__expectCode)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(code))
	_res = _res.Conjoin(MakeString(message))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

func __ptrTo_Reader_ReadContinuedLine(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)ReadContinuedLine()", args, 0, 0)
	_res1, _res2 := o.O.(*_textproto.Reader).ReadContinuedLine()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __ptrTo_Reader_ReadContinuedLineBytes(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)ReadContinuedLineBytes()", args, 0, 0)
	_res1, _res2 := o.O.(*_textproto.Reader).ReadContinuedLineBytes()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __ptrTo_Reader_ReadDotBytes(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)ReadDotBytes()", args, 0, 0)
	_res1, _res2 := o.O.(*_textproto.Reader).ReadDotBytes()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __ptrTo_Reader_ReadDotLines(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)ReadDotLines()", args, 0, 0)
	_res1, _res2 := o.O.(*_textproto.Reader).ReadDotLines()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __ptrTo_Reader_ReadLine(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)ReadLine()", args, 0, 0)
	_res1, _res2 := o.O.(*_textproto.Reader).ReadLine()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __ptrTo_Reader_ReadLineBytes(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)ReadLineBytes()", args, 0, 0)
	_res1, _res2 := o.O.(*_textproto.Reader).ReadLineBytes()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __ptrTo_Reader_ReadMIMEHeader(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)ReadMIMEHeader()", args, 0, 0)
	_res1, _res2 := o.O.(*_textproto.Reader).ReadMIMEHeader()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __ptrTo_Reader_ReadResponse(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/textproto.Reader)ReadResponse()", args, 1, 1)
	__expectCode := ExtractGoInt("(*_net/textproto.Reader)ReadResponse()", "__expectCode", _argList, 0)
	code, message, err := o.O.(*_textproto.Reader).ReadResponse(__expectCode)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(code))
	_res = _res.Conjoin(MakeString(message))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

func __ptrTo_Writer_DotWriter(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Writer)DotWriter()", args, 0, 0)
	_res := o.O.(*_textproto.Writer).DotWriter()
	return MakeGoObject(_res)
}

// func __ptrTo_Writer_PrintfLine(o GoObject, args Object) Object {
// (__format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}
var members_PtrTo_Conn GoTypeInfo
var members_PtrTo_Error GoTypeInfo
var members_MIMEHeader GoTypeInfo
var members_PtrTo_Pipeline GoTypeInfo
var members_ProtocolError GoTypeInfo
var members_PtrTo_Reader GoTypeInfo
var members_PtrTo_Writer GoTypeInfo

func initNative() {
	members_PtrTo_Conn = GoTypeInfo{Members: GoMembers{
		"Close": __ptrTo_Conn_Close,
	}}

	members_PtrTo_Error = GoTypeInfo{Members: GoMembers{
		"Error": __ptrTo_Error_Error,
	}}

	members_MIMEHeader = GoTypeInfo{Members: GoMembers{
		"Get": __mIMEHeader_Get,
	}}

	members_PtrTo_Pipeline = GoTypeInfo{Members: GoMembers{
		"Next": __ptrTo_Pipeline_Next,
	}}

	members_ProtocolError = GoTypeInfo{Members: GoMembers{
		"Error": __protocolError_Error,
	}}

	members_PtrTo_Reader = GoTypeInfo{Members: GoMembers{
		"DotReader": __ptrTo_Reader_DotReader,
		"ReadCodeLine": __ptrTo_Reader_ReadCodeLine,
		"ReadContinuedLine": __ptrTo_Reader_ReadContinuedLine,
		"ReadContinuedLineBytes": __ptrTo_Reader_ReadContinuedLineBytes,
		"ReadDotBytes": __ptrTo_Reader_ReadDotBytes,
		"ReadDotLines": __ptrTo_Reader_ReadDotLines,
		"ReadLine": __ptrTo_Reader_ReadLine,
		"ReadLineBytes": __ptrTo_Reader_ReadLineBytes,
		"ReadMIMEHeader": __ptrTo_Reader_ReadMIMEHeader,
		"ReadResponse": __ptrTo_Reader_ReadResponse,
	}}

	members_PtrTo_Writer = GoTypeInfo{Members: GoMembers{
		"DotWriter": __ptrTo_Writer_DotWriter,
	}}

	GoTypes[_reflect.TypeOf((*_textproto.Conn)(nil))] = &members_PtrTo_Conn
	GoTypes[_reflect.TypeOf((*_textproto.Error)(nil))] = &members_PtrTo_Error
	GoTypes[_reflect.TypeOf((*_textproto.MIMEHeader)(nil)).Elem()] = &members_MIMEHeader
	GoTypes[_reflect.TypeOf((*_textproto.Pipeline)(nil))] = &members_PtrTo_Pipeline
	GoTypes[_reflect.TypeOf((*_textproto.ProtocolError)(nil)).Elem()] = &members_ProtocolError
	GoTypes[_reflect.TypeOf((*_textproto.Reader)(nil))] = &members_PtrTo_Reader
	GoTypes[_reflect.TypeOf((*_textproto.Writer)(nil))] = &members_PtrTo_Writer
}
