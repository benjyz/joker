;;;; Auto-generated by gostd at 2019-09-17T13:14:28.216621211-04:00 by version 0.1, do not edit!!

(ns
  ^{:go-imports ["net/rpc"]
    :doc "Provides a low-level interface to the net/rpc package.\n\n\tPackage rpc provides access to the exported methods of an object across a\n\tnetwork or other I/O connection.  A server registers an object, making it visible\n\tas a service with the name of the type of the object.  After registration, exported\n\tmethods of the object will be accessible remotely.  A server may register multiple\n\tobjects (services) of different types but it is an error to register multiple\n\tobjects of the same type.\n\n\tOnly methods that satisfy these criteria will be made available for remote access;\n\tother methods will be ignored:\n\n\t\t- the method's type is exported.\n\t\t- the method is exported.\n\t\t- the method has two arguments, both exported (or builtin) types.\n\t\t- the method's second argument is a pointer.\n\t\t- the method has return type error.\n\n\tIn effect, the method must look schematically like\n\n\t\tfunc (t *T) MethodName(argType T1, replyType *T2) error\n\n\twhere T1 and T2 can be marshaled by encoding/gob.\n\tThese requirements apply even if a different codec is used.\n\t(In the future, these requirements may soften for custom codecs.)\n\n\tThe method's first argument represents the arguments provided by the caller; the\n\tsecond argument represents the result parameters to be returned to the caller.\n\tThe method's return value, if non-nil, is passed back as a string that the client\n\tsees as if created by errors.New.  If an error is returned, the reply parameter\n\twill not be sent back to the client.\n\n\tThe server may handle requests on a single connection by calling ServeConn.  More\n\ttypically it will create a network listener and call Accept or, for an HTTP\n\tlistener, HandleHTTP and http.Serve.\n\n\tA client wishing to use the service establishes a connection and then invokes\n\tNewClient on the connection.  The convenience function Dial (DialHTTP) performs\n\tboth steps for a raw network connection (an HTTP connection).  The resulting\n\tClient object has two methods, Call and Go, that specify the service and method to\n\tcall, a pointer containing the arguments, and a pointer to receive the result\n\tparameters.\n\n\tThe Call method waits for the remote call to complete while the Go method\n\tlaunches the call asynchronously and signals completion using the Call\n\tstructure's Done channel.\n\n\tUnless an explicit codec is set up, package encoding/gob is used to\n\ttransport the data.\n\n\tHere is a simple example.  A server wishes to export an object of type Arith:\n\n\t\tpackage server\n\n\t\timport \"errors\"\n\n\t\ttype Args struct {\n\t\t\tA, B int\n\t\t}\n\n\t\ttype Quotient struct {\n\t\t\tQuo, Rem int\n\t\t}\n\n\t\ttype Arith int\n\n\t\tfunc (t *Arith) Multiply(args *Args, reply *int) error {\n\t\t\t*reply = args.A * args.B\n\t\t\treturn nil\n\t\t}\n\n\t\tfunc (t *Arith) Divide(args *Args, quo *Quotient) error {\n\t\t\tif args.B == 0 {\n\t\t\t\treturn errors.New(\"divide by zero\")\n\t\t\t}\n\t\t\tquo.Quo = args.A / args.B\n\t\t\tquo.Rem = args.A % args.B\n\t\t\treturn nil\n\t\t}\n\n\tThe server calls (for HTTP service):\n\n\t\tarith := new(Arith)\n\t\trpc.Register(arith)\n\t\trpc.HandleHTTP()\n\t\tl, e := net.Listen(\"tcp\", \":1234\")\n\t\tif e != nil {\n\t\t\tlog.Fatal(\"listen error:\", e)\n\t\t}\n\t\tgo http.Serve(l, nil)\n\n\tAt this point, clients can see a service \"Arith\" with methods \"Arith.Multiply\" and\n\t\"Arith.Divide\".  To invoke one, a client first dials the server:\n\n\t\tclient, err := rpc.DialHTTP(\"tcp\", serverAddress + \":1234\")\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"dialing:\", err)\n\t\t}\n\n\tThen it can make a remote call:\n\n\t\t// Synchronous call\n\t\targs := &server.Args{7,8}\n\t\tvar reply int\n\t\terr = client.Call(\"Arith.Multiply\", args, &reply)\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"arith error:\", err)\n\t\t}\n\t\tfmt.Printf(\"Arith: %d*%d=%d\", args.A, args.B, reply)\n\n\tor\n\n\t\t// Asynchronous call\n\t\tquotient := new(Quotient)\n\t\tdivCall := client.Go(\"Arith.Divide\", args, quotient, nil)\n\t\treplyCall := <-divCall.Done\t// will be equal to divCall\n\t\t// check errors, print, etc.\n\n\tA server implementation will often provide a simple, type-safe wrapper for the\n\tclient.\n\n\tThe net/rpc package is frozen and is not accepting new features.\n"
    :empty false}
  go.std.net.rpc)

(def
  ^{:doc ""
    :added "1.0"
    :tag String
    :go "rpc.DefaultDebugPath"}
  DefaultDebugPath)

(def
  ^{:doc "Defaults used by HandleHTTP\n"
    :added "1.0"
    :tag String
    :go "rpc.DefaultRPCPath"}
  DefaultRPCPath)

(def
  ^{:doc "DefaultServer is the default instance of *Server.\n"
    :added "1.0"
    :tag Var
    :go "rpc.DefaultServer"}
  DefaultServer)

(def
  ^{:doc ""
    :added "1.0"
    :tag Var
    :go "rpc.ErrShutdown"}
  ErrShutdown)

;; (defn ^"GoObject" Call.
;;   "Constructor for rpc.Call"
;;   {:added "1.0"
;;    :go "_ConstructCall(_v)"}
;;   [^Object _v])

(defn ^"GoObject" Client.
  "Constructor for rpc.Client"
  {:added "1.0"
   :go "_ConstructClient(_v)"}
  [^Object _v])

;; (defn ^"GoObject" ClientCodec.
;;   "Constructor for rpc.ClientCodec"
;;   {:added "1.0"
;;    :go "_ConstructClientCodec(_v)"}
;;   [^Object _v])

(defn ^"GoObject" Request.
  "Constructor for rpc.Request"
  {:added "1.0"
   :go "_ConstructRequest(_v)"}
  [^Object _v])

(defn ^"GoObject" Response.
  "Constructor for rpc.Response"
  {:added "1.0"
   :go "_ConstructResponse(_v)"}
  [^Object _v])

(defn ^"GoObject" Server.
  "Constructor for rpc.Server"
  {:added "1.0"
   :go "_ConstructServer(_v)"}
  [^Object _v])

;; (defn ^"GoObject" ServerCodec.
;;   "Constructor for rpc.ServerCodec"
;;   {:added "1.0"
;;    :go "_ConstructServerCodec(_v)"}
;;   [^Object _v])

(defn ^"GoObject" ServerError.
  "Constructor for rpc.ServerError"
  {:added "1.0"
   :go "_ConstructServerError(_v)"}
  [^Object _v])

;; (defn Accept
;;   "Accept accepts connections on the listener and serves requests\nto DefaultServer for each incoming connection.\nAccept blocks; the caller typically invokes it in a go statement.\n\nGo input arguments: (lis net.Listener)\n\nJoker input arguments: [^go.std.net/Listener lis]"
;;   {:added "1.0"
;;    :go "__accept(*__lis)"}
;;   [^net/Listener __lis])

(defn Dial
  "Dial connects to an RPC server at the specified network address.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dial(__network, __address)"}
  [^String __network, ^String __address])

(defn DialHTTP
  "DialHTTP connects to an HTTP RPC server at the specified network address\nlistening on the default HTTP RPC path.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dialHTTP(__network, __address)"}
  [^String __network, ^String __address])

(defn DialHTTPPath
  "DialHTTPPath connects to an HTTP RPC server\nat the specified network address and path.\n\nGo input arguments: (network string, address string, path string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address, ^String path]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dialHTTPPath(__network, __address, __path)"}
  [^String __network, ^String __address, ^String __path])

;; (defn HandleHTTP
;;   "HandleHTTP registers an HTTP handler for RPC messages to DefaultServer\non DefaultRPCPath and a debugging handler on DefaultDebugPath.\nIt is still necessary to invoke http.Serve(), typically in a go statement.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__handleHTTP()"}
;;   [])

;; (defn NewClient
;;   "NewClient returns a new Client to handle requests to the\nset of services at the other end of the connection.\nIt adds a buffer to the write side of the connection so\nthe header and payload are sent as a unit.\n\nThe read and write halves of the connection are serialized independently,\nso no interlocking is required. However each half may be accessed\nconcurrently so the implementation of conn should protect against\nconcurrent reads or concurrent writes.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *Client\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: (atom-of go.std.net.rpc/Client)"
;;   {:added "1.0"
;;    :go "__newClient(*__conn)"}
;;   [^io/ReadWriteCloser __conn])

(defn NewClientWithCodec
  "NewClientWithCodec is like NewClient but uses the specified\ncodec to encode requests and decode responses.\n\nGo input arguments: (codec ClientCodec)\n\nGo return type: *Client\n\nJoker input arguments: [^go.std.net.rpc/ClientCodec codec]\n\nJoker return type: (atom-of go.std.net.rpc/Client)"
  {:added "1.0"
   :go "__newClientWithCodec(*__codec)"}
  [^rpc/ClientCodec __codec])

(defn NewServer
  "NewServer returns a new Server.\n\nGo return type: *Server\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.net.rpc/Server)"
  {:added "1.0"
   :go "__newServer()"}
  [])

;; (defn ^"Error" Register
;;   "Register publishes the receiver's methods in the DefaultServer.\n\nGo input arguments: (rcvr interface {})\n\nGo return type: error\n\nJoker input arguments: [^<protocol-or-something> rcvr]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.Register(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> __rcvr])

;; (defn ^"Error" RegisterName
;;   "RegisterName is like Register but uses the provided name for the type\ninstead of the receiver's concrete type.\n\nGo input arguments: (name string, rcvr interface {})\n\nGo return type: error\n\nJoker input arguments: [^String name, ^<protocol-or-something> rcvr]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.RegisterName(__name, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^String __name, ^<protocol-or-something> __rcvr])

;; (defn ServeCodec
;;   "ServeCodec is like ServeConn but uses the specified codec to\ndecode requests and encode responses.\n\nGo input arguments: (codec ServerCodec)\n\nJoker input arguments: [^go.std.net.rpc/ServerCodec codec]"
;;   {:added "1.0"
;;    :go "__serveCodec(*__codec)"}
;;   [^rpc/ServerCodec __codec])

;; (defn ServeConn
;;   "ServeConn runs the DefaultServer on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\nServeConn uses the gob wire format (see package gob) on the\nconnection. To use an alternate codec, use ServeCodec.\nSee NewClient's comment for information about concurrent access.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]"
;;   {:added "1.0"
;;    :go "__serveConn(*__conn)"}
;;   [^io/ReadWriteCloser __conn])

(defn ^"Error" ServeRequest
  "ServeRequest is like ServeCodec but synchronously serves a single request.\nIt does not close the codec upon completion.\n\nGo input arguments: (codec ServerCodec)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net.rpc/ServerCodec codec]\n\nJoker return type: Error"
  {:added "1.0"
   :go "rpc.ServeRequest(*__codec)"}
  [^rpc/ServerCodec __codec])
