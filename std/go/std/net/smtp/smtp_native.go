// Auto-generated by gostd at 2019-09-17T13:14:28.216621211-04:00 by version 0.1, do not edit!!

package smtp

import (
	"fmt"
	. "github.com/candid82/joker/core"
	_smtp "net/smtp"
	_reflect "reflect"
)

func ExtractGoObjectAuth(args []Object, index int) *_smtp.Auth {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _smtp.Auth:
			return &r
		case *_smtp.Auth:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/smtp.Auth]"))
}

// func _ConstructAuth(_v Object) _smtp.Auth {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _smtp.Auth:
// 			return _g
// 		case *_smtp.Auth:
// 			return *_g
// 		}
// 	default:
// 		return _smtp.Auth(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Auth))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[smtp.Auth] or: whatever"))
// }

func ExtractGo_go_std_net_smtp__Auth(rcvr, arg string, args *ArraySeq, n int) (res _smtp.Auth) {
	a := CheckGoNth(rcvr, "go.std.net.smtp/Auth", arg, args, n).O
	res, ok := a.(_smtp.Auth)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.smtp/Auth], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectClient(args []Object, index int) *_smtp.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _smtp.Client:
			return &r
		case *_smtp.Client:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/smtp.Client]"))
}

// func _mapToClient(o Map) *_smtp.Client {
// 	return &_smtp.Client{}
// }

// func _vectorToClient(o *Vector) *_smtp.Client {
// 	return &_smtp.Client{
// 		Text: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructClient(_v Object) *_smtp.Client {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _smtp.Client:
// 			return &_g
// 		case *_smtp.Client:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToClient(_o.(Map))
// 	case *Vector:
// 		return _vectorToClient(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[smtp.Client] or: Map or Vector"))
// }

func ExtractGo_go_std_net_smtp__Client(rcvr, arg string, args *ArraySeq, n int) (res _smtp.Client) {
	a := CheckGoNth(rcvr, "go.std.net.smtp/Client", arg, args, n).O
	res, ok := a.(_smtp.Client)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.smtp/Client], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func ExtractGoObjectServerInfo(args []Object, index int) *_smtp.ServerInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _smtp.ServerInfo:
			return &r
		case *_smtp.ServerInfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/smtp.ServerInfo]"))
}

// func _mapToServerInfo(o Map) *_smtp.ServerInfo {
// 	return &_smtp.ServerInfo{}
// }

// func _vectorToServerInfo(o *Vector) *_smtp.ServerInfo {
// 	return &_smtp.ServerInfo{
// 		Name: AssertString(o.Nth(0), "").S,
// 		TLS: ToBool(o.Nth(1)),
// 		Auth: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 	}
// }

// func _ConstructServerInfo(_v Object) *_smtp.ServerInfo {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _smtp.ServerInfo:
// 			return &_g
// 		case *_smtp.ServerInfo:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToServerInfo(_o.(Map))
// 	case *Vector:
// 		return _vectorToServerInfo(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[smtp.ServerInfo] or: Map or Vector"))
// }

func ExtractGo_go_std_net_smtp__ServerInfo(rcvr, arg string, args *ArraySeq, n int) (res _smtp.ServerInfo) {
	a := CheckGoNth(rcvr, "go.std.net.smtp/ServerInfo", arg, args, n).O
	res, ok := a.(_smtp.ServerInfo)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.smtp/ServerInfo], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

func __cRAMMD5Auth(__username string, __secret string) Object {
	_res := _smtp.CRAMMD5Auth(__username, __secret)
	return MakeGoObject(_res)
}

func __dial(__addr string) Object {
	_res1, _res2 := _smtp.Dial(__addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// func __newClient(__conn ABEND987(genutils.go: imports not yet supported: net.Conn), __host string) Object {
// 	_res1, _res2 := _smtp.NewClient(__conn, __host)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

func __plainAuth(__identity string, __username string, __password string, __host string) Object {
	_res := _smtp.PlainAuth(__identity, __username, __password, __host)
	return MakeGoObject(_res)
}

// func __sendMail(__addr string, __a _smtp.Auth, __from string, __to []string, __msg []byte)  {
// 	_res := _smtp.SendMail(__addr, __a, __from, __to, __msg)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

func __ptrTo_Client_Auth(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/smtp.Client)Auth()", args, 1, 1)
	__a := ExtractGo_go_std_net_smtp__Auth("(*_net/smtp.Client)Auth()", "__a", _argList, 0)
	_res := o.O.(*_smtp.Client).Auth(__a)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

func __ptrTo_Client_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net/smtp.Client)Close()", args, 0, 0)
	_res := o.O.(*_smtp.Client).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

func __ptrTo_Client_Data(o GoObject, args Object) Object {
	CheckGoArity("(*_net/smtp.Client)Data()", args, 0, 0)
	_res1, _res2 := o.O.(*_smtp.Client).Data()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

func __ptrTo_Client_Extension(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/smtp.Client)Extension()", args, 1, 1)
	__ext := ExtractGoString("(*_net/smtp.Client)Extension()", "__ext", _argList, 0)
	_res1, _res2 := o.O.(*_smtp.Client).Extension(__ext)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBoolean(_res1))
	_res = _res.Conjoin(MakeString(_res2))
	return _res
}

func __ptrTo_Client_Hello(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/smtp.Client)Hello()", args, 1, 1)
	__localName := ExtractGoString("(*_net/smtp.Client)Hello()", "__localName", _argList, 0)
	_res := o.O.(*_smtp.Client).Hello(__localName)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

func __ptrTo_Client_Mail(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/smtp.Client)Mail()", args, 1, 1)
	__from := ExtractGoString("(*_net/smtp.Client)Mail()", "__from", _argList, 0)
	_res := o.O.(*_smtp.Client).Mail(__from)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

func __ptrTo_Client_Noop(o GoObject, args Object) Object {
	CheckGoArity("(*_net/smtp.Client)Noop()", args, 0, 0)
	_res := o.O.(*_smtp.Client).Noop()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

func __ptrTo_Client_Quit(o GoObject, args Object) Object {
	CheckGoArity("(*_net/smtp.Client)Quit()", args, 0, 0)
	_res := o.O.(*_smtp.Client).Quit()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

func __ptrTo_Client_Rcpt(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/smtp.Client)Rcpt()", args, 1, 1)
	__to := ExtractGoString("(*_net/smtp.Client)Rcpt()", "__to", _argList, 0)
	_res := o.O.(*_smtp.Client).Rcpt(__to)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

func __ptrTo_Client_Reset(o GoObject, args Object) Object {
	CheckGoArity("(*_net/smtp.Client)Reset()", args, 0, 0)
	_res := o.O.(*_smtp.Client).Reset()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

// func __ptrTo_Client_StartTLS(o GoObject, args Object) Object {
// __config *ABEND987(genutils.go: imports not yet supported: tls.Config)}

func __ptrTo_Client_TLSConnectionState(o GoObject, args Object) Object {
	CheckGoArity("(*_net/smtp.Client)TLSConnectionState()", args, 0, 0)
	state, ok := o.O.(*_smtp.Client).TLSConnectionState()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(state))
	_res = _res.Conjoin(MakeBoolean(ok))
	return _res
}

func __ptrTo_Client_Verify(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/smtp.Client)Verify()", args, 1, 1)
	__addr := ExtractGoString("(*_net/smtp.Client)Verify()", "__addr", _argList, 0)
	_res := o.O.(*_smtp.Client).Verify(__addr)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}
var members_PtrTo_Client GoTypeInfo

func initNative() {
	members_PtrTo_Client = GoTypeInfo{Members: GoMembers{
		"Auth": __ptrTo_Client_Auth,
		"Close": __ptrTo_Client_Close,
		"Data": __ptrTo_Client_Data,
		"Extension": __ptrTo_Client_Extension,
		"Hello": __ptrTo_Client_Hello,
		"Mail": __ptrTo_Client_Mail,
		"Noop": __ptrTo_Client_Noop,
		"Quit": __ptrTo_Client_Quit,
		"Rcpt": __ptrTo_Client_Rcpt,
		"Reset": __ptrTo_Client_Reset,
		"TLSConnectionState": __ptrTo_Client_TLSConnectionState,
		"Verify": __ptrTo_Client_Verify,
	}}

	GoTypes[_reflect.TypeOf((*_smtp.Client)(nil))] = &members_PtrTo_Client
}
