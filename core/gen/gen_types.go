package main

import (
	"fmt"
	"os"
	"strings"
	"text/template"
)

type (
	TypeInfo struct {
		GoName   string // Form usable within a Go variable/function name
		ShowName string // What is shown to the user
		RealName string // The real name (e.g. "*Foo", when GoName and ShowName are "Foo")
		Nilable  bool   // Whether "nil" is valid for the type (else use "{{.RealName}}{}")
	}
)

var header string = `// Generated by gen_types. Don't modify manually!

package core
`

var importFmt string = `
import (
	"io"
)
`

var maybeIsTemplate string = `
func MaybeIs{{.GoName}}(obj Object) ({{.RealName}}, string) {
	if res, yes := obj.({{.RealName}}); yes {
		return res, ""
	}
	return {{if .Nilable}}nil{{else}}{{.RealName}}{}{{end}}, "{{.ShowName}}"
}
`

var ensureObjectIsTemplate string = `
func EnsureObjectIs{{.GoName}}(obj Object, pattern string) {{.RealName}} {
	res, sb := MaybeIs{{.GoName}}(obj)
	if sb == "" {
		return res
	}
	panic(FailObject(obj, sb, pattern))
}
`

var ensureArgIsTemplate string = `
func EnsureArgIs{{.GoName}}(args []Object, index int) {{.RealName}} {
	obj := args[index]
	res, sb := MaybeIs{{.GoName}}(obj)
	if sb == "" {
		return res
	}
	panic(FailArg(obj, sb, index))
}
`

var infoTemplate string = `
func (x {{.RealName}}) WithInfo(info *ObjectInfo) Object {
	x.info = info
	return x
}
`

func checkError(err error) {
	if err != nil {
		panic(err)
	}
}

// For a given type, the prefix "*" indicates a reference type; the
// prefix "." an abstract (interface{}) type.
func generateAssertions(types []string) {
	filename := "types_assert_gen.go"
	f, err := os.Create(filename)
	checkError(err)
	defer f.Close()

	var maybeIs = template.Must(template.New("maybe").Parse(maybeIsTemplate))
	var ensureObjectIs = template.Must(template.New("assert").Parse(ensureObjectIsTemplate))
	var ensureArgIs = template.Must(template.New("ensure").Parse(ensureArgIsTemplate))
	f.WriteString(header)
	f.WriteString(importFmt)
	for _, t := range types {
		realName := t
		nilable := false
		switch t[0] {
		case '*':
			t = t[1:]
			nilable = true
		case '.': // denotes abstract type (interface{}), which is Nilable
			t = t[1:]
			realName = t
			nilable = true
		}
		typeInfo := TypeInfo{
			GoName:   strings.ReplaceAll(t, ".", "_"),
			ShowName: t,
			RealName: realName,
			Nilable:  nilable,
		}
		maybeIs.Execute(f, typeInfo)
		ensureObjectIs.Execute(f, typeInfo)
		ensureArgIs.Execute(f, typeInfo)
	}
}

func generateInfo(types []string) {
	filename := "types_info_gen.go"
	f, err := os.Create(filename)
	checkError(err)
	defer f.Close()

	var info = template.Must(template.New("info").Parse(infoTemplate))

	f.WriteString(header)
	for _, t := range types {
		typeInfo := TypeInfo{
			GoName:   t,
			RealName: t,
		}
		if t[0] == '*' {
			typeInfo.GoName = t[1:]
		}
		info.Execute(f, typeInfo)
	}
}

func main() {
	cmd := os.Args[1]
	switch cmd {
	case "assert":
		generateAssertions(os.Args[2:])
	case "info":
		generateInfo(os.Args[2:])
	default:
		fmt.Println("Unknown command: ", cmd)
	}
}
